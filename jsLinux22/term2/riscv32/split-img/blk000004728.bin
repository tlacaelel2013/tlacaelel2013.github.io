if

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  inline long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  inline long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  inline long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  inline long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  inline long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }
#endif

  template<typename _Tp, typename _Up, typename _Vp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  inline long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  inline long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  inline long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__y), __type(__x));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  inline int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  inline long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  inline long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  inline long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  inline long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }

  // DR 568.
#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  log2(float __x)
  { return __builtin_log2f(__x); }

  inline long double
  log2(long double __x)
  { return __builtin_log2l(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  logb(float __x)
  { return __builtin_logbf(__x); }

  inline long double
  logb(long double __x)
  { return __builtin_logbl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    logb(_Tp __x)
    {
      return __builtin_logb(__x);
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  inline long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  inline long
  lround(long double __x)
  { return __builtin_lroundl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  inline long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  inline long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  inline long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  inline long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  rint(float __x)
  { return __builtin_rintf(__x); }

  inline long double
  rint(long double __x)
  { return __builtin_rintl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  round(float __x)
  { return __builtin_roundf(__x); }

  inline long double
  round(long double __x)
  { return __builtin_roundl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  inline long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }
 
#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  inline long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  inline long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }
 
#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  inline long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value, 
					   double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }

#endif // __cplusplus < 201103L

  /// @}

#endif /* _GLIBCXX_USE_C99_MATH_TR1 */

  // DR 550. What should the return type of pow(float,int) be?
  // NB: C++11 and TR1 != C++03.

  // We cannot do "using std::pow;" because that would bring in unwanted
  // pow(*, int) overloads in C++03, with the wrong return type. Instead we
  // define all the necessary overloads, but the std::tr1::pow(double, double)
  // overload cannot be provided here, because <tr1/math.h> would add it to
  // the global namespace where it would clash with ::pow(double,double) from
  // libc (revealed by the fix of PR c++/54537).
  // The solution is to forward std::tr1::pow(double,double) to
  // std::pow(double,double) via the function template below. See
  // the discussion about this issue here:
  // http://gcc.gnu.org/ml/gcc-patches/2012-09/msg01278.html

#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  pow(float __x, float __y)
  { return std::pow(__x, __y); }

  inline long double
  pow(long double __x, long double __y)
  { return std::pow(__x, __y); }
#endif

  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), __type(__y));
    }

#if __cplusplus >= 201103L
  // We also deal with fabs in a special way, because "using std::fabs;"
  // could bring in C++11's std::fabs<T>(const std::complex<T>&) with a
  // different return type from std::tr1::fabs<T>(const std::complex<T>&).
  // We define the necessary overloads, except std::tr1::fabs(double) which
  // could clash with ::fabs(double) from libc.
  // The function template handles double as well as integers, forwarding
  // to std::fabs.

#ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
#ifndef __CORRECT_ISO_CPP11_MATH_H_PROTO_FP
  inline float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }
#endif
#endif

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    fabs(_Tp __x)
    { return std::fabs(__x); }

#else  // ! C++11

  // For C++03 just use std::fabs as there is no overload for std::complex<>.
  using std::fabs;

#endif // C++11

#if _GLIBCXX_USE_STD_SPEC_FUNCS

  /**
   * @defgroup tr1_math_spec_func Mathematical Special Functions
   * @ingroup numerics
   *
   * A collection of advanced mathematical special functions.
   * @{
   */

  using std::assoc_laguerref;
  using std::assoc_laguerrel;
  using std::assoc_laguerre;

  using std::assoc_legendref;
  using std::assoc_legendrel;
  using std::assoc_legendre;

  using std::betaf;
  using std::betal;
  using std::beta;

  using std::comp_ellint_1f;
  using std::comp_ellint_1l;
  using std::comp_ellint_1;

  using std::comp_ellint_2f;
  using std::comp_ellint_2l;
  using std::comp_ellint_2;

  using std::comp_ellint_3f;
  using std::comp_ellint_3l;
  using std::comp_ellint_3;

  using std::cyl_bessel_if;
  using std::cyl_bessel_il;
  using std::cyl_bessel_i;

  using std::cyl_bessel_jf;
  using std::cyl_bessel_jl;
  using std::cyl_bessel_j;

  using std::cyl_bessel_kf;
  using std::cyl_bessel_kl;
  using std::cyl_bessel_k;

  using std::cyl_neumannf;
  using std::cyl_neumannl;
  using std::cyl_neumann;

  using std::ellint_1f;
  using std::ellint_1l;
  using std::ellint_1;

  using std::ellint_2f;
  using std::ellint_2l;
  using std::ellint_2;

  using std::ellint_3f;
  using std::ellint_3l;
  using std::ellint_3;

  using std::expintf;
  using std::expintl;
  using std::expint;

  using std::hermitef;
  using std::hermitel;
  using std::hermite;

  using std::laguerref;
  using std::laguerrel;
  using std::laguerre;

  using std::legendref;
  using std::legendrel;
  using std::legendre;

  using std::riemann_zetaf;
  using std::riemann_zetal;
  using std::riemann_zeta;

  using std::sph_besself;
  using std::sph_bessell;
  using std::sph_bessel;

  using std::sph_legendref;
  using std::sph_legendrel;
  using std::sph_legendre;

  using std::sph_neumannf;
  using std::sph_neumannl;
  using std::sph_neumann;

  /** @} */ // tr1_math_spec_func

#else // ! _GLIBCXX_USE_STD_SPEC_FUNCS

} // namespace tr1

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#include <bits/stl_algobase.h>
#include <limits>
#include <tr1/type_traits>

#include <tr1/gamma.tcc>
#include <tr1/bessel_function.tcc>
#include <tr1/beta_function.tcc>
#include <tr1/ell_integral.tcc>
#include <tr1/exp_integral.tcc>
#include <tr1/legendre_function.tcc>
#include <tr1/modified_bessel_func.tcc>
#include <tr1/poly_hermite.tcc>
#include <tr1/poly_laguerre.tcc>
#include <tr1/riemann_zeta.tcc>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

namespace tr1
{
  /**
   * @defgroup tr1_math_spec_func Mathematical Special Functions
   * @ingroup numerics
   *
   * A collection of advanced mathematical special functions.
   * @{
   */

  inline float
  assoc_laguerref(unsigned int __n, unsigned int __m, float __x)
  { return __detail::__assoc_laguerre<float>(__n, __m, __x); }

  inline long double
  assoc_laguerrel(unsigned int __n, unsigned int __m, long double __x)
  {
    return __detail::__assoc_laguerre<long double>(__n, __m, __x);
  }

  ///  5.2.1.1  Associated Laguerre polynomials.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_laguerre(unsigned int __n, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_laguerre<__type>(__n, __m, __x);
    }

  inline float
  assoc_legendref(unsigned int __l, unsigned int __m, float __x)
  { return __detail::__assoc_legendre_p<float>(__l, __m, __x); }

  inline long double
  assoc_legendrel(unsigned int __l, unsigned int __m, long double __x)
  { return __detail::__assoc_legendre_p<long double>(__l, __m, __x); }

  ///  5.2.1.2  Associated Legendre functions.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    assoc_legendre(unsigned int __l, unsigned int __m, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__assoc_legendre_p<__type>(__l, __m, __x);
    }

  inline float
  betaf(float __x, float __y)
  { return __detail::__beta<float>(__x, __y); }

  inline long double
  betal(long double __x, long double __y)
  { return __detail::__beta<long double>(__x, __y); }

  ///  5.2.1.3  Beta functions.
  template<typename _Tpx, typename _Tpy>
    inline typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type
    beta(_Tpx __x, _Tpy __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpx, _Tpy>::__type __type;
      return __detail::__beta<__type>(__x, __y);
    }

  inline float
  comp_ellint_1f(float __k)
  { return __detail::__comp_ellint_1<float>(__k); }

  inline long double
  comp_ellint_1l(long double __k)
  { return __detail::__comp_ellint_1<long double>(__k); }

  ///  5.2.1.4  Complete elliptic integrals of the first kind.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_1(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_1<__type>(__k);
    }

  inline float
  comp_ellint_2f(float __k)
  { return __detail::__comp_ellint_2<float>(__k); }

  inline long double
  comp_ellint_2l(long double __k)
  { return __detail::__comp_ellint_2<long double>(__k); }

  ///  5.2.1.5  Complete elliptic integrals of the second kind.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    comp_ellint_2(_Tp __k)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__comp_ellint_2<__type>(__k);
    }

  inline float
  comp_ellint_3f(float __k, float __nu)
  { return __detail::__comp_ellint_3<float>(__k, __nu); }

  inline long double
  comp_ellint_3l(long double __k, long double __nu)
  { return __detail::__comp_ellint_3<long double>(__k, __nu); }

  ///  5.2.1.6  Complete elliptic integrals of the third kind.
  template<typename _Tp, typename _Tpn>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type
    comp_ellint_3(_Tp __k, _Tpn __nu)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpn>::__type __type;
      return __detail::__comp_ellint_3<__type>(__k, __nu);
    }

  inline float
  cyl_bessel_if(float __nu, float __x)
  { return __detail::__cyl_bessel_i<float>(__nu, __x); }

  inline long double
  cyl_bessel_il(long double __nu, long double __x)
  { return __detail::__cyl_bessel_i<long double>(__nu, __x); }

  ///  5.2.1.8  Regular modified cylindrical Bessel functions.
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_i(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_i<__type>(__nu, __x);
    }

  inline float
  cyl_bessel_jf(float __nu, float __x)
  { return __detail::__cyl_bessel_j<float>(__nu, __x); }

  inline long double
  cyl_bessel_jl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_j<long double>(__nu, __x); }

  ///  5.2.1.9  Cylindrical Bessel functions (of the first kind).
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_j(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_j<__type>(__nu, __x);
    }

  inline float
  cyl_bessel_kf(float __nu, float __x)
  { return __detail::__cyl_bessel_k<float>(__nu, __x); }

  inline long double
  cyl_bessel_kl(long double __nu, long double __x)
  { return __detail::__cyl_bessel_k<long double>(__nu, __x); }

  ///  5.2.1.10  Irregular modified cylindrical Bessel functions.
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_bessel_k(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_bessel_k<__type>(__nu, __x);
    }

  inline float
  cyl_neumannf(float __nu, float __x)
  { return __detail::__cyl_neumann_n<float>(__nu, __x); }

  inline long double
  cyl_neumannl(long double __nu, long double __x)
  { return __detail::__cyl_neumann_n<long double>(__nu, __x); }

  ///  5.2.1.11  Cylindrical Neumann functions.
  template<typename _Tpnu, typename _Tp>
    inline typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type
    cyl_neumann(_Tpnu __nu, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tpnu, _Tp>::__type __type;
      return __detail::__cyl_neumann_n<__type>(__nu, __x);
    }

  inline float
  ellint_1f(float __k, float __phi)
  { return __detail::__ellint_1<float>(__k, __phi); }

  inline long double
  ellint_1l(long double __k, long double __phi)
  { return __detail::__ellint_1<long double>(__k, __phi); }

  ///  5.2.1.12  Incomplete elliptic integrals of the first kind.
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_1(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_1<__type>(__k, __phi);
    }

  inline float
  ellint_2f(float __k, float __phi)
  { return __detail::__ellint_2<float>(__k, __phi); }

  inline long double
  ellint_2l(long double __k, long double __phi)
  { return __detail::__ellint_2<long double>(__k, __phi); }

  ///  5.2.1.13  Incomplete elliptic integrals of the second kind.
  template<typename _Tp, typename _Tpp>
    inline typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type
    ellint_2(_Tp __k, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Tpp>::__type __type;
      return __detail::__ellint_2<__type>(__k, __phi);
    }

  inline float
  ellint_3f(float __k, float __nu, float __phi)
  { return __detail::__ellint_3<float>(__k, __nu, __phi); }

  inline long double
  ellint_3l(long double __k, long double __nu, long double __phi)
  { return __detail::__ellint_3<long double>(__k, __nu, __phi); }

  ///  5.2.1.14  Incomplete elliptic integrals of the third kind.
  template<typename _Tp, typename _Tpn, typename _Tpp>
    inline typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type
    ellint_3(_Tp __k, _Tpn __nu, _Tpp __phi)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Tpn, _Tpp>::__type __type;
      return __detail::__ellint_3<__type>(__k, __nu, __phi);
    }

  inline float
  expintf(float __x)
  { return __detail::__expint<float>(__x); }

  inline long double
  expintl(long double __x)
  { return __detail::__expint<long double>(__x); }

  ///  5.2.1.15  Exponential integrals.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    expint(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__expint<__type>(__x);
    }

  inline float
  hermitef(unsigned int __n, float __x)
  { return __detail::__poly_hermite<float>(__n, __x); }

  inline long double
  hermitel(unsigned int __n, long double __x)
  { return __detail::__poly_hermite<long double>(__n, __x); }

  ///  5.2.1.16  Hermite polynomials.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    hermite(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_hermite<__type>(__n, __x);
    }

  inline float
  laguerref(unsigned int __n, float __x)
  { return __detail::__laguerre<float>(__n, __x); }

  inline long double
  laguerrel(unsigned int __n, long double __x)
  { return __detail::__laguerre<long double>(__n, __x); }

  ///  5.2.1.18  Laguerre polynomials.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    laguerre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__laguerre<__type>(__n, __x);
    }

  inline float
  legendref(unsigned int __n, float __x)
  { return __detail::__poly_legendre_p<float>(__n, __x); }

  inline long double
  legendrel(unsigned int __n, long double __x)
  { return __detail::__poly_legendre_p<long double>(__n, __x); }

  ///  5.2.1.19  Legendre polynomials.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    legendre(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__poly_legendre_p<__type>(__n, __x);
    }

  inline float
  riemann_zetaf(float __x)
  { return __detail::__riemann_zeta<float>(__x); }

  inline long double
  riemann_zetal(long double __x)
  { return __detail::__riemann_zeta<long double>(__x); }

  ///  5.2.1.20  Riemann zeta function.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    riemann_zeta(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__riemann_zeta<__type>(__x);
    }

  inline float
  sph_besself(unsigned int __n, float __x)
  { return __detail::__sph_bessel<float>(__n, __x); }

  inline long double
  sph_bessell(unsigned int __n, long double __x)
  { return __detail::__sph_bessel<long double>(__n, __x); }

  ///  5.2.1.21  Spherical Bessel functions.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_bessel(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_bessel<__type>(__n, __x);
    }

  inline float
  sph_legendref(unsigned int __l, unsigned int __m, float __theta)
  { return __detail::__sph_legendre<float>(__l, __m, __theta); }

  inline long double
  sph_legendrel(unsigned int __l, unsigned int __m, long double __theta)
  { return __detail::__sph_legendre<long double>(__l, __m, __theta); }

  ///  5.2.1.22  Spherical associated Legendre functions.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_legendre(unsigned int __l, unsigned int __m, _Tp __theta)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_legendre<__type>(__l, __m, __theta);
    }

  inline float
  sph_neumannf(unsigned int __n, float __x)
  { return __detail::__sph_neumann<float>(__n, __x); }

  inline long double
  sph_neumannl(unsigned int __n, long double __x)
  { return __detail::__sph_neumann<long double>(__n, __x); }

  ///  5.2.1.23  Spherical Neumann functions.
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    sph_neumann(unsigned int __n, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __detail::__sph_neumann<__type>(__n, __x);
    }

  /** @} */ // tr1_math_spec_func
#endif // _GLIBCXX_USE_STD_SPEC_FUNCS

} // namespace tr1

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#if _GLIBCXX_USE_STD_SPEC_FUNCS && !defined(__STRICT_ANSI__)
namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

namespace tr1
{
  using __gnu_cxx::conf_hypergf;
  using __gnu_cxx::conf_hypergl;
  using __gnu_cxx::conf_hyperg;

  using __gnu_cxx::hypergf;
  using __gnu_cxx::hypergl;
  using __gnu_cxx::hyperg;
} // namespace tr1

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#else // ! (_GLIBCXX_USE_STD_SPEC_FUNCS && !defined(__STRICT_ANSI__))

#include <bits/stl_algobase.h>
#include <limits>
#include <tr1/type_traits>

#include <tr1/hypergeometric.tcc>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

namespace tr1
{
  inline float
  conf_hypergf(float __a, float __c, float __x)
  { return __detail::__conf_hyperg<float>(__a, __c, __x); }

  inline long double
  conf_hypergl(long double __a, long double __c, long double __x)
  { return __detail::__conf_hyperg<long double>(__a, __c, __x); }

  ///  5.2.1.7  Confluent hypergeometric functions.
  template<typename _Tpa, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type
    conf_hyperg(_Tpa __a, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_3<_Tpa, _Tpc, _Tp>::__type __type;
      return __detail::__conf_hyperg<__type>(__a, __c, __x);
    }

  inline float
  hypergf(float __a, float __b, float __c, float __x)
  { return __detail::__hyperg<float>(__a, __b, __c, __x); }

  inline long double
  hypergl(long double __a, long double __b, long double __c, long double __x)
  { return __detail::__hyperg<long double>(__a, __b, __c, __x); }

  ///  5.2.1.17  Hypergeometric functions.
  template<typename _Tpa, typename _Tpb, typename _Tpc, typename _Tp>
    inline typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type
    hyperg(_Tpa __a, _Tpb __b, _Tpc __c, _Tp __x)
    {
      typedef typename __gnu_cxx::__promote_4<_Tpa, _Tpb, _Tpc, _Tp>::__type __type;
      return __detail::__hyperg<__type>(__a, __b, __c, __x);
    }

} // namespace tr1

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std
#endif // _GLIBCXX_USE_STD_SPEC_FUNCS && !defined(__STRICT_ANSI__)

#endif // _GLIBCXX_TR1_CMATH
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               