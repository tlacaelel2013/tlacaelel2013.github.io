if the class 'class_' conforms to Protocol 'protocol',
   and NO if not.  This function does not check superclasses; if you
   want to check for superclasses (in the way that [NSObject
   +conformsToProtocol:] does) you need to iterate over the class
   hierarchy using class_getSuperclass(), and call
   class_conformsToProtocol() for each of them.  */
objc_EXPORT BOOL class_conformsToProtocol (Class class_, Protocol *protocol);

/* Return all the protocols that the class conforms to.  The return
   value of the function is a pointer to an area, allocated with
   malloc(), that contains all the protocols formally adopted by the
   class.  It does not include protocols adopted by superclasses.  The
   list is terminated by NULL.  Optionally, if you pass a non-NULL
   'numberOfReturnedProtocols' pointer, the unsigned int that it
   points to will be filled with the number of protocols returned.
   This function does not return protocols that superclasses conform
   to.  */
objc_EXPORT Protocol **class_copyProtocolList (Class class_, unsigned int *numberOfReturnedProtocols);

/* Return YES if protocol 'protocol' conforms to protocol
   'anotherProtocol', and NO if not.  Note that if one of the two
   protocols is nil, it returns NO.  */
objc_EXPORT BOOL protocol_conformsToProtocol (Protocol *protocol, Protocol *anotherProtocol);

/* Return YES if protocol 'protocol' is the same as protocol
   'anotherProtocol', and 'NO' if not.  Note that it returns YES if
   the two protocols are both nil.  */
objc_EXPORT BOOL protocol_isEqual (Protocol *protocol, Protocol *anotherProtocol);

/* Return the name of protocol 'protocol'.  If 'protocol' is nil or is
   not a Protocol, return NULL.  */
objc_EXPORT const char *protocol_getName (Protocol *protocol);

/* Return the method description for the method with selector
   'selector' in protocol 'protocol'; if 'requiredMethod' is YES, the
   function searches the list of required methods; if NO, the list of
   optional methods.  If 'instanceMethod' is YES, the function search
   for an instance method; if NO, for a class method.  If there is no
   matching method, an objc_method_description structure with both
   name and types set to NULL is returned.  This function will only
   find methods that are directly declared in the protocol itself, not
   in other protocols that this protocol adopts.

   Note that the traditional ABI does not store the list of optional
   methods of a protocol in a compiled module, so the traditional ABI
   will always return (NULL, NULL) when requiredMethod == NO.  */
objc_EXPORT struct objc_method_description protocol_getMethodDescription (Protocol *protocol, 
									  SEL selector,
									  BOOL requiredMethod,
									  BOOL instanceMethod);

/* Return the method descriptions of all the methods of the protocol.
   The return value of the function is a pointer to an area, allocated
   with malloc(), that contains all the method descriptions of the
   methods of the protocol.  It does not recursively include methods
   of the protocols adopted by this protocol.  The list is terminated
   by a NULL objc_method_description (one with both fields set to
   NULL).  Optionally, if you pass a non-NULL
   'numberOfReturnedMethods' pointer, the unsigned int that it points
   to will be filled with the number of properties returned.

   Note that the traditional ABI does not store the list of optional
   methods of a protocol in a compiled module, so the traditional ABI
   will always return an empty list if requiredMethod is set to
   NO.  */
objc_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList (Protocol *protocol,
										BOOL requiredMethod,
										BOOL instanceMethod,
										unsigned int *numberOfReturnedMethods);

/* Return the property with name 'propertyName' of the protocol
   'protocol'.  If 'requiredProperty' is YES, the function searches
   the list of required properties; if NO, the list of optional
   properties.  If 'instanceProperty' is YES, the function searches
   the list of instance properties; if NO, the list of class
   properties.  At the moment, optional properties and class
   properties are not part of the Objective-C language, so both
   'requiredProperty' and 'instanceProperty' should be set to YES.
   This function returns NULL if the required property cannot be
   found.

   Note that the traditional ABI does not store the list of properties
   of a protocol in a compiled module, so the traditional ABI will
   always return NULL.  */
objc_EXPORT Property protocol_getProperty (Protocol *protocol, const char *propertyName, 
					   BOOL requiredProperty, BOOL instanceProperty);

/* Return all the properties of the protocol.  The return value of the
   function is a pointer to an area, allocated with malloc(), that
   contains all the properties of the protocol.  It does not
   recursively include properties of the protocols adopted by this
   protocol.  The list is terminated by NULL.  Optionally, if you pass
   a non-NULL 'numberOfReturnedProperties' pointer, the unsigned int
   that it points to will be filled with the number of properties
   returned.

   Note that the traditional ABI does not store the list of properties
   of a protocol in a compiled module, so the traditional ABI will
   always return NULL and store 0 in numberOfReturnedProperties.  */
objc_EXPORT Property *protocol_copyPropertyList (Protocol *protocol, unsigned int *numberOfReturnedProperties);

/* Return all the protocols that the protocol conforms to.  The return
   value of the function is a pointer to an area, allocated with
   malloc(), that contains all the protocols formally adopted by the
   protocol.  It does not recursively include protocols adopted by the
   protocols adopted by this protocol.  The list is terminated by
   NULL.  Optionally, if you pass a non-NULL
   'numberOfReturnedProtocols' pointer, the unsigned int that it
   points to will be filled with the number of protocols returned.  */
objc_EXPORT Protocol **protocol_copyProtocolList (Protocol *protocol, unsigned int *numberOfReturnedProtocols);


/** Implementation: the following hook is in init.c.  */

/* This is a hook which is called by __objc_exec_class every time a
   class or a category is loaded into the runtime.  This may e.g. help
   a dynamic loader determine the classes that have been loaded when
   an object file is dynamically linked in.  */
objc_EXPORT void (*_objc_load_callback)(Class _class, struct objc_category *category);


/** Implementation: the following functions are in objc-foreach.c.  */

/* 'objc_enumerationMutation()' is called when a collection is
   mutated while being "fast enumerated".  That is a hard error, and
   objc_enumerationMutation is called to deal with it.  'collection'
   is the collection object that was mutated during an enumeration.

   objc_enumerationMutation() will invoke the mutation handler if any
   is set.  Then, it will abort the program.

   Compatibility note: the Apple runtime will not abort the program
   after calling the mutation handler.  */
objc_EXPORT void objc_enumerationMutation (id collection);

/* 'objc_set_enumeration_mutation_handler' can be used to set a
   function that will be called (instead of aborting) when a fast
   enumeration is mutated during enumeration.  The handler will be
   called with the 'collection' being mutated as the only argument and
   it should not return; it should either exit the program, or could
   throw an exception.  The recommended implementation is to throw an
   exception - the user can then use exception handlers to deal with
   it.

   This function is not thread safe (other threads may be trying to
   invoke the enumeration mutation handler while you are changing it!)
   and should be called during during the program initialization
   before threads are started.  It is mostly reserved for "Foundation"
   libraries; in the case of GNUstep, GNUstep Base may be using this
   function to improve the standard enumeration mutation handling.
   You probably shouldn't use this function unless you are writing
   your own Foundation library.  */
objc_EXPORT void objc_setEnumerationMutationHandler (void (*handler)(id));

/* This structure (used during fast enumeration) is automatically
   defined by the compiler (it is as if this definition was always
   included in all Objective-C files).  Note that it is usually
   defined again with the name of NSFastEnumeration by "Foundation"
   libraries such as GNUstep Base.  And if NSFastEnumeration is
   defined, the compiler will use it instead of
   __objcFastEnumerationState when doing fast enumeration.  */
/*
struct __objcFastEnumerationState
{
  unsigned long state;
  id            *itemsPtr;
  unsigned long *mutationsPtr;
  unsigned long extra[5];
};
*/


/* Compatibility Note: The Apple/NeXT runtime has the functions
   objc_copyImageNames (), class_getImageName () and
   objc_copyClassNamesForImage () but they are undocumented.  The GNU
   runtime does not have them at the moment.  */

/* Compatibility Note: The Apple/NeXT runtime has the functions
   objc_setAssociatedObject (), objc_getAssociatedObject (),
   objc_removeAssociatedObjects () and the objc_AssociationPolicy type
   and related enum.  The GNU runtime does not have them yet.
   TODO: Implement them.  */

/* Compatibility Note: The Apple/NeXT runtime has the function
   objc_setForwardHandler ().  The GNU runtime does not have it
   because messaging (and, in particular, forwarding) works in a
   different (incompatible) way with the GNU runtime.  If you need to
   customize message forwarding at the Objective-C runtime level (that
   is, if you are implementing your own "Foundation" library such as
   GNUstep Base on top of the Objective-C runtime), in objc/message.h
   there are hooks (that work in the framework of the GNU runtime) to
   do so.  */


/** Implementation: the following functions are in memory.c.  */

/* Traditional GNU Objective-C Runtime functions that are used for
   memory allocation and disposal.  These functions are used in the
   same way as you use malloc, realloc, calloc and free and make sure
   that memory allocation works properly with the garbage
   collector.

   Compatibility Note: these functions are not available with the
   Apple/NeXT runtime.  */

objc_EXPORT void *objc_malloc(size_t size);

/* FIXME: Shouldn't the following be called objc_malloc_atomic ?  The
   GC function is GC_malloc_atomic() which makes sense.
 */
objc_EXPORT void *objc_atomic_malloc(size_t size);

objc_EXPORT void *objc_realloc(void *mem, size_t size);

objc_EXPORT void *objc_calloc(size_t nelem, size_t size);

objc_EXPORT void objc_free(void *mem);


/** Implementation: the following functions are in gc.c.  */

/* The GNU Objective-C Runtime has a different implementation of
   garbage collection.

   Compatibility Note: these functions are not available with the
   Apple/NeXT runtime.  */

/* Mark the instance variable as inaccessible to the garbage
   collector.  */
objc_EXPORT void class_ivar_set_gcinvisible (Class _class,
					     const char* ivarname,
					     BOOL gcInvisible);


/** Implementation: the following functions are in encoding.c.  */

/* Traditional GNU Objective-C Runtime functions that are currently
   used to implement method forwarding.

   Compatibility Note: these functions are not available with the
   Apple/NeXT runtime.  */

/* Return the size of a variable which has the specified 'type'
   encoding.  */
objc_EXPORT int objc_sizeof_type (const char *type);

/* Return the align of a variable which has the specified 'type'
   encoding.  */
objc_EXPORT int objc_alignof_type (const char *type);

/* Return the aligned size of a variable which has the specified
   'type' encoding.  The aligned size is the size rounded up to the
   nearest alignment.  */
objc_EXPORT int objc_aligned_size (const char *type);

/* Return the promoted size of a variable which has the specified
   'type' encoding.  This is the size rounded up to the nearest
   integral of the wordsize, taken to be the size of a void *.  */
objc_EXPORT int objc_promoted_size (const char *type);


/* The following functions are used when parsing the type encoding of
   methods, to skip over parts ´&                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              that are ignored.  They take as
   argument a pointer to a location inside the type encoding of a
   method (which is a string) and return a new pointer, pointing to a
   new location inside the string after having skipped the unwanted
   information.  */

/* Skip some type qualifiers (_C_CONST, _C_IN, etc).  These may
  eventually precede typespecs occurring in method prototype
  encodings.  */
objc_EXPORT const char *objc_skip_type_qualifiers (const char *type);

/* Skip one typespec element (_C_CLASS, _C_SEL, etc).  If the typespec
  is prepended by type qualifiers, these are skipped as well.  */
objc_EXPORT const char *objc_skip_typespec (const char *type);

/* Skip an offset.  */
objc_EXPORT const char *objc_skip_offset (const char *type);

/* Skip an argument specification (ie, skipping a typespec, which may
   include qualifiers, and an offset too).  */
objc_EXPORT const char *objc_skip_argspec (const char *type);

/* Read type qualifiers (_C_CONST, _C_IN, etc) from string 'type'
   (stopping at the first non-type qualifier found) and return an
   unsigned int which is the logical OR of all the corresponding flags
   (_F_CONST, _F_IN etc).  */
objc_EXPORT unsigned objc_get_type_qualifiers (const char *type);


/* Note that the following functions work for very simple structures,
   but get easily confused by more complicated ones (for example,
   containing vectors).  A better solution is required.  These
   functions are likely to change in the next GCC release.  */

/* The following three functions can be used to determine how a
   structure is laid out by the compiler. For example:

  struct objc_struct_layout layout;
  int i;

  objc_layout_structure (type, &layout);
  while (objc_layout_structure_next_member (&layout))
    {
      int position, align;
      const char *type;

      objc_layout_structure_get_info (&layout, &position, &align, &type);
      printf ("element %d has offset %d, alignment %d\n",
              i++, position, align);
    }

  These functions are used by objc_sizeof_type and objc_alignof_type
  functions to compute the size and alignment of structures. The
  previous method of computing the size and alignment of a structure
  was not working on some architectures, particularly on AIX, and in
  the presence of bitfields inside the structure.  */
struct objc_struct_layout
{
  const char *original_type;
  const char *type;
  const char *prev_type;
  unsigned int record_size;
  unsigned int record_align;
};

objc_EXPORT void objc_layout_structure (const char *type,
                            struct objc_struct_layout *layout);
objc_EXPORT BOOL  objc_layout_structure_next_member (struct objc_struct_layout *layout);
objc_EXPORT void objc_layout_finish_structure (struct objc_struct_layout *layout,
					       unsigned int *size,
					       unsigned int *align);
objc_EXPORT void objc_layout_structure_get_info (struct objc_struct_layout *layout,
						 unsigned int *offset,
						 unsigned int *align,
						 const char **type);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* Thread and mutex controls for Objective C.
   Copyright (C) 1996-2019 Free Software Foundation, Inc.
   Contributed by Galen C. Hunt (gchunt@cs.rochester.edu)

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

#ifndef __thread_INCLUDE_GNU
#define __thread_INCLUDE_GNU

#include "objc.h"

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*************************************************************************
 *  Universal static variables:
 */
extern int __objc_thread_exit_status;      /* Global exit status.   */

/********
 *  Thread safe implementation types and functions.  
 */

/* Thread priorities */
#define OBJC_THREAD_INTERACTIVE_PRIORITY        2
#define OBJC_THREAD_BACKGROUND_PRIORITY         1
#define OBJC_THREAD_LOW_PRIORITY                0

/* A thread */
typedef void * objc_thread_t;

/* This structure represents a single mutual exclusion lock. */
struct objc_mutex
{
  volatile objc_thread_t owner;     /* Id of thread that owns. */
  volatile int depth;               /* # of acquires. */
  void * backend;                   /* Specific to backend */
};
typedef struct objc_mutex *objc_mutex_t;

/* This structure represents a single condition mutex */
struct objc_condition
{
  void * backend;                   /* Specific to backend */
};
typedef struct objc_condition *objc_condition_t;

/* Frontend mutex functions */
objc_mutex_t objc_mutex_allocate (void);
int objc_mutex_deallocate (objc_mutex_t mutex);
int objc_mutex_lock (objc_mutex_t mutex);
int objc_mutex_unlock (objc_mutex_t mutex);
int objc_mutex_trylock (objc_mutex_t mutex);

/* Frontend condition mutex functions */
objc_condition_t objc_condition_allocate (void);
int objc_condition_deallocate (objc_condition_t condition);
int objc_condition_wait (objc_condition_t condition, objc_mutex_t mutex);
int objc_condition_signal (objc_condition_t condition);
int objc_condition_broadcast (objc_condition_t condition);

/* Frontend thread functions */
objc_thread_t objc_thread_detach (SEL selector, id object, id argument);
void objc_thread_yield (void);
int objc_thread_exit (void);
int objc_thread_set_priority (int priority);
int objc_thread_get_priority (void);
void * objc_thread_get_data (void);
int objc_thread_set_data (void *value);
objc_thread_t objc_thread_id (void);
void objc_thread_add (void);
void objc_thread_remove (void);

/*
  Use this to set the hook function that will be called when the 
  runtime initially becomes multi threaded.
  The hook function is only called once, meaning only when the 
  2nd thread is spawned, not for each and every thread.

  It returns the previous hook function or NULL if there is none.

  A program outside of the runtime could set this to some function so
  it can be informed; for example, the GNUstep Base Library sets it 
  so it can implement the NSBecomingMultiThreaded notification.
  */
typedef void (*objc_thread_callback) (void);
objc_thread_callback objc_set_thread_callback (objc_thread_callback func);

/* Backend initialization functions */
int __objc_init_thread_system (void);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* not __thread_INCLUDE_GNU */
                                                                                                              /* Copyright (C) 2011-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/* ISO C1X: 7.15 Alignment <stdalign.h>.  */

#ifndef _STDALIGN_H
#define _STDALIGN_H

#ifndef __cplusplus

#define alignas _Alignas
#define alignof _Alignof

#define __alignas_is_defined 1
#define __alignof_is_defined 1

#endif

#endif	/* stdalign.h */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /* Copyright (C) 1989-2019 Free Software Foundation, Inc.

This file is part of GCC.

GCC is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3, or (at your option)
any later version.

GCC is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

Under Section 7 of GPL version 3, you are granted additional
permissions described in the GCC Runtime Library Exception, version
3.1, as published by the Free Software Foundation.

You should have received a copy of the GNU General Public License and
a copy of the GCC Runtime Library Exception along with this program;
see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
<http://www.gnu.org/licenses/>.  */

/*
 * ISO C Standard:  7.15  Variable arguments  <stdarg.h>
 */

#ifndef _STDARG_H
#ifndef _ANSI_STDARG_H_
#ifndef __need___va_list
#define _STDARG_H
#define _ANSI_STDARG_H_
#endif /* not __need___va_list */
#undef __need___va_list

/* Define __gnuc_va_list.  */

#ifndef __GNUC_VA_LIST
#define __GNUC_VA_LIST
typedef __builtin_va_list __gnuc_va_list;
#endif

/* Define the standard macros for the user,
   if this invocation was from the user program.  */
#ifdef _STDARG_H

#define va_start(v,l)	__builtin_va_start(v,l)
#define va_end(v)	__builtin_va_end(v)
#define va_arg(v,l)	__builtin_va_arg(v,l)
#if !defined(__STRICT_ANSI__) || __STDC_VERSION__ + 0 >= 199900L \
    || __cplusplus + 0 >= 201103L
#define va_copy(d,s)	__builtin_va_copy(d,s)
#endif
#define __va_copy(d,s)	__builtin_va_copy(d,s)

/* Define va_list, if desired, from __gnuc_va_list. */
/* We deliberately do not define va_list when called from
   stdio.h, because ANSI C says that stdio.h is not supposed to define
   va_list.  stdio.h needs to have access to that data type, 
   but must not use that name.  It should use the name __gnuc_va_list,
   which is safe because it is reserved for the implementation.  */

#ifdef _BSD_VA_LIST
#undef _BSD_VA_LIST
#endif

#if defined(__svr4__) || (defined(_SCO_DS) && !defined(__VA_LIST))
/* SVR4.2 uses _VA_LIST for an internal alias for va_list,
   so we must avoid testing it and setting it here.
   SVR4 uses _VA_LIST as a flag in stdarg.h, but we should
   have no conflict with that.  */
#ifndef _VA_LIST_
#define _VA_LIST_
#ifdef __i860__
#ifndef _VA_LIST
#define _VA_LIST va_list
#endif
#endif /* __i860__ */
typedef __gnuc_va_list va_list;
#ifdef _SCO_DS
#define __VA_LIST
#endif
#endif /* _VA_LIST_ */
#else /* not __svr4__ || _SCO_DS */

/* The macro _VA_LIST_ is the same thing used by this file in Ultrix.
   But on BSD NET2 we must not test or define or undef it.
   (Note that the comments in NET 2's ansi.h
   are incorrect for _VA_LIST_--see stdio.h!)  */
#if !defined (_VA_LIST_) || defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__) || defined(WINNT)
/* The macro _VA_LIST_DEFINED is used in Windows NT 3.5  */
#ifndef _VA_LIST_DEFINED
/* The macro _VA_LIST is used in SCO Unix 3.2.  */
#ifndef _VA_LIST
/* The macro _VA_LIST_T_H is used in the Bull dpx2  */
#ifndef _VA_LIST_T_H
/* The macro __va_list__ is used by BeOS.  */
#ifndef __va_list__
typedef __gnuc_va_list va_list;
#endif /* not __va_list__ */
#endif /* not _VA_LIST_T_H */
#endif /* not _VA_LIST */
#endif /* not _VA_LIST_DEFINED */
#if !(defined (__BSD_NET2__) || defined (____386BSD____) || defined (__bsdi__) || defined (__sequent__) || defined (__FreeBSD__))
#define _VA_LIST_
#endif
#ifndef _VA_LIST
#define _VA_LIST
#endif
#ifndef _VA_LIST_DEFINED
#define _VA_LIST_DEFINED
#endif
#ifndef _VA_LIST_T_H
#define _VA_LIST_T_H
#endif
#ifndef __va_list__
#define __va_list__
#endif

#endif /* not _VA_LIST_, except on certain systems */

#endif /* not __svr4__ */

#endif /* _STDARG_H */

#endif /* not _ANSI_STDARG_H_ */
#endif /* not _STDARG_H */
                        