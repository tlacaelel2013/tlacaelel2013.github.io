    __begin1, __end1, __out, equal_to<_ValueType>(),
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__out));
    }

  // Public interface
  template<typename _IIter, typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    unique_copy(_IIter __begin1, _IIter __end1, _OutputIterator __out,
		_Predicate __pred)
    {
      return __unique_copy_switch(
	       __begin1, __end1, __out, __pred,
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__out));
    }

  // Sequential fallback
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_union(_IIter1 __begin1, _IIter1 __end1,
	      _IIter2 __begin2, _IIter2 __end2,
	      _OutputIterator __out, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_union(
	       __begin1, __end1, __begin2, __end2, __out); }

  // Sequential fallback
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_union(_IIter1 __begin1, _IIter1 __end1,
	      _IIter2 __begin2, _IIter2 __end2,
	      _OutputIterator __out, _Predicate __pred,
	      __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_union(__begin1, __end1,
				       __begin2, __end2, __out, __pred); }

  // Sequential fallback for input iterator case
  template<typename _IIter1, typename _IIter2, typename _Predicate,
	   typename _OutputIterator, typename _IteratorTag1,
	   typename _IteratorTag2, typename _IteratorTag3>
    inline _OutputIterator
    __set_union_switch(
      _IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, _IIter2 __end2,
      _OutputIterator __result, _Predicate __pred,
      _IteratorTag1, _IteratorTag2, _IteratorTag3)
    { return _GLIBCXX_STD_A::set_union(__begin1, __end1,
				       __begin2, __end2, __result, __pred); }

  // Parallel set_union for random access iterators
  template<typename _RAIter1, typename _RAIter2,
	   typename _Output_RAIter, typename _Predicate>
    _Output_RAIter
    __set_union_switch(_RAIter1 __begin1, _RAIter1 __end1,
		       _RAIter2 __begin2, _RAIter2 __end2,
		       _Output_RAIter __result, _Predicate __pred,
		       random_access_iterator_tag, random_access_iterator_tag,
		       random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
	    >= __gnu_parallel::_Settings::get().set_union_minimal_n
	    || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)
	    >= __gnu_parallel::_Settings::get().set_union_minimal_n))
	return __gnu_parallel::__parallel_set_union(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
      else
	return _GLIBCXX_STD_A::set_union(__begin1, __end1,
					 __begin2, __end2, __result, __pred);
    }

  // Public interface
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_union(_IIter1 __begin1, _IIter1 __end1,
	      _IIter2 __begin2, _IIter2 __end2, _OutputIterator __out)
    {
      typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
      typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;

      return __set_union_switch(
	       __begin1, __end1, __begin2, __end2, __out,
	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Public interface
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_union(_IIter1 __begin1, _IIter1 __end1,
	      _IIter2 __begin2, _IIter2 __end2,
	      _OutputIterator __out, _Predicate __pred)
    {
      return __set_union_switch(
	       __begin1, __end1, __begin2, __end2, __out, __pred,
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Sequential fallback.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_IIter1 __begin1, _IIter1 __end1,
		     _IIter2 __begin2, _IIter2 __end2,
		     _OutputIterator __out, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_intersection(__begin1, __end1,
					      __begin2, __end2, __out); }

  // Sequential fallback.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_intersection(_IIter1 __begin1, _IIter1 __end1,
		     _IIter2 __begin2, _IIter2 __end2,
		     _OutputIterator __out, _Predicate __pred,
		     __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_intersection(
	       __begin1, __end1, __begin2, __end2, __out, __pred); }

  // Sequential fallback for input iterator case
  template<typename _IIter1, typename _IIter2,
	   typename _Predicate, typename _OutputIterator,
	   typename _IteratorTag1, typename _IteratorTag2,
	   typename _IteratorTag3>
    inline _OutputIterator
    __set_intersection_switch(_IIter1 __begin1, _IIter1 __end1,
			      _IIter2 __begin2, _IIter2 __end2,
			      _OutputIterator __result, _Predicate __pred,
			      _IteratorTag1, _IteratorTag2, _IteratorTag3)
    { return _GLIBCXX_STD_A::set_intersection(__begin1, __end1, __begin2,
					      __end2, __result, __pred); }

  // Parallel set_intersection for random access iterators
  template<typename _RAIter1, typename _RAIter2,
	   typename _Output_RAIter, typename _Predicate>
    _Output_RAIter
    __set_intersection_switch(_RAIter1 __begin1,
			      _RAIter1 __end1,
			      _RAIter2 __begin2,
			      _RAIter2 __end2,
			      _Output_RAIter __result,
			      _Predicate __pred,
			      random_access_iterator_tag,
			      random_access_iterator_tag,
			      random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
	    >= __gnu_parallel::_Settings::get().set_union_minimal_n
	    || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)
	    >= __gnu_parallel::_Settings::get().set_union_minimal_n))
	return __gnu_parallel::__parallel_set_intersection(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
      else
	return _GLIBCXX_STD_A::set_intersection(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
    }

  // Public interface
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_IIter1 __begin1, _IIter1 __end1,
		     _IIter2 __begin2, _IIter2 __end2,
		     _OutputIterator __out)
    {
      typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
      typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;

      return __set_intersection_switch(
	       __begin1, __end1, __begin2, __end2, __out,
	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_intersection(_IIter1 __begin1, _IIter1 __end1,
		     _IIter2 __begin2, _IIter2 __end2,
		     _OutputIterator __out, _Predicate __pred)
    {
      return __set_intersection_switch(
	       __begin1, __end1, __begin2, __end2, __out, __pred,
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Sequential fallback
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
			     _IIter2 __begin2, _IIter2 __end2,
			     _OutputIterator __out,
			     __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_symmetric_difference(
	       __begin1, __end1, __begin2, __end2, __out); }

  // Sequential fallback
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
			     _IIter2 __begin2, _IIter2 __end2,
			     _OutputIterator __out, _Predicate __pred,
			     __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_symmetric_difference(
	       __begin1, __end1, __begin2, __end2, __out, __pred); }

  // Sequential fallback for input iterator case
  template<typename _IIter1, typename _IIter2,
	   typename _Predicate, typename _OutputIterator,
	   typename _IteratorTag1, typename _IteratorTag2,
	   typename _IteratorTag3>
    inline _OutputIterator
    __set_symmetric_difference_switch(
	_IIter1 __begin1, _IIter1 __end1, _IIter2 __begin2, _IIter2 __end2,
	_OutputIterator __result, _Predicate __pred,
	_IteratorTag1, _IteratorTag2, _IteratorTag3)
    { return _GLIBCXX_STD_A::set_symmetric_difference(
	       __begin1, __end1, __begin2, __end2, __result, __pred); }

  // Parallel set_symmetric_difference for random access iterators
  template<typename _RAIter1, typename _RAIter2,
	   typename _Output_RAIter, typename _Predicate>
    _Output_RAIter
    __set_symmetric_difference_switch(_RAIter1 __begin1,
				      _RAIter1 __end1,
				      _RAIter2 __begin2,
				      _RAIter2 __end2,
				      _Output_RAIter __result,
				      _Predicate __pred,
				      random_access_iterator_tag,
				      random_access_iterator_tag,
				      random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
      static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
      >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n
      || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)
      >= __gnu_parallel::_Settings::get().set_symmetric_difference_minimal_n))
  return __gnu_parallel::__parallel_set_symmetric_difference(
	   __begin1, __end1, __begin2, __end2, __result, __pred);
      else
	return _GLIBCXX_STD_A::set_symmetric_difference(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
    }

  // Public interface.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
			     _IIter2 __begin2, _IIter2 __end2,
			     _OutputIterator __out)
    {
      typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
      typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;

      return __set_symmetric_difference_switch(
	       __begin1, __end1, __begin2, __end2, __out,
	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Public interface.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_symmetric_difference(_IIter1 __begin1, _IIter1 __end1,
			     _IIter2 __begin2, _IIter2 __end2,
			     _OutputIterator __out, _Predicate __pred)
    {
      return __set_symmetric_difference_switch(
	       __begin1, __end1, __begin2, __end2, __out, __pred,
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Sequential fallback.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_difference(_IIter1 __begin1, _IIter1 __end1,
		   _IIter2 __begin2, _IIter2 __end2,
		   _OutputIterator __out, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_difference(
	       __begin1,__end1, __begin2, __end2, __out); }

  // Sequential fallback.
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_difference(_IIter1 __begin1, _IIter1 __end1,
		   _IIter2 __begin2, _IIter2 __end2,
		   _OutputIterator __out, _Predicate __pred,
		   __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::set_difference(__begin1, __end1,
					    __begin2, __end2, __out, __pred); }

  // Sequential fallback for input iterator case.
  template<typename _IIter1, typename _IIter2, typename _Predicate,
	   typename _OutputIterator, typename _IteratorTag1,
	   typename _IteratorTag2, typename _IteratorTag3>
    inline _OutputIterator
    __set_difference_switch(_IIter1 __begin1, _IIter1 __end1,
			    _IIter2 __begin2, _IIter2 __end2,
			    _OutputIterator __result, _Predicate __pred,
			    _IteratorTag1, _IteratorTag2, _IteratorTag3)
    { return _GLIBCXX_STD_A::set_difference(
	       __begin1, __end1, __begin2, __end2, __result, __pred); }

  // Parallel set_difference for random access iterators
  template<typename _RAIter1, typename _RAIter2,
	   typename _Output_RAIter, typename _Predicate>
    _Output_RAIter
    __set_difference_switch(_RAIter1 __begin1,
			    _RAIter1 __end1,
			    _RAIter2 __begin2,
			    _RAIter2 __end2,
			    _Output_RAIter __result, _Predicate __pred,
			    random_access_iterator_tag,
			    random_access_iterator_tag,
			    random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
	    >= __gnu_parallel::_Settings::get().set_difference_minimal_n
	    || static_cast<__gnu_parallel::_SequenceIndex>(__end2 - __begin2)
	    >= __gnu_parallel::_Settings::get().set_difference_minimal_n))
	return __gnu_parallel::__parallel_set_difference(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
      else
	return _GLIBCXX_STD_A::set_difference(
		 __begin1, __end1, __begin2, __end2, __result, __pred);
    }

  // Public interface
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator>
    inline _OutputIterator
    set_difference(_IIter1 __begin1, _IIter1 __end1,
		   _IIter2 __begin2, _IIter2 __end2,
		   _OutputIterator __out)
    {
      typedef typename std::iterator_traits<_IIter1>::value_type _ValueType1;
      typedef typename std::iterator_traits<_IIter2>::value_type _ValueType2;

      return __set_difference_switch(
	       __begin1, __end1, __begin2, __end2, __out,
	       __gnu_parallel::_Less<_ValueType1, _ValueType2>(),
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Public interface
  template<typename _IIter1, typename _IIter2,
	   typename _OutputIterator, typename _Predicate>
    inline _OutputIterator
    set_difference(_IIter1 __begin1, _IIter1 __end1,
		   _IIter2 __begin2, _IIter2 __end2,
		   _OutputIterator __out, _Predicate __pred)
    {
      return __set_difference_switch(
	       __begin1, __end1, __begin2, __end2, __out, __pred,
	       std::__iterator_category(__begin1),
	       std::__iterator_category(__begin2),
	       std::__iterator_category(__out));
    }

  // Sequential fallback
  template<typename _FIterator>
    inline _FIterator
    adjacent_find(_FIterator __begin, _FIterator __end,
		  __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::adjacent_find(__begin, __end); }

  // Sequential fallback
  template<typename _FIterator, typename _BinaryPredicate>
    inline _FIterator
    adjacent_find(_FIterator __begin, _FIterator __end,
		  _BinaryPredicate __binary_pred,
		  __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::adjacent_find(__begin, __end, __binary_pred); }

  // Parallel algorithm for random access iterators
  template<typename _RAIter>
    _RAIter
    __adjacent_find_switch(_RAIter __begin, _RAIter __end,
			   random_access_iterator_tag)
    {
      typedef iterator_traits<_RAIter> _TraitsType;
      typedef typename _TraitsType::value_type _ValueType;

      if (_GLIBCXX_PARALLEL_CONDITION(true))
	{
	  _RAIter __spot = __gnu_parallel::
	      __find_template(
		__begin, __end - 1, __begin, equal_to<_ValueType>(),
		__gnu_parallel::__adjacent_find_selector())
	    .first;
	  if (__spot == (__end - 1))
	    return __end;
	  else
	    return __spot;
	}
      else
	return adjacent_find(__begin, __end, __gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case
  template<typename _FIterator, typename _IteratorTag>
    inline _FIterator
    __adjacent_find_switch(_FIterator __begin, _FIterator __end,
			   _IteratorTag)
    { return adjacent_find(__begin, __end, __gnu_parallel::sequential_tag()); }

  // Public interface
  template<typename _FIterator>
    inline _FIterator
    adjacent_find(_FIterator __begin, _FIterator __end)
    {
      return __adjacent_find_switch(__begin, __end,
				    std::__iterator_category(__begin));
    }

  // Sequential fallback for input iterator case
  template<typename _FIterator, typename _BinaryPredicate,
	   typename _IteratorTag>
    inline _FIterator
    __adjacent_find_switch(_FIterator __begin, _FIterator __end,
			   _BinaryPredicate __pred, _IteratorTag)
    { return adjacent_find(__begin, __end, __pred,
			   __gnu_parallel::sequential_tag()); }

  // Parallel algorithm for random access iterators
  template<typename _RAIter, typename _BinaryPredicate>
    _RAIter
    __adjacent_find_switch(_RAIter __begin, _RAIter __end,
			   _BinaryPredicate __pred, random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(true))
	return __gnu_parallel::__find_template(__begin, __end, __begin, __pred,
					     __gnu_parallel::
					     __adjacent_find_selector()).first;
      else
	return adjacent_find(__begin, __end, __pred,
			     __gnu_parallel::sequential_tag());
    }

  // Public interface
  template<typename _FIterator, typename _BinaryPredicate>
    inline _FIterator
    adjacent_find(_FIterator __begin, _FIterator __end,
		  _BinaryPredicate __pred)
    {
      return __adjacent_find_switch(__begin, __end, __pred,
				    std::__iterator_category(__begin));
    }

  // Sequential fallback
  template<typename _IIter, typename _Tp>
    inline typename iterator_traits<_IIter>::difference_type
    count(_IIter __begin, _IIter __end, const _Tp& __value,
	  __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::count(__begin, __end, __value); }

  // Parallel code for random access iterators
  template<typename _RAIter, typename _Tp>
    typename iterator_traits<_RAIter>::difference_type
    __count_switch(_RAIter __begin, _RAIter __end,
		   const _Tp& __value, random_access_iterator_tag,
		   __gnu_parallel::_Parallelism __parallelism_tag)
    {
      typedef iterator_traits<_RAIter> _TraitsType;
      typedef typename _TraitsType::value_type _ValueType;
      typedef typename _TraitsType::difference_type _DifferenceType;
      typedef __gnu_parallel::_SequenceIndex _SequenceIndex;

      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<_SequenceIndex>(__end - __begin)
	    >= __gnu_parallel::_Settings::get().count_minimal_n
	    && __gnu_parallel::__is_parallel(__parallelism_tag)))
	{
	  __gnu_parallel::__count_selector<_RAIter, _DifferenceType>
	    __functionality;
	  _DifferenceType __res = 0;
	  __gnu_parallel::
	    __for_each_template_random_access(
	      __begin, __end, __value, __functionality,
	      std::plus<_SequenceIndex>(), __res, __res, -1,
	      __parallelism_tag);
	  return __res;
	}
      else
	return count(__begin, __end, __value,
		     __gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case.
  template<typename _IIter, typename _Tp, typename _IteratorTag>
    inline typename iterator_traits<_IIter>::difference_type
    __count_switch(_IIter __begin, _IIter __end, const _Tp& __value,
		   _IteratorTag)
    { return count(__begin, __end, __value, __gnu_parallel::sequential_tag());
      }

  // Public interface.
  template<typename _IIter, typename _Tp>
    inline typename iterator_traits<_IIter>::difference_type
    count(_IIter __begin, _IIter __end, const _Tp& __value,
	  __gnu_parallel::_Parallelism __parallelism_tag)
    {
      return __count_switch(__begin, __end, __value,
			    std::__iterator_category(__begin),
			    __parallelism_tag);
    }

  template<typename _IIter, typename _Tp>
    inline typename iterator_traits<_IIter>::difference_type
    count(_IIter __begin, _IIter __end, const _Tp& __value)
    {
      return __count_switch(__begin, __end, __value,
			    std::__iterator_category(__begin));
    }


  // Sequential fallback.
  template<typename _IIter, typename _Predicate>
    inline typename iterator_traits<_IIter>::difference_type
    count_if(_IIter __begin, _IIter __end, _Predicate __pred,
	     __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::count_if(__begin, __end, __pred); }

  // Parallel count_if for random access iterators
  template<typename _RAIter, typename _Predicate>
    typename iterator_traits<_RAIter>::difference_type
    __count_if_switch(_RAIter __begin, _RAIter __end,
		      _Predicate __pred, random_access_iterator_tag,
		      __gnu_parallel::_Parallelism __parallelism_tag)
    {
      typedef iterator_traits<_RAIter> _TraitsType;
      typedef typename _TraitsType::value_type _ValueType;
      typedef typename _TraitsType::difference_type _DifferenceType;
      typedef __gnu_parallel::_SequenceIndex _SequenceIndex;

      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<_SequenceIndex>(__end - __begin)
	    >= __gnu_parallel::_Settings::get().count_minimal_n
	    && __gnu_parallel::__is_parallel(__parallelism_tag)))
	{
	  _DifferenceType __res = 0;
	  __gnu_parallel::
	    __count_if_selector<_RAIter, _DifferenceType>
	    __functionality;
	  __gnu_parallel::
	    __for_each_template_random_access(
	      __begin, __end, __pred, __functionality,
	      std::plus<_SequenceIndex>(), __res, __res, -1,
	      __parallelism_tag);
	  return __res;
	}
      else
	return count_if(__begin, __end, __pred,
			__gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case.
  template<typename _IIter, typename _Predicate, typename _IteratorTag>
    inline typename iterator_traits<_IIter>::difference_type
    __count_if_switch(_IIter __begin, _IIter __end, _Predicate __pred,
		      _IteratorTag)
    { return count_if(__begin, __end, __pred,
		      __gnu_parallel::sequential_tag()); }

  // Public interface.
  template<typename _IIter, typename _Predicate>
    inline typename iterator_traits<_IIter>::difference_type
    count_if(_IIter __begin, _IIter __end, _Predicate __pred,
	     __gnu_parallel::_Parallelism __parallelism_tag)
    {
      return __count_if_switch(__begin, __end, __pred,
			       std::__iterator_category(__begin),
			       __parallelism_tag);
    }

  template<typename _IIter, typename _Predicate>
    inline typename iterator_traits<_IIter>::difference_type
    count_if(_IIter __begin, _IIter __end, _Predicate __pred)
    {
      return __count_if_switch(__begin, __end, __pred,
			       std::__iterator_category(__begin));
    }


  // Sequential fallback.
  template<typename _FIterator1, typename _FIterator2>
    inline _FIterator1
    search(_FIterator1 __begin1, _FIterator1 __end1,
	   _FIterator2 __begin2, _FIterator2 __end2,
	   __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::search(__begin1, __end1, __begin2, __end2); }

  // Parallel algorithm for random access iterator
  template<typename _RAIter1, typename _RAIter2>
    _RAIter1
    __search_switch(_RAIter1 __begin1, _RAIter1 __end1,
		    _RAIter2 __begin2, _RAIter2 __end2,
		    random_access_iterator_tag, random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RAIter1>::value_type _ValueType1;
      typedef typename std::iterator_traits<_RAIter2>::value_type _ValueType2;

      if (_GLIBCXX_PARALLEL_CONDITION(
		static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
	    >= __gnu_parallel::_Settings::get().search_minimal_n))
	return __gnu_parallel::
	  __search_template(
	    __begin1, __end1, __begin2, __end2,
	    __gnu_parallel::_EqualTo<_ValueType1, _ValueType2>());
      else
	return search(__begin1, __end1, __begin2, __end2,
		      __gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case
  template<typename _FIterator1, typename _FIterator2,
	   typename _IteratorTag1, typename _IteratorTag2>
    inline _FIterator1
    __search_switch(_FIterator1 __begin1, _FIterator1 __end1,
		    _FIterator2 __begin2, _FIterator2 __end2,
		    _IteratorTag1, _IteratorTag2)
    { return search(__begin1, __end1, __begin2, __end2,
		    __gnu_parallel::sequential_tag()); }

  // Public interface.
  template<typename _FIterator1, typename _FIterator2>
    inline _FIterator1
    search(_FIterator1 __begin1, _FIterator1 __end1,
	   _FIterator2 __begin2, _FIterator2 __end2)
    {
      return __search_switch(__begin1, __end1, __begin2, __end2,
			     std::__iterator_category(__begin1),
			     std::__iterator_category(__begin2));
    }

  // Public interface.
  template<typename _FIterator1, typename _FIterator2,
	   typename _BinaryPredicate>
    inline _FIterator1
    search(_FIterator1 __begin1, _FIterator1 __end1,
	   _FIterator2 __begin2, _FIterator2 __end2,
	   _BinaryPredicate __pred, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::search(
			       __begin1, __end1, __begin2, __end2, __pred); }

  // Parallel algorithm for random access iterator.
  template<typename _RAIter1, typename _RAIter2,
	   typename _BinaryPredicate>
    _RAIter1
    __search_switch(_RAIter1 __begin1, _RAIter1 __end1,
		    _RAIter2 __begin2, _RAIter2 __end2,
		    _BinaryPredicate __pred,
		    random_access_iterator_tag, random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
		static_cast<__gnu_parallel::_SequenceIndex>(__end1 - __begin1)
	    >= __gnu_parallel::_Settings::get().search_minimal_n))
	return __gnu_parallel::__search_template(__begin1, __end1,
					       __begin2, __end2, __pred);
      else
	return search(__begin1, __end1, __begin2, __end2, __pred,
		      __gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case
  template<typename _FIterator1, typename _FIterator2,
	   typename _BinaryPredicate, typename _IteratorTag1,
	   typename _IteratorTag2>
    inline _FIterator1
    __search_switch(_FIterator1 __begin1, _FIterator1 __end1,
		    _FIterator2 __begin2, _FIterator2 __end2,
		    _BinaryPredicate __pred, _IteratorTag1, _IteratorTag2)
    { return search(__begin1, __end1, __begin2, __end2, __pred,
		    __gnu_parallel::sequential_tag()); }

  // Public interface
  template<typename _FIterator1, typename _FIterator2,
	   typename _BinaryPredicate>
    inline _FIterator1
    search(_FIterator1 __begin1, _FIterator1 __end1,
	   _FIterator2 __begin2, _FIterator2 __end2,
	   _BinaryPredicate  __pred)
    {
      return __search_switch(__begin1, __end1, __begin2, __end2, __pred,
			     std::__iterator_category(__begin1),
			     std::__iterator_category(__begin2));
    }

  // Sequential fallback
  template<typename _FIterator, typename _Integer, typename _Tp>
    inline _FIterator
    search_n(_FIterator __begin, _FIterator __end, _Integer __count,
	     const _Tp& __val, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::search_n(__begin, __end, __count, __val); }

  // Sequential fallback
  template<typename _FIterator, typename _Integer, typename _Tp,
	   typename _BinaryPredicate>
    inline _FIterator
    search_n(_FIterator __begin, _FIterator __end, _Integer __count,
	     const _Tp& __val, _BinaryPredicate __binary_pred,
	     __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::search_n(
	       __begin, __end, __count, __val, __binary_pred); }

  // Public interface.
  template<typename _FIterator, typename _Integer, typename _Tp>
    inline _FIterator
    search_n(_FIterator __begin, _FIterator __end, _Integer __count,
	     const _Tp& __val)
    {
      typedef typename iterator_traits<_FIterator>::value_type _ValueType;
      return __gnu_parallel::search_n(__begin, __end, __count, __val,
		      __gnu_parallel::_EqualTo<_ValueType, _Tp>());
    }

  // Parallel algorithm for random access iterators.
  template<typename _RAIter, typename _Integer,
	   typename _Tp, typename _BinaryPredicate>
    _RAIter
    __search_n_switch(_RAIter __begin, _RAIter __end, _Integer __count,
		      const _Tp& __val, _BinaryPredicate __binary_pred,
		      random_access_iterator_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
		static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
	    >= __gnu_parallel::_Settings::get().search_minimal_n))
	{
	  __gnu_parallel::_PseudoSequence<_Tp, _Integer> __ps(__val, __count);
	  return __gnu_parallel::__search_template(
		   __begin, __end, __ps.begin(), __ps.end(), __binary_pred);
	}
      else
	return _GLIBCXX_STD_A::search_n(__begin, __end, __count, __val,
					__binary_pred);
    }

  // Sequential fallback for input iterator case.
  template<typename _FIterator, typename _Integer, typename _Tp,
	   typename _BinaryPredicate, typename _IteratorTag>
    inline _FIterator
    __search_n_switch(_FIterator __begin, _FIterator __end, _Integer __count,
		      const _Tp& __val, _BinaryPredicate __binary_pred,
		      _IteratorTag)
    { return _GLIBCXX_STD_A::search_n(__begin, __end, __count, __val,
				      __binary_pred); }

  // Public interface.
  template<typename _FIterator, typename _Integer, typename _Tp,
	   typename _BinaryPredicate>
    inline _FIterator
    search_n(_FIterator __begin, _FIterator __end, _Integer __count,
	     const _Tp& __val, _BinaryPredicate __binary_pred)
    {
      return __search_n_switch(__begin, __end, __count, __val, __binary_pred,
			       std::__iterator_category(__begin));
    }


  // Sequential fallback.
  template<typename _IIter, typename _OutputIterator,
	   typename _UnaryOperation>
    inline _OutputIterator
    transform(_IIter __begin, _IIter __end, _OutputIterator __result,
	      _UnaryOperation __unary_op, __gnu_parallel::sequential_tag)
    { return _GLIBCXX_STD_A::transform(__begin, __end, __result, __unary_op); }

  // Parallel unary transform for random access iterators.
  template<typename _RAIter1, typename _RAIter2,
	   typename _UnaryOperation>
    _RAIter2
    __transform1_switch(_RAIter1 __begin, _RAIter1 __end,
			_RAIter2 __result, _UnaryOperation __unary_op,
			random_access_iterator_tag, random_access_iterator_tag,
			__gnu_parallel::_Parallelism __parallelism_tag)
    {
      if (_GLIBCXX_PARALLEL_CONDITION(
	    static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
	    >= __gnu_parallel::_Settings::get().transform_minimal_n
	    && __gnu_parallel::__is_parallel(__parallelism_tag)))
	{
	  bool __dummy = true;
	  typedef __gnu_parallel::_IteratorPair<_RAIter1,
	    _RAIter2, random_access_iterator_tag> _ItTrip;
	  _ItTrip __begin_pair(__begin, __result),
		  __end_pair(__end, __result + (__end - __begin));
	  __gnu_parallel::__transform1_selector<_ItTrip> __functionality;
	  __gnu_parallel::
	    __for_each_template_random_access(
	      __begin_pair, __end_pair, __unary_op, __functionality,
	      __gnu_parallel::_DummyReduct(),
	      __dummy, __dummy, -1, __parallelism_tag);
	  return __functionality._M_finish_iterator;
	}
      else
	return transform(__begin, __end, __result, __unary_op,
			 __gnu_parallel::sequential_tag());
    }

  // Sequential fallback for input iterator case.
  template<typename _RAIter1, typename _RAIter2,
	   typename _UnaryOperation, typename _IteratorTag1,
	   typename _IteratorTag2>
    inline _RAIter2
    __transform1_switch(_RAIter1 __begin, _RAIter1 __end,
			_RAIter2 __result, _UnaryOperation __unary_op,
			_IteratorTag1, _IteratorTag2)
    { return transform(__begin, __end, __result, __unary_op,
		       __gnu_parallel::sequential_tag()); }

  // Public interface.
  template<typename _IIter, typename _OutputIterator,
	   typename _UnaryOperation>
    inline _OutputIterator
    transform(_IIter __begin, _IIter __end, _OutputIterator __result,
	      _UnaryOperation __unary_op,
	      __gnu_parallel::_Parallelism __parallelism_tag)
    {
      return __transform1_switch(__begin, __end, __result, __unary_op,
				 std::__iterator_category(__begin),
				 std::__iterator_category(__result),
				 __parallelism_tag);
    }

  template<typename _IIter, typename _OutputIterator,
	   typename _UnaryOperation>
    inline _OutputIterator
    transform(_IIter __begin, _IIter __end, _OutputIterator __result,
	      _UnaryOperation __unary_op)
    {
      return __transform1_switch(__begin, __end, __result, __unary_op,
				 std::__iterato