PROBE_REQ_DEFERRAL_SUPPRESSION: allow probe request
 *	tx deferral (dot11FILSProbeDelay shall be set to 15ms)
 *	and suppression (if it has received a broadcast Probe Response frame,
 *	Beacon frame or FILS Discovery frame from an AP that the STA considers
 *	a suitable candidate for (re-)association - suitable in terms of
 *	SSID and/or RSSI.
 * @NL80211_SCAN_FLAG_LOW_SPAN: Span corresponds to the total time taken to
 *	accomplish the scan. Thus, this flag intends the driver to perform the
 *	scan request with lesser span/duration. It is specific to the driver
 *	implementations on how this is accomplished. Scan accuracy may get
 *	impacted with this flag.
 * @NL80211_SCAN_FLAG_LOW_POWER: This flag intends the scan attempts to consume
 *	optimal possible power. Drivers can resort to their specific means to
 *	optimize the power. Scan accuracy may get impacted with this flag.
 * @NL80211_SCAN_FLAG_HIGH_ACCURACY: Accuracy here intends to the extent of scan
 *	results obtained. Thus HIGH_ACCURACY scan flag aims to get maximum
 *	possible scan results. This flag hints the driver to use the best
 *	possible scan configuration to improve the accuracy in scanning.
 *	Latency and power use may get impacted with this flag.
 * @NL80211_SCAN_FLAG_RANDOM_SN: randomize the sequence number in probe
 *	request frames from this scan to avoid correlation/tracking being
 *	possible.
 * @NL80211_SCAN_FLAG_MIN_PREQ_CONTENT: minimize probe request content to
 *	only have supported rates and no additional capabilities (unless
 *	added by userspace explicitly.)
 * @NL80211_SCAN_FLAG_FREQ_KHZ: report scan results with
 *	%NL80211_ATTR_SCAN_FREQ_KHZ. This also means
 *	%NL80211_ATTR_SCAN_FREQUENCIES will not be included.
 */
enum nl80211_scan_flags {
	NL80211_SCAN_FLAG_LOW_PRIORITY				= 1<<0,
	NL80211_SCAN_FLAG_FLUSH					= 1<<1,
	NL80211_SCAN_FLAG_AP					= 1<<2,
	NL80211_SCAN_FLAG_RANDOM_ADDR				= 1<<3,
	NL80211_SCAN_FLAG_FILS_MAX_CHANNEL_TIME			= 1<<4,
	NL80211_SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP		= 1<<5,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE		= 1<<6,
	NL80211_SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION	= 1<<7,
	NL80211_SCAN_FLAG_LOW_SPAN				= 1<<8,
	NL80211_SCAN_FLAG_LOW_POWER				= 1<<9,
	NL80211_SCAN_FLAG_HIGH_ACCURACY				= 1<<10,
	NL80211_SCAN_FLAG_RANDOM_SN				= 1<<11,
	NL80211_SCAN_FLAG_MIN_PREQ_CONTENT			= 1<<12,
	NL80211_SCAN_FLAG_FREQ_KHZ				= 1<<13,
};

/**
 * enum nl80211_acl_policy - access control policy
 *
 * Access control policy is applied on a MAC list set by
 * %NL80211_CMD_START_AP and %NL80211_CMD_SET_MAC_ACL, to
 * be used with %NL80211_ATTR_ACL_POLICY.
 *
 * @NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED: Deny stations which are
 *	listed in ACL, i.e. allow all the stations which are not listed
 *	in ACL to authenticate.
 * @NL80211_ACL_POLICY_DENY_UNLESS_LISTED: Allow the stations which are listed
 *	in ACL, i.e. deny all the stations which are not listed in ACL.
 */
enum nl80211_acl_policy {
	NL80211_ACL_POLICY_ACCEPT_UNLESS_LISTED,
	NL80211_ACL_POLICY_DENY_UNLESS_LISTED,
};

/**
 * enum nl80211_smps_mode - SMPS mode
 *
 * Requested SMPS mode (for AP mode)
 *
 * @NL80211_SMPS_OFF: SMPS off (use all antennas).
 * @NL80211_SMPS_STATIC: static SMPS (use a single antenna)
 * @NL80211_SMPS_DYNAMIC: dynamic smps (start with a single antenna and
 *	turn on other antennas after CTS/RTS).
 */
enum nl80211_smps_mode {
	NL80211_SMPS_OFF,
	NL80211_SMPS_STATIC,
	NL80211_SMPS_DYNAMIC,

	__NL80211_SMPS_AFTER_LAST,
	NL80211_SMPS_MAX = __NL80211_SMPS_AFTER_LAST - 1
};

/**
 * enum nl80211_radar_event - type of radar event for DFS operation
 *
 * Type of event to be used with NL80211_ATTR_RADAR_EVENT to inform userspace
 * about detected radars or success of the channel available check (CAC)
 *
 * @NL80211_RADAR_DETECTED: A radar pattern has been detected. The channel is
 *	now unusable.
 * @NL80211_RADAR_CAC_FINISHED: Channel Availability Check has been finished,
 *	the channel is now available.
 * @NL80211_RADAR_CAC_ABORTED: Channel Availability Check has been aborted, no
 *	change to the channel status.
 * @NL80211_RADAR_NOP_FINISHED: The Non-Occupancy Period for this channel is
 *	over, channel becomes usable.
 * @NL80211_RADAR_PRE_CAC_EXPIRED: Channel Availability Check done on this
 *	non-operating channel is expired and no longer valid. New CAC must
 *	be done on this channel before starting the operation. This is not
 *	applicable for ETSI dfs domain where pre-CAC is valid for ever.
 * @NL80211_RADAR_CAC_STARTED: Channel Availability Check has been started,
 *	should be generated by HW if NL80211_EXT_FEATURE_DFS_OFFLOAD is enabled.
 */
enum nl80211_radar_event {
	NL80211_RADAR_DETECTED,
	NL80211_RADAR_CAC_FINISHED,
	NL80211_RADAR_CAC_ABORTED,
	NL80211_RADAR_NOP_FINISHED,
	NL80211_RADAR_PRE_CAC_EXPIRED,
	NL80211_RADAR_CAC_STARTED,
};

/**
 * enum nl80211_dfs_state - DFS states for channels
 *
 * Channel states used by the DFS code.
 *
 * @NL80211_DFS_USABLE: The channel can be used, but channel availability
 *	check (CAC) must be performed before using it for AP or IBSS.
 * @NL80211_DFS_UNAVAILABLE: A radar has been detected on this channel, it
 *	is therefore marked as not available.
 * @NL80211_DFS_AVAILABLE: The channel has been CAC checked and is available.
 */
enum nl80211_dfs_state {
	NL80211_DFS_USABLE,
	NL80211_DFS_UNAVAILABLE,
	NL80211_DFS_AVAILABLE,
};

/**
 * enum enum nl80211_protocol_features - nl80211 protocol features
 * @NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP: nl80211 supports splitting
 *	wiphy dumps (if requested by the application with the attribute
 *	%NL80211_ATTR_SPLIT_WIPHY_DUMP. Also supported is filtering the
 *	wiphy dump by %NL80211_ATTR_WIPHY, %NL80211_ATTR_IFINDEX or
 *	%NL80211_ATTR_WDEV.
 */
enum nl80211_protocol_features {
	NL80211_PROTOCOL_FEATURE_SPLIT_WIPHY_DUMP =	1 << 0,
};

/**
 * enum nl80211_crit_proto_id - nl80211 critical protocol identifiers
 *
 * @NL80211_CRIT_PROTO_UNSPEC: protocol unspecified.
 * @NL80211_CRIT_PROTO_DHCP: BOOTP or DHCPv6 protocol.
 * @NL80211_CRIT_PROTO_EAPOL: EAPOL protocol.
 * @NL80211_CRIT_PROTO_APIPA: APIPA protocol.
 * @NUM_NL80211_CRIT_PROTO: must be kept last.
 */
enum nl80211_crit_proto_id {
	NL80211_CRIT_PROTO_UNSPEC,
	NL80211_CRIT_PROTO_DHCP,
	NL80211_CRIT_PROTO_EAPOL,
	NL80211_CRIT_PROTO_APIPA,
	/* add other protocols before this one */
	NUM_NL80211_CRIT_PROTO
};

/* maximum duration for critical protocol measures */
#define NL80211_CRIT_PROTO_MAX_DURATION		5000 /* msec */

/**
 * enum nl80211_rxmgmt_flags - flags for received management frame.
 *
 * Used by cfg80211_rx_mgmt()
 *
 * @NL80211_RXMGMT_FLAG_ANSWERED: frame was answered by device/driver.
 * @NL80211_RXMGMT_FLAG_EXTERNAL_AUTH: Host driver intends to offload
 *	the authentication. Exclusively defined for host drivers that
 *	advertises the SME functionality but would like the userspace
 *	to handle certain authentication algorithms (e.g. SAE).
 */
enum nl80211_rxmgmt_flags {
	NL80211_RXMGMT_FLAG_ANSWERED = 1 << 0,
	NL80211_RXMGMT_FLAG_EXTERNAL_AUTH = 1 << 1,
};

/*
 * If this flag is unset, the lower 24 bits are an OUI, if set
 * a Linux nl80211 vendor ID is used (no such IDs are allocated
 * yet, so that's not valid so far)
 */
#define NL80211_VENDOR_ID_IS_LINUX	0x80000000

/**
 * struct nl80211_vendor_cmd_info - vendor command data
 * @vendor_id: If the %NL80211_VENDOR_ID_IS_LINUX flag is clear, then the
 *	value is a 24-bit OUI; if it is set then a separately allocated ID
 *	may be used, but no such IDs are allocated yet. New IDs should be
 *	added to this file when needed.
 * @subcmd: sub-command ID for the command
 */
struct nl80211_vendor_cmd_info {
	__u32 vendor_id;
	__u32 subcmd;
};

/**
 * enum nl80211_tdls_peer_capability - TDLS peer flags.
 *
 * Used by tdls_mgmt() to determine which conditional elements need
 * to be added to TDLS Setup frames.
 *
 * @NL80211_TDLS_PEER_HT: TDLS peer is HT capable.
 * @NL80211_TDLS_PEER_VHT: TDLS peer is VHT capable.
 * @NL80211_TDLS_PEER_WMM: TDLS peer is WMM capable.
 */
enum nl80211_tdls_peer_capability {
	NL80211_TDLS_PEER_HT = 1<<0,
	NL80211_TDLS_PEER_VHT = 1<<1,
	NL80211_TDLS_PEER_WMM = 1<<2,
};

/**
 * enum nl80211_sched_scan_plan - scanning plan for scheduled scan
 * @__NL80211_SCHED_SCAN_PLAN_INVALID: attribute number 0 is reserved
 * @NL80211_SCHED_SCAN_PLAN_INTERVAL: interval between scan iterations. In
 *	seconds (u32).
 * @NL80211_SCHED_SCAN_PLAN_ITERATIONS: number of scan iterations in this
 *	scan plan (u32). The last scan plan must not specify this attribute
 *	because it will run infinitely. A value of zero is invalid as it will
 *	make the scan plan meaningless.
 * @NL80211_SCHED_SCAN_PLAN_MAX: highest scheduled scan plan attribute number
 *	currently defined
 * @__NL80211_SCHED_SCAN_PLAN_AFTER_LAST: internal use
 */
enum nl80211_sched_scan_plan {
	__NL80211_SCHED_SCAN_PLAN_INVALID,
	NL80211_SCHED_SCAN_PLAN_INTERVAL,
	NL80211_SCHED_SCAN_PLAN_ITERATIONS,

	/* keep last */
	__NL80211_SCHED_SCAN_PLAN_AFTER_LAST,
	NL80211_SCHED_SCAN_PLAN_MAX =
		__NL80211_SCHED_SCAN_PLAN_AFTER_LAST - 1
};

/**
 * struct nl80211_bss_select_rssi_adjust - RSSI adjustment parameters.
 *
 * @band: band of BSS that must match for RSSI value adjustment. The value
 *	of this field is according to &enum nl80211_band.
 * @delta: value used to adjust the RSSI value of matching BSS in dB.
 */
struct nl80211_bss_select_rssi_adjust {
	__u8 band;
	__s8 delta;
} __attribute__((packed));

/**
 * enum nl80211_bss_select_attr - attributes for bss selection.
 *
 * @__NL80211_BSS_SELECT_ATTR_INVALID: reserved.
 * @NL80211_BSS_SELECT_ATTR_RSSI: Flag indicating only RSSI-based BSS selection
 *	is requested.
 * @NL80211_BSS_SELECT_ATTR_BAND_PREF: attribute indicating BSS
 *	selection should be done such that the specified band is preferred.
 *	When there are multiple BSS-es in the preferred band, the driver
 *	shall use RSSI-based BSS selection as a second step. The value of
 *	this attribute is according to &enum nl80211_band (u32).
 * @NL80211_BSS_SELECT_ATTR_RSSI_ADJUST: When present the RSSI level for
 *	BSS-es in the specified band is to be adjusted before doing
 *	RSSI-based BSS selection. The attribute value is a packed structure
 *	value as specified by &struct nl80211_bss_select_rssi_adjust.
 * @NL80211_BSS_SELECT_ATTR_MAX: highest bss select attribute number.
 * @__NL80211_BSS_SELECT_ATTR_AFTER_LAST: internal use.
 *
 * One and only one of these attributes are found within %NL80211_ATTR_BSS_SELECT
 * for %NL80211_CMD_CONNECT. It specifies the required BSS selection behaviour
 * which the driver shall use.
 */
enum nl80211_bss_select_attr {
	__NL80211_BSS_SELECT_ATTR_INVALID,
	NL80211_BSS_SELECT_ATTR_RSSI,
	NL80211_BSS_SELECT_ATTR_BAND_PREF,
	NL80211_BSS_SELECT_ATTR_RSSI_ADJUST,

	/* keep last */
	__NL80211_BSS_SELECT_ATTR_AFTER_LAST,
	NL80211_BSS_SELECT_ATTR_MAX = __NL80211_BSS_SELECT_ATTR_AFTER_LAST - 1
};

/**
 * enum nl80211_nan_function_type - NAN function type
 *
 * Defines the function type of a NAN function
 *
 * @NL80211_NAN_FUNC_PUBLISH: function is publish
 * @NL80211_NAN_FUNC_SUBSCRIBE: function is subscribe
 * @NL80211_NAN_FUNC_FOLLOW_UP: function is follow-up
 */
enum nl80211_nan_function_type {
	NL80211_NAN_FUNC_PUBLISH,
	NL80211_NAN_FUNC_SUBSCRIBE,
	NL80211_NAN_FUNC_FOLLOW_UP,

	/* keep last */
	__NL80211_NAN_FUNC_TYPE_AFTER_LAST,
	NL80211_NAN_FUNC_MAX_TYPE = __NL80211_NAN_FUNC_TYPE_AFTER_LAST - 1,
};

/**
 * enum nl80211_nan_publish_type - NAN publish tx type
 *
 * Defines how to send publish Service Discovery Frames
 *
 * @NL80211_NAN_SOLICITED_PUBLISH: publish function is solicited
 * @NL80211_NAN_UNSOLICITED_PUBLISH: publish function is unsolicited
 */
enum nl80211_nan_publish_type {
	NL80211_NAN_SOLICITED_PUBLISH = 1 << 0,
	NL80211_NAN_UNSOLICITED_PUBLISH = 1 << 1,
};

/**
 * enum nl80211_nan_func_term_reason - NAN functions termination reason
 *
 * Defines termination reasons of a NAN function
 *
 * @NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST: requested by user
 * @NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED: timeout
 * @NL80211_NAN_FUNC_TERM_REASON_ERROR: errored
 */
enum nl80211_nan_func_term_reason {
	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST,
	NL80211_NAN_FUNC_TERM_REASON_TTL_EXPIRED,
	NL80211_NAN_FUNC_TERM_REASON_ERROR,
};

#define NL80211_NAN_FUNC_SERVICE_ID_LEN 6
#define NL80211_NAN_FUNC_SERVICE_SPEC_INFO_MAX_LEN 0xff
#define NL80211_NAN_FUNC_SRF_MAX_LEN 0xff

/**
 * enum nl80211_nan_func_attributes - NAN function attributes
 * @__NL80211_NAN_FUNC_INVALID: invalid
 * @NL80211_NAN_FUNC_TYPE: &enum nl80211_nan_function_type (u8).
 * @NL80211_NAN_FUNC_SERVICE_ID: 6 bytes of the service ID hash as
 *	specified in NAN spec. This is a binary attribute.
 * @NL80211_NAN_FUNC_PUBLISH_TYPE: relevant if the function's type is
 *	publish. Defines the transmission type for the publish Service Discovery
 *	Frame, see &enum nl80211_nan_publish_type. Its type is u8.
 * @NL80211_NAN_FUNC_PUBLISH_BCAST: relevant if the function is a solicited
 *	publish. Should the solicited publish Service Discovery Frame be sent to
 *	the NAN Broadcast address. This is a flag.
 * @NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE: relevant if the function's type is
 *	subscribe. Is the subscribe active. This is a flag.
 * @NL80211_NAN_FUNC_FOLLOW_UP_ID: relevant if the function's type is follow up.
 *	The instance ID for the follow up Service Discovery Frame. This is u8.
 * @NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID: relevant if the function's type
 *	is follow up. This is a u8.
 *	The requestor instance ID for the follow up Service Discovery Frame.
 * @NL80211_NAN_FUNC_FOLLOW_UP_DEST: the MAC address of the recipient of the
 *	follow up Service Discovery Frame. This is a binary attribute.
 * @NL80211_NAN_FUNC_CLOSE_RANGE: is this function limited for devices in a
 *	close range. The range itself (RSSI) is defined by the device.
 *	This is a flag.
 * @NL80211_NAN_FUNC_TTL: strictly positive number of DWs this function should
 *	stay active. If not present infinite TTL is assumed. This is a u32.
 * @NL80211_NAN_FUNC_SERVICE_INFO: array of bytes describing the service
 *	specific info. This is a binary attribute.
 * @NL80211_NAN_FUNC_SRF: Service Receive Filter. This is a nested attribute.
 *	See &enum nl80211_nan_srf_attributes.
 * @NL80211_NAN_FUNC_RX_MATCH_FILTER: Receive Matching filter. This is a nested
 *	attribute. It is a list of binary values.
 * @NL80211_NAN_FUNC_TX_MATCH_FILTER: Transmit Matching filter. This is a
 *	nested attribute. It is a list of binary values.
 * @NL80211_NAN_FUNC_INSTANCE_ID: The instance ID of the function.
 *	Its type is u8 and it cannot be 0.
 * @NL80211_NAN_FUNC_TERM_REASON: NAN function termination reason.
 *	See &enum nl80211_nan_func_term_reason.
 *
 * @NUM_NL80211_NAN_FUNC_ATTR: internal
 * @NL80211_NAN_FUNC_ATTR_MAX: highest NAN function attribute
 */
enum nl80211_nan_func_attributes {
	__NL80211_NAN_FUNC_INVALID,
	NL80211_NAN_FUNC_TYPE,
	NL80211_NAN_FUNC_SERVICE_ID,
	NL80211_NAN_FUNC_PUBLISH_TYPE,
	NL80211_NAN_FUNC_PUBLISH_BCAST,
	NL80211_NAN_FUNC_SUBSCRIBE_ACTIVE,
	NL80211_NAN_FUNC_FOLLOW_UP_ID,
	NL80211_NAN_FUNC_FOLLOW_UP_REQ_ID,
	NL80211_NAN_FUNC_FOLLOW_UP_DEST,
	NL80211_NAN_FUNC_CLOSE_RANGE,
	NL80211_NAN_FUNC_TTL,
	NL80211_NAN_FUNC_SERVICE_INFO,
	NL80211_NAN_FUNC_SRF,
	NL80211_NAN_FUNC_RX_MATCH_FILTER,
	NL80211_NAN_FUNC_TX_MATCH_FILTER,
	NL80211_NAN_FUNC_INSTANCE_ID,
	NL80211_NAN_FUNC_TERM_REASON,

	/* keep last */
	NUM_NL80211_NAN_FUNC_ATTR,
	NL80211_NAN_FUNC_ATTR_MAX = NUM_NL80211_NAN_FUNC_ATTR - 1
};

/**
 * enum nl80211_nan_srf_attributes - NAN Service Response filter attributes
 * @__NL80211_NAN_SRF_INVALID: invalid
 * @NL80211_NAN_SRF_INCLUDE: present if the include bit of the SRF set.
 *	This is a flag.
 * @NL80211_NAN_SRF_BF: Bloom Filter. Present if and only if
 *	%NL80211_NAN_SRF_MAC_ADDRS isn't present. This attribute is binary.
 * @NL80211_NAN_SRF_BF_IDX: index of the Bloom Filter. Mandatory if
 *	%NL80211_NAN_SRF_BF is present. This is a u8.
 * @NL80211_NAN_SRF_MAC_ADDRS: list of MAC addresses for the SRF. Present if
 *	and only if %NL80211_NAN_SRF_BF isn't present. This is a nested
 *	attribute. Each nested attribute is a MAC address.
 * @NUM_NL80211_NAN_SRF_ATTR: internal
 * @NL80211_NAN_SRF_ATTR_MAX: highest NAN SRF attribute
 */
enum nl80211_nan_srf_attributes {
	__NL80211_NAN_SRF_INVALID,
	NL80211_NAN_SRF_INCLUDE,
	NL80211_NAN_SRF_BF,
	NL80211_NAN_SRF_BF_IDX,
	NL80211_NAN_SRF_MAC_ADDRS,

	/* keep last */
	NUM_NL80211_NAN_SRF_ATTR,
	NL80211_NAN_SRF_ATTR_MAX = NUM_NL80211_NAN_SRF_ATTR - 1,
};

/**
 * enum nl80211_nan_match_attributes - NAN match attributes
 * @__NL80211_NAN_MATCH_INVALID: invalid
 * @NL80211_NAN_MATCH_FUNC_LOCAL: the local function that had the
 *	match. This is a nested attribute.
 *	See &enum nl80211_nan_func_attributes.
 * @NL80211_NAN_MATCH_FUNC_PEER: the peer function
 *	that caused the match. This is a nested attribute.
 *	See &enum nl80211_nan_func_attributes.
 *
 * @NUM_NL80211_NAN_MATCH_ATTR: internal
 * @NL80211_NAN_MATCH_ATTR_MAX: highest NAN match attribute
 */
enum nl80211_nan_match_attributes {
	__NL80211_NAN_MATCH_INVALID,
	NL80211_NAN_MATCH_FUNC_LOCAL,
	NL80211_NAN_MATCH_FUNC_PEER,

	/* keep last */
	NUM_NL80211_NAN_MATCH_ATTR,
	NL80211_NAN_MATCH_ATTR_MAX = NUM_NL80211_NAN_MATCH_ATTR - 1
};

/**
 * nl80211_external_auth_action - Action to perform with external
 *     authentication request. Used by NL80211_ATTR_EXTERNAL_AUTH_ACTION.
 * @NL80211_EXTERNAL_AUTH_START: Start the authentication.
 * @NL80211_EXTERNAL_AUTH_ABORT: Abort the ongoing authentication.
 */
enum nl80211_external_auth_action {
	NL80211_EXTERNAL_AUTH_START,
	NL80211_EXTERNAL_AUTH_ABORT,
};

/**
 * enum nl80211_ftm_responder_attributes - fine timing measurement
 *	responder attributes
 * @__NL80211_FTM_RESP_ATTR_INVALID: Invalid
 * @NL80211_FTM_RESP_ATTR_ENABLED: FTM responder is enabled
 * @NL80211_FTM_RESP_ATTR_LCI: The content of Measurement Report Element
 *	(9.4.2.22 in 802.11-2016) with type 8 - LCI (9.4.2.22.10),
 *	i.e. starting with the measurement token
 * @NL80211_FTM_RESP_ATTR_CIVIC: The content of Measurement Report Element
 *	(9.4.2.22 in 802.11-2016) with type 11 - Civic (Section 9.4.2.22.13),
 *	i.e. starting with the measurement token
 * @__NL80211_FTM_RESP_ATTR_LAST: Internal
 * @NL80211_FTM_RESP_ATTR_MAX: highest FTM responder attribute.
 */
enum nl80211_ftm_responder_attributes {
	__NL80211_FTM_RESP_ATTR_INVALID,

	NL80211_FTM_RESP_ATTR_ENABLED,
	NL80211_FTM_RESP_ATTR_LCI,
	NL80211_FTM_RESP_ATTR_CIVICLOC,

	/* keep last */
	__NL80211_FTM_RESP_ATTR_LAST,
	NL80211_FTM_RESP_ATTR_MAX = __NL80211_FTM_RESP_ATTR_LAST - 1,
};

/*
 * enum nl80211_ftm_responder_stats - FTM responder statistics
 *
 * These attribute types are used with %NL80211_ATTR_FTM_RESPONDER_STATS
 * when getting FTM responder statistics.
 *
 * @__NL80211_FTM_STATS_INVALID: attribute number 0 is reserved
 * @NL80211_FTM_STATS_SUCCESS_NUM: number of FTM sessions in which all frames
 *	were ssfully answered (u32)
 * @NL80211_FTM_STATS_PARTIAL_NUM: number of FTM sessions in which part of the
 *	frames were successfully answered (u32)
 * @NL80211_FTM_STATS_FAILED_NUM: number of failed FTM sessions (u32)
 * @NL80211_FTM_STATS_ASAP_NUM: number of ASAP sessions (u32)
 * @NL80211_FTM_STATS_NON_ASAP_NUM: number of non-ASAP sessions (u32)
 * @NL80211_FTM_STATS_TOTAL_DURATION_MSEC: total sessions durations - gives an
 *	indication of how much time the responder was busy (u64, msec)
 * @NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM: number of unknown FTM triggers -
 *	triggers from initiators that didn't finish successfully the negotiation
 *	phase with the responder (u32)
 * @NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM: number of FTM reschedule requests
 *	- initiator asks for a new scheduling although it already has scheduled
 *	FTM slot (u32)
 * @NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM: number of FTM triggers out of
 *	scheduled window (u32)
 * @NL80211_FTM_STATS_PAD: used for padding, ignore
 * @__NL80211_TXQ_ATTR_AFTER_LAST: Internal
 * @NL80211_FTM_STATS_MAX: highest possible FTM responder stats attribute
 */
enum nl80211_ftm_responder_stats {
	__NL80211_FTM_STATS_INVALID,
	NL80211_FTM_STATS_SUCCESS_NUM,
	NL80211_FTM_STATS_PARTIAL_NUM,
	NL80211_FTM_STATS_FAILED_NUM,
	NL80211_FTM_STATS_ASAP_NUM,
	NL80211_FTM_STATS_NON_ASAP_NUM,
	NL80211_FTM_STATS_TOTAL_DURATION_MSEC,
	NL80211_FTM_STATS_UNKNOWN_TRIGGERS_NUM,
	NL80211_FTM_STATS_RESCHEDULE_REQUESTS_NUM,
	NL80211_FTM_STATS_OUT_OF_WINDOW_TRIGGERS_NUM,
	NL80211_FTM_STATS_PAD,

	/* keep last */
	__NL80211_FTM_STATS_AFTER_LAST,
	NL80211_FTM_STATS_MAX = __NL80211_FTM_STATS_AFTER_LAST - 1
};

/**
 * enum nl80211_preamble - frame preamble types
 * @NL80211_PREAMBLE_LEGACY: legacy (HR/DSSS, OFDM, ERP PHY) preamble
 * @NL80211_PREAMBLE_HT: HT preamble
 * @NL80211_PREAMBLE_VHT: VHT preamble
 * @NL80211_PREAMBLE_DMG: DMG preamble
 * @NL80211_PREAMBLE_HE: HE preamble
 */
enum nl80211_preamble {
	NL80211_PREAMBLE_LEGACY,
	NL80211_PREAMBLE_HT,
	NL80211_PREAMBLE_VHT,
	NL80211_PREAMBLE_DMG,
	NL80211_PREAMBLE_HE,
};

/**
 * enum nl80211_peer_measurement_type - peer measurement types
 * @NL80211_PMSR_TYPE_INVALID: invalid/unused, needed as we use
 *	these numbers also for attributes
 *
 * @NL80211_PMSR_TYPE_FTM: flight time measurement
 *
 * @NUM_NL80211_PMSR_TYPES: internal
 * @NL80211_PMSR_TYPE_MAX: highest type number
 */
enum nl80211_peer_measurement_type {
	NL80211_PMSR_TYPE_INVALID,

	NL80211_PMSR_TYPE_FTM,

	NUM_NL80211_PMSR_TYPES,
	NL80211_PMSR_TYPE_MAX = NUM_NL80211_PMSR_TYPES - 1
};

/**
 * enum nl80211_peer_measurement_status - peer measurement status
 * @NL80211_PMSR_STATUS_SUCCESS: measurement completed successfully
 * @NL80211_PMSR_STATUS_REFUSED: measurement was locally refused
 * @NL80211_PMSR_STATUS_TIMEOUT: measurement timed out
 * @NL80211_PMSR_STATUS_FAILURE: measurement failed, a type-dependent
 *	reason may be available in the response data
 */
enum nl80211_peer_measurement_status {
	NL80211_PMSR_STATUS_SUCCESS,
	NL80211_PMSR_STATUS_REFUSED,
	NL80211_PMSR_STATUS_TIMEOUT,
	NL80211_PMSR_STATUS_FAILURE,
};

/**
 * enum nl80211_peer_measurement_req - peer measurement request attributes
 * @__NL80211_PMSR_REQ_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_REQ_ATTR_DATA: This is a nested attribute with measurement
 *	type-specific request data inside. The attributes used are from the
 *	enums named nl80211_peer_measurement_<type>_req.
 * @NL80211_PMSR_REQ_ATTR_GET_AP_TSF: include AP TSF timestamp, if supported
 *	(flag attribute)
 *
 * @NUM_NL80211_PMSR_REQ_ATTRS: internal
 * @NL80211_PMSR_REQ_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_req {
	__NL80211_PMSR_REQ_ATTR_INVALID,

	NL80211_PMSR_REQ_ATTR_DATA,
	NL80211_PMSR_REQ_ATTR_GET_AP_TSF,

	/* keep last */
	NUM_NL80211_PMSR_REQ_ATTRS,
	NL80211_PMSR_REQ_ATTR_MAX = NUM_NL80211_PMSR_REQ_ATTRS - 1
};

/**
 * enum nl80211_peer_measurement_resp - peer measurement response attributes
 * @__NL80211_PMSR_RESP_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_RESP_ATTR_DATA: This is a nested attribute with measurement
 *	type-specific results inside. The attributes used are from the enums
 *	named nl80211_peer_measurement_<type>_resp.
 * @NL80211_PMSR_RESP_ATTR_STATUS: u32 value with the measurement status
 *	(using values from &enum nl80211_peer_measurement_status.)
 * @NL80211_PMSR_RESP_ATTR_HOST_TIME: host time (%CLOCK_BOOTTIME) when the
 *	result was measured; this value is not expected to be accurate to
 *	more than 20ms. (u64, nanoseconds)
 * @NL80211_PMSR_RESP_ATTR_AP_TSF: TSF of the AP that the interface
 *	doing the measurement is connected to when the result was measured.
 *	This shall be accurately reported if supported and requested
 *	(u64, usec)
 * @NL80211_PMSR_RESP_ATTR_FINAL: If results are sent to the host partially
 *	(*e.g. with FTM per-burst data) this flag will be cleared on all but
 *	the last result; if all results are combined it's set on the single
 *	result.
 * @NL80211_PMSR_RESP_ATTR_PAD: padding for 64-bit attributes, ignore
 *
 * @NUM_NL80211_PMSR_RESP_ATTRS: internal
 * @NL80211_PMSR_RESP_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_resp {
	__NL80211_PMSR_RESP_ATTR_INVALID,

	NL80211_PMSR_RESP_ATTR_DATA,
	NL80211_PMSR_RESP_ATTR_STATUS,
	NL80211_PMSR_RESP_ATTR_HOST_TIME,
	NL80211_PMSR_RESP_ATTR_AP_TSF,
	NL80211_PMSR_RESP_ATTR_FINAL,
	NL80211_PMSR_RESP_ATTR_PAD,

	/* keep last */
	NUM_NL80211_PMSR_RESP_ATTRS,
	NL80211_PMSR_RESP_ATTR_MAX = NUM_NL80211_PMSR_RESP_ATTRS - 1
};

/**
 * enum nl80211_peer_measurement_peer_attrs - peer attributes for measurement
 * @__NL80211_PMSR_PEER_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_PEER_ATTR_ADDR: peer's MAC address
 * @NL80211_PMSR_PEER_ATTR_CHAN: channel definition, nested, using top-level
 *	attributes like %NL80211_ATTR_WIPHY_FREQ etc.
 * @NL80211_PMSR_PEER_ATTR_REQ: This is a nested attribute indexed by
 *	measurement type, with attributes from the
 *	&enum nl80211_peer_measurement_req inside.
 * @NL80211_PMSR_PEER_ATTR_RESP: This is a nested attribute indexed by
 *	measurement type, with attributes from the
 *	&enum nl80211_peer_measurement_resp inside.
 *
 * @NUM_NL80211_PMSR_PEER_ATTRS: internal
 * @NL80211_PMSR_PEER_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_peer_attrs {
	__NL80211_PMSR_PEER_ATTR_INVALID,

	NL80211_PMSR_PEER_ATTR_ADDR,
	NL80211_PMSR_PEER_ATTR_CHAN,
	NL80211_PMSR_PEER_ATTR_REQ,
	NL80211_PMSR_PEER_ATTR_RESP,

	/* keep last */
	NUM_NL80211_PMSR_PEER_ATTRS,
	NL80211_PMSR_PEER_ATTR_MAX = NUM_NL80211_PMSR_PEER_ATTRS - 1,
};

/**
 * enum nl80211_peer_measurement_attrs - peer measurement attributes
 * @__NL80211_PMSR_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_ATTR_MAX_PEERS: u32 attribute used for capability
 *	advertisement only, indicates the maximum number of peers
 *	measurements can be done with in a single request
 * @NL80211_PMSR_ATTR_REPORT_AP_TSF: flag attribute in capability
 *	indicating that the connected AP's TSF can be reported in
 *	measurement results
 * @NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR: flag attribute in capability
 *	indicating that MAC address randomization is supported.
 * @NL80211_PMSR_ATTR_TYPE_CAPA: capabilities reported by the device,
 *	this contains a nesting indexed by measurement type, and
 *	type-specific capabilities inside, which are from the enums
 *	named nl80211_peer_measurement_<type>_capa.
 * @NL80211_PMSR_ATTR_PEERS: nested attribute, the nesting index is
 *	meaningless, just a list of peers to measure with, with the
 *	sub-attributes taken from
 *	&enum nl80211_peer_measurement_peer_attrs.
 *
 * @NUM_NL80211_PMSR_ATTR: internal
 * @NL80211_PMSR_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_attrs {
	__NL80211_PMSR_ATTR_INVALID,

	NL80211_PMSR_ATTR_MAX_PEERS,
	NL80211_PMSR_ATTR_REPORT_AP_TSF,
	NL80211_PMSR_ATTR_RANDOMIZE_MAC_ADDR,
	NL80211_PMSR_ATTR_TYPE_CAPA,
	NL80211_PMSR_ATTR_PEERS,

	/* keep last */
	NUM_NL80211_PMSR_ATTR,
	NL80211_PMSR_ATTR_MAX = NUM_NL80211_PMSR_ATTR - 1
};

/**
 * enum nl80211_peer_measurement_ftm_capa - FTM capabilities
 * @__NL80211_PMSR_FTM_CAPA_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_FTM_CAPA_ATTR_ASAP: flag attribute indicating ASAP mode
 *	is supported
 * @NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP: flag attribute indicating non-ASAP
 *	mode is supported
 * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI: flag attribute indicating if LCI
 *	data can be requested during the measurement
 * @NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC: flag attribute indicating if civic
 *	location data can be requested during the measurement
 * @NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES: u32 bitmap attribute of bits
 *	from &enum nl80211_preamble.
 * @NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS: bitmap of values from
 *	&enum nl80211_chan_width indicating the supported channel
 *	bandwidths for FTM. Note that a higher channel bandwidth may be
 *	configured to allow for other measurements types with different
 *	bandwidth requirement in the same measurement.
 * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT: u32 attribute indicating
 *	the maximum bursts exponent that can be used (if not present anything
 *	is valid)
 * @NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST: u32 attribute indicating
 *	the maximum FTMs per burst (if not present anything is valid)
 * @NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED: flag attribute indicating if
 *	trigger based ranging measurement is supported
 * @NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED: flag attribute indicating
 *	if non trigger based ranging measurement is supported
 *
 * @NUM_NL80211_PMSR_FTM_CAPA_ATTR: internal
 * @NL80211_PMSR_FTM_CAPA_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_ftm_capa {
	__NL80211_PMSR_FTM_CAPA_ATTR_INVALID,

	NL80211_PMSR_FTM_CAPA_ATTR_ASAP,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_ASAP,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_LCI,
	NL80211_PMSR_FTM_CAPA_ATTR_REQ_CIVICLOC,
	NL80211_PMSR_FTM_CAPA_ATTR_PREAMBLES,
	NL80211_PMSR_FTM_CAPA_ATTR_BANDWIDTHS,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_BURSTS_EXPONENT,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX_FTMS_PER_BURST,
	NL80211_PMSR_FTM_CAPA_ATTR_TRIGGER_BASED,
	NL80211_PMSR_FTM_CAPA_ATTR_NON_TRIGGER_BASED,

	/* keep last */
	NUM_NL80211_PMSR_FTM_CAPA_ATTR,
	NL80211_PMSR_FTM_CAPA_ATTR_MAX = NUM_NL80211_PMSR_FTM_CAPA_ATTR - 1
};

/**
 * enum nl80211_peer_measurement_ftm_req - FTM request attributes
 * @__NL80211_PMSR_FTM_REQ_ATTR_INVALID: invalid
 *
 * @NL80211_PMSR_FTM_REQ_ATTR_ASAP: ASAP mode requested (flag)
 * @NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE: preamble type (see
 *	&enum nl80211_preamble), optional for DMG (u32)
 * @NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP: number of bursts exponent as in
 *	802.11-2016 9.4.2.168 "Fine Timing Measurement Parameters element"
 *	(u8, 0-15, optional with default 15 i.e. "no preference")
 * @NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD: interval between bursts in units
 *	of 100ms (u16, optional with default 0)
 * @NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION: burst duration, as in 802.11-2016
 *	Table 9-257 "Burst Duration field encoding" (u8, 0-15, optional with
 *	default 15 i.e. "no preference")
 * @NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST: number of successful FTM frames
 *	requested per burst
 *	(u8, 0-31, optional with default 0 i.e. "no preference")
 * @NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES: number of FTMR frame retries
 *	(u8, default 3)
 * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI: request LCI data (flag)
 * @NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC: request civic location data
 *	(flag)
 * @NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED: request trigger based ranging
 *	measurement (flag).
 *	This attribute and %NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED are
 *	mutually exclusive.
 *      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor
 *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based
 *	ranging will be used.
 * @NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED: request non trigger based
 *	ranging measurement (flag)
 *	This attribute and %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED are
 *	mutually exclusive.
 *      if neither %NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED nor
 *	%NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED is set, EDCA based
 *	ranging will be used.
 *
 * @NUM_NL80211_PMSR_FTM_REQ_ATTR: internal
 * @NL80211_PMSR_FTM_REQ_ATTR_MAX: highest attribute number
 */
enum nl80211_peer_measurement_ftm_req {
	__NL80211_PMSR_FTM_REQ_ATTR_INVALID,

	NL80211_PMSR_FTM_REQ_ATTR_ASAP,
	NL80211_PMSR_FTM_REQ_ATTR_PREAMBLE,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_BURSTS_EXP,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_PERIOD,
	NL80211_PMSR_FTM_REQ_ATTR_BURST_DURATION,
	NL80211_PMSR_FTM_REQ_ATTR_FTMS_PER_BURST,
	NL80211_PMSR_FTM_REQ_ATTR_NUM_FTMR_RETRIES,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_LCI,
	NL80211_PMSR_FTM_REQ_ATTR_REQUEST_CIVICLOC,
	NL80211_PMSR_FTM_REQ_ATTR_TRIGGER_BASED,
	NL80211_PMSR_FTM_REQ_ATTR_NON_TRIGGER_BASED,

	/* keep last */
	NUM_NL80211_PMSR_FTM_REQ_ATTR,
	NL80211_PMSR_FTM_REQ_ATTR_MAX = NUM_NL80211_PMSR_FTM_REQ_ATTR - 1
};

/**
 * enum nl80211_peer_measurement_ftm_failure_reasons - FTM failure reasons
 * @NL80211_PMSR_FTM_FAILURE_UNSPECIFIED: unspecified failure, not used
 * @NL80211_PMSR_FTM_FAILURE_NO_RESPONSE: no response from the FTM responder
 * @NL80211_PMSR_FTM_FAILURE_REJECTED: FTM responder rejected measurement
 * @NL80211_PMSR_FTM_FAILURE_WRONG_CHANNEL: we already know the peer is
 *	on a different channel, so can't measure (if we didn't know, we'd
 *	try and get no response)
 * @NL80211_PMSR_FTM_FAILURE_PEER_NOT_CAPABLE: peer can't actually do FTM
 * @NL80211_PMSR_FTM_FAILURE_INVALID_TIMESTAMP: invalid T1/T4 timestamps
 *	received
 * @NL80211_PMSR_FTM_FAILURE_PEER_BUSY: peer reports busy, you may retry
 *	later (see %NL80211_PMSR_FTM_RESP_ATTR_BUSY_RETRY_TIME)
 * @NL80211_PMSR_FTM_FAILURE_BAD_CHANGED_PARAMS: parameters were changed
 *	by the peer and are no 