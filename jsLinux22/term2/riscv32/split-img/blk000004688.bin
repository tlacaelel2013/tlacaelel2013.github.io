}

  inline void
  __set_max_mem()
  {
    _GLIBCXX_PROFILE_DATA(_S_max_mem) 
      = __env_to_size_t(_GLIBCXX_PROFILE_MEM_PER_DIAGNOSTIC_ENV_VAR,
			_GLIBCXX_PROFILE_DATA(_S_max_mem));
  }

  inline int
  __log_magnitude(float __f)
  {
    const float __log_base = 10.0;
    int __result = 0;
    int __sign = 1;

    if (__f < 0) 
      {
	__f = -__f;
	__sign = -1;
      }

    while (__f > __log_base) 
      {
	++__result;
	__f /= 10.0;
      }
    return __sign * __result;
  }

  inline FILE* 
  __open_output_file(const char* __extension)
  {
    // The path is made of _S_trace_file_name + "." + extension.
    std::size_t __root_len 
      = __builtin_strlen(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));
    std::size_t __ext_len = __builtin_strlen(__extension);
    char* __file_name = new char[__root_len + 1 + __ext_len + 1];
    __builtin_memcpy(__file_name,
		     _GLIBCXX_PROFILE_DATA(_S_trace_file_name),
		     __root_len);
    *(__file_name + __root_len) = '.';
    __builtin_memcpy(__file_name + __root_len + 1,
		     __extension, __ext_len + 1);

    FILE* __out_file = std::fopen(__file_name, "w");
    if (!__out_file)
      {
	std::fprintf(stderr, "Could not open trace file '%s'.\n",
		     __file_name);
	std::abort();
      }

    delete[] __file_name;
    return __out_file;
  }

  struct __warn
  {
    FILE* __file;

    __warn(FILE* __f)
    { __file = __f; }

    void
    operator()(const __warning_data& __info)
    {
      std::fprintf(__file,  __info.__warning_id);
      std::fprintf(__file, ": improvement = %d",
		   __log_magnitude(__info.__magnitude));
      std::fprintf(__file, ": call stack = ");
      __gnu_profile::__write(__file, __info.__context);
      std::fprintf(__file, ": advice = %s\n",
		   __info.__warning_message.c_str());
    }
  };

  /** @brief Final report method, registered with @b atexit.
   *
   * This can also be called directly by user code, including signal handlers.
   * It is protected against deadlocks by the reentrance guard in profiler.h.
   * However, when called from a signal handler that triggers while within
   * __gnu_profile (under the guarded zone), no output will be produced.
   */
  inline void
  __report()
  {
    __gnu_cxx::__scoped_lock __lock(_GLIBCXX_PROFILE_DATA(__global_mutex));

    __warning_vector_t __warnings, __top_warnings;

    FILE* __raw_file = __open_output_file("raw");
    __trace_vector_size_report(__raw_file, __warnings);
    __trace_hashtable_size_report(__raw_file, __warnings);
    __trace_hash_func_report(__raw_file, __warnings);
    __trace_vector_to_list_report(__raw_file, __warnings);
    __trace_list_to_slist_report(__raw_file, __warnings);
    __trace_list_to_vector_report(__raw_file, __warnings);
    __trace_map_to_unordered_map_report(__raw_file, __warnings);
    std::fclose(__raw_file);

    // Sort data by magnitude, keeping just top N.
    std::size_t __cutoff = std::min(_GLIBCXX_PROFILE_DATA(_S_max_warn_count),
				    __warnings.size());
    __top_n(__warnings, __top_warnings, __cutoff);

    FILE* __warn_file = __open_output_file("txt");
    __for_each(__top_warnings.begin(), __top_warnings.end(),
	       __warn(__warn_file));
    std::fclose(__warn_file);
  }

  inline void
  __report_and_free()
  {
    __report();

    __trace_map_to_unordered_map_free();
    __trace_list_to_vector_free();
    __trace_list_to_slist_free(); 
    __trace_vector_to_list_free();
    __trace_hash_func_free();
    __trace_hashtable_size_free();
    __trace_vector_size_free();
    delete _GLIBCXX_PROFILE_DATA(__cost_factors);
  }

  inline void
  __set_trace_path()
  {
    char* __env_trace_file_name = std::getenv(_GLIBCXX_PROFILE_TRACE_ENV_VAR);

    if (__env_trace_file_name)
      _GLIBCXX_PROFILE_DATA(_S_trace_file_name) = __env_trace_file_name;

    // Make sure early that we can create the trace file.
    std::fclose(__open_output_file("txt"));
  }

  inline void
  __set_max_warn_count()
  {
    char* __env_max_warn_count_str
      = std::getenv(_GLIBCXX_PROFILE_MAX_WARN_COUNT_ENV_VAR);

    if (__env_max_warn_count_str)
      _GLIBCXX_PROFILE_DATA(_S_max_warn_count)
	= static_cast<std::size_t>(std::atoi(__env_max_warn_count_str));
  }

  inline void
  __read_cost_factors()
  {
    std::string __conf_file_name(_GLIBCXX_PROFILE_DATA(_S_trace_file_name));
    __conf_file_name += ".conf";

    std::ifstream __conf_file(__conf_file_name.c_str());

    if (__conf_file.is_open())
      {
	std::string __line;

	while (std::getline(__conf_file, __line))
	  {
	    std::string::size_type __i = __line.find_first_not_of(" \t\n\v");

	    if (__line.length() <= 0 || __line[__i] == '#')
	      // Skip empty lines or comments.
	      continue;
	  }

	// Trim.
	__line.erase(__remove(__line.begin(), __line.end(), ' '),
		     __line.end());
	std::string::size_type __pos = __line.find("=");
	std::string __factor_name = __line.substr(0, __pos);
	std::string::size_type __end = __line.find_first_of(";\n");
	std::string __factor_value = __line.substr(__pos + 1, __end - __pos);

	_GLIBCXX_PROFILE_DATA(__env)[__factor_name] = __factor_value;
      }
  }

  struct __cost_factor_writer
  {
    FILE* __file;

    __cost_factor_writer(FILE* __f)
    : __file(__f) { }

    void
    operator() (const __cost_factor* __factor)
    { std::fprintf(__file, "%s = %f\n", __factor->__env_var,
		   __factor->__value); }
  };

  inline void
  __write_cost_factors()
  {
    FILE* __file = __open_output_file("conf.out");
    __for_each(_GLIBCXX_PROFILE_DATA(__cost_factors)->begin(),
	       _GLIBCXX_PROFILE_DATA(__cost_factors)->end(),
	       __cost_factor_writer(__file));
    std::fclose(__file);
  }

  struct __cost_factor_setter
  {
    void
    operator()(__cost_factor* __factor)
    {
      // Look it up in the process environment first.
      const char* __env_value = std::getenv(__factor->__env_var);

      if (!__env_value)
	{
	  // Look it up in the config file.
	  __env_t::iterator __it
	    = _GLIBCXX_PROFILE_DATA(__env).find(__factor->__env_var);
	  if (__it != _GLIBCXX_PROFILE_DATA(__env).end())
	    __env_value = __it->second.c_str();
	}

      if (__env_value)
	__factor->__value = std::atof(__env_value);
    }
  };

  inline void
  __set_cost_factors()
  {
    __cost_factor_vector* __factors = new __cost_factor_vector;
    _GLIBCXX_PROFILE_DATA(__cost_factors) = __factors;
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__list_shift_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__list_resize_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__map_insert_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__map_erase_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__map_find_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__map_iterate_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__umap_insert_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__umap_erase_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__umap_find_cost_factor));
    __factors->push_back(&_GLIBCXX_PROFILE_DATA(__umap_iterate_cost_factor));
    __for_each(__factors->begin(), __factors->end(), __cost_factor_setter());
  }

  inline void
  __profcxx_init_unconditional()
  {
    __gnu_cxx::__scoped_lock __lock(_GLIBCXX_PROFILE_DATA(__global_mutex));

    if (__is_invalid())
      {
	__set_max_warn_count();

	if (_GLIBCXX_PROFILE_DATA(_S_max_warn_count) == 0)
	  __turn_off();
	else
	  {
	    __set_max_stack_trace_depth();
	    __set_max_mem();
	    __set_trace_path();
	    __read_cost_factors(); 
	    __set_cost_factors();
	    __write_cost_factors();

	    __trace_vector_size_init();
	    __trace_hashtable_size_init();
	    __trace_hash_func_init();
	    __trace_vector_to_list_init();
	    __trace_list_to_slist_init(); 
	    __trace_list_to_vector_init();
	    __trace_map_to_unordered_map_init();

	    std::atexit(__report_and_free);

	    __turn_on();
	  }
      }
  }

  /** @brief This function must be called by each instrumentation point.
   *
   * The common path is inlined fully.
   */
  inline bool
  __profcxx_init()
  {
    if (__is_invalid())
      __profcxx_init_unconditional();

    return __is_on();
  }

} // namespace __gnu_profile

#endif /* _GLIBCXX_PROFILE_PROFILER_TRACE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     // -*- C++ -*-
//
// Copyright (C) 2009-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

/** @file profile/impl/profiler_vector_size.h
 *  @brief Collection of vector size traces.
 */

// Written by Lixia Liu and Silvius Rus.

#ifndef _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H
#define _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H 1

#include "profile/impl/profiler.h"
#include "profile/impl/profiler_node.h"
#include "profile/impl/profiler_trace.h"
#include "profile/impl/profiler_state.h"
#include "profile/impl/profiler_container_size.h"

namespace __gnu_profile
{
  /** @brief Hashtable size instrumentation trace producer.  */
  class __trace_vector_size
  : public __trace_container_size
  {
  public:
    __trace_vector_size()
    : __trace_container_size()
    { __id = "vector-size"; }
  };

  inline void
  __trace_vector_size_init()
  { _GLIBCXX_PROFILE_DATA(_S_vector_size) = new __trace_vector_size(); }

  inline void
  __trace_vector_size_free()
  { delete _GLIBCXX_PROFILE_DATA(_S_vector_size); }

  inline void
  __trace_vector_size_report(FILE* __f, __warning_vector_t& __warnings)
  { __trace_report(_GLIBCXX_PROFILE_DATA(_S_vector_size), __f, __warnings); }

  inline __container_size_info*
  __trace_vector_size_construct(std::size_t __num)
  {
    if (!__profcxx_init())
      return 0;

    if (!__reentrance_guard::__get_in())
      return 0;

    __reentrance_guard __get_out;
    return _GLIBCXX_PROFILE_DATA(_S_vector_size)->
      __insert(__get_stack(), __num);
  }

  inline void
  __trace_vector_size_resize(__container_size_info* __obj_info,
			     std::size_t __from, std::size_t __to)
  {
    if (!__obj_info)
      return;

    __obj_info->__resize(__from, __to);
  }

  inline void
  __trace_vector_size_destruct(__container_size_info* __obj_info,
			       std::size_t __num, std::size_t __inum)
  {
    if (!__obj_info)
      return;

    _GLIBCXX_PROFILE_DATA(_S_vector_size)->
      __destruct(__obj_info, __num, __inum);
  }

} // namespace __gnu_profile

#endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_SIZE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // -*- C++ -*-
//
// Copyright (C) 2009-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.
//
// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License along
// with this library; see the file COPYING3.  If not see
// <http://www.gnu.org/licenses/>.

/** @file profile/impl/profiler_vector_to_list.h
 *  @brief diagnostics for vector to list.
 */

// Written by Lixia Liu and Silvius Rus.

#ifndef _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H
#define _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H 1

#include "profile/impl/profiler.h"
#include "profile/impl/profiler_node.h"
#include "profile/impl/profiler_trace.h"

namespace __gnu_profile
{
  /** @brief A vector-to-list instrumentation line in the object table.  */
  class __vector2list_info
  : public __object_info_base
  {
  public:
    __vector2list_info(__stack_t __stack)
    : __object_info_base(__stack), _M_shift_count(0), _M_iterate(0),
      _M_resize(0), _M_list_cost(0), _M_vector_cost(0)
    { }

    void
    __merge(const __vector2list_info& __o)
    {
      __object_info_base::__merge(__o);
      _M_shift_count  += __o._M_shift_count;
      _M_iterate      += __o._M_iterate;
      _M_vector_cost  += __o._M_vector_cost;
      _M_list_cost    += __o._M_list_cost;
      _M_resize       += __o._M_resize;
    }

    void
    __write(FILE* __f) const
    {
      std::fprintf(__f, "%Zu %Zu %Zu %.0f %.0f\n", _M_shift_count,
		   _M_resize, _M_iterate, _M_vector_cost, _M_list_cost);
    }

    float
    __magnitude() const
    { return _M_vector_cost - _M_list_cost; }

    std::string
    __advice() const 
    { return "change std::vector to std::list"; }

    std::size_t
    __shift_count()
    { return _M_shift_count; }

    std::size_t
    __iterate()
    { return _M_iterate; }

    float
    __list_cost()
    { return _M_list_cost; }

    std::size_t
    __resize()
    { return _M_resize; }

    void
    __set_list_cost(float __lc)
    { _M_list_cost = __lc; }
    
    void
    __set_vector_cost(float __vc)
    { _M_vector_cost = __vc; }
    
    void
    __opr_insert(std::size_t __pos, std::size_t __num)
    { _M_shift_count += __num - __pos; }

    void
    __opr_iterate(int __num)
    { __gnu_cxx::__atomic_add(&_M_iterate, __num); }

    void
    __resize(std::size_t __from, std::size_t)
    { _M_resize += __from; }

  private:
    std::size_t _M_shift_count;
    mutable _Atomic_word _M_iterate;
    std::size_t _M_resize;
    float _M_list_cost;
    float _M_vector_cost;
  };


  /** @brief A vector-to-list instrumentation line in the stack table.  */
  class __vector2list_stack_info
  : public __vector2list_info
  {
  public:
    __vector2list_stack_info(const __vector2list_info& __o) 
    : __vector2list_info(__o) { }
  };


  /** @brief Vector-to-list instrumentation producer.  */
  class __trace_vector_to_list
  : public __trace_base<__vector2list_info, __vector2list_stack_info> 
  {
  public:
    __trace_vector_to_list()
    : __trace_base<__vector2list_info, __vector2list_stack_info>()
    { __id = "vector-to-list"; }

    ~__trace_vector_to_list() { }

    // Call at destruction/clean to set container final size.
    void
    __destruct(__vector2list_info* __obj_info)
    {
      float __vc = __vector_cost(__obj_info->__shift_count(),
				 __obj_info->__iterate(),
				 __obj_info->__resize());
      float __lc = __list_cost(__obj_info->__shift_count(),
			       __obj_info->__iterate(),
			       __obj_info->__resize());
      __obj_info->__set_vector_cost(__vc);
      __obj_info->__set_list_cost(__lc);

      __retire_object(__obj_info);
    }

    // Collect cost of operations.
    float
    __vector_cost(std::size_t __shift, std::size_t __iterate,
		  std::size_t __resize)
    {
      return (__shift
	      * _GLIBCXX_PROFILE_DATA(__vector_shift_cost_factor).__value
	      + __iterate
	      * _GLIBCXX_PROFILE_DATA(__vector_iterate_cost_factor).__value
	      + __resize
	      * _GLIBCXX_PROFILE_DATA(__vector_resize_cost_factor).__value);
    }

    float
    __list_cost(std::size_t __shift, std::size_t __iterate,
		std::size_t __resize)
    {
      return (__shift
	      * _GLIBCXX_PROFILE_DATA(__list_shift_cost_factor).__value
	      + __iterate
	      * _GLIBCXX_PROFILE_DATA(__list_iterate_cost_factor).__value
	      + __resize
	      * _GLIBCXX_PROFILE_DATA(__list_resize_cost_factor).__value);
    }
  };


  inline void
  __trace_vector_to_list_init()
  { _GLIBCXX_PROFILE_DATA(_S_vector_to_list) = new __trace_vector_to_list(); }

  inline void
  __trace_vector_to_list_free()
  { delete _GLIBCXX_PROFILE_DATA(_S_vector_to_list); }

  inline void
  __trace_vector_to_list_report(FILE* __f, __warning_vector_t& __warnings)
  { __trace_report(_GLIBCXX_PROFILE_DATA(_S_vector_to_list), __f, __warnings); }

  inline __vector2list_info*
  __trace_vector_to_list_construct()
  {
    if (!__profcxx_init())
      return 0;

    if (!__reentrance_guard::__get_in())
      return 0;

    __reentrance_guard __get_out;
    return _GLIBCXX_PROFILE_DATA(_S_vector_to_list)
      ->__add_object(__get_stack());
  }

  inline void
  __trace_vector_to_list_insert(__vector2list_info* __obj_info,
				std::size_t __pos,
				std::size_t __num)
  {
    if (!__obj_info)
      return;

    __obj_info->__opr_insert(__pos, __num);
  }

  inline void
  __trace_vector_to_list_iterate(__vector2list_info* __obj_info, int)
  {
    if (!__obj_info)
      return;

    // We only collect if an iteration took place no matter in what side.
    __obj_info->__opr_iterate(1);
  }

  inline void
  __trace_vector_to_list_invalid_operator(__vector2list_info* __obj_info)
  {
    if (!__obj_info)
      return;

    __obj_info->__set_invalid();
  }

  inline void
  __trace_vector_to_list_resize(__vector2list_info* __obj_info,
				std::size_t __from,
				std::size_t __to)
  {
    if (!__obj_info)
      return;

    __obj_info->__resize(__from, __to);
  }

  inline void
  __trace_vector_to_list_destruct(__vector2list_info* __obj_info)
  {
    if (!__obj_info)
      return;

    _GLIBCXX_PROFILE_DATA(_S_vector_to_list)->__destruct(__obj_info);
  }

} // namespace __gnu_profile
#endif /* _GLIBCXX_PROFILE_PROFILER_VECTOR_TO_LIST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // Profiling iterator implementation -*- C++ -*-

// Copyright (C) 2009-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file profile/iterator_tracker.h
 *  This file is a GNU profile extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_PROFILE_ITERATOR_TRACKER
#define _GLIBCXX_PROFILE_ITERATOR_TRACKER 1

#include <ext/type_traits.h>

namespace std _GLIBCXX_VISIBILITY(default)
{
namespace __profile
{
  template<typename _Iterator, typename _Sequence>
    class __iterator_tracker
    {
      typedef __iterator_tracker _Self;

      // The underlying iterator
      _Iterator _M_current;

      // The underlying data structure
      const _Sequence* _M_ds;
      typedef std::iterator_traits<_Iterator> _Traits;

    public:
      typedef _Iterator					_Base_iterator;
      typedef typename _Traits::iterator_category	iterator_category;
      typedef typename _Traits::value_type		value_type;
      typedef typename _Traits::difference_type		difference_type;
      typedef typename _Traits::reference		reference;
      typedef typename _Traits::pointer			pointer;

      __iterator_tracker() _GLIBCXX_NOEXCEPT
      : _M_current(), _M_ds(0) { }

      __iterator_tracker(const _Iterator& __i, const _Sequence* __seq)
      _GLIBCXX_NOEXCEPT
      : _M_current(__i), _M_ds(__seq) { }

      __iterator_tracker(const __iterator_tracker& __x) _GLIBCXX_NOEXCEPT
      : _M_current(__x._M_current), _M_ds(__x._M_ds) { }

      template<typename _MutableIterator>
	__iterator_tracker(const __iterator_tracker<_MutableIterator,
			   typename __gnu_cxx::__enable_if
			   <(std::__are_same<_MutableIterator, typename
			     _Sequence::iterator::_Base_iterator>::__value),
			   _Sequence>::__type>& __x) _GLIBCXX_NOEXCEPT
	:  _M_current(__x.base()), _M_ds(__x._M_get_sequence()) { }

      _Iterator
      base() const _GLIBCXX_NOEXCEPT { return _M_current; }

      /**
       * @brief Conversion to underlying non-debug iterator to allow
       * better interaction with non-profile containers.
       */
      operator _Iterator() const _GLIBCXX_NOEXCEPT { return _M_current; }

      pointer
      operator->() const _GLIBCXX_NOEXCEPT { return &*_M_current; }

      __iterator_tracker&
      operator++() _GLIBCXX_NOEXCEPT
      {
	_M_ds->_M_profile_iterate();
	++_M_current;
	return *this;
      }

      __iterator_tracker
      operator++(int) _GLIBCXX_NOEXCEPT
      {
	_M_ds->_M_profile_iterate();
	__iterator_tracker __tmp(*this);
	++_M_current;
	return __tmp;
      }

      __iterator_tracker&
      operator--() _GLIBCXX_NOEXCEPT
      {
	_M_ds->_M_profile_iterate(1);
	--_M_current;
	return *this;
      }

      __iterator_tracker
      operator--(int) _GLIBCXX_NOEXCEPT
      {
	_M_ds->_M_profile_iterate(1);
	__iterator_tracker __tmp(*this);
	--_M_current;
	return __tmp;
      }

      __iterator_tracker&
      operator=(const __iterator_tracker& __x) _GLIBCXX_NOEXCEPT
      {
	_M_current = __x._M_current;
	_M_ds = __x._M_ds;
	return *this;
      }

      reference
      operator*() const _GLIBCXX_NOEXCEPT
      { return *_M_current; }

      // ------ Random access iterator requirements ------
      reference
      operator[](const difference_type& __n) const  _GLIBCXX_NOEXCEPT
      { return _M_current[__n]; }

      __iterator_tracker&
      operator+=(const difference_type& __n) _GLIBCXX_NOEXCEPT
      {
	_M_current += __n;
	return *this;
      }

      __iterator_tracker
      operator+(const difference_type& __n) const _GLIBCXX_NOEXCEPT
      {
	__iterator_tracker __tmp(*this);
	__tmp += __n;
	return __tmp;
      }

      __iterator_tracker&
      operator-=(const difference_type& __n) _GLIBCXX_NOEXCEPT
      {
	_M_current += -__n;
	return *this;
      }

      __iterator_tracker
      operator-(const difference_type& __n) const _GLIBCXX_NOEXCEPT
      {
	__iterator_tracker __tmp(*this);
	__tmp -= __n;
	return __tmp;
      }

      const _Sequence*
      _M_get_sequence() const
      { return static_cast<const _Sequence*>(_M_ds); }
  };

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator==(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	       const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator==(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	       const __iterator_tracker<_Iterator, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator!=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	       const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator!=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	       const __iterator_tracker<_Iterator, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() != __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator<(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	      const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator<(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	      const __iterator_tracker<_Iterator, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator<=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	       const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator<=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	       const __iterator_tracker<_Iterator, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator>(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	      const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator>(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	      const __iterator_tracker<_Iterator, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Sequence>
    inline bool
    operator>=(const __iterator_tracker<_IteratorL, _Sequence>& __lhs,
	       const __iterator_tracker<_IteratorR, _Sequence>& __rhs)
    _GLIBCXX_NOEXCEPT
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Sequence>
    inline bool
    operator>=(const __iterator_tracker<_Iterator, _Sequence>& __lhs,
	      