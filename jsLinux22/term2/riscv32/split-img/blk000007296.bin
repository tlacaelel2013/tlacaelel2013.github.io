ine I915_CONTEXT_PARAM_BAN_PERIOD	0x1
#define I915_CONTEXT_PARAM_NO_ZEROMAP	0x2
#define I915_CONTEXT_PARAM_GTT_SIZE	0x3
#define I915_CONTEXT_PARAM_NO_ERROR_CAPTURE	0x4
#define I915_CONTEXT_PARAM_BANNABLE	0x5
#define I915_CONTEXT_PARAM_PRIORITY	0x6
#define   I915_CONTEXT_MAX_USER_PRIORITY	1023 /* inclusive */
#define   I915_CONTEXT_DEFAULT_PRIORITY		0
#define   I915_CONTEXT_MIN_USER_PRIORITY	-1023 /* inclusive */
	/*
	 * When using the following param, value should be a pointer to
	 * drm_i915_gem_context_param_sseu.
	 */
#define I915_CONTEXT_PARAM_SSEU		0x7

/*
 * Not all clients may want to attempt automatic recover of a context after
 * a hang (for example, some clients may only submit very small incremental
 * batches relying on known logical state of previous batches which will never
 * recover correctly and each attempt will hang), and so would prefer that
 * the context is forever banned instead.
 *
 * If set to false (0), after a reset, subsequent (and in flight) rendering
 * from this context is discarded, and the client will need to create a new
 * context to use instead.
 *
 * If set to true (1), the kernel will automatically attempt to recover the
 * context by skipping the hanging batch and executing the next batch starting
 * from the default context state (discarding the incomplete logical context
 * state lost due to the reset).
 *
 * On creation, all new contexts are marked as recoverable.
 */
#define I915_CONTEXT_PARAM_RECOVERABLE	0x8

	/*
	 * The id of the associated virtual memory address space (ppGTT) of
	 * this context. Can be retrieved and passed to another context
	 * (on the same fd) for both to use the same ppGTT and so share
	 * address layouts, and avoid reloading the page tables on context
	 * switches between themselves.
	 *
	 * See DRM_I915_GEM_VM_CREATE and DRM_I915_GEM_VM_DESTROY.
	 */
#define I915_CONTEXT_PARAM_VM		0x9

/*
 * I915_CONTEXT_PARAM_ENGINES:
 *
 * Bind this context to operate on this subset of available engines. Henceforth,
 * the I915_EXEC_RING selector for DRM_IOCTL_I915_GEM_EXECBUFFER2 operates as
 * an index into this array of engines; I915_EXEC_DEFAULT selecting engine[0]
 * and upwards. Slots 0...N are filled in using the specified (class, instance).
 * Use
 *	engine_class: I915_ENGINE_CLASS_INVALID,
 *	engine_instance: I915_ENGINE_CLASS_INVALID_NONE
 * to specify a gap in the array that can be filled in later, e.g. by a
 * virtual engine used for load balancing.
 *
 * Setting the number of engines bound to the context to 0, by passing a zero
 * sized argument, will revert back to default settings.
 *
 * See struct i915_context_param_engines.
 *
 * Extensions:
 *   i915_context_engines_load_balance (I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE)
 *   i915_context_engines_bond (I915_CONTEXT_ENGINES_EXT_BOND)
 */
#define I915_CONTEXT_PARAM_ENGINES	0xa

/*
 * I915_CONTEXT_PARAM_PERSISTENCE:
 *
 * Allow the context and active rendering to survive the process until
 * completion. Persistence allows fire-and-forget clients to queue up a
 * bunch of work, hand the output over to a display server and then quit.
 * If the context is marked as not persistent, upon closing (either via
 * an explicit DRM_I915_GEM_CONTEXT_DESTROY or implicitly from file closure
 * or process termination), the context and any outstanding requests will be
 * cancelled (and exported fences for cancelled requests marked as -EIO).
 *
 * By default, new contexts allow persistence.
 */
#define I915_CONTEXT_PARAM_PERSISTENCE	0xb

/*
 * I915_CONTEXT_PARAM_RINGSIZE:
 *
 * Sets the size of the CS ringbuffer to use for logical ring contexts. This
 * applies a limit of how many batches can be queued to HW before the caller
 * is blocked due to lack of space for more commands.
 *
 * Only reliably possible to be set prior to first use, i.e. during
 * construction. At any later point, the current execution must be flushed as
 * the ring can only be changed while the context is idle. Note, the ringsize
 * can be specified as a constructor property, see
 * I915_CONTEXT_CREATE_EXT_SETPARAM, but can also be set later if required.
 *
 * Only applies to the current set of engine and lost when those engines
 * are replaced by a new mapping (see I915_CONTEXT_PARAM_ENGINES).
 *
 * Must be between 4 - 512 KiB, in intervals of page size [4 KiB].
 * Default is 16 KiB.
 */
#define I915_CONTEXT_PARAM_RINGSIZE	0xc
/* Must be kept compact -- no holes and well documented */

	__u64 value;
};

/**
 * Context SSEU programming
 *
 * It may be necessary for either functional or performance reason to configure
 * a context to run with a reduced number of SSEU (where SSEU stands for Slice/
 * Sub-slice/EU).
 *
 * This is done by configuring SSEU configuration using the below
 * @struct drm_i915_gem_context_param_sseu for every supported engine which
 * userspace intends to use.
 *
 * Not all GPUs or engines support this functionality in which case an error
 * code -ENODEV will be returned.
 *
 * Also, flexibility of possible SSEU configuration permutations varies between
 * GPU generations and software imposed limitations. Requesting such a
 * combination will return an error code of -EINVAL.
 *
 * NOTE: When perf/OA is active the context's SSEU configuration is ignored in
 * favour of a single global setting.
 */
struct drm_i915_gem_context_param_sseu {
	/*
	 * Engine class & instance to be configured or queried.
	 */
	struct i915_engine_class_instance engine;

	/*
	 * Unknown flags must be cleared to zero.
	 */
	__u32 flags;
#define I915_CONTEXT_SSEU_FLAG_ENGINE_INDEX (1u << 0)

	/*
	 * Mask of slices to enable for the context. Valid values are a subset
	 * of the bitmask value returned for I915_PARAM_SLICE_MASK.
	 */
	__u64 slice_mask;

	/*
	 * Mask of subslices to enable for the context. Valid values are a
	 * subset of the bitmask value return by I915_PARAM_SUBSLICE_MASK.
	 */
	__u64 subslice_mask;

	/*
	 * Minimum/Maximum number of EUs to enable per subslice for the
	 * context. min_eus_per_subslice must be inferior or equal to
	 * max_eus_per_subslice.
	 */
	__u16 min_eus_per_subslice;
	__u16 max_eus_per_subslice;

	/*
	 * Unused for now. Must be cleared to zero.
	 */
	__u32 rsvd;
};

/*
 * i915_context_engines_load_balance:
 *
 * Enable load balancing across this set of engines.
 *
 * Into the I915_EXEC_DEFAULT slot [0], a virtual engine is created that when
 * used will proxy the execbuffer request onto one of the set of engines
 * in such a way as to distribute the load evenly across the set.
 *
 * The set of engines must be compatible (e.g. the same HW class) as they
 * will share the same logical GPU context and ring.
 *
 * To intermix rendering with the virtual engine and direct rendering onto
 * the backing engines (bypassing the load balancing proxy), the context must
 * be defined to use a single timeline for all engines.
 */
struct i915_context_engines_load_balance {
	struct i915_user_extension base;

	__u16 engine_index;
	__u16 num_siblings;
	__u32 flags; /* all undefined flags must be zero */

	__u64 mbz64; /* reserved for future use; must be zero */

	struct i915_engine_class_instance engines[0];
} __attribute__((packed));

#define I915_DEFINE_CONTEXT_ENGINES_LOAD_BALANCE(name__, N__) struct { \
	struct i915_user_extension base; \
	__u16 engine_index; \
	__u16 num_siblings; \
	__u32 flags; \
	__u64 mbz64; \
	struct i915_engine_class_instance engines[N__]; \
} __attribute__((packed)) name__

/*
 * i915_context_engines_bond:
 *
 * Constructed bonded pairs for execution within a virtual engine.
 *
 * All engines are equal, but some are more equal than others. Given
 * the distribution of resources in the HW, it may be preferable to run
 * a request on a given subset of engines in parallel to a request on a
 * specific engine. We enable this selection of engines within a virtual
 * engine by specifying bonding pairs, for any given master engine we will
 * only execute on one of the corresponding siblings within the virtual engine.
 *
 * To execute a request in parallel on the master engine and a sibling requires
 * coordination with a I915_EXEC_FENCE_SUBMIT.
 */
struct i915_context_engines_bond {
	struct i915_user_extension base;

	struct i915_engine_class_instance master;

	__u16 virtual_index; /* index of virtual engine in ctx->engines[] */
	__u16 num_bonds;

	__u64 flags; /* all undefined flags must be zero */
	__u64 mbz64[4]; /* reserved for future use; must be zero */

	struct i915_engine_class_instance engines[0];
} __attribute__((packed));

#define I915_DEFINE_CONTEXT_ENGINES_BOND(name__, N__) struct { \
	struct i915_user_extension base; \
	struct i915_engine_class_instance master; \
	__u16 virtual_index; \
	__u16 num_bonds; \
	__u64 flags; \
	__u64 mbz64[4]; \
	struct i915_engine_class_instance engines[N__]; \
} __attribute__((packed)) name__

struct i915_context_param_engines {
	__u64 extensions; /* linked chain of extension blocks, 0 terminates */
#define I915_CONTEXT_ENGINES_EXT_LOAD_BALANCE 0 /* see i915_context_engines_load_balance */
#define I915_CONTEXT_ENGINES_EXT_BOND 1 /* see i915_context_engines_bond */
	struct i915_engine_class_instance engines[0];
} __attribute__((packed));

#define I915_DEFINE_CONTEXT_PARAM_ENGINES(name__, N__) struct { \
	__u64 extensions; \
	struct i915_engine_class_instance engines[N__]; \
} __attribute__((packed)) name__

struct drm_i915_gem_context_create_ext_setparam {
#define I915_CONTEXT_CREATE_EXT_SETPARAM 0
	struct i915_user_extension base;
	struct drm_i915_gem_context_param param;
};

struct drm_i915_gem_context_create_ext_clone {
#define I915_CONTEXT_CREATE_EXT_CLONE 1
	struct i915_user_extension base;
	__u32 clone_id;
	__u32 flags;
#define I915_CONTEXT_CLONE_ENGINES	(1u << 0)
#define I915_CONTEXT_CLONE_FLAGS	(1u << 1)
#define I915_CONTEXT_CLONE_SCHEDATTR	(1u << 2)
#define I915_CONTEXT_CLONE_SSEU		(1u << 3)
#define I915_CONTEXT_CLONE_TIMELINE	(1u << 4)
#define I915_CONTEXT_CLONE_VM		(1u << 5)
#define I915_CONTEXT_CLONE_UNKNOWN -(I915_CONTEXT_CLONE_VM << 1)
	__u64 rsvd;
};

struct drm_i915_gem_context_destroy {
	__u32 ctx_id;
	__u32 pad;
};

/*
 * DRM_I915_GEM_VM_CREATE -
 *
 * Create a new virtual memory address space (ppGTT) for use within a context
 * on the same file. Extensions can be provided to configure exactly how the
 * address space is setup upon creation.
 *
 * The id of new VM (bound to the fd) for use with I915_CONTEXT_PARAM_VM is
 * returned in the outparam @id.
 *
 * No flags are defined, with all bits reserved and must be zero.
 *
 * An extension chain maybe provided, starting with @extensions, and terminated
 * by the @next_extension being 0. Currently, no extensions are defined.
 *
 * DRM_I915_GEM_VM_DESTROY -
 *
 * Destroys a previously created VM id, specified in @id.
 *
 * No extensions or flags are allowed currently, and so must be zero.
 */
struct drm_i915_gem_vm_control {
	__u64 extensions;
	__u32 flags;
	__u32 vm_id;
};

struct drm_i915_reg_read {
	/*
	 * Register offset.
	 * For 64bit wide registers where the upper 32bits don't immediately
	 * follow the lower 32bits, the offset of the lower 32bits must
	 * be specified
	 */
	__u64 offset;
#define I915_REG_READ_8B_WA (1ul << 0)

	__u64 val; /* Return value */
};

/* Known registers:
 *
 * Render engine timestamp - 0x2358 + 64bit - gen7+
 * - Note this register returns an invalid value if using the default
 *   single instruction 8byte read, in order to workaround that pass
 *   flag I915_REG_READ_8B_WA in offset field.
 *
 */

struct drm_i915_reset_stats {
	__u32 ctx_id;
	__u32 flags;

	/* All resets since boot/module reload, for all contexts */
	__u32 reset_count;

	/* Number of batches lost when active in GPU, for this context */
	__u32 batch_active;

	/* Number of batches lost pending for execution, for this context */
	__u32 batch_pending;

	__u32 pad;
};

struct drm_i915_gem_userptr {
	__u64 user_ptr;
	__u64 user_size;
	__u32 flags;
#define I915_USERPTR_READ_ONLY 0x1
#define I915_USERPTR_UNSYNCHRONIZED 0x80000000
	/**
	 * Returned handle for the object.
	 *
	 * Object handles are nonzero.
	 */
	__u32 handle;
};

enum drm_i915_oa_format {
	I915_OA_FORMAT_A13 = 1,	    /* HSW only */
	I915_OA_FORMAT_A29,	    /* HSW only */
	I915_OA_FORMAT_A13_B8_C8,   /* HSW only */
	I915_OA_FORMAT_B4_C8,	    /* HSW only */
	I915_OA_FORMAT_A45_B8_C8,   /* HSW only */
	I915_OA_FORMAT_B4_C8_A16,   /* HSW only */
	I915_OA_FORMAT_C4_B8,	    /* HSW+ */

	/* Gen8+ */
	I915_OA_FORMAT_A12,
	I915_OA_FORMAT_A12_B8_C8,
	I915_OA_FORMAT_A32u40_A4u32_B8_C8,

	I915_OA_FORMAT_MAX	    /* non-ABI */
};

enum drm_i915_perf_property_id {
	/**
	 * Open the stream for a specific context handle (as used with
	 * execbuffer2). A stream opened for a specific context this way
	 * won't typically require root privileges.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_CTX_HANDLE = 1,

	/**
	 * A value of 1 requests the inclusion of raw OA unit reports as
	 * part of stream samples.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_SAMPLE_OA,

	/**
	 * The value specifies which set of OA unit metrics should be
	 * be configured, defining the contents of any OA unit reports.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_METRICS_SET,

	/**
	 * The value specifies the size and layout of OA unit reports.
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_FORMAT,

	/**
	 * Specifying this property implicitly requests periodic OA unit
	 * sampling and (at least on Haswell) the sampling frequency is derived
	 * from this exponent as follows:
	 *
	 *   80ns * 2^(period_exponent + 1)
	 *
	 * This property is available in perf revision 1.
	 */
	DRM_I915_PERF_PROP_OA_EXPONENT,

	/**
	 * Specifying this property is only valid when specify a context to
	 * filter with DRM_I915_PERF_PROP_CTX_HANDLE. Specifying this property
	 * will hold preemption of the particular context we want to gather
	 * performance data about. The execbuf2 submissions must include a
	 * drm_i915_gem_execbuffer_ext_perf parameter for this to apply.
	 *
	 * This property is available in perf revision 3.
	 */
	DRM_I915_PERF_PROP_HOLD_PREEMPTION,

	/**
	 * Specifying this pins all contexts to the specified SSEU power
	 * configuration for the duration of the recording.
	 *
	 * This parameter's value is a pointer to a struct
	 * drm_i915_gem_context_param_sseu.
	 *
	 * This property is available in perf revision 4.
	 */
	DRM_I915_PERF_PROP_GLOBAL_SSEU,

	/**
	 * This optional parameter specifies the timer interval in nanoseconds
	 * at which the i915 driver will check the OA buffer for available data.
	 * Minimum allowed value is 100 microseconds. A default value is used by
	 * the driver if this parameter is not specified. Note that larger timer
	 * values will reduce cpu consumption during OA perf captures. However,
	 * excessively large values would potentially result in OA buffer
	 * overwrites as captures reach end of the OA buffer.
	 *
	 * This property is available in perf revision 5.
	 */
	DRM_I915_PERF_PROP_POLL_OA_PERIOD,

	DRM_I915_PERF_PROP_MAX /* non-ABI */
};

struct drm_i915_perf_open_param {
	__u32 flags;
#define I915_PERF_FLAG_FD_CLOEXEC	(1<<0)
#define I915_PERF_FLAG_FD_NONBLOCK	(1<<1)
#define I915_PERF_FLAG_DISABLED		(1<<2)

	/** The number of u64 (id, value) pairs */
	__u32 num_properties;

	/**
	 * Pointer to array of u64 (id, value) pairs configuring the stream
	 * to open.
	 */
	__u64 properties_ptr;
};

/**
 * Enable data capture for a stream that was either opened in a disabled state
 * via I915_PERF_FLAG_DISABLED or was later disabled via
 * I915_PERF_IOCTL_DISABLE.
 *
 * It is intended to be cheaper to disable and enable a stream than it may be
 * to close and re-open a stream with the same configuration.
 *
 * It's undefined whether any pending data for the stream will be lost.
 *
 * This ioctl is available in perf revision 1.
 */
#define I915_PERF_IOCTL_ENABLE	_IO('i', 0x0)

/**
 * Disable data capture for a stream.
 *
 * It is an error to try and read a stream that is disabled.
 *
 * This ioctl is available in perf revision 1.
 */
#define I915_PERF_IOCTL_DISABLE	_IO('i', 0x1)

/**
 * Change metrics_set captured by a stream.
 *
 * If the stream is bound to a specific context, the configuration change
 * will performed __inline__ with that context such that it takes effect before
 * the next execbuf submission.
 *
 * Returns the previously bound metrics set id, or a negative error code.
 *
 * This ioctl is available in perf revision 2.
 */
#define I915_PERF_IOCTL_CONFIG	_IO('i', 0x2)

/**
 * Common to all i915 perf records
 */
struct drm_i915_perf_record_header {
	__u32 type;
	__u16 pad;
	__u16 size;
};

enum drm_i915_perf_record_type {

	/**
	 * Samples are the work horse record type whose contents are extensible
	 * and defined when opening an i915 perf stream based on the given
	 * properties.
	 *
	 * Boolean properties following the naming convention
	 * DRM_I915_PERF_SAMPLE_xyz_PROP request the inclusion of 'xyz' data in
	 * every sample.
	 *
	 * The order of these sample properties given by userspace has no
	 * affect on the ordering of data within a sample. The order is
	 * documented here.
	 *
	 * struct {
	 *     struct drm_i915_perf_record_header header;
	 *
	 *     { u32 oa_report[]; } && DRM_I915_PERF_PROP_SAMPLE_OA
	 * };
	 */
	DRM_I915_PERF_RECORD_SAMPLE = 1,

	/*
	 * Indicates that one or more OA reports were not written by the
	 * hardware. This can happen for example if an MI_REPORT_PERF_COUNT
	 * command collides with periodic sampling - which would be more likely
	 * at higher sampling frequencies.
	 */
	DRM_I915_PERF_RECORD_OA_REPORT_LOST = 2,

	/**
	 * An error occurred that resulted in all pending OA reports being lost.
	 */
	DRM_I915_PERF_RECORD_OA_BUFFER_LOST = 3,

	DRM_I915_PERF_RECORD_MAX /* non-ABI */
};

/**
 * Structure to upload perf dynamic configuration into the kernel.
 */
struct drm_i915_perf_oa_config {
	/** String formatted like "%08x-%04x-%04x-%04x-%012x" */
	char uuid[36];

	__u32 n_mux_regs;
	__u32 n_boolean_regs;
	__u32 n_flex_regs;

	/*
	 * These fields are pointers to tuples of u32 values (register address,
	 * value). For example the expected length of the buffer pointed by
	 * mux_regs_ptr is (2 * sizeof(u32) * n_mux_regs).
	 */
	__u64 mux_regs_ptr;
	__u64 boolean_regs_ptr;
	__u64 flex_regs_ptr;
};

struct drm_i915_query_item {
	__u64 query_id;
#define DRM_I915_QUERY_TOPOLOGY_INFO    1
#define DRM_I915_QUERY_ENGINE_INFO	2
#define DRM_I915_QUERY_PERF_CONFIG      3
/* Must be kept compact -- no holes and well documented */

	/*
	 * When set to zero by userspace, this is filled with the size of the
	 * data to be written at the data_ptr pointer. The kernel sets this
	 * value to a negative value to signal an error on a particular query
	 * item.
	 */
	__s32 length;

	/*
	 * When query_id == DRM_I915_QUERY_TOPOLOGY_INFO, must be 0.
	 *
	 * When query_id == DRM_I915_QUERY_PERF_CONFIG, must be one of the
	 * following :
	 *         - DRM_I915_QUERY_PERF_CONFIG_LIST
	 *         - DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID
	 *         - DRM_I915_QUERY_PERF_CONFIG_FOR_UUID
	 */
	__u32 flags;
#define DRM_I915_QUERY_PERF_CONFIG_LIST          1
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID 2
#define DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID   3

	/*
	 * Data will be written at the location pointed by data_ptr when the
	 * value of length matches the length of the data to be written by the
	 * kernel.
	 */
	__u64 data_ptr;
};

struct drm_i915_query {
	__u32 num_items;

	/*
	 * Unused for now. Must be cleared to zero.
	 */
	__u32 flags;

	/*
	 * This points to an array of num_items drm_i915_query_item structures.
	 */
	__u64 items_ptr;
};

/*
 * Data written by the kernel with query DRM_I915_QUERY_TOPOLOGY_INFO :
 *
 * data: contains the 3 pieces of information :
 *
 * - the slice mask with one bit per slice telling whether a slice is
 *   available. The availability of slice X can be queried with the following
 *   formula :
 *
 *           (data[X / 8] >> (X % 8)) & 1
 *
 * - the subslice mask for each slice with one bit per subslice telling
 *   whether a subslice is available. Gen12 has dual-subslices, which are
 *   similar to two gen11 subslices. For gen12, this array represents dual-
 *   subslices. The availability of subslice Y in slice X can be queried
 *   with the following formula :
 *
 *           (data[subslice_offset +
 *                 X * subslice_stride +
 *                 Y / 8] >> (Y % 8)) & 1
 *
 * - the EU mask for each subslice in each slice with one bit per EU telling
 *   whether an EU is available. The availability of EU Z in subslice Y in
 *   slice X can be queried with the following formula :
 *
 *           (data[eu_offset +
 *                 (X * max_subslices + Y) * eu_stride +
 *                 Z / 8] >> (Z % 8)) & 1
 */
struct drm_i915_query_topology_info {
	/*
	 * Unused for now. Must be cleared to zero.
	 */
	__u16 flags;

	__u16 max_slices;
	__u16 max_subslices;
	__u16 max_eus_per_subslice;

	/*
	 * Offset in data[] at which the subslice masks are stored.
	 */
	__u16 subslice_offset;

	/*
	 * Stride at which each of the subslice masks for each slice are
	 * stored.
	 */
	__u16 subslice_stride;

	/*
	 * Offset in data[] at which the EU masks are stored.
	 */
	__u16 eu_offset;

	/*
	 * Stride at which each of the EU masks for each subslice are stored.
	 */
	__u16 eu_stride;

	__u8 data[];
};

/**
 * struct drm_i915_engine_info
 *
 * Describes one engine and it's capabilities as known to the driver.
 */
struct drm_i915_engine_info {
	/** Engine class and instance. */
	struct i915_engine_class_instance engine;

	/** Reserved field. */
	__u32 rsvd0;

	/** Engine flags. */
	__u64 flags;

	/** Capabilities of this engine. */
	__u64 capabilities;
#define I915_VIDEO_CLASS_CAPABILITY_HEVC		(1 << 0)
#define I915_VIDEO_AND_ENHANCE_CLASS_CAPABILITY_SFC	(1 << 1)

	/** Reserved fields. */
	__u64 rsvd1[4];
};

/**
 * struct drm_i915_query_engine_info
 *
 * Engine info query enumerates all engines known to the driver by filling in
 * an array of struct drm_i915_engine_info structures.
 */
struct drm_i915_query_engine_info {
	/** Number of struct drm_i915_engine_info structs following. */
	__u32 num_engines;

	/** MBZ */
	__u32 rsvd[3];

	/** Marker for drm_i915_engine_info structures. */
	struct drm_i915_engine_info engines[];
};

/*
 * Data written by the kernel with query DRM_I915_QUERY_PERF_CONFIG.
 */
struct drm_i915_query_perf_config {
	union {
		/*
		 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 sets
		 * this fields to the number of configurations available.
		 */
		__u64 n_configs;

		/*
		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_ID,
		 * i915 will use the value in this field as configuration
		 * identifier to decide what data to write into config_ptr.
		 */
		__u64 config;

		/*
		 * When query_id == DRM_I915_QUERY_PERF_CONFIG_DATA_FOR_UUID,
		 * i915 will use the value in this field as configuration
		 * identifier to decide what data to write into config_ptr.
		 *
		 * String formatted like "%08x-%04x-%04x-%04x-%012x"
		 */
		char uuid[36];
	};

	/*
	 * Unused for now. Must be cleared to zero.
	 */
	__u32 flags;

	/*
	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_LIST, i915 will
	 * write an array of __u64 of configuration identifiers.
	 *
	 * When query_item.flags == DRM_I915_QUERY_PERF_CONFIG_DATA, i915 will
	 * write a struct drm_i915_perf_oa_config. If the following fields of
	 * drm_i915_perf_oa_config are set not set to 0, i915 will write into
	 * the associated pointers the values of submitted when the
	 * configuration was created :
	 *
	 *         - n_mux_regs
	 *         - n_boolean_regs
	 *         - n_flex_regs
	 */
	__u8 data[];
};

#if defined(__cplusplus)
}
#endif

#endif /* _I915_DRM_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /* SPDX-License-Identifier: (GPL-2.0 WITH Linux-syscall-note) OR MIT */
/* Copyright 2017-2018 Qiang Yu <yuq825@gmail.com> */

#ifndef __LIMA_DRM_H__
#define __LIMA_DRM_H__

#include "drm.h"

#if defined(__cplusplus)
extern "C" {
#endif

enum drm_lima_param_gpu_id {
	DRM_LIMA_PARAM_GPU_ID_UNKNOWN,
	DRM_LIMA_PARAM_GPU_ID_MALI400,
	DRM_LIMA_PARAM_GPU_ID_MALI450,
};

enum drm_lima_param {
	DRM_LIMA_PARAM_GPU_ID,
	DRM_LIMA_PARAM_NUM_PP,
	DRM_LIMA_PARAM_GP_VERSION,
	DRM_LIMA_PARAM_PP_VERSION,
};

/**
 * get various information of the GPU
 */
struct drm_lima_get_param {
	__u32 param; /* in, value in enum drm_lima_param */
	__u32 pad;   /* pad, must be zero */
	__u64 value; /* out, parameter value */
};

/*
 * heap buffer dynamically increase backup memory size when GP task fail
 * due to lack of heap memory. size field of heap buffer is an up bound of
 * the backup memory which can be set to a fairly large value.
 */
#define LIMA_BO_FLAG_HEAP  (1 << 0)

/**
 * create a buffer for used by GPU
 */
struct drm_lima_gem_create {
	__u32 size;    /* in, buffer size */
	__u32 flags;   /* in, buffer flags */
	__u32 handle;  /* out, GEM buffer handle */
	__u32 pad;     /* pad, must be zero */
};

/**
 * get information of a buffer
 */
struct drm_lima_gem_info {
	__u32 handle;  /* in, GEM buffer handle */
	__u32 va;      /* out, virtual address mapped into GPU MMU */
	__u64 offset;  /* out, used to mmap this buffer to CPU */
};

#define LIMA_SUBMIT_BO_READ   0x01
#define LIMA_SUBMIT_BO_WRITE  0x02

/* buffer information used by one task */
struct drm_lima_gem_submit_bo {
	__u32 handle;  /* in, GEM buffer handle */
	__u32 flags;   /* in, buffer read/write by GPU */
};

#define LIMA_GP_FRAME_REG_NUM 6

/* frame used to setup GP for each task */
struct drm_lima_gp_frame {
	__u32 frame[LIMA_GP_FRAME_REG_NUM];
};

#define LIMA_PP_FRAME_REG_NUM 23
#define LIMA_PP_WB_REG_NUM 12

/* frame used to setup mali400 GPU PP for each task */
struct drm_lima_m400_pp_frame {
	__u32 frame[LIMA_PP_FRAME_REG_NUM];
	__u32 num_pp;
	__u32 wb[3 * LIMA_PP_WB_REG_NUM];
	__u32 plbu_array_address[4];
	__u32 fragment_stack_address[4];
};

/* frame used to setup mali450 GPU PP for each task */
struct drm_lima_m450_pp_frame {
	__u32 frame[LIMA_PP_FRAME_REG_NUM];
	__u32 num_pp;
	__u32 wb[3 * LIMA_PP_WB_REG_NUM];
	__u32 use_dlbu;
	__u32 _pad;
	union {
		__u32 plbu_array_address[8];
		__u32 dlbu_regs[4];
	};
	__u32 fragment_stack_address[8];
};

#define LIMA_PIPE_GP  0x00
#define LIMA_PIPE_PP  0x01

#define LIMA_SUBMIT_FLAG_EXPLICIT_FENCE (1 << 0)

/**
 * submit a task to GPU
 *
 * User can always merge multi sync_file and drm_syncobj
 * into one drm_syncobj as in_sync[0], but we reserve
 * in_sync[1] for another task's out_sync to avoid the
 * export/import/merge pass when explicit sync.
 */
struct drm_lima_gem_submit {
	__u32 ctx;         /* in, context handle task is submitted to */
	__u32 pipe;        /* in, which pipe to use, GP/PP */
	__u32 nr_bos;      /* in, array length of bos field */
	__u32 frame_size;  /* in, size of frame field */
	__u64 bos;         /* in, array of drm_lima_gem_submit_bo */
	__u64 frame;       /* in, GP/PP frame */
	__u32 flags;       /* in, submit flags */
	__u32 out_sync;    /* in, drm_syncobj handle used to wait task finish after submission */
	__u32 in_sync[2];  /* in, drm_syncobj handle used to wait before start this task */
};

#define LIMA_GEM_WAIT_READ   0x01
#define LIMA_GEM_WAIT_WRITE  0x02

/**
 * wait pending GPU task finish of a buffer
 */
struct drm_lima_gem_wait {
	__u32 handle;      /* in, GEM buffer handle */
	__u32 op;          /* in, CPU want to read/write this buffer */
	__s64 timeout_ns;  /* in, wait timeout in absulute time */
};

/**
 * create a context
 */
struct drm_lima_ctx_create {
	__u32 id;          /* out, context handle */
	__u32 _pad;        /* pad, must be zero */
};

/**
 * free a context
 */
struct drm_lima_ctx_free {
	__u32 id;          /* in, context handle */
	__u32 _pad;        /* pad, must be zero */
};

#define DRM_LIMA_GET_PARAM   0x00
#define DRM_LIMA_GEM_CREATE  0x01
#define DRM_LIMA_GEM_INFO    0x02
#define DRM_LIMA_GEM_SUBMIT  0x03
#define DRM_LIMA_GEM_WAIT    0x04
#define DRM_LIMA_CTX_CREATE  0x05
#define DRM_LIMA_CTX_FREE    0x06

#define DRM_IOCTL_LIMA_GET_PARAM DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GET_PARAM, struct drm_lima_get_param)
#define DRM_IOCTL_LIMA_GEM_CREATE DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_CREATE, struct drm_lima_gem_create)
#define DRM_IOCTL_LIMA_GEM_INFO DRM_IOWR(DRM_COMMAND_BASE + DRM_LIMA_GEM_INFO, struct drm_lima_gem_info)
#define DRM_IOCTL_LIMA_GEM_SUBMIT DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_SUBMIT, struct drm_lima_gem_submit)
#define DRM_IOCTL_LIMA_GEM_WAIT DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_GEM_WAIT, struct drm_lima_gem_wait)
#define DRM_IOCTL_LIMA_CTX_CREATE DRM_IOR(DRM_COMMAND_BASE + DRM_LIMA_CTX_CREATE, struct drm_lima_ctx_create)
#define DRM_IOCTL_LIMA_CTX_FREE DRM_IOW(DRM_COMMAND_BASE + DRM_LIMA_CTX_FREE, struct drm_lima_ctx_free)

#if defined(__cplusplus)
}
#endif

#endif /* __LIMA_DRM_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    