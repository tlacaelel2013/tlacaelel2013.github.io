nitiator flags */
	__be16		cp_recip;	/* recipient flags */
	__be16		cp_rdfs;	/* receive data field size */
	__be16		cp_con_seq;	/* concurrent sequences */
	__be16		cp_ee_cred;	/* N-port end-to-end credit */
	__u8		cp_resv1;	/* reserved */
	__u8		cp_open_seq;	/* open sequences per exchange */
	__u8		_cp_resv2[2];	/* reserved */
};

/*
 * cp_class flags.
 */
#define	FC_CPC_VALID	0x8000		/* class valid */
#define	FC_CPC_IMIX	0x4000		/* intermix mode */
#define	FC_CPC_SEQ	0x0800		/* sequential delivery */
#define	FC_CPC_CAMP	0x0200		/* camp-on */
#define	FC_CPC_PRI	0x0080		/* priority */

/*
 * cp_init flags.
 * (TBD: not all flags defined here).
 */
#define	FC_CPI_CSYN	0x0010		/* clock synch. capable */

/*
 * cp_recip flags.
 */
#define	FC_CPR_CSYN	0x0008		/* clock synch. capable */

/*
 * NFC_ELS_FLOGI: Fabric login request.
 * NFC_ELS_PLOGI: Port login request (same format).
 */
struct fc_els_flogi {
	__u8		fl_cmd;		/* command */
	__u8		_fl_resvd[3];	/* must be zero */
	struct fc_els_csp fl_csp;	/* common service parameters */
	__be64		fl_wwpn;	/* port name */
	__be64		fl_wwnn;	/* node name */
	struct fc_els_cssp fl_cssp[4];	/* class 1-4 service parameters */
	__u8		fl_vend[16];	/* vendor version level */
} __attribute__((__packed__));

/*
 * Process login service parameter page.
 */
struct fc_els_spp {
	__u8		spp_type;	/* type code or common service params */
	__u8		spp_type_ext;	/* type code extension */
	__u8		spp_flags;
	__u8		_spp_resvd;
	__be32		spp_orig_pa;	/* originator process associator */
	__be32		spp_resp_pa;	/* responder process associator */
	__be32		spp_params;	/* service parameters */
};

/*
 * spp_flags.
 */
#define	FC_SPP_OPA_VAL	    0x80	/* originator proc. assoc. valid */
#define	FC_SPP_RPA_VAL	    0x40	/* responder proc. assoc. valid */
#define	FC_SPP_EST_IMG_PAIR 0x20	/* establish image pair */
#define	FC_SPP_RESP_MASK    0x0f	/* mask for response code (below) */

/*
 * SPP response code in spp_flags - lower 4 bits.
 */
enum fc_els_spp_resp {
	FC_SPP_RESP_ACK	=	1,	/* request executed */
	FC_SPP_RESP_RES =	2,	/* unable due to lack of resources */
	FC_SPP_RESP_INIT =	3,	/* initialization not complete */
	FC_SPP_RESP_NO_PA = 	4,	/* unknown process associator */
	FC_SPP_RESP_CONF = 	5,	/* configuration precludes image pair */
	FC_SPP_RESP_COND = 	6,	/* request completed conditionally */
	FC_SPP_RESP_MULT = 	7,	/* unable to handle multiple SPPs */
	FC_SPP_RESP_INVL = 	8,	/* SPP is invalid */
};

/*
 * ELS_RRQ - Reinstate Recovery Qualifier
 */
struct fc_els_rrq {
	__u8		rrq_cmd;	/* command (0x12) */
	__u8		rrq_zero[3];	/* specified as zero - part of cmd */
	__u8		rrq_resvd;	/* reserved */
	__u8		rrq_s_id[3];	/* originator FID */
	__be16		rrq_ox_id;	/* originator exchange ID */
	__be16		rrq_rx_id;	/* responders exchange ID */
};

/*
 * ELS_REC - Read exchange concise.
 */
struct fc_els_rec {
	__u8		rec_cmd;	/* command (0x13) */
	__u8		rec_zero[3];	/* specified as zero - part of cmd */
	__u8		rec_resvd;	/* reserved */
	__u8		rec_s_id[3];	/* originator FID */
	__be16		rec_ox_id;	/* originator exchange ID */
	__be16		rec_rx_id;	/* responders exchange ID */
};

/*
 * ELS_REC LS_ACC payload.
 */
struct fc_els_rec_acc {
	__u8		reca_cmd;	/* accept (0x02) */
	__u8		reca_zero[3];	/* specified as zero - part of cmd */
	__be16		reca_ox_id;	/* originator exchange ID */
	__be16		reca_rx_id;	/* responders exchange ID */
	__u8		reca_resvd1;	/* reserved */
	__u8		reca_ofid[3];	/* originator FID */
	__u8		reca_resvd2;	/* reserved */
	__u8		reca_rfid[3];	/* responder FID */
	__be32		reca_fc4value;	/* FC4 value */
	__be32		reca_e_stat;	/* ESB (exchange status block) status */
};

/*
 * ELS_PRLI - Process login request and response.
 */
struct fc_els_prli {
	__u8		prli_cmd;	/* command */
	__u8		prli_spp_len;	/* length of each serv. parm. page */
	__be16		prli_len;	/* length of entire payload */
	/* service parameter pages follow */
};

/*
 * ELS_PRLO - Process logout request and response.
 */
struct fc_els_prlo {
	__u8            prlo_cmd;       /* command */
	__u8            prlo_obs;       /* obsolete, but shall be set to 10h */
	__be16          prlo_len;       /* payload length */
};

/*
 * ELS_ADISC payload
 */
struct fc_els_adisc {
	__u8		adisc_cmd;
	__u8		adisc_resv[3];
	__u8            adisc_resv1;
	__u8            adisc_hard_addr[3];
	__be64          adisc_wwpn;
	__be64          adisc_wwnn;
	__u8            adisc_resv2;
	__u8            adisc_port_id[3];
} __attribute__((__packed__));

/*
 * ELS_LOGO - process or fabric logout.
 */
struct fc_els_logo {
	__u8		fl_cmd;		/* command code */
	__u8		fl_zero[3];	/* specified as zero - part of cmd */
	__u8		fl_resvd;	/* reserved */
	__u8		fl_n_port_id[3];/* N port ID */
	__be64		fl_n_port_wwn;	/* port name */
};

/*
 * ELS_RTV - read timeout value.
 */
struct fc_els_rtv {
	__u8		rtv_cmd;	/* command code 0x0e */
	__u8		rtv_zero[3];	/* specified as zero - part of cmd */
};

/*
 * LS_ACC for ELS_RTV - read timeout value.
 */
struct fc_els_rtv_acc {
	__u8		rtv_cmd;	/* command code 0x02 */
	__u8		rtv_zero[3];	/* specified as zero - part of cmd */
	__be32		rtv_r_a_tov;	/* resource allocation timeout value */
	__be32		rtv_e_d_tov;	/* error detection timeout value */
	__be32		rtv_toq;	/* timeout qualifier (see below) */
};

/*
 * rtv_toq bits.
 */
#define	FC_ELS_RTV_EDRES (1 << 26)	/* E_D_TOV resolution is nS else mS */
#define	FC_ELS_RTV_RTTOV (1 << 19)	/* R_T_TOV is 100 uS else 100 mS */

/*
 * ELS_SCR - state change registration payload.
 */
struct fc_els_scr {
	__u8		scr_cmd;	/* command code */
	__u8		scr_resv[6];	/* reserved */
	__u8		scr_reg_func;	/* registration function (see below) */
};

enum fc_els_scr_func {
	ELS_SCRF_FAB =	1,	/* fabric-detected registration */
	ELS_SCRF_NPORT = 2,	/* Nx_Port-detected registration */
	ELS_SCRF_FULL =	3,	/* full registration */
	ELS_SCRF_CLEAR = 255,	/* remove any current registrations */
};

/*
 * ELS_RSCN - registered state change notification payload.
 */
struct fc_els_rscn {
	__u8		rscn_cmd;	/* RSCN opcode (0x61) */
	__u8		rscn_page_len;	/* page length (4) */
	__be16		rscn_plen;	/* payload length including this word */

	/* followed by 4-byte generic affected Port_ID pages */
};

struct fc_els_rscn_page {
	__u8		rscn_page_flags; /* event and address format */
	__u8		rscn_fid[3];	/* fabric ID */
};

#define	ELS_RSCN_EV_QUAL_BIT	2	/* shift count for event qualifier */
#define	ELS_RSCN_EV_QUAL_MASK	0xf	/* mask for event qualifier */
#define	ELS_RSCN_ADDR_FMT_BIT	0	/* shift count for address format */
#define	ELS_RSCN_ADDR_FMT_MASK	0x3	/* mask for address format */

enum fc_els_rscn_ev_qual {
	ELS_EV_QUAL_NONE = 0,		/* unspecified */
	ELS_EV_QUAL_NS_OBJ = 1,		/* changed name server object */
	ELS_EV_QUAL_PORT_ATTR = 2,	/* changed port attribute */
	ELS_EV_QUAL_SERV_OBJ = 3,	/* changed service object */
	ELS_EV_QUAL_SW_CONFIG = 4,	/* changed switch configuration */
	ELS_EV_QUAL_REM_OBJ = 5,	/* removed object */
};

enum fc_els_rscn_addr_fmt {
	ELS_ADDR_FMT_PORT = 0,	/* rscn_fid is a port address */
	ELS_ADDR_FMT_AREA = 1,	/* rscn_fid is a area address */
	ELS_ADDR_FMT_DOM = 2,	/* rscn_fid is a domain address */
	ELS_ADDR_FMT_FAB = 3,	/* anything on fabric may have changed */
};

/*
 * ELS_RNID - request Node ID.
 */
struct fc_els_rnid {
	__u8		rnid_cmd;	/* RNID opcode (0x78) */
	__u8		rnid_resv[3];	/* reserved */
	__u8		rnid_fmt;	/* data format */
	__u8		rnid_resv2[3];	/* reserved */
};

/*
 * Node Identification Data formats (rnid_fmt)
 */
enum fc_els_rnid_fmt {
	ELS_RNIDF_NONE = 0,		/* no specific identification data */
	ELS_RNIDF_GEN = 0xdf,		/* general topology discovery format */
};

/*
 * ELS_RNID response.
 */
struct fc_els_rnid_resp {
	__u8		rnid_cmd;	/* response code (LS_ACC) */
	__u8		rnid_resv[3];	/* reserved */
	__u8		rnid_fmt;	/* data format */
	__u8		rnid_cid_len;	/* common ID data length */
	__u8		rnid_resv2;	/* reserved */
	__u8		rnid_sid_len;	/* specific ID data length */
};

struct fc_els_rnid_cid {
	__be64		rnid_wwpn;	/* N port name */
	__be64		rnid_wwnn;	/* node name */
};

struct fc_els_rnid_gen {
	__u8		rnid_vend_id[16]; /* vendor-unique ID */
	__be32		rnid_atype;	/* associated type (see below) */
	__be32		rnid_phys_port;	/* physical port number */
	__be32		rnid_att_nodes;	/* number of attached nodes */
	__u8		rnid_node_mgmt;	/* node management (see below) */
	__u8		rnid_ip_ver;	/* IP version (see below) */
	__be16		rnid_prot_port;	/* UDP / TCP port number */
	__be32		rnid_ip_addr[4]; /* IP address */
	__u8		rnid_resvd[2];	/* reserved */
	__be16		rnid_vend_spec;	/* vendor-specific field */
};

enum fc_els_rnid_atype {
	ELS_RNIDA_UNK =		0x01,	/* unknown */
	ELS_RNIDA_OTHER =	0x02,	/* none of the following */
	ELS_RNIDA_HUB =		0x03,
	ELS_RNIDA_SWITCH =	0x04,
	ELS_RNIDA_GATEWAY =	0x05,
	ELS_RNIDA_CONV =	0x06,   /* Obsolete, do not use this value */
	ELS_RNIDA_HBA =	        0x07,   /* Obsolete, do not use this value */
	ELS_RNIDA_PROXY =       0x08,   /* Obsolete, do not use this value */
	ELS_RNIDA_STORAGE =	0x09,
	ELS_RNIDA_HOST =	0x0a,
	ELS_RNIDA_SUBSYS =	0x0b,	/* storage subsystem (e.g., RAID) */
	ELS_RNIDA_ACCESS =	0x0e,	/* access device (e.g. media changer) */
	ELS_RNIDA_NAS =		0x11,	/* NAS server */
	ELS_RNIDA_BRIDGE =	0x12,	/* bridge */
	ELS_RNIDA_VIRT =	0x13,	/* virtualization device */
	ELS_RNIDA_MF =		0xff,	/* multifunction device (bits below) */
	ELS_RNIDA_MF_HUB =	1UL << 31, 	/* hub */
	ELS_RNIDA_MF_SW =	1UL << 30, 	/* switch */
	ELS_RNIDA_MF_GW =	1UL << 29,	/* gateway */
	ELS_RNIDA_MF_ST =	1UL << 28,	/* storage */
	ELS_RNIDA_MF_HOST =	1UL << 27,	/* host */
	ELS_RNIDA_MF_SUB =	1UL << 26,	/* storage subsystem */
	ELS_RNIDA_MF_ACC =	1UL << 25,	/* storage access dev */
	ELS_RNIDA_MF_WDM =	1UL << 24,	/* wavelength division mux */
	ELS_RNIDA_MF_NAS =	1UL << 23,	/* NAS server */
	ELS_RNIDA_MF_BR =	1UL << 22,	/* bridge */
	ELS_RNIDA_MF_VIRT =	1UL << 21,	/* virtualization device */
};

enum fc_els_rnid_mgmt {
	ELS_RNIDM_SNMP =	0,
	ELS_RNIDM_TELNET =	1,
	ELS_RNIDM_HTTP =	2,
	ELS_RNIDM_HTTPS =	3,
	ELS_RNIDM_XML =		4,	/* HTTP + XML */
};

enum fc_els_rnid_ipver {
	ELS_RNIDIP_NONE =	0,	/* no IP support or node mgmt. */
	ELS_RNIDIP_V4 =		1,	/* IPv4 */
	ELS_RNIDIP_V6 =		2,	/* IPv6 */
};

/*
 * ELS RPL - Read Port List.
 */
struct fc_els_rpl {
	__u8		rpl_cmd;	/* command */
	__u8		rpl_resv[5];	/* reserved - must be zero */
	__be16		rpl_max_size;	/* maximum response size or zero */
	__u8		rpl_resv1;	/* reserved - must be zero */
	__u8		rpl_index[3];	/* starting index */
};

/*
 * Port number block in RPL response.
 */
struct fc_els_pnb {
	__be32		pnb_phys_pn;	/* physical port number */
	__u8		pnb_resv;	/* reserved */
	__u8		pnb_port_id[3];	/* port ID */
	__be64		pnb_wwpn;	/* port name */
};

/*
 * RPL LS_ACC response.
 */
struct fc_els_rpl_resp {
	__u8		rpl_cmd;	/* ELS_LS_ACC */
	__u8		rpl_resv1;	/* reserved - must be zero */
	__be16		rpl_plen;	/* payload length */
	__u8		rpl_resv2;	/* reserved - must be zero */
	__u8		rpl_llen[3];	/* list length */
	__u8		rpl_resv3;	/* reserved - must be zero */
	__u8		rpl_index[3];	/* starting index */
	struct fc_els_pnb rpl_pnb[1];	/* variable number of PNBs */
};

/*
 * Link Error Status Block.
 */
struct fc_els_lesb {
	__be32		lesb_link_fail;	/* link failure count */
	__be32		lesb_sync_loss;	/* loss of synchronization count */
	__be32		lesb_sig_loss;	/* loss of signal count */
	__be32		lesb_prim_err;	/* primitive sequence error count */
	__be32		lesb_inv_word;	/* invalid transmission word count */
	__be32		lesb_inv_crc;	/* invalid CRC count */
};

/*
 * ELS RPS - Read Port Status Block request.
 */
struct fc_els_rps {
	__u8		rps_cmd;	/* command */
	__u8		rps_resv[2];	/* reserved - must be zero */
	__u8		rps_flag;	/* flag - see below */
	__be64		rps_port_spec;	/* port selection */
};

enum fc_els_rps_flag {
	FC_ELS_RPS_DID =	0x00,	/* port identified by D_ID of req. */
	FC_ELS_RPS_PPN =	0x01,	/* port_spec is physical port number */
	FC_ELS_RPS_WWPN =	0x02,	/* port_spec is port WWN */
};

/*
 * ELS RPS LS_ACC response.
 */
struct fc_els_rps_resp {
	__u8		rps_cmd;	/* command - LS_ACC */
	__u8		rps_resv[2];	/* reserved - must be zero */
	__u8		rps_flag;	/* flag - see below */
	__u8		rps_resv2[2];	/* reserved */
	__be16		rps_status;	/* port status - see below */
	struct fc_els_lesb rps_lesb;	/* link error status block */
};

enum fc_els_rps_resp_flag {
	FC_ELS_RPS_LPEV =	0x01,	/* L_port extension valid */
};

enum fc_els_rps_resp_status {
	FC_ELS_RPS_PTP =	1 << 5,	/* point-to-point connection */
	FC_ELS_RPS_LOOP =	1 << 4,	/* loop mode */
	FC_ELS_RPS_FAB =	1 << 3,	/* fabric present */
	FC_ELS_RPS_NO_SIG =	1 << 2,	/* loss of signal */
	FC_ELS_RPS_NO_SYNC =	1 << 1,	/* loss of synchronization */
	FC_ELS_RPS_RESET =	1 << 0,	/* in link reset protocol */
};

/*
 * ELS LIRR - Link Incident Record Registration request.
 */
struct fc_els_lirr {
	__u8		lirr_cmd;	/* command */
	__u8		lirr_resv[3];	/* reserved - must be zero */
	__u8		lirr_func;	/* registration function */
	__u8		lirr_fmt;	/* FC-4 type of RLIR requested */
	__u8		lirr_resv2[2];	/* reserved - must be zero */
};

enum fc_els_lirr_func {
	ELS_LIRR_SET_COND = 	0x01,	/* set - conditionally receive */
	ELS_LIRR_SET_UNCOND = 	0x02,	/* set - unconditionally receive */
	ELS_LIRR_CLEAR = 	0xff	/* clear registration */
};

/*
 * ELS SRL - Scan Remote Loop request.
 */
struct fc_els_srl {
	__u8		srl_cmd;	/* command */
	__u8		srl_resv[3];	/* reserved - must be zero */
	__u8		srl_flag;	/* flag - see below */
	__u8		srl_flag_param[3];	/* flag parameter */
};

enum fc_els_srl_flag {
	FC_ELS_SRL_ALL =	0x00,	/* scan all FL ports */
	FC_ELS_SRL_ONE =	0x01,	/* scan specified loop */
	FC_ELS_SRL_EN_PER =	0x02,	/* enable periodic scanning (param) */
	FC_ELS_SRL_DIS_PER =	0x03,	/* disable periodic scanning */
};

/*
 * ELS RLS - Read Link Error Status Block request.
 */
struct fc_els_rls {
	__u8		rls_cmd;	/* command */
	__u8		rls_resv[4];	/* reserved - must be zero */
	__u8		rls_port_id[3];	/* port ID */
};

/*
 * ELS RLS LS_ACC Response.
 */
struct fc_els_rls_resp {
	__u8		rls_cmd;	/* ELS_LS_ACC */
	__u8		rls_resv[3];	/* reserved - must be zero */
	struct fc_els_lesb rls_lesb;	/* link error status block */
};

/*
 * ELS RLIR - Registered Link Incident Report.
 * This is followed by the CLIR and the CLID, described below.
 */
struct fc_els_rlir {
	__u8		rlir_cmd;	/* command */
	__u8		rlir_resv[3];	/* reserved - must be zero */
	__u8		rlir_fmt;	/* format (FC4-type if type specific) */
	__u8		rlir_clr_len;	/* common link incident record length */
	__u8		rlir_cld_len;	/* common link incident desc. length */
	__u8		rlir_slr_len;	/* spec. link incident record length */
};

/*
 * CLIR - Common Link Incident Record Data. - Sent via RLIR.
 */
struct fc_els_clir {
	__be64		clir_wwpn;	/* incident port name */
	__be64		clir_wwnn;	/* incident port node name */
	__u8		clir_port_type;	/* incident port type */
	__u8		clir_port_id[3];	/* incident port ID */

	__be64		clir_conn_wwpn;	/* connected port name */
	__be64		clir_conn_wwnn;	/* connected node name */
	__be64		clir_fab_name;	/* fabric name */
	__be32		clir_phys_port;	/* physical port number */
	__be32		clir_trans_id;	/* transaction ID */
	__u8		clir_resv[3];	/* reserved */
	__u8		clir_ts_fmt;	/* time stamp format */
	__be64		clir_timestamp;	/* time stamp */
};

/*
 * CLIR clir_ts_fmt - time stamp format values.
 */
enum fc_els_clir_ts_fmt {
	ELS_CLIR_TS_UNKNOWN = 	0,	/* time stamp field unknown */
	ELS_CLIR_TS_SEC_FRAC = 	1,	/* time in seconds and fractions */
	ELS_CLIR_TS_CSU =	2,	/* time in clock synch update format */
};

/*
 * Common Link Incident Descriptor - sent via RLIR.
 */
struct fc_els_clid {
	__u8		clid_iq;	/* incident qualifier flags */
	__u8		clid_ic;	/* incident code */
	__be16		clid_epai;	/* domain/area of ISL */
};

/*
 * CLID incident qualifier flags.
 */
enum fc_els_clid_iq {
	ELS_CLID_SWITCH =	0x20,	/* incident port is a switch node */
	ELS_CLID_E_PORT =	0x10,	/* incident is an ISL (E) port */
	ELS_CLID_SEV_MASK =	0x0c,	/* severity 2-bit field mask */
	ELS_CLID_SEV_INFO =	0x00,	/* report is informational */
	ELS_CLID_SEV_INOP =	0x08,	/* link not operational */
	ELS_CLID_SEV_DEG =	0x04,	/* link degraded but operational */
	ELS_CLID_LASER =	0x02,	/* subassembly is a laser */
	ELS_CLID_FRU =		0x01,	/* format can identify a FRU */
};

/*
 * CLID incident code.
 */
enum fc_els_clid_ic {
	ELS_CLID_IC_IMPL =	1,	/* implicit incident */
	ELS_CLID_IC_BER =	2,	/* bit-error-rate threshold exceeded */
	ELS_CLID_IC_LOS =	3,	/* loss of synch or signal */
	ELS_CLID_IC_NOS =	4,	/* non-operational primitive sequence */
	ELS_CLID_IC_PST =	5,	/* primitive sequence timeout */
	ELS_CLID_IC_INVAL =	6,	/* invalid primitive sequence */
	ELS_CLID_IC_LOOP_TO =	7,	/* loop initialization time out */
	ELS_CLID_IC_LIP =	8,	/* receiving LIP */
};


enum fc_fpin_li_event_types {
	FPIN_LI_UNKNOWN =		0x0,
	FPIN_LI_LINK_FAILURE =		0x1,
	FPIN_LI_LOSS_OF_SYNC =		0x2,
	FPIN_LI_LOSS_OF_SIG =		0x3,
	FPIN_LI_PRIM_SEQ_ERR =		0x4,
	FPIN_LI_INVALID_TX_WD =		0x5,
	FPIN_LI_INVALID_CRC =		0x6,
	FPIN_LI_DEVICE_SPEC =		0xF,
};

/*
 * Initializer useful for decoding table.
 * Please keep this in sync with the above definitions.
 */
#define FC_FPIN_LI_EVT_TYPES_INIT {					\
	{ FPIN_LI_UNKNOWN,		"Unknown" },			\
	{ FPIN_LI_LINK_FAILURE,		"Link Failure" },		\
	{ FPIN_LI_LOSS_OF_SYNC,		"Loss of Synchronization" },	\
	{ FPIN_LI_LOSS_OF_SIG,		"Loss of Signal" },		\
	{ FPIN_LI_PRIM_SEQ_ERR,		"Primitive Sequence Protocol Error" }, \
	{ FPIN_LI_INVALID_TX_WD,	"Invalid Transmission Word" },	\
	{ FPIN_LI_INVALID_CRC,		"Invalid CRC" },		\
	{ FPIN_LI_DEVICE_SPEC,		"Device Specific" },		\
}


/*
 * Link Integrity Notification Descriptor
 */
struct fc_fn_li_desc {
	__be32		desc_tag;	/* Descriptor Tag (0x00020001) */
	__be32		desc_len;	/* Length of Descriptor (in bytes).
					 * Size of descriptor excluding
					 * desc_tag and desc_len fields.
					 */
	__be64		detecting_wwpn;	/* Port Name that detected event */
	__be64		attached_wwpn;	/* Port Name of device attached to
					 * detecting Port Name
					 */
	__be16		event_type;	/* see enum fc_fpin_li_event_types */
	__be16		event_modifier;	/* Implementation specific value
					 * describing the event type
					 */
	__be32		event_threshold;/* duration in ms of the link
					 * integrity detection cycle
					 */
	__be32		event_count;	/* minimum number of event
					 * occurrences during the event
					 * threshold to caause the LI event
					 */
	__be32		pname_count;	/* number of portname_list elements */
	__be64		pname_list[0];	/* list of N_Port_Names accessible
					 * through the attached port
					 */
};

/*
 * ELS_FPIN - Fabric Performance Impact Notification
 */
struct fc_els_fpin {
	__u8		fpin_cmd;	/* command (0x16) */
	__u8		fpin_zero[3];	/* specified as zero - part of cmd */
	__be32		desc_len;	/* Length of Descriptor List (in bytes).
					 * Size of ELS excluding fpin_cmd,
					 * fpin_zero and desc_len fields.
					 */
	struct fc_tlv_desc	fpin_desc[0];	/* Descriptor list */
};

/* Diagnostic Function Descriptor - FPIN Registration */
struct fc_df_desc_fpin_reg {
	__be32		desc_tag;	/* FPIN Registration (0x00030001) */
	__be32		desc_len;	/* Length of Descriptor (in bytes).
					 * Size of descriptor excluding
					 * desc_tag and desc_len fields.
					 */
	__be32		count;		/* Number of desc_tags elements */
	__be32		desc_tags[0];	/* Array of Descriptor Tags.
					 * Each tag indicates a function
					 * supported by the N_Port (request)
					 * or by the  N_Port and Fabric
					 * Controller (reply; may be a subset
					 * of the request).
					 * See ELS_FN_DTAG_xxx for tag values.
					 */
};

/*
 * ELS_RDF - Register Diagnostic Functions
 */
struct fc_els_rdf {
	__u8		fpin_cmd;	/* command (0x19) */
	__u8		fpin_zero[3];	/* specified as zero - part of cmd */
	__be32		desc_len;	/* Length of Descriptor List (in bytes).
					 * Size of ELS excluding fpin_cmd,
					 * fpin_zero and desc_len fields.
					 */
	struct fc_tlv_desc	desc[0];	/* Descriptor list */
};

/*
 * ELS RDF LS_ACC Response.
 */
struct fc_els_rdf_resp {
	struct fc_els_ls_acc	acc_hdr;
	__be32			desc_list_len;	/* Length of response (in
						 * bytes). Excludes acc_hdr
						 * and desc_list_len fields.
						 */
	struct fc_els_lsri_desc	lsri;
	struct fc_tlv_desc	desc[0];	/* Supported Descriptor list */
};


#endif /* _FC_ELS_H_ */
                                                                                                                                                                                         /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * Copyright(c) 2007 Intel Corporation. All rights reserved.
 *
 * Maintained at www.Open-FCoE.org
 */

#ifndef _FC_FS_H_
#define _FC_FS_H_

#include <linux/types.h>

/*
 * Fibre Channel Framing and Signalling definitions.
 * From T11 FC-FS-2 Rev 0.90 - 9 August 2005.
 */

/*
 * Frame header
 */
struct fc_frame_header {
	__u8          fh_r_ctl;	/* routing control */
	__u8          fh_d_id[3];	/* Destination ID */

	__u8          fh_cs_ctl;	/* class of service control / pri */
	__u8          fh_s_id[3];	/* Source ID */

	__u8          fh_type;		/* see enum fc_fh_type below */
	__u8          fh_f_ctl[3];	/* frame control */

	__u8          fh_seq_id;	/* sequence ID */
	__u8          fh_df_ctl;	/* data field control */
	__be16        fh_seq_cnt;	/* sequence count */

	__be16        fh_ox_id;		/* originator exchange ID */
	__be16        fh_rx_id;		/* responder exchange ID */
	__be32        fh_parm_offset;	/* parameter or relative offset */
};

#define FC_FRAME_HEADER_LEN 24	/* expected length of structure */

#define FC_MAX_PAYLOAD  2112U		/* max payload length in bytes */
#define FC_MIN_MAX_PAYLOAD  256U 	/* lower limit on max payload */

#define FC_MAX_FRAME	(FC_MAX_PAYLOAD + FC_FRAME_HEADER_LEN)
#define FC_MIN_MAX_FRAME (FC_MIN_MAX_PAYLOAD + FC_FRAME_HEADER_LEN)

/*
 * fh_r_ctl - Routing control definitions.
 */
    /*
     * FC-4 device_data.
     */
enum fc_rctl {
	FC_RCTL_DD_UNCAT = 0x00,	/* uncategorized information */
	FC_RCTL_DD_SOL_DATA = 0x01,	/* solicited data */
	FC_RCTL_DD_UNSOL_CTL = 0x02,	/* unsolicited control */
	FC_RCTL_DD_SOL_CTL = 0x03,	/* solicited control or reply */
	FC_RCTL_DD_UNSOL_DATA = 0x04,	/* unsolicited data */
	FC_RCTL_DD_DATA_DESC = 0x05,	/* data descriptor */
	FC_RCTL_DD_UNSOL_CMD = 0x06,	/* unsolicited command */
	FC_RCTL_DD_CMD_STATUS = 0x07,	/* command status */

#define FC_RCTL_ILS_REQ FC_RCTL_DD_UNSOL_CTL	/* ILS request */
#define FC_RCTL_ILS_REP FC_RCTL_DD_SOL_CTL	/* ILS reply */

	/*
	 * Extended Link_Data
	 */
	FC_RCTL_ELS_REQ = 0x22,	/* extended link services request */
	FC_RCTL_ELS_REP = 0x23,	/* extended link services reply */
	FC_RCTL_ELS4_REQ = 0x32, /* FC-4 ELS request */
	FC_RCTL_ELS4_REP = 0x33, /* FC-4 ELS reply */
	/*
	 * Optional Extended Headers
	 */
	FC_RCTL_VFTH = 0x50,	/* virtual fabric tagging header */
	FC_RCTL_IFRH = 0x51,	/* inter-fabric routing header */
	FC_RCTL_ENCH = 0x52,	/* encapsulation header */
	/*
	 * Basic Link Services fh_r_ctl values.
	 */
	FC_RCTL_BA_NOP = 0x80,	/* basic link service NOP */
	FC_RCTL_BA_ABTS = 0x81,	/* basic link service abort */
	FC_RCTL_BA_RMC = 0x82,	/* remove connection */
	FC_RCTL_BA_ACC = 0x84,	/* basic accept */
	FC_RCTL_BA_RJT = 0x85,	/* basic reject */
	FC_RCTL_BA_PRMT = 0x86,	/* dedicated connection preempted */
	/*
	 * Link Control Information.
	 */
	FC_RCTL_ACK_1 = 0xc0,	/* acknowledge_1 */
	FC_RCTL_ACK_0 = 0xc1,	/* acknowledge_0 */
	FC_RCTL_P_RJT = 0xc2,	/* port reject */
	FC_RCTL_F_RJT = 0xc3,	/* fabric reject */
	FC_RCTL_P_BSY = 0xc4,	/* port busy */
	FC_RCTL_F_BSY = 0xc5,	/* fabric busy to data frame */
	FC_RCTL_F_BSYL = 0xc6,	/* fabric busy to link control frame */
	FC_RCTL_LCR = 0xc7,	/* link credit reset */
	FC_RCTL_END = 0xc9,	/* end */
};
				    /* incomplete list of definitions */

/*
 * R_CTL names initializer.
 * Please keep this matching the above definitions.
 */
#define FC_RCTL_NAMES_INIT { \
	[FC_RCTL_DD_UNCAT] =		"uncat",			\
	[FC_RCTL_DD_SOL_DATA] =		"sol data",			\
	[FC_RCTL_DD_UNSOL_CTL] =	"unsol ctl",			\
	[FC_RCTL_DD_SOL_CTL] =		"sol ctl/reply",		\
	[FC_RCTL_DD_UNSOL_DATA] =	"unsol data",			\
	[FC_RCTL_DD_DATA_DESC] =	"data desc",			\
	[FC_RCTL_DD_UNSOL_CMD] =	"unsol cmd",			\
	[FC_RCTL_DD_CMD_STATUS] =	"cmd status",			\
	[FC_RCTL_ELS_REQ] =		"ELS req",			\
	[FC_RCTL_ELS_REP] =		"ELS rep",			\
	[FC_RCTL_ELS4_REQ] =		"FC-4 ELS req",			\
	[FC_RCTL_ELS4_REP] =		"FC-4 ELS rep",			\
	[FC_RCTL_BA_NOP] =		"BLS NOP",			\
	[FC_RCTL_BA_ABTS] =		"BLS abort",			\
	[FC_RCTL_BA_RMC] =		"BLS remove connection",	\
	[FC_RCTL_BA_ACC] =		"BLS accept",			\
	[FC_RCTL_BA_RJT] =		"BLS reject",			\
	[FC_RCTL_BA_PRMT] =		"BLS dedicated connection preempted", \
	[FC_RCTL_ACK_1] =		"LC ACK_1",			\
	[FC_RCTL_ACK_0] =		"LC ACK_0",			\
	[FC_RCTL_P_RJT] =		"LC port reject",		\
	[FC_RCTL_F_RJT] =		"LC fabric reject",		\
	[FC_RCTL_P_BSY] =		"LC port busy",			\
	[FC_RCTL_F_BSY] =		"LC fabric busy to data frame",	\
	[FC_RCTL_F_BSYL] =		"LC fabric busy to link control frame",\
	[FC_RCTL_LCR] =			"LC link credit reset",		\
	[FC_RCTL_END] =			"LC end",			\
}

/*
 * Well-known fabric addresses.
 */
enum fc_well_known_fid {
	FC_FID_NONE =           0x000000,       /* No destination */
	FC_FID_BCAST =		0xffffff,	/* broadcast */
	FC_FID_FLOGI =		0xfffffe,	/* fabric login */
	FC_FID_FCTRL =		0xfffffd,	/* fabric controller */
	FC_FID_DIR_SERV =	0xfffffc,	/* directory server */
	FC_FID_TIME_SERV =	0xfffffb,	/* time server */
	FC_FID_MGMT_SERV =	0xfffffa,	/* management server */
	FC_FID_QOS =		0xfffff9,	/* QoS Facilitator */
	FC_FID_ALIASES =	0xfffff8,	/* alias server (FC-PH2) */
	FC_FID_SEC_KEY =	0xfffff7,	/* Security key dist. server */
	FC_FID_CLOCK =		0xfffff6,	/* clock synch server */
	FC_FID_MCAST_SERV =	0xfffff5,	/* multicast server */
};

#define	FC_FID_WELL_KNOWN_MAX	0xffffff /* highest well-known fabric ID */
#define	FC_FID_WELL_KNOWN_BASE	0xfffff5 /* start of well-known fabric ID */

/*
 * Other well-known addresses, outside the above contiguous range.
 */
#define	FC_FID_DOM_MGR		0xfffc00	/* domain manager base */

/*
 * Fabric ID bytes.
 */
#define	FC_FID_DOMAIN		0
#define	FC_FID_PORT		1
#define	FC_FID_LINK		2

/*
 * fh_type codes
 */
enum fc_fh_type {
	FC_TYPE_BLS =	0x00,	/* basic link service */
	FC_TYPE_ELS =	0x01,	/* extended link service */
	FC_TYPE_IP =	0x05,	/* IP over FC, RFC 4338 */
	FC_TYPE_FCP =	0x08,	/* SCSI FCP */
	FC_TYPE_CT =	0x20,	/* Fibre Channel Services (FC-CT) */
	FC_TYPE_ILS =	0x22,	/* internal link service */
	FC_TYPE_NVME =	0x28,	/* FC-NVME */
};

/*
 * FC_TYPE names initializer.
 * Please keep this matching the above definitions.
 */
#define FC_TYPE_NAMES_INIT {				\
	[FC_TYPE_BLS] =		"BLS",			\
	[FC_TYPE_ELS] =		"ELS",			\
	[FC_TYPE_IP] =		"IP",			\
	[FC_TYPE_FCP] =		"FCP",			\
	[FC_TYPE_CT] =		"CT",			\
	[FC_TYPE_ILS] =		"ILS",			\
	[FC_TYPE_NVME] =	"NVME",			\
}

/*
 * Exchange IDs.
 */
#define FC_XID_UNKNOWN  0xffff	/* unknown exchange ID */
#define FC_XID_MIN	0x0	/* supported min exchange ID */
#define FC_XID_MAX	0xfffe	/* supported max exchange ID */

/*
 * fh_f_ctl - Frame control flags.
 */
#define	FC_FC_EX_CTX	(1 << 23)	/* sent by responder to exchange */
#define	FC_FC_SEQ_CTX	(1 << 22)	/* sent by responder to sequence */
#define	FC_FC_FIRST_SEQ (1 << 21)	/* first sequence of this exchange */
#define	FC_FC_LAST_SEQ	(1 << 20)	/* last sequence of this exchange */
#define	FC_FC_END_SEQ	(1 << 19)	/* last frame of sequence */
#define	FC_FC_END_CONN	(1 << 18)	/* end of class 1 connection pending */
#define	FC_FC_RES_B17	(1 << 17)	/* reserved */
#define	FC_FC_SEQ_INIT	(1 << 16)	/* transfer of sequence initiative */
#define	FC_FC_X_ID_REASS (1 << 15)	/* exchange ID has been changed */
#define	FC_FC_X_ID_INVAL (1 << 14)	/* exchange ID invalidated */

#define	FC_FC_ACK_1	(1 << 12)	/* 13:12 = 1: ACK_1 expected */
#define	FC_FC_ACK_N	(2 << 12)	/* 13:12 = 2: ACK_N expected */
#define	FC_FC_ACK_0	(3 << 12)	/* 13:12 = 3: ACK_0 expected */

#define	FC_FC_RES_B11	(1 << 11)	/* reserved */
#define	FC_FC_RES_B10	(1 << 10)	/* reserved */
#define	FC_FC_RETX_SEQ	(1 << 9)	/* retransmitted sequence */
#define	FC_FC_UNI_TX	(1 << 8)	/* unidirectional transmit (class 1) */
#define	FC_FC_CONT_SEQ(i) ((i) << 6)
#define	FC_FC_ABT_SEQ(i) ((i) << 4)
#define	FC_FC_REL_OFF	(1 << 3)	/* parameter is relative offset */
#define	FC_FC_RES2	(1 << 2)	/* reserved */
#define	FC_FC_FILL(i)	((i) & 3)	/* 1:0: bytes of trailing fill */

/*
 * BA_ACC payload.
 */
struct fc_ba_acc {
	__u8		ba_seq_id_val;	/* SEQ_ID validity */
#define FC_BA_SEQ_ID_VAL 0x80
	__u8		ba_seq_id;	/* SEQ_ID of seq last deliverable */
	__u8		ba_resvd[2];	/* reserved */
	__be16		ba_ox_id;	/* OX_ID for aborted seq or exch */
	__be16		ba_rx_id;	/* RX_ID for aborted seq or exch */
	__be16		ba_low_seq_cnt;	/* low SEQ_CNT of aborted seq */
	__be16		ba_high_seq_cnt; /* high SEQ_CNT of aborted seq */
};

/*
 * BA_RJT: Basic Reject payload.
 */
struct fc_ba_rjt {
	__u8		br_resvd;	/* reserved */
	__u8		br_reason;	/* reason code */
	__u8		br_explan;	/* reason explanation */
	__u8		br_vendor;	/* vendor unique code */
};

/*
 * BA_RJT reason codes.
 * From FS-2.
 */
enum fc_ba_rjt_reason {
	FC_BA_RJT_NONE =	0,	/* in software this means no reject */
	FC_BA_RJT_INVL_CMD =	0x01,	/* invalid command code */
	FC_BA_RJT_LOG_ERR =	0x03,	/* logical error */
	FC_BA_RJT_LOG_BUSY =	0x05,	/* logical busy */
	FC_BA_RJT_PROTO_ERR =	0x07,	/* protocol error */
	FC_BA_RJT_UNABLE =	0x09,	/* unable to perform request */
	FC_BA_RJT_VENDOR =	0xff,	/* vendor-specific (see br_vendor) */
};

/*
 * BA_RJT reason code explanations.
 */
enum fc_ba_rjt_explan {
	FC_BA_RJT_EXP_NONE =	0x00,	/* no additional expanation */
	FC_BA_RJT_INV_XID =	0x03,	/* invalid OX_ID-RX_ID combination */
	FC_BA_RJT_ABT =		0x05,	/* sequence aborted, no seq info */
};

/*
 * P_RJT or F_RJT: Port Reject or Fabric Reject parameter field.
 */
struct fc_pf_rjt {
	__u8		rj_action;	/* reserved */
	__u8		rj_reason;	/* reason code */
	__u8		rj_resvd;	/* reserved */
	__u8		rj_vendor;	/* vendor unique code */
};

/*
 * P_RJT and F_RJT reject reason codes.
 */
enum fc_pf_rjt_reason {
	FC_RJT_NONE =		0,	/* non-reject (reserved by standard) */
	FC_RJT_INVL_DID =	0x01,	/* invalid destination ID */
	FC_RJT_INVL_SID =	0x02,	/* invalid source ID */
	FC_RJT_P_UNAV_T =	0x03,	/* port unavailable, temporary */
	FC_RJT_P_UNAV =		0x04,	/* port unavailable, permanent */
	FC_RJT_CLS_UNSUP =	0x05,	/* class not supported */
	FC_RJT_DEL_USAGE =	0x06,	/* delimiter usage error */
	FC_RJT_TYPE_UNSUP =	0x07,	/* type not supported */
	FC_RJT_LINK_CTL =	0x08,	/* invalid link control */
	FC_RJT_R_CTL =		0x09,	/* invalid R_CTL field */
	FC_RJT_F_CTL =		0x0a,	/* invalid F_CTL field */
	FC_RJT_OX_ID =		0x0b,	/* invalid originator exchange ID */
	FC_RJT_RX_ID =		0x0c,	/* invalid responder exchange ID */
	FC_RJT_SEQ_ID =		0x0d,	/* invalid sequence ID */
	FC_RJT_DF_CTL =		0x0e,	/* invalid DF_CTL field */
	FC_RJT_SEQ_CNT =	0x0f,	/* invalid SEQ_CNT field */
	FC_RJT_PARAM =		0x10,	/* invalid parameter field */
	FC_RJT_EXCH_ERR =	0x11,	/* exchange error */
	FC_RJT_PROTO =		0x12,	/* protocol error */
	FC_RJT_LEN =		0x13,	/* incorrect length */
	FC_RJT_UNEXP_ACK =	0x14,	/* unexpected ACK */
	FC_RJT_FAB_CLASS =	0x15,	/* class unsupported by fabric entity */
	FC_RJT_LOGI_REQ =	0x16,	/* login required */
	FC_RJT_SEQ_XS =		0x17,	/* excessive sequences attempted */
	FC_RJT_EXCH_EST =	0x18,	/* unable to establish exchange */
	FC_RJT_FAB_UNAV =	0x1a,	/* fabric unavailable */
	FC_RJT_VC_ID =		0x1b,	/* invalid VC_ID (class 4) */
	FC_RJT_CS_CTL =		0x1c,	/* invalid CS_CTL field */
	FC_RJT_INSUF_RES =	0x1d,	/* insuff. resources for VC (Class 4) */
	FC_RJT_INVL_CLS =	0x1f,	/* invalid class of service */
	FC_RJT_PREEMT_RJT =	0x20,	/* preemption request rejected */
	FC_RJT_PREEMT_DIS =	0x21,	/* preemption not enabled */
	FC_RJT_MCAST_ERR =	0x22,	/* multicast error */
	FC_RJT_MCAST_ET =	0x23,	/* multicast error terminate */
	FC_RJT_PRLI_REQ =	0x24,	/* process login required */
	FC_RJT_INVL_ATT =	0x25,	/* invalid attachment */
	FC_RJT_VENDOR =		0xff,	/* vendor specific reject */
};

/* default timeout values */

#define FC_DEF_E_D_TOV	2000UL
#define FC_DEF_R_A_TOV	10000UL

#endif /* _FC_FS_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         