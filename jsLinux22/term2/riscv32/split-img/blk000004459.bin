ormRandomNumberGenerator& __urng)
      {
	const double __y = _M_gd(__urng);

	// XXX Is the constructor too slow?
	std::poisson_distribution<result_type> __poisson(__y);
	return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename negative_binomial_distribution<_IntType>::result_type
      negative_binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __p)
      {
	typedef typename std::gamma_distribution<double>::param_type
	  param_type;
	
	const double __y =
	  _M_gd(__urng, param_type(__p.k(), (1.0 - __p.p()) / __p.p()));

	std::poisson_distribution<result_type> __poisson(__y);
	return __poisson(__urng);
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	while (__f != __t)
	  {
	    const double __y = _M_gd(__urng);

	    // XXX Is the constructor too slow?
	    std::poisson_distribution<result_type> __poisson(__y);
	    *__f++ = __poisson(__urng);
	  }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      negative_binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __p)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	typename std::gamma_distribution<result_type>::param_type
	  __p2(__p.k(), (1.0 - __p.p()) / __p.p());

	while (__f != __t)
	  {
	    const double __y = _M_gd(__urng, __p2);

	    std::poisson_distribution<result_type> __poisson(__y);
	    *__f++ = __poisson(__urng);
	  }
      }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.k() << __space << __x.p()
	   << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       negative_binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      _IntType __k;
      double __p;
      if (__is >> __k >> __p >> __x._M_gd)
	__x.param(typename negative_binomial_distribution<_IntType>::
		  param_type(__k, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    poisson_distribution<_IntType>::param_type::
    _M_initialize()
    {
#if _GLIBCXX_USE_C99_MATH_TR1
      if (_M_mean >= 12)
	{
	  const double __m = std::floor(_M_mean);
	  _M_lm_thr = std::log(_M_mean);
	  _M_lfm = std::lgamma(__m + 1);
	  _M_sm = std::sqrt(__m);

	  const double __pi_4 = 0.7853981633974483096156608458198757L;
	  const double __dx = std::sqrt(2 * __m * std::log(32 * __m
							      / __pi_4));
	  _M_d = std::round(std::max<double>(6.0, std::min(__m, __dx)));
	  const double __cx = 2 * __m + _M_d;
	  _M_scx = std::sqrt(__cx / 2);
	  _M_1cx = 1 / __cx;

	  _M_c2b = std::sqrt(__pi_4 * __cx) * std::exp(_M_1cx);
	  _M_cb = 2 * __cx * std::exp(-_M_d * _M_1cx * (1 + _M_d / 2))
		/ _M_d;
	}
      else
#endif
	_M_lm_thr = std::exp(-_M_mean);
      }

  /**
   * A rejection algorithm when mean >= 12 and a simple method based
   * upon the multiplication of uniform random variates otherwise.
   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
   * is defined.
   *
   * Reference:
   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
   * New York, 1986, Ch. X, Sects. 3.3 & 3.4 (+ Errata!).
   */
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename poisson_distribution<_IntType>::result_type
      poisson_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __param)
      {
	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
	  __aurng(__urng);
#if _GLIBCXX_USE_C99_MATH_TR1
	if (__param.mean() >= 12)
	  {
	    double __x;

	    // See comments above...
	    const double __naf =
	      (1 - std::numeric_limits<double>::epsilon()) / 2;
	    const double __thr =
	      std::numeric_limits<_IntType>::max() + __naf;

	    const double __m = std::floor(__param.mean());
	    // sqrt(pi / 2)
	    const double __spi_2 = 1.2533141373155002512078826424055226L;
	    const double __c1 = __param._M_sm * __spi_2;
	    const double __c2 = __param._M_c2b + __c1;
	    const double __c3 = __c2 + 1;
	    const double __c4 = __c3 + 1;
	    // 1 / 78
	    const double __178 = 0.0128205128205128205128205128205128L;
	    // e^(1 / 78)
	    const double __e178 = 1.0129030479320018583185514777512983L;
	    const double __c5 = __c4 + __e178;
	    const double __c = __param._M_cb + __c5;
	    const double __2cx = 2 * (2 * __m + __param._M_d);

	    bool __reject = true;
	    do
	      {
		const double __u = __c * __aurng();
		const double __e = -std::log(1.0 - __aurng());

		double __w = 0.0;

		if (__u <= __c1)
		  {
		    const double __n = _M_nd(__urng);
		    const double __y = -std::abs(__n) * __param._M_sm - 1;
		    __x = std::floor(__y);
		    __w = -__n * __n / 2;
		    if (__x < -__m)
		      continue;
		  }
		else if (__u <= __c2)
		  {
		    const double __n = _M_nd(__urng);
		    const double __y = 1 + std::abs(__n) * __param._M_scx;
		    __x = std::ceil(__y);
		    __w = __y * (2 - __y) * __param._M_1cx;
		    if (__x > __param._M_d)
		      continue;
		  }
		else if (__u <= __c3)
		  // NB: This case not in the book, nor in the Errata,
		  // but should be ok...
		  __x = -1;
		else if (__u <= __c4)
		  __x = 0;
		else if (__u <= __c5)
		  {
		    __x = 1;
		    // Only in the Errata, see libstdc++/83237.
		    __w = __178;
		  }
		else
		  {
		    const double __v = -std::log(1.0 - __aurng());
		    const double __y = __param._M_d
				     + __v * __2cx / __param._M_d;
		    __x = std::ceil(__y);
		    __w = -__param._M_d * __param._M_1cx * (1 + __y / 2);
		  }

		__reject = (__w - __e - __x * __param._M_lm_thr
			    > __param._M_lfm - std::lgamma(__x + __m + 1));

		__reject |= __x + __m >= __thr;

	      } while (__reject);

	    return result_type(__x + __m + __naf);
	  }
	else
#endif
	  {
	    _IntType     __x = 0;
	    double __prod = 1.0;

	    do
	      {
		__prod *= __aurng();
		__x += 1;
	      }
	    while (__prod > __param._M_lm_thr);

	    return __x - 1;
	  }
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      poisson_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __param)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	// We could duplicate everything from operator()...
	while (__f != __t)
	  *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.mean() << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       poisson_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::skipws);

      double __mean;
      if (__is >> __mean >> __x._M_nd)
	__x.param(typename poisson_distribution<_IntType>::param_type(__mean));

      __is.flags(__flags);
      return __is;
    }


  template<typename _IntType>
    void
    binomial_distribution<_IntType>::param_type::
    _M_initialize()
    {
      const double __p12 = _M_p <= 0.5 ? _M_p : 1.0 - _M_p;

      _M_easy = true;

#if _GLIBCXX_USE_C99_MATH_TR1
      if (_M_t * __p12 >= 8)
	{
	  _M_easy = false;
	  const double __np = std::floor(_M_t * __p12);
	  const double __pa = __np / _M_t;
	  const double __1p = 1 - __pa;

	  const double __pi_4 = 0.7853981633974483096156608458198757L;
	  const double __d1x =
	    std::sqrt(__np * __1p * std::log(32 * __np
					     / (81 * __pi_4 * __1p)));
	  _M_d1 = std::round(std::max<double>(1.0, __d1x));
	  const double __d2x =
	    std::sqrt(__np * __1p * std::log(32 * _M_t * __1p
					     / (__pi_4 * __pa)));
	  _M_d2 = std::round(std::max<double>(1.0, __d2x));

	  // sqrt(pi / 2)
	  const double __spi_2 = 1.2533141373155002512078826424055226L;
	  _M_s1 = std::sqrt(__np * __1p) * (1 + _M_d1 / (4 * __np));
	  _M_s2 = std::sqrt(__np * __1p) * (1 + _M_d2 / (4 * _M_t * __1p));
	  _M_c = 2 * _M_d1 / __np;
	  _M_a1 = std::exp(_M_c) * _M_s1 * __spi_2;
	  const double __a12 = _M_a1 + _M_s2 * __spi_2;
	  const double __s1s = _M_s1 * _M_s1;
	  _M_a123 = __a12 + (std::exp(_M_d1 / (_M_t * __1p))
			     * 2 * __s1s / _M_d1
			     * std::exp(-_M_d1 * _M_d1 / (2 * __s1s)));
	  const double __s2s = _M_s2 * _M_s2;
	  _M_s = (_M_a123 + 2 * __s2s / _M_d2
		  * std::exp(-_M_d2 * _M_d2 / (2 * __s2s)));
	  _M_lf = (std::lgamma(__np + 1)
		   + std::lgamma(_M_t - __np + 1));
	  _M_lp1p = std::log(__pa / __1p);

	  _M_q = -std::log(1 - (__p12 - __pa) / __1p);
	}
      else
#endif
	_M_q = -std::log(1 - __p12);
    }

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      _M_waiting(_UniformRandomNumberGenerator& __urng,
		 _IntType __t, double __q)
      {
	_IntType __x = 0;
	double __sum = 0.0;
	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
	  __aurng(__urng);

	do
	  {
	    if (__t == __x)
	      return __x;
	    const double __e = -std::log(1.0 - __aurng());
	    __sum += __e / (__t - __x);
	    __x += 1;
	  }
	while (__sum <= __q);

	return __x - 1;
      }

  /**
   * A rejection algorithm when t * p >= 8 and a simple waiting time
   * method - the second in the referenced book - otherwise.
   * NB: The former is available only if _GLIBCXX_USE_C99_MATH_TR1
   * is defined.
   *
   * Reference:
   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
   * New York, 1986, C\‹  ]‹  ^‹  _‹  `‹  a‹  b‹  c‹  d‹  e‹  f‹  g‹  h‹  i‹                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          h. X, Sect. 4 (+ Errata!).
   */
  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename binomial_distribution<_IntType>::result_type
      binomial_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __param)
      {
	result_type __ret;
	const _IntType __t = __param.t();
	const double __p = __param.p();
	const double __p12 = __p <= 0.5 ? __p : 1.0 - __p;
	__detail::_Adaptor<_UniformRandomNumberGenerator, double>
	  __aurng(__urng);

#if _GLIBCXX_USE_C99_MATH_TR1
	if (!__param._M_easy)
	  {
	    double __x;

	    // See comments above...
	    const double __naf =
	      (1 - std::numeric_limits<double>::epsilon()) / 2;
	    const double __thr =
	      std::numeric_limits<_IntType>::max() + __naf;

	    const double __np = std::floor(__t * __p12);

	    // sqrt(pi / 2)
	    const double __spi_2 = 1.2533141373155002512078826424055226L;
	    const double __a1 = __param._M_a1;
	    const double __a12 = __a1 + __param._M_s2 * __spi_2;
	    const double __a123 = __param._M_a123;
	    const double __s1s = __param._M_s1 * __param._M_s1;
	    const double __s2s = __param._M_s2 * __param._M_s2;

	    bool __reject;
	    do
	      {
		const double __u = __param._M_s * __aurng();

		double __v;

		if (__u <= __a1)
		  {
		    const double __n = _M_nd(__urng);
		    const double __y = __param._M_s1 * std::abs(__n);
		    __reject = __y >= __param._M_d1;
		    if (!__reject)
		      {
			const double __e = -std::log(1.0 - __aurng());
			__x = std::floor(__y);
			__v = -__e - __n * __n / 2 + __param._M_c;
		      }
		  }
		else if (__u <= __a12)
		  {
		    const double __n = _M_nd(__urng);
		    const double __y = __param._M_s2 * std::abs(__n);
		    __reject = __y >= __param._M_d2;
		    if (!__reject)
		      {
			const double __e = -std::log(1.0 - __aurng());
			__x = std::floor(-__y);
			__v = -__e - __n * __n / 2;
		      }
		  }
		else if (__u <= __a123)
		  {
		    const double __e1 = -std::log(1.0 - __aurng());
		    const double __e2 = -std::log(1.0 - __aurng());

		    const double __y = __param._M_d1
				     + 2 * __s1s * __e1 / __param._M_d1;
		    __x = std::floor(__y);
		    __v = (-__e2 + __param._M_d1 * (1 / (__t - __np)
						    -__y / (2 * __s1s)));
		    __reject = false;
		  }
		else
		  {
		    const double __e1 = -std::log(1.0 - __aurng());
		    const double __e2 = -std::log(1.0 - __aurng());

		    const double __y = __param._M_d2
				     + 2 * __s2s * __e1 / __param._M_d2;
		    __x = std::floor(-__y);
		    __v = -__e2 - __param._M_d2 * __y / (2 * __s2s);
		    __reject = false;
		  }

		__reject = __reject || __x < -__np || __x > __t - __np;
		if (!__reject)
		  {
		    const double __lfx =
		      std::lgamma(__np + __x + 1)
		      + std::lgamma(__t - (__np + __x) + 1);
		    __reject = __v > __param._M_lf - __lfx
			     + __x * __param._M_lp1p;
		  }

		__reject |= __x + __np >= __thr;
	      }
	    while (__reject);

	    __x += __np + __naf;

	    const _IntType __z = _M_waiting(__urng, __t - _IntType(__x),
					    __param._M_q);
	    __ret = _IntType(__x) + __z;
	  }
	else
#endif
	  __ret = _M_waiting(__urng, __t, __param._M_q);

	if (__p12 != __p)
	  __ret = __t - __ret;
	return __ret;
      }

  template<typename _IntType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      binomial_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __param)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	// We could duplicate everything from operator()...
	while (__f != __t)
	  *__f++ = this->operator()(__urng, __param);
      }

  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<double>::max_digits10);

      __os << __x.t() << __space << __x.p()
	   << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _IntType,
	   typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       binomial_distribution<_IntType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _IntType __t;
      double __p;
      if (__is >> __t >> __p >> __x._M_nd)
	__x.param(typename binomial_distribution<_IntType>::
		  param_type(__t, __p));

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      std::exponential_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __p)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	  __aurng(__urng);
	while (__f != __t)
	  *__f++ = -std::log(result_type(1) - __aurng()) / __p.lambda();
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__os.widen(' '));
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.lambda();

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       exponential_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __lambda;
      if (__is >> __lambda)
	__x.param(typename exponential_distribution<_RealType>::
		  param_type(__lambda));

      __is.flags(__flags);
      return __is;
    }


  /**
   * Polar method due to Marsaglia.
   *
   * Devroye, L. Non-Uniform Random Variates Generation. Springer-Verlag,
   * New York, 1986, Ch. V, Sect. 4.4.
   */
  template<typename _RealType>
    template<typename _UniformRandomNumberGenerator>
      typename normal_distribution<_RealType>::result_type
      normal_distribution<_RealType>::
      operator()(_UniformRandomNumberGenerator& __urng,
		 const param_type& __param)
      {
	result_type __ret;
	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	  __aurng(__urng);

	if (_M_saved_available)
	  {
	    _M_saved_available = false;
	    __ret = _M_saved;
	  }
	else
	  {
	    result_type __x, __y, __r2;
	    do
	      {
		__x = result_type(2.0) * __aurng() - 1.0;
		__y = result_type(2.0) * __aurng() - 1.0;
		__r2 = __x * __x + __y * __y;
	      }
	    while (__r2 > 1.0 || __r2 == 0.0);

	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
	    _M_saved = __x * __mult;
	    _M_saved_available = true;
	    __ret = __y * __mult;
	  }

	__ret = __ret * __param.stddev() + __param.mean();
	return __ret;
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      normal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __param)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)

	if (__f == __t)
	  return;

	if (_M_saved_available)
	  {
	    _M_saved_available = false;
	    *__f++ = _M_saved * __param.stddev() + __param.mean();

	    if (__f == __t)
	      return;
	  }

	__detail::_Adaptor<_UniformRandomNumberGenerator, result_type>
	  __aurng(__urng);

	while (__f + 1 < __t)
	  {
	    result_type __x, __y, __r2;
	    do
	      {
		__x = result_type(2.0) * __aurng() - 1.0;
		__y = result_type(2.0) * __aurng() - 1.0;
		__r2 = __x * __x + __y * __y;
	      }
	    while (__r2 > 1.0 || __r2 == 0.0);

	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
	    *__f++ = __y * __mult * __param.stddev() + __param.mean();
	    *__f++ = __x * __mult * __param.stddev() + __param.mean();
	  }

	if (__f != __t)
	  {
	    result_type __x, __y, __r2;
	    do
	      {
		__x = result_type(2.0) * __aurng() - 1.0;
		__y = result_type(2.0) * __aurng() - 1.0;
		__r2 = __x * __x + __y * __y;
	      }
	    while (__r2 > 1.0 || __r2 == 0.0);

	    const result_type __mult = std::sqrt(-2 * std::log(__r2) / __r2);
	    _M_saved = __x * __mult;
	    _M_saved_available = true;
	    *__f = __y * __mult * __param.stddev() + __param.mean();
	  }
      }

  template<typename _RealType>
    bool
    operator==(const std::normal_distribution<_RealType>& __d1,
	       const std::normal_distribution<_RealType>& __d2)
    {
      if (__d1._M_param == __d2._M_param
	  && __d1._M_saved_available == __d2._M_saved_available)
	{
	  if (__d1._M_saved_available
	      && __d1._M_saved == __d2._M_saved)
	    return true;
	  else if(!__d1._M_saved_available)
	    return true;
	  else
	    return false;
	}
      else
	return false;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const normal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.mean() << __space << __x.stddev()
	   << __space << __x._M_saved_available;
      if (__x._M_saved_available)
	__os << __space << __x._M_saved;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       normal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      double __mean, __stddev;
      bool __saved_avail;
      if (__is >> __mean >> __stddev >> __saved_avail)
	{
	  if (!__saved_avail || (__is >> __x._M_saved))
	    {
	      __x._M_saved_available = __saved_avail;
	      __x.param(typename normal_distribution<_RealType>::
			param_type(__mean, __stddev));
	    }
	}

      __is.flags(__flags);
      return __is;
    }


  template<typename _RealType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      lognormal_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const param_type& __p)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	  while (__f != __t)
	    *__f++ = std::exp(__p.s() * _M_nd(__urng) + __p.m());
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.m() << __space << __x.s()
	   << __space << __x._M_nd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      return __os;
    }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_istream<_CharT, _Traits>&
    operator>>(std::basic_istream<_CharT, _Traits>& __is,
	       lognormal_distribution<_RealType>& __x)
    {
      typedef std::basic_istream<_CharT, _Traits>  __istream_type;
      typedef typename __istream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __is.flags();
      __is.flags(__ios_base::dec | __ios_base::skipws);

      _RealType __m, __s;
      if (__is >> __m >> __s >> __x._M_nd)
	__x.param(typename lognormal_distribution<_RealType>::
		  param_type(__m, __s));

      __is.flags(__flags);
      return __is;
    }

  template<typename _RealType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	while (__f != __t)
	  *__f++ = 2 * _M_gd(__urng);
      }

  template<typename _RealType>
    template<typename _ForwardIterator,
	     typename _UniformRandomNumberGenerator>
      void
      std::chi_squared_distribution<_RealType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
		      _UniformRandomNumberGenerator& __urng,
		      const typename
		      std::gamma_distribution<result_type>::param_type& __p)
      {
	__glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
	while (__f != __t)
	  *__f++ = 2 * _M_gd(__urng, __p);
      }

  template<typename _RealType, typename _CharT, typename _Traits>
    std::basic_ostream<_CharT, _Traits>&
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
	       const chi_squared_distribution<_RealType>& __x)
    {
      typedef std::basic_ostream<_CharT, _Traits>  __ostream_type;
      typedef typename __ostream_type::ios_base    __ios_base;

      const typename __ios_base::fmtflags __flags = __os.flags();
      const _CharT __fill = __os.fill();
      const std::streamsize __precision = __os.precision();
      const _CharT __space = __os.widen(' ');
      __os.flags(__ios_base::scientific | __ios_base::left);
      __os.fill(__space);
      __os.precision(std::numeric_limits<_RealType>::max_digits10);

      __os << __x.n() << __space << __x._M_gd;

      __os.flags(__flags);
      __os.fill(__fill);
      __os.precision(__precision);
      ret