e<class _InputIterator>
	void
	insert(iterator __position, _InputIterator __first,
	       _InputIterator __last)
	{
	  typename __gnu_debug::_Distance_traits<_InputIterator>::__type __dist;
	  __glibcxx_check_insert_range(__position, __first, __last, __dist);

	  if (__dist.second >= __gnu_debug::__dp_sign)
	    _Base::insert(__position.base(), __gnu_debug::__unsafe(__first),
					     __gnu_debug::__unsafe(__last));
	  else
	    _Base::insert(__position.base(), __first, __last);
	}
#endif

    private:
      _Base_iterator
#if __cplusplus >= 201103L
      _M_erase(_Base_const_iterator __position) noexcept
#else
      _M_erase(_Base_iterator __position)
#endif
      {
	this->_M_invalidate_if(_Equal(__position));
	return _Base::erase(__position);
      }

    public:
      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __position) noexcept
#else
      erase(iterator __position)
#endif
      {
	__glibcxx_check_erase(__position);
	return iterator(_M_erase(__position.base()), this);
      }

      iterator
#if __cplusplus >= 201103L
      erase(const_iterator __first, const_iterator __last) noexcept
#else
      erase(iterator __first, iterator __last)
#endif
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 151. can't currently clear() empty container
	__glibcxx_check_erase_range(__first, __last);
	for (_Base_const_iterator __victim = __first.base();
	     __victim != __last.base(); ++__victim)
	  {
	    _GLIBCXX_DEBUG_VERIFY(__victim != _Base::end(),
				  _M_message(__gnu_debug::__msg_valid_range)
				  ._M_iterator(__first, "position")
				  ._M_iterator(__last, "last"));
	    this->_M_invalidate_if(_Equal(__victim));
	  }

	return iterator(_Base::erase(__first.base(), __last.base()), this);
      }

      void
      swap(list& __x)
      _GLIBCXX_NOEXCEPT_IF( noexcept(declval<_Base&>().swap(__x)) )
      {
	_Safe::_M_swap(__x);
	_Base::swap(__x);
      }

      void
      clear() _GLIBCXX_NOEXCEPT
      {
	_Base::clear();
	this->_M_invalidate_all();
      }

      // 23.2.2.4 list operations:
      void
#if __cplusplus >= 201103L
      splice(const_iterator __position, list&& __x) noexcept
#else
      splice(iterator __position, list& __x)
#endif
      {
	_GLIBCXX_DEBUG_VERIFY(std::__addressof(__x) != this,
			      _M_message(__gnu_debug::__msg_self_splice)
			      ._M_sequence(*this, "this"));
	this->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));
	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()));
      }

#if __cplusplus >= 201103L
      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
#endif

      void
#if __cplusplus >= 201103L
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
#else
      splice(iterator __position, list& __x, iterator __i)
#endif
      {
	__glibcxx_check_insert(__position);

	// We used to perform the splice_alloc check:  not anymore, redundant
	// after implementing the relevant bits of N1599.

	_GLIBCXX_DEBUG_VERIFY(__i._M_dereferenceable(),
			      _M_message(__gnu_debug::__msg_splice_bad)
			      ._M_iterator(__i, "__i"));
	_GLIBCXX_DEBUG_VERIFY(__i._M_attached_to(std::__addressof(__x)),
			      _M_message(__gnu_debug::__msg_splice_other)
			      ._M_iterator(__i, "__i")._M_sequence(__x, "__x"));

	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 250. splicing invalidates iterators
	this->_M_transfer_from_if(__x, _Equal(__i.base()));
	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),
		      __i.base());
      }

#if __cplusplus >= 201103L
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
#endif

      void
#if __cplusplus >= 201103L
      splice(const_iterator __position, list&& __x, const_iterator __first,
	     const_iterator __last) noexcept
#else
      splice(iterator __position, list& __x, iterator __first,
	     iterator __last)
#endif
      {
	__glibcxx_check_insert(__position);
	__glibcxx_check_valid_range(__first, __last);
	_GLIBCXX_DEBUG_VERIFY(__first._M_attached_to(std::__addressof(__x)),
			      _M_message(__gnu_debug::__msg_splice_other)
			      ._M_sequence(__x, "x")
			      ._M_iterator(__first, "first"));

	// We used to perform the splice_alloc check:  not anymore, redundant
	// after implementing the relevant bits of N1599.

	for (_Base_const_iterator __tmp = __first.base();
	     __tmp != __last.base(); ++__tmp)
	  {
	    _GLIBCXX_DEBUG_VERIFY(__tmp != _Base::end(),
				  _M_message(__gnu_debug::__msg_valid_range)
				  ._M_iterator(__first, "first")
				  ._M_iterator(__last, "last"));
	    _GLIBCXX_DEBUG_VERIFY(std::__addressof(__x) != this
				  || __tmp != __position.base(),
				_M_message(__gnu_debug::__msg_splice_overlap)
				  ._M_iterator(__tmp, "position")
				  ._M_iterator(__first, "first")
				  ._M_iterator(__last, "last"));

	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
	    // 250. splicing invalidates iterators
	    this->_M_transfer_from_if(__x, _Equal(__tmp));
	  }

	_Base::splice(__position.base(), _GLIBCXX_MOVE(__x._M_base()),
		      __first.base(), __last.base());
      }

#if __cplusplus >= 201103L
      void
      splice(const_iterator __position, list& __x,
	     const_iterator __first, const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
#endif

    private:
#if __cplusplus > 201703L
      typedef size_type __remove_return_type;
# define _GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG \
      __attribute__((__abi_tag__("__cxx20")))
# define _GLIBCXX20_ONLY(__expr) __expr
#else
      typedef void __remove_return_type;
# define _GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG
# define _GLIBCXX20_ONLY(__expr)
#endif

    public:
      _GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG
      __remove_return_type
      remove(const _Tp& __value)
      {
	if (!this->_M_iterators && !this->_M_const_iterators)
	  return _Base::remove(__value);

	size_type __removed __attribute__((__unused__)) = 0;
	_Base_iterator __first = _Base::begin();
	_Base_iterator __last = _Base::end();
	_Base_iterator __extra = __last;
	while (__first != __last)
	  {
	    if (*__first == __value)
	      // _GLIBCXX_RESOLVE_LIB_DEFECTS
	      // 526. Is it undefined if a function in the standard changes
	      // in parameters?
	      if (std::__addressof(*__first) != std::__addressof(__value))
		{
		  __first = _M_erase(__first);
		  _GLIBCXX20_ONLY( __removed++ );
		}
	      else
		{
		  __extra = __first;
		  ++__first;
		}
	    else
	      ++__first;
	  }

	if (__extra != __last)
	  {
	    _M_erase(__extra);
	    _GLIBCXX20_ONLY( __removed++ );
	  }
	return _GLIBCXX20_ONLY( __removed );
      }

      template<class _Predicate>
	__remove_return_type
	remove_if(_Predicate __pred)
	{
	  if (!this->_M_iterators && !this->_M_const_iterators)
	    return _Base::remove_if(__pred);

	  size_type __removed __attribute__((__unused__)) = 0;
	  for (_Base_iterator __x = _Base::begin(); __x != _Base::end(); )
	    if (__pred(*__x))
	      {
		__x = _M_erase(__x);
		_GLIBCXX20_ONLY( __removed++ );
	      }
	    else
	      ++__x;

	  return _GLIBCXX20_ONLY( __removed );
	}

      _GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG
      __remove_return_type
      unique()
      {
	if (!this->_M_iterators && !this->_M_const_iterators)
	  return _Base::unique();

	if (empty())
	  return _GLIBCXX20_ONLY(0);

        size_type __removed __attribute__((__unused__)) = 0;
	_Base_iterator __first = _Base::begin();
	_Base_iterator __last = _Base::end();
	_Base_iterator __next = __first;
	while (++__next != __last)
	  if (*__first == *__next)
	    {
	      _M_erase(__next);
	      __next = __first;
	      _GLIBCXX20_ONLY( __removed++ );
	    }
	  else
	    __first = __next;

	return _GLIBCXX20_ONLY( __removed );
      }

      template<class _BinaryPredicate>
	__remove_return_type
	unique(_BinaryPredicate __binary_pred)
	{
	  if (!this->_M_iterators && !this->_M_const_iterators)
	    return _Base::unique(__binary_pred);

	  if (empty())
	    return _GLIBCXX20_ONLY(0);

	  size_type __removed __attribute__((__unused__)) = 0;
	  _Base_iterator __first = _Base::begin();
	  _Base_iterator __last = _Base::end();
	  _Base_iterator __next = __first;;
	  while (++__next != __last)
	    if (__binary_pred(*__first, *__next))
	      {
		_M_erase(__next);
		__next = __first;
		_GLIBCXX20_ONLY( __removed++ );
	      }
	    else
	      __first = __next;

	  return _GLIBCXX20_ONLY( __removed );
	}

#undef _GLIBCXX_LIST_REMOVE_RETURN_TYPE_TAG
#undef _GLIBCXX20_ONLY

      void
#if __cplusplus >= 201103L
      merge(list&& __x)
#else
      merge(list& __x)
#endif
      {
	// _GLIBCXX_RESOLVE_LIB_DEFECTS
	// 300. list::merge() specification incomplete
	if (this != std::__addressof(__x))
	  {
	    __glibcxx_check_sorted(_Base::begin(), _Base::end());
	    __glibcxx_check_sorted(__x.begin().base(), __x.end().base());
	    this->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));
	    _Base::merge(_GLIBCXX_MOVE(__x._M_base()));
	  }
      }

#if __cplusplus >= 201103L
      void
      merge(list& __x)
      { merge(std::move(__x)); }
#endif

      template<class _Compare>
	void
#if __cplusplus >= 201103L
	merge(list&& __x, _Compare __comp)
#else
	merge(list& __x, _Compare __comp)
#endif
	{
	  // _GLIBCXX_RESOLVE_LIB_DEFECTS
	  // 300. list::merge() specification incomplete
	  if (this != std::__addressof(__x))
	    {
	      __glibcxx_check_sorted_pred(_Base::begin(), _Base::end(),
					  __comp);
	      __glibcxx_check_sorted_pred(__x.begin().base(), __x.end().base(),
					  __comp);
	      this->_M_transfer_from_if(__x, _Not_equal(__x._M_base().end()));
	      _Base::merge(_GLIBCXX_MOVE(__x._M_base()), __comp);
	    }
	}

#if __cplusplus >= 201103L
      template<typename _Compare>
	void
	merge(list& __x, _Compare __comp)
	{ merge(std::move(__x), __comp); }
#endif

      void
      sort() { _Base::sort(); }

      template<typename _StrictWeakOrdering>
	void
	sort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }

      using _Base::reverse;

      _Base&
      _M_base() _GLIBCXX_NOEXCEPT	{ return *this; }

      const _Base&
      _M_base() const _GLIBCXX_NOEXCEPT	{ return *this; }
    };

#if __cpp_deduction_guides >= 201606
  template<typename _InputIterator, typename _ValT
	     = typename iterator_traits<_InputIterator>::value_type,
	   typename _Allocator = allocator<_ValT>,
	   typename = _RequireInputIter<_InputIterator>,
	   typename = _RequireAllocator<_Allocator>>
    list(_InputIterator, _InputIterator, _Allocator = _Allocator())
      -> list<_ValT, _Allocator>;
#endif

  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __lhs,
	       const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() == __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __lhs,
	       const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() != __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __lhs,
	      const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() < __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __lhs,
	       const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() <= __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __lhs,
	       const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() >= __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __lhs,
	      const list<_Tp, _Alloc>& __rhs)
    { return __lhs._M_base() > __rhs._M_base(); }

  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __lhs, list<_Tp, _Alloc>& __rhs)
    _GLIBCXX_NOEXCEPT_IF(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

} // namespace __debug
} // namespace std

namespace __gnu_debug
{
#ifndef _GLIBCXX_USE_CXX11_ABI
  // If not using C++11 list::size() is not in O(1) so we do not use it.
  template<typename _Tp, typename _Alloc>
    struct _Sequence_traits<std::__debug::list<_Tp, _Alloc> >
    {
      typedef typename std::__debug::list<_Tp, _Alloc>::iterator _It;

      static typename _Distance_traits<_It>::__type
      _S_size(const std::__debug::list<_Tp, _Alloc>& __seq)
      {
	return __seq.empty()
	  ? std::make_pair(0, __dp_exact) : std::make_pair(1, __dp_equality);
      }
    };
#endif

#ifndef _GLIBCXX_DEBUG_PEDANTIC
  template<class _Tp, class _Alloc>
    struct _Insert_range_from_self_is_safe<std::__debug::list<_Tp, _Alloc> >
    { enum { __value = 1 }; };
#endif
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // Debugging support implementation -*- C++ -*-

// Copyright (C) 2003-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file debug/macros.h
 *  This file is a GNU debug extension to the Standard C++ Library.
 */

#ifndef _GLIBCXX_DEBUG_MACROS_H
#define _GLIBCXX_DEBUG_MACROS_H 1

/**
 * Macros used by the implementation to verify certain
 * properties. These macros may only be used directly by the debug
 * wrappers. Note that these are macros (instead of the more obviously
 * @a correct choice of making them functions) because we need line and
 * file information at the call site, to minimize the distance between
 * the user error and where the error is reported.
 *
 */
#define _GLIBCXX_DEBUG_VERIFY_COND_AT(_Cond,_ErrMsg,_File,_Line,_Func)	\
  if (! (_Cond))							\
    __gnu_debug::_Error_formatter::_S_at(_File, _Line, _Func)		\
      ._ErrMsg._M_error()

#define _GLIBCXX_DEBUG_VERIFY_AT_F(_Cond,_ErrMsg,_File,_Line,_Func)	\
  do									\
  {									\
    _GLIBCXX_DEBUG_VERIFY_COND_AT(_Cond,_ErrMsg,_File,_Line,_Func);	\
  } while (false)

#define _GLIBCXX_DEBUG_VERIFY_AT(_Cond,_ErrMsg,_File,_Line)		\
  _GLIBCXX_DEBUG_VERIFY_AT_F(_Cond,_ErrMsg,_File,_Line,__PRETTY_FUNCTION__)

#define _GLIBCXX_DEBUG_VERIFY(_Cond,_ErrMsg)				\
  _GLIBCXX_DEBUG_VERIFY_AT_F(_Cond, _ErrMsg, __FILE__, __LINE__,	\
			     __PRETTY_FUNCTION__)

// Verify that [_First, _Last) forms a valid iterator range.
#define __glibcxx_check_valid_range(_First,_Last)			\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__valid_range(_First, _Last),	\
		      _M_message(__gnu_debug::__msg_valid_range)	\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))

#define __glibcxx_check_valid_range_at(_First,_Last,_File,_Line,_Func)	\
_GLIBCXX_DEBUG_VERIFY_AT_F(__gnu_debug::__valid_range(_First, _Last),	\
			   _M_message(__gnu_debug::__msg_valid_range)	\
			   ._M_iterator(_First, #_First)		\
			   ._M_iterator(_Last, #_Last),			\
			   _File,_Line,_Func)

#define __glibcxx_check_valid_range2(_First,_Last,_Dist)		\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__valid_range(_First, _Last, _Dist),	\
		      _M_message(__gnu_debug::__msg_valid_range)	\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))

#define __glibcxx_check_valid_constructor_range(_First,_Last)		\
  __gnu_debug::__check_valid_range(_First, _Last,			\
				   __FILE__, __LINE__, __PRETTY_FUNCTION__)

// Verify that [_First, _Last) forms a non-empty iterator range.
#define __glibcxx_check_non_empty_range(_First,_Last)			\
_GLIBCXX_DEBUG_VERIFY(_First != _Last,					\
		      _M_message(__gnu_debug::__msg_non_empty_range)	\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))

// Verify that [_First, _First + _Size) forms a valid range.
#define __glibcxx_check_can_increment(_First,_Size)			\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__can_advance(_First, _Size),	\
		      _M_message(__gnu_debug::__msg_iter_subscript_oob)	\
		      ._M_iterator(_First, #_First)			\
		      ._M_integer(_Size, #_Size))

#define __glibcxx_check_can_increment_range(_First1,_Last1,_First2)	\
  do									\
  {									\
    typename __gnu_debug::_Distance_traits<__decltype(_First1)>::__type __dist;\
    _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
			__gnu_debug::__valid_range(_First1, _Last1, __dist),\
			_M_message(__gnu_debug::__msg_valid_range)	\
			._M_iterator(_First1, #_First1)			\
			._M_iterator(_Last1, #_Last1),			\
			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
    _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
			__gnu_debug::__can_advance(_First2, __dist.first),\
			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
			._M_iterator(_First2, #_First2)			\
			._M_integer(__dist.first),			\
			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
  } while(false)

#define __glibcxx_check_can_decrement_range(_First1,_Last1,_First2)	\
  do									\
  {									\
    typename __gnu_debug::_Distance_traits<__decltype(_First1)>::__type __dist;\
    _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
			__gnu_debug::__valid_range(_First1, _Last1, __dist),\
			_M_message(__gnu_debug::__msg_valid_range)	\
			._M_iterator(_First1, #_First1)			\
			._M_iterator(_Last1, #_Last1),			\
			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
    _GLIBCXX_DEBUG_VERIFY_COND_AT(					\
			__gnu_debug::__can_advance(_First2, -__dist.first),\
			_M_message(__gnu_debug::__msg_iter_subscript_oob)\
			._M_iterator(_First2, #_First2)			\
			._M_integer(-__dist.first),			\
			__FILE__,__LINE__,__PRETTY_FUNCTION__);		\
  } while(false)

/** Verify that we can insert into *this with the iterator _Position.
 *  Insertion into a container at a specific position requires that
 *  the iterator be nonsingular, either dereferenceable or past-the-end,
 *  and that it reference the sequence we are inserting into. Note that
 *  this macro is only valid when the container is a_Safe_sequence and
 *  the iterator is a _Safe_iterator.
*/
#define __glibcxx_check_insert(_Position)				\
_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),				\
		      _M_message(__gnu_debug::__msg_insert_singular)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position));		\
_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),			\
		      _M_message(__gnu_debug::__msg_insert_different)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position))

/** Verify that we can insert into *this after the iterator _Position.
 *  Insertion into a container after a specific position requires that
 *  the iterator be nonsingular, either dereferenceable or before-begin,
 *  and that it reference the sequence we are inserting into. Note that
 *  this macro is only valid when the container is a_Safe_sequence and
 *  the iterator is a _Safe_iterator.
*/
#define __glibcxx_check_insert_after(_Position)				\
__glibcxx_check_insert(_Position);					\
_GLIBCXX_DEBUG_VERIFY(!_Position._M_is_end(),				\
		      _M_message(__gnu_debug::__msg_insert_after_end)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position))

/** Verify that we can insert the values in the iterator range
 *  [_First, _Last) into *this with the iterator _Position.  Insertion
 *  into a container at a specific position requires that the iterator
 *  be nonsingular (i.e., either dereferenceable or past-the-end),
 *  that it reference the sequence we are inserting into, and that the
 *  iterator range [_First, _Last) is a valid (possibly empty)
 *  range which does not reference the sequence we are inserting into.
 *  Note that this macro is only valid when the container is a
 *  _Safe_sequence and the _Position iterator is a _Safe_iterator.
*/
#define __glibcxx_check_insert_range(_Position,_First,_Last,_Dist)	\
__glibcxx_check_valid_range2(_First,_Last,_Dist);			\
__glibcxx_check_insert(_Position);					\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__foreign_iterator(_Position,_First,_Last),\
		      _M_message(__gnu_debug::__msg_insert_range_from_self)\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last)			\
		      ._M_sequence(*this, "this"))

/** Verify that we can insert the values in the iterator range
 *  [_First, _Last) into *this after the iterator _Position.  Insertion
 *  into a container after a specific position requires that the iterator
 *  be nonsingular (i.e., either dereferenceable or past-the-end),
 *  that it reference the sequence we are inserting into, and that the
 *  iterator range [_First, _Last) is a valid (possibly empty)
 *  range which does not reference the sequence we are inserting into.
 *  Note that this macro is only valid when the container is a
 *  _Safe_sequence and the _Position iterator is a _Safe_iterator.
*/
#define __glibcxx_check_insert_range_after(_Position,_First,_Last,_Dist)\
__glibcxx_check_valid_range2(_First,_Last,_Dist);			\
__glibcxx_check_insert_after(_Position);				\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__foreign_iterator(_Position,_First,_Last),\
		      _M_message(__gnu_debug::__msg_insert_range_from_self)\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last)			\
		      ._M_sequence(*this, "this"))

/** Verify that we can erase the element referenced by the iterator
 * _Position. We can erase the element if the _Position iterator is
 * dereferenceable and references this sequence.
*/
#define __glibcxx_check_erase(_Position)				\
_GLIBCXX_DEBUG_VERIFY(_Position._M_dereferenceable(),			\
		      _M_message(__gnu_debug::__msg_erase_bad)	        \
                      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position));		\
_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),			\
		      _M_message(__gnu_debug::__msg_erase_different)    \
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position))

/** Verify that we can erase the element after the iterator
 * _Position. We can erase the element if the _Position iterator is
 * before a dereferenceable one and references this sequence.
*/
#define __glibcxx_check_erase_after(_Position)				\
_GLIBCXX_DEBUG_VERIFY(_Position._M_before_dereferenceable(),		\
		      _M_message(__gnu_debug::__msg_erase_after_bad)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position));		\
_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),			\
		      _M_message(__gnu_debug::__msg_erase_different)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_Position, #_Position))

/** Verify that we can erase the elements in the iterator range
 *  [_First, _Last). We can erase the elements if [_First, _Last) is a
 *  valid iterator range within this sequence.
*/
#define __glibcxx_check_erase_range(_First,_Last)			\
__glibcxx_check_valid_range(_First,_Last);				\
_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),			\
		      _M_message(__gnu_debug::__msg_erase_different)    \
                      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))

/** Verify that we can erase the elements in the iterator range
 *  (_First, _Last). We can erase the elements if (_First, _Last) is a
 *  valid iterator range within this sequence.
*/
#define __glibcxx_check_erase_range_after(_First,_Last)			\
_GLIBCXX_DEBUG_VERIFY(_First._M_can_compare(_Last),			\
		      _M_message(__gnu_debug::__msg_erase_different)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last));			\
_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),			\
		      _M_message(__gnu_debug::__msg_erase_different)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First));			\
_GLIBCXX_DEBUG_VERIFY(_First != _Last,					\
		      _M_message(__gnu_debug::__msg_valid_range2)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last));			\
_GLIBCXX_DEBUG_VERIFY(_First._M_incrementable(),			\
		      _M_message(__gnu_debug::__msg_valid_range2)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last));			\
_GLIBCXX_DEBUG_VERIFY(!_Last._M_is_before_begin(),			\
		      _M_message(__gnu_debug::__msg_valid_range2)	\
		      ._M_sequence(*this, "this")			\
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))			\

// Verify that the subscript _N is less than the container's size.
#define __glibcxx_check_subscript(_N)					\
_GLIBCXX_DEBUG_VERIFY(_N < this->size(),				\
		      _M_message(__gnu_debug::__msg_subscript_oob)	\
                      ._M_sequence(*this, "this")			\
		      ._M_integer(_N, #_N)				\
		      ._M_integer(this->size(), "size"))

// Verify that the bucket _N is less than the container's buckets count.
#define __glibcxx_check_bucket_index(_N)				\
_GLIBCXX_DEBUG_VERIFY(_N < this->bucket_count(),			\
		      _M_message(__gnu_debug::__msg_bucket_index_oob)	\
                      ._M_sequence(*this, "this")			\
		      ._M_integer(_N, #_N)				\
		      ._M_integer(this->bucket_count(), "size"))

// Verify that the container is nonempty
#define __glibcxx_check_nonempty()					\
_GLIBCXX_DEBUG_VERIFY(! this->empty(),					\
		      _M_message(__gnu_debug::__msg_empty)	        \
                      ._M_sequence(*this, "this"))

// Verify that the iterator range [_First, _Last) is sorted
#define __glibcxx_check_sorted(_First,_Last)				\
__glibcxx_check_valid_range(_First,_Last);				\
 _GLIBCXX_DEBUG_VERIFY(__gnu_debug::__check_sorted(			\
			__gnu_debug::__base(_First),			\
			__gnu_debug::__base(_Last)),			\
		      _M_message(__gnu_debug::__msg_unsorted)	        \
                      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last))

/** Verify that the iterator range [_First, _Last) is sorted by the
    predicate _Pred. */
#define __glibcxx_check_sorted_pred(_First,_Last,_Pred)			\
__glibcxx_check_valid_range(_First,_Last);				\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__check_sorted(			\
			__gnu_debug::__base(_First),			\
			__gnu_debug::__base(_Last), _Pred),		\
		      _M_message(__gnu_debug::__msg_unsorted_pred)      \
                      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last)			\
		      ._M_string(#_Pred))

// Special variant for std::merge, std::includes, std::set_*
#define __glibcxx_check_sorted_set(_First1,_Last1,_First2)		\
__glibcxx_check_valid_range(_First1,_Last1);				\
_GLIBCXX_DEBUG_VERIFY(                                                  \
  __gnu_debug::__check_sorted_set(__gnu_debug::__base(_First1),		\
				  __gnu_debug::__base(_Last1), _First2),\
  _M_message(__gnu_debug::__msg_unsorted)				\
  ._M_iterator(_First1, #_First1)					\
  ._M_iterator(_Last1, #_Last1))

// Likewise with a _Pred.
#define __glibcxx_check_sorted_set_pred(_First1,_Last1,_First2,_Pred)	\
__glibcxx_check_valid_range(_First1,_Last1);        			\
_GLIBCXX_DEBUG_VERIFY(							\
  __gnu_debug::__check_sorted_set(__gnu_debug::__base(_First1),		\
				  __gnu_debug::__base(_Last1),		\
				  _First2, _Pred),			\
  _M_message(__gnu_debug::__msg_unsorted_pred)				\
  ._M_iterator(_First1, #_First1)					\
  ._M_iterator(_Last1, #_Last1)						\
  ._M_string(#_Pred))

/** Verify that the iterator range [_First, _Last) is partitioned
    w.r.t. the value _Value. */
#define __glibcxx_check_partitioned_lower(_First,_Last,_Value)		\
__glibcxx_check_valid_range(_First,_Last);				\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__check_partitioned_lower(		\
			__gnu_debug::__base(_First),			\
			__gnu_debug::__base(_Last), _Value),		\
		      _M_message(__gnu_debug::__msg_unpartitioned)      \
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last)			\
		      ._M_string(#_Value))

#define __glibcxx_check_partitioned_upper(_First,_Last,_Value)		\
__glibcxx_check_valid_range(_First,_Last);				\
_GLIBCXX_DEBUG_VERIFY(__gnu_debug::__check_partitioned_upper(		\
			__gnu_debug::__base(_First),			\
			__gnu_debug::__base(_Last), _Value),		\
		      _M_message(__gnu_debug::__msg_unpartitioned)      \
		      ._M_iterator(_First, #_First)			\
		      ._M_iterator(_Last, #_Last)			\
		      ._M_string(#_Value))

/** Verify that the iterator range [_First, _Last) is partitioned
    w.r.t. the value _Value and predicate _Pred. */
#define __glibcxx_check_partitioned_lower_pred(_First,_Last,_Value,_Pred) \
__glibcxx_check_valid_range(_First,_Last);				\
_GLIBCXX_DEBUG_VERIFY(__