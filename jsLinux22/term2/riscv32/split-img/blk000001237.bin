lowing are used in encode strings to describe some
   qualifiers of method and ivar types.  */
#define _C_CONST	'r'
#define _C_IN		'n'
#define _C_INOUT	'N'
#define _C_OUT      	'o'
#define _C_BYCOPY	'O'
#define _C_BYREF	'R'
#define _C_ONEWAY	'V'
#define _C_GCINVISIBLE	'|'

/* The same when used as flags.  */
#define _F_CONST	0x01
#define _F_IN		0x01
#define _F_OUT		0x02
#define _F_INOUT	0x03
#define _F_BYCOPY	0x04
#define _F_BYREF	0x08
#define _F_ONEWAY	0x10
#define _F_GCINVISIBLE	0x20


/** Implementation: the following functions are defined inline.  */

/* Return the class of 'object', or Nil if the object is nil.  If
   'object' is a class, the meta class is returned; if 'object' is a
   meta class, the root meta class is returned (note that this is
   different from the traditional GNU Objective-C Runtime API function
   object_get_class(), which for a meta class would return the meta
   class itself).  This function is inline, so it is really fast and
   should be used instead of accessing object->class_pointer
   directly.  */
static inline Class
object_getClass (id object)
{
  if (object != nil)
    return object->class_pointer;
  else
    return Nil;
}


/** Implementation: the following functions are in selector.c.  */

/* Return the name of a given selector.  If 'selector' is NULL, return
   "<null selector>".  */
objc_EXPORT const char *sel_getName (SEL selector);

/* Return the type of a given selector.  Return NULL if selector is
   NULL.

   Compatibility Note: the Apple/NeXT runtime has untyped selectors,
   so it does not have this function, which is specific to the GNU
   Runtime.  */
objc_EXPORT const char *sel_getTypeEncoding (SEL selector);

/* This is the same as sel_registerName ().  Please use
   sel_registerName () instead.  */
objc_EXPORT SEL sel_getUid (const char *name);

/* Register a selector with a given name (but unspecified types).  If
   you know the types, it is better to call sel_registerTypedName().
   If a selector with this name and no types already exists, it is
   returned.  Note that this function should really be called
   'objc_registerSelector'.  Return NULL if 'name' is NULL.  */
objc_EXPORT SEL sel_registerName (const char *name);

/* Register a selector with a given name and types.  If a selector
   with this name and types already exists, it is returned.  Note that
   this function should really be called 'objc_registerTypedSelector',
   and it's called 'sel_registerTypedName' only for consistency with
   'sel_registerName'.  Return NULL if 'name' is NULL.

   Compatibility Note: the Apple/NeXT runtime has untyped selectors,
   so it does not have this function, which is specific to the GNU
   Runtime.  */
objc_EXPORT SEL sel_registerTypedName (const char *name, const char *type);

/* Return YES if first_selector is the same as second_selector, and NO
   if not.  */
objc_EXPORT BOOL sel_isEqual (SEL first_selector, SEL second_selector);

/* Return all the selectors with the supplied name.  In the GNU
   runtime, selectors are typed and there may be multiple selectors
   with the same name but a different type.  The return value of the
   function is a pointer to an area, allocated with malloc(), that
   contains all the selectors with the supplier name known to the
   runtime.  The list is terminated by NULL.  Optionally, if you pass
   a non-NULL 'numberOfReturnedSelectors' pointer, the unsigned int
   that it points to will be filled with the number of selectors
   returned.

   Compatibility Note: the Apple/NeXT runtime has untyped selectors,
   so it does not have this function, which is specific to the GNU
   Runtime.  */
objc_EXPORT SEL * sel_copyTypedSelectorList (const char *name,
					     unsigned int *numberOfReturnedSelectors);

/* Return a selector with name 'name' and a non-zero type encoding, if
   there is a single selector with a type, and with that name,
   registered with the runtime.  If there is no such selector, or if
   there are multiple selectors with the same name but conflicting
   types, NULL is returned.  Return NULL if 'name' is NULL.

   This is useful if you have the name of the selector, and would
   really like to get a selector for it that includes the type
   encoding.  Unfortunately, if the program contains multiple selector
   with the same name but different types, sel_getTypedSelector cannot
   possibly know which one you need, and so will return NULL.

   Compatibility Note: the Apple/NeXT runtime has untyped selectors,
   so it does not have this function, which is specific to the GNU
   Runtime.  */
objc_EXPORT SEL sel_getTypedSelector (const char *name);


/** Implementation: the following functions are in objects.c.  */

/* Create an instance of class 'class_', adding extraBytes to the size
   of the returned object.  This method allocates the appropriate
   amount of memory for the instance, initializes it to zero, then
   calls all the C++ constructors on appropriate C++ instance
   variables of the instance (if any) (TODO: The C++ constructors bit
   is not implemented yet).  */
objc_EXPORT id class_createInstance (Class class_, size_t extraBytes);

/* Copy an object and return the copy.  extraBytes should be identical
   to the extraBytes parameter that was passed when creating the
   original object.  */
objc_EXPORT id object_copy (id object, size_t extraBytes);

/* Dispose of an object.  This method calls the appropriate C++
   destructors on appropriate C++ instance variables of the instance
   (if any) (TODO: This is not implemented yet), then frees the memory
   for the instance.  */
objc_EXPORT id object_dispose (id object);

/* Return the name of the class of 'object'.  If 'object' is 'nil',
   returns "Nil".  */
objc_EXPORT const char * object_getClassName (id object);

/* Change the class of object to be class_.  Return the previous class
   of object.  This is currently not really thread-safe.  */
objc_EXPORT Class object_setClass (id object, Class class_);


/** Implementation: the following functions are in ivars.c.  */

/* Return an instance variable given the class and the instance
   variable name.  This is an expensive function to call, so try to
   reuse the returned Ivar if you can.  */
objc_EXPORT Ivar class_getInstanceVariable (Class class_, const char *name);

/* Return a class variable given the class and the class variable
   name.  This is an expensive function to call, so try to reuse the
   returned Ivar if you can.  
   
   This function always returns NULL since class variables are
   currently unavailable in Objective-C.  */
objc_EXPORT Ivar class_getClassVariable (Class class_, const char *name);

/* If the object was created in class_createInstance() with some
   extraBytes, returns a pointer to them.  If it was not, then the
   returned pointer may make no sense.  */
objc_EXPORT void * object_getIndexedIvars (id object);

/* Get the value of an instance variable of type 'id'.  The function
   returns the instance variable.  To get the value of the instance
   variable, you should pass as 'returnValue' a pointer to an 'id';
   the value will be copied there.  Note that 'returnValue' is really
   a 'void *', not a 'void **'.  This function really works only with
   instance variables of type 'id'; for other types of instance
   variables, access directly the data at (char *)object +
   ivar_getOffset (ivar).  */
objc_EXPORT Ivar object_getInstanceVariable (id object, const char *name, void **returnValue);

/* Set the value of an instance variable.  The value to set is passed
   in 'newValue' (which really is an 'id', not a 'void *').  The
   function returns the instance variable.  This function really works
   only with instance variables of type 'id'; for other types of
   instance variables, access directly the data at (char *)object +
   ivar_getOffset (ivar).  */
objc_EXPORT Ivar object_setInstanceVariable (id object, const char *name, void *newValue);

/* Get the value of an instance variable of type 'id' of the object
   'object'.  This is faster than object_getInstanceVariable if you
   already have the instance variable because it avoids the expensive
   call to class_getInstanceVariable that is done by
   object_getInstanceVariable.  */
objc_EXPORT id object_getIvar (id object, Ivar variable);

/* Set the value of an instance variable of type 'id' of the object
   'object'.  This is faster than object_setInstanceVariable if you
   already have the instance variable because it avoids the expensive
   call to class_getInstanceVariable that is done by
   object_setInstanceVariable.  */
objc_EXPORT void object_setIvar (id object, Ivar variable, id value);

/* Return the name of the instance variable.  Return NULL if
   'variable' is NULL.  */
objc_EXPORT const char * ivar_getName (Ivar variable);

/* Return the offset of the instance variable from the start of the
   object data.  Return 0 if 'variable' is NULL.  */
objc_EXPORT ptrdiff_t ivar_getOffset (Ivar variable);

/* Return the type encoding of the variable.  Return NULL if
   'variable' is NULL.  */
objc_EXPORT const char * ivar_getTypeEncoding (Ivar variable);

/* Return all the instance variables of the class.  The return value
   of the function is a pointer to an area, allocated with malloc(),
   that contains all the instance variables of the class.  It does not
   include instance variables of superclasses.  The list is terminated
   by NULL.  Optionally, if you pass a non-NULL
   'numberOfReturnedIvars' pointer, the unsigned int that it points to
   will be filled with the number of instance variables returned.
   Return NULL for classes still in construction (ie, allocated using
   objc_allocatedClassPair() but not yet registered with the runtime
   using objc_registerClassPair()).  */
objc_EXPORT Ivar * class_copyIvarList (Class class_, unsigned int *numberOfReturnedIvars);

/* Add an instance variable with name 'ivar_name' to class 'class_',
   where 'class_' is a class in construction that has been created
   using objc_allocateClassPair() and has not been registered with the
   runtime using objc_registerClassPair() yet.  You cannot add
   instance variables to classes already registered with the runtime.
   'size' is the size of the instance variable, 'log_2_of_alignment'
   the alignment as a power of 2 (so 0 means alignment to a 1 byte
   boundary, 1 means alignment to a 2 byte boundary, 2 means alignment
   to a 4 byte boundary, etc), and 'type' the type encoding of the
   variable type.  You can use sizeof(), log2(__alignof__()) and
   @encode() to determine the right 'size', 'alignment' and 'type' for
   your instance variable.  For example, to add an instance variable
   name "my_variable" and of type 'id', you can use:

   class_addIvar (class, "my_variable", sizeof (id), log2 ( __alignof__ (id)),
                  @encode (id));

   Return YES if the variable was added, and NO if not.  In
   particular, return NO if 'class_' is Nil, or a meta-class or a
   class not in construction.  Return Nil also if 'ivar_name' or
   'type' is NULL, or 'size' is 0.
 */
objc_EXPORT BOOL class_addIvar (Class class_, const char * ivar_name, size_t size,
				unsigned char log_2_of_alignment, const char *type);

/* Return the name of the property.  Return NULL if 'property' is
   NULL.  */
objc_EXPORT const char * property_getName (Property property);

/* Return the attributes of the property as a string.  Return NULL if
   'property' is NULL.  */
objc_EXPORT const char * property_getAttributes (Property property);

/* Return the property with name 'propertyName' of the class 'class_'.
   This function returns NULL if the required property cannot be
   found.  Return NULL if 'class_' or 'propertyName' is NULL.

   Note that the traditional ABI does not store the list of properties
   of a class in a compiled module, so the traditional ABI will always
   return NULL.  */
objc_EXPORT Property class_getProperty (Class class_, const char *propertyName);

/* Return all the properties of the class.  The return value
   of the function is a pointer to an area, allocated with malloc(),
   that contains all the properties of the class.  It does not
   include properties of superclasses.  The list is terminated
   by NULL.  Optionally, if you pass a non-NULL
   'numberOfReturnedIvars' pointer, the unsigned int that it points to
   will be filled with the number of properties returned.

   Note that the traditional ABI does not store the list of properties
   of a class in a compiled module, so the traditional ABI will always
   return an empty list.  */
objc_EXPORT Property * class_copyPropertyList 
(Class class_, unsigned int *numberOfReturnedProperties);

/* Return the ivar layout for class 'class_'.

   At the moment this function always returns NULL.  */
objc_EXPORT const char * class_getIvarLayout (Class class_);

/* Return the weak ivar layout for class 'class_'.

   At the moment this function always returns NULL.  */
objc_EXPORT const char * class_getWeakIvarLayout (Class class_);

/* Set the ivar layout for class 'class_'.

   At the moment, this function does nothing.  */
objc_EXPORT void class_setIvarLayout (Class class_, const char *layout);

/* Set the weak ivar layout for class 'class_'.

   At the moment, this function does nothing.  With the GNU runtime,
   you should use class_ivar_set_gcinvisible () to hide variables from
   the Garbage Collector.  */
objc_EXPORT void class_setWeakIvarLayout (Class class_, const char *layout);


/** Implementation: the following functions are in class.c.  */

/* Compatibility Note: The Apple/NeXT runtime does not have
   objc_get_unknown_class_handler and
   objc_setGetUnknownClassHandler().  They provide functionality that
   the traditional GNU Objective-C Runtime API used to provide via the
   _objc_lookup_class hook.  */

/* An 'objc_get_unknown_class_handler' function is used by
   objc_getClass() to get a class that is currently unknown to the
   compiler.  You could use it for example to have the class loaded by
   dynamically loading a library.  'class_name' is the name of the
   class.  The function should return the Class object if it manages to
   load the class, and Nil if not.  */
typedef Class (*objc_get_unknown_class_handler)(const char *class_name);

/* Sets a new handler function for getting unknown classes (to be used
   by objc_getClass () and related), and returns the previous one.
   This function is not safe to call in a multi-threaded environment
   because other threads may be trying to use the get unknown class
   handler while you change it!  */
objc_EXPORT 
objc_get_unknown_class_handler
objc_setGetUnknownClassHandler (objc_get_unknown_class_handler new_handler);

/* Return the class with name 'name', if it is already registered with
   the runtime.  If it is not registered, and
   objc_setGetUnknownClassHandler() has been called to set a handler
   for unknown classes, the handler is called to give it a chance to
   load the class in some other way.  If the class is not known to the
   runtime and the handler is not set or returns Nil, objc_getClass()
   returns Nil.  */
objc_EXPORT Class objc_getClass (const char *name);

/* Return the class with name 'name', if it is already registered with
   the runtime.  Return Nil if not.  This function does not call the
   objc_get_unknown_class_handler function if the class is not
   found.  */
objc_EXPORT Class objc_lookUpClass (const char *name);

/* Return the meta class associated to the class with name 'name', if
   it is already registered with the runtime.  First, it finds the
   class using objc_getClass().  Then, it returns the associated meta
   class.  If the class could not be found using objc_getClass(),
   returns Nil.  */
objc_EXPORT Class objc_getMetaClass (const char *name);

/* This is identical to objc_getClass(), but if the class is not found,
   it aborts the process instead of returning Nil.  */
objc_EXPORT Class objc_getRequiredClass (const char *name);

/* If 'returnValue' is NULL, 'objc_getClassList' returns the number of
   classes currently registered with the runtime.  If 'returnValue' is
   not NULL, it should be a (Class *) pointer to an area of memory
   which can contain up to 'maxNumberOfClassesToReturn' Class records.
   'objc_getClassList' will fill the area pointed to by 'returnValue'
   with all the Classes registered with the runtime (or up to
   maxNumberOfClassesToReturn if there are more than
   maxNumberOfClassesToReturn).  The function return value is the
   number of classes actually returned in 'returnValue'.  */
objc_EXPORT int objc_getClassList (Class *returnValue, int maxNumberOfClassesToReturn); 

/* Compatibility Note: The Apple/NeXT runtime also has

    Class objc_getFutureClass (const char *name);
    void objc_setFutureClass (Class class_, const char *name);

   the documentation is unclear on what they are supposed to do, and
   the GNU Objective-C Runtime currently does not provide them.  */

/* Return the name of the class 'class_', or the string "nil" if the
   class_ is Nil.  */
objc_EXPORT const char * class_getName (Class class_);

/* Return YES if 'class_' is a meta class, and NO if not.  If 'class_'
   is Nil, return NO.  */
objc_EXPORT BOOL class_isMetaClass (Class class_);

/* Return the superclass of 'class_'.  If 'class_' is Nil, or it is a
   root class, return Nil.  This function also works if 'class_' is a
   class being constructed, that is, a class returned by
   objc_allocateClassPair() but before it has been registered with the
   runtime using objc_registerClassPair().  */
objc_EXPORT Class class_getSuperclass (Class class_);

/* Return the 'version' number of the class, which is an integer that
   can be used to track changes in the class API, methods and
   variables.  If class_ is Nil, return 0.  If class_ is not Nil, the
   version is 0 unless class_setVersion() has been called to set a
   different one.

   Please note that internally the version is a long, but the API only
   allows you to set and retrieve int values.  */
objc_EXPORT int class_getVersion (Class class_);

/* Set the 'version' number of the class, which is an integer that can
   be used to track changes in the class API, methods and variables.
   If 'class_' is Nil, does nothing.

   This is typically used internally by "Foundation" libraries such as
   GNUstep Base to support serialization / deserialization of objects
   that work across changes in the classes.  If you are using such a
   library, you probably want to use their versioning API, which may
   be based on this one, but is integrated with the rest of the
   library.

   Please note that internally the version is a long, but the API only
   allows you to set and retrieve int values.  */
objc_EXPORT void class_setVersion (Class class_, int version);

/* Return the size in bytes (a byte is the size of a char) of an
   instance of the class.  If class_ is Nil, return 0; else it return
   a non-zero number (since the 'isa' instance variable is required
   for all classes).  */
objc_EXPORT size_t class_getInstanceSize (Class class_);

/* Change the implementation of the method.  It also searches all
   classes for any class implementing the method, and replaces the
   existing implementation with the new one.  For that to work,
   'method' must be a method returned by class_getInstanceMethod() or
   class_getClassMethod() as the matching is done by comparing the
   pointers; in that case, only the implementation in the class is
   modified.  Return the previous implementation that has been
   replaced.  If method or implementation is NULL, do nothing and
   return NULL.  */
objc_EXPORT IMP
method_setImplementation (Method method, IMP implementation);

/* Swap the implementation of two methods in a single, atomic
   operation.  This is equivalent to getting the implementation of
   each method and then calling method_setImplementation() on the
   other one.  For this to work, the two methods must have been
   returned by class_getInstanceMethod() or class_getClassMethod().
   If 'method_a' or 'method_b' is NULL, do nothing.  */
objc_EXPORT void
method_exchangeImplementations (Method method_a, Method method_b);

/* Create a new class/meta-class pair.  This function is called to
   create a new class at runtime.  The class is created with
   superclass 'superclass' (use 'Nil' to create a new root class) and
   name 'class_name'.  'extraBytes' can be used to specify some extra
   space for indexed variables to be added at the end of the class and
   meta-class objects (it is recommended that you set extraBytes to
   0).  Once you have created the class, it is not usable yet.  You
   need to add any instance variables (by using class_addIvar()), any
   instance methods (by using class_addMethod()) and any class methods
   (by using class_addMethod() on the meta-class, as in
   class_addMethod (object_getClass (class), method)) that are
   required, and then you need to call objc_registerClassPair() to
   activate the class.  If you need to create a hierarchy of classes,
   you need to create and register them one at a time.  You cannot
   create a new class using another class in construction as
   superclass.  Return Nil if 'class-name' is NULL or if a class with
   that name already exists or 'superclass' is a class still in
   construction.

   Implementation Note: in the GNU runtime, allocating a class pair
   only creates the structures for the class pair, but does not
   register anything with the runtime.  The class is registered with
   the runtime only when objc_registerClassPair() is called.  In
   particular, if a class is in construction, objc_getClass() will not
   find it, the superclass will not know about it,
   class_getSuperclass() will return Nil and another thread may
   allocate a class pair with the same name; the conflict will only be
   detected when the classes are registered with the runtime.
 */
objc_EXPORT Class
objc_allocateClassPair (Class super_class, const char *class_name, 
			size_t extraBytes);

/* Register a class pair that was created with
   objc_allocateClassPair().  After you register a class, you can no
   longer make changes to its instance variables, but you can start
   creating instances of it.  Do nothing if 'class_' is NULL or if it
   is not a class allocated by objc_allocateClassPair() and still in
   construction.  */
objc_EXPORT void
objc_registerClassPair (Class class_);

/* Dispose of a class pair created using objc_allocateClassPair().
   Call this function if you started creating a new class with
   objc_allocateClassPair() but then want to abort the process.  You
   should not access 'class_' after calling this method.  Note that if
   'class_' has already been registered with the runtime via
   objc_registerClassPair(), this function does nothing; you can only
   dispose of class pairs that are still being constructed.  Do
   nothing if class is 'Nil' or if 'class_' is not a class being
   constructed.  */
objc_EXPORT void
objc_disposeClassPair (Class class_);

/* Compatibility Note: The Apple/NeXT runtime has the function
   objc_duplicateClass () but it's undocumented.  The GNU runtime does
   not have it.  */


/** Implementation: the following functions are in sendmsg.c.  */

/* Return the instance method with selector 'selector' of class
   'class_', or NULL if the class (or one of its superclasses) does
   not implement the method.  Return NULL if class_ is Nil or selector
   is NULL.  Calling this function may trigger a call to
   +resolveInstanceMethod:, but does not return a forwarding
   function.  */
objc_EXPORT Method class_getInstanceMethod (Class class_, SEL selector);

/* Return the class method with selector 'selector' of class 'class_',
   or NULL if the class (or one of its superclasses) does not
   implement the method.  Return NULL if class_ is Nil or selector is
   NULL.  Calling this function may trigger a call to
   +resolveClassMethod:, but does not return a forwarding
   function.  */
objc_EXPORT Method class_getClassMethod (Class class_, SEL selector);

/* Return the IMP (pointer to the function implementing a method) for
   the instance method with selector 'selector' in class 'class_'.
   This is the same routine that is used while messaging, and should
   be very fast.  Note that you most likely would need to cast the
   return function pointer to a function pointer with the appropriate
   arguments and return type before calling it.  To get a class
   method, you can pass the meta-class as the class_ argument (ie, use
   class_getMethodImplementation (object_getClass (class_),
   selector)).  Return NULL if class_ is Nil or selector is NULL.
   This function first looks for an existing method; if it is not
   found, it calls +resolveClassMethod: or +resolveInstanceMethod:
   (depending on whether a class or instance method is being looked
   up) if it is implemented.  If the method returns YES, then it tries
   the look up again (the assumption being that +resolveClassMethod:
   or resolveInstanceMethod: will add the method using
   class_addMethod()).  If it is still not found, it returns a
   forwarding function.  */
objc_EXPORT IMP class_getMethodImplementation (Class class_, SEL selector);

/* Compatibility Note: the Apple/NeXT runtime has the function
   class_getMethodImplementation_stret () which currently does not
   exist on the GNU runtime because the messaging implementation is
   different.  */

/* Return YES if class 'class_' has an instance method implementing
   selector 'selector', and NO if not.  Return NO if class_ is Nil or
   selector is NULL.  If you need to check a class method, use the
   meta-class as the class_ argument (ie, use class_respondsToSelector
   (object_getClass (class_), selector)).  */
objc_EXPORT BOOL class_respondsToSelector (Class class_, SEL selector);

/* Add a method to a class.  Use this function to add a new method to
   a class (potentially overriding a method with the same selector in
   the superclass); if you want to modify an existing method, use
   method_setImplementation() instead (or class_replaceMethod ()).
   This method adds an instance method to 'class_'; to add a class
   method, get the meta class first, then add the method to the meta
   class, that is, use

   class_addMethod (object_getClass (class_), selector,
   implementation, type);

   Return YES if the method was added, and NO if not.  Do nothing if
   one of the arguments is NULL.  */
objc_EXPORT BOOL class_addMethod (Class class_, SEL selector, IMP implementation,
				  const char *method_types);

/* Replace a method in a class.  If the class already have a method
   with this 'selector', find it and use method_setImplementation() to
   replace the implementation with 'implementation' (method_types is
   ignored in that case).  If the class does not already have a method
   with this 'selector', call 'class_addMethod() to add it.

   Return the previous implementation of the method, or NULL if none
   was found.  Return NULL if any of the arguments is NULL.  */
objc_EXPORT IMP class_replaceMethod (Class class_, SEL selector, IMP implementation,
				     const char *method_types);


/** Implementation: the following functions are in methods.c.  */

/* Return the selector for method 'method'.  Return NULL if 'method'
   is NULL.

   This function is misnamed; it should be called
   'method_getSelector'.  To get the actual name, get the selector,
   then the name from the selector (ie, use sel_getName
   (method_getName (method))).  */
objc_EXPORT SEL method_getName (Method method);

/* Return the IMP of the method.  Return NULL if 'method' is NULL.  */
objc_EXPORT IMP method_getImplementation (Method method);

/* Return the type encoding of the method.  Return NULL if 'method' is
   NULL.  */
objc_EXPORT const char * method_getTypeEncoding (Method method);

/* Return a method description for the method.  Return NULL if
   'method' is NULL.  */
objc_EXPORT struct objc_method_description * method_getDescription (Method method);

/* Return all the instance methods of the class.  The return value of
   the function is a pointer to an area, allocated with malloc(), that
   contains all the instance methods of the class.  It does not
   include instance methods of superclasses.  The list is terminated
   by NULL.  Optionally, if you pass a non-NULL
   'numberOfReturnedMethods' pointer, the unsigned int that it points
   to will be filled with the number of instance methods returned.  To
   get the list of class methods, pass the meta-class in the 'class_'
   argument, (ie, use class_copyMethodList (object_getClass (class_),
   &numberOfReturnedMethods)).  */
objc_EXPORT Method * class_copyMethodList (Class class_, unsigned int *numberOfReturnedMethods);


/** Implementation: the following functions are in encoding.c.  */

/* Return the number of arguments that the method 'method' expects.
   Note that all methods need two implicit arguments ('self' for the
   receiver, and '_cmd' for the selector).  Return 0 if 'method' is
   NULL.  */
objc_EXPORT unsigned int method_getNumberOfArguments (Method method);

/* Return the string encoding for the return type of method 'method'.
   The string is a standard zero-terminated string in an area of
   memory allocated with malloc(); you should free it with free() when
   you finish using it.  Return an empty string if method is NULL.  */
objc_EXPORT char * method_copyReturnType (Method method);

/* Return the string encoding for the argument type of method
   'method', argument number 'argumentNumber' ('argumentNumber' is 0
   for self, 1 for _cmd, and 2 or more for the additional arguments if
   any).  The string is a standard zero-terminated string in an area
   of memory allocated with malloc(); you should free it with free()
   when you finish using it.  Return an empty string if method is NULL
   or if 'argumentNumber' refers to a non-existing argument.  */
objc_EXPORT char * method_copyArgumentType (Method method, unsigned int argumentNumber);

/* Return the string encoding for the return type of method 'method'.
   The string is returned by copying it into the supplied
   'returnValue' string, which is of size 'returnValueSize'.  No more
   than 'returnValueSize' characters are copied; if the encoding is
   smaller than 'returnValueSize', the rest of 'returnValue' is filled
   with zeros.  If it is bigger, it is truncated (and would not be
   zero-terminated).  You should supply a big enough
   'returnValueSize'.  If the method is NULL, returnValue is set to a
   string of zeros.  */
objc_EXPORT void method_getReturnType (Method method, char *returnValue, 
				       size_t returnValueSize);

/* Return the string encoding for the argument type of method
   'method', argument number 'argumentNumber' ('argumentNumber' is 0
   for self, 1 for _cmd, and 2 or more for the additional arguments if
   any).  The string is returned by copying it into the supplied
   'returnValue' string, which is of size 'returnValueSize'.  No more
   than 'returnValueSize' characters are copied; if the encoding is
   smaller than 'returnValueSize', the rest of 'returnValue' is filled
   with zeros.  If it is bigger, it is truncated (and would not be
   zero-terminated).  You should supply a big enough
   'returnValueSize'.  If the method is NULL, returnValue is set to a
   string of zeros.  */
objc_EXPORT void method_getArgumentType (Method method, unsigned int argumentNumber,
					 char *returnValue, size_t returnValueSize);


/** Implementation: the following functions are in protocols.c.  */

/* Return the protocol with name 'name', or nil if it the protocol is
   not known to the runtime.  */
objc_EXPORT Protocol *objc_getProtocol (const char *name);

/* Return all the protocols known to the runtime.  The return value of
   the function is a pointer to an area, allocated with malloc(), that
   contains all the protocols known to the runtime; the list is
   terminated by NULL.  You should free this area using free() once
   you no longer need it.  Optionally, if you pass a non-NULL
   'numberOfReturnedProtocols' pointer, the unsigned int that it
   points to will be filled with the number of protocols returned.  If
   there are no protocols known to the runtime, NULL is returned.  */
objc_EXPORT Protocol **objc_copyProtocolList (unsigned int *numberOfReturnedProtocols);

/* Add a protocol to a class, and return YES if it was done
   successfully, and NO if not.  At the moment, NO should only happen
   if class_ or protocol are nil, if the protocol is not a Protocol
   object or if the class already conforms to the protocol.  */
objc_EXPORT BOOL class_addProtocol (Class class_, Protocol *protocol);

/* Return YES 