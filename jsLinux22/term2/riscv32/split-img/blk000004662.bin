   }

  /**
   *  @brief  Combine elements from two ranges and reduce
   *
   *  @param  __first1  Start of first range.
   *  @param  __last1  End of first range.
   *  @param  __first2  Start of second range.
   *  @param  __init  Starting value to add other values to.
   *  @return  The final sum.
   *
   *  Call `first1[n]*first2[n]` for each `n` in `[0,last1-first1)` and then
   *  use addition to sum those products to a single value of type `T`.
   *
   *  The range beginning at `first2` must contain at least `last1-first1`
   *  elements.
   */
  template<typename _InputIterator1, typename _InputIterator2, typename _Tp>
    inline _Tp
    transform_reduce(_InputIterator1 __first1, _InputIterator1 __last1,
		     _InputIterator2 __first2, _Tp __init)
    {
      return std::transform_reduce(__first1, __last1, __first2,
				   std::move(__init),
				   plus<>(), multiplies<>());
    }

  /**
   *  @brief  Transform the elements of a range and reduce
   *
   *  @param  __first  Start of range.
   *  @param  __last  End of range.
   *  @param  __init  Starting value to add other values to.
   *  @param  __binary_op The function used to perform reduction.
   *  @param  __unary_op The function used to transform values from the range.
   *  @return  The final sum.
   *
   *  Call `unary_op(first[n])` for each `n` in `[0,last-first)` and then
   *  use `binary_op` to reduce the values returned by `unary_op`
   *  to a single value of type `T`.
   */
  template<typename _InputIterator, typename _Tp,
	   typename _BinaryOperation, typename _UnaryOperation>
    _Tp
    transform_reduce(_InputIterator __first, _InputIterator __last, _Tp __init,
		     _BinaryOperation __binary_op, _UnaryOperation __unary_op)
    {
      if constexpr (__is_random_access_iter<_InputIterator>::value)
	{
	  while ((__last - __first) >= 4)
	    {
	      _Tp __v1 = __binary_op(__unary_op(__first[0]),
				     __unary_op(__first[1]));
	      _Tp __v2 = __binary_op(__unary_op(__first[2]),
				     __unary_op(__first[3]));
	      _Tp __v3 = __binary_op(__v1, __v2);
	      __init = __binary_op(__init, __v3);
	      __first += 4;
	    }
	}
      for (; __first != __last; ++__first)
	__init = __binary_op(__init, __unary_op(*__first));
      return __init;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __init   Initial value.
   *  @param __binary_op Function to perform summation.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements (and the initial value),
   *  using `binary_op` for summation.
   *
   *  This function generates an "exclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N-1 input elements,
   *  so the Nth input element is not included.
   */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp,
	   typename _BinaryOperation>
    _OutputIterator
    exclusive_scan(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _Tp __init,
		   _BinaryOperation __binary_op)
    {
      while (__first != __last)
	{
	  auto __v = __init;
	  __init = __binary_op(__init, *__first);
	  ++__first;
	  *__result++ = std::move(__v);
	}
      return __result;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __init   Initial value.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements (and the initial value),
   *  using `std::plus<>` for summation.
   *
   *  This function generates an "exclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N-1 input elements,
   *  so the Nth input element is not included.
   */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    exclusive_scan(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _Tp __init)
    {
      return std::exclusive_scan(__first, __last, __result, std::move(__init),
				 plus<>());
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __binary_op Function to perform summation.
   *  @param __init   Initial value.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements (and the initial value),
   *  using `binary_op` for summation.
   *
   *  This function generates an "inclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N input elements,
   *  so the Nth input element is included.
   */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryOperation, typename _Tp>
    _OutputIterator
    inclusive_scan(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _BinaryOperation __binary_op,
		   _Tp __init)
    {
      for (; __first != __last; ++__first)
	*__result++ = __init = __binary_op(__init, *__first);
      return __result;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __binary_op Function to perform summation.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements, using `binary_op` for summation.
   *
   *  This function generates an "inclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N input elements,
   *  so the Nth input element is included.
   */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryOperation>
    _OutputIterator
    inclusive_scan(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result, _BinaryOperation __binary_op)
    {
      if (__first != __last)
	{
	  auto __init = *__first;
	  *__result++ = __init;
	  ++__first;
	  if (__first != __last)
	    __result = std::inclusive_scan(__first, __last, __result,
					   __binary_op, std::move(__init));
	}
      return __result;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements, using `std::plus<>` for summation.
   *
   *  This function generates an "inclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N input elements,
   *  so the Nth input element is included.
   */
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    inclusive_scan(_InputIterator __first, _InputIterator __last,
		   _OutputIterator __result)
    { return std::inclusive_scan(__first, __last, __result, plus<>()); }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __init   Initial value.
   *  @param __binary_op Function to perform summation.
   *  @param __unary_op Function to transform elements of the input range.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements (and the initial value),
   *  using `__unary_op` to transform the input elements
   *  and using `__binary_op` for summation.
   *
   *  This function generates an "exclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N-1 input elements,
   *  so the Nth input element is not included.
   */
  template<typename _InputIterator, typename _OutputIterator, typename _Tp,
	   typename _BinaryOperation, typename _UnaryOperation>
    _OutputIterator
    transform_exclusive_scan(_InputIterator __first, _InputIterator __last,
			     _OutputIterator __result, _Tp __init,
			     _BinaryOperation __binary_op,
			     _UnaryOperation __unary_op)
    {
      while (__first != __last)
	{
	  auto __v = __init;
	  __init = __binary_op(__init, __unary_op(*__first));
	  ++__first;
	  *__result++ = std::move(__v);
	}
      return __result;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __binary_op Function to perform summation.
   *  @param __unary_op Function to transform elements of the input range.
   *  @param __init   Initial value.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements (and the initial value),
   *  using `__unary_op` to transform the input elements
   *  and using `__binary_op` for summation.
   *
   *  This function generates an "inclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N input elements,
   *  so the Nth input element is included.
   */
  template<typename _InputIterator, typename _OutputIterator,
	   typename _BinaryOperation, typename _UnaryOperation, typename _Tp>
    _OutputIterator
    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
			     _OutputIterator __result,
			     _BinaryOperation __binary_op,
			     _UnaryOperation __unary_op,
			     _Tp __init)
    {
      for (; __first != __last; ++__first)
	*__result++ = __init = __binary_op(__init, __unary_op(*__first));
      return __result;
    }

  /** @brief Output the cumulative sum of one range to a second range
   *
   *  @param __first  Start of input range.
   *  @param __last   End of input range.
   *  @param __result Start of output range.
   *  @param __binary_op Function to perform summation.
   *  @param __unary_op Function to transform elements of the input range.
   *  @return The end of the output range.
   *
   *  Write the cumulative sum (aka prefix sum, aka scan) of the input range
   *  to the output range. Each element of the output range contains the
   *  running total of all earlier elements,
   *  using `__unary_op` to transform the input elements
   *  and using `__binary_op` for summation.
   *
   *  This function generates an "inclusive" scan, meaning the Nth element
   *  of the output range is the sum of the first N input elements,
   *  so the Nth input element is included.
   */
  template<typename _InputIterator, typename _OutputIterator,
	  typename _BinaryOperation, typename _UnaryOperation>
    _OutputIterator
    transform_inclusive_scan(_InputIterator __first, _InputIterator __last,
			     _OutputIterator __result,
			     _BinaryOperation __binary_op,
			     _UnaryOperation __unary_op)
    {
      if (__first != __last)
	{
	  auto __init = __unary_op(*__first);
	  *__result++ = __init;
	  ++__first;
	  if (__first != __last)
	    __result = std::transform_inclusive_scan(__first, __last, __result,
						     __binary_op, __unary_op,
						     std::move(__init));
	}
      return __result;
    }

  /// @} group numeric_ops

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

// Parallel STL algorithms
# if __PSTL_EXECUTION_POLICIES_DEFINED
// If <execution> has already been included, pull in implementations
#  include <pstl/glue_numeric_impl.h>
# else
// Otherwise just pull in forward declarations
#  include <pstl/glue_numeric_defs.h>
#  define __PSTL_NUMERIC_FORWARD_DECLARED 1
# endif

// Feature test macro for parallel algorithms
# define __cpp_lib_parallel_algorithm 201603L
#endif // C++17

#endif /* _GLIBCXX_NUMERIC */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // <optional> -*- C++ -*-

// Copyright (C) 2013-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file include/optional
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_OPTIONAL
#define _GLIBCXX_OPTIONAL 1

#pragma GCC system_header

#if __cplusplus >= 201703L

#include <utility>
#include <type_traits>
#include <stdexcept>
#include <new>
#include <initializer_list>
#include <bits/functexcept.h>
#include <bits/functional_hash.h>
#include <bits/enable_special_members.h>

namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   *  @addtogroup utilities
   *  @{
   */

#define __cpp_lib_optional 201606L

  template<typename _Tp>
    class optional;

  /// Tag type to disengage optional objects.
  struct nullopt_t
  {
    // Do not user-declare default constructor at all for
    // optional_value = {} syntax to work.
    // nullopt_t() = delete;

    // Used for constructing nullopt.
    enum class _Construct { _Token };

    // Must be constexpr for nullopt_t to be literal.
    explicit constexpr nullopt_t(_Construct) { }
  };

  /// Tag to disengage optional objects.
  inline constexpr nullopt_t nullopt { nullopt_t::_Construct::_Token };

  /**
   *  @brief Exception class thrown when a disengaged optional object is
   *  dereferenced.
   *  @ingroup exceptions
   */
  class bad_optional_access : public exception
  {
  public:
    bad_optional_access() { }

    virtual const char* what() const noexcept override
    { return "bad optional access"; }

    virtual ~bad_optional_access() noexcept = default;
  };

  void
  __throw_bad_optional_access()
  __attribute__((__noreturn__));

  // XXX Does not belong here.
  inline void
  __throw_bad_optional_access()
  { _GLIBCXX_THROW_OR_ABORT(bad_optional_access()); }

  // This class template manages construction/destruction of
  // the contained value for a std::optional.
  template <typename _Tp>
    struct _Optional_payload_base
    {
      using _Stored_type = remove_const_t<_Tp>;

      _Optional_payload_base() = default;
      ~_Optional_payload_base() = default;

      template<typename... _Args>
	constexpr
	_Optional_payload_base(in_place_t __tag, _Args&&... __args)
	: _M_payload(__tag, std::forward<_Args>(__args)...),
	  _M_engaged(true)
	{ }

      template<typename _Up, typename... _Args>
	constexpr
	_Optional_payload_base(std::initializer_list<_Up> __il,
			       _Args&&... __args)
	: _M_payload(__il, std::forward<_Args>(__args)...),
	  _M_engaged(true)
	{ }

      // Constructor used by _Optional_base copy constructor when the
      // contained value is not trivially copy constructible.
      constexpr
      _Optional_payload_base(bool __engaged,
			     const _Optional_payload_base& __other)
      {
	if (__other._M_engaged)
	  this->_M_construct(__other._M_get());
      }

      // Constructor used by _Optional_base move constructor when the
      // contained value is not trivially move constructible.
      constexpr
      _Optional_payload_base(bool __engaged,
			     _Optional_payload_base&& __other)
      {
	if (__other._M_engaged)
	  this->_M_construct(std::move(__other._M_get()));
      }

      // Copy constructor is only used to when the contained value is
      // trivially copy constructible.
      _Optional_payload_base(const _Optional_payload_base&) = default;

      // Move constructor is only used to when the contained value is
      // trivially copy constructible.
      _Optional_payload_base(_Optional_payload_base&&) = default;

      _Optional_payload_base&
      operator=(const _Optional_payload_base&) = default;

      _Optional_payload_base&
      operator=(_Optional_payload_base&&) = default;

      // used to perform non-trivial copy assignment.
      constexpr void
      _M_copy_assign(const _Optional_payload_base& __other)
      {
        if (this->_M_engaged && __other._M_engaged)
          this->_M_get() = __other._M_get();
        else
	  {
	    if (__other._M_engaged)
	      this->_M_construct(__other._M_get());
	    else
	      this->_M_reset();
	  }
      }

      // used to perform non-trivial move assignment.
      constexpr void
      _M_move_assign(_Optional_payload_base&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
		       is_nothrow_move_assignable<_Tp>>)
      {
	if (this->_M_engaged && __other._M_engaged)
	  this->_M_get() = std::move(__other._M_get());
	else
	  {
	    if (__other._M_engaged)
	      this->_M_construct(std::move(__other._M_get()));
	    else
	      this->_M_reset();
	  }
      }

      struct _Empty_byte { };

      template<typename _Up, bool = is_trivially_destructible_v<_Up>>
	union _Storage
	{
	  constexpr _Storage() noexcept : _M_empty() { }

	  template<typename... _Args>
	    constexpr
	    _Storage(in_place_t, _Args&&... __args)
	    : _M_value(std::forward<_Args>(__args)...)
	    { }

	  template<typename _Vp, typename... _Args>
	    constexpr
	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
	    : _M_value(__il, std::forward<_Args>(__args)...)
	    { }

	  _Empty_byte _M_empty;
          _Up _M_value;
	};

      template<typename _Up>
	union _Storage<_Up, false>
	{
	  constexpr _Storage() noexcept : _M_empty() { }

	  template<typename... _Args>
	    constexpr
	    _Storage(in_place_t, _Args&&... __args)
	    : _M_value(std::forward<_Args>(__args)...)
	    { }

	  template<typename _Vp, typename... _Args>
	    constexpr
	    _Storage(std::initializer_list<_Vp> __il, _Args&&... __args)
	    : _M_value(__il, std::forward<_Args>(__args)...)
	    { }

	  // User-provided destructor is needed when _Up has non-trivial dtor.
	  ~_Storage() { }

	  _Empty_byte _M_empty;
          _Up _M_value;
	};

      _Storage<_Stored_type> _M_payload;

      bool _M_engaged = false;

      template<typename... _Args>
        void
        _M_construct(_Args&&... __args)
        noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
        {
          ::new ((void *) std::__addressof(this->_M_payload))
            _Stored_type(std::forward<_Args>(__args)...);
          this->_M_engaged = true;
        }

      constexpr void
      _M_destroy() noexcept
      {
	_M_engaged = false;
	_M_payload._M_value.~_Stored_type();
      }

      // The _M_get() operations have _M_engaged as a precondition.
      // They exist to access the contained value with the appropriate
      // const-qualification, because _M_payload has had the const removed.

      constexpr _Tp&
      _M_get() noexcept
      { return this->_M_payload._M_value; }

      constexpr const _Tp&
      _M_get() const noexcept
      { return this->_M_payload._M_value; }

      // _M_reset is a 'safe' operation with no precondition.
      constexpr void
      _M_reset() noexcept
      {
	if (this->_M_engaged)
	  _M_destroy();
      }
    };

  // Class template that manages the payload for optionals.
  template <typename _Tp,
	    bool /*_HasTrivialDestructor*/ =
	      is_trivially_destructible_v<_Tp>,
	    bool /*_HasTrivialCopy */ =
	      is_trivially_copy_assignable_v<_Tp>
	      && is_trivially_copy_constructible_v<_Tp>,
	    bool /*_HasTrivialMove */ =
	      is_trivially_move_assignable_v<_Tp>
	      && is_trivially_move_constructible_v<_Tp>>
    struct _Optional_payload;

  // Payload for potentially-constexpr optionals (trivial copy/move/destroy).
  template <typename _Tp>
    struct _Optional_payload<_Tp, true, true, true>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
    };

  // Payload for optionals with non-trivial copy construction/assignment.
  template <typename _Tp>
    struct _Optional_payload<_Tp, true, false, true>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(_Optional_payload&&) = default;

      // Non-trivial copy assignment.
      constexpr
      _Optional_payload&
      operator=(const _Optional_payload& __other)
      {
	this->_M_copy_assign(__other);
	return *this;
      }
    };

  // Payload for optionals with non-trivial move construction/assignment.
  template <typename _Tp>
    struct _Optional_payload<_Tp, true, true, false>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(const _Optional_payload&) = default;

      // Non-trivial move assignment.
      constexpr
      _Optional_payload&
      operator=(_Optional_payload&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
		       is_nothrow_move_assignable<_Tp>>)
      {
	this->_M_move_assign(std::move(__other));
	return *this;
      }
    };

  // Payload for optionals with non-trivial copy and move assignment.
  template <typename _Tp>
    struct _Optional_payload<_Tp, true, false, false>
    : _Optional_payload_base<_Tp>
    {
      using _Optional_payload_base<_Tp>::_Optional_payload_base;

      _Optional_payload() = default;
      ~_Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;

      // Non-trivial copy assignment.
      constexpr
      _Optional_payload&
      operator=(const _Optional_payload& __other)
      {
	this->_M_copy_assign(__other);
	return *this;
      }

      // Non-trivial move assignment.
      constexpr
      _Optional_payload&
      operator=(_Optional_payload&& __other)
      noexcept(__and_v<is_nothrow_move_constructible<_Tp>,
		       is_nothrow_move_assignable<_Tp>>)
      {
	this->_M_move_assign(std::move(__other));
	return *this;
      }
    };

  // Payload for optionals with non-trivial destructors.
  template <typename _Tp, bool _Copy, bool _Move>
    struct _Optional_payload<_Tp, false, _Copy, _Move>
    : _Optional_payload<_Tp, true, false, false>
    {
      // Base class implements all the constructors and assignment operators:
      using _Optional_payload<_Tp, true, false, false>::_Optional_payload;
      _Optional_payload() = default;
      _Optional_payload(const _Optional_payload&) = default;
      _Optional_payload(_Optional_payload&&) = default;
      _Optional_payload& operator=(const _Optional_payload&) = default;
      _Optional_payload& operator=(_Optional_payload&&) = default;

      // Destructor needs to destroy the contained value:
      ~_Optional_payload() { this->_M_reset(); }
    };

  // Common base class for _Optional_base<T> to avoid repeating these
  // member functions in each specialization.
  template<typename _Tp, typename _Dp>
    class _Optional_base_impl
    {
    protected:
      using _Stored_type = remove_const_t<_Tp>;

      // The _M_construct operation has !_M_engaged as a precondition
      // while _M_destruct has _M_engaged as a precondition.
      template<typename... _Args>
	void
	_M_construct(_Args&&... __args)
	noexcept(is_nothrow_constructible_v<_Stored_type, _Args...>)
	{
	  ::new
	    (std::__addressof(static_cast<_Dp*>(this)->_M_payload._M_payload))
	    _Stored_type(std::forward<_Args>(__args)...);
	  static_cast<_Dp*>(this)->_M_payload._M_engaged = true;
	}

      void
      _M_destruct() noexcept
      { static_cast<_Dp*>(this)->_M_payload._M_destroy(); }

      // _M_reset is a 'safe' operation with no precondition.
      constexpr void
      _M_reset() noexcept
      { static_cast<_Dp*>(this)->_M_payload._M_reset(); }

      constexpr bool _M_is_engaged() const noexcept
      { return static_cast<const _Dp*>(this)->_M_payload._M_engaged; }

      // The _M_get operations have _M_engaged as a precondition.
      constexpr _Tp&
      _M_get() noexcept
      {
	__glibcxx_assert(this->_M_is_engaged());
	return static_cast<_Dp*>(this)->_M_payload._M_get();
      }

      constexpr const _Tp&
      _M_get() const noexcept
      {
	__glibcxx_assert(this->_M_is_engaged());
	return static_cast<const _Dp*>(this)->_M_payload._M_get();
      }
    };

  /**
    * @brief Class template that provides copy/move constructors of optional.
    *
    * Such a separate base class template is necessary in order to
    * conditionally make copy/move constructors trivial.
    *
    * When the contained value is trivally copy/move constructible,
    * the copy/move constructors of _Optional_base will invoke the
    * trivial copy/move constructor of _Optional_payload. Otherwise,
    * they will invoke _Optional_payload(bool, const _Optional_payload&)
    * or _Optional_payload(bool, _Optional_payload&&) to initialize
    * the contained value, if copying/moving an engaged optional.
    *
    * Whether the other special members are trivial is determined by the
    * _Optional_payload<_Tp> specialization used for the _M_payload member.
    *
    * @see optional, _Enable_special_members
    */
  template<typename _Tp,
	   bool = is_trivially_copy_constructible_v<_Tp>,
	   bool = is_trivially_move_constructible_v<_Tp>>
    struct _Optional_base
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {
      // Constructors for disengaged optionals.
      constexpr _Optional_base() = default;

      // Constructors for engaged optionals.
      template<typename... _Args,
	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
		     std::forward<_Args>(__args)...) { }

      template<typename _Up, typename... _Args,
               enable_if_t<is_constructible_v<_Tp,
					      initializer_list<_Up>&,
					      _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t,
                                          initializer_list<_Up> __il,
                                          _Args&&... __args)
        : _M_payload(in_place,
		     __il, std::forward<_Args>(__args)...)
        { }

      // Copy and move constructors.
      constexpr _Optional_base(const _Optional_base& __other)
	: _M_payload(__other._M_payload._M_engaged,
		     __other._M_payload)
      { }

      constexpr _Optional_base(_Optional_base&& __other)
      noexcept(is_nothrow_move_constructible_v<_Tp>)
	: _M_payload(__other._M_payload._M_engaged,
		     std::move(__other._M_payload))
      { }

      // Assignment operators.
      _Optional_base& operator=(const _Optional_base&) = default;
      _Optional_base& operator=(_Optional_base&&) = default;

      _Optional_payload<_Tp> _M_payload;
    };

  template<typename _Tp>
    struct _Optional_base<_Tp, false, true>
      : _Optional_base_impl<_Tp, _Optional_base<_Tp>>
    {
      // Constructors for disengaged optionals.
      constexpr _Optional_base() = default;

      // Constructors for engaged optionals.
      template<typename... _Args,
	       enable_if_t<is_constructible_v<_Tp, _Args&&...>, bool> = false>
        constexpr explicit _Optional_base(in_place_t, _Args&&... __args)
        : _M_payload(in_place,
		     std::forward<_Args>(__args)...) { }

      template<typename _Up, t