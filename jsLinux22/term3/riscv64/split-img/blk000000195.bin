um SWP_DEFERERASE = 8192;
enum SWP_ASYNCWINDOWPOS = 16384;

enum { // passed variously as int or WPARAM
    HSHELL_WINDOWCREATED    =     1,
    HSHELL_WINDOWDESTROYED,
    HSHELL_ACTIVATESHELLWINDOW,
    HSHELL_WINDOWACTIVATED,
    HSHELL_GETMINRECT,
    HSHELL_REDRAW,
    HSHELL_TASKMAN,
    HSHELL_LANGUAGE,     // =     8
    HSHELL_ENDTASK          =    10,
    HSHELL_ACCESSIBILITYSTATE,
    HSHELL_APPCOMMAND,   // =    12
    HSHELL_RUDEAPPACTIVATED = 32772,
    HSHELL_FLASH            = 32774
}

static if (_WIN32_WINNT >= 0x501) {
    enum {
        HSHELL_WINDOWREPLACED = 13,
        HSHELL_WINDOWREPLACING
    }
}

enum {
    SPI_GETBEEP                   = 0x0001,
    SPI_SETBEEP                   = 0x0002,
    SPI_GETMOUSE                  = 0x0003,
    SPI_SETMOUSE                  = 0x0004,
    SPI_GETBORDER                 = 0x0005,
    SPI_SETBORDER                 = 0x0006,
    SPI_GETKEYBOARDSPEED          = 0x000A,
    SPI_SETKEYBOARDSPEED          = 0x000B,
    SPI_LANGDRIVER                = 0x000C,
    SPI_ICONHORIZONTALSPACING     = 0x000D,
    SPI_GETSCREENSAVETIMEOUT      = 0x000E,
    SPI_SETSCREENSAVETIMEOUT      = 0x000F,
    SPI_GETSCREENSAVEACTIVE       = 0x0010,
    SPI_SETSCREENSAVEACTIVE       = 0x0011,
    SPI_GETGRIDGRANULARITY        = 0x0012,
    SPI_SETGRIDGRANULARITY        = 0x0013,
    SPI_SETDESKWALLPAPER          = 0x0014,
    SPI_SETDESKPATTERN            = 0x0015,
    SPI_GETKEYBOARDDELAY          = 0x0016,
    SPI_SETKEYBOARDDELAY          = 0x0017,
    SPI_ICONVERTICALSPACING       = 0x0018,
    SPI_GETICONTITLEWRAP          = 0x0019,
    SPI_SETICONTITLEWRAP          = 0x001A,
    SPI_GETMENUDROPALIGNMENT      = 0x001B,
    SPI_SETMENUDROPALIGNMENT      = 0x001C,
    SPI_SETDOUBLECLKWIDTH         = 0x001D,
    SPI_SETDOUBLECLKHEIGHT        = 0x001E,
    SPI_GETICONTITLELOGFONT       = 0x001F,
    SPI_SETDOUBLECLICKTIME        = 0x0020,
    SPI_SETMOUSEBUTTONSWAP        = 0x0021,
    SPI_SETICONTITLELOGFONT       = 0x0022,
    SPI_GETFASTTASKSWITCH         = 0x0023,
    SPI_SETFASTTASKSWITCH         = 0x0024,
    SPI_SETDRAGFULLWINDOWS        = 0x0025,
    SPI_GETDRAGFULLWINDOWS        = 0x0026,
    SPI_GETNONCLIENTMETRICS       = 0x0029,
    SPI_SETNONCLIENTMETRICS       = 0x002A,
    SPI_GETMINIMIZEDMETRICS       = 0x002B,
    SPI_SETMINIMIZEDMETRICS       = 0x002C,
    SPI_GETICONMETRICS            = 0x002D,
    SPI_SETICONMETRICS            = 0x002E,
    SPI_SETWORKAREA               = 0x002F,
    SPI_GETWORKAREA               = 0x0030,
    SPI_SETPENWINDOWS             = 0x0031,
    SPI_GETFILTERKEYS             = 0x0032,
    SPI_SETFILTERKEYS             = 0x0033,
    SPI_GETTOGGLEKEYS             = 0x0034,
    SPI_SETTOGGLEKEYS             = 0x0035,
    SPI_GETMOUSEKEYS              = 0x0036,
    SPI_SETMOUSEKEYS              = 0x0037,
    SPI_GETSHOWSOUNDS             = 0x0038,
    SPI_SETSHOWSOUNDS             = 0x0039,
    SPI_GETSTICKYKEYS             = 0x003A,
    SPI_SETSTICKYKEYS             = 0x003B,
    SPI_GETACCESSTIMEOUT          = 0x003C,
    SPI_SETACCESSTIMEOUT          = 0x003D,
    SPI_GETSERIALKEYS             = 0x003E,
    SPI_SETSERIALKEYS             = 0x003F,
    SPI_GETSOUNDSENTRY            = 0x0040,
    SPI_SETSOUNDSENTRY            = 0x0041,
    SPI_GETHIGHCONTRAST           = 0x0042,
    SPI_SETHIGHCONTRAST           = 0x0043,
    SPI_GETKEYBOARDPREF           = 0x0044,
    SPI_SETKEYBOARDPREF           = 0x0045,
    SPI_GETSCREENREADER           = 0x0046,
    SPI_SETSCREENREADER           = 0x0047,
    SPI_GETANIMATION              = 0x0048,
    SPI_SETANIMATION              = 0x0049,
    SPI_GETFONTSMOOTHING          = 0x004A,
    SPI_SETFONTSMOOTHING          = 0x004B,
    SPI_SETDRAGWIDTH              = 0x004C,
    SPI_SETDRAGHEIGHT             = 0x004D,
    SPI_SETHANDHELD               = 0x004E,
    SPI_GETLOWPOWERTIMEOUT        = 0x004F,
    SPI_GETPOWEROFFTIMEOUT        = 0x0050,
    SPI_SETLOWPOWERTIMEOUT        = 0x0051,
    SPI_SETPOWEROFFTIMEOUT        = 0x0052,
    SPI_GETLOWPOWERACTIVE         = 0x0053,
    SPI_GETPOWEROFFACTIVE         = 0x0054,
    SPI_SETLOWPOWERACTIVE         = 0x0055,
    SPI_SETPOWEROFFACTIVE         = 0x0056,
    SPI_SETCURSORS                = 0x0057,
    SPI_SETICONS                  = 0x0058,
    SPI_GETDEFAULTINPUTLANG       = 0x0059,
    SPI_SETDEFAULTINPUTLANG       = 0x005A,
    SPI_SETLANGTOGGLE             = 0x005B,
    SPI_GETWINDOWSEXTENSION       = 0x005C,
    SPI_SETMOUSETRAILS            = 0x005D,
    SPI_GETMOUSETRAILS            = 0x005E,
    SPI_GETSNAPTODEFBUTTON        = 0x005F,
    SPI_SETSNAPTODEFBUTTON        = 0x0060,
    //SPI_SCREENSAVERRUNNING        = 0x0061, // mistake in older MinGW?
    SPI_SETSCREENSAVERRUNNING     = 0x0061,
    SPI_GETMOUSEHOVERWIDTH        = 0x0062,
    SPI_SETMOUSEHOVERWIDTH        = 0x0063,
    SPI_GETMOUSEHOVERHEIGHT       = 0x0064,
    SPI_SETMOUSEHOVERHEIGHT       = 0x0065,
    SPI_GETMOUSEHOVERTIME         = 0x0066,
    SPI_SETMOUSEHOVERTIME         = 0x0067,
    SPI_GETWHEELSCROLLLINES       = 0x0068,
    SPI_SETWHEELSCROLLLINES       = 0x0069,
    SPI_GETMENUSHOWDELAY          = 0x006A,
    SPI_SETMENUSHOWDELAY          = 0x006B,
    SPI_GETSHOWIMEUI              = 0x006E,
    SPI_SETSHOWIMEUI              = 0x006F,
    SPI_GETMOUSESPEED             = 0x0070,
    SPI_SETMOUSESPEED             = 0x0071,
    SPI_GETSCREENSAVERRUNNING     = 0x0072,
    SPI_GETDESKWALLPAPER          = 0x0073,
    SPI_GETACTIVEWINDOWTRACKING   = 0x1000,
    SPI_SETACTIVEWINDOWTRACKING   = 0x1001,
    SPI_GETMENUANIMATION          = 0x1002,
    SPI_SETMENUANIMATION          = 0x1003,
    SPI_GETCOMBOBOXANIMATION      = 0x1004,
    SPI_SETCOMBOBOXANIMATION      = 0x1005,
    SPI_GETLISTBOXSMOOTHSCROLLING = 0x1006,
    SPI_SETLISTBOXSMOOTHSCROLLING = 0x1007,
    SPI_GETGRADIENTCAPTIONS       = 0x1008,
    SPI_SETGRADIENTCAPTIONS       = 0x1009,
    SPI_GETKEYBOARDCUES           = 0x100A,
    SPI_GETMENUUNDERLINES         = SPI_GETKEYBOARDCUES,
    SPI_SETKEYBOARDCUES           = 0x100B,
    SPI_SETMENUUNDERLINES         = SPI_SETKEYBOARDCUES,
    SPI_GETACTIVEWNDTRKZORDER     = 0x100C,
    SPI_SETACTIVEWNDTRKZORDER     = 0x100D,
    SPI_GETHOTTRACKING            = 0x100E,
    SPI_SETHOTTRACKING            = 0x100F,
    SPI_GETMENUFADE               = 0x1012,
    SPI_SETMENUFADE               = 0x1013,
    SPI_GETSELECTIONFADE          = 0x1014,
    SPI_SETSELECTIONFADE          = 0x1015,
    SPI_GETTOOLTIPANIMATION       = 0x1016,
    SPI_SETTOOLTIPANIMATION       = 0x1017,
    SPI_GETTOOLTIPFADE            = 0x1018,
    SPI_SETTOOLTIPFADE            = 0x1019,
    SPI_GETCURSORSHADOW           = 0x101A,
    SPI_SETCURSORSHADOW           = 0x101B,
    SPI_GETBLOCKSENDINPUTRESETS   = 0x1026,
    SPI_SETBLOCKSENDINPUTRESETS   = 0x1027,
    SPI_GETUIEFFECTS              = 0x103E,
    SPI_SETUIEFFECTS              = 0x103F,
    SPI_GETFOREGROUNDLOCKTIMEOUT  = 0x2000,
    SPI_SETFOREGROUNDLOCKTIMEOUT  = 0x2001,
    SPI_GETACTIVEWNDTRKTIMEOUT    = 0x2002,
    SPI_SETACTIVEWNDTRKTIMEOUT    = 0x2003,
    SPI_GETFOREGROUNDFLASHCOUNT   = 0x2004,
    SPI_SETFOREGROUNDFLASHCOUNT   = 0x2005,
    SPI_GETCARETWIDTH             = 0x2006,
    SPI_SETCARETWIDTH             = 0x2007
}

enum {
    SPIF_UPDATEINIFILE    = 1,
    SPIF_SENDWININICHANGE = 2,
    SPIF_SENDCHANGE       = SPIF_SENDWININICHANGE
}

// [Redefined] ATF_ONOFFFEEDBACK = 2
// [Redefined] ATF_TIMEOUTON = 1
enum WM_APP = 32768;
enum WM_ACTIVATE = 6;
enum WM_ACTIVATEAPP = 28;
enum WM_AFXFIRST = 864;
enum WM_AFXLAST = 895;
enum WM_ASKCBFORMATNAME = 780;
enum WM_CANCELJOURNAL = 75;
enum WM_CANCELMODE = 31;
enum WM_CAPTURECHANGED = 533;
enum WM_CHANGECBCHAIN = 781;
enum WM_CHAR = 258;
enum WM_CHARTOITEM = 47;
enum WM_CHILDACTIVATE = 34;
enum WM_CLEAR = 771;
enum WM_CLOSE = 16;
enum WM_COMMAND = 273;
enum WM_COMMNOTIFY = 68; // obsolete
enum WM_COMPACTING = 65;
enum WM_COMPAREITEM = 57;
enum WM_CONTEXTMENU = 123;
enum WM_COPY = 769;
enum WM_COPYDATA = 74;
enum WM_CREATE = 1;
enum WM_CTLCOLORBTN = 309;
enum WM_CTLCOLORDLG = 310;
enum WM_CTLCOLOREDIT = 307;
enum WM_CTLCOLORLISTBOX = 308;
enum WM_CTLCOLORMSGBOX = 306;
enum WM_CTLCOLORSCROLLBAR = 311;
enum WM_CTLCOLORSTATIC = 312;
enum WM_CUT = 768;
enum WM_DEADCHAR = 259;
enum WM_DELETEITEM = 45;
enum WM_DESTROY = 2;
enum WM_DESTROYCLIPBOARD = 775;
enum WM_DEVICECHANGE = 537;
enum WM_DEVMODECHANGE = 27;
enum WM_DISPLAYCHANGE = 126;
enum WM_DRAWCLIPBOARD = 776;
enum WM_DRAWITEM = 43;
enum WM_DROPFILES = 563;
enum WM_ENABLE = 10;
enum WM_ENDSESSION = 22;
enum WM_ENTERIDLE = 289;
enum WM_ENTERMENULOOP = 529;
enum WM_ENTERSIZEMOVE = 561;
enum WM_ERASEBKGND = 20;
enum WM_EXITMENULOOP = 530;
enum WM_EXITSIZEMOVE = 562;
enum WM_FONTCHANGE = 29;
enum WM_GETDLGCODE = 135;
enum WM_GETFONT = 49;
enum WM_GETHOTKEY = 51;
enum WM_GETICON = 127;
enum WM_GETMINMAXINFO = 36;
enum WM_GETTEXT = 13;
enum WM_GETTEXTLENGTH = 14;
enum WM_HANDHELDFIRST = 856;
enum WM_HANDHELDLAST = 863;
enum WM_HELP = 83;
enum WM_HOTKEY = 786;
enum WM_HSCROLL = 276;
enum WM_HSCROLLCLIPBOARD = 782;
enum WM_ICONERASEBKGND = 39;
enum WM_INITDIALOG = 272;
enum WM_INITMENU = 278;
enum WM_INITMENUPOPUP = 279;
enum WM_INPUTLANGCHANGE = 81;
enum WM_INPUTLANGCHANGEREQUEST = 80;
enum WM_KEYDOWN = 256;
enum WM_KEYUP = 257;
enum WM_KILLFOCUS = 8;
enum WM_MDIACTIVATE = 546;
enum WM_MDICASCADE = 551;
enum WM_MDICREATE = 544;
enum WM_MDIDESTROY = 545;
enum WM_MDIGETACTIVE = 553;
enum WM_MDIICONARRANGE = 552;
enum WM_MDIMAXIMIZE = 549;
enum WM_MDINEXT = 548;
enum WM_MDIREFRESHMENU = 564;
enum WM_MDIRESTORE = 547;
enum WM_MDISETMENU = 560;
enum WM_MDITILE = 550;
enum WM_MEASUREITEM = 44;
enum WM_UNINITMENUPOPUP = 0x0125;
enum WM_MENURBUTTONUP = 290;
enum WM_MENUCOMMAND = 0x0126;
enum WM_MENUGETOBJECT = 0x0124;
enum WM_MENUDRAG = 0x0123;

enum WM_CHANGEUISTATE = 0x0127;
enum WM_UPDATEUISTATE = 0x0128;
enum WM_QUERYUISTATE  = 0x0129;

// LOWORD(wParam) values in WM_*UISTATE*
enum {
    UIS_SET          =  1,
    UIS_CLEAR        =  2,
    UIS_INITIALIZE   =  3
}

// HIWORD(wParam) values in WM_*UISTATE*
enum {
    UISF_HIDEFOCUS   =  0x1,
    UISF_HIDEACCEL   =  0x2
}


static if (_WIN32_WINNT >= 0x501) {

    // HIWORD(wParam) values in WM_*UISTATE*
    enum {
        UISF_ACTIVE      =  0x4
    }

}

enum WM_MENUCHAR = 288;
enum WM_MENUSELECT = 287;
enum WM_MOVE = 3;
enum WM_MOVING = 534;
enum WM_NCACTIVATE = 134;
enum WM_NCCALCSIZE = 131;
enum WM_NCCREATE = 129;
enum WM_NCDESTROY = 130;
enum WM_NCHITTEST = 132;
enum WM_NCLBUTTONDBLCLK = 163;
enum WM_NCLBUTTONDOWN = 161;
enum WM_NCLBUTTONUP = 162;
enum WM_NCMBUTTONDBLCLK = 169;
enum WM_NCMBUTTONDOWN = 167;
enum WM_NCMBUTTONUP = 168;
enum WM_NCXBUTTONDOWN = 171;
enum WM_NCXBUTTONUP = 172;
enum WM_NCXBUTTONDBLCLK = 173;
enum WM_NCMOUSEHOVER = 0x02A0;
enum WM_NCMOUSELEAVE = 0x02A2;
enum WM_NCMOUSEMOVE = 160;
enum WM_NCPAINT = 133;
enum WM_NCRBUTTONDBLCLK = 166;
enum WM_NCRBUTTONDOWN = 164;
enum WM_NCRBUTTONUP = 165;
enum WM_NEXTDLGCTL = 40;
enum WM_NEXTMENU = 531;
enum WM_NOTIFY = 78;
enum WM_NOTIFYFORMAT = 85;
enum WM_NULL = 0;
enum WM_PAINT = 15;
enum WM_PAINTCLIPBOARD = 777;
enum WM_PAINTICON = 38;
enum WM_PALETTECHANGED = 785;
enum WM_PALETTEISCHANGING = 784;
enum WM_PARENTNOTIFY = 528;
enum WM_PASTE = 770;
enum WM_PENWINFIRST = 896;
enum WM_PENWINLAST = 911;
enum WM_POWER = 72;
enum WM_POWERBROADCAST = 536;
enum WM_PRINT = 791;
enum WM_PRINTCLIENT = 792;
enum WM_APPCOMMAND = 0x0319;
enum WM_QUERYDRAGICON = 55;
enum WM_QUERYENDSESSION = 17;
enum WM_QUERYNEWPALETTE = 783;
enum WM_QUERYOPEN = 19;
enum WM_QUEUESYNC = 35;
enum WM_QUIT = 18;
enum WM_RENDERALLFORMATS = 774;
enum WM_RENDERFORMAT = 773;
enum WM_SETCURSOR = 32;
enum WM_SETFOCUS = 7;
enum WM_SETFONT = 48;
enum WM_SETHOTKEY = 50;
enum WM_SETICON = 128;
enum WM_SETREDRAW = 11;
enum WM_SETTEXT = 12;
enum WM_SETTINGCHANGE = 26;
enum WM_SHOWWINDOW = 24;
enum WM_SIZE = 5;
enum WM_SIZECLIPBOARD = 779;
enum WM_SIZING = 532;
enum WM_SPOOLERSTATUS = 42;
enum WM_STYLECHANGED = 125;
enum WM_STYLECHANGING = 124;
enum WM_SYSCHAR = 262;
enum WM_SYSCOLORCHANGE = 21;
enum WM_SYSCOMMAND = 274;
enum WM_SYSDEADCHAR = 263;
enum WM_SYSKEYDOWN = 260;
enum WM_SYSKEYUP = 261;
static if (_WIN32_WINNT >= 0x501) {
    enum WM_TABLET_FIRST = 704;
    enum WM_TABLET_LAST = 735;
}
enum WM_TCARD = 82;
enum WM_THEMECHANGED = 794;
enum WM_TIMECHANGE = 30;
enum WM_TIMER = 275;
enum WM_UNDO = 772;
enum WM_USER = 1024;
enum WM_USERCHANGED = 84;
enum WM_VKEYTOITEM = 46;
enum WM_VSCROLL = 277;
enum WM_VSCROLLCLIPBOARD = 778;
enum WM_WINDOWPOSCHANGED = 71;
enum WM_WINDOWPOSCHANGING = 70;
enum WM_WININICHANGE = 26;
static if (_WIN32_WINNT >= 0x501) {
enum WM_WTSSESSION_CHANGE = 689;
}
enum WM_INPUT = 255;
enum WM_KEYFIRST = 256;
static if (_WIN32_WINNT >= 0x501) {
enum WM_UNICHAR = 265;
enum WM_KEYLAST = 265;
enum UNICODE_NOCHAR = 0xFFFF;
} else {
enum WM_KEYLAST = 264;
}
enum WM_SYNCPAINT = 136;
enum WM_MOUSEACTIVATE = 33;
enum WM_MOUSEMOVE = 512;
enum WM_LBUTTONDOWN = 513;
enum WM_LBUTTONUP = 514;
enum WM_LBUTTONDBLCLK = 515;
enum WM_RBUTTONDOWN = 516;
enum WM_RBUTTONUP = 517;
enum WM_RBUTTONDBLCLK = 518;
enum WM_MBUTTONDOWN = 519;
enum WM_MBUTTONUP = 520;
enum WM_MBUTTONDBLCLK = 521;
enum WM_MOUSEWHEEL = 522;
enum WM_MOUSEFIRST = 512;
static if (_WIN32_WINNT >= 0x501) {
    enum WM_XBUTTONDOWN = 523;
    enum WM_XBUTTONUP = 524;
    enum WM_XBUTTONDBLCLK = 525;
}
static if (_WIN32_WINNT >= 0x600) { // FIXME: where did this come from? what version is it?
    enum WM_MOUSEHWHEEL = 526;
}

static if (_WIN32_WINNT >= 0x600) {
    enum WM_MOUSELAST = WM_MOUSEHWHEEL;
} else static if (_WIN32_WINNT >= 0x501) {
    enum WM_MOUSELAST = WM_XBUTTONDBLCLK;
} else {
    enum WM_MOUSELAST = WM_MOUSEWHEEL;
}

enum WM_MOUSEHOVER = 0x2A1;
enum WM_MOUSELEAVE = 0x2A3;

enum WHEEL_DELTA = 120;

SHORT GET_WHEEL_DELTA_WPARAM()(WPARAM wparam) {
    return cast(SHORT) HIWORD(wparam);
}

enum WHEEL_PAGESCROLL = uint.max;

enum BM_CLICK = 245;
enum BM_GETCHECK = 240;
enum BM_GETIMAGE = 246;
enum BM_GETSTATE = 242;
enum BM_SETCHECK = 241;
enum BM_SETIMAGE = 247;
static if (_WIN32_WINNT >= 0x600) {
    enum BM_SETDONTCLICK = 248;
}
enum BM_SETSTATE = 243;
enum BM_SETSTYLE = 244;
enum BN_CLICKED = 0;
enum BN_DBLCLK = 5;
enum BN_DISABLE = 4;
enum BN_DOUBLECLICKED = 5;
enum BN_HILITE = 2;
enum BN_KILLFOCUS = 7;
enum BN_PAINT = 1;
enum BN_PUSHED = 2;
enum BN_SETFOCUS = 6;
enum BN_UNHILITE = 3;
enum BN_UNPUSHED = 3;
enum CB_ADDSTRING = 323;
enum CB_DELETESTRING = 324;
enum CB_DIR = 325;
enum CB_FINDSTRING = 332;
enum CB_FINDSTRINGEXACT = 344;
enum CB_GETCOUNT = 326;
enum CB_GETCURSEL = 327;
enum CB_GETDROPPEDCONTROLRECT = 338;
enum CB_GETDROPPEDSTATE = 343;
enum CB_GETDROPPEDWIDTH = 351;
enum CB_GETEDITSEL = 320;
enum CB_GETEXTENDEDUI = 342;
enum CB_GETHORIZONTALEXTENT = 349;
enum CB_GETITEMDATA = 336;
enum CB_GETITEMHEIGHT = 340;
enum CB_GETLBTEXT = 328;
enum CB_GETLBTEXTLEN = 329;
enum CB_GETLOCALE = 346;
enum CB_GETTOPINDEX = 347;
enum CB_INITSTORAGE = 353;
enum CB_INSERTSTRING = 330;
enum CB_LIMITTEXT = 321;
enum CB_RESETCONTENT = 331;
enum CB_SELECTSTRING = 333;
enum CB_SETCURSEL = 334;
enum CB_SETDROPPEDWIDTH = 352;
enum CB_SETEDITSEL = 322;
enum CB_SETEXTENDEDUI = 341;
enum CB_SETHORIZONTALEXTENT = 350;
enum CB_SETITEMDATA = 337;
enum CB_SETITEMHEIGHT = 339;
enum CB_SETLOCALE = 345;
enum CB_SETTOPINDEX = 348;
enum CB_SHOWDROPDOWN = 335;

static if (_WIN32_WINNT >= 0x501) {
enum CB_GETCOMBOBOXINFO = 356;
}

enum CBN_CLOSEUP = 8;
enum CBN_DBLCLK = 2;
enum CBN_DROPDOWN = 7;
enum CBN_EDITCHANGE = 5;
enum CBN_EDITUPDATE = 6;
enum CBN_ERRSPACE = (-1);
enum CBN_KILLFOCUS = 4;
enum CBN_SELCHANGE = 1;
enum CBN_SELENDCANCEL = 10;
enum CBN_SELENDOK = 9;
enum CBN_SETFOCUS = 3;

enum EM_CANUNDO = 198;
enum EM_CHARFROMPOS = 215;
enum EM_EMPTYUNDOBUFFER = 205;
enum EM_FMTLINES = 200;
enum EM_GETFIRSTVISIBLELINE = 206;
enum EM_GETHANDLE = 189;
enum EM_GETLIMITTEXT = 213;
enum EM_GETLINE = 196;
enum EM_GETLINECOUNT = 186;
enum EM_GETMARGINS = 212;
enum EM_GETMODIFY = 184;
enum EM_GETPASSWORDCHAR = 210;
enum EM_GETRECT = 178;
enum EM_GETSEL = 176;
enum EM_GETTHUMB = 190;
enum EM_GETWORDBREAKPROC = 209;
enum EM_LIMITTEXT = 197;
enum EM_LINEFROMCHAR = 201;
enum EM_LINEINDEX = 187;
enum EM_LINELENGTH = 193;
enum EM_LINESCROLL = 182;
enum EM_POSFROMCHAR = 214;
enum EM_REPLACESEL = 194;
enum EM_SCROLL = 181;
enum EM_SCROLLCARET = 183;
enum EM_SETHANDLE = 188;
enum EMÅ0  Æ0  Ç0  È0  É0  Ê0  Ë0  Ì0  Í0  Î0  Ï0  Ð0  Ñ0  Ò0  Ó0  Ô0  Õ0  Ö0  ×0  Ø0  Ù0  Ú0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          _SETLIMITTEXT = 197;
enum EM_SETMARGINS = 211;
enum EM_SETMODIFY = 185;
enum EM_SETPASSWORDCHAR = 204;
enum EM_SETREADONLY = 207;
enum EM_SETRECT = 179;
enum EM_SETRECTNP = 180;
enum EM_SETSEL = 177;
enum EM_SETTABSTOPS = 203;
enum EM_SETWORDBREAKPROC = 208;
enum EM_UNDO = 199;

enum EM_SETIMESTATUS = 216;
enum EM_GETIMESTATUS = 217;

enum EN_CHANGE = 768;
enum EN_ERRSPACE = 1280;
enum EN_HSCROLL = 1537;
enum EN_KILLFOCUS = 512;
enum EN_MAXTEXT = 1281;
enum EN_SETFOCUS = 256;
enum EN_UPDATE = 1024;
enum EN_VSCROLL = 1538;

enum LB_ADDFILE = 406;
enum LB_ADDSTRING = 384;
enum LB_DELETESTRING = 386;
enum LB_DIR = 397;
enum LB_FINDSTRING = 399;
enum LB_FINDSTRINGEXACT = 418;
enum LB_GETANCHORINDEX = 413;
enum LB_GETCARETINDEX = 415;
enum LB_GETCOUNT = 395;
enum LB_GETCURSEL = 392;
enum LB_GETHORIZONTALEXTENT = 403;
enum LB_GETITEMDATA = 409;
enum LB_GETITEMHEIGHT = 417;
enum LB_GETITEMRECT = 408;
enum LB_GETLOCALE = 422;
enum LB_GETSEL = 391;
enum LB_GETSELCOUNT = 400;
enum LB_GETSELITEMS = 401;
enum LB_GETTEXT = 393;
enum LB_GETTEXTLEN = 394;
enum LB_GETTOPINDEX = 398;
enum LB_INITSTORAGE = 424;
enum LB_INSERTSTRING = 385;
enum LB_ITEMFROMPOINT = 425;
enum LB_RESETCONTENT = 388;
enum LB_SELECTSTRING = 396;
enum LB_SELITEMRANGE = 411;
enum LB_SELITEMRANGEEX = 387;
enum LB_SETANCHORINDEX = 412;
enum LB_SETCARETINDEX = 414;
enum LB_SETCOLUMNWIDTH = 405;
enum LB_SETCOUNT = 423;
enum LB_SETCURSEL = 390;
enum LB_SETHORIZONTALEXTENT = 404;
enum LB_SETITEMDATA = 410;
enum LB_SETITEMHEIGHT = 416;
enum LB_SETLOCALE = 421;
enum LB_SETSEL = 389;
enum LB_SETTABSTOPS = 402;
enum LB_SETTOPINDEX = 407;
static if (_WIN32_WINNT >= 0x501) {
enum LB_GETLISTBOXINFO = 434;
}

enum LBN_DBLCLK = 2;
enum LBN_ERRSPACE = -2;
enum LBN_KILLFOCUS = 5;
enum LBN_SELCANCEL = 3;
enum LBN_SELCHANGE = 1;
enum LBN_SETFOCUS = 4;

enum SBM_ENABLE_ARROWS = 228;
enum SBM_GETPOS = 225;
enum SBM_GETRANGE = 227;
enum SBM_GETSCROLLINFO = 234;
enum SBM_SETPOS = 224;
enum SBM_SETRANGE = 226;
enum SBM_SETRANGEREDRAW = 230;
enum SBM_SETSCROLLINFO = 233;
static if (_WIN32_WINNT >= 0x501) {
enum SBM_GETSCROLLBARINFO = 235;
}

enum STM_GETICON = 369;
enum STM_GETIMAGE = 371;
enum STM_SETICON = 368;
enum STM_SETIMAGE = 370;
enum STN_CLICKED = 0;
enum STN_DBLCLK = 1;
enum STN_DISABLE = 3;
enum STN_ENABLE = 2;
enum STM_MSGMAX = 372;

enum DM_GETDEFID   = WM_USER;
enum DM_SETDEFID   = WM_USER+1;
enum DM_REPOSITION = WM_USER+2;

enum PSM_PAGEINFO  = WM_USER+100;
enum PSM_SHEETINFO = WM_USER+101;

enum PSI_SETACTIVE = 1;
enum PSI_KILLACTIVE = 2;
enum PSI_APPLY = 3;
enum PSI_RESET = 4;
enum PSI_HASHELP = 5;
enum PSI_HELP = 6;
enum PSI_CHANGED = 1;
enum PSI_GUISTART = 2;
enum PSI_REBOOT = 3;
enum PSI_GETSIBLINGS = 4;

enum DCX_WINDOW = 1;
enum DCX_CACHE = 2;
enum DCX_PARENTCLIP = 32;
enum DCX_CLIPSIBLINGS = 16;
enum DCX_CLIPCHILDREN = 8;
enum DCX_NORESETATTRS = 4;
enum DCX_INTERSECTUPDATE = 0x200;
enum DCX_LOCKWINDOWUPDATE = 0x400;
enum DCX_EXCLUDERGN = 64;
enum DCX_INTERSECTRGN = 128;
enum DCX_EXCLUDEUPDATE = 256;
enum DCX_VALIDATE = 0x200000;

enum GMDI_GOINTOPOPUPS = 2;
enum GMDI_USEDISABLED = 1;
enum FKF_AVAILABLE = 2;
enum FKF_CLICKON = 64;
enum FKF_FILTERKEYSON = 1;
enum FKF_HOTKEYACTIVE = 4;
enum FKF_HOTKEYSOUND = 16;
enum FKF_CONFIRMHOTKEY = 8;
enum FKF_INDICATOR = 32;
enum HCF_HIGHCONTRASTON = 1;
enum HCF_AVAILABLE = 2;
enum HCF_HOTKEYACTIVE = 4;
enum HCF_CONFIRMHOTKEY = 8;
enum HCF_HOTKEYSOUND = 16;
enum HCF_INDICATOR = 32;
enum HCF_HOTKEYAVAILABLE = 64;
enum MKF_AVAILABLE = 2;
enum MKF_CONFIRMHOTKEY = 8;
enum MKF_HOTKEYACTIVE = 4;
enum MKF_HOTKEYSOUND = 16;
enum MKF_INDICATOR = 32;
enum MKF_MOUSEKEYSON = 1;
enum MKF_MODIFIERS = 64;
enum MKF_REPLACENUMBERS = 128;
enum SERKF_ACTIVE = 8;  // May be obsolete. Not in recent MS docs.
enum SERKF_AVAILABLE = 2;
enum SERKF_INDICATOR = 4;
enum SERKF_SERIALKEYSON = 1;
enum SSF_AVAILABLE = 2;
enum SSF_SOUNDSENTRYON = 1;
enum SSTF_BORDER = 2;
enum SSTF_CHARS = 1;
enum SSTF_DISPLAY = 3;
enum SSTF_NONE = 0;
enum SSGF_DISPLAY = 3;
enum SSGF_NONE = 0;
enum SSWF_CUSTOM = 4;
enum SSWF_DISPLAY = 3;
enum SSWF_NONE = 0;
enum SSWF_TITLE = 1;
enum SSWF_WINDOW = 2;
enum SKF_AUDIBLEFEEDBACK = 64;
enum SKF_AVAILABLE = 2;
enum SKF_CONFIRMHOTKEY = 8;
enum SKF_HOTKEYACTIVE = 4;
enum SKF_HOTKEYSOUND = 16;
enum SKF_INDICATOR = 32;
enum SKF_STICKYKEYSON = 1;
enum SKF_TRISTATE = 128;
enum SKF_TWOKEYSOFF = 256;
enum TKF_AVAILABLE = 2;
enum TKF_CONFIRMHOTKEY = 8;
enum TKF_HOTKEYACTIVE = 4;
enum TKF_HOTKEYSOUND = 16;
enum TKF_TOGGLEKEYSON = 1;
enum MDITILE_SKIPDISABLED = 2;
enum MDITILE_HORIZONTAL = 1;
enum MDITILE_VERTICAL = 0;

enum {
    VK_LBUTTON = 0x01,
    VK_RBUTTON = 0x02,
    VK_CANCEL = 0x03,
    VK_MBUTTON = 0x04,
    VK_XBUTTON1 = 0x05,
    VK_XBUTTON2 = 0x06,
    VK_BACK = 0x08,
    VK_TAB = 0x09,
    VK_CLEAR = 0x0C,
    VK_RETURN = 0x0D,
    VK_SHIFT = 0x10,
    VK_CONTROL = 0x11,
    VK_MENU = 0x12,
    VK_PAUSE = 0x13,
    VK_CAPITAL = 0x14,
    VK_KANA = 0x15,
    VK_HANGEUL = 0x15,
    VK_HANGUL = 0x15,
    VK_JUNJA = 0x17,
    VK_FINAL = 0x18,
    VK_HANJA = 0x19,
    VK_KANJI = 0x19,
    VK_ESCAPE = 0x1B,
    VK_CONVERT = 0x1C,
    VK_NONCONVERT = 0x1D,
    VK_ACCEPT = 0x1E,
    VK_MODECHANGE = 0x1F,
    VK_SPACE = 0x20,
    VK_PRIOR = 0x21,
    VK_NEXT = 0x22,
    VK_END = 0x23,
    VK_HOME = 0x24,
    VK_LEFT = 0x25,
    VK_UP = 0x26,
    VK_RIGHT = 0x27,
    VK_DOWN = 0x28,
    VK_SELECT = 0x29,
    VK_PRINT = 0x2A,
    VK_EXECUTE = 0x2B,
    VK_SNAPSHOT = 0x2C,
    VK_INSERT = 0x2D,
    VK_DELETE = 0x2E,
    VK_HELP = 0x2F,
    VK_LWIN = 0x5B,
    VK_RWIN = 0x5C,
    VK_APPS = 0x5D,
    VK_SLEEP = 0x5F,
    VK_NUMPAD0 = 0x60,
    VK_NUMPAD1 = 0x61,
    VK_NUMPAD2 = 0x62,
    VK_NUMPAD3 = 0x63,
    VK_NUMPAD4 = 0x64,
    VK_NUMPAD5 = 0x65,
    VK_NUMPAD6 = 0x66,
    VK_NUMPAD7 = 0x67,
    VK_NUMPAD8 = 0x68,
    VK_NUMPAD9 = 0x69,
    VK_MULTIPLY = 0x6A,
    VK_ADD = 0x6B,
    VK_SEPARATOR = 0x6C,
    VK_SUBTRACT = 0x6D,
    VK_DECIMAL = 0x6E,
    VK_DIVIDE = 0x6F,
    VK_F1 = 0x70,
    VK_F2 = 0x71,
    VK_F3 = 0x72,
    VK_F4 = 0x73,
    VK_F5 = 0x74,
    VK_F6 = 0x75,
    VK_F7 = 0x76,
    VK_F8 = 0x77,
    VK_F9 = 0x78,
    VK_F10 = 0x79,
    VK_F11 = 0x7A,
    VK_F12 = 0x7B,
    VK_F13 = 0x7C,
    VK_F14 = 0x7D,
    VK_F15 = 0x7E,
    VK_F16 = 0x7F,
    VK_F17 = 0x80,
    VK_F18 = 0x81,
    VK_F19 = 0x82,
    VK_F20 = 0x83,
    VK_F21 = 0x84,
    VK_F22 = 0x85,
    VK_F23 = 0x86,
    VK_F24 = 0x87,
    VK_NUMLOCK = 0x90,
    VK_SCROLL = 0x91,
    VK_LSHIFT = 0xA0,
    VK_RSHIFT = 0xA1,
    VK_LCONTROL = 0xA2,
    VK_RCONTROL = 0xA3,
    VK_LMENU = 0xA4,
    VK_RMENU = 0xA5,
    VK_BROWSER_BACK = 0xA6,
    VK_BROWSER_FORWARD = 0xA7,
    VK_BROWSER_REFRESH = 0xA8,
    VK_BROWSER_STOP = 0xA9,
    VK_BROWSER_SEARCH = 0xAA,
    VK_BROWSER_FAVORITES = 0xAB,
    VK_BROWSER_HOME = 0xAC,
    VK_VOLUME_MUTE = 0xAD,
    VK_VOLUME_DOWN = 0xAE,
    VK_VOLUME_UP = 0xAF,
    VK_MEDIA_NEXT_TRACK = 0xB0,
    VK_MEDIA_PREV_TRACK = 0xB1,
    VK_MEDIA_STOP = 0xB2,
    VK_MEDIA_PLAY_PAUSE = 0xB3,
    VK_LAUNCH_MAIL = 0xB4,
    VK_LAUNCH_MEDIA_SELECT = 0xB5,
    VK_LAUNCH_APP1 = 0xB6,
    VK_LAUNCH_APP2 = 0xB7,
    VK_OEM_1 = 0xBA,
    VK_OEM_PLUS = 0xBB,
    VK_OEM_COMMA = 0xBC,
    VK_OEM_MINUS = 0xBD,
    VK_OEM_PERIOD = 0xBE,
    VK_OEM_2 = 0xBF,
    VK_OEM_3 = 0xC0,
    VK_OEM_4 = 0xDB,
    VK_OEM_5 = 0xDC,
    VK_OEM_6 = 0xDD,
    VK_OEM_7 = 0xDE,
    VK_OEM_8 = 0xDF,
    VK_OEM_102 = 0xE2,
    VK_PROCESSKEY = 0xE5,
    VK_PACKET = 0xE7,
    VK_ATTN = 0xF6,
    VK_CRSEL = 0xF7,
    VK_EXSEL = 0xF8,
    VK_EREOF = 0xF9,
    VK_PLAY = 0xFA,
    VK_ZOOM = 0xFB,
    VK_NONAME = 0xFC,
    VK_PA1 = 0xFD,
    VK_OEM_CLEAR = 0xFE,
}

enum TME_HOVER = 1;
enum TME_LEAVE = 2;
enum TME_QUERY = 0x40000000;
enum TME_CANCEL = 0x80000000;

enum HOVER_DEFAULT = 0xFFFFFFFF;

enum MK_LBUTTON = 1;
enum MK_RBUTTON = 2;
enum MK_SHIFT = 4;
enum MK_CONTROL = 8;
enum MK_MBUTTON = 16;
enum MK_XBUTTON1 = 32;
enum MK_XBUTTON2 = 64;

enum {
    TPM_RECURSE      = 0x0001,
    TPM_LEFTBUTTON   = 0,
    TPM_RIGHTBUTTON  = 0x0002,
    TPM_LEFTALIGN    = 0,
    TPM_CENTERALIGN  = 0x0004,
    TPM_RIGHTALIGN   = 0x0008,
    TPM_TOPALIGN     = 0,
    TPM_VCENTERALIGN = 0x0010,
    TPM_BOTTOMALIGN  = 0x0020,
    TPM_HORIZONTAL   = 0,
    TPM_VERTICAL     = 0x0040,
    TPM_NONOTIFY     = 0x0080,
    TPM_RETURNCMD    = 0x0100
}

enum HELP_COMMAND = 0x102;
enum HELP_CONTENTS = 3;
enum HELP_CONTEXT = 1;
enum HELP_CONTEXTPOPUP = 8;
enum HELP_FORCEFILE = 9;
enum HELP_HELPONHELP = 4;
enum HELP_INDEX = 3;
enum HELP_KEY = 0x101;
enum HELP_MULTIKEY = 0x201;
enum HELP_PARTIALKEY = 0x105;
enum HELP_QUIT = 2;
enum HELP_SETCONTENTS = 5;
enum HELP_SETINDEX = 5;
enum HELP_SETWINPOS = 0x203;
enum HELP_CONTEXTMENU = 0xa;
enum HELP_FINDER = 0xb;
enum HELP_WM_HELP = 0xc;
enum HELP_TCARD = 0x8000;
enum HELP_TCARD_DATA = 16;
enum HELP_TCARD_OTHER_CALLER = 0x11;

enum IDH_NO_HELP = 28440;
enum IDH_MISSING_CONTEXT = 28441;
enum IDH_GENERIC_HELP_BUTTON = 28442;
enum IDH_OK = 28443;
enum IDH_CANCEL = 28444;
enum IDH_HELP = 28445;

enum LB_CTLCODE = 0;
enum LB_OKAY = 0;
enum LB_ERR = -1;
enum LB_ERRSPACE = -2;

enum CB_OKAY = 0;
enum CB_ERR = -1;
enum CB_ERRSPACE = -2;

enum HIDE_WINDOW = 0;

enum SHOW_OPENWINDOW = 1;
enum SHOW_ICONWINDOW = 2;
enum SHOW_FULLSCREEN = 3;
enum SHOW_OPENNOACTIVATE = 4;

enum KF_EXTENDED = 256;
enum KF_DLGMODE = 2048;
enum KF_MENUMODE = 4096;
enum KF_ALTDOWN = 8192;
enum KF_REPEAT = 16384;
enum KF_UP = 32768;

enum WSF_VISIBLE = 1;

enum PWR_OK = 1;
enum PWR_FAIL = -1;
enum PWR_SUSPENDREQUEST = 1;
enum PWR_SUSPENDRESUME = 2;
enum PWR_CRITICALRESUME = 3;

enum NFR_ANSI = 1;
enum NFR_UNICODE = 2;
enum NF_QUERY = 3;
enum NF_REQUERY = 4;

enum MENULOOP_WINDOW = 0;
enum MENULOOP_POPUP = 1;

enum WMSZ_LEFT = 1;
enum WMSZ_RIGHT = 2;
enum WMSZ_TOP = 3;
enum WMSZ_TOPLEFT = 4;
enum WMSZ_TOPRIGHT = 5;
enum WMSZ_BOTTOM = 6;
enum WMSZ_BOTTOMLEFT = 7;
enum WMSZ_BOTTOMRIGHT = 8;

enum HTERROR = -2;
enum HTTRANSPARENT = -1;
enum HTNOWHERE = 0;
enum HTCLIENT = 1;
enum HTCAPTION = 2;
enum HTSYSMENU = 3;
enum HTGROWBOX = 4;
enum HTSIZE = 4;
enum HTMENU = 5;
enum HTHSCROLL = 6;
enum HTVSCROLL = 7;
enum HTMINBUTTON = 8;
enum HTMAXBUTTON = 9;
enum HTREDUCE = 8;
enum HTZOOM = 9;
enum HTLEFT = 10;
enum HTSIZEFIRST = 10;
enum HTRIGHT = 11;
enum HTTOP = 12;
enum HTTOPLEFT = 13;
enum HTTOPRIGHT = 14;
enum HTBOTTOM = 15;
enum HTBOTTOMLEFT = 16;
enum HTBOTTOMRIGHT = 17;
enum HTSIZELAST = 17;
enum HTBORDER = 18;
enum HTOBJECT = 19;
enum HTCLOSE = 20;
enum HTHELP = 21;

enum MA_ACTIVATE = 1;
enum MA_ACTIVATEANDEAT = 2;
enum MA_NOACTIVATE = 3;
enum MA_NOACTIVATEANDEAT = 4;

enum SIZE_RESTORED = 0;
enum SIZE_MINIMIZED = 1;
enum SIZE_MAXIMIZED = 2;
enum SIZE_MAXSHOW = 3;
enum SIZE_MAXHIDE = 4;

enum SIZENORMAL = 0;
enum SIZEICONIC = 1;
enum SIZEFULLSCREEN = 2;
enum SIZEZOOMSHOW = 3;
enum SIZEZOOMHIDE = 4;

enum WVR_ALIGNTOP = 16;
enum WVR_ALIGNLEFT = 32;
enum WVR_ALIGNBOTTOM = 64;
enum WVR_ALIGNRIGHT = 128;
enum WVR_HREDRAW = 256;
enum WVR_VREDRAW = 512;
enum WVR_REDRAW = (WVR_HREDRAW|WVR_VREDRAW);
enum WVR_VALIDRECTS = 1024;

enum PRF_CHECKVISIBLE = 1;
enum PRF_NONCLIENT = 2;
enum PRF_CLIENT = 4;
enum PRF_ERASEBKGND = 8;
enum PRF_CHILDREN = 16;
enum PRF_OWNED = 32;

enum IDANI_OPEN = 1;
enum IDANI_CLOSE = 2;
enum IDANI_CAPTION = 3;

enum WPF_RESTORETOMAXIMIZED = 2;
enum WPF_SETMINPOSITION = 1;

enum ODT_MENU = 1;
enum ODT_LISTBOX = 2;
enum ODT_COMBOBOX = 3;
enum ODT_BUTTON = 4;
enum ODT_STATIC = 5;
enum ODA_DRAWENTIRE = 1;
enum ODA_SELECT = 2;
enum ODA_FOCUS = 4;
enum ODS_SELECTED = 1;
enum ODS_GRAYED = 2;
enum ODS_DISABLED = 4;
enum ODS_CHECKED = 8;
enum ODS_FOCUS = 16;
enum ODS_DEFAULT = 32;
enum ODS_COMBOBOXEDIT = 4096;

enum IDHOT_SNAPWINDOW = -1;
enum IDHOT_SNAPDESKTOP = -2;

enum DBWF_LPARAMPOINTER = 0x8000;
enum DLGWINDOWEXTRA = 30;
enum MNC_IGNORE = 0;
enum MNC_CLOSE = 1;
enum MNC_EXECUTE = 2;
enum MNC_SELECT = 3;
enum DOF_EXECUTABLE = 0x8001;
enum DOF_DOCUMENT = 0x8002;
enum DOF_DIRECTORY = 0x8003;
enum DOF_MULTIPLE = 0x8004;
enum DOF_PROGMAN = 1;
enum DOF_SHELLDATA = 2;
enum DO_DROPFILE = 0x454C4946;
enum DO_PRINTFILE = 0x544E5250;

enum SC_SIZE = 0xF000;
enum SC_MOVE = 0xF010;
enum SC_MINIMIZE = 0xF020;
enum SC_ICON = 0xf020;
enum SC_MAXIMIZE = 0xF030;
enum SC_ZOOM = 0xF030;
enum SC_NEXTWINDOW = 0xF040;
enum SC_PREVWINDOW = 0xF050;
enum SC_CLOSE = 0xF060;
enum SC_VSCROLL = 0xF070;
enum SC_HSCROLL = 0xF080;
enum SC_MOUSEMENU = 0xF090;
enum SC_KEYMENU = 0xF100;
enum SC_ARRANGE = 0xF110;
enum SC_RESTORE = 0xF120;
enum SC_TASKLIST = 0xF130;
enum SC_SCREENSAVE = 0xF140;
enum SC_HOTKEY = 0xF150;
enum SC_DEFAULT = 0xF160;
enum SC_MONITORPOWER = 0xF170;
enum SC_CONTEXTHELP = 0xF180;
enum SC_SEPARATOR = 0xF00F;

enum EC_LEFTMARGIN = 1;
enum EC_RIGHTMARGIN = 2;
enum EC_USEFONTINFO = 0xffff;

enum DC_HASDEFID = 0x534B;

enum DLGC_WANTARROWS = 1;
enum DLGC_WANTTAB = 2;
enum DLGC_WANTALLKEYS = 4;
enum DLGC_WANTMESSAGE = 4;
enum DLGC_HASSETSEL = 8;
enum DLGC_DEFPUSHBUTTON = 16;
enum DLGC_UNDEFPUSHBUTTON = 32;
enum DLGC_RADIOBUTTON = 64;
enum DLGC_WANTCHARS = 128;
enum DLGC_STATIC = 256;
enum DLGC_BUTTON = 0x2000;

enum WA_INACTIVE = 0;
enum WA_ACTIVE = 1;
enum WA_CLICKACTIVE = 2;

enum ICON_SMALL = 0;
enum ICON_BIG = 1;
static if (_WIN32_WINNT >= 0x501) {
enum ICON_SMALL2 = 2;
}

enum HBITMAP
    HBMMENU_CALLBACK = cast(HBITMAP)-1,
    HBMMENU_SYSTEM = cast(HBITMAP)1,
    HBMMENU_MBAR_RESTORE = cast(HBITMAP)2,
    HBMMENU_MBAR_MINIMIZE = cast(HBITMAP)3,
    HBMMENU_MBAR_CLOSE = cast(HBITMAP)5,
    HBMMENU_MBAR_CLOSE_D = cast(HBITMAP)6,
    HBMMENU_MBAR_MINIMIZE_D = cast(HBITMAP)7,
    HBMMENU_POPUP_CLOSE = cast(HBITMAP)8,
    HBMMENU_POPUP_RESTORE = cast(HBITMAP)9,
    HBMMENU_POPUP_MAXIMIZE = cast(HBITMAP)10,
    HBMMENU_POPUP_MINIMIZE = cast(HBITMAP)11;

enum MOD_ALT = 1;
enum MOD_CONTROL = 2;
enum MOD_SHIFT = 4;
enum MOD_WIN = 8;
enum MOD_IGNORE_ALL_MODIFIER = 1024;
enum MOD_ON_KEYUP = 2048;
enum MOD_RIGHT = 16384;
enum MOD_LEFT = 32768;

enum LLKHF_EXTENDED = (KF_EXTENDED >> 8);
enum LLKHF_INJECTED = 0x00000010;
enum LLKHF_ALTDOWN = (KF_ALTDOWN >> 8);
enum LLKHF_UP = (KF_UP >> 8);

enum CURSOR_SHOWING = 0x00000001;
enum WS_ACTIVECAPTION = 0x00000001;
enum ENDSESSION_LOGOFF = 0x80000000;

enum GA_PARENT    = 1;
enum GA_ROOT      = 2;
enum GA_ROOTOWNER = 3;

enum {
    MAPVK_VK_TO_VSC,
    MAPVK_VSC_TO_VK,
    MAPVK_VK_TO_CHAR,
    MAPVK_VSC_TO_VK_EX,
    MAPVK_VK_TO_VSC_EX // = 4
}

enum {
    INPUT_MOUSE,
    INPUT_KEYBOARD,
    INPUT_HARDWARE // = 2
}

// Callbacks
// ---------
extern (Windows) nothrow {
    alias INT_PTR function(HWND, UINT, WPARAM, LPARAM)   DLGPROC;
    alias void function(HWND, UINT, UINT_PTR, DWORD)     TIMERPROC;
    alias BOOL function(HDC, LPARAM, int)                GRAYSTRINGPROC;
    alias LRESULT function(int, WPARAM, LPARAM)          HOOKPROC;
    alias BOOL function(HWND, LPCSTR, HANDLE)            PROPENUMPROCA;
    alias BOOL function(HWND, LPCWSTR, HANDLE)           PROPENUMPROCW;
    alias BOOL function(HWND, LPSTR, HANDLE, ULONG_PTR)  PROPENUMPROCEXA;
    alias BOOL function(HWND, LPWSTR, HANDLE, ULONG_PTR) PROPENUMPROCEXW;
    alias int function(LPSTR, int, int, int)             EDITWORDBREAKPROCA;
    alias int function(LPWSTR, int, int, int)            EDITWORDBREAKPROCW;
    alias LRESULT function(HWND, UINT, WPARAM, LPARAM)   WNDPROC;
    alias BOOL function(HDC, LPARAM, WPARAM, int, int)   DRAWSTATEPROC;
    alias BOOL function(HWND, LPARAM)                    WNDENUMPROC;
    alias BOOL function(HWND, LPARAM)                    ENUMWINDOWSPROC;
    alias void function(LPHELPINFO)                      MSGBOXCALLBACK;

    alias BOOL function(HMONITOR, HDC, LPRECT, LPARAM)   MONITORENUMPROC;
    alias BOOL function(LPSTR, LPARAM)                   NAMEENUMPROCA;
    alias BOOL function(LPWSTR, LPARAM)                  NAMEENUMPROCW;
    alias void function(HWND, UINT, ULONG_PTR, LRESULT)  SENDASYNCPROC;

    alias NAMEENUMPROCA DESKTOPENUMPROCA;
    alias NAMEENUMPROCW DESKTOPENUMPROCW;
    alias NAMEENUMPROCA WINSTAENUMPROCA;
    alias NAMEENUMPROCW WINSTAENUMPROCW;
}

mixin DECLARE_HANDLE!("HDWP");
mixin DECLARE_HANDLE!("HDEVNOTIFY");

struct MENUGETOBJECTINFO {
    DWORD dwFlags;
    UINT  uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
}
alias MENUGETOBJECTINFO* PMENUGETOBJECTINFO;

struct ACCEL {
    BYTE fVirt;
    WORD key;
    WORD cmd;
}
alias ACCEL* LPACCEL;

struct ACCESSTIMEOUT {
    UINT  cbSize = ACCESSTIMEOUT.sizeof;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
}
alias ACCESSTIMEOUT* LPACCESSTIMEOUT;

struct ANIMATIONINFO {
    UINT cbSize = ANIMATIONINFO.sizeof;
    int  iMinAnimate;
}
alias ANIMATIONINFO* LPANIMATIONINFO;

struct CREATESTRUCTA {
    LPVOID    lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
}
alias CREATESTRUCTA* LPCREATESTRUCTA;

struct CREATESTRUCTW {
    LPVOID    lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCWSTR   lpszName;
    LPCWSTR   lpszClass;
    DWORD     dwExStyle;
}
alias CREATESTRUCTW* LPCREATESTRUCTW;

struct CBT_CREATEWNDA {
    LPCREATESTRUCTA lpcs;
    HWND            hwndInsertAfter;
}
alias CBT_CREATEWNDA* LPCBT_CREATEWNDA;

struct CBT_CREATEWNDW {
    LPCREATESTRUCTW lpcs;
    HWND            hwndInsertAfter;
}
alias CBT_CREATEWNDW* LPCBT_CREATEWNDW;

struct CBTACTIVATESTRUCT {
    BOOL fMouse;
    HWND hWndActive;
}
alias CBTACTIVATESTRUCT* LPCBTACTIVATESTRUCT;

static if (_WIN32_WINNT >= 0x501) {

struct WTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;
}
alias WTSSESSION_NOTIFICATION* PWTSSESSION_NOTIFICATION;

}

struct CLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT   idFirstChild;
}
alias CLIENTCREATESTRUCT* LPCLIENTCREATESTRUCT;

struct COMPAREITEMSTRUCT {
    UINT  CtlType;
    UINT  CtlID;
    HWND  hwndItem;
    UINT  itemID1;
    ULONG_PTR itemData1;
    UINT  itemID2;
    ULONG_PTR itemData2;
    DWORD dwLocaleId;
}
alias COMPAREITEMSTRUCT* LPCOMPAREITEMSTRUCT;

struct COPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
    PVOID lpData;
}
alias COPYDATASTRUCT* PCOPYDATASTRUCT;

struct CURSORSHAPE {
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    BYTE Planes;
    BYTE BitsPixel;
}
alias CURSORSHAPE* LPCURSORSHAPE;

struct CWPRETSTRUCT {
    LRESULT lResult;
    LPARAM lParam;
    WPARAM wParam;
    DWORD message;
    HWND hwnd;
}

struct CWPSTRUCT {
    LPARAM lParam;
    WPARAM wParam;
    UINT message;
    HWND hwnd;
}
alias CWPSTRUCT* PCWPSTRUCT;

struct DEBUGHOOKINFO {
    DWORD idThread;
    DWORD idThreadInstaller;
    LPARAM lParam;
    WPARAM wParam;
    int code;
}
alias DEBUGHOOKINFO* PDEBUGHOOKINFO, LPDEBUGHOOKINFO;

struct DELETEITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    HWND hwndItem;
    ULONG_PTR itemData;
}
alias DELETEITEMSTRUCT* PDELETEITEMSTRUCT, LPDELETEITEMSTRUCT;

align(2):
struct DLGITEMTEMPLATE {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
}
alias DLGITEMTEMPLATE* LPDLGITEMTEMPLATE;

struct DLGTEMPLATE {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD  cdit;
    short x;
    short y;
    short cx;
    short cy;
}
alias DLGTEMPLATE*        LPDLGTEMPLATE, LPDLGTEMPLATEA, LPDLGTEMPLATEW;
alias const(DLGTEMPLATE)* LPCDLGTEMPLATE, LPCDLGTEMPLATEA, LPCDLGTEMPLATEW;

align:

struct DRAWITEMSTRUCT {
    UINT  CtlType;
    UINT  CtlID;
    UINT  itemID;
    UINT  itemAction;
    UINT  itemState;
    HWND  hwndItem;
    HDC   hDC;
    RECT  rcItem;
    ULONG_PTR itemData;
}
alias DRAWITEMSTRUCT* LPDRAWITEMSTRUCT, PDRAWITEMSTRUCT;

struct DRAWTEXTPARAMS {
    UINT cbSize = DRAWTEXTPARAMS.sizeof;
    int  iTabLength;
    int  iLeftMargin;
    int  iRightMargin;
    UINT uiLengthDrawn;
}
alias DRAWTEXTPARAMS* LPDRAWTEXTPARAMS;

struct PAINTSTRUCT {
    HDC      hdc;
    BOOL     fErase;
    RECT     rcPaint;
    BOOL     fRestore;
    BOOL     fIncUpdate;
    BYTE[32] rgbReserved;
}
alias PAINTSTRUCT* PPAINTSTRUCT, NPPAINTSTRUCT, LPPAINTSTRUCT;

struct MSG {
    HWND   hwnd;
    UINT   message;
    WPARAM wParam;
    LPARAM lParam;
    DWORD  time;
    POINT  pt;
}
alias MSG* NPMSG, LPMSG, PMSG;

struct ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
}
alias ICONINFO* PICONINFO;

struct NMHDR {
    HWND hwndFrom;
    UINT_PTR idFrom;
    UINT code;
}
alias NMHDR* LPNMHDR;

struct WNDCLASSA {
    UINT      style;
    WNDPROC   lpfnWndProc;
    int       cbClsExtra;
    int       cbWndExtra;
    HINSTANCE hInstance;
    HICON     hIcon;
    HCURSOR   hCursor;
    HBRUSH    hbrBackground;
    LPCSTR    lpszMenuName;
    LPCSTR    lpszClassName;
}
alias WNDCLASSA* NPWNDCLASSA, LPWNDCLASSA, PWNDCLASSA;

struct WNDCLASSW {
    UINT      style;
    WNDPROC   lpfnWndProc;
    int       cbClsExtra;
    int       cbWndExtra;
    HINSTANCE hInstance;
    HICON     hIcon;
    HCURSOR   hCursor;
    HBRUSH    hbrBackground;
    LPCWSTR   lpszMenuName;
    LPCWSTR   lpszClassName;
}
alias WNDCLASSW* NPWNDCLASSW, LPWNDCLASSW, PWNDCLASSW;

struct WNDCLASSEXA {
    UINT      cbSize = WNDCLASSEXA.sizeof;
    UINT      style;
    WNDPROC   lpfnWndProc;
    int       cbClsExtra;
    int       cbWndExtra;
    HINSTANCE hInstance;
    HICON     hIcon;
    HCURSOR   hCursor;
    HBRUSH    hbrBackground;
    LPCSTR    lpszMenuName;
    LPCSTR    lpszClassName;
    HICON     hIconSm;
}
alias WNDCLASSEXA* NPWNDCLASSEXA, LPWNDCLASSEXA, PWNDCLASSEXA;

struct WNDCLASSEXW {
    UINT      cbSize = WNDCLASSEXW.sizeof;
    UINT      style;
    WNDPROC   lpfnWndProc;
    int       cbClsExtra;
    int       cbWndExtra;
    HINSTANCE hInstance;
    HICON     hIcon;
    HCURSOR   hCursor;
    HBRUSH    hbrBackground;
    LPCWSTR   lpszMenuName;
    LPCWSTR   lpszClassName;
    HICON     hIconSm;
}
alias WNDCLASSEXW* LPWNDCLASSEXW, PWNDCLASSEXW;

struct MENUITEMINFOA {
    UINT      cbSize = MENUITEMINFOA.sizeof;
    UINT      fMask;
    UINT      fType;
    UINT      fState;
    UINT      wID;
    HMENU     hSubMenu;
    HBITMAP   hbmpChecked;
    HBITMAP   hbmpUnchecked;
    ULONG_PTR dwItemData;
    LPSTR     dwTypeData;
    UINT      cch;
    HBITMAP   hbmpItem;
}
alias MENUITEMINFOA*        LPMENUITEMINFOA;
alias const(MENUITEMINFOA)* LPCMENUITEMINFOA;

struct MENUITEMINFOW {
    UINT      cbSize = MENUITEMINFOW.sizeof;
    UINT      fMask;
    UINT      fType;
    UINT      fState;
    UINT      wID;
    HMENU     hSubMenu;
    HBITMAP   hbmpChecked;
    HBITMAP   hbmpUnchecked;
    ULONG_PTR dwItemData;
    LPWSTR    dwTypeData;
    UINT      cch;
    HBITMAP   hbmpItem;
}
alias MENUITEMINFOW*        LPMENUITEMINFOW;
alias const(MENUITEMINFOW)* LPCMENUITEMINFOW;

struct SCROLLINFO {
    UINT cbSize = this.sizeof;
    UINT fMask;
    int nMin;
    int nMax;
    UINT nPage;
    int nPos;
    int nTrackPos;
}
alias SCROLLINFO*        LPSCROLLINFO;
alias const(SCROLLINFO)* LPCSCROLLINFO;

struct WINDOWPLACEMENT {
    UINT length;
    UINT flags;
    UINT showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT rcNormalPosition;
}
alias WINDOWPLACEMENT* LPWINDOWPLACEMENT, PWINDOWPLACEMENT;

struct MENUITEMTEMPLATEHEADER {
    WORD versionNumber;
    WORD offset;
}

struct MENUITEMTEMPLATE {
    WORD mtOption;
    WORD mtID;
    WCHAR[1] mtString = 0;
}

alias void MENUTEMPLATE, MENUTEMPLATEA, MENUTEMPLATEW;

alias MENUTEMPLATE* LPMENUTEMPLATEA, LPMENUTEMPLATEW, LPMENUTEMPLATE;

struct HELPINFO {
    UINT cbSize = this.sizeof;
    int iContextType;
    int iCtrlId;
    HANDLE hItemHandle;
    DWORD_PTR dwContextId;
    POINT MousePos;
}
alias HELPINFO* LPHELPINFO;

struct MSGBOXPARAMSA {
    UINT cbSize = this.sizeof;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCSTR lpszText;
    LPCSTR lpszCaption;
    DWORD dwStyle;
    LPCSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
}
alias MSGBOXPARAMSA* PMSGBOXPARAMSA, LPMSGBOXPARAMSA;

struct MSGBOXPARAMSW {
    UINT cbSize = this.sizeof;
    HWND hwndOwner;
    HINSTANCE hInstance;
    LPCWSTR lpszText;
    LPCWSTR lpszCaption;
    DWORD dwStyle;
    LPCWSTR lpszIcon;
    DWORD_PTR dwContextHelpId;
    MSGBOXCALLBACK lpfnMsgBoxCallback;
    DWORD dwLanguageId;
}
alias MSGBOXPARAMSW* PMSGBOXPARAMSW, LPMSGBOXPARAMSW;

struct USEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
}

struct FILTERKEYS {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    DWORD iWaitMSec;
    DWORD iDelayMSec;
    DWORD iRepeatMSec;
    DWORD iBounceMSec;
}

struct HIGHCONTRASTA {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    LPSTR lpszDefaultScheme;
}
alias HIGHCONTRASTA* LPHIGHCONTRASTA;

struct HIGHCONTRASTW {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    LPWSTR lpszDefaultScheme;
}
alias HIGHCONTRASTW* LPHIGHCONTRASTW;

struct ICONMETRICSA {
    UINT cbSize = this.sizeof;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTA lfFont;
}
alias ICONMETRICSA* LPICONMETRICSA;

struct ICONMETRICSW {
    UINT cbSize = this.sizeof;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    LOGFONTW lfFont;
}
alias ICONMETRICSW* LPICONMETRICSW;

struct MINIMIZEDMETRICS {
    UINT cbSize = this.sizeof;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
}
alias MINIMIZEDMETRICS* LPMINIMIZEDMETRICS;

struct MOUSEKEYS {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
}
alias MOUSEKEYS* LPMOUSEKEYS;

struct NONCLIENTMETRICSA {
    UINT cbSize = this.sizeof;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
}
alias NONCLIENTMETRICSA* LPNONCLIENTMETRICSA;

struct NONCLIENTMETRICSW {
    UINT cbSize = this.sizeof;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
}
alias NONCLIENTMETRICSW* LPNONCLIENTMETRICSW;

struct SERIALKEYSA {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    LPSTR lpszActivePort;
    LPSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
}
alias SERIALKEYSA* LPSERIALKEYSA;

struct SERIALKEYSW {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    LPWSTR lpszActivePort;
    LPWSTR lpszPort;
    UINT iBaudRate;
    UINT iPortState;
    UINT iActive;
}
alias SERIALKEYSW* LPSERIALKEYSW;

struct SOUNDSENTRYA {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
}
alias SOUNDSENTRYA* LPSOUNDSENTRYA;

struct SOUNDSENTRYW {
    UINT cbSize = this.sizeof;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
}
alias SOUNDSENTRYW* LPSOUNDSENTRYW;

struct STICKYKEYS {
    DWORD cbSize = this.sizeof;
    DWORD dwFlags;
}
alias STICKYKEYS* LPSTICKYKEYS;

struct TOGGLEKEYS {
    DWORD cbSize = this.sizeof;
    DWORD dwFlags;
}

struct MOUSEHOOKSTRUCT {
    POINT pt;
    HWND hwnd;
    UINT wHitTestCode;
    ULONG_PTR dwExtraInfo;
}
alias MOUSEHOOKSTRUCT* LPMOUSEHOOKSTRUCT, PMOUSEHOOKSTRUCT;

struct TRACKMOUSEEVENT {
    DWORD cbSize = this.sizeof;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
}
alias TRACKMOUSEEVENT* LPTRACKMOUSEEVENT;

struct TPMPARAMS {
    UINT cbSize = this.sizeof;
    RECT rcExclude;
}
alias TPMPARAMS* LPTPMPARAMS;

struct EVENTMSG {
    UINT message;
    UINT paramL;
    UINT paramH;
    DWORD time;
    HWND hwnd;
}
alias EVENTMSG* PEVENTMSGMSG, LPEVENTMSGMSG, PEVENTMSG, LPEVENTMSG;

struct WINDOWPOS {
    HWND hwnd;
    HWND hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    UINT flags;
}
alias WINDOWPOS* PWINDOWPOS, LPWINDOWPOS;

struct NCCALCSIZE_PARAMS {
    RECT[3] rgrc;
    PWINDOWPOS lppos;
}
alias NCCALCSIZE_PARAMS* LPNCCALCSIZE_PARAMS;

struct MDICREATESTRUCTA {
    LPCSTR szClass;
    LPCSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;
}
alias MDICREATESTRUCTA* LPMDICREATESTRUCTA;

struct MDICREATESTRUCTW {
    LPCWSTR szClass;
    LPCWSTR szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;
}
alias MDICREATESTRUCTW* LPMDICREATESTRUCTW;

struct MINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
}
alias MINMAXINFO* PMINMAXINFO, LPMINMAXINFO;

struct MDINEXTMENU {
    HMENU hmenuIn;
    HMENU hmenuNext;
    HWND hwndNext;
}
alias MDINEXTMENU* PMDINEXTMENU, LPMDINEXTMENU;

struct MEASUREITEMSTRUCT {
    UINT CtlType;
    UINT CtlID;
    UINT itemID;
    UINT itemWidth;
    UINT itemHeight;
    ULONG_PTR itemData;
}
alias MEASUREITEMSTRUCT* PMEASUREITEMSTRUCT, LPMEASUREITEMSTRUCT;

struct DROPSTRUCT {
    HWND hwndSource;
    HWND hwndSink;
    DWORD wFmt;
    ULONG_PTR dwData;
    POINT ptDrop;
    DWORD dwControlData;
}
alias DROPSTRUCT* PDROPSTRUCT, LPDROPSTRUCT;

alias DWORD HELPPOLY;

struct MULTIKEYHELPA {
    DWORD mkSize;
    CHAR mkKeylist = 0;
    CHAR[1] szKeyphrase = 0;
}
alias MULTIKEYHELPA* PMULTIKEYHELPA, LPMULTIKEYHELPA;

struct MULTIKEYHELPW {
    DWORD mkSize;
    WCHAR mkKeylist = 0;
    WCHAR[1] szKeyphrase = 0;
}
alias MULTIKEYHELPW* PMULTIKEYHELPW, LPMULTIKEYHELPW;

struct HELPWININFOA {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    CHAR[2] rgchMember = 0;
}
alias HELPWININFOA* PHELPWININFOA, LPHELPWININFOA;

struct HELPWININFOW {
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    WCHAR[2] rgchMember = 0;
}
alias HELPWININFOW* PHELPWININFOW, LPHELPWININFOW;

struct STYLESTRUCT {
    DWORD styleOld;
    DWORD styleNew;
}
alias STYLESTRUCT* LPSTYLESTRUCT;

struct ALTTABINFO {
    DWORD cbSize = this.sizeof;
    int   cItems;
    int   cColumns;
    int   cRows;
    int   iColFocus;
    int   iRowFocus;
    int   cxItem;
    int   cyItem;
    POINT ptStart;
}
alias ALTTABINFO* PALTTABINFO, LPALTTABINFO;

struct COMBOBOXINFO {
    DWORD cbSize = this.sizeof;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
}
alias COMBOBOXINFO* PCOMBOBOXINFO, LPCOMBOBOXINFO;

struct CURSORINFO {
    DWORD cbSize = this.sizeof;
    DWORD flags;
    HCURSOR hCursor;
    POINT ptScreenPos;
}
alias CURSORINFO* PCURSORINFO, LPCURSORINFO;

struct MENUBARINFO {
    DWORD cbSize = this.sizeof;
    RECT  rcBar;
    HMENU hMenu;
    HWND  hwndMenu;
    byte bf_; // Simulated bitfield
//  BOOL  fBarFocused:1;
//  BOOL  fFocused:1;
    bool fBarFocused()       { return (bf_ & 1) == 1; }
    bool fFocused()          { return (bf_ & 2) == 2; }
    bool fBarFocused(bool b) { bf_ = cast(byte) ((bf_ & 0xFE) | b);           return b; }
    bool fFocused(bool b)    { bf_ = cast(byte) (b ? (bf_ | 2) : bf_ & 0xFD); return b; }
}
alias MENUBARINFO* PMENUBARINFO;

struct MENUINFO {
    DWORD cbSize = this.sizeof;
    DWORD fMask;
    DWORD dwStyle;
    UINT cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}
alias MENUINFO*        LPMENUINFO;
alias const(MENUINFO)* LPCMENUINFO;


enum CCHILDREN_SCROLLBAR = 5;

struct SCROLLBARINFO {
    DWORD cbSize = this.sizeof;
    RECT  rcScrollBar;
    int   dxyLineButton;
    int   xyThumbTop;
    int   xyThumbBottom;
    int   reserved;
    DWORD[CCHILDREN_SCROLLBAR+1] rgstate;
}
alias SCROLLBARINFO* PSCROLLBARINFO, LPSCROLLBARINFO;

enum CCHILDREN_TITLEBAR = 5;

struct WINDOWINFO {
    DWORD cbSize = WINDOWINFO.sizeof;
    RECT  rcWindow;
    RECT  rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT  cxWindowBorders;
    UINT  cyWindowBorders;
    ATOM  atomWindowType;
    WORD  wCreatorVersion;
}
alias WINDOWINFO* PWINDOWINFO, LPWINDOWINFO;

struct LASTINPUTINFO {
    UINT cbSize = this.sizeof;
    DWORD dwTime;
}
alias LASTINPUTINFO* PLASTINPUTINFO;

struct MONITORINFO {
    DWORD cbSize = this.sizeof;
    RECT rcMonitor;
    RECT rcWork;
    DWORD dwFlags;
}
alias MONITORINFO* LPMONITORINFO;

enum CCHDEVICENAME = 32;

struct MONITORINFOEXA {
    DWORD cbSize = MONITORINFOEXA.sizeof;
    RECT  rcMonitor;
    RECT  rcWork;
    DWORD dwFlags;
    CHAR[CCHDEVICENAME] szDevice = 0;
}
alias MONITORINFOEXA* LPMONITORINFOEXA;

struct MONITORINFOEXW {
    DWORD cbSize = MONITORINFOEXW.sizeof;
    RECT  rcMonitor;
    RECT  rcWork;
    DWORD dwFlags;
    WCHAR[CCHDEVICENAME] szDevice = 0;
}
alias MONITORINFOEXW* LPMONITORINFOEXW;

struct KBDLLHOOKSTRUCT {
    DWORD vkCode;
    DWORD scanCode;
    DWORD flags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
}
alias KBDLLHOOKSTRUCT* LPKBDLLHOOKSTRUCT, PKBDLLHOOKSTRUCT;

struct MSLLHOOKSTRUCT {
    POINT     pt;
    DWORD     mouseData;
    DWORD     flags;
    DWORD     time;
    ULONG_PTR dwExtraInfo;
}
alias MSLLHOOKSTRUCT* PMSLLHOOKSTRUCT;

struct MOUSEINPUT {
    LONG dx;
    LONG dy;
    DWORD mouseData;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
}
alias MOUSEINPUT* PMOUSEINPUT;

struct KEYBDINPUT {
    WORD wVk;
    WORD wScan;
    DWORD dwFlags;
    DWORD time;
    ULONG_PTR dwExtraInfo;
}
alias KEYBDINPUT* PKEYBDINPUT;

struct HARDWAREINPUT {
    DWORD uMsg;
    WORD wParamL;
    WORD wParamH;
}
alias HARDWAREINPUT* PHARDWAREINPUT;

struct INPUT {
    DWORD type;
    union {
        MOUSEINPUT mi;
        KEYBDINPUT ki;
        HARDWAREINPUT hi;
    }
}
alias INPUT* PINPUT, LPINPUT;

static if (_WIN32_WINNT >= 0x501) {
    align(4) struct BSMINFO {
        UINT  cbSize = this.sizeof;
        HDESK hdesk;
        HWND  hwnd;
align(4) LUID  luid;
    }
    alias BSMINFO* PBSMINFO;

    alias TypeDef!(HANDLE) HRAWINPUT;

    struct RAWINPUTHEADER {
        DWORD dwType;
        DWORD dwSize;
        HANDLE hDevice;
        WPARAM wParam;
    }
    alias RAWINPUTHEADER* PRAWINPUTHEADER;

    struct RAWMOUSE {
        USHORT usFlags;
        union {
            ULONG ulButtons;
            struct {
                USHORT usButtonFlags;
                USHORT usButtonData;
            }
        }
        ULONG ulRawButtons;
        LONG lLastX;
        LONG lLastY;
        ULONG ulExtraInformation;
    }
    alias RAWMOUSE* PRAWMOUSE, LPRAWMOUSE;

    struct RAWKEYBOARD {
        USHORT MakeCode;
        USHORT Flags;
        USHORT Reserved;
        USHORT VKey;
        UINT Message;
        ULONG ExtraInformation;
    }
    alias RAWKEYBOARD* PRAWKEYBOARD, LPRAWKEYBOARD;

    struct RAWHID {
        DWORD dwSizeHid;
        DWORD dwCount;
        BYTE bRawData;
    }
    alias RAWHID* PRAWHID, LPRAWHID;

    struct RAWINPUT {
        RAWINPUTHEADER header;
        union _data {
            RAWMOUSE    mouse;
            RAWKEYBOARD keyboard;
            RAWHID      hid;
        }
        _data data;
    }
    alias RAWINPUT* PRAWINPUT, LPRAWINPUT;

    struct RAWINPUTDEVICE {
        USHORT usUsagePage;
        USHORT usUsage;
        DWORD dwFlags;
        HWND hwndTarget;
    }
    alias RAWINPUTDEVICE*        PRAWINPUTDEVICE, LPRAWINPUTDEVICE;
    alias const(RAWINPUTDEVICE)* PCRAWINPUTDEVICE;

    struct RAWINPUTDEVICELIST {
        HANDLE hDevice;
        DWORD dwType;
    }
    alias RAWINPUTDEVICELIST* PRAWINPUTDEVICELIST;

    struct RID_DEVICE_INFO_MOUSE {
        DWORD dwId;
        DWORD dwNumberOfButtons;
        DWORD dwSampleRate;
        BOOL  fHasHorizontalWheel;
    }

    struct RID_DEVICE_INFO_KEYBOARD {
        DWORD dwType;
        DWORD dwSubType;
        DWORD dwKeyboardMode;
        DWORD dwNumberOfFunctionKeys;
        DWORD dwNumberOfIndicators;
        DWORD dwNumberOfKeysTotal;
    }

    struct RID_DEVICE_INFO_HID {
        DWORD dwVendorId;
        DWORD dwProductId;
        DWORD dwVersionNumber;
        USHORT usUsagePage;
        USHORT usUsage;
    }

    struct RID_DEVICE_INFO {
        DWORD cbSize = this.sizeof;
        DWORD dwType;
        union {
            RID_DEVICE_INFO_MOUSE mouse;
            RID_DEVICE_INFO_KEYBOARD keyboard;
            RID_DEVICE_INFO_HID hid;
        }
    }
}// (_WIN32_WINNT >= 0x501)

alias CharToOemA AnsiToOem;
alias OemToCharA OemToAnsi;
alias CharToOemBuffA AnsiToOemBuff;
alias OemToCharBuffA OemToAnsiBuff;
alias CharUpperA AnsiUpper;
alias CharUpperBuffA AnsiUpperBuff;
alias CharLowerA AnsiLower;
alias CharLowerBuffA AnsiLowerBuff;
alias CharNextA AnsiNext;
alias CharPrevA AnsiPrev;

alias MAKELONG MAKEWPARAM;
alias MAKELONG MAKELPARAM;
alias MAKELONG MAKELRESULT;

void POINTSTOPOINT()(out POINT p, LONG ps) {
    p.x = LOWORD(ps);
    p.y = HIWORD(ps);
}

POINTS POINTTOPOINTS()(in POINT p) {
    return MAKELONG(p.x, p.y);
}

extern (Windows) nothrow @nogc {
    HKL ActivateKeyboardLayout(HKL, UINT);
    BOOL AdjustWindowRect(LPRECT, DWORD, BOOL);
    BOOL AdjustWindowRectEx(LPRECT, DWORD, BOOL, DWORD);
    BOOL AnyPopup();
    BOOL AppendMenuA(HMENU, UINT, UINT_PTR, LPCSTR);
    BOOL AppendMenuW(HMENU, UINT, UINT_PTR, LPCWSTR);
    UINT ArrangeIconicWindows(HWND);
    BOOL AttachThreadInput(DWORD, DWORD, BOOL);
    HDWP BeginDeferWindowPos(int);
    HDC BeginPaint(HWND, LPPAINTSTRUCT);
    BOOL BringWindowToTop(HWND);
    BOOL CallMsgFilterA(LPMSG, INT);
    BOOL CallMsgFilterW(LPMSG, INT);
    LRESULT CallNextHookEx(HHOOK, int, WPARAM, LPARAM);
    LRESULT CallWindowProcA(WNDPROC, HWND, UINT, WPARAM, LPARAM);
    LRESULT CallWindowProcW(WNDPROC, HWND, UINT, WPARAM, LPARAM);
    WORD CascadeWindows(HWND, UINT, LPCRECT, UINT, const(HWND)*);
    BOOL ChangeClipboardChain(HWND, HWND);

    LONG ChangeDisplaySettingsA(PDEVMODEA, DWORD);
    LONG ChangeDisplaySettingsW(PDEVMODEW, DWORD);
    LONG ChangeDisplaySettingsExA(LPCSTR, LPDEVMODEA, HWND, DWORD, LPVOID);
    LONG ChangeDisplaySettingsExW(LPCWSTR, LPDEVMODEW, HWND, DWORD, LPVOID);

    BOOL ChangeMenuA(HMENU, UINT, LPCSTR, UINT, UINT);
    BOOL ChangeMenuW(HMENU, UINT, LPCWSTR, UINT, UINT);
    LPSTR CharLowerA(LPSTR);
    LPWSTR CharLowerW(LPWSTR);
    DWORD CharLowerBuffA(LPSTR, DWORD);
    DWORD CharLowerBuffW(LPWSTR, DWORD);
    LPSTR CharNextA(LPCSTR);
    LPWSTR CharNextW(LPCWSTR);
    LPSTR CharNextExA(WORD, LPCSTR, DWORD);
    LPWSTR CharNextExW(WORD, LPCWSTR, DWORD);
    LPSTR CharPrevA(LPCSTR, LPCSTR);
    LPWSTR CharPrevW(LPCWSTR, LPCWSTR);
    LPSTR CharPrevExA(WORD, LPCSTR, LPCSTR, DWORD);
    LPWSTR CharPrevExW(WORD, LPCWSTR, LPCWSTR, DWORD);
    BOOL CharToOemA(LPCSTR, LPSTR);
    BOOL CharToOemW(LPCWSTR, LPSTR);
    BOOL CharToOemBuffA(LPCSTR, LPSTR, DWORD);
    BOOL CharToOemBuffW(LPCWSTR, LPSTR, DWORD);
    LPSTR CharUpperA(LPSTR);
    LPWSTR CharUpperW(LPWSTR);
    DWORD CharUpperBuffA(LPSTR, DWORD);
    DWORD CharUpperBuffW(LPWSTR, DWORD);
    BOOL CheckDlgButton(HWND, int, UINT);
    DWORD CheckMenuItem(HMENU, UINT, UINT);
    BOOL CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);
    BOOL CheckRadioButton(HWND, int, int, int);
    HWND ChildWindowFromPoint(HWND, POINT);
    HWND ChildWindowFromPointEx(HWND, POINT, UINT);
    BOOL ClientToScreen(HWND, LPPOINT);
    BOOL ClipCursor(LPCRECT);
    BOOL CloseClipboard();
    BOOL CloseDesktop(HDESK);
    BOOL CloseWindow(HWND);
    BOOL CloseWindowStation(HWINSTA);
    int CopyAcceleratorTableA(HACCEL, LPACCEL, int);
    int CopyAcceleratorTableW(HACCEL, LPACCEL, int);

    HICON CopyIcon(HICON);
    HANDLE CopyImage(HANDLE, UINT, int, int, UINT);
    BOOL CopyRect(LPRECT, LPCRECT);
    int CountClipboardFormats();
    HACCEL CreateAcceleratorTableA(LPACCEL, int);
    HACCEL CreateAcceleratorTableW(LPACCEL, int);
    BOOL CreateCaret(HWND, HBITMAP, int, int);
    HCURSOR CreateCursor(HINSTANCE, int, int, int, int, PCVOID, PCVOID);

    HDESK CreateDesktopA(LPCSTR, LPCSTR, LPDEVMODEA, DWORD, ACCESS_MASK, LPSECURITY_ATTRIBUTES);
    HDESK CreateDesktopW(LPCWSTR, LPCWSTR, LPDEVMODEW, DWORD, ACCESS_MASK, LPSECURITY_ATTRIBUTES);

    HWND CreateDialogParamA(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
    HWND CreateDialogParamW(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM);
    HWND CreateDialogIndirectParamA(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
    HWND CreateDialogIndirectParamW(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);

    HICON CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const(BYTE)*, BYTE*);
    HICON CreateIconFromResource(PBYTE, DWORD, BOOL, DWORD);
    HICON CreateIconFromResourceEx(PBYTE, DWORD, BOOL, DWORD, int, int, UINT);
    HICON CreateIconIndirect(PICONINFO);
    HWND CreateMDIWindowA(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HINSTANCE, LPARAM);
    HWND CreateMDIWindowW(LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HINSTANCE, LPARAM);
    HMENU CreateMenu();
    HMENU CreatePopupMenu();

    HWND CreateWindowExA(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);
    HWND CreateWindowExW(DWORD, LPCWSTR, LPCWSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, LPVOID);

    HWINSTA CreateWindowStationA(LPSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES);
    HWINSTA CreateWindowStationW(LPWSTR, DWORD, DWORD, LPSECURITY_ATTRIBUTES);
    LRESULT DefDlgProcA(HWND, UINT, WPARAM, LPARAM);
    LRESULT DefDlgProcW(HWND, UINT, WPARAM, LPARAM);
    HDWP DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
    LRESULT DefFrameProcA(HWND, HWND, UINT, WPARAM, LPARAM);
    LRESULT DefFrameProcW(HWND, HWND, UINT, WPARAM, LPARAM);

    LRESULT DefMDIChildProcA(HWND, UINT, WPARAM, LPARAM);
    LRESULT DefMDIChildProcW(HWND, UINT, WPARAM, LPARAM);
    LRESULT DefWindowProcA(HWND, UINT, WPARAM, LPARAM);
    LRESULT DefWindowProcW(HWND, UINT, WPARAM, LPARAM);
    BOOL DeleteMenu(HMENU, UINT, UINT);
    BOOL DeregisterShellHookWindow(HWND);
    BOOL DestroyAcceleratorTable(HACCEL);
    BOOL DestroyCaret();
    BOOL DestroyCursor(HCURSOR);
    BOOL DestroyIcon(HICON);
    BOOL DestroyMenu(HMENU);
    BOOL DestroyWindow(HWND);

    INT_PTR DialogBoxParamA(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
    INT_PTR DialogBoxParamW(HINSTANCE, LPCWSTR, HWND, DLGPROC, LPARAM);
    INT_PTR DialogBoxIndirectParamA(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);
    INT_PTR DialogBoxIndirectParamW(HINSTANCE, LPCDLGTEMPLATE, HWND, DLGPROC, LPARAM);

} // extern (Windows)

nothrow @nogc {
    HCURSOR CopyCursor(HCURSOR c) {
        return cast(HCURSOR)CopyIcon(cast(HICON)c);
    }

    HWND CreateDialogA(HINSTANCE h, LPCSTR n, HWND w, DLGPROC f) {
        return CreateDialogParamA(h, n, w, f, 0);
    }

    HWND CreateDialogW(HINSTANCE h, LPCWSTR n, HWND w, DLGPROC f) {
        return CreateDialogParamW(h, n, w, f, 0);
    }

    HWND CreateDialogIndirectA(HINSTANCE h, LPCDLGTEMPLATE t, HWND w, DLGPROC f) {
        return CreateDialogIndirectParamA(h, t, w, f, 0);
    }

    HWND CreateDialogIndirectW(HINSTANCE h, LPCDLGTEMPLATE t, HWND w, DLGPROC f) {
        return CreateDialogIndirectParamW(h, t, w, f, 0);
    }

    HWND CreateWindowA(LPCSTR a, LPCSTR b, DWORD c, int d, int e, int f, int g, HWND h, HMENU i, HINSTANCE j, LPVOID k) {
        return CreateWindowExA(0, a, b, c, d, e, f, g, h, i, j, k);
    }

    HWND CreateWindowW(LPCWSTR a, LPCWSTR b, DWORD c, int d, int e, int f, int g, HWND h, HMENU i, HINSTANCE j, LPVOID k) {
        return CreateWindowExW(0, a, b, c, d, e, f, g, h, i, j, k);
    }

    INT_PTR DialogBoxA(HINSTANCE i, LPCSTR t, HWND p, DLGPROC f) {
        return DialogBoxParamA(i, t, p, f, 0);
    }

    INT_PTR DialogBoxW(HINSTANCE i, LPCWSTR t, HWND p, DLGPROC f) {
        return DialogBoxParamW(i, t, p, f, 0);
    }

    INT_PTR DialogBoxIndirectA(HINSTANCE i, LPCDLGTEMPLATE t, HWND p, DLGPROC f) {
        return DialogBoxIndirectParamA(i, t, p, f, 0);
    }

    INT_PTR DialogBoxIndirectW(HINSTANCE i, LPCDLGTEMPLATE t, HWND p, DLGPROC f) {
        return DialogBoxIndirectParamW(i, t, p, f, 0);
    }

    BOOL ExitWindows(UINT r, DWORD c) {
        return ExitWindowsEx(EWX_LOGOFF, 0);
    }
}
alias GetWindow GetNextWindow;

extern (Windows) nothrow @nogc:
LONG DispatchMessageA(const(MSG)*);
LONG DispatchMessageW(const(MSG)*);
int DlgDirListA(HWND, LPSTR, int, int, UINT);
int DlgDirListW(HWND, LPWSTR, int, int, UINT);
int DlgDirListComboBoxA(HWND, LPSTR, int, int, UINT);
int DlgDirListComboBoxW(HWND, LPWSTR, int, int, UINT);
BOOL DlgDirSelectComboBoxExA(HWND, LPSTR, int, int);
BOOL DlgDirSelectComboBoxExW(HWND, LPWSTR, int, int);
BOOL DlgDirSelectExA(HWND, LPSTR, int, int);
BOOL DlgDirSelectExW(HWND, LPWSTR, int, int);
BOOL DragDetect(HWND, POINT);
DWORD DragObject(HWND, HWND, UINT, ULONG_PTR, HCURSOR);
BOOL DrawAnimatedRects(HWND, int, LPCRECT, LPCRECT);
BOOL DrawCaption(HWND, HDC, LPCRECT, UINT);
BOOL DrawEdge(HDC, LPRECT, UINT, UINT);
BOOL DrawFocusRect(HDC, LPCRECT);
BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT);
BOOL DrawIcon(HDC, int, int, HICON);
BOOL DrawIconEx(HDC, int, int, HICON, int, int, UINT, HBRUSH, UINT);
BOOL DrawMenuBar(HWND);
BOOL DrawStateA(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
BOOL DrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
int DrawTextA(HDC, LPCSTR, int, LPRECT, UINT);
int DrawTextW(HDC, LPCWSTR, int, LPRECT, UINT);
int DrawTextExA(HDC, LPSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
int DrawTextExW(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
BOOL EmptyClipboard();
BOOL EnableMenuItem(HMENU, UINT, UINT);
BOOL EnableScrollBar(HWND, UINT, UINT);
BOOL EnableWindow(HWND, BOOL);
BOOL EndDeferWindowPos(HDWP);
BOOL EndDialog(HWND, INT_PTR);
BOOL EndMenu();
BOOL EndPaint(HWND, const(PAINTSTRUCT)*);
BOOL EnumChildWindows(HWND, ENUMWINDOWSPROC, LPARAM);
UINT EnumClipboardFormats(UINT);
BOOL EnumDesktopsA(HWINSTA, DESKTOPENUMPROCA, LPARAM);
BOOL EnumDesktopsW(HWINSTA, DESKTOPENUMPROCW, LPARAM);
BOOL EnumDesktopWindows(HDESK, ENUMWINDOWSPROC, LPARAM);
BOOL EnumDisplaySettingsA(LPCSTR, DWORD, PDEVMODEA);
BOOL EnumDisplaySettingsW(LPCWSTR, DWORD, PDEVMODEW);

BOOL EnumDisplayDevicesA(LPCSTR, DWORD, PDISPLAY_DEVICEA, DWORD);
BOOL EnumDisplayDevicesW(LPCWSTR, DWORD, PDISPLAY_DEVICEW, DWORD);

int EnumPropsA(HWND, PROPENUMPROCA);
int EnumPropsW(HWND, PROPENUMPROCW);
int EnumPropsExA(HWND, PROPENUMPROCEXA, LPARAM);
int EnumPropsExW(HWND, PROPENUMPROCEXW, LPARAM);

BOOL EnumThreadWindows(DWORD, WNDENUMPROC, LPARAM);
BOOL EnumWindows(WNDENUMPROC, LPARAM);
BOOL EnumWindowStationsA(WINSTAENUMPROCA, LPARAM);
BOOL EnumWindowStationsW(WINSTAENUMPROCW, LPARAM);
BOOL EqualRect(LPCRECT, LPCRECT);

BOOL ExitWindowsEx(UINT, DWORD);
HWND FindWindowA(LPCSTR, LPCSTR);
HWND FindWindowExA(HWND, HWND, LPCSTR, LPCSTR);
HWND FindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR);
HWND FindWindowW(LPCWSTR, LPCWSTR);
BOOL FlashWindow(HWND, BOOL);

int FrameRect(HDC, LPCRECT, HBRUSH);
BOOL FrameRgn(HDC, HRGN, HBRUSH, int, int);
HWND GetActiveWindow();
HWND GetAncestor(HWND, UINT);
SHORT GetAsyncKeyState(int);
HWND GetCapture();
UINT GetCaretBlinkTime();
BOOL GetCaretPos(LPPOINT);
BOOL GetClassInfoA(HINSTANCE, LPCSTR, LPWNDCLASSA);
BOOL GetClassInfoExA(HINSTANCE, LPCSTR, LPWNDCLASSEXA);
BOOL GetClassInfoW(HINSTANCE, LPCWSTR, LPWNDCLASSW);
BOOL GetClassInfoExW(HINSTANCE, LPCWSTR, LPWNDCLASSEXW);
DWORD GetClassLongA(HWND, int);
DWORD GetClassLongW(HWND, int);
int GetClassNameA(HWND, LPSTR, int);
int GetClassNameW(HWND, LPWSTR, int);
WORD GetClassWord(HWND, int);
BOOL GetClientRect(HWND, LPRECT);
HANDLE GetClipboardData(UINT);
int GetClipboardFormatNameA(UINT, LPSTR, int);
int GetClipboardFormatNameW(UINT, LPWSTR, int);
HWND GetClipboardOwner();
HWND GetClipboardViewer();
BOOL GetClipCursor(LPRECT);
BOOL GetCursorPos(LPPOINT);
HDC GetDC(HWND);
HDC GetDCEx(HWND, HRGN, DWORD);
HWND GetDesktopWindow();
int GetDialogBaseUnits();
int GetDlgCtrlID(HWND);
HWND GetDlgItem(HWND, int);
UINT GetDlgItemInt(HWND, int, PBOOL, BOOL);
UINT GetDlgItemTextA(HWND, int, LPSTR, int);
UINT GetDlgItemTextW(HWND, int, LPWSTR, int);
UINT GetDoubleClickTime();
HWND GetFocus();
HWND GetForegroundWindow();

BOOL GetIconInfo(HICON, PICONINFO);
BOOL GetInputState();
UINT GetKBCodePage();
HKL GetKeyboardLayout(DWORD);
UINT GetKeyboardLayoutList(int, HKL*);
BOOL GetKeyboardLayoutNameA(LPSTR);
BOOL GetKeyboardLayoutNameW(LPWSTR);
BOOL GetKeyboardState(PBYTE);
int GetKeyboardType(int);
int GetKeyNameTextA(LONG, LPSTR, int);
int GetKeyNameTextW(LONG, LPWSTR, int);
SHORT GetKeyState(int);
HWND GetLastActivePopup(HWND);
HMENU GetMenu(HWND);
LONG GetMenuCheckMarkDimensions();
DWORD GetMenuContextHelpId(HMENU);
UINT GetMenuDefaultItem(HMENU, UINT, UINT);
int GetMenuItemCount(HMENU);
UINT GetMenuItemID(HMENU, int);
BOOL GetMenuItemInfoA(HMENU, UINT, BOOL, LPMENUITEMINFOA);
BOOL GetMenuItemInfoW(HMENU, UINT, BOOL, LPMENUITEMINFOW);
BOOL GetMenuItemRect(HWND, HMENU, UINT, LPRECT);
UINT GetMenuState(HMENU, UINT, UINT);
int GetMenuStringA(HMENU, UINT, LPSTR, int, UINT);
int GetMenuStringW(HMENU, UINT, LPWSTR, int, UINT);
BOOL GetMessageA(LPMSG, HWND, UINT, UINT);
BOOL GetMessageW(LPMSG, HWND, UINT, UINT);
LONG GetMessageExtraInfo();
DWORD GetMessagePos();
LONG GetMessageTime();

HWND GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND GetNextDlgTabItem(HWND, HWND, BOOL);

HWND GetOpenClipboardWindow();
HWND GetParent(HWND);
int GetPriorityClipboardFormat(UINT*, int);
HANDLE GetPropA(HWND, LPCSTR);
HANDLE GetPropW(HWND, LPCWSTR);

DWORD GetQueueStatus(UINT);
BOOL GetScrollInfo(HWND, int, LPSCROLLINFO);
int GetScrollPos(HWND, int);
BOOL GetScrollRange(HWND, int, LPINT, LPINT);

HMENU GetSubMenu(HMENU, int);
DWORD GetSysColor(int);
HBRUSH GetSysColorBrush(int);

HMENU GetSystemMenu(HWND, BOOL);
int GetSystemMetrics(int);
DWORD GetTabbedTextExtentA(HDC, LPCSTR, int, int, LPINT);
DWORD GetTabbedTextExtentW(HDC, LPCWSTR, int, int, LPINT);
LONG GetWindowLongA(HWND, int);
LONG GetWindowLongW(HWND, int);

HDESK GetThreadDesktop(DWORD);
HWND GetTopWindow(HWND);
BOOL GetUpdateRect(HWND, LPRECT, BOOL);
int GetUpdateRgn(HWND, HRGN, BOOL);
BOOL GetUserObjectInformationA(HANDLE, int, PVOID, DWORD, PDWORD);
BOOL GetUserObjectInformationW(HANDLE, int, PVOID, DWORD, PDWORD);
BOOL GetUserObjectSecurity(HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR, DWORD, PDWORD);
HWND GetWindow(HWND, UINT);
DWORD GetWindowContextHelpId(HWND);
HDC GetWindowDC(HWND);
BOOL GetWindowPlacement(HWND, WINDOWPLACEMENT*);
BOOL GetWindowRect(HWND, LPRECT);
int GetWindowRgn(HWND, HRGN);
int GetWindowTextA(HWND, LPSTR, int);
int GetWindowTextLengthA(HWND);
int GetWindowTextLengthW(HWND);
int GetWindowTextW(HWND, LPWSTR, int);
WORD GetWindowWord(HWND, int);
BOOL GetAltTabInfoA(HWND, int, PALTTABINFO, LPSTR, UINT);
BOOL GetAltTabInfoW(HWND, int, PALTTABINFO, LPWSTR, UINT);
BOOL GetComboBoxInfo(HWND, PCOMBOBOXINFO);
BOOL GetCursorInfo(PCURSORINFO);
BOOL GetLastInputInfo(PLASTINPUTINFO);
DWORD GetListBoxInfo(HWND);
BOOL GetMenuBarInfo(HWND, LONG, LONG, PMENUBARINFO);
BOOL GetMenuInfo(HMENU, LPMENUINFO);
BOOL GetScrollBarInfo(HWND, LONG, PSCROLLBARINFO);
BOOL GetTitleBarInfo(HWND, PTITLEBARINFO);
BOOL GetWindowInfo(HWND, PWINDOWINFO);
UINT GetWindowModuleFileNameA(HWND, LPSTR, UINT);
UINT GetWindowModuleFileNameW(HWND, LPWSTR, UINT);
BOOL GrayStringA(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);
BOOL GrayStringW(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);
BOOL HideCaret(HWND);
BOOL HiliteMenuItem(HWND, HMENU, UINT, UINT);
BOOL InflateRect(LPRECT, int, int);
BOOL InSendMessage();
BOOL InsertMenuA(HMENU, UINT, UINT, UINT_PTR, LPCSTR);
BOOL InsertMenuW(HMENU, UINT, UINT, UINT_PTR, LPCWSTR);
BOOL InsertMenuItemA(HMENU, UINT, BOOL, LPCMENUITEMINFOA);
BOOL InsertMenuItemW(HMENU, UINT, BOOL, LPCMENUITEMINFOW);
INT InternalGetWindowText(HWND, LPWSTR, INT);
BOOL IntersectRect(LPRECT, LPCRECT, LPCRECT);
BOOL InvalidateRect(HWND, LPCRECT, BOOL);
BOOL InvalidateRgn(HWND, HRGN, BOOL);
BOOL InvertRect(HDC, LPCRECT);
BOOL IsCharAlphaA(CHAR ch);
BOOL IsCharAlphaNumericA(CHAR);
BOOL IsCharAlphaNumericW(WCHAR);
BOOL IsCharAlphaW(WCHAR);
BOOL IsCharLowerA(CHAR);
BOOL IsCharLowerW(WCHAR);
BOOL IsCharUpperA(CHAR);
BOOL IsCharUpperW(WCHAR);
BOOL IsChild(HWND, HWND);
BOOL IsClipboardFormatAvailable(UINT);
BOOL IsDialogMessageA(HWND, LPMSG);
BOOL IsDialogMessageW(HWND, LPMSG);
UINT IsDlgButtonChecked(HWND, int);
BOOL IsIconic(HWND);
BOOL IsMenu(HMENU);
BOOL IsRectEmpty(LPCRECT);
BOOL IsWindow(HWND);
BOOL IsWindowEnabled(HWND);
BOOL IsWindowUnicode(HWND);
BOOL IsWindowVisible(HWND);
BOOL IsZoomed(HWND);
void keybd_event(BYTE, BYTE, DWORD, ULONG_PTR);
BOOL KillTimer(HWND, UINT_PTR);
HACCEL LoadAcceleratorsA(HINSTANCE, LPCSTR);
HACCEL LoadAcceleratorsW(HINSTANCE, LPCWSTR);
HBITMAP LoadBitmapA(HINSTANCE, LPCSTR);
HBITMAP LoadBitmapW(HINSTANCE, LPCWSTR);
HCURSOR LoadCursorA(HINSTANCE, LPCSTR);
HCURSOR LoadCursorFromFileA(LPCSTR);
HCURSOR LoadCursorFromFileW(LPCWSTR);
HCURSOR LoadCursorW(HINSTANCE, LPCWSTR);
HICON LoadIconA(HINSTANCE, LPCSTR);
HICON LoadIconW(HINSTANCE, LPCWSTR);
HANDLE LoadImageA(HINSTANCE, LPCSTR, UINT, int, int, UINT);
HANDLE LoadImageW(HINSTANCE, LPCWSTR, UINT, int, int, UINT);
HKL LoadKeyboardLayoutA(LPCSTR, UINT);
HKL LoadKeyboardLayoutW(LPCWSTR, UINT);
HMENU LoadMenuA(HINSTANCE, LPCSTR);
HMENU LoadMenuIndirectA(const(MENUTEMPLATE)*);
HMENU LoadMenuIndirectW(const(MENUTEMPLATE)*);
HMENU LoadMenuW(HINSTANCE, LPCWSTR);
int LoadStringA(HINSTANCE, UINT, LPSTR, int);
int LoadStringW(HINSTANCE, UINT, LPWSTR, int);
BOOL LockWindowUpdate(HWND);
int LookupIconIdFromDirectory(PBYTE, BOOL);
int LookupIconIdFromDirectoryEx(PBYTE, BOOL, int, int, UINT);
BOOL MapDialogRect(HWND, LPRECT);
UINT MapVirtualKeyA(UINT, UINT);
UINT MapVirtualKeyExA(UINT, UINT, HKL);
UINT MapVirtualKeyExW(UINT, UINT, HKL);
UINT MapVirtualKeyW(UINT, UINT);
int MapWindowPoints(HWND, HWND, LPPOINT, UINT);
int MenuItemFromPoint(HWND, HMENU, POINT);
BOOL MessageBeep(UINT);
int MessageBoxA(HWND, LPCSTR, LPCSTR, UINT);
int MessageBoxW(HWND, LPCWSTR, LPCWSTR, UINT);
int MessageBoxExA(HWND, LPCSTR, LPCSTR, UINT, WORD);
int MessageBoxExW(HWND, LPCWSTR, LPCWSTR, UINT, WORD);
int MessageBoxIndirectA(const(MSGBOXPARAMSA)*);
int MessageBoxIndirectW(const(MSGBOXPARAMSW)*);
BOOL ModifyMenuA(HMENU, UINT, UINT, UINT_PTR, LPCSTR);
BOOL ModifyMenuW(HMENU, UINT, UINT, UINT_PTR, LPCWSTR);
void mouse_event(DWORD, DWORD, DWORD, DWORD, ULONG_PTR);
BOOL MoveWindow(HWND, int, int, int, int, BOOL);
DWORD MsgWaitForMultipleObjects(DWORD, const(HANDLE)*, BOOL, DWORD, DWORD);
DWORD MsgWaitForMultipleObjectsEx(DWORD, const(HANDLE)*, DWORD, DWORD, DWORD);
DWORD OemKeyScan(WORD);
BOOL OemToCharA(LPCSTR, LPSTR);
BOOL OemToCharBuffA(LPCSTR, LPSTR, DWORD);
BOOL OemToCharBuffW(LPCSTR, LPWSTR, DWORD);
BOOL OemToCharW(LPCSTR, LPWSTR);
BOOL OffsetRect(LPRECT, int, int);
BOOL OpenClipboard(HWND);
HDESK OpenDesktopA(LPSTR, DWORD, BOOL, DWORD);
HDESK OpenDesktopW(LPWSTR, DWORD, BOOL, DWORD);
BOOL OpenIcon(HWND);
HDESK OpenInputDesktop(DWORD, BOOL, DWORD);
HWINSTA OpenWindowStationA(LPSTR, BOOL, DWORD);
HWINSTA OpenWindowStationW(LPWSTR, BOOL, DWORD);
BOOL PaintDesktop(HDC);
BOOL PeekMessageA(LPMSG, HWND, UINT, UINT, UINT);
BOOL PeekMessageW(LPMSG, HWND, UINT, UINT, UINT);
BOOL PostMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL PostMessageW(HWND, UINT, WPARAM, LPARAM);
void PostQuitMessage(int);
BOOL PostThreadMessageA(DWORD, UINT, WPARAM, LPARAM);
BOOL PostThreadMessageW(DWORD, UINT, WPARAM, LPARAM);
BOOL PtInRect(LPCRECT, POINT);
HWND RealChildWindowFromPoint(HWND, POINT);
UINT RealGetWindowClassA(HWND, LPSTR, UINT);
UINT RealGetWindowClassW(HWND, LPWSTR, UINT);
BOOL RedrawWindow(HWND, LPCRECT, HRGN, UINT);
ATOM RegisterClassA(const(WNDCLASSA)*);
ATOM RegisterClassW(const(WNDCLASSW)*);
ATOM RegisterClassExA(const(WNDCLASSEXA)*);
ATOM RegisterClassExW(const(WNDCLASSEXW)*);
UINT RegisterClipboardFormatA(LPCSTR);
UINT RegisterClipboardFormatW(LPCWSTR);
BOOL RegisterHotKey(HWND, int, UINT, UINT);
UINT RegisterWindowMessageA(LPCSTR);
UINT RegisterWindowMessageW(LPCWSTR);
BOOL ReleaseCapture();
int ReleaseDC(HWND, HDC);
BOOL RemoveMenu(HMENU, UINT, UINT);
HANDLE RemovePropA(HWND, LPCSTR);
HANDLE RemovePropW(HWND, LPCWSTR);
BOOL ReplyMessage(LRESULT);
BOOL ScreenToClient(HWND, LPPOINT);
BOOL ScrollDC(HDC, int, int, LPCRECT, LPCRECT, HRGN, LPRECT);
BOOL ScrollWindow(HWND, int, int, LPCRECT, LPCRECT);
int ScrollWindowEx(HWND, int, int, LPCRECT, LPCRECT, HRGN, LPRECT, UINT);
LONG SendDlgItemMessageA(HWND, int, UINT, WPARAM, LPARAM);
LONG SendDlgItemMessageW(HWND, int, UINT, WPARAM, LPARAM);
LRESULT SendMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL SendMessageCallbackA(HWND, UINT, WPARAM, LPARAM, SENDASYNCPROC, ULONG_PTR);
BOOL SendMessageCallbackW(HWND, UINT, WPARAM, LPARAM, SENDASYNCPROC, ULONG_PTR);
LRESULT SendMessageTimeoutA(HWND, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD);
LRESULT SendMessageTimeoutW(HWND, UINT, WPARAM, LPARAM, UINT, UINT, PDWORD);
LRESULT SendMessageW(HWND, UINT, WPARAM, LPARAM);
BOOL SendNotifyMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL SendNotifyMessageW(HWND, UINT, WPARAM, LPARAM);
HWND SetActiveWindow(HWND);
HWND SetCapture(HWND hWnd);
BOOL SetCaretBlinkTime(UINT);
BOOL SetCaretPos(int, int);
DWORD SetClassLongA(HWND, int, LONG);
DWORD SetClassLongW(HWND, int, LONG);
WORD SetClassWord(HWND, int, WORD);
HANDLE SetClipboardData(UINT, HANDLE);
HWND SetClipboardViewer(HWND);
HCURSOR SetCursor(HCURSOR);
BOOL SetCursorPos(int, int);
void SetDebugErrorLevel(DWORD);
BOOL SetDlgItemInt(HWND, int, UINT, BOOL);
BOOL SetDlgItemTextA(HWND, int, LPCSTR);
BOOL SetDlgItemTextW(HWND, int, LPCWSTR);
BOOL SetDoubleClickTime(UINT);
HWND SetFocus(HWND);
BOOL SetForegroundWindow(HWND);
BOOL SetKeyboardState(PBYTE);
BOOL SetMenu(HWND, HMENU);
BOOL SetMenuContextHelpId(HMENU, DWORD);
BOOL SetMenuDefaultItem(HMENU, UINT, UINT);
BOOL SetMenuInfo(HMENU, LPCMENUINFO);
BOOL SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
BOOL SetMenuItemInfoA(HMENU, UINT, BOOL, LPCMENUITEMINFOA);
BOOL SetMenuItemInfoW(HMENU, UINT, BOOL, LPCMENUITEMINFOW);
LPARAM SetMessageExtraInfo(LPARAM);
BOOL SetMessageQueue(int);
HWND SetParent(HWND, HWND);
BOOL SetProcessWindowStation(HWINSTA);
BOOL SetPropA(HWND, LPCSTR, HANDLE);
BOOL SetPropW(HWND, LPCWSTR, HANDLE);
BOOL SetRect(LPRECT, int, int, int, int);
BOOL SetRectEmpty(LPRECT);
int SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);
int SetScrollPos(HWND, int, int, BOOL);
BOOL SetScrollRange(HWND, int, int, int, BOOL);
BOOL SetSysColors(int, const(INT)*, const(COLORREF)*);
BOOL SetSystemCursor(HCURSOR, DWORD);
BOOL SetThreadDesktop(HDESK);
UINT_PTR SetTimer(HWND, UINT_PTR, UINT, TIMERPROC);
BOOL SetUserObjectInformationA(HANDLE, int, PVOID, DWORD);
BOOL SetUserObjectInformationW(HANDLE, int, PVOID, DWORD);
BOOL SetUserObjectSecurity(HANDLE, PSECURITY_INFORMATION, PSECURITY_DESCRIPTOR);
BOOL SetWindowContextHelpId(HWND, DWORD);
LONG SetWindowLongA(HWND, int, LONG);
LONG SetWindowLongW(HWND, int, LONG);
BOOL SetWindowPlacement(HWND hWnd, const(WINDOWPLACEMENT)*);
BOOL SetWindowPos(HWND, HWND, int, int, int, int, UINT);
int SetWindowRgn(HWND, HRGN, BOOL);
HHOOK SetWindowsHookA(int, HOOKPROC);
HHOOK SetWindowsHookW(int, HOOKPROC);
HHOOK SetWindowsHookExA(int, HOOKPROC, HINSTANCE, DWORD);
HHOOK SetWindowsHookExW(int, HOOKPROC, HINSTANCE, DWORD);
BOOL SetWindowTextA(HWND, LPCSTR);
BOOL SetWindowTextW(HWND, LPCWSTR);
WORD SetWindowWord(HWND, int, WORD);
BOOL ShowCaret(HWND);
int ShowCursor(BOOL);
BOOL ShowOwnedPopups(HWND, BOOL);
BOOL ShowScrollBar(HWND, int, BOOL);
BOOL ShowWindow(HWND, int);
BOOL ShowWindowAsync(HWND, int);
BOOL SubtractRect(LPRECT, LPCRECT, LPCRECT);
BOOL SwapMouseButton(BOOL);
BOOL SwitchDesktop(HDESK);
BOOL SystemParametersInfoA(UINT, UINT, PVOID, UINT);
BOOL SystemParametersInfoW(UINT, UINT, PVOID, UINT);
LONG TabbedTextOutA(HDC, int, int, LPCSTR, int, int, LPINT, int);
LONG TabbedTextOutW(HDC, int, int, LPCWSTR, int, int, LPINT, int);
WORD TileWindows(HWND, UINT, LPCRECT, UINT, const(HWND)*);
int ToAscii(UINT, UINT, PBYTE, LPWORD, UINT);
int ToAsciiEx(UINT, UINT, PBYTE, LPWORD, UINT, HKL);
int ToUnicode(UINT, UINT, PBYTE, LPWSTR, int, UINT);
int ToUnicodeEx(UINT, UINT, PBYTE, LPWSTR, int, UINT, HKL);
BOOL TrackMouseEvent(LPTRACKMOUSEEVENT);
BOOL TrackPopupMenu(HMENU, UINT, int, int, int, HWND, LPCRECT);
BOOL TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);
int TranslateAcceleratorA(HWND, HACCEL, LPMSG);
int TranslateAcceleratorW(HWND, HACCEL, LPMSG);
BOOL TranslateMDISysAccel(HWND, LPMSG);
BOOL TranslateMessage(const(MSG)*);
BOOL UnhookWindowsHook(int, HOOKPROC);
BOOL UnhookWindowsHookEx(HHOOK);
BOOL UnionRect(LPRECT, LPCRECT, LPCRECT);
BOOL UnloadKeyboardLayout(HKL);
BOOL UnregisterClassA(LPCSTR, HINSTANCE);
BOOL UnregisterClassW(LPCWSTR, HINSTANCE);
BOOL UnregisterHotKey(HWND, int);
BOOL UpdateWindow(HWND);
BOOL ValidateRect(HWND, LPCRECT);
BOOL ValidateRgn(HWND, HRGN);
SHORT VkKeyScanA(CHAR);
SHORT VkKeyScanExA(CHAR, HKL);
SHORT VkKeyScanExW(WCHAR, HKL);
SHORT VkKeyScanW(WCHAR);
DWORD WaitForInputIdle(HANDLE, DWORD);
BOOL WaitMessage();
HWND WindowFromDC(HDC hDC);
HWND WindowFromPoint(POINT);
UINT WinExec(LPCSTR, UINT);
BOOL WinHelpA(HWND, LPCSTR, UINT, ULONG_PTR);
BOOL WinHelpW(HWND, LPCWSTR, UINT, ULONG_PTR);

extern (C) {
    int wsprintfA(LPSTR, LPCSTR, ...);
    int wsprintfW(LPWSTR, LPCWSTR, ...);
}


// These shouldn't be necessary for D.
alias TypeDef!(char*) va_list_;
int wvsprintfA(LPSTR, LPCSTR, va_list_ arglist);
int wvsprintfW(LPWSTR, LPCWSTR, va_list_ arglist);

enum : DWORD {
    MONITOR_DEFAULTTONULL,
    MONITOR_DEFAULTTOPRIMARY,
    MONITOR_DEFAULTTONEAREST // = 2
}
enum MONITORINFOF_PRIMARY = 1;

enum EDS_RAWMODE = 0x00000002;

enum {
    ISMEX_NOSEND   = 0,
    ISMEX_SEND     = 1,
    ISMEX_NOTIFY   = 2,
    ISMEX_CALLBACK = 4,
    ISMEX_REPLIED  = 8
}

struct TITLEBARINFO {
    DWORD cbSize = TITLEBARINFO.sizeof;
    RECT  rcTitleBar;
    DWORD[CCHILDREN_TITLEBAR+1] rgstate;
}
alias TITLEBARINFO* PTITLEBARINFO, LPTITLEBARINFO;

static if (_WIN32_WINNT >= 0x501) { // *** correct?
    struct FLASHWINFO {
        UINT  cbSize = this.sizeof;
        HWND  hwnd;
        DWORD dwFlags;
        UINT  uCount;
        DWORD dwTimeout;
    }
    alias FLASHWINFO* PFLASHWINFO;
}

enum DWORD ASFW_ANY = -1;
enum : UINT {
    LSFW_LOCK = 1,
    LSFW_UNLOCK
}
enum {
    GMMP_USE_DISPLAY_POINTS = 1,
    GMMP_USE_HIGH_RESOLUTION_POINTS
}

struct MOUSEMOVEPOINT {
    int x;
    int y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
}
alias MOUSEMOVEPOINT* PMOUSEMOVEPOINT, LPMOUSEMOVEPOINT;

enum {
    MIM_MAXHEIGHT       =  1,
    MIM_BACKGROUND      =  2,
    MIM_HELPID          =  4,
    MIM_MENUDATA        =  8,
    MIM_STYLE           = 16,
    MIM_APPLYTOSUBMENUS = 0x80000000L
}

enum {
    MNS_NOCHECK     = 0x80000000,
    MNS_MODELESS    = 0x40000000,
    MNS_DRAGDROP    = 0x20000000,
    MNS_AUTODISMISS = 0x10000000,
    MNS_NOTIFYBYPOS = 0x08000000,
    MNS_CHECKORBMP  = 0x04000000
}

enum {
    PM_QS_INPUT       = (QS_INPUT << 16),
    PM_QS_POSTMESSAGE = ((QS_POSTMESSAGE | QS_HOTKEY | QS_TIMER) << 16),
    PM_QS_PAINT       = (QS_PAINT << 16),
    PM_QS_SENDMESSAGE = (QS_SENDMESSAGE << 16)
}
/*
#define WM_GETOBJECT 0x003D
#define WM_CHANGEUISTATE 0x0127
#define WM_UPDATEUISTATE 0x0128
#define WM_QUERYUISTATE 0x0129
#define WM_UNINITMENUPOPUP 0x0125
#define WM_MENURBUTTONUP 290
#define WM_MENUCOMMAND 0x0126
#define WM_MENUGETOBJECT 0x0124
#define WM_MENUDRAG 0x0123
#define WM_APPCOMMAND 0x0319
#define WM_NCXBUTTONDOWN 171
#define WM_NCXBUTTONUP 172
#define WM_NCXBUTTONDBLCLK 173
#define WM_NCMOUSEHOVER 0x02A0
#define WM_NCMOUSELEAVE 0x02A2*/

enum {
    FLASHW_STOP      = 0,
    FLASHW_CAPTION   = 0x01,
    FLASHW_TRAY      = 0x02,
    FLASHW_ALL       = 0x03,
    FLASHW_TIMER     = 0x04,
    FLASHW_TIMERNOFG = 0x0C
}

enum CHILDID_SELF = 0;

enum {
    OBJID_WINDOW   = 0x00000000,
    OBJID_SOUND    = 0xFFFFFFF5,
    OBJID_ALERT    = 0xFFFFFFF6,
    OBJID_CURSOR   = 0xFFFFFFF7,
    OBJID_CARET    = 0xFFFFFFF8,
    OBJID_SIZEGRIP = 0xFFFFFFF9,
    OBJID_HSCROLL  = 0xFFFFFFFA,
    OBJID_VSCROLL  = 0xFFFFFFFB,
    OBJID_CLIENT   = 0xFFFFFFFC,
    OBJID_MENU     = 0xFFFFFFFD,
    OBJID_TITLEBAR = 0xFFFFFFFE,
    OBJID_SYSMENU  = 0xFFFFFFFF
}

enum {
    GUI_CARETBLINKING  = 0x0001,
    GUI_INMOVESIZE     = 0x0002,
    GUI_INMENUMODE     = 0x0004,
    GUI_SYSTEMMENUMODE = 0x0008,
    GUI_POPUPMENUMODE  = 0x0010
}
static if (_WIN32_WINNT >= 0x501) {
    enum GUI_16BITTASK = 0x0020;
}

enum {
    WINEVENT_OUTOFCONTEXT   = 0x00,
    WINEVENT_SKIPOWNTHREAD  = 0x01,
    WINEVENT_SKIPOWNPROCESS = 0x02,
    WINEVENT_INCONTEXT      = 0x04
}

enum {
    AW_HOR_POSITIVE = 0x00000001,
    AW_HOR_NEGATIVE = 0x00000002,
    AW_VER_POSITIVE = 0x00000004,
    AW_VER_NEGATIVE = 0x00000008,
    AW_CENTER       = 0x00000010,
    AW_HIDE         = 0x00010000,
    AW_ACTIVATE     = 0x00020000,
    AW_SLIDE        = 0x00040000,
    AW_BLEND        = 0x00080000
}

enum {
    DEVICE_NOTIFY_WINDOW_HANDLE  = 0x00000000,
    DEVICE_NOTIFY_SERVICE_HANDLE = 0x00000001
}

static if (_WIN32_WINNT >= 0x501) {
    enum DEVICE_NOTIFY_ALL_INTERFACE_CLASSES = 0x00000004;
}

enum : DWORD {
    EVENT_MIN                          = 0x00000001,
    EVENT_SYSTEM_SOUND                 = 0x00000001,
    EVENT_SYSTEM_ALERT,
    EVENT_SYSTEM_FOREGROUND,
    EVENT_SYSTEM_MENUSTART,
    EVENT_SYSTEM_MENUEND,
    EVENT_SYSTEM_MENUPOPUPSTART,
    EVENT_SYSTEM_MENUPOPUPEND,
    EVENT_SYSTEM_CAPTURESTART,
    EVENT_SYSTEM_CAPTUREEND,
    EVENT_SYSTEM_MOVESIZESTART,
    EVENT_SYSTEM_MOVESIZEEND,
    EVENT_SYSTEM_CONTEXTHELPSTART,
    EVENT_SYSTEM_CONTEXTHELPEND,
    EVENT_SYSTEM_DRAGDROPSTART,
    EVENT_SYSTEM_DRAGDROPEND,
    EVENT_SYSTEM_DIALOGSTART,
    EVENT_SYSTEM_DIALOGEND,
    EVENT_SYSTEM_SCROLLINGSTART,
    EVENT_SYSTEM_SCROLLINGEND,
    EVENT_SYSTEM_SWITCHSTART,
    EVENT_SYSTEM_SWITCHEND,
    EVENT_SYSTEM_MINIMIZESTART,
    EVENT_SYSTEM_MINIMIZEEND,       // = 0x00000017
    EVENT_OBJECT_CREATE                = 0x00008000,
    EVENT_OBJECT_DESTROY,
    EVENT_OBJECT_SHOW,
    EVENT_OBJECT_HIDE,
    EVENT_OBJECT_REORDER,
    EVENT_OBJECT_FOCUS,
    EVENT_OBJECT_SELECTION,
    EVENT_OBJECT_SELECTIONADD,
    EVENT_OBJECT_SELECTIONREMOVE,
    EVENT_OBJECT_SELECTIONWITHIN,
    EVENT_OBJECT_STATECHANGE,
    EVENT_OBJECT_LOCATIONCHANGE,
    EVENT_OBJECT_NAMECHANGE,
    EVENT_OBJECT_DESCRIPTIONCHANGE,
    EVENT_OBJECT_VALUECHANGE,
    EVENT_OBJECT_PARENTCHANGE,
    EVENT_OBJECT_HELPCHANGE,
    EVENT_OBJECT_DEFACTIONCHANGE,
    EVENT_OBJECT_ACCELERATORCHANGE, // = 0x00008012
    EVENT_MAX                          = 0x7FFFFFFF
}

static if (_WIN32_WINNT >= 0x501) {
    enum : DWORD {
        EVENT_CONSOLE_CARET                = 0x00004000,
        EVENT_CONSOLE_UPDATE_REGION,
        EVENT_CONSOLE_UPDATE_SIMPLE,
        EVENT_CONSOLE_UPDATE_SCROLL,
        EVENT_CONSOLE_LAYOUT,
        EVENT_CONSOLE_START_APPLICATION,
        EVENT_CONSOLE_END_APPLICATION,  // = 0x00004007
    }

    enum : LONG {
        CONSOLE_CARET_SELECTION  = 1,
        CONSOLE_CARET_VISIBLE // = 2
    }
    enum LONG CONSOLE_APPLICATION_16BIT = 1;
}

enum {
    LWA_COLORKEY = 1,
    LWA_ALPHA
}
enum {
    ULW_COLORKEY = 1,
    ULW_ALPHA    = 2,
    ULW_OPAQUE   = 4
}
enum {
    GR_GDIOBJECTS,
    GR_USEROBJECTS
}

enum {
    XBUTTON1 = 1,
    XBUTTON2
}

struct GUITHREADINFO {
    DWORD cbSize = this.sizeof;
    DWORD flags;
    HWND  hwndActive;
    HWND  hwndFocus;
    HWND  hwndCapture;
    HWND  hwndMenuOwner;
    HWND  hwndMoveSize;
    HWND  hwndCaret;
    RECT  rcCaret;
}
alias GUITHREADINFO* PGUITHREADINFO, LPGUITHREADINFO;
extern (Windows) {
    alias void function(HWINEVENTHOOK, DWORD, HWND, LONG, LONG, DWORD, DWORD) WINEVENTPROC;
}
// *** line 4680 of MinGW 4.0
int BroadcastSystemMessageA(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
int BroadcastSystemMessageW(DWORD, LPDWORD, UINT, WPARAM, LPARAM);

UINT SendInput(UINT, LPINPUT, int);
BOOL EnumDisplayMonitors(HDC, LPCRECT, MONITORENUMPROC, LPARAM);
BOOL GetMonitorInfoA(HMONITOR, LPMONITORINFO);
extern(D) BOOL GetMonitorInfoA(HMONITOR m, LPMONITORINFOEXA mi) { return GetMonitorInfoA(m, cast(LPMONITORINFO)mi); }
BOOL GetMonitorInfoW(HMONITOR, LPMONITORINFO);
extern(D) BOOL GetMonitorInfoW(HMONITOR m, LPMONITORINFOEXW mi) { return GetMonitorInfoW(m, cast(LPMONITORINFO)mi); }
HMONITOR MonitorFromPoint(POINT, DWORD);
HMONITOR MonitorFromRect(LPCRECT, DWORD);
HMONITOR MonitorFromWindow(HWND, DWORD);
BOOL AllowSetForegroundWindow(DWORD);
BOOL AnimateWindow(HWND, DWORD, DWORD);
BOOL EndTask(HWND, BOOL, BOOL);
BOOL EnumDisplaySettingsExA(LPCSTR, DWORD, LPDEVMODEA, DWORD);
BOOL EnumDisplaySettingsExW(LPCWSTR, DWORD, LPDEVMODEW, DWORD);
DWORD GetClipboardSequenceNumber();
DWORD GetGuiResources(HANDLE, DWORD);
BOOL GetGUIThreadInfo(DWORD, LPGUITHREADINFO);

int GetMouseMovePointsEx(UINT, LPMOUSEMOVEPOINT, LPMOUSEMOVEPOINT, int, DWORD);
BOOL GetProcessDefaultLayout(DWORD*);
HWND GetShellWindow();
BOOL IsHungAppWindow(HWND);
DWORD InSendMessageEx(LPVOID);
BOOL LockSetForegroundWindow(UINT);
BOOL LockWorkStation();
void NotifyWinEvent(DWORD, HWND, LONG, LONG);
HDEVNOTIFY RegisterDeviceNotificationA(HANDLE, LPVOID, DWORD);
HDEVNOTIFY RegisterDeviceNotificationW(HANDLE, LPVOID, DWORD);
BOOL SetProcessDefaultLayout(DWORD);
HWINEVENTHOOK SetWinEventHook(UINT, UINT, HMODULE, WINEVENTPROC, DWORD, DWORD, UINT);
void SwitchToThisWindow(HWND, BOOL);
BOOL SetLayeredWindowAttributes(HWND, COLORREF, BYTE, DWORD);
BOOL UpdateLayeredWindow(HWND, HDC, POINT*, SIZE*, HDC, POINT*, COLORREF, BLENDFUNCTION*, DWORD);
BOOL UserHandleGrantAccess(HANDLE, HANDLE, BOOL);
BOOL UnhookWinEvent(HWINEVENTHOOK);
BOOL UnregisterDeviceNotification(HANDLE);

static if (_WIN32_WINNT >= 0x501) {
    int BroadcastSystemMessageExA(DWORD, LPDWORD, UINT, WPARAM, LPARAM, PBSMINFO);
    int BroadcastSystemMessageExW(DWORD, LPDWORD, UINT, WPARAM, LPARAM, PBSMINFO);
    LRESULT DefRawInputProc(PRAWINPUT*, INT, UINT);
    BOOL FlashWindowEx(PFLASHWINFO);
    BOOL GetLayeredWindowAttributes(HWND, COLORREF*, BYTE*, DWORD*);
    UINT GetRawInputBuffer(PRAWINPUT, PUINT, UINT);
    UINT GetRawInputData(HRAWINPUT, UINT, LPVOID, PUINT, UINT);
    UINT GetRawInputDeviceInfoA(HANDLE, UINT, LPVOID, PUINT);
    UINT GetRawInputDeviceInfoW(HANDLE, UINT, LPVOID, PUINT);
    UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST, PUINT, UINT);
    UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE, PUINT, UINT);
    BOOL IsGUIThread(BOOL);
    BOOL IsWinEventHookInstalled(DWORD);
    BOOL PrintWindow(HWND, HDC, UINT);
    BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE, UINT, UINT);
}

version (Win64) {
    ULONG_PTR GetClassLongPtrA(HWND, int);
    ULONG_PTR GetClassLongPtrW(HWND, int);
    ULONG_PTR SetClassLongPtrA(HWND, int, LONG_PTR);
    ULONG_PTR SetClassLongPtrW(HWND, int, LONG_PTR);
    LONG_PTR GetWindowLongPtrA(HWND, int);
    LONG_PTR GetWindowLongPtrW(HWND, int);
    LONG_PTR SetWindowLongPtrA(HWND, int, LONG_PTR);
    LONG_PTR SetWindowLongPtrW(HWND, int, LONG_PTR);
} else {
    alias GetClassLongA GetClassLongPtrA;
    alias GetClassLongW GetClassLongPtrW;
    alias SetClassLongA SetClassLongPtrA;
    alias SetClassLongW SetClassLongPtrW;
    alias GetWindowLongA GetWindowLongPtrA;
    alias GetWindowLongW GetWindowLongPtrW;
    alias SetWindowLongA SetWindowLongPtrA;
    alias SetWindowLongW SetWindowLongPtrW;
}


// -----
// Aliases for Unicode or Ansi
version (Unicode) {
    alias EDITWORDBREAKPROCW EDITWORDBREAKPROC;
    alias PROPENUMPROCW PROPENUMPROC;
    alias PROPENUMPROCEXW PROPENUMPROCEX;
    alias DESKTOPENUMPROCW DESKTOPENUMPROC;
    alias WINSTAENUMPROCW WINSTAENUMPROC;
    alias MAKEINTRESOURCEW MAKEINTRESOURCE;

    alias WNDCLASSW WNDCLASS;
    alias WNDCLASSEXW WNDCLASSEX;
    alias MENUITEMINFOW MENUITEMINFO;
    alias LPCMENUITEMINFOW LPCMENUITEMINFO;
    alias MSGBOXPARAMSW MSGBOXPARAMS;
    alias HIGHCONTRASTW HIGHCONTRAST;
    alias SERIALKEYSW SERIALKEYS;
    alias SOUNDSENTRYW SOUNDSENTRY;
    alias CREATESTRUCTW CREATESTRUCT;
    alias CBT_CREATEWNDW CBT_CREATEWND;
    alias MDICREATESTRUCTW MDICREATESTRUCT;
    alias MULTIKEYHELPW MULTIKEYHELP;
    alias MONITORINFOEXW MONITORINFOEX;
    alias ICONMETRICSW ICONMETRICS;
    alias NONCLIENTMETRICSW NONCLIENTMETRICS;

    alias AppendMenuW AppendMenu;
    alias BroadcastSystemMessageW BroadcastSystemMessage;
    static if (_WIN32_WINNT >= 0x501) {
        alias BroadcastSystemMessageExW BroadcastSystemMessageEx;
    }
    alias CallMsgFilterW CallMsgFilter;
    alias CallWindowProcW CallWindowProc;
    alias ChangeMenuW ChangeMenu;
    alias CharLowerW CharLower;
    alias CharLowerBuffW CharLowerBuff;
    alias CharNextW CharNext;
    alias CharNextExW CharNextEx;
    alias CharPrevW CharPrev;
    alias CharPrevExW CharPrevEx;
    alias CharToOemW CharToOem;
    alias CharToOemBuffW CharToOemBuff;
    alias CharUpperW CharUpper;
    alias CharUpperBuffW CharUpperBuff;
    alias CopyAcceleratorTableW CopyAcceleratorTable;
    alias CreateAcceleratorTableW CreateAcceleratorTable;
    alias CreateDialogW CreateDialog;
    alias CreateDialogIndirectW CreateDialogIndirect;
    alias CreateDialogIndirectParamW CreateDialogIndirectParam;
    alias CreateDialogParamW CreateDialogParam;
    alias CreateMDIWindowW CreateMDIWindow;
    alias CreateWindowW CreateWindow;
    alias CreateWindowExW CreateWindowEx;
    alias CreateWindowStationW CreateWindowStation;
    alias DefDlgProcW DefDlgProc;
    alias DefFrameProcW DefFrameProc;
    alias DefMDIChildProcW DefMDIChildProc;
    alias DefWindowProcW DefWindowProc;
    alias DialogBoxW DialogBox;
    alias DialogBoxIndirectW DialogBoxIndirect;
    alias DialogBoxIndirectParamW DialogBoxIndirectParam;
    alias DialogBoxParamW DialogBoxParam;
    alias DispatchMessageW DispatchMessage;
    alias DlgDirListW DlgDirList;
    alias DlgDirListComboBoxW DlgDirListComboBox;
    alias DlgDirSelectComboBoxExW DlgDirSelectComboBoxEx;
    alias DlgDirSelectExW DlgDirSelectEx;
    alias DrawStateW DrawState;
    alias DrawTextW DrawText;
    alias DrawTextExW DrawTextEx;
    alias EnumDesktopsW EnumDesktops;
    alias EnumPropsW EnumProps;
    alias EnumPropsExW EnumPropsEx;
    alias EnumWindowStationsW EnumWindowStations;
    alias FindWindowW FindWindow;
    alias FindWindowExW FindWindowEx;
    alias GetClassInfoW GetClassInfo;
    alias GetClassInfoExW GetClassInfoEx;
    alias GetClassLongW GetClassLong;
    alias GetClassLongPtrW GetClassLongPtr;
    alias GetClassNameW GetClassName;
    alias GetClipboardFormatNameW GetClipboardFormatName;
    alias GetDlgItemTextW GetDlgItemText;
    alias GetKeyboardLayoutNameW GetKeyboardLayoutName;
    alias GetKeyNameTextW GetKeyNameText;
    alias GetMenuItemInfoW GetMenuItemInfo;
    alias GetMenuStringW GetMenuString;
    alias GetMessageW GetMessage;
    alias GetMonitorInfoW GetMonitorInfo;
    alias GetPropW GetProp;
    static if (_WIN32_WINNT >= 0x501) {
        alias GetRawInputDeviceInfoW GetRawInputDeviceInfo;
    }
    alias GetTabbedTextExtentW GetTabbedTextExtent;
    alias GetUserObjectInformationW GetUserObjectInformation;
    alias GetWindowLongW GetWindowLong;
    alias GetWindowLongPtrW GetWindowLongPtr;
    alias GetWindowTextW GetWindowText;
    alias GetWindowTextLengthW GetWindowTextLength;
    alias GetAltTabInfoW GetAltTabInfo;
    alias GetWindowModuleFileNameW GetWindowModuleFileName;
    alias GrayStringW GrayString;
    alias InsertMenuW InsertMenu;
    alias InsertMenuItemW InsertMenuItem;
    alias IsCharAlphaW IsCharAlpha;
    alias IsCharAlphaNumericW IsCharAlphaNumeric;
    alias IsCharLowerW IsCharLower;
    alias IsCharUpperW IsCharUpper;
    alias IsDialogMessageW IsDialogMessage;
    alias LoadAcceleratorsW LoadAccelerators;
    alias LoadBitmapW LoadBitmap;
    alias LoadCursorW LoadCursor;
    alias LoadCursorFromFileW LoadCursorFromFile;
    alias LoadIconW LoadIcon;
    alias LoadImageW LoadImage;
    alias LoadKeyboardLayoutW LoadKeyboardLayout;
    alias LoadMenuW LoadMenu;
    alias LoadMenuIndirectW LoadMenuIndirect;
    alias LoadStringW LoadString;
    alias MapVirtualKeyW MapVirtualKey;
    alias MapVirtualKeyExW MapVirtualKeyEx;
    alias MessageBoxW MessageBox;
    alias MessageBoxExW MessageBoxEx;
    alias MessageBoxIndirectW MessageBoxIndirect;
    alias ModifyMenuW ModifyMenu;
    alias OemToCharW OemToChar;
    alias OemToCharBuffW OemToCharBuff;
    alias OpenDesktopW OpenDesktop;
    alias OpenWindowStationW OpenWindowStation;
    alias PeekMessageW PeekMessage;
    alias PostMessageW PostMessage;
    alias PostThreadMessageW PostThreadMessage;
    alias RealGetWindowClassW RealGetWindowClass;
    alias RegisterClassW RegisterClass;
    alias RegisterClassExW RegisterClassEx;
    alias RegisterClipboardFormatW RegisterClipboardFormat;
    alias RegisterDeviceNotificationW RegisterDeviceNotification;
    alias RegisterWindowMessageW RegisterWindowMessage;
    alias RemovePropW RemoveProp;
    alias SendDlgItemMessageW SendDlgItemMessage;
    alias SendMessageW SendMessage;
    alias SendMessageCallbackW SendMessageCallback;
    alias SendMessageTimeoutW SendMessageTimeout;
    alias SendNotifyMessageW SendNotifyMessage;
    alias SetClassLongW SetClassLong;
    alias SetClassLongPtrW SetClassLongPtr;
    alias SetDlgItemTextW SetDlgItemText;
    alias SetMenuItemInfoW SetMenuItemInfo;
    alias SetPropW SetProp;
    alias SetUserObjectInformationW SetUserObjectInformation;
    alias SetWindowLongW SetWindowLong;
    alias SetWindowLongPtrW SetWindowLongPtr;
    alias SetWindowsHookW SetWindowsHook;
    alias SetWindowsHookExW SetWindowsHookEx;
    alias SetWindowTextW SetWindowText;
    alias SystemParametersInfoW SystemParametersInfo;
    alias TabbedTextOutW TabbedTextOut;
    alias TranslateAcceleratorW TranslateAccelerator;
    alias UnregisterClassW UnregisterClass;
    alias VkKeyScanW VkKeyScan;
    alias VkKeyScanExW VkKeyScanEx;
    alias WinHelpW WinHelp;
    alias wsprintfW wsprintf;
    alias wvsprintfW wvsprintf;

    alias ChangeDisplaySettingsW ChangeDisplaySettings;
    alias ChangeDisplaySettingsExW ChangeDisplaySettingsEx;
    alias CreateDesktopW CreateDesktop;
    alias EnumDisplaySettingsW EnumDisplaySettings;
    alias EnumDisplaySettingsExW EnumDisplaySettingsEx;
    alias EnumDisplayDevicesW EnumDisplayDevices;

} else { // ANSI

    alias EDITWORDBREAKPROCA EDITWORDBREAKPROC;
    alias PROPENUMPROCA PROPENUMPROC;
    alias PROPENUMPROCEXA PROPENUMPROCEX;
    alias DESKTOPENUMPROCA DESKTOPENUMPROC;
    alias WINSTAENUMPROCA WINSTAENUMPROC;
    alias MAKEINTRESOURCEA MAKEINTRESOURCE;

    alias WNDCLASSA WNDCLASS;
    alias WNDCLASSEXA WNDCLASSEX;
    alias MENUITEMINFOA MENUITEMINFO;
    alias LPCMENUITEMINFOA LPCMENUITEMINFO;
    alias MSGBOXPARAMSA MSGBOXPARAMS;
    alias HIGHCONTRASTA HIGHCONTRAST;
    alias SERIALKEYSA SERIALKEYS;
    alias SOUNDSENTRYA SOUNDSENTRY;
    alias CREATESTRUCTA CREATESTRUCT;
    alias CBT_CREATEWNDA CBT_CREATEWND;
    alias MDICREATESTRUCTA MDICREATESTRUCT;
    alias MULTIKEYHELPA MULTIKEYHELP;
    alias MONITORINFOEXA MONITORINFOEX;
    alias ICONMETRICSA ICONMETRICS;
    alias NONCLIENTMETRICSA NONCLIENTMETRICS;

    alias AppendMenuA AppendMenu;
    alias BroadcastSystemMessageA BroadcastSystemMessage;
    static if (_WIN32_WINNT >= 0x501) {
        alias BroadcastSystemMessageExA BroadcastSystemMessageEx;
    }
    alias CallMsgFilterA CallMsgFilter;
    alias CallWindowProcA CallWindowProc;
    alias ChangeMenuA ChangeMenu;
    alias CharLowerA CharLower;
    alias CharLowerBuffA CharLowerBuff;
    alias CharNextA CharNext;
    alias CharNextExA CharNextEx;
    alias CharPrevA CharPrev;
    alias CharPrevExA CharPrevEx;
    alias CharToOemA CharToOem;
    alias CharToOemBuffA CharToOemBuff;
    alias CharUpperA CharUpper;
    alias CharUpperBuffA CharUpperBuff;
    alias CopyAcceleratorTableA CopyAcceleratorTable;
    alias CreateAcceleratorTableA CreateAcceleratorTable;
    alias CreateDialogA CreateDialog;
    alias CreateDialogIndirectA CreateDialogIndirect;
    alias CreateDialogIndirectParamA CreateDialogIndirectParam;
    alias CreateDialogParamA CreateDialogParam;
    alias CreateMDIWindowA CreateMDIWindow;
    alias CreateWindowA CreateWindow;
    alias CreateWindowExA CreateWindowEx;
    alias CreateWindowStationA CreateWindowStation;
    alias DefDlgProcA DefDlgProc;
    alias DefFrameProcA DefFrameProc;
    alias DefMDIChildProcA DefMDIChildProc;
    alias DefWindowProcA DefWindowProc;
    alias DialogBoxA DialogBox;
    alias DialogBoxIndirectA DialogBoxIndirect;
    alias DialogBoxIndirectParamA DialogBoxIndirectParam;
    alias DialogBoxParamA DialogBoxParam;
    alias DispatchMessageA DispatchMessage;
    alias DlgDirListA DlgDirList;
    alias DlgDirListComboBoxA DlgDirListComboBox;
    alias DlgDirSelectComboBoxExA DlgDirSelectComboBoxEx;
    alias DlgDirSelectExA DlgDirSelectEx;
    alias DrawStateA DrawState;
    alias DrawTextA DrawText;
    alias DrawTextExA DrawTextEx;
    alias EnumDesktopsA EnumDesktops;
    alias EnumPropsA EnumProps;
    alias EnumPropsExA EnumPropsEx;
    alias EnumWindowStationsA EnumWindowStations;
    alias FindWindowA FindWindow;
    alias FindWindowExA FindWindowEx;
    alias GetClassInfoA GetClassInfo;
    alias GetClassInfoExA GetClassInfoEx;
    alias GetClassLongA GetClassLong;
    alias GetClassLongPtrA GetClassLongPtr;
    alias GetClassNameA GetClassName;
    alias GetClipboardFormatNameA GetClipboardFormatName;
    alias GetDlgItemTextA GetDlgItemText;
    alias GetKeyboardLayoutNameA GetKeyboardLayoutName;
    alias GetKeyNameTextA GetKeyNameText;
    alias GetMenuItemInfoA GetMenuItemInfo;
    alias GetMenuStringA GetMenuString;
    alias GetMessageA GetMessage;
    alias GetMonitorInfoA GetMonitorInfo;
    alias GetPropA GetProp;
    static if (_WIN32_WINNT >= 0x501) {
        alias GetRawInputDeviceInfoA GetRawInputDeviceInfo;
    }
    alias GetTabbedTextExtentA GetTabbedTextExtent;
    alias GetUserObjectInformationA GetUserObjectInformation;
    alias GetWindowLongA GetWindowLong;
    alias GetWindowLongPtrA GetWindowLongPtr;
    alias GetWindowTextA GetWindowText;
    alias GetWindowTextLengthA GetWindowTextLength;
    alias GetAltTabInfoA GetAltTabInfo;
    alias GetWindowModuleFileNameA GetWindowModuleFileName;
    alias GrayStringA GrayString;
    alias InsertMenuA InsertMenu;
    alias InsertMenuItemA InsertMenuItem;
    alias IsCharAlphaA IsCharAlpha;
    alias IsCharAlphaNumericA IsCharAlphaNumeric;
    alias IsCharLowerA IsCharLower;
    alias IsCharUpperA IsCharUpper;
    alias IsDialogMessageA IsDialogMessage;
    alias LoadAcceleratorsA LoadAccelerators;
    alias LoadBitmapA LoadBitmap;
    alias LoadCursorA LoadCursor;
    alias LoadIconA LoadIcon;
    alias LoadCursorFromFileA LoadCursorFromFile;
    alias LoadImageA LoadImage;
    alias LoadKeyboardLayoutA LoadKeyboardLayout;
    alias LoadMenuA LoadMenu;
    alias LoadMenuIndirectA LoadMenuIndirect;
    alias LoadStringA LoadString;
    alias MapVirtualKeyA MapVirtualKey;
    alias MapVirtualKeyExA MapVirtualKeyEx;
    alias MessageBoxA MessageBox;
    alias MessageBoxExA MessageBoxEx;
    alias MessageBoxIndirectA MessageBoxIndirect;
    alias ModifyMenuA ModifyMenu;
    alias OemToCharA OemToChar;
    alias OemToCharBuffA OemToCharBuff;
    alias OpenDesktopA OpenDesktop;
    alias OpenWindowStationA OpenWindowStation;
    alias PeekMessageA PeekMessage;
    alias PostMessageA PostMessage;
    alias PostThreadMessageA PostThreadMessage;
    alias RealGetWindowClassA RealGetWindowClass;
    alias RegisterClassA RegisterClass;
    alias RegisterClassExA RegisterClassEx;
    alias RegisterClipboardFormatA RegisterClipboardFormat;
    alias RegisterDeviceNotificationA RegisterDeviceNotification;
    alias RegisterWindowMessageA RegisterWindowMessage;
    alias RemovePropA RemoveProp;
    alias SendDlgItemMessageA SendDlgItemMessage;
    alias SendMessageA SendMessage;
    alias SendMessageCallbackA SendMessageCallback;
    alias SendMessageTimeoutA SendMessageTimeout;
    alias SendNotifyMessageA SendNotifyMessage;
    alias SetClassLongA SetClassLong;
    alias SetClassLongPtrA SetClassLongPtr;
    alias SetDlgItemTextA SetDlgItemText;
    alias SetMenuItemInfoA SetMenuItemInfo;
    alias SetPropA SetProp;
    alias SetUserObjectInformationA SetUserObjectInformation;
    alias SetWindowLongA SetWindowLong;
    alias SetWindowLongPtrA SetWindowLongPtr;
    alias SetWindowsHookA SetWindowsHook;
    alias SetWindowsHookExA SetWindowsHookEx;
    alias SetWindowTextA SetWindowText;
    alias SystemParametersInfoA SystemParametersInfo;
    alias TabbedTextOutA TabbedTextOut;
    alias TranslateAcceleratorA TranslateAccelerator;
    alias UnregisterClassA UnregisterClass;
    alias VkKeyScanA VkKeyScan;
    alias VkKeyScanExA VkKeyScanEx;
    alias WinHelpA WinHelp;
    alias wsprintfA wsprintf;
    alias wvsprintfA wvsprintf;

    alias ChangeDisplaySettingsA ChangeDisplaySettings;
    alias ChangeDisplaySettingsExA ChangeDisplaySettingsEx;
    alias CreateDesktopA CreateDesktop;
    alias EnumDisplaySettingsA EnumDisplaySettings;
    alias EnumDisplaySettingsExA EnumDisplaySettingsEx;
    alias EnumDisplayDevicesA EnumDisplayDevices;
}

alias WNDCLASS* LPWNDCLASS, PWNDCLASS;
alias WNDCLASSEX* LPWNDCLASSEX, PWNDCLASSEX;
alias MENUITEMINFO* LPMENUITEMINFO;
alias MSGBOXPARAMS* PMSGBOXPARAMS, LPMSGBOXPARAMS;
alias HIGHCONTRAST* LPHIGHCONTRAST;
alias SERIALKEYS* LPSERIALKEYS;
alias SOUNDSENTRY* LPSOUNDSENTRY;
alias CREATESTRUCT* LPCREATESTRUCT;
alias CBT_CREATEWND* LPCBT_CREATEWND;
alias MDICREATESTRUCT* LPMDICREATESTRUCT;
alias MULTIKEYHELP* PMULTIKEYHELP, LPMULTIKEYHELP;
alias MONITORINFOEX* LPMONITORINFOEX;
alias ICONMETRICS* LPICONMETRICS;
alias NONCLIENTMETRICS* LPNONCLIENTMETRICS;

static if (_WIN32_WINNT >= 0x501) {
    enum PW_CLIENTONLY               = 0x00000001;
    enum RIM_INPUT                   = 0x00000000;
    enum RIM_INPUTSINK               = 0x00000001;
    enum RIM_TYPEMOUSE               = 0x00000000;
    enum RIM_TYPEKEYBOARD            = 0x00000001;
    enum RIM_TYPEHID                 = 0x00000002;
    enum MOUSE_MOVE_RELATIVE         = 0x00000000;
    enum MOUSE_MOVE_ABSOLUTE         = 0x00000001;
    enum MOUSE_VIRTUAL_DESKTOP       = 0x00000002;
    enum MOUSE_ATTRIBUTES_CHANGED    = 0x00000004;
    enum RI_MOUSE_LEFT_BUTTON_DOWN   = 0x0001;
    enum RI_MOUSE_LEFT_BUTTON_UP     = 0x0002;
    enum RI_MOUSE_RIGHT_BUTTON_DOWN  = 0x0004;
    enum RI_MOUSE_RIGHT_BUTTON_UP    = 0x0008;
    enum RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010;
    enum RI_MOUSE_MIDDLE_BUTTON_UP   = 0x0020;
    enum RI_MOUSE_BUTTON_1_DOWN = RI_MOUSE_LEFT_BUTTON_DOWN;
    enum RI_MOUSE_BUTTON_1_UP   = RI_MOUSE_LEFT_BUTTON_UP;
    enum RI_MOUSE_BUTTON_2_DOWN = RI_MOUSE_RIGHT_BUTTON_DOWN;
    enum RI_MOUSE_BUTTON_2_UP   = RI_MOUSE_RIGHT_BUTTON_UP;
    enum RI_MOUSE_BUTTON_3_DOWN = RI_MOUSE_MIDDLE_BUTTON_DOWN;
    enum RI_MOUSE_BUTTON_3_UP   = RI_MOUSE_MIDDLE_BUTTON_UP;
    enum RI_MOUSE_BUTTON_4_DOWN = 0x0040;
    enum RI_MOUSE_BUTTON_4_UP   = 0x0080;
    enum RI_MOUSE_BUTTON_5_DOWN = 0x0100;
    enum RI_MOUSE_BUTTON_5_UP   = 0x0200;
    enum RI_MOUSE_WHEEL         = 0x0400;
    enum KEYBOARD_OVERRUN_MAKE_CODE = 0x00ff;
    enum RI_KEY_MAKE            = 0x0000;
    enum RI_KEY_BREAK           = 0x0001;
    enum RI_KEY_E0              = 0x0002;
    enum RI_KEY_E1              = 0x0004;
    enum RI_KEY_TERMSRV_SET_LED = 0x0008;
    enum RI_KEY_TERMSRV_SHADOW  = 0x0010;

    enum RID_INPUT          = 0x10000003;
    enum RID_HEADER         = 0x10000005;

    enum RIDI_PREPARSEDDATA = 0x20000005;
    enum RIDI_DEVICENAME    = 0x20000007;
    enum RIDI_DEVICEINFO    = 0x2000000b;

    enum RIDEV_REMOVE       = 0x00000001;
    enum RIDEV_EXCLUDE      = 0x00000010;
    enum RIDEV_PAGEONLY     = 0x00000020;
    enum RIDEV_NOLEGACY     = 0x00000030;
    enum RIDEV_INPUTSINK    = 0x00000100;
    enum RIDEV_CAPTUREMOUSE = 0x00000200;
    enum RIDEV_NOHOTKEYS    = 0x00000200;
    enum RIDEV_APPKEYS      = 0x00000400;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winver.d)
 */
module core.sys.windows.winver;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "version");

private import core.sys.windows.windef;

// FIXME: type weirdness
enum {
    VS_FILE_INFO    =  16,
    VS_VERSION_INFO =   1,
    VS_USER_DEFINED = 100
}

enum {
    VS_FFI_SIGNATURE     = 0xFEEF04BD,
    VS_FFI_STRUCVERSION  =    0x10000,
    VS_FFI_FILEFLAGSMASK =       0x3F
}

enum {
    VS_FF_DEBUG        =  1,
    VS_FF_PRERELEASE   =  2,
    VS_FF_PATCHED      =  4,
    VS_FF_PRIVATEBUILD =  8,
    VS_FF_INFOINFERRED = 16,
    VS_FF_SPECIALBUILD = 32
}

enum {
    VOS_UNKNOWN       =       0,
    VOS_DOS           = 0x10000,
    VOS_OS216         = 0x20000,
    VOS_OS232         = 0x30000,
    VOS_NT            = 0x40000,
    VOS__BASE         =       0,
    VOS__WINDOWS16    =       1,
    VOS__PM16         =       2,
    VOS__PM32         =       3,
    VOS__WINDOWS32    =       4,
    VOS_DOS_WINDOWS16 = 0x10001,
    VOS_DOS_WINDOWS32 = 0x10004,
    VOS_OS216_PM16    = 0x20002,
    VOS_OS232_PM32    = 0x30003,
    VOS_NT_WINDOWS32  = 0x40004
}

enum {
    VFT_UNKNOWN    = 0,
    VFT_APP        = 1,
    VFT_DLL        = 2,
    VFT_DRV        = 3,
    VFT_FONT       = 4,
    VFT_VXD        = 5,
    VFT_STATIC_LIB = 7
}

enum {
    VFT2_UNKNOWN         =  0,
    VFT2_DRV_PRINTER     =  1,
    VFT2_DRV_KEYBOARD    =  2,
    VFT2_DRV_LANGUAGE    =  3,
    VFT2_DRV_DISPLAY     =  4,
    VFT2_DRV_MOUSE       =  5,
    VFT2_DRV_NETWORK     =  6,
    VFT2_DRV_SYSTEM      =  7,
    VFT2_DRV_INSTALLABLE =  8,
    VFT2_DRV_SOUND       =  9,
    VFT2_DRV_COMM        = 10,
    VFT2_DRV_INPUTMETHOD = 11,
    VFT2_FONT_RASTER     =  1,
    VFT2_FONT_VECTOR     =  2,
    VFT2_FONT_TRUETYPE   =  3
}

enum : DWORD {
    VFFF_ISSHAREDFILE = 1
}

enum : DWORD {
    VFF_CURNEDEST    = 1,
    VFF_FILEINUSE    = 2,
    VFF_BUFFTOOSMALL = 4
}

enum : DWORD {
    VIFF_FORCEINSTALL  = 1,
    VIFF_DONTDELETEOLD
}

enum {
    VIF_TEMPFILE         = 0x00001,
    VIF_MISMATCH         = 0x00002,
    VIF_SRCOLD           = 0x00004,
    VIF_DIFFLANG         = 0x00008,
    VIF_DIFFCODEPG       = 0x00010,
    VIF_DIFFTYPE         = 0x00020,
    VIF_WRITEPROT        = 0x00040,
    VIF_FILEINUSE        = 0x00080,
    VIF_OUTOFSPACE       = 0x00100,
    VIF_ACCESSVIOLATION  = 0x00200,
    VIF_SHARINGVIOLATION = 0x00400,
    VIF_CANNOTCREATE     = 0x00800,
    VIF_CANNOTDELETE     = 0x01000,
    VIF_CANNOTRENAME     = 0x02000,
    VIF_CANNOTDELETECUR  = 0x04000,
    VIF_OUTOFMEMORY      = 0x08000,
    VIF_CANNOTREADSRC    = 0x10000,
    VIF_CANNOTREADDST    = 0x20000,
    VIF_BUFFTOOSMALL     = 0x40000
}

struct VS_FIXEDFILEINFO {
    DWORD dwSignature;
    DWORD dwStrucVersion;
    DWORD dwFileVersionMS;
    DWORD dwFileVersionLS;
    DWORD dwProductVersionMS;
    DWORD dwProductVersionLS;
    DWORD dwFileFlagsMask;
    DWORD dwFileFlags;
    DWORD dwFileOS;
    DWORD dwFileType;
    DWORD dwFileSubtype;
    DWORD dwFileDateMS;
    DWORD dwFileDateLS;
}

extern (Windows) {
    DWORD VerFindFileA(DWORD, LPCSTR, LPCSTR, LPCSTR, LPSTR, PUINT, LPSTR,
      PUINT);
    DWORD VerFindFileW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPWSTR, PUINT, LPWSTR,
      PUINT);
    DWORD VerInstallFileA(DWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPCSTR, LPSTR,
      PUINT);
    DWORD VerInstallFileW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR,
      LPWSTR, PUINT);
    DWORD GetFileVersionInfoSizeA(LPCSTR, PDWORD);
    DWORD GetFileVersionInfoSizeW(LPCWSTR, PDWORD);
    BOOL GetFileVersionInfoA(LPCSTR, DWORD, DWORD, PVOID);
    BOOL GetFileVersionInfoW(LPCWSTR, DWORD, DWORD, PVOID);
    DWORD VerLanguageNameA(DWORD, LPSTR, DWORD);
    DWORD VerLanguageNameW(DWORD, LPWSTR, DWORD);
    BOOL VerQueryValueA(LPCVOID, LPCSTR, LPVOID*, PUINT);
    BOOL VerQueryValueW(LPCVOID, LPCWSTR, LPVOID*, PUINT);
}

version (Unicode) {
    alias VerFindFileW VerFindFile;
    alias VerQueryValueW VerQueryValue;
    alias VerInstallFileW VerInstallFile;
    alias GetFileVersionInfoSizeW GetFileVersionInfoSize;
    alias GetFileVersionInfoW GetFileVersionInfo;
    alias VerLanguageNameW VerLanguageName;
    alias VerQueryValueW VerQueryValue;
} else {
    alias VerQueryValueA VerQueryValue;
    alias VerFindFileA VerFindFile;
    alias VerInstallFileA VerInstallFile;
    alias GetFileVersionInfoSizeA GetFileVersionInfoSize;
    alias GetFileVersionInfoA GetFileVersionInfo;
    alias VerLanguageNameA VerLanguageName;
    alias VerQueryValueA VerQueryValue;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * Windows API header module
 *
 * Translated from MinGW-w64 API
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_wtsapi32.d)
 */
module core.sys.windows.wtsapi32;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "wtsapi32");
private import core.sys.windows.w32api;
import core.sys.windows.windef;

enum {
    WTS_CURRENT_SERVER        = null,
    WTS_CURRENT_SERVER_HANDLE = null,
    WTS_CURRENT_SERVER_NAME   = null
}

enum DWORD WTS_CURRENT_SESSION = cast(DWORD) -1;

enum {
    IDTIMEOUT = 32000,
    IDASYNC   = 32001
}

enum {
    WTS_WSD_LOGOFF     = 0x01,
    WTS_WSD_SHUTDOWN   = 0x02,
    WTS_WSD_REBOOT     = 0x04,
    WTS_WSD_POWEROFF   = 0x08,
    WTS_WSD_FASTREBOOT = 0x10
}

enum WTS_CONNECTSTATE_CLASS {
    WTSActive,
    WTSConnected,
    WTSConnectQuery,
    WTSShadow,
    WTSDisconnected,
    WTSIdle,
    WTSListen,
    WTSReset,
    WTSDown,
    WTSInit
}

struct WTS_SERVER_INFOW {
    LPWSTR pServerName;
}
alias WTS_SERVER_INFOW* PWTS_SERVER_INFOW;

struct WTS_SERVER_INFOA {
    LPSTR pServerName;
}
alias WTS_SERVER_INFOA* PWTS_SERVER_INFOA;

version (Unicode) {
    alias WTS_SERVER_INFOW  WTS_SERVER_INFO;
    alias PWTS_SERVER_INFOW PWTS_SERVER_INFO;
} else {
    alias WTS_SERVER_INFOA  WTS_SERVER_INFO;
    alias PWTS_SERVER_INFOA PWTS_SERVER_INFO;
}

struct WTS_SESSION_INFOW {
    DWORD SessionId;
    LPWSTR pWinStationName;
    WTS_CONNECTSTATE_CLASS State;
}
alias WTS_SESSION_INFOW* PWTS_SESSION_INFOW;

struct WTS_SESSION_INFOA {
    DWORD SessionId;
    LPSTR pWinStationName;
    WTS_CONNECTSTATE_CLASS State;
}
alias WTS_SESSION_INFOA* PWTS_SESSION_INFOA;

version (Unicode) {
    alias WTS_SESSION_INFOW  WTS_SESSION_INFO;
    alias PWTS_SESSION_INFOW PWTS_SESSION_INFO;
} else {
    alias WTS_SESSION_INFOA  WTS_SESSION_INFO;
    alias PWTS_SESSION_INFOA PWTS_SESSION_INFO;
}

struct WTS_PROCESS_INFOW {
    DWORD SessionId;
    DWORD ProcessId;
    LPWSTR pProcessName;
    PSID pUserSid;
}
alias WTS_PROCESS_INFOW* PWTS_PROCESS_INFOW;

struct WTS_PROCESS_INFOA {
    DWORD SessionId;
    DWORD ProcessId;
    LPSTR pProcessName;
    PSID pUserSid;
}
alias WTS_PROCESS_INFOA* PWTS_PROCESS_INFOA;

version (Unicode) {
    alias WTS_PROCESS_INFOW  WTS_PROCESS_INFO;
    alias PWTS_PROCESS_INFOW PWTS_PROCESS_INFO;
} else {
    alias WTS_PROCESS_INFOA  WTS_PROCESS_INFO;
    alias PWTS_PROCESS_INFOA PWTS_PROCESS_INFO;
}

enum {
    WTS_PROTOCOL_TYPE_CONSOLE,
    WTS_PROTOCOL_TYPE_ICA,
    WTS_PROTOCOL_TYPE_RDP
}

enum WTS_INFO_CLASS {
    WTSInitialProgram,
    WTSApplicationName,
    WTSWorkingDirectory,
    WTSOEMId,
    WTSSessionId,
    WTSUserName,
    WTSWinStationName,
    WTSDomainName,
    WTSConnectState,
    WTSClientBuildNumber,
    WTSClientName,
    WTSClientDirectory,
    WTSClientProductId,
    WTSClientHardwareId,
    WTSClientAddress,
    WTSClientDisplay,
    WTSClientProtocolType,
    WTSIdleTime,
    WTSLogonTime,
    WTSIncomingBytes,
    WTSOutgoingBytes,
    WTSIncomingFrames,
    WTSOutgoingFrames,
    WTSClientInfo,
    WTSSessionInfo, // = 24
}

struct WTS_CLIENT_ADDRESS {
    DWORD    AddressFamily;
    BYTE[20] Address;
}
alias WTS_CLIENT_ADDRESS* PWTS_CLIENT_ADDRESS;

struct WTS_CLIENT_DISPLAY {
    DWORD HorizontalResolution;
    DWORD VerticalResolution;
    DWORD ColorDepth;
}
alias WTS_CLIENT_DISPLAY* PWTS_CLIENT_DISPLAY;

enum WTS_CONFIG_CLASS {
    WTSUserConfigInitialProgram,
    WTSUserConfigWorkingDirectory,
    WTSUserConfigfInheritInitialProgram,
    WTSUserConfigfAllowLogonTerminalServer,
    WTSUserConfigTimeoutSettingsConnections,
    WTSUserConfigTimeoutSettingsDisconnections,
    WTSUserConfigTimeoutSettingsIdle,
    WTSUserConfigfDeviceClientDrives,
    WTSUserConfigfDeviceClientPrinters,
    WTSUserConfigfDeviceClientDefaultPrinter,
    WTSUserConfigBrokenTimeoutSettings,
    WTSUserConfigReconnectSettings,
    WTSUserConfigModemCallbackSettings,
    WTSUserConfigModemCallbackPhoneNumber,
    WTSUserConfigShadowingSettings,
    WTSUserConfigTerminalServerProfilePath,
    WTSUserConfigTerminalServerHomeDir,
    WTSUserConfigTerminalServerHomeDirDrive,
    WTSUserConfigfTerminalServerRemoteHomeDir
}

enum {
    WTS_EVENT_NONE        = 0x0,
    WTS_EVENT_CREATE      = 0x1,
    WTS_EVENT_DELETE      = 0x2,
    WTS_EVENT_RENAME      = 0x4,
    WTS_EVENT_CONNECT     = 0x8,
    WTS_EVENT_DISCONNECT  = 0x10,
    WTS_EVENT_LOGON       = 0x20,
    WTS_EVENT_LOGOFF      = 0x40,
    WTS_EVENT_STATECHANGE = 0x80,
    WTS_EVENT_LICENSE     = 0x100,
    WTS_EVENT_ALL         = 0x7fffffff,
    WTS_EVENT_FLUSH       = 0x80000000
}

enum WTS_VIRTUAL_CLASS {
    WTSVirtualClientData,
    WTSVirtualFileHandle
}

version (Unicode) {
    alias WTSEnumerateServersW WTSEnumerateServers;
    alias WTSOpenServerW WTSOpenServer;
    alias WTSEnumerateSessionsW WTSEnumerateSessions;
    alias WTSEnumerateProcessesW WTSEnumerateProcesses;
    alias WTSQuerySessionInformationW WTSQuerySessionInformation;
    alias WTSQueryUserConfigW WTSQueryUserConfig;
    alias WTSSetUserConfigW WTSSetUserConfig;
    alias WTSSendMessageW WTSSendMessage;
} else {
    alias WTSEnumerateServersA WTSEnumerateServers;
    alias WTSOpenServerA WTSOpenServer;
    alias WTSEnumerateSessionsA WTSEnumerateSessions;
    alias WTSEnumerateProcessesA WTSEnumerateProcesses;
    alias WTSQuerySessionInformationA WTSQuerySessionInformation;
    alias WTSQueryUserConfigA WTSQueryUserConfig;
    alias WTSSetUserConfigA WTSSetUserConfig;
    alias WTSSendMessageA WTSSendMessage;
}

extern(Windows) {
    WINBOOL WTSEnumerateServersW(LPWSTR pDomainName, DWORD Reserved, DWORD Version, PWTS_SERVER_INFOW* ppServerInfo, DWORD* pCount);
    WINBOOL WTSEnumerateServersA(LPSTR pDomainName, DWORD Reserved, DWORD Version, PWTS_SERVER_INFOA* ppServerInfo, DWORD* pCount);
    HANDLE WTSOpenServerW(LPWSTR pServerName);
    HANDLE WTSOpenServerA(LPSTR pServerName);
    VOID WTSCloseServer(HANDLE hServer);
    WINBOOL WTSEnumerateSessionsW(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFOW* ppSessionInfo, DWORD* pCount);
    WINBOOL WTSEnumerateSessionsA(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_SESSION_INFOA* ppSessionInfo, DWORD* pCount);
    WINBOOL WTSEnumerateProcessesW(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_PROCESS_INFOW* ppProcessInfo, DWORD* pCount);
    WINBOOL WTSEnumerateProcessesA(HANDLE hServer, DWORD Reserved, DWORD Version, PWTS_PROCESS_INFOA* ppProcessInfo, DWORD* pCount);
    WINBOOL WTSTerminateProcess(HANDLE hServer, DWORD ProcessId, DWORD ExitCode);
    WINBOOL WTSQuerySessionInformationW(HANDLE hServer, DWORD SessionId, WTS_INFO_CLASS WTSInfoClass, LPWSTR* ppBuffer, DWORD* pBytesReturned);
    WINBOOL WTSQuerySessionInformationA(HANDLE hServer, DWORD SessionId, WTS_INFO_CLASS WTSInfoClass, LPSTR* ppBuffer, DWORD* pBytesReturned);
    WINBOOL WTSQueryUserConfigW(LPWSTR pServerName, LPWSTR pUserName, WTS_CONFIG_CLASS WTSConfigClass, LPWSTR* ppBuffer, DWORD* pBytesReturned);
    WINBOOL WTSQueryUserConfigA(LPSTR pServerName, LPSTR pUserName, WTS_CONFIG_CLASS WTSConfigClass, LPSTR* ppBuffer, DWORD* pBytesReturned);
    WINBOOL WTSSetUserConfigW(LPWSTR pServerName, LPWSTR pUserName, WTS_CONFIG_CLASS WTSConfigClass, LPWSTR pBuffer, DWORD DataLength);
    WINBOOL WTSSetUserConfigA(LPSTR pServerName, LPSTR pUserName, WTS_CONFIG_CLASS WTSConfigClass, LPSTR pBuffer, DWORD DataLength);
    WINBOOL WTSSendMessageW(HANDLE hServer, DWORD SessionId, LPWSTR pTitle, DWORD TitleLength, LPWSTR pMessage, DWORD MessageLength, DWORD Style, DWORD Timeout, DWORD* pResponse, WINBOOL bWait);
    WINBOOL WTSSendMessageA(HANDLE hServer, DWORD SessionId, LPSTR pTitle, DWORD TitleLength, LPSTR pMessage, DWORD MessageLength, DWORD Style, DWORD Timeout, DWORD* pResponse, WINBOOL bWait);
    WINBOOL WTSDisconnectSession(HANDLE hServer, DWORD SessionId, WINBOOL bWait);
    WINBOOL WTSLogoffSession(HANDLE hServer, DWORD SessionId, WINBOOL bWait);
    WINBOOL WTSShutdownSystem(HANDLE hServer, DWORD ShutdownFlag);
    WINBOOL WTSWaitSystemEvent(HANDLE hServer, DWORD EventMask, DWORD* pEventFlags);
    HANDLE WTSVirtualChannelOpen(HANDLE hServer, DWORD SessionId, LPSTR pVirtualName);
    WINBOOL WTSVirtualChannelClose(HANDLE hChannelHandle);
    WINBOOL WTSVirtualChannelRead(HANDLE hChannelHandle, ULONG TimeOut, PCHAR Buffer, ULONG BufferSize, PULONG pBytesRead);
    WINBOOL WTSVirtualChannelWrite(HANDLE hChannelHandle, PCHAR Buffer, ULONG Length, PULONG pBytesWritten);
    WINBOOL WTSVirtualChannelPurgeInput(HANDLE hChannelHandle);
    WINBOOL WTSVirtualChannelPurgeOutput(HANDLE hChannelHandle);
    WINBOOL WTSVirtualChannelQuery(HANDLE hChannelHandle, WTS_VIRTUAL_CLASS, PVOID* ppBuffer, DWORD* pBytesReturned);
    VOID WTSFreeMemory(PVOID pMemory);

    WINBOOL WTSRegisterSessionNotification(HWND hWnd, DWORD dwFlags);
    WINBOOL WTSUnRegisterSessionNotification(HWND hWnd);
    WINBOOL WTSQueryUserToken(ULONG SessionId, PHANDLE phToken);
}

enum {
    NOTIFY_FOR_ALL_SESSIONS = 1,
    NOTIFY_FOR_THIS_SESSION = 0
}

enum {
    USERNAME_LENGTH       = 20,
    CLIENTNAME_LENGTH     = 20,
    CLIENTADDRESS_LENGTH  = 30,
    WINSTATIONNAME_LENGTH = 32,
    DOMAIN_LENGTH         = 17
}

static if (_WIN32_WINNT >= 0x600) {
    struct WTSCLIENTW {
        WCHAR[CLIENTNAME_LENGTH + 1]      ClientName = 0;
        WCHAR[DOMAIN_LENGTH + 1]          Domain = 0;
        WCHAR[USERNAME_LENGTH + 1]        UserName = 0;
        WCHAR[MAX_PATH + 1]               WorkDirectory = 0;
        WCHAR[MAX_PATH + 1]               InitialProgram = 0;
        BYTE                              EncryptionLevel;
        ULONG                             ClientAddressFamily;
        USHORT[CLIENTADDRESS_LENGTH + 1]  ClientAddress;
        USHORT                            HRes;
        USHORT                            VRes;
        USHORT                            ColorDepth;
        WCHAR[MAX_PATH + 1]               ClientDirectory = 0;
        ULONG                             ClientBuildNumber;
        ULONG                             ClientHardwareId;
        USHORT                            ClientProductId;
        USHORT                            OutBufCountHost;
        USHORT                            OutBufCountClient;
        USHORT                            OutBufLength;
        WCHAR[MAX_PATH + 1]               DeviceId = 0;
    }
    alias WTSCLIENTW* PWTSCLIENTW;

    struct WTSCLIENTA {
        CHAR[CLIENTNAME_LENGTH + 1]       ClientName = 0;
        CHAR[DOMAIN_LENGTH + 1 ]          Domain = 0;
        CHAR[USERNAME_LENGTH + 1]         UserName = 0;
        CHAR[MAX_PATH + 1]                WorkDirectory = 0;
        CHAR[MAX_PATH + 1]                InitialProgram = 0;
        BYTE                              EncryptionLevel;
        ULONG                             ClientAddressFamily;
        USHORT[CLIENTADDRESS_LENGTH + 1]  ClientAddress;
        USHORT                            HRes;
        USHORT                            VRes;
        USHORT                            ColorDepth;
        CHAR[MAX_PATH + 1]                ClientDirectory = 0;
        ULONG                             ClientBuildNumber;
        ULONG                             ClientHardwareId;
        USHORT                            ClientProductId;
        USHORT                            OutBufCountHost;
        USHORT                            OutBufCountClient;
        USHORT                            OutBufLength;
        CHAR[MAX_PATH + 1]                DeviceId = 0;
    }
    alias WTSCLIENTA* PWTSCLIENTA;

    version (Unicode) {
        alias WTSCLIENTW  WTSCLIENT;
        alias PWTSCLIENTW PWTSCLIENT;
    } else {
        alias WTSCLIENTA  WTSCLIENT;
        alias PWTSCLIENTA PWTSCLIENT;
    }

    struct WTSINFOW {
        WTS_CONNECTSTATE_CLASS       State;
        DWORD                        SessionId;
        DWORD                        IncomingBytes;
        DWORD                        OutgoingBytes;
        DWORD                        IncomingFrames;
        DWORD                        OutgoingFrames;
        DWORD                        IncomingCompressedBytes;
        DWORD                        OutgoingCompressedBytes;
        WCHAR[WINSTATIONNAME_LENGTH] WinStationName = 0;
        WCHAR[DOMAIN_LENGTH]         Domain = 0;
        WCHAR[USERNAME_LENGTH+1]     UserName = 0;
        LARGE_INTEGER                ConnectTime;
        LARGE_INTEGER                DisconnectTime;
        LARGE_INTEGER                LastInputTime;
        LARGE_INTEGER                LogonTime;
        LARGE_INTEGER                CurrentTime;
    }
    alias WTSINFOW* PWTSINFOW;

    struct WTSINFOA {
        WTS_CONNECTSTATE_CLASS      State;
        DWORD                       SessionId;
        DWORD                       IncomingBytes;
        DWORD                       OutgoingBytes;
        DWORD                       IncomingFrames;
        DWORD                       OutgoingFrames;
        DWORD                       IncomingCompressedBytes;
        DWORD                       OutgoingCompressedBytes;
        CHAR[WINSTATIONNAME_LENGTH] WinStationName = 0;
        CHAR[DOMAIN_LENGTH]         Domain = 0;
        CHAR[USERNAME_LENGTH+1]     UserName = 0;
        LARGE_INTEGER               ConnectTime;
        LARGE_INTEGER               DisconnectTime;
        LARGE_INTEGER               LastInputTime;
        LARGE_INTEGER               LogonTime;
        LARGE_INTEGER               CurrentTime;
    }
    alias WTSINFOA* PWTSINFOA;

    version (Unicode) {
        alias WTSINFOW  WTSINFO;
        alias PWTSINFOW PWTSINFO;
    } else {
        alias WTSINFOA  WTSINFO;
        alias PWTSINFOA PWTSINFO;
    }

    extern(Windows) {
        WINBOOL WTSConnectSessionA(
            ULONG LogonId,
            ULONG TargetLogonId,
            PSTR   pPassword,
            WINBOOL bWait
        );

        WINBOOL WTSConnectSessionW(
            ULONG LogonId,
            ULONG TargetLogonId,
            PWSTR  pPassword,
            WINBOOL bWait
        );

        WINBOOL WTSRegisterSessionNotificationEx(
            HANDLE hServer,
            HWND hWnd,
            DWORD dwFlags
        );

        WINBOOL WTSStartRemoteControlSessionA(
            LPSTR pTargetServerName,
            ULONG TargetLogonId,
            BYTE HotkeyVk,
            USHORT HotkeyModifiers
        );

        WINBOOL WTSStartRemoteControlSessionW(
            LPWSTR pTargetServerName,
            ULONG TargetLogonId,
            BYTE HotkeyVk,
            USHORT HotkeyModifiers
        );

        version (Unicode) {
            alias WTSStartRemoteControlSessionW WTSStartRemoteControlSession;
            alias WTSConnectSessionW WTSConnectSession;
        } else {
            alias WTSStartRemoteControlSessionA WTSStartRemoteControlSession;
            alias WTSConnectSessionA WTSConnectSession;
        }

        WINBOOL WTSStopRemoteControlSession(
            ULONG LogonId
        );

        WINBOOL WTSUnRegisterSessionNotificationEx(
            HANDLE hServer,
            HWND hWnd
        );

        HANDLE WTSVirtualChannelOpenEx(
            DWORD SessionId,
            LPSTR pVirtualName,
            DWORD flags
        );
    } /* extern(Windows) */
} /* static if (_WIN32_WINNT >= 0x600) */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_wtypes.d)
 */
module core.sys.windows.wtypes;
version (Windows):

import core.sys.windows.rpc, core.sys.windows.rpcndr;
private import core.sys.windows.windef;
private import core.sys.windows.uuid; // for GUID_NULL

alias GUID_NULL IID_NULL, CLSID_NULL;

enum ROTFLAGS_REGISTRATIONKEEPSALIVE = 0x01;
enum ROTFLAGS_ALLOWANYCLIENT         = 0x02;

// also in winsock2.h
struct BLOB {
    ULONG cbSize;
    BYTE* pBlobData;
}
alias BLOB* PBLOB, LPBLOB;

enum DVASPECT {
    DVASPECT_CONTENT   = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON      = 4,
    DVASPECT_DOCPRINT  = 8
}

enum DVASPECT2 {
    DVASPECT_OPAQUE      = 16,
    DVASPECT_TRANSPARENT = 32
}

enum STATFLAG {
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME  = 1
}

enum MEMCTX {
    MEMCTX_LOCAL = 0,
    MEMCTX_TASK,
    MEMCTX_SHARED,
    MEMCTX_MACSYSTEM,
    MEMCTX_UNKNOWN = -1,
    MEMCTX_SAME = -2
}

enum MSHCTX {
    MSHCTX_LOCAL = 0,
    MSHCTX_NOSHAREDMEM,
    MSHCTX_DIFFERENTMACHINE,
    MSHCTX_INPROC,
    MSHCTX_CROSSCTX
}

enum CLSCTX {
    CLSCTX_INPROC_SERVER    = 0x1,
    CLSCTX_INPROC_HANDLER   = 0x2,
    CLSCTX_LOCAL_SERVER     = 0x4,
    CLSCTX_INPROC_SERVER16  = 0x8,
    CLSCTX_REMOTE_SERVER    = 0x10,
    CLSCTX_INPROC_HANDLER16 = 0x20,
    CLSCTX_INPROC_SERVERX86 = 0x40,
    CLSCTX_INPROC_HANDLERX86 = 0x80,
}

enum MSHLFLAGS {
    MSHLFLAGS_NORMAL,
    MSHLFLAGS_TABLESTRONG,
    MSHLFLAGS_TABLEWEAK
}

struct FLAGGED_WORD_BLOB {
    uint fFlags;
    uint clSize;
    ushort[1] asData;
}

alias WCHAR OLECHAR;
alias LPWSTR LPOLESTR;
alias LPCWSTR LPCOLESTR;

alias ushort VARTYPE;
alias short VARIANT_BOOL;
alias VARIANT_BOOL _VARIANT_BOOL;
enum VARIANT_BOOL VARIANT_TRUE = -1; // 0xffff;
enum VARIANT_BOOL VARIANT_FALSE = 0;

alias OLECHAR* BSTR;
alias FLAGGED_WORD_BLOB* wireBSTR;
alias BSTR* LPBSTR;
//alias LONG SCODE; // also in winerror
mixin DECLARE_HANDLE!("HCONTEXT");
mixin DECLARE_HANDLE!("HMETAFILEPICT");

union CY {
    struct {
        uint Lo;
        int Hi;
    }
    LONGLONG int64;
}

alias double DATE;
struct  BSTRBLOB {
    ULONG cbSize;
    PBYTE pData;
}
alias BSTRBLOB* LPBSTRBLOB;

// Used only in the PROPVARIANT structure
// According to the 2003 SDK, this should be in propidl.h, not here.
struct CLIPDATA {
    ULONG cbSize;
    int ulClipFmt;
    PBYTE pClipData;
}

enum STGC {
    STGC_DEFAULT,
    STGC_OVERWRITE,
    STGC_ONLYIFCURRENT,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE
}

enum STGMOVE {
    STGMOVE_MOVE,
    STGMOVE_COPY,
    STGMOVE_SHALLOWCOPY
}

enum VARENUM {
    VT_EMPTY,
    VT_NULL,
    VT_I2,
    VT_I4,
    VT_R4,
    VT_R8,
    VT_CY,
    VT_DATE,
    VT_BSTR,
    VT_DISPATCH,
    VT_ERROR,
    VT_BOOL,
    VT_VARIANT,
    VT_UNKNOWN,
    VT_DECIMAL,
    VT_I1 = 16,
    VT_UI1,
    VT_UI2,
    VT_UI4,
    VT_I8,
    VT_UI8,
    VT_INT,
    VT_UINT,
    VT_VOID,
    VT_HRESULT,
    VT_PTR,
    VT_SAFEARRAY,
    VT_CARRAY,
    VT_USERDEFINED,
    VT_LPSTR,
    VT_LPWSTR,
    VT_RECORD   = 36,
    VT_INT_PTR  = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB,
    VT_STREAM,
    VT_STORAGE,
    VT_STREAMED_OBJECT,
    VT_STORED_OBJECT,
    VT_BLOB_OBJECT,
    VT_CF,
    VT_CLSID,
    VT_BSTR_BLOB     = 0xfff,
    VT_VECTOR        = 0x1000,
    VT_ARRAY         = 0x2000,
    VT_BYREF         = 0x4000,
    VT_RESERVED      = 0x8000,
    VT_ILLEGAL       = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK      = 0xfff
};

struct BYTE_SIZEDARR {
    uint clSize;
    byte* pData;
}

struct WORD_SIZEDARR {
    uint clSize;
    ushort* pData;
}

struct DWORD_SIZEDARR {
uint clSize;
uint* pData;
}

struct HYPER_SIZEDARR {
    uint clSize;
    hyper* pData;
}

alias double DOUBLE;


struct DECIMAL {
    USHORT wReserved;
    union {
        struct {
            ubyte scale; // valid values are 0 to 28
            ubyte sign; // 0 for positive, DECIMAL_NEG for negatives.
            enum ubyte DECIMAL_NEG = 0x80;
        }
        USHORT signscale;
    }
    ULONG Hi32;
    union {
        struct {
            ULONG Lo32;
            ULONG Mid32;
        }
        ULONGLONG Lo64;
    }
    // #define DECIMAL_SETZERO(d) {(d).Lo64=(d).Hi32=(d).signscale=0;}
    void setZero() { Lo64 = 0; Hi32 = 0; signscale = 0; }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * The thread module provides support for thread creation and management.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2012.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly, Walter Bright, Alex RÃ¸nne Petersen, Martin Nowak
 * Source:    $(DRUNTIMESRC core/_thread.d)
 */

/* NOTE: This file has been patched from the original DMD distribution to
 * work with the GDC compiler.
 */
module core.thread;


public import core.time; // for Duration
import core.exception : onOutOfMemoryError;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

private
{
    // interface to rt.tlsgc
    import core.internal.traits : externDFunc;

    alias rt_tlsgc_init = externDFunc!("rt.tlsgc.init", void* function() nothrow @nogc);
    alias rt_tlsgc_destroy = externDFunc!("rt.tlsgc.destroy", void function(void*) nothrow @nogc);

    alias ScanDg = void delegate(void* pstart, void* pend) nothrow;
    alias rt_tlsgc_scan =
        externDFunc!("rt.tlsgc.scan", void function(void*, scope ScanDg) nothrow);

    alias rt_tlsgc_processGCMarks =
        externDFunc!("rt.tlsgc.processGCMarks", void function(void*, scope IsMarkedDg) nothrow);
}

version (Solaris)
{
    import core.sys.solaris.sys.priocntl;
    import core.sys.solaris.sys.types;
}

// this should be true for most architectures
version (GNU_StackGrowsDown)
    version = StackGrowsDown;

/**
 * Returns the process ID of the calling process, which is guaranteed to be
 * unique on the system. This call is always successful.
 *
 * Example:
 * ---
 * writefln("Current process id: %s", getpid());
 * ---
 */
version (Posix)
{
    alias getpid = core.sys.posix.unistd.getpid;
}
else version (Windows)
{
    alias getpid = core.sys.windows.windows.GetCurrentProcessId;
}


///////////////////////////////////////////////////////////////////////////////
// Thread and Fiber Exceptions
///////////////////////////////////////////////////////////////////////////////


/**
 * Base class for thread exceptions.
 */
class ThreadException : Exception
{
    @safe pure nothrow this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)
    {
        super(msg, file, line, next);
    }

    @safe pure nothrow this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)
    {
        super(msg, file, line, next);
    }
}


/**
* Base class for thread errors to be used for function inside GC when allocations are unavailable.
*/
class ThreadError : Error
{
    @safe pure nothrow this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)
    {
        super(msg, file, line, next);
    }

    @safe pure nothrow this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)
    {
        super(msg, file, line, next);
    }
}

private
{
    import core.atomic, core.memory, core.sync.mutex;

    // Handling unaligned mutexes are not supported on all platforms, so we must
    // ensure that the address of all shared data are appropriately aligned.
    import core.internal.traits : classInstanceAlignment;

    enum mutexAlign = classInstanceAlignment!Mutex;
    enum mutexClassInstanceSize = __traits(classInstanceSize, Mutex);

    //
    // exposed by compiler runtime
    //
    extern (C) void  rt_moduleTlsCtor();
    extern (C) void  rt_moduleTlsDtor();

    /**
     * Hook for whatever EH implementation is used to save/restore some data
     * per stack.
     *
     * Params:
     *     newContext = The return value of the prior call to this function
     *         where the stack was last swapped out, or null when a fiber stack
     *         is switched in for the first time.
     */
    extern(C) void* _d_eh_swapContext(void* newContext) nothrow @nogc;

    version (DigitalMars)
    {
        version (Windows)
            alias swapContext = _d_eh_swapContext;
        else
        {
            extern(C) void* _d_eh_swapContextDwarf(void* newContext) nothrow @nogc;

            void* swapContext(void* newContext) nothrow @nogc
            {
                /* Detect at runtime which scheme is being used.
                 * Eventually, determine it statically.
                 */
                static int which = 0;
                final switch (which)
                {
                    case 0:
                    {
                        assert(newContext == null);
                        auto p = _d_eh_swapContext(newContext);
                        auto pdwarf = _d_eh_swapContextDwarf(newContext);
                        if (p)
                        {
                            which = 1;
                            return p;
                        }
                        else if (pdwarf)
                        {
                            which = 2;
                            return pdwarf;
                        }
                        return null;
                    }
                    case 1:
                        return _d_eh_swapContext(newContext);
                    case 2:
                        return _d_eh_swapContextDwarf(newContext);
                }
            }
        }
    }
    else
        alias swapContext = _d_eh_swapContext;
}


///////////////////////////////////////////////////////////////////////////////
// Thread Entry Point and Signal Handlers
///////////////////////////////////////////////////////////////////////////////


version (Windows)
{
    private
    {
        import core.stdc.stdint : uintptr_t; // for _beginthreadex decl below
        import core.stdc.stdlib;             // for malloc, atexit
        import core.sys.windows.windows;
        import core.sys.windows.threadaux;   // for OpenThreadHandle

        extern (Windows) alias btex_fptr = uint function(void*);
        extern (C) uintptr_t _beginthreadex(void*, uint, btex_fptr, void*, uint, uint*) nothrow;

        //
        // Entry point for Windows threads
        //
        extern (Windows) uint thread_entryPoint( void* arg ) nothrow
        {
            Thread  obj = cast(Thread) arg;
            assert( obj );

            assert( obj.m_curr is &obj.m_main );
            obj.m_main.bstack = getStackBottom();
            obj.m_main.tstack = obj.m_main.bstack;
            obj.m_tlsgcdata = rt_tlsgc_init();

            Thread.setThis(obj);
            Thread.add(obj);
            scope (exit)
            {
                Thread.remove(obj);
            }
            Thread.add(&obj.m_main);

            // NOTE: No GC allocations may occur until the stack pointers have
            //       been set and Thread.getThis returns a valid reference to
            //       this thread object (this latter condition is not strictly
            //       necessary on Windows but it should be followed for the
            //       sake of consistency).

            // TODO: Consider putting an auto exception object here (using
            //       alloca) forOutOfMemoryError plus something to track
            //       whether an exception is in-flight?

            void append( Throwable t )
            {
                if ( obj.m_unhandled is null )
                    obj.m_unhandled = t;
                else
                {
                    Throwable last = obj.m_unhandled;
                    while ( last.next !is null )
                        last = last.next;
                    last.next = t;
                }
            }

            version (D_InlineAsm_X86)
            {
                asm nothrow @nogc { fninit; }
            }

            try
            {
                rt_moduleTlsCtor();
                try
                {
                    obj.run();
                }
                catch ( Throwable t )
                {
                    append( t );
                }
                rt_moduleTlsDtor();
            }
            catch ( Throwable t )
            {
                append( t );
            }
            return 0;
        }


        HANDLE GetCurrentThreadHandle() nothrow @nogc
        {
            const uint DUPLICATE_SAME_ACCESS = 0x00000002;

            HANDLE curr = GetCurrentThread(),
                   proc = GetCurrentProcess(),
                   hndl;

            DuplicateHandle( proc, curr, proc, &hndl, 0, TRUE, DUPLICATE_SAME_ACCESS );
            return hndl;
        }
    }
}
else version (Posix)
{
    private
    {
        import core.stdc.errno;
        import core.sys.posix.semaphore;
        import core.sys.posix.stdlib; // for malloc, valloc, free, atexit
        import core.sys.posix.pthread;
        import core.sys.posix.signal;
        import core.sys.posix.time;

        version (Darwin)
        {
            import core.sys.darwin.mach.thread_act;
            import core.sys.darwin.pthread : pthread_mach_thread_np;
        }

        version (GNU)
        {
            import gcc.builtins;
        }

        //
        // Entry point for POSIX threads
        //
        extern (C) void* thread_entryPoint( void* arg ) nothrow
        {
            version (Shared)
            {
                import rt.sections;
                Thread obj = cast(Thread)(cast(void**)arg)[0];
                auto loadedLibraries = (cast(void**)arg)[1];
                .free(arg);
            }
            else
            {
                Thread obj = cast(Thread)arg;
            }
            assert( obj );

            // loadedLibraries need to be inherited from parent thread
            // before initilizing GC for TLS (rt_tlsgc_init)
            version (Shared) inheritLoadedLibraries(loadedLibraries);

            assert( obj.m_curr is &obj.m_main );
            obj.m_main.bstack = getStackBottom();
            obj.m_main.tstack = obj.m_main.bstack;
            obj.m_tlsgcdata = rt_tlsgc_init();

            atomicStore!(MemoryOrder.raw)(obj.m_isRunning, true);
            Thread.setThis(obj); // allocates lazy TLS (see Issue 11981)
            Thread.add(obj);     // can only receive signals from here on
            scope (exit)
            {
                Thread.remove(obj);
                atomicStore!(MemoryOrder.raw)(obj.m_isRunning, false);
            }
            Thread.add(&obj.m_main);

            static extern (C) void thread_cleanupHandler( void* arg ) nothrow @nogc
            {
                Thread  obj = cast(Thread) arg;
                assert( obj );

                // NOTE: If the thread terminated abnormally, just set it as
                //       not running and let thread_suspendAll remove it from
                //       the thread list.  This is safer and is consistent
                //       with the Windows thread code.
                atomicStore!(MemoryOrder.raw)(obj.m_isRunning,false);
            }

            // NOTE: Using void to skip the initialization here relies on
            //       knowledge of how pthread_cleanup is implemented.  It may
            //       not be appropriate for all platforms.  However, it does
            //       avoid the need to link the pthread module.  If any
            //       implementation actually requires default initialization
            //       then pthread_cleanup should be restructured to maintain
            //       the current lack of a link dependency.
            static if ( __traits( compiles, pthread_cleanup ) )
            {
                pthread_cleanup cleanup = void;
                cleanup.push( &thread_cleanupHandler, cast(void*) obj );
            }
            else static if ( __traits( compiles, pthread_cleanup_push ) )
            {
                pthread_cleanup_push( &thread_cleanupHandler, cast(void*) obj );
            }
            else
            {
                static assert( false, "Platform not supported." );
            }

            // NOTE: No GC allocations may occur until the stack pointers have
            //       been set and Thread.getThis returns a valid reference to
            //       this thread object (this latter condition is not strictly
            //       necessary on Windows but it should be followed for the
            //       sake of consistency).

            // TODO: Consider putting an auto exception object here (using
            //       alloca) forOutOfMemoryError plus something to track
            //       whether an exception is in-flight?

            void append( Throwable t )
            {
                if ( obj.m_unhandled is null )
                    obj.m_unhandled = t;
                else
                {
                    Throwable last = obj.m_unhandled;
                    while ( last.next !is null )
                        last = last.next;
                    last.next = t;
                }
            }

            try
            {
                rt_moduleTlsCtor();
                try
                {
                    obj.run();
                }
                catch ( Throwable t )
                {
                    append( t );
                }
                rt_moduleTlsDtor();
                version (Shared) cleanupLoadedLibraries();
            }
            catch ( Throwable t )
            {
                append( t );
            }

            // NOTE: Normal cleanup is handled by scope(exit).

            static if ( __traits( compiles, pthread_cleanup ) )
            {
                cleanup.pop( 0 );
            }
            else static if ( __traits( compiles, pthread_cleanup_push ) )
            {
                pthread_cleanup_pop( 0 );
            }

            return null;
        }


        //
        // Used to track the number of suspended threads
        //
        __gshared sem_t suspendCount;


        extern (C) void thread_suspendHandler( int sig ) nothrow
        in
        {
            assert( sig == suspendSignalNumber );
        }
        body
        {
            void op(void* sp) nothrow
            {
                // NOTE: Since registers are being pushed and popped from the
                //       stack, any other stack data used by this function should
                //       be gone before the stack cleanup code is called below.
                Thread obj = Thread.getThis();
                assert(obj !is null);

                if ( !obj.m_lock )
                {
                    obj.m_curr.tstack = getStackTop();
                }

                sigset_t    sigres = void;
                int         status;

                status = sigfillset( &sigres );
                assert( status == 0 );

                status = sigdelset( &sigres, resumeSignalNumber );
                assert( status == 0 );

                version (FreeBSD) obj.m_suspendagain = false;
                status = sem_post( &suspendCount );
                assert( status == 0 );

                sigsuspend( &sigres );

                if ( !obj.m_lock )
                {
                    obj.m_curr.tstack = obj.m_curr.bstack;
                }
            }

            // avoid deadlocks on FreeBSD, see Issue 13416
            version (FreeBSD)
            {
                auto obj = Thread.getThis();
                if (THR_IN_CRITICAL(obj.m_addr))
                {
                    obj.m_suspendagain = true;
                    if (sem_post(&suspendCount)) assert(0);
                    return;
                }
            }

            callWithStackShell(&op);
        }


        extern (C) void thread_resumeHandler( int sig ) nothrow
        in
        {
            assert( sig == resumeSignalNumber );
        }
        body
        {

        }

        // HACK libthr internal (thr_private.h) macro, used to
        // avoid deadlocks in signal handler, see Issue 13416
        version (FreeBSD) bool THR_IN_CRITICAL(pthread_t p) nothrow @nogc
        {
            import core.sys.posix.config : c_long;
            import core.sys.posix.sys.types : lwpid_t;

            // If the begin of pthread would be changed in libthr (unlikely)
            // we'll run into undefined behavior, compare with thr_private.h.
            static struct pthread
            {
                c_long tid;
                static struct umutex { lwpid_t owner; uint flags; uint[2] ceilings; uint[4] spare; }
                umutex lock;
                uint cycle;
                int locklevel;
                int critical_count;
                // ...
            }
            auto priv = cast(pthread*)p;
            return priv.locklevel > 0 || priv.critical_count > 0;
        }
    }
}
else
{
    // NOTE: This is the only place threading versions are checked.  If a new
    //       version is added, the module code will need to be searched for
    //       places where version-specific code may be required.  This can be
    //       easily accomlished by searching for 'Windows' or 'Posix'.
    static assert( false, "Unknown threading implementation." );
}


///////////////////////////////////////////////////////////////////////////////
// Thread
///////////////////////////////////////////////////////////////////////////////


/**
 * This class encapsulates all threading functionality for the D
 * programming language.  As thread manipulation is a required facility
 * for garbage collection, all user threads should derive from this
 * class, and instances of this class should never be explicitly deleted.
 * A new thread may be created using either derivation or composition, as
 * in the following example.
 */
class Thread
{
    ///////////////////////////////////////////////////////////////////////////
    // Initialization
    ///////////////////////////////////////////////////////////////////////////


    /**
     * Initializes a thread object which is associated with a static
     * D function.
     *
     * Params:
     *  fn = The thread function.
     *  sz = The stack size for this thread.
     *
     * In:
     *  fn must not be null.
     */
    this( void function() fn, size_t sz = 0 ) @safe pure nothrow @nogc
    in
    {
        assert( fn );
    }
    body
    {
        this(sz);
        () @trusted { m_fn   = fn; }();
        m_call = Call.FN;
        m_curr = &m_main;
    }


    /**
     * Initializes a thread object which is associated with a dynamic
     * D function.
     *
     * Params:
     *  dg = The thread function.
     *  sz = The stack size for this thread.
     *
     * In:
     *  dg must not be null.
     */
    this( void delegate() dg, size_t sz = 0 ) @safe pure nothrow @nogc
    in
    {
        assert( dg );
    }
    body
    {
        this(sz);
        () @trusted { m_dg   = dg; }();
        m_call = Call.DG;
        m_curr = &m_main;
    }


    /**
     * Cleans up any remaining resources used by this object.
     */
    ~this() nothrow @nogc
    {
        if ( m_addr == m_addr.init )
        {
            return;
        }

        version (Windows)
        {
            m_addr = m_addr.init;
            CloseHandle( m_hndl );
            m_hndl = m_hndl.init;
        }
        else version (Posix)
        {
            pthread_detach( m_addr );
            m_addr = m_addr.init;
        }
        version (Darwin)
        {
            m_tmach = m_tmach.init;
        }
        rt_tlsgc_destroy( m_tlsgcdata );
        m_tlsgcdata = null;
    }


    ///////////////////////////////////////////////////////////////////////////
    // General Actions
    ///////////////////////////////////////////////////////////////////////////


    /**
     * Starts the thread and invokes the function or delegate passed upon
     * construction.
     *
     * In:
     *  This routine may only be called once per thread instance.
     *
     * Throws:
     *  ThreadException if the thread fails to start.
     */
    final Thread start() nothrow
    in
    {
        assert( !next && !prev );
    }
    body
    {
        auto wasThreaded  = multiThreadedFlag;
        multiThreadedFlag = true;
        scope( failure )
        {
            if ( !wasThreaded )
                multiThreadedFlag = false;
        }

        version (Windows) {} else
        version (Posix)
        {
            pthread_attr_t  attr;

            if ( pthread_attr_init( &attr ) )
                onThreadError( "Error initializing thread attributes" );
            if ( m_sz && pthread_attr_setstacksize( &attr, m_sz ) )
                onThreadError( "Error initializing thread stack size" );
        }

        version (Windows)
        {
            // NOTE: If a thread is just executing DllMain()
            //       while another thread is started here, it holds an OS internal
            //       lock that serializes DllMain with CreateThread. As the code
            //       might request a synchronization on slock (e.g. in thread_findByAddr()),
            //       we cannot hold that lock while creating the thread without
            //       creating a deadlock
            //
            // Solution: Create the thread in suspended state and then
            //       add and resume it with slock acquired
            assert(m_sz <= uint.max, "m_sz must be less than or equal to uint.max");
            m_hndl = cast(HANDLE) _beginthreadex( null, cast(uint) m_sz, &thread_entryPoint, cast(void*) this, CREATE_SUSPENDED, &m_addr );
            if ( cast(size_t) m_hndl == 0 )
                onThreadError( "Error creating thread" );
        }

        slock.lock_nothrow();
        scope(exit) slock.unlock_nothrow();
        {
            ++nAboutToStart;
            pAboutToStart = cast(Thread*)realloc(pAboutToStart, Thread.sizeof * nAboutToStart);
            pAboutToStart[nAboutToStart - 1] = this;
            version (Windows)
            {
                if ( ResumeThread( m_hndl ) == -1 )
                    onThreadError( "Error resuming thread" );
            }
            else version (Posix)
            {
                // NOTE: This is also set to true by thread_entryPoint, but set it
                //       here as well so the calling thread will see the isRunning
                //       state immediately.
                atomicStore!(MemoryOrder.raw)(m_isRunning, true);
                scope( failure ) atomicStore!(MemoryOrder.raw)(m_isRunning, false);

                version (Shared)
                {
                    import rt.sections;
                    auto libs = pinLoadedLibraries();
                    auto ps = cast(void**).malloc(2 * size_t.sizeof);
                    if (ps is null) onOutOfMemoryError();
                    ps[0] = cast(void*)this;
                    ps[1] = cast(void*)libs;
                    if ( pthread_create( &m_addr, &attr, &thread_entryPoint, ps ) != 0 )
                    {
                        unpinLoadedLibraries(libs);
                        .free(ps);
                        onThreadError( "Error creating thread" );
                    }
                }
                else
                {
                    if ( pthread_create( &m_addr, &attr, &thread_entryPoint, cast(void*) this ) != 0 )
                        onThreadError( "Error creating thread" );
                }
            }
            version (Darwin)
            {
                m_tmach = pthread_mach_thread_np( m_addr );
                if ( m_tmach == m_tmach.init )
                    onThreadError( "Error creating thread" );
            }

            return this;
        }
    }

    /**
     * Waits for this thread to complete.  If the thread terminated as the
     * result of an unhandled exception, this exception will be rethrown.
     *
     * Params:
     *  rethrow = Rethrow any unhandled exception which may have caused this
     *            thread to terminate.
     *
     * Throws:
     *  ThreadException if the operation fails.
     *  Any exception not handled by the joined thread.
     *
     * Returns:
     *  Any exception not handled by this thread if rethrow = false, null
     *  otherwise.
     */
    final Throwable join( bool rethrow = true )
    {
        version (Windows)
        {
            if ( WaitForSingleObject( m_hndl, INFINITE ) != WAIT_OBJECT_0 )
                throw new ThreadException( "Unable to join thread" );
            // NOTE: m_addr must be cleared before m_hndl is closed to avoid
            //       a race condition with isRunning. The operation is done
            //       with atomicStore to prevent compiler reordering.
            atomicStore!(MemoryOrder.raw)(*cast(shared)&m_addr, m_addr.init);
            CloseHandle( m_hndl );
            m_hndl = m_hndl.init;
        }
        else version (Posix)
        {
            if ( pthread_join( m_addr, null ) != 0 )
                throw new ThreadException( "Unable to join thread" );
            // NOTE: pthread_join acts as a substitute for pthread_detach,
            //       which is normally called by the dtor.  Setting m_addr
            //       to zero ensures that pthread_detach will not be called
            //       on object destruction.
            m_addr = m_addr.init;
        }
        if ( m_unhandled )
        {
            if ( rethrow )
                throw m_unhandled;
            return m_unhandled;
        }
        return null;
    }


    ///////////////////////////////////////////////////////////////////////////
    // General Properties
    ///////////////////////////////////////////////////////////////////////////


    /**
     * Gets the OS identifier for this thread.
     *
     * Returns:
     *  If the thread hasn't been started yet, returns $(LREF ThreadID)$(D.init).
     *  Otherwise, returns the result of $(D GetCurrentThreadId) on Windows,
     *  and $(D pthread_self) on POSIX.
     *
     *  The value is unique for the current process.
     */
    final @property ThreadID id() @safe @nogc
    {
        synchronized( this )
        {
            return m_addr;
        }
    }


    /**
     * Gets the user-readable label for this thread.
     *
     * Returns:
     *  The name of this thread.
     */
    final @property string name() @safe @nogc
    {
        synchronized( this )
        {
            return m_name;
        }
    }


    /**
     * Sets the user-readable label for this thread.
     *
     * Params:
     *  val = The new name of this thread.
     */
    final @property void name( string val ) @safe @nogc
    {
        synchronized( this )
        {
            m_name = val;
        }
    }


    /**
     * Gets the daemon status for this thread.  While the runtime will wait for
     * all normal threads to complete before tearing down the process, daemon
     * threads are effectively ignored and thus will not prevent the process
     * from terminating.  In effect, daemon threads will be terminated
     * automatically by the OS when the process exits.
     *
     * Returns:
     *  true if this is a daemon thread.
     */
    final @property bool isDaemon() @safe @nogc
    {
        synchronized( this )
        {
            return m_isDaemon;
        }
    }


    /**
     * Sets the daemon status for this thread.  While the runtime will wait for
     * all normal threads to complete before tearing down the process, daemon
     * threads are effectively ignored and thus will not prevent the process
     * from terminating.  In effect, daemon threads will be terminated
     * automatically by the OS when the process exits.
     *
     * Params:
     *  val = The new daemon status for this thread.
     */
    final @property void isDaemon( bool val ) @safe @nogc
    {
        synchronized( this )
        {
            m_isDaemon = val;
        }
    }


    /**
     * Tests whether this thread is running.
     *
     * Returns:
     *  true if the thread is running, false if not.
     */
    final @property bool isRunning() nothrow @nogc
    {
        if ( m_addr == m_addr.init )
        {
            return false;
        }

        version (Windows)
        {
            uint ecode = 0;
            GetExitCodeThread( m_hndl, &ecode );
            return ecode == STILL_ACTIVE;
        }
        else version (Posix)
        {
            return atomicLoad(m_isRunning);
        }
    }


    ///////////////////////////////////////////////////////////////////////////
    // Thread Priority Actions
    ///////////////////////////////////////////////////////////////////////////

    version (Windows)
    {
        @property static int PRIORITY_MIN() @nogc nothrow pure @safe
        {
            return THREAD_PRIORITY_IDLE;
        }

        @property static const(int) PRIORITY_MAX() @nogc nothrow pure @safe
        {
            return THREAD_PRIORITY_TIME_CRITICAL;
        }

        @property static int PRIORITY_DEFAULT() @nogc nothrow pure @safe
        {
            return THREAD_PRIORITY_NORMAL;
        }
    }
    else
    {
        private struct Priority
        {
            int PRIORITY_MIN = int.min;
            int PRIORITY_DEFAULT = int.min;
            int PRIORITY_MAX = int.min;
        }

        /*
        Lazily loads one of the members stored in a hidden global variable of
        type `Priority`. Upon the first access of either member, the entire
        `Priority` structure is initialized. Multiple initializations from
        different threads calling this function are tolerated.

        `which` must be one of `PRIORITY_MIN`, `PRIORITY_DEFAULT`,
        `PRIORITY_MAX`.
        */
        private static int loadGlobal(string which)()
        {
            static shared Priority cache;
            auto local = atomicLoad(mixin("cache." ~ which));
            if (local != local.min) return local;
            // There will be benign races
            cache = loadPriorities;
            return atomicLoad(mixin("cache." ~ which));
        }

        /*
        Loads all priorities and returns them as a `Priority` structure. This
        function is thread-neutral.
        */
        private static Priority loadPriorities() @nogc nothrow @trusted
        {
            Priority result;
            version (Solaris)
            {
                pcparms_t pcParms;
                pcinfo_t pcInfo;

                pcParms.pc_cid = PC_CLNULL;
                if (priocntl(idtype_t.P_PID, P_MYID, PC_GETPARMS, &pcParms) == -1)
                    assert( 0, "Unable to get scheduling class" );

                pcInfo.pc_cid = pcParms.pc_cid;
                // PC_GETCLINFO ignores the first two args, use dummy values
                if (priocntl(idtype_t.P_PID, 0, PC_GETCLINFO, &pcInfo) == -1)
                    assert( 0, "Unable to get scheduling class info" );

                pri_t* clparms = cast(pri_t*)&pcParms.pc_clparms;
                pri_t* clinfo = cast(pri_t*)&pcInfo.pc_clinfo;

                result.PRIORITY_MAX = clparms[0];

                if (pcInfo.pc_clname == "RT")
                {
                    m_isRTClass = true;

                    // For RT class, just assume it can't be changed
                    result.PRIORITY_MIN = clparms[0];
                    result.PRIORITY_DEFAULT = clparms[0];
                }
                else
                {
                    m_isRTClass = false;

                    // For all other scheduling classes, there are
                    // two key values -- uprilim and maxupri.
                    // maxupri is the maximum possible priority defined
                    // for the scheduling class, and valid priorities
                    // range are in [-maxupri, maxupri].
                    //
                    // However, uprilim is an upper limit that the
                    // current thread can set for the current scheduling
                    // class, which can be less than maxupri.  As such,
                    // use this value for priorityMax since this is
                    // the effective maximum.

                    // maxupri
                    result.PRIORITY_MIN = -clinfo[0];
                    // by definition
                    result.PRIORITY_DEFAULT = 0;
                }
            }
            else version (Posix)
            {
                int         policy;
                sched_param param;
                pthread_getschedparam( pthread_self(), &policy, &param ) == 0
                    || assert(0, "Internal error in pthread_getschedparam");

                result.PRIORITY_MIN = sched_get_priority_min( policy );
                result.PRIORITY_MIN != -1
                    || assert(0, "Internal error in sched_get_priority_min");
                result.PRIORITY_DEFAULT = param.sched_priority;
                result.PRIORITY_MAX = sched_get_priority_max( policy );
                result.PRIORITY_MAX != -1 ||
                    assert(0, "Internal error in sched_get_priority_max");
            }
            else
            {
                static assert(0, "Your code here.");
            }
            return result;
        }

        /**
         * The minimum scheduling priority that may be set for a thread.  On
         * systems where multiple scheduling policies are defined, this value
         * represents the minimum valid priority for the scheduling policy of
         * the process.
         */
        @property static int PRIORITY_MIN() @nogc nothrow pure @trusted
        {
            return (cast(int function() @nogc nothrow pure @safe)
                &loadGlobal!"PRIORITY_MIN")();
        }

        /**
         * The maximum scheduling priority that may be set for a thread.  On
         * systems where multiple scheduling policies are defined, this value
         * represents the maximum valid priority for the scheduling policy of
         * the process.
         */
        @property static const(int) PRIORITY_MAX() @nogc nothrow pure @trusted
        {
            return (cast(int function() @nogc nothrow pure @safe)
                &loadGlobal!"PRIORITY_MAX")();
        }

        /**
         * The default scheduling priority that is set for a thread.  On
         * systems where multiple scheduling policies are defined, this value
         * represents the default priority for the scheduling policy of
         * the process.
         */
        @property static int PRIORITY_DEFAULT() @nogc nothrow pure @trusted
        {
            return (cast(int function() @nogc nothrow pure @safe)
                &loadGlobal!"PRIORITY_DEFAULT")();
        }
    }

    version (NetBSD)
    {
        //NetBSD does not support priority for default policy
        // and it is not possible change policy without root access
        int fakePriority = int.max;
    }

    /**
     * Gets the scheduling priority for the associated thread.
     *
     * Note: Getting the priority of a thread that already terminated
     * might return the default priority.
     *
     * Returns:
     *  The scheduling priority of this thread.
     */
    final @property int priority()
    {
        version (Windows)
        {
            return GetThreadPriority( m_hndl );
        }
        else version (NetBSD)
        {
           return fakePriority==int.max? PRIORITY_DEFAULT : fakePriority;
        }
        else version (Posix)
        {
            int         policy;
            sched_param param;

            if (auto err = pthread_getschedparam(m_addr, &policy, &param))
            {
                // ignore error if thread is not running => Bugzilla 8960
                if (!atomicLoad(m_isRunning)) return PRIORITY_DEFAULT;
                throw new ThreadException("Unable to get thread priority");
            }
            return param.sched_priority;
        }
    }


    /**
     * Sets the scheduling priority for the associated thread.
     *
     * Note: Setting the priority of a thread that already terminated
     * might have no effect.
     *
     * Params:
     *  val = The new scheduling priority of this thread.
     */
    final @property void priority( int val )
    in
    {
        assert(val >= PRIORITY_MIN);
        assert(val <= PRIORITY_MAX);
    }
    body
    {
        version (Windows)
        {
            if ( !SetThreadPriority( m_hndl, val ) )
                throw new ThreadException( "Unable to set thread priority" );
        }
        else version (Solaris)
        {
            // the pthread_setschedprio(3c) and pthread_setschedparam functions
            // are broken for the default (TS / time sharing) scheduling class.
            // instead, we use priocntl(2) which gives us the desired behavior.

            // We hardcode the min and max priorities to the current value
            // so this is a no-op for RT threads.
            if (m_isRTClass)
                return;

            pcparms_t   pcparm;

            pcparm.pc_cid = PC_CLNULL;
            if (priocntl(idtype_t.P_LWPID, P_MYID, PC_GETPARMS, &pcparm) == -1)
                throw new ThreadException( "Unable to get scheduling class" );

            pri_t* clparms = cast(pri_t*)&pcparm.pc_clparms;

            // clparms is filled in by the PC_GETPARMS call, only necessary
            // to adjust the element that contains the thread priority
            clparms[1] = cast(pri_t) val;

            if (priocntl(idtype_t.P_LWPID, P_MYID, PC_SETPARMS, &pcparm) == -1)
                throw new ThreadException( "Unable to set scheduling class" );
        }
        else version (NetBSD)
        {
           fakePriority = val;
        }
        else version (Posix)
        {
            static if (__traits(compiles, pthread_setschedprio))
            {
                if (auto err = pthread_setschedprio(m_addr, val))
                {
                    // ignore error if thread is not running => Bugzilla 8960
                    if (!atomicLoad(m_isRunning)) return;
                    throw new ThreadException("Unable to set thread priority");
                }
            }
            else
            {
                // NOTE: pthread_setschedprio is not implemented on Darwin, FreeBSD or DragonFlyBSD, so use
                //       the more complicated get/set sequence below.
                int         policy;
                sched_param param;

                if (auto err = pthread_getschedparam(m_addr, &policy, &param))
                {
                    // ignore error if thread is not running => Bugzilla 8960
                    if (!atomicLoad(m_isRunning)) return;
                    throw new ThreadException("Unable to set thread priority");
                }
                param.sched_priority = val;
                if (auto err = pthread_setschedparam(m_addr, policy, &param))
                {
                    // ignore error if thread is not running => Bugzilla 8960
                    if (!atomicLoad(m_isRunning)) return;
                    throw new ThreadException("Unable to set thread priority");
                }
            }
        }
    }


    unittest
    {
        auto thr = Thread.getThis();
        immutable prio = thr.priority;
        scope (exit) thr.priority = prio;

        assert(prio == PRIORITY_DEFAULT);
        assert(prio >= PRIORITY_MIN && prio <= PRIORITY_MAX);
        thr.priority = PRIORITY_MIN;
        assert(thr.priority == PRIORITY_MIN);
        thr.priority = PRIORITY_MAX;
        assert(thr.priority == PRIORITY_MAX);
    }

    unittest // Bugzilla 8960
    {
        import core.sync.semaphore;

        auto thr = new Thread({});
        thr.start();
        Thread.sleep(1.msecs);       // wait a little so the thread likely has finished
        thr.priority = PRIORITY_MAX; // setting priority doesn't cause error
        auto prio = thr.priority;    // getting priority doesn't cause error
        assert(prio >= PRIORITY_MIN && prio <= PRIORITY_MAX);
    }

    ///////////////////////////////////////////////////////////////////////////
    // Actions on Calling Thread
    ///////////////////////////////////////////////////////////////////////////


    /**
     * Suspends the calling thread for at least the supplied period.  This may
     * result in multiple OS calls if period is greater than the maximum sleep
     * duration supported by the operating system.
     *
     * Params:
     *  val = The minimum duration the calling thread should be suspended.
     *
     * In:
     *  period must be non-negative.
     *
     * Example:
     * ------------------------------------------------------------------------
     *
     * Thread.sleep( dur!("msecs")( 50 ) );  // sleep for 50 milliseconds
     * Thread.sleep( dur!("seconds")( 5 ) ); // sleep for 5 seconds
     *
     * ------------------------------------------------------------------------
     */
    static void sleep( Duration val ) @nogc nothrow
    in
    {
        assert( !val.isNegative );
    }
    body
    {
        version (Windows)
        {
            auto maxSleepMillis = dur!("msecs")( uint.max - 1 );

            // avoid a non-zero time to be round down to 0
            if ( val > dur!"msecs"( 0 ) && val < dur!"msecs"( 1 ) )
                val = dur!"msecs"( 1 );

            // NOTE: In instances where all other threads in the process have a
            //       lower priority than the current thread, the current thread
            //       will not yield with a sleep time of zero.  However, unlike
            //       yield(), the user is not asking for a yield to occur but
            //       only for execution to suspend for the requested interval.
            //       Therefore, expected performance may not be met if a yield
            //       is forced upon the user.
            while ( val > maxSleepMillis )
            {
                Sleep( cast(uint)
                       maxSleepMillis.total!"msecs" );
                val -= maxSleepMillis;
            }
            Sleep( cast(uint) val.total!"msecs" );
        }
        else version (Posix)
        {
            timespec tin  = void;
            timespec tout = void;

            val.split!("seconds", "nsecs")(tin.tv_sec, tin.tv_nsec);
            if ( val.total!"seconds" > tin.tv_sec.max )
                tin.tv_sec  = tin.tv_sec.max;
            while ( true )
            {
                if ( !nanosleep( &tin, &tout ) )
                    return;
                if ( errno != EINTR )
                    assert(0, "Unable to sleep for the specified duration");
                tin = tout;
            }
        }
    }


    /**
     * Forces a context switch to occur away from the calling thread.
     */
    static void yield() @nogc nothrow
    {
        version (Windows)
            SwitchToThread();
        else version (Posix)
            sched_yield();
    }


    ///////////////////////////////////////////////////////////////////////////
    // Thread Accessors
    ///////////////////////////////////////////////////////////////////////////

    /**
     * Provides a reference to the calling thread.
     *
     * Returns:
     *  The thread object representing the calling thread.  The result of
     *  deleting this object is undefined.  If the current thread is not
     *  attached to the runtime, a null reference is returned.
     */
    static Thread getThis() @safe nothrow @nogc
    {
        // NOTE: This function may not be called until thread_init has
        //       completed.  See thread_suspendAll for more information
        //       on why this might occur.
        return sm_this;
    }


    /**
     * Provides a list of all threads currently being tracked by the system.
     * Note that threads in the returned array might no longer run (see
     * $(D Thread.)$(LREF isRunning)).
     *
     * Returns:
     *  An array containing references to all threads currently being
     *  tracked by the system.  The result of deleting any contained
     *  objects is undefined.
     */
    static Thread[] getAll()
    {
        static void resize(ref Thread[] buf, size_t nlen)
        {
            buf.length = nlen;
        }
        return getAllImpl!resize();
    }


    /**
     * Operates on all threads currently being tracked by the system.  The
     * result of deleting any Thread object is undefined.
     * Note that threads passed to the callback might no longer run (see
     * $(D Thread.)$(LREF isRunning)).
     *
     * Params:
     *  dg = The supplied code as a delegate.
     *
     * Returns:
     *  Zero if all elemented are visited, nonzero if not.
     */
    static int opApply(scope int delegate(ref Thread) dg)
    {
        import core.stdc.stdlib : free, realloc;

        static void resize(ref Thread[] buf, size_t nlen)
        {
            buf = (cast(Thread*)realloc(buf.ptr, nlen * Thread.sizeof))[0 .. nlen];
        }
        auto buf = getAllImpl!resize;
        scope(exit) if (buf.ptr) free(buf.ptr);

        foreach (t; buf)
        {
            if (auto res = dg(t))
                return res;
        }
        return 0;
    }

    unittest
    {
        auto t1 = new Thread({
            foreach (_; 0 .. 20)
                Thread.getAll;
        }).start;
        auto t2 = new Thread({
            foreach (_; 0 .. 20)
                GC.collect;
        }).start;
        t1.join();
        t2.join();
    }

    private static Thread[] getAllImpl(alias resize)()
    {
        import core.atomic;

        Thread[] buf;
        while (true)
        {
            immutable len = atomicLoad!(MemoryOrder.raw)(*cast(shared)&sm_tlen);
            resize(buf, len);
            assert(buf.length == len);
            synchronized (slock)
            {
                if (len == sm_tlen)
                {
                    size_t pos;
                    for (Thread t = sm_tbeg; t; t = t.next)
                        buf[pos++] = t;
                    return buf;
                }
            }
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // Stuff That Should Go Away
    ///////////////////////////////////////////////////////////////////////////


private:
    //
    // Initializes a thread object which has no associated executable function.
    // This is used for the main thread initialized in thread_init().
    //
    this(size_t sz = 0) @safe pure nothrow @nogc
    {
        if (sz)
        {
            version (Posix)
            {
                // stack size must be a multiple of PAGESIZE
                sz += PAGESIZE - 1;
                sz -= sz % PAGESIZE;
                // and at least PTHREAD_STACK_MIN
                if (PTHREAD_STACK_MIN > sz)
                    sz = PTHREAD_STACK_MIN;
            }
            m_sz = sz;
        }
        m_call = Call.NO;
        m_curr = &m_main;
    }


    //
    // Thread entry point.  Invokes the function or delegate passed on
    // construction (if any).
    //
    final void run()
    {
        switch ( m_call )
        {
        case Call.FN:
            m_fn();
            break;
        case Call.DG:
            m_dg();
            break;
        default:
            break;
        }
    }


private:
    //
    // The type of routine passed on thread construction.
    //
    enum Call
    {
        NO,
        FN,
        DG
    }


    //
    // Standard types
    //
    version (Windows)
    {
        alias TLSKey = uint;
    }
    else version (Posix)
    {
        alias TLSKey = pthread_key_t;
    }


    //
    // Local storage
    //
    static Thread       sm_this;


    //
    // Main process thread
    //
    __gshared Thread    sm_main;

    version (FreeBSD)
    {
        // set when suspend failed and should be retried, see Issue 13416
        shared bool m_suspendagain;
    }


    //
    // Standard thread data
    //
    version (Windows)
    {
        HANDLE          m_hndl;
    }
    else version (Darwin)
    {
        mach_port_t     m_tmach;
    }
    ThreadID            m_addr;
    Call                m_call;
    string              m_name;
    union
    {
        void function() m_fn;
        void delegate() m_dg;
    }
    size_t              m_sz;
    version (Posix)
    {
        shared bool     m_isRunning;
    }
    bool                m_isDaemon;
    bool                m_isInCriticalRegion;
    Throwable           m_unhandled;

    version (Solaris)
    {
        __gshared bool m_isRTClass;
    }

private:
    ///////////////////////////////////////////////////////////////////////////
    // Storage of Active Thread
    ///////////////////////////////////////////////////////////////////////////


    //
    // Sets a thread-local reference to the current thread object.
    //
    static void setThis( Thread t ) nothrow @nogc
    {
        sm_this = t;
    }


private:
    ///////////////////////////////////////////////////////////////////////////
    // Thread Context and GC Scanning Support
    ///////////////////////////////////////////////////////////////////////////


    final void pushContext( Context* c ) nothrow @nogc
    in
    {
        assert( !c.within );
    }
    body
    {
        m_curr.ehContext = swapCoð0  ñ0  ò0  ó0  ô0  õ0  ö0  ÷0  ø0  ù0  ú0  û0  ü0  ý0  þ0  ÿ0   1  1  1  1  1  1  1  1  1  	1  
1  1  1  1  1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ntext(c.ehContext);
        c.within = m_curr;
        m_curr = c;
    }


    final void popContext() nothrow @nogc
    in
    {
        assert( m_curr && m_curr.within );
    }
    body
    {
        Context* c = m_curr;
        m_curr = c.within;
        c.ehContext = swapContext(m_curr.ehContext);
        c.within = null;
    }


    final Context* topContext() nothrow @nogc
    in
    {
        assert( m_curr );
    }
    body
    {
        return m_curr;
    }


    static struct Context
    {
        void*           bstack,
                        tstack;

        /// Slot for the EH implementation to keep some state for each stack
        /// (will be necessary for exception chaining, etc.). Opaque as far as
        /// we are concerned here.
        void*           ehContext;

        Context*        within;
        Context*        next,
                        prev;
    }


    Context             m_main;
    Context*            m_curr;
    bool                m_lock;
    void*               m_tlsgcdata;

    version (Windows)
    {
      version (X86)
      {
        uint[8]         m_reg; // edi,esi,ebp,esp,ebx,edx,ecx,eax
      }
      else version (X86_64)
      {
        ulong[16]       m_reg; // rdi,rsi,rbp,rsp,rbx,rdx,rcx,rax
                               // r8,r9,r10,r11,r12,r13,r14,r15
      }
      else
      {
        static assert(false, "Architecture not supported." );
      }
    }
    else version (Darwin)
    {
      version (X86)
      {
        uint[8]         m_reg; // edi,esi,ebp,esp,ebx,edx,ecx,eax
      }
      else version (X86_64)
      {
        ulong[16]       m_reg; // rdi,rsi,rbp,rsp,rbx,rdx,rcx,rax
                               // r8,r9,r10,r11,r12,r13,r14,r15
      }
      else
      {
        static assert(false, "Architecture not supported." );
      }
    }


private:
    ///////////////////////////////////////////////////////////////////////////
    // GC Scanning Support
    ///////////////////////////////////////////////////////////////////////////


    // NOTE: The GC scanning process works like so:
    //
    //          1. Suspend all threads.
    //          2. Scan the stacks of all suspended threads for roots.
    //          3. Resume all threads.
    //
    //       Step 1 and 3 require a list of all threads in the system, while
    //       step 2 requires a list of all thread stacks (each represented by
    //       a Context struct).  Traditionally, there was one stack per thread
    //       and the Context structs were not necessary.  However, Fibers have
    //       changed things so that each thread has its own 'main' stack plus
    //       an arbitrary number of nested stacks (normally referenced via
    //       m_curr).  Also, there may be 'free-floating' stacks in the system,
    //       which are Fibers that are not currently executing on any specific
    //       thread but are still being processed and still contain valid
    //       roots.
    //
    //       To support all of this, the Context struct has been created to
    //       represent a stack range, and a global list of Context structs has
    //       been added to enable scanning of these stack ranges.  The lifetime
    //       (and presence in the Context list) of a thread's 'main' stack will
    //       be equivalent to the thread's lifetime.  So the Ccontext will be
    //       added to the list on thread entry, and removed from the list on
    //       thread exit (which is essentially the same as the presence of a
    //       Thread object in its own global list).  The lifetime of a Fiber's
    //       context, however, will be tied to the lifetime of the Fiber object
    //       itself, and Fibers are expected to add/remove their Context struct
    //       on construction/deletion.


    //
    // All use of the global thread lists/array should synchronize on this lock.
    //
    // Careful as the GC acquires this lock after the GC lock to suspend all
    // threads any GC usage with slock held can result in a deadlock through
    // lock order inversion.
    @property static Mutex slock() nothrow @nogc
    {
        return cast(Mutex)_slock.ptr;
    }

    @property static Mutex criticalRegionLock() nothrow @nogc
    {
        return cast(Mutex)_criticalRegionLock.ptr;
    }

    __gshared align(mutexAlign) void[mutexClassInstanceSize] _slock;
    __gshared align(mutexAlign) void[mutexClassInstanceSize] _criticalRegionLock;

    static void initLocks()
    {
        _slock[] = typeid(Mutex).initializer[];
        (cast(Mutex)_slock.ptr).__ctor();

        _criticalRegionLock[] = typeid(Mutex).initializer[];
        (cast(Mutex)_criticalRegionLock.ptr).__ctor();
    }

    static void termLocks()
    {
        (cast(Mutex)_slock.ptr).__dtor();
        (cast(Mutex)_criticalRegionLock.ptr).__dtor();
    }

    __gshared Context*  sm_cbeg;

    __gshared Thread    sm_tbeg;
    __gshared size_t    sm_tlen;

    // can't use rt.util.array in public code
    __gshared Thread* pAboutToStart;
    __gshared size_t nAboutToStart;

    //
    // Used for ordering threads in the global thread list.
    //
    Thread              prev;
    Thread              next;


    ///////////////////////////////////////////////////////////////////////////
    // Global Context List Operations
    ///////////////////////////////////////////////////////////////////////////


    //
    // Add a context to the global context list.
    //
    static void add( Context* c ) nothrow @nogc
    in
    {
        assert( c );
        assert( !c.next && !c.prev );
    }
    body
    {
        slock.lock_nothrow();
        scope(exit) slock.unlock_nothrow();
        assert(!suspendDepth); // must be 0 b/c it's only set with slock held

        if (sm_cbeg)
        {
            c.next = sm_cbeg;
            sm_cbeg.prev = c;
        }
        sm_cbeg = c;
    }


    //
    // Remove a context from the global context list.
    //
    // This assumes slock being acquired. This isn't done here to
    // avoid double locking when called from remove(Thread)
    static void remove( Context* c ) nothrow @nogc
    in
    {
        assert( c );
        assert( c.next || c.prev );
    }
    body
    {
        if ( c.prev )
            c.prev.next = c.next;
        if ( c.next )
            c.next.prev = c.prev;
        if ( sm_cbeg == c )
            sm_cbeg = c.next;
        // NOTE: Don't null out c.next or c.prev because opApply currently
        //       follows c.next after removing a node.  This could be easily
        //       addressed by simply returning the next node from this
        //       function, however, a context should never be re-added to the
        //       list anyway and having next and prev be non-null is a good way
        //       to ensure that.
    }


    ///////////////////////////////////////////////////////////////////////////
    // Global Thread List Operations
    ///////////////////////////////////////////////////////////////////////////


    //
    // Add a thread to the global thread list.
    //
    static void add( Thread t, bool rmAboutToStart = true ) nothrow @nogc
    in
    {
        assert( t );
        assert( !t.next && !t.prev );
    }
    body
    {
        slock.lock_nothrow();
        scope(exit) slock.unlock_nothrow();
        assert(t.isRunning); // check this with slock to ensure pthread_create already returned
        assert(!suspendDepth); // must be 0 b/c it's only set with slock held

        if (rmAboutToStart)
        {
            size_t idx = -1;
            foreach (i, thr; pAboutToStart[0 .. nAboutToStart])
            {
                if (thr is t)
                {
                    idx = i;
                    break;
                }
            }
            assert(idx != -1);
            import core.stdc.string : memmove;
            memmove(pAboutToStart + idx, pAboutToStart + idx + 1, Thread.sizeof * (nAboutToStart - idx - 1));
            pAboutToStart =
                cast(Thread*)realloc(pAboutToStart, Thread.sizeof * --nAboutToStart);
        }

        if (sm_tbeg)
        {
            t.next = sm_tbeg;
            sm_tbeg.prev = t;
        }
        sm_tbeg = t;
        ++sm_tlen;
    }


    //
    // Remove a thread from the global thread list.
    //
    static void remove( Thread t ) nothrow @nogc
    in
    {
        assert( t );
    }
    body
    {
        // Thread was already removed earlier, might happen b/c of thread_detachInstance
        if (!t.next && !t.prev)
            return;
        slock.lock_nothrow();
        {
            // NOTE: When a thread is removed from the global thread list its
            //       main context is invalid and should be removed as well.
            //       It is possible that t.m_curr could reference more
            //       than just the main context if the thread exited abnormally
            //       (if it was terminated), but we must assume that the user
            //       retains a reference to them and that they may be re-used
            //       elsewhere.  Therefore, it is the responsibility of any
            //       object that creates contexts to clean them up properly
            //       when it is done with them.
            remove( &t.m_main );

            if ( t.prev )
                t.prev.next = t.next;
            if ( t.next )
                t.next.prev = t.prev;
            if ( sm_tbeg is t )
                sm_tbeg = t.next;
            t.prev = t.next = null;
            --sm_tlen;
        }
        // NOTE: Don't null out t.next or t.prev because opApply currently
        //       follows t.next after removing a node.  This could be easily
        //       addressed by simply returning the next node from this
        //       function, however, a thread should never be re-added to the
        //       list anyway and having next and prev be non-null is a good way
        //       to ensure that.
        slock.unlock_nothrow();
    }
}

///
unittest
{
    class DerivedThread : Thread
    {
        this()
        {
            super(&run);
        }

    private:
        void run()
        {
            // Derived thread running.
        }
    }

    void threadFunc()
    {
        // Composed thread running.
    }

    // create and start instances of each type
    auto derived = new DerivedThread().start();
    auto composed = new Thread(&threadFunc).start();
    new Thread({
        // Codes to run in the newly created thread.
    }).start();
}

unittest
{
    int x = 0;

    new Thread(
    {
        x++;
    }).start().join();
    assert( x == 1 );
}


unittest
{
    enum MSG = "Test message.";
    string caughtMsg;

    try
    {
        new Thread(
        {
            throw new Exception( MSG );
        }).start().join();
        assert( false, "Expected rethrown exception." );
    }
    catch ( Throwable t )
    {
        assert( t.msg == MSG );
    }
}


///////////////////////////////////////////////////////////////////////////////
// GC Support Routines
///////////////////////////////////////////////////////////////////////////////

version (CoreDdoc)
{
    /**
     * Instruct the thread module, when initialized, to use a different set of
     * signals besides SIGUSR1 and SIGUSR2 for suspension and resumption of threads.
     * This function should be called at most once, prior to thread_init().
     * This function is Posix-only.
     */
    extern (C) void thread_setGCSignals(int suspendSignalNo, int resumeSignalNo) nothrow @nogc
    {
    }
}
else version (Posix)
{
    extern (C) void thread_setGCSignals(int suspendSignalNo, int resumeSignalNo) nothrow @nogc
    in
    {
        assert(suspendSignalNumber == 0);
        assert(resumeSignalNumber  == 0);
        assert(suspendSignalNo != 0);
        assert(resumeSignalNo  != 0);
    }
    out
    {
        assert(suspendSignalNumber != 0);
        assert(resumeSignalNumber  != 0);
    }
    body
    {
        suspendSignalNumber = suspendSignalNo;
        resumeSignalNumber  = resumeSignalNo;
    }
}

version (Posix)
{
    __gshared int suspendSignalNumber;
    __gshared int resumeSignalNumber;
}

/**
 * Initializes the thread module.  This function must be called by the
 * garbage collector on startup and before any other thread routines
 * are called.
 */
extern (C) void thread_init()
{
    // NOTE: If thread_init itself performs any allocations then the thread
    //       routines reserved for garbage collector use may be called while
    //       thread_init is being processed.  However, since no memory should
    //       exist to be scanned at this point, it is sufficient for these
    //       functions to detect the condition and return immediately.

    Thread.initLocks();
    // The Android VM runtime intercepts SIGUSR1 and apparently doesn't allow
    // its signal handler to run, so swap the two signals on Android, since
    // thread_resumeHandler does nothing.
    version (Android) thread_setGCSignals(SIGUSR2, SIGUSR1);

    version (Darwin)
    {
    }
    else version (Posix)
    {
        if ( suspendSignalNumber == 0 )
        {
            suspendSignalNumber = SIGUSR1;
        }

        if ( resumeSignalNumber == 0 )
        {
            resumeSignalNumber = SIGUSR2;
        }

        int         status;
        sigaction_t sigusr1 = void;
        sigaction_t sigusr2 = void;

        // This is a quick way to zero-initialize the structs without using
        // memset or creating a link dependency on their static initializer.
        (cast(byte*) &sigusr1)[0 .. sigaction_t.sizeof] = 0;
        (cast(byte*) &sigusr2)[0 .. sigaction_t.sizeof] = 0;

        // NOTE: SA_RESTART indicates that system calls should restart if they
        //       are interrupted by a signal, but this is not available on all
        //       Posix systems, even those that support multithreading.
        static if ( __traits( compiles, SA_RESTART ) )
            sigusr1.sa_flags = SA_RESTART;
        else
            sigusr1.sa_flags   = 0;
        sigusr1.sa_handler = &thread_suspendHandler;
        // NOTE: We want to ignore all signals while in this handler, so fill
        //       sa_mask to indicate this.
        status = sigfillset( &sigusr1.sa_mask );
        assert( status == 0 );

        // NOTE: Since resumeSignalNumber should only be issued for threads within the
        //       suspend handler, we don't want this signal to trigger a
        //       restart.
        sigusr2.sa_flags   = 0;
        sigusr2.sa_handler = &thread_resumeHandler;
        // NOTE: We want to ignore all signals while in this handler, so fill
        //       sa_mask to indicate this.
        status = sigfillset( &sigusr2.sa_mask );
        assert( status == 0 );

        status = sigaction( suspendSignalNumber, &sigusr1, null );
        assert( status == 0 );

        status = sigaction( resumeSignalNumber, &sigusr2, null );
        assert( status == 0 );

        status = sem_init( &suspendCount, 0, 0 );
        assert( status == 0 );
    }
    Thread.sm_main = thread_attachThis();
}


/**
 * Terminates the thread module. No other thread routine may be called
 * afterwards.
 */
extern (C) void thread_term()
{
    assert(Thread.sm_tbeg && Thread.sm_tlen == 1);
    assert(!Thread.nAboutToStart);
    if (Thread.pAboutToStart) // in case realloc(p, 0) doesn't return null
    {
        free(Thread.pAboutToStart);
        Thread.pAboutToStart = null;
    }
    Thread.termLocks();
}


/**
 *
 */
extern (C) bool thread_isMainThread() nothrow @nogc
{
    return Thread.getThis() is Thread.sm_main;
}


/**
 * Registers the calling thread for use with the D Runtime.  If this routine
 * is called for a thread which is already registered, no action is performed.
 *
 * NOTE: This routine does not run thread-local static constructors when called.
 *       If full functionality as a D thread is desired, the following function
 *       must be called after thread_attachThis:
 *
 *       extern (C) void rt_moduleTlsCtor();
 */
extern (C) Thread thread_attachThis()
{
    GC.disable(); scope(exit) GC.enable();

    if (auto t = Thread.getThis())
        return t;

    Thread          thisThread  = new Thread();
    Thread.Context* thisContext = &thisThread.m_main;
    assert( thisContext == thisThread.m_curr );

    version (Windows)
    {
        thisThread.m_addr  = GetCurrentThreadId();
        thisThread.m_hndl  = GetCurrentThreadHandle();
        thisContext.bstack = getStackBottom();
        thisContext.tstack = thisContext.bstack;
    }
    else version (Posix)
    {
        thisThread.m_addr  = pthread_self();
        thisContext.bstack = getStackBottom();
        thisContext.tstack = thisContext.bstack;

        atomicStore!(MemoryOrder.raw)(thisThread.m_isRunning, true);
    }
    thisThread.m_isDaemon = true;
    thisThread.m_tlsgcdata = rt_tlsgc_init();
    Thread.setThis( thisThread );

    version (Darwin)
    {
        thisThread.m_tmach = pthread_mach_thread_np( thisThread.m_addr );
        assert( thisThread.m_tmach != thisThread.m_tmach.init );
    }

    Thread.add( thisThread, false );
    Thread.add( thisContext );
    if ( Thread.sm_main !is null )
        multiThreadedFlag = true;
    return thisThread;
}


version (Windows)
{
    // NOTE: These calls are not safe on Posix systems that use signals to
    //       perform garbage collection.  The suspendHandler uses getThis()
    //       to get the thread handle so getThis() must be a simple call.
    //       Mutexes can't safely be acquired inside signal handlers, and
    //       even if they could, the mutex needed (Thread.slock) is held by
    //       thread_suspendAll().  So in short, these routines will remain
    //       Windows-specific.  If they are truly needed elsewhere, the
    //       suspendHandler will need a way to call a version of getThis()
    //       that only does the TLS lookup without the fancy fallback stuff.

    /// ditto
    extern (C) Thread thread_attachByAddr( ThreadID addr )
    {
        return thread_attachByAddrB( addr, getThreadStackBottom( addr ) );
    }


    /// ditto
    extern (C) Thread thread_attachByAddrB( ThreadID addr, void* bstack )
    {
        GC.disable(); scope(exit) GC.enable();

        if (auto t = thread_findByAddr(addr))
            return t;

        Thread          thisThread  = new Thread();
        Thread.Context* thisContext = &thisThread.m_main;
        assert( thisContext == thisThread.m_curr );

        thisThread.m_addr  = addr;
        thisContext.bstack = bstack;
        thisContext.tstack = thisContext.bstack;

        thisThread.m_isDaemon = true;

        if ( addr == GetCurrentThreadId() )
        {
            thisThread.m_hndl = GetCurrentThreadHandle();
            thisThread.m_tlsgcdata = rt_tlsgc_init();
            Thread.setThis( thisThread );
        }
        else
        {
            thisThread.m_hndl = OpenThreadHandle( addr );
            impersonate_thread(addr,
            {
                thisThread.m_tlsgcdata = rt_tlsgc_init();
                Thread.setThis( thisThread );
            });
        }

        Thread.add( thisThread, false );
        Thread.add( thisContext );
        if ( Thread.sm_main !is null )
            multiThreadedFlag = true;
        return thisThread;
    }
}


/**
 * Deregisters the calling thread from use with the runtime.  If this routine
 * is called for a thread which is not registered, the result is undefined.
 *
 * NOTE: This routine does not run thread-local static destructors when called.
 *       If full functionality as a D thread is desired, the following function
 *       must be called after thread_detachThis, particularly if the thread is
 *       being detached at some indeterminate time before program termination:
 *
 *       $(D extern(C) void rt_moduleTlsDtor();)
 */
extern (C) void thread_detachThis() nothrow @nogc
{
    if (auto t = Thread.getThis())
        Thread.remove(t);
}


/**
 * Deregisters the given thread from use with the runtime.  If this routine
 * is called for a thread which is not registered, the result is undefined.
 *
 * NOTE: This routine does not run thread-local static destructors when called.
 *       If full functionality as a D thread is desired, the following function
 *       must be called by the detached thread, particularly if the thread is
 *       being detached at some indeterminate time before program termination:
 *
 *       $(D extern(C) void rt_moduleTlsDtor();)
 */
extern (C) void thread_detachByAddr( ThreadID addr )
{
    if ( auto t = thread_findByAddr( addr ) )
        Thread.remove( t );
}


/// ditto
extern (C) void thread_detachInstance( Thread t ) nothrow @nogc
{
    Thread.remove( t );
}


unittest
{
    import core.sync.semaphore;
    auto sem = new Semaphore();

    auto t = new Thread(
    {
        sem.notify();
        Thread.sleep(100.msecs);
    }).start();

    sem.wait(); // thread cannot be detached while being started
    thread_detachInstance(t);
    foreach (t2; Thread)
        assert(t !is t2);
    t.join();
}


/**
 * Search the list of all threads for a thread with the given thread identifier.
 *
 * Params:
 *  addr = The thread identifier to search for.
 * Returns:
 *  The thread object associated with the thread identifier, null if not found.
 */
static Thread thread_findByAddr( ThreadID addr )
{
    Thread.slock.lock_nothrow();
    scope(exit) Thread.slock.unlock_nothrow();

    // also return just spawned thread so that
    // DLL_THREAD_ATTACH knows it's a D thread
    foreach (t; Thread.pAboutToStart[0 .. Thread.nAboutToStart])
        if (t.m_addr == addr)
            return t;

    foreach (t; Thread)
        if (t.m_addr == addr)
            return t;

    return null;
}


/**
 * Sets the current thread to a specific reference. Only to be used
 * when dealing with externally-created threads (in e.g. C code).
 * The primary use of this function is when Thread.getThis() must
 * return a sensible value in, for example, TLS destructors. In
 * other words, don't touch this unless you know what you're doing.
 *
 * Params:
 *  t = A reference to the current thread. May be null.
 */
extern (C) void thread_setThis(Thread t) nothrow @nogc
{
    Thread.setThis(t);
}


/**
 * Joins all non-daemon threads that are currently running.  This is done by
 * performing successive scans through the thread list until a scan consists
 * of only daemon threads.
 */
extern (C) void thread_joinAll()
{
 Lagain:
    Thread.slock.lock_nothrow();
    // wait for just spawned threads
    if (Thread.nAboutToStart)
    {
        Thread.slock.unlock_nothrow();
        Thread.yield();
        goto Lagain;
    }

    // join all non-daemon threads, the main thread is also a daemon
    auto t = Thread.sm_tbeg;
    while (t)
    {
        if (!t.isRunning)
        {
            auto tn = t.next;
            Thread.remove(t);
            t = tn;
        }
        else if (t.isDaemon)
        {
            t = t.next;
        }
        else
        {
            Thread.slock.unlock_nothrow();
            t.join(); // might rethrow
            goto Lagain; // must restart iteration b/c of unlock
        }
    }
    Thread.slock.unlock_nothrow();
}


/**
 * Performs intermediate shutdown of the thread module.
 */
shared static ~this()
{
    // NOTE: The functionality related to garbage collection must be minimally
    //       operable after this dtor completes.  Therefore, only minimal
    //       cleanup may occur.
    auto t = Thread.sm_tbeg;
    while (t)
    {
        auto tn = t.next;
        if (!t.isRunning)
            Thread.remove(t);
        t = tn;
    }
}


// Used for needLock below.
private __gshared bool multiThreadedFlag = false;

version (PPC64) version = ExternStackShell;

version (ExternStackShell)
{
    extern(D) public void callWithStackShell(scope void delegate(void* sp) nothrow fn) nothrow;
}
else
{
    // Calls the given delegate, passing the current thread's stack pointer to it.
    private void callWithStackShell(scope void delegate(void* sp) nothrow fn) nothrow
    in
    {
        assert(fn);
    }
    body
    {
        // The purpose of the 'shell' is to ensure all the registers get
        // put on the stack so they'll be scanned. We only need to push
        // the callee-save registers.
        void *sp = void;

        version (GNU)
        {
            __builtin_unwind_init();
            sp = &sp;
        }
        else version (AsmX86_Posix)
        {
            size_t[3] regs = void;
            asm pure nothrow @nogc
            {
                mov [regs + 0 * 4], EBX;
                mov [regs + 1 * 4], ESI;
                mov [regs + 2 * 4], EDI;

                mov sp[EBP], ESP;
            }
        }
        else version (AsmX86_Windows)
        {
            size_t[3] regs = void;
            asm pure nothrow @nogc
            {
                mov [regs + 0 * 4], EBX;
                mov [regs + 1 * 4], ESI;
                mov [regs + 2 * 4], EDI;

                mov sp[EBP], ESP;
            }
        }
        else version (AsmX86_64_Posix)
        {
            size_t[5] regs = void;
            asm pure nothrow @nogc
            {
                mov [regs + 0 * 8], RBX;
                mov [regs + 1 * 8], R12;
                mov [regs + 2 * 8], R13;
                mov [regs + 3 * 8], R14;
                mov [regs + 4 * 8], R15;

                mov sp[RBP], RSP;
            }
        }
        else version (AsmX86_64_Windows)
        {
            size_t[7] regs = void;
            asm pure nothrow @nogc
            {
                mov [regs + 0 * 8], RBX;
                mov [regs + 1 * 8], RSI;
                mov [regs + 2 * 8], RDI;
                mov [regs + 3 * 8], R12;
                mov [regs + 4 * 8], R13;
                mov [regs + 5 * 8], R14;
                mov [regs + 6 * 8], R15;

                mov sp[RBP], RSP;
            }
        }
        else
        {
            static assert(false, "Architecture not supported.");
        }

        fn(sp);
    }
}

// Used for suspendAll/resumeAll below.
private __gshared uint suspendDepth = 0;

/**
 * Suspend the specified thread and load stack and register information for
 * use by thread_scanAll.  If the supplied thread is the calling thread,
 * stack and register information will be loaded but the thread will not
 * be suspended.  If the suspend operation fails and the thread is not
 * running then it will be removed from the global thread list, otherwise
 * an exception will be thrown.
 *
 * Params:
 *  t = The thread to suspend.
 *
 * Throws:
 *  ThreadError if the suspend operation fails for a running thread.
 * Returns:
 *  Whether the thread is now suspended (true) or terminated (false).
 */
private bool suspend( Thread t ) nothrow
{
    Duration waittime = dur!"usecs"(10);
 Lagain:
    if (!t.isRunning)
    {
        Thread.remove(t);
        return false;
    }
    else if (t.m_isInCriticalRegion)
    {
        Thread.criticalRegionLock.unlock_nothrow();
        Thread.sleep(waittime);
        if (waittime < dur!"msecs"(10)) waittime *= 2;
        Thread.criticalRegionLock.lock_nothrow();
        goto Lagain;
    }

    version (Windows)
    {
        if ( t.m_addr != GetCurrentThreadId() && SuspendThread( t.m_hndl ) == 0xFFFFFFFF )
        {
            if ( !t.isRunning )
            {
                Thread.remove( t );
                return false;
            }
            onThreadError( "Unable to suspend thread" );
        }

        CONTEXT context = void;
        context.ContextFlags = CONTEXT_INTEGER | CONTEXT_CONTROL;

        if ( !GetThreadContext( t.m_hndl, &context ) )
            onThreadError( "Unable to load thread context" );
        version (X86)
        {
            if ( !t.m_lock )
                t.m_curr.tstack = cast(void*) context.Esp;
            // eax,ebx,ecx,edx,edi,esi,ebp,esp
            t.m_reg[0] = context.Eax;
            t.m_reg[1] = context.Ebx;
            t.m_reg[2] = context.Ecx;
            t.m_reg[3] = context.Edx;
            t.m_reg[4] = context.Edi;
            t.m_reg[5] = context.Esi;
            t.m_reg[6] = context.Ebp;
            t.m_reg[7] = context.Esp;
        }
        else version (X86_64)
        {
            if ( !t.m_lock )
                t.m_curr.tstack = cast(void*) context.Rsp;
            // rax,rbx,rcx,rdx,rdi,rsi,rbp,rsp
            t.m_reg[0] = context.Rax;
            t.m_reg[1] = context.Rbx;
            t.m_reg[2] = context.Rcx;
            t.m_reg[3] = context.Rdx;
            t.m_reg[4] = context.Rdi;
            t.m_reg[5] = context.Rsi;
            t.m_reg[6] = context.Rbp;
            t.m_reg[7] = context.Rsp;
            // r8,r9,r10,r11,r12,r13,r14,r15
            t.m_reg[8]  = context.R8;
            t.m_reg[9]  = context.R9;
            t.m_reg[10] = context.R10;
            t.m_reg[11] = context.R11;
            t.m_reg[12] = context.R12;
            t.m_reg[13] = context.R13;
            t.m_reg[14] = context.R14;
            t.m_reg[15] = context.R15;
        }
        else
        {
            static assert(false, "Architecture not supported." );
        }
    }
    else version (Darwin)
    {
        if ( t.m_addr != pthread_self() && thread_suspend( t.m_tmach ) != KERN_SUCCESS )
        {
            if ( !t.isRunning )
            {
                Thread.remove( t );
                return false;
            }
            onThreadError( "Unable to suspend thread" );
        }

        version (X86)
        {
            x86_thread_state32_t    state = void;
            mach_msg_type_number_t  count = x86_THREAD_STATE32_COUNT;

            if ( thread_get_state( t.m_tmach, x86_THREAD_STATE32, &state, &count ) != KERN_SUCCESS )
                onThreadError( "Unable to load thread state" );
            if ( !t.m_lock )
                t.m_curr.tstack = cast(void*) state.esp;
            // eax,ebx,ecx,edx,edi,esi,ebp,esp
            t.m_reg[0] = state.eax;
            t.m_reg[1] = state.ebx;
            t.m_reg[2] = state.ecx;
            t.m_reg[3] = state.edx;
            t.m_reg[4] = state.edi;
            t.m_reg[5] = state.esi;
            t.m_reg[6] = state.ebp;
            t.m_reg[7] = state.esp;
        }
        else version (X86_64)
        {
            x86_thread_state64_t    state = void;
            mach_msg_type_number_t  count = x86_THREAD_STATE64_COUNT;

            if ( thread_get_state( t.m_tmach, x86_THREAD_STATE64, &state, &count ) != KERN_SUCCESS )
                onThreadError( "Unable to load thread state" );
            if ( !t.m_lock )
                t.m_curr.tstack = cast(void*) state.rsp;
            // rax,rbx,rcx,rdx,rdi,rsi,rbp,rsp
            t.m_reg[0] = state.rax;
            t.m_reg[1] = state.rbx;
            t.m_reg[2] = state.rcx;
            t.m_reg[3] = state.rdx;
            t.m_reg[4] = state.rdi;
            t.m_reg[5] = state.rsi;
            t.m_reg[6] = state.rbp;
            t.m_reg[7] = state.rsp;
            // r8,r9,r10,r11,r12,r13,r14,r15
            t.m_reg[8]  = state.r8;
            t.m_reg[9]  = state.r9;
            t.m_reg[10] = state.r10;
            t.m_reg[11] = state.r11;
            t.m_reg[12] = state.r12;
            t.m_reg[13] = state.r13;
            t.m_reg[14] = state.r14;
            t.m_reg[15] = state.r15;
        }
        else
        {
            static assert(false, "Architecture not supported." );
        }
    }
    else version (Posix)
    {
        if ( t.m_addr != pthread_self() )
        {
            if ( pthread_kill( t.m_addr, suspendSignalNumber ) != 0 )
            {
                if ( !t.isRunning )
                {
                    Thread.remove( t );
                    return false;
                }
                onThreadError( "Unable to suspend thread" );
            }
        }
        else if ( !t.m_lock )
        {
            t.m_curr.tstack = getStackTop();
        }
    }
    return true;
}

/**
 * Suspend all threads but the calling thread for "stop the world" garbage
 * collection runs.  This function may be called multiple times, and must
 * be followed by a matching number of calls to thread_resumeAll before
 * processing is resumed.
 *
 * Throws:
 *  ThreadError if the suspend operation fails for a running thread.
 */
extern (C) void thread_suspendAll() nothrow
{
    // NOTE: We've got an odd chicken & egg problem here, because while the GC
    //       is required to call thread_init before calling any other thread
    //       routines, thread_init may allocate memory which could in turn
    //       trigger a collection.  Thus, thread_suspendAll, thread_scanAll,
    //       and thread_resumeAll must be callable before thread_init
    //       completes, with the assumption that no other GC memory has yet
    //       been allocated by the system, and thus there is no risk of losing
    //       data if the global thread list is empty.  The check of
    //       Thread.sm_tbeg below is done to ensure thread_init has completed,
    //       and therefore that calling Thread.getThis will not result in an
    //       error.  For the short time when Thread.sm_tbeg is null, there is
    //       no reason not to simply call the multithreaded code below, with
    //       the expectation that the foreach loop will never be entered.
    if ( !multiThreadedFlag && Thread.sm_tbeg )
    {
        if ( ++suspendDepth == 1 )
            suspend( Thread.getThis() );

        return;
    }

    Thread.slock.lock_nothrow();
    {
        if ( ++suspendDepth > 1 )
            return;

        Thread.criticalRegionLock.lock_nothrow();
        scope (exit) Thread.criticalRegionLock.unlock_nothrow();
        size_t cnt;
        auto t = Thread.sm_tbeg;
        while (t)
        {
            auto tn = t.next;
            if (suspend(t))
                ++cnt;
            t = tn;
        }

        version (Darwin)
        {}
        else version (Posix)
        {
            // subtract own thread
            assert(cnt >= 1);
            --cnt;
        Lagain:
            // wait for semaphore notifications
            for (; cnt; --cnt)
            {
                while (sem_wait(&suspendCount) != 0)
                {
                    if (errno != EINTR)
                        onThreadError("Unable to wait for semaphore");
                    errno = 0;
                }
            }
            version (FreeBSD)
            {
                // avoid deadlocks, see Issue 13416
                t = Thread.sm_tbeg;
                while (t)
                {
                    auto tn = t.next;
                    if (t.m_suspendagain && suspend(t))
                        ++cnt;
                    t = tn;
                }
                if (cnt)
                    goto Lagain;
             }
        }
    }
}

/**
 * Resume the specified thread and unload stack and register information.
 * If the supplied thread is the calling thread, stack and register
 * information will be unloaded but the thread will not be resumed.  If
 * the resume operation fails and the thread is not running then it will
 * be removed from the global thread list, otherwise an exception will be
 * thrown.
 *
 * Params:
 *  t = The thread to resume.
 *
 * Throws:
 *  ThreadError if the resume fails for a running thread.
 */
private void resume( Thread t ) nothrow
{
    version (Windows)
    {
        if ( t.m_addr != GetCurrentThreadId() && ResumeThread( t.m_hndl ) == 0xFFFFFFFF )
        {
            if ( !t.isRunning )
            {
                Thread.remove( t );
                return;
            }
            onThreadError( "Unable to resume thread" );
        }

        if ( !t.m_lock )
            t.m_curr.tstack = t.m_curr.bstack;
        t.m_reg[0 .. $] = 0;
    }
    else version (Darwin)
    {
        if ( t.m_addr != pthread_self() && thread_resume( t.m_tmach ) != KERN_SUCCESS )
        {
            if ( !t.isRunning )
            {
                Thread.remove( t );
                return;
            }
            onThreadError( "Unable to resume thread" );
        }

        if ( !t.m_lock )
            t.m_curr.tstack = t.m_curr.bstack;
        t.m_reg[0 .. $] = 0;
    }
    else version (Posix)
    {
        if ( t.m_addr != pthread_self() )
        {
            if ( pthread_kill( t.m_addr, resumeSignalNumber ) != 0 )
            {
                if ( !t.isRunning )
                {
                    Thread.remove( t );
                    return;
                }
                onThreadError( "Unable to resume thread" );
            }
        }
        else if ( !t.m_lock )
        {
            t.m_curr.tstack = t.m_curr.bstack;
        }
    }
}

/**
 * Resume all threads but the calling thread for "stop the world" garbage
 * collection runs.  This function must be called once for each preceding
 * call to thread_suspendAll before the threads are actually resumed.
 *
 * In:
 *  This routine must be preceded by a call to thread_suspendAll.
 *
 * Throws:
 *  ThreadError if the resume operation fails for a running thread.
 */
extern (C) void thread_resumeAll() nothrow
in
{
    assert( suspendDepth > 0 );
}
body
{
    // NOTE: See thread_suspendAll for the logic behind this.
    if ( !multiThreadedFlag && Thread.sm_tbeg )
    {
        if ( --suspendDepth == 0 )
            resume( Thread.getThis() );
        return;
    }

    scope(exit) Thread.slock.unlock_nothrow();
    {
        if ( --suspendDepth > 0 )
            return;

        for ( Thread t = Thread.sm_tbeg; t; t = t.next )
        {
            // NOTE: We do not need to care about critical regions at all
            //       here. thread_suspendAll takes care of everything.
            resume( t );
        }
    }
}

/**
 * Indicates the kind of scan being performed by $(D thread_scanAllType).
 */
enum ScanType
{
    stack, /// The stack and/or registers are being scanned.
    tls, /// TLS data is being scanned.
}

alias ScanAllThreadsFn = void delegate(void*, void*) nothrow; /// The scanning function.
alias ScanAllThreadsTypeFn = void delegate(ScanType, void*, void*) nothrow; /// ditto

/**
 * The main entry point for garbage collection.  The supplied delegate
 * will be passed ranges representing both stack and register values.
 *
 * Params:
 *  scan        = The scanner function.  It should scan from p1 through p2 - 1.
 *
 * In:
 *  This routine must be preceded by a call to thread_suspendAll.
 */
extern (C) void thread_scanAllType( scope ScanAllThreadsTypeFn scan ) nothrow
in
{
    assert( suspendDepth > 0 );
}
body
{
    callWithStackShell(sp => scanAllTypeImpl(scan, sp));
}


private void scanAllTypeImpl( scope ScanAllThreadsTypeFn scan, void* curStackTop ) nothrow
{
    Thread  thisThread  = null;
    void*   oldStackTop = null;

    if ( Thread.sm_tbeg )
    {
        thisThread  = Thread.getThis();
        if ( !thisThread.m_lock )
        {
            oldStackTop = thisThread.m_curr.tstack;
            thisThread.m_curr.tstack = curStackTop;
        }
    }

    scope( exit )
    {
        if ( Thread.sm_tbeg )
        {
            if ( !thisThread.m_lock )
            {
                thisThread.m_curr.tstack = oldStackTop;
            }
        }
    }

    // NOTE: Synchronizing on Thread.slock is not needed because this
    //       function may only be called after all other threads have
    //       been suspended from within the same lock.
    if (Thread.nAboutToStart)
        scan(ScanType.stack, Thread.pAboutToStart, Thread.pAboutToStart + Thread.nAboutToStart);

    for ( Thread.Context* c = Thread.sm_cbeg; c; c = c.next )
    {
        version (StackGrowsDown)
        {
            // NOTE: We can't index past the bottom of the stack
            //       so don't do the "+1" for StackGrowsDown.
            if ( c.tstack && c.tstack < c.bstack )
                scan( ScanType.stack, c.tstack, c.bstack );
        }
        else
        {
            if ( c.bstack && c.bstack < c.tstack )
                scan( ScanType.stack, c.bstack, c.tstack + 1 );
        }
    }

    for ( Thread t = Thread.sm_tbeg; t; t = t.next )
    {
        version (Windows)
        {
            // Ideally, we'd pass ScanType.regs or something like that, but this
            // would make portability annoying because it only makes sense on Windows.
            scan( ScanType.stack, t.m_reg.ptr, t.m_reg.ptr + t.m_reg.length );
        }

        if (t.m_tlsgcdata !is null)
            rt_tlsgc_scan(t.m_tlsgcdata, (p1, p2) => scan(ScanType.tls, p1, p2));
    }
}

/**
 * The main entry point for garbage collection.  The supplied delegate
 * will be passed ranges representing both stack and register values.
 *
 * Params:
 *  scan        = The scanner function.  It should scan from p1 through p2 - 1.
 *
 * In:
 *  This routine must be preceded by a call to thread_suspendAll.
 */
extern (C) void thread_scanAll( scope ScanAllThreadsFn scan ) nothrow
{
    thread_scanAllType((type, p1, p2) => scan(p1, p2));
}


/**
 * Signals that the code following this call is a critical region. Any code in
 * this region must finish running before the calling thread can be suspended
 * by a call to thread_suspendAll.
 *
 * This function is, in particular, meant to help maintain garbage collector
 * invariants when a lock is not used.
 *
 * A critical region is exited with thread_exitCriticalRegion.
 *
 * $(RED Warning):
 * Using critical regions is extremely error-prone. For instance, using locks
 * inside a critical region can easily result in a deadlock when another thread
 * holding the lock already got suspended.
 *
 * The term and concept of a 'critical region' comes from
 * $(LINK2 https://github.com/mono/mono/blob/521f4a198e442573c400835ef19bbb36b60b0ebb/mono/metadata/sgen-gc.h#L925 Mono's SGen garbage collector).
 *
 * In:
 *  The calling thread must be attached to the runtime.
 */
extern (C) void thread_enterCriticalRegion() @nogc
in
{
    assert(Thread.getThis());
}
body
{
    synchronized (Thread.criticalRegionLock)
        Thread.getThis().m_isInCriticalRegion = true;
}


/**
 * Signals that the calling thread is no longer in a critical region. Following
 * a call to this function, the thread can once again be suspended.
 *
 * In:
 *  The calling thread must be attached to the runtime.
 */
extern (C) void thread_exitCriticalRegion() @nogc
in
{
    assert(Thread.getThis());
}
body
{
    synchronized (Thread.criticalRegionLock)
        Thread.getThis().m_isInCriticalRegion = false;
}


/**
 * Returns true if the current thread is in a critical region; otherwise, false.
 *
 * In:
 *  The calling thread must be attached to the runtime.
 */
extern (C) bool thread_inCriticalRegion() @nogc
in
{
    assert(Thread.getThis());
}
body
{
    synchronized (Thread.criticalRegionLock)
        return Thread.getThis().m_isInCriticalRegion;
}


/**
* A callback for thread errors in D during collections. Since an allocation is not possible
*  a preallocated ThreadError will be used as the Error instance
*
* Throws:
*  ThreadError.
*/
private void onThreadError(string msg = null, Throwable next = null) nothrow
{
    __gshared ThreadError error = new ThreadError(null);
    error.msg = msg;
    error.next = next;
    import core.exception : SuppressTraceInfo;
    error.info = SuppressTraceInfo.instance;
    throw error;
}


unittest
{
    assert(!thread_inCriticalRegion());

    {
        thread_enterCriticalRegion();

        scope (exit)
            thread_exitCriticalRegion();

        assert(thread_inCriticalRegion());
    }

    assert(!thread_inCriticalRegion());
}

unittest
{
    // NOTE: This entire test is based on the assumption that no
    //       memory is allocated after the child thread is
    //       started. If an allocation happens, a collection could
    //       trigger, which would cause the synchronization below
    //       to cause a deadlock.
    // NOTE: DO NOT USE LOCKS IN CRITICAL REGIONS IN NORMAL CODE.

    import core.sync.semaphore;

    auto sema = new Semaphore(),
         semb = new Semaphore();

    auto thr = new Thread(
    {
        thread_enterCriticalRegion();
        assert(thread_inCriticalRegion());
        sema.notify();

        semb.wait();
        assert(thread_inCriticalRegion());

        thread_exitCriticalRegion();
        assert(!thread_inCriticalRegion());
        sema.notify();

        semb.wait();
        assert(!thread_inCriticalRegion());
    });

    thr.start();

    sema.wait();
    synchronized (Thread.criticalRegionLock)
        assert(thr.m_isInCriticalRegion);
    semb.notify();

    sema.wait();
    synchronized (Thread.criticalRegionLock)
        assert(!thr.m_isInCriticalRegion);
    semb.notify();

    thr.join();
}

unittest
{
    import core.sync.semaphore;

    shared bool inCriticalRegion;
    auto sema = new Semaphore(),
         semb = new Semaphore();

    auto thr = new Thread(
    {
        thread_enterCriticalRegion();
        inCriticalRegion = true;
        sema.notify();
        semb.wait();

        Thread.sleep(dur!"msecs"(1));
        inCriticalRegion = false;
        thread_exitCriticalRegion();
    });
    thr.start();

    sema.wait();
    assert(inCriticalRegion);
    semb.notify();

    thread_suspendAll();
    assert(!inCriticalRegion);
    thread_resumeAll();
}

/**
 * Indicates whether an address has been marked by the GC.
 */
enum IsMarked : int
{
         no, /// Address is not marked.
        yes, /// Address is marked.
    unknown, /// Address is not managed by the GC.
}

alias IsMarkedDg = int delegate( void* addr ) nothrow; /// The isMarked callback function.

/**
 * This routine allows the runtime to process any special per-thread handling
 * for the GC.  This is needed for taking into account any memory that is
 * referenced by non-scanned pointers but is about to be freed.  That currently
 * means the array append cache.
 *
 * Params:
 *  isMarked = The function used to check if $(D addr) is marked.
 *
 * In:
 *  This routine must be called just prior to resuming all threads.
 */
extern(C) void thread_processGCMarks( scope IsMarkedDg isMarked ) nothrow
{
    for ( Thread t = Thread.sm_tbeg; t; t = t.next )
    {
        /* Can be null if collection was triggered between adding a
         * thread and calling rt_tlsgc_init.
         */
        if (t.m_tlsgcdata !is null)
            rt_tlsgc_processGCMarks(t.m_tlsgcdata, isMarked);
    }
}


extern (C) @nogc nothrow
{
    version (CRuntime_Glibc) int pthread_getattr_np(pthread_t thread, pthread_attr_t* attr);
    version (FreeBSD) int pthread_attr_get_np(pthread_t thread, pthread_attr_t* attr);
    version (NetBSD) int pthread_attr_get_np(pthread_t thread, pthread_attr_t* attr);
    version (DragonFlyBSD) int pthread_attr_get_np(pthread_t thread, pthread_attr_t* attr);
    version (Solaris) int thr_stksegment(stack_t* stk);
    version (CRuntime_Bionic) int pthread_getattr_np(pthread_t thid, pthread_attr_t* attr);
    version (CRuntime_Musl) int pthread_getattr_np(pthread_t, pthread_attr_t*);
    version (CRuntime_UClibc) int pthread_getattr_np(pthread_t thread, pthread_attr_t* attr);
}


private void* getStackTop() nothrow @nogc
{
    version (D_InlineAsm_X86)
        asm pure nothrow @nogc { naked; mov EAX, ESP; ret; }
    else version (D_InlineAsm_X86_64)
        asm pure nothrow @nogc { naked; mov RAX, RSP; ret; }
    else version (GNU)
        return __builtin_frame_address(0);
    else
        static assert(false, "Architecture not supported.");
}


private void* getStackBottom() nothrow @nogc
{
    version (Windows)
    {
        version (D_InlineAsm_X86)
            asm pure nothrow @nogc { naked; mov EAX, FS:4; ret; }
        else version (D_InlineAsm_X86_64)
            asm pure nothrow @nogc
            {    naked;
                 mov RAX, 8;
                 mov RAX, GS:[RAX];
                 ret;
            }
        else version (GNU_InlineAsm)
        {
            void *bottom;

            version (X86)
                asm pure nothrow @nogc { "movl %%fs:4, %0;" : "=r" bottom; }
            else version (X86_64)
                asm pure nothrow @nogc { "movq %%gs:8, %0;" : "=r" bottom; }
            else
                static assert(false, "Platform not supported.");

            return bottom;
        }
        else
            static assert(false, "Architecture not supported.");
    }
    else version (Darwin)
    {
        import core.sys.darwin.pthread;
        return pthread_get_stackaddr_np(pthread_self());
    }
    else version (CRuntime_Glibc)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_getattr_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (FreeBSD)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_attr_init(&attr);
        pthread_attr_get_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (NetBSD)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_attr_init(&attr);
        pthread_attr_get_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (DragonFlyBSD)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_attr_init(&attr);
        pthread_attr_get_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (Solaris)
    {
        stack_t stk;

        thr_stksegment(&stk);
        return stk.ss_sp;
    }
    else version (CRuntime_Bionic)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_getattr_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (CRuntime_Musl)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_getattr_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else version (CRuntime_UClibc)
    {
        pthread_attr_t attr;
        void* addr; size_t size;

        pthread_getattr_np(pthread_self(), &attr);
        pthread_attr_getstack(&attr, &addr, &size);
        pthread_attr_destroy(&attr);
        version (StackGrowsDown)
            addr += size;
        return addr;
    }
    else
        static assert(false, "Platform not supported.");
}


/**
 * Returns the stack top of the currently active stack within the calling
 * thread.
 *
 * In:
 *  The calling thread must be attached to the runtime.
 *
 * Returns:
 *  The address of the stack top.
 */
extern (C) void* thread_stackTop() nothrow @nogc
in
{
    // Not strictly required, but it gives us more flexibility.
    assert(Thread.getThis());
}
body
{
    return getStackTop();
}


/**
 * Returns the stack bottom of the currently active stack within the calling
 * thread.
 *
 * In:
 *  The calling thread must be attached to the runtime.
 *
 * Returns:
 *  The address of the stack bottom.
 */
extern (C) void* thread_stackBottom() nothrow @nogc
in
{
    assert(Thread.getThis());
}
body
{
    return Thread.getThis().topContext().bstack;
}


///////////////////////////////////////////////////////////////////////////////
// Thread Group
///////////////////////////////////////////////////////////////////////////////


/**
 * This class is intended to simplify certain common programming techniques.
 */
class ThreadGroup
{
    /**
     * Creates and starts a new Thread object that executes fn and adds it to
     * the list of tracked threads.
     *
     * Params:
     *  fn = The thread function.
     *
     * Returns:
     *  A reference to the newly created thread.
     */
    final Thread create( void function() fn )
    {
        Thread t = new Thread( fn ).start();

        synchronized( this )
        {
            m_all[t] = t;
        }
        return t;
    }


    /**
     * Creates and starts a new Thread object that executes dg and adds it to
     * the list of tracked threads.
     *
     * Params:
     *  dg = The thread function.
     *
     * Returns:
     *  A reference to the newly created thread.
     */
    final Thread create( void delegate() dg )
    {
        Thread t = new Thread( dg ).start();

        synchronized( this )
        {
            m_all[t] = t;
        }
        return t;
    }


    /**
     * Add t to the list of tracked threads if it is not already being tracked.
     *
     * Params:
     *  t = The thread to add.
     *
     * In:
     *  t must not be null.
     */
    final void add( Thread t )
    in
    {
        assert( t );
    }
    body
    {
        synchronized( this )
        {
            m_all[t] = t;
        }
    }


    /**
     * Removes t from the list of tracked threads.  No operation will be
     * performed if t is not currently being tracked by this object.
     *
     * Params:
     *  t = The thread to remove.
     *
     * In:
     *  t must not be null.
     */
    final void remove( Thread t )
    in
    {
        assert( t );
    }
    body
    {
        synchronized( this )
        {
            m_all.remove( t );
        }
    }


    /**
     * Operates on all threads currently tracked by this object.
     */
    final int opApply( scope int delegate( ref Thread ) dg )
    {
        synchronized( this )
        {
            int ret = 0;

            // NOTE: This loop relies on the knowledge that m_all uses the
            //       Thread object for both the key and the mapped value.
            foreach ( Thread t; m_all.keys )
            {
                ret = dg( t );
                if ( ret )
                    break;
            }
            return ret;
        }
    }


    /**
     * Iteratively joins all tracked threads.  This function will block add,
     * remove, and opApply until it completes.
     *
     * Params:
     *  rethrow = Rethrow any unhandled exception which may have caused the
     *            current thread to terminate.
     *
     * Throws:
     *  Any exception not handled by the joined threads.
     */
    final void joinAll( bool rethrow = true )
    {
        synchronized( this )
        {
            // NOTE: This loop relies on the knowledge that m_all uses the
            //       Thread object for both the key and the mapped value.
            foreach ( Thread t; m_all.keys )
            {
                t.join( rethrow );
            }
        }
    }


private:
    Thread[Thread]  m_all;
}


///////////////////////////////////////////////////////////////////////////////
// Fiber Platform Detection and Memory Allocation
///////////////////////////////////////////////////////////////////////////////


private
{
    version (D_InlineAsm_X86)
    {
        version (Windows)
            version = AsmX86_Windows;
        else version (Posix)
            version = AsmX86_Posix;

        version (Darwin)
            version = AlignFiberStackTo16Byte;
    }
    else version (D_InlineAsm_X86_64)
    {
        version (Windows)
        {
            version = AsmX86_64_Windows;
            version = AlignFiberStackTo16Byte;
        }
        else version (Posix)
        {
            version = AsmX86_64_Posix;
            version = AlignFiberStackTo16Byte;
        }
    }
    else version (X86)
    {
        version = AsmExternal;

        version (MinGW)
        {
            version = GNU_AsmX86_Windows;
            version = AlignFiberStackTo16Byte;
        }
        else version (Posix)
        {
            version = AsmX86_Posix;
            version (OSX)
                version = AlignFiberStackTo16Byte;
        }
    }
    else version (X86_64)
    {
        version (D_X32)
        {
            // let X32 be handled by ucontext swapcontext
        }
        else
        {
            version = AsmExternal;
            version = AlignFiberStackTo16Byte;

            version (MinGW)
                version = GNU_AsmX86_64_Windows;
            else version (Posix)
                version = AsmX86_64_Posix;
        }
    }
    else version (PPC)
    {
        version (Posix)
        {
            version = AsmPPC_Posix;
            version = AsmExternal;
        }
    }
    else version (PPC64)
    {
        version (Posix)
        {
            version = AlignFiberStackTo16Byte;
        }
    }
    else version (MIPS_O32)
    {
        version (Posix)
        {
            version = AsmMIPS_O32_Posix;
            version = AsmExternal;
        }
    }
    else version (AArch64)
    {
        version (Posix)
        {
            version = AsmAArch64_Posix;
            version = AsmExternal;
            version = AlignFiberStackTo16Byte;
        }
    }
    else version (ARM)
    {
        version (Posix)
        {
            version = AsmARM_Posix;
            version = AsmExternal;
        }
    }
    else version (SPARC)
    {
        // NOTE: The SPARC ABI specifies only doubleword alignment.
        version = AlignFiberStackTo16Byte;
    }
    else version (SPARC64)
    {
        version = AlignFiberStackTo16Byte;
    }

    version (Posix)
    {
        import core.sys.posix.unistd;   // for sysconf

        version (AsmX86_Windows)    {} else
        version (AsmX86_Posix)      {} else
        version (AsmX86_64_Windows) {} else
        version (AsmX86_64_Posix)   {} else
        version (AsmExternal)       {} else
        {
            // NOTE: The ucontext implementation requires architecture specific
            //       data definitions to operate so testing for it must be done
            //       by checking for the existence of ucontext_t rather than by
            //       a version identifier.  Please note that this is considered
            //       an obsolescent feature according to the POSIX spec, so a
            //       custom solution is still preferred.
            import core.sys.posix.ucontext;
        }
    }

    static immutable size_t PAGESIZE;
    version (Posix) static immutable size_t PTHREAD_STACK_MIN;
}


shared static this()
{
    version (Windows)
    {
        SYSTEM_INFO info;
        GetSystemInfo(&info);

        PAGESIZE = info.dwPageSize;
        assert(PAGESIZE < int.max);
    }
    else version (Posix)
    {
        PAGESIZE = cast(size_t)sysconf(_SC_PAGESIZE);
        PTHREAD_STACK_MIN = cast(size_t)sysconf(_SC_THREAD_STACK_MIN);
    }
    else
    {
        static assert(0, "unimplemented");
    }
}


///////////////////////////////////////////////////////////////////////////////
// Fiber Entry Point and Context Switch
///////////////////////////////////////////////////////////////////////////////


private
{
    extern (C) void fiber_entryPoint() nothrow
    {
        Fiber   obj = Fiber.getThis();
        assert( obj );

        assert( Thread.getThis().m_curr is obj.m_ctxt );
        atomicStore!(MemoryOrder.raw)(*cast(shared)&Thread.getThis().m_lock, false);
        obj.m_ctxt.tstack = obj.m_ctxt.bstack;
        obj.m_state = Fiber.State.EXEC;

        try
        {
            obj.run();
        }
        catch ( Throwable t )
        {
            obj.m_unhandled = t;
        }

        static if ( __traits( compiles, ucontext_t ) )
          obj.m_ucur = &obj.m_utxt;

        obj.m_state = Fiber.State.TERM;
        obj.switchOut();
    }

  // Look above the definition of 'class Fiber' for some information about the implementation of this routine
  version (AsmExternal)
  {
      extern (C) void fiber_switchContext( void** oldp, void* newp ) nothrow @nogc;
      version (AArch64)
          extern (C) void fiber_trampoline() nothrow;
  }
  else
    extern (C) void fiber_switchContext( void** oldp, void* newp ) nothrow @nogc
    {
        // NOTE: The data pushed and popped in this routine must match the
        //       default stack created by Fiber.initStack or the initial
        //       switch into a new context will fail.

        version (AsmX86_Windows)
        {
            asm pure nothrow @nogc
            {
                naked;

                // save current stack state
                push EBP;
                mov  EBP, ESP;
                push EDI;
                push ESI;
                push EBX;
                push dword ptr FS:[0];
                push dword ptr FS:[4];
                push dword ptr FS:[8];
                push EAX;

                // store oldp again with more accurate address
                mov EAX, dword ptr 8[EBP];
                mov [EAX], ESP;
                // load newp to begin context switch
                mov ESP, dword ptr 12[EBP];

                // load saved state from new stack
                pop EAX;
                pop dword ptr FS:[8];
                pop dword ptr FS:[4];
                pop dword ptr FS:[0];
                pop EBX;
                pop ESI;
                pop EDI;
                pop EBP;

                // 'return' to complete switch
                pop ECX;
                jmp ECX;
            }
        }
        else version (AsmX86_64_Windows)
        {
            asm pure nothrow @nogc
            {
                naked;

                // save current stack state
                // NOTE: When changing the layout of registers on the stack,
                //       make sure that the XMM registers are still aligned.
                //       On function entry, the stack is guaranteed to not
                //       be aligned to 16 bytes because of the return address
                //       on the stack.
                push RBP;
                mov  RBP, RSP;
                push R12;
                push R13;
                push R14;
                push R15;
                push RDI;
                push RSI;
                // 7 registers = 56 bytes; stack is now aligned to 16 bytes
                sub RSP, 160;
                movdqa [RSP + 144], XMM6;
                movdqa [RSP + 128], XMM7;
                movdqa [RSP + 112], XMM8;
                movdqa [RSP + 96], XMM9;
                movdqa [RSP + 80], XMM10;
                movdqa [RSP + 64], XMM11;
                movdqa [RSP + 48], XMM12;
                movdqa [RSP + 32], XMM13;
                movdqa [RSP + 16], XMM14;
                movdqa [RSP], XMM15;
                push RBX;
                xor  RAX,RAX;
                push qword ptr GS:[RAX];
                push qword ptr GS:8[RAX];
                push qword ptr GS:16[RAX];

                // store oldp
                mov [RCX], RSP;
                // load newp to begin context switch
                mov RSP, RDX;

                // load saved state from new stack
                pop qword ptr GS:16[RAX];
                pop qword ptr GS:8[RAX];
                pop qword ptr GS:[RAX];
                pop RBX;
                movdqa XMM15, [RSP];
                movdqa XMM14, [RSP + 16];
                movdqa XMM13, [RSP + 32];
                movdqa XMM12, [RSP + 48];
                movdqa XMM11, [RSP + 64];
                movdqa XMM10, [RSP + 80];
                movdqa XMM9, [RSP + 96];
                movdqa XMM8, [RSP + 112];
                movdqa XMM7, [RSP + 128];
                movdqa XMM6, [RSP + 144];
                add RSP, 160;
                pop RSI;
                pop RDI;
                pop R15;
                pop R14;
                pop R13;
                pop R12;
                pop RBP;

                // 'return' to complete switch
                pop RCX;
                jmp RCX;
            }
        }
        else version (AsmX86_Posix)
        {
            asm pure nothrow @nogc
            {
                naked;

                // save current stack state
                push EBP;
                mov  EBP, ESP;
                push EDI;
                push ESI;
                push EBX;
                push EAX;

                // store oldp again with more accurate address
                mov EAX, dword ptr 8[EBP];
                mov [EAX], ESP;
                // load newp to begin context switch
                mov ESP, dword ptr 12[EBP];

                // load saved state from new stack
                pop EAX;
                pop EBX;
                pop ESI;
                pop EDI;
                pop EBP;

                // 'return' to complete switch
                pop ECX;
                jmp ECX;
            }
        }
        else version (AsmX86_64_Posix)
        {
            asm pure nothrow @nogc
            {
                naked;

                // save current stack state
                push RBP;
                mov  RBP, RSP;
                push RBX;
                push R12;
                push R13;
                push R14;
                push R15;

                // store oldp
                mov [RDI], RSP;
                // load newp to begin context sw