nt *);
    double lgamma_r(double x, int *);

    double significand(double x);

    /* float */
    float acosf(float x);
    float asinf(float x);
    pure float atanf(float x);
    float atan2f(float x, float y);
    pure float cosf(float x);
    pure float sinf(float x);
    pure float tanf(float x);

    float acoshf(float x);
    pure float asinhf(float x);
    float atanhf(float x);
    float coshf(float x);
    float sinhf(float x);
    pure float tanhf(float x);

    float expf(float x);
    float exp2f(float x);
    float expm1f(float x);
    pure float frexpf(float x, int *exp);
    int ilogbf(float x);
    float ldexpf(float x, int exp);
    float logf(float x);
    float log10f(float x);
    float log1pf(float x);
    float log2f(float x);
    float logbf(float x);
    pure float modff(float x, float *iptr);
    float scalbnf(float x, int y);
    float scalblnf(float x, c_long y);

    pure float cbrtf(float x);
    pure float fabsf(float x);
    float hypotf(float x, float y);
    float powf(float x, float y);
    float sqrtf(float x);

    pure float erff(float x);
    float erfcf(float x);
    float lgammaf(float x);
    float tgammaf(float x);

    pure float ceilf(float x);
    pure float floorf(float x);
    pure float nearbyintf(float x);
    pure float rintf(float x);
    c_long lrintf(float x);
    long llrintf(float x);
    pure float roundf(float x);
    c_long lroundf(float x);
    long llroundf(float x);
    pure float truncf(float x);

    pure float fmodf(float x, float y);
    float remainderf(float x, float y);
    float remquof(float x, float y, int *iptr);

    pure float copysignf(float x, float y);
    pure float nanf(const char *);
    float nextafterf(float x, float y);
    float nexttowardf(float x, real y);

    float fdimf(float x, float y);
    pure float fmaxf(float x, float y);
    pure float fminf(float x, float y);

    pure float fmaf(float x, float y, float z);

    float j0f(float x);
    float j1f(float x);
    float jnf(int, float);
    float scalbf(float x, float);
    float y0f(float x);
    float y1f(float x);
    float ynf(int, float);
    float gammaf(float x);
    float dremf(float x, float);
    pure int finitef(float x);
    pure int isinff(float x);
    pure int isnanf(float x);

    float gammaf_r(float x, int *);
    float lgammaf_r(float x, int *);
    float significandf(float x);

    /* real */
    pure real acosl(real x);
    pure real asinl(real x);
    pure real atanl(real x);
    real atan2l(real x, real y);
    pure real cosl(real x);
    pure real sinl(real x);
    pure real tanl(real x);

    real acoshl(real x);
    pure real asinhl(real x);
    real atanhl(real x);
    real coshl(real x);
    real sinhl(real x);
    pure real tanhl(real x);

    real expl(real x);
    real exp2l(real x);
    real expm1l(real x);
    pure real frexpl(real x, int *exp);
    int ilogbl(real x);
    real ldexpl(real x, int exp);
    real logl(real x);
    real log10l(real x);
    real log1pl(real x);
    real log2l(real x);
    real logbl(real x);
    pure real modfl(real x, real *iptr);
    real scalbnl(real x, int y);
    real scalblnl(real x, c_long y);

    pure real cbrtl(real x);
    pure real fabsl(real x);
    real hypotl(real x, real y);
    real powl(real x, real y);
    real sqrtl(real x);

    pure real erfl(real x);
    real erfcl(real x);
    real lgammal(real x);
    real tgammal(real x);

    pure real ceill(real x);
    pure real floorl(real x);
    pure real nearbyintl(real x);
    pure real rintl(real x);
    c_long lrintl(real x);
    long llrintl(real x);
    pure real roundl(real x);
    c_long lroundl(real x);
    long llroundl(real x);
    pure real truncl(real x);

    pure real fmodl(real x, real);
    pure real remainderl(real x, real);
    pure real remquol(real x, real y, int *iptr);

    pure real copysignl(real x, real y);
    pure real nanl(const char *);
    real nextafterl(real x, real y);
    real nexttowardl(real x, real y);

    real fdiml(real x, real y);
    pure real fmaxl(real x, real y);
    pure real fminl(real x, real y);

    pure real fmal(real x, real, real);
}
else version (CRuntime_Bionic)
{
    ///
    double  acos(double x);
    ///
    float   acosf(float x);
    /// Added since Lollipop
    real    acosl(real x);

    ///
    double  asin(double x);
    ///
    float   asinf(float x);
    /// Added since Lollipop
    real    asinl(real x);

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);
    /// Added since Lollipop
    pure real    atanl(real x);

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);
    /// Added since Lollipop
    real    atan2l(real y, real x);

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);
    ///
    pure real    cosl(real x);

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);
    /// Added since Lollipop
    pure real    sinl(real x);

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);
    /// Added since Lollipop
    pure real    tanl(real x);

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    /// Added since Lollipop
    real    acoshl(real x);

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    /// Added since Lollipop
    pure real    asinhl(real x);

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    /// Added since Lollipop
    real    atanhl(real x);

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    /// Added since Lollipop
    real    coshl(real x);

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    /// Added since Lollipop
    real    sinhl(real x);

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);
    /// Added since Lollipop
    pure real    tanhl(real x);

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    real    expl(real x);

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);
    /// Added since Lollipop
    real    exp2l(real x);

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    /// Added since Lollipop
    real    expm1l(real x);

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);
    /// Added since Lollipop
    pure real    frexpl(real value, int* exp);

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);
    ///
    int     ilogbl(real x);

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);
    ///
    real    ldexpl(real x, int exp);

    ///
    double  log(double x);
    ///
    float   logf(float x);
    /// Added since Lollipop
    real    logl(real x);

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    /// Added since Lollipop
    real    log10l(real x);

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    /// Added since Lollipop
    real    log1pl(real x);

    ///
    double  log2(double x);
    ///
    float   log2f(float x);
    ///
    real    log2l(real x);

    ///
    double  logb(double x);
    ///
    float   logbf(float x);
    ///
    real    logbl(real x);

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);
    /// Added since Lollipop
    pure real    modfl(real value, real *iptr);

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);
    ///
    real    scalbnl(real x, int n);

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);
    ///
    real    scalblnl(real x, c_long n);

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    /// Added since Lollipop
    pure real    cbrtl(real x);

    ///
    pure double  fabs(double x);
    ///
    pure float   fabsf(float x);
    ///
    pure real    fabsl(real x);

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);
    /// Added since Lollipop
    real    hypotl(real x, real y);

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    /// Added since Lollipop
    real    powl(real x, real y);

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);
    /// Added since Lollipop
    real    sqrtl(real x);

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    /// Added since Lollipop
    pure real    erfl(real x);

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    /// Added since Lollipop
    real    erfcl(real x);

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    /// Added since Lollipop
    real    lgammal(real x);

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    /// Added since Lollipop
    real    tgammal(real x);

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);
    ///
    pure real    ceill(real x);

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);
    ///
    pure real    floorl(real x);

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);
    /// Added since Lollipop
    pure real    nearbyintl(real x);

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);
    /// Added since Lollipop
    pure real    rintl(real x);

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);
    /// Added since Lollipop
    c_long  lrintl(real x);

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    /// Added since Lollipop
    long    llrintl(real x);

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);
    ///
    pure real    roundl(real x);

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);
    ///
    c_long  lroundl(real x);

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);
    ///
    long    llroundl(real x);

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);
    ///
    pure real    truncl(real x);

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);
    /// Added since Lollipop
    real    fmodl(real x, real y);

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);
    /// Added since Lollipop
    real    remainderl(real x, real y);

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);
    /// Added since Lollipop
    real    remquol(real x, real y, int* quo);

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);
    ///
    pure real    copysignl(real x, real y);

    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    pure real    nanl(char* tagp);

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);
    /// Added since Lollipop
    real    nextafterl(real x, real y);

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);
    ///
    real    nexttowardl(real x, real y);

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);
    ///
    real    fdiml(real x, real y);

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);
    ///
    pure real    fmaxl(real x, real y);

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);
    ///
    pure real    fminl(real x, real y);

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
    /// Added since Lollipop
    pure real    fmal(real x, real y, real z);
}
else version (CRuntime_UClibc)
{
    // uClibc wraps 'long double' to double, so we do the same for 'real'

    ///
    double  acos(double x);
    ///
    float   acosf(float x);
    ///
    extern(D) real acosl(real x) { return acos(cast(double) x); }

    ///
    double  asin(double x);
    ///
    float   asinf(float x);
    ///
    extern(D) real asinl(real x) { return asin(cast(double) x); }

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);
    ///
    extern(D) pure real atanl(real x) { return atan(cast(double) x); }

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);
    ///
    extern(D) real atan2l(real y, real x) { return atan2(cast(double) x, cast(double) y); }

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);
    ///
    extern(D) pure real cosl(real x) { return cos(cast(double) x); }

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);
    ///
    extern(D) pure real sinl(real x) { return sin(cast(double) x); }

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);
    ///
    extern(D) pure real tanl(real x) { return tan(cast(double) x); }

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    ///
    extern(D) real acoshl(real x) { return acosh(cast(double) x); }

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    ///
    extern(D) pure real asinhl(real x) { return asinh(cast(double) x); }

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    ///
    extern(D) real atanhl(real x) { return atanh(cast(double) x); }

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    ///
    extern(D) real coshl(real x) { return cosh(cast(double) x); }

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    ///
    extern(D) real sinhl(real x) { return sinh(cast(double) x); }

    ///
    double  tanh(double x);
    ///
    float   tanhf(float x);
    ///
    extern(D) real tanhl(real x) { return tanh(cast(double) x); }

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    extern(D) real expl(real x) { return exp(cast(double) x); }

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);
    ///
    extern(D) real exp2l(real x) { return exp2(cast(double) x); }

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    ///
    extern(D) real expm1l(real x) { return expm1(cast(double) x); }

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);
    ///
    extern(D) pure real frexpl(real value, int* exp) { return frexp(cast(double) value, exp); }

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);
    ///
    extern(D) int ilogbl(real x) { return ilogb(cast(double) x); }

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);
    ///
    extern(D) real ldexpl(real x, int exp) { return ldexp(cast(double) x, exp); }

    ///
    double  log(double x);
    ///
    float   logf(float x);
    ///
    extern(D) real logl(real x) { return log(cast(double) x); }

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    ///
    extern(D) real log10l(real x) { return log10(cast(double) x); }

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    ///
    extern(D) real log1pl(real x) { return log1p(cast(double) x); }

    ///
    double  log2(double x);
    ///
    float   log2f(float x);
    ///
    extern(D) real log2l(real x) { return log2(cast(double) x); }

    ///
    double  logb(double x);
    ///
    float   logbf(float x);
    ///
    extern(D) real logbl(real x) { return logb(cast(double) x); }

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);
    ///
    extern(D) pure real modfl(real value, real *iptr) { return modf(cast(double) value, cast(double*) iptr); }

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);
    ///
    extern(D) real scalbnl(real x, int n) { return scalbln(cast(double) x, n); }

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);
    ///
    extern(D) real scalblnl(real x, c_long n) { return scalbln(cast(double) x, n); }

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    ///
    extern(D) pure real cbrtl(real x) { return cbrt(cast(double) x); }

    ///
    pure double  fabs(double x);
    ///
    pure float   fabsf(float x);
    ///
    extern(D) pure real fabsl(real x) { return fabs(cast(double) x); }

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);
    ///
    extern(D) real hypotl(real x, real y) { return hypot(cast(double) x, cast(double) y); }

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    ///
    extern(D) real powl(real x, real y) { return pow(cast(double) x, cast(double) y); }

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);
    ///
    extern(D) real sqrtl(real x) { return sqrt(cast(double) x); }

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    extern(D) pure real erfl(real x) { return erf(cast(double) x); }

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    extern(D) real erfcl(real x) { return erfc(cast(double) x); }

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    extern(D) real lgammal(real x) { return lgamma(cast(double) x); }

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    extern(D) real tgammal(real x) { return tgamma(cast(double) x); }

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);
    ///
    extern(D) pure real ceill(real x) { return ceil(cast(double) x); }

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);
    ///
    extern(D) pure real floorl(real x) { return floor(cast(double) x); }

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);
    ///
    extern(D) pure real nearbyintl(real x) { return nearbyint(cast(double) x); }

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);
    ///
    extern(D) pure real rintl(real x) { return rint(cast(double) x); }

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);
    ///
    extern(D) c_long lrintl(real x) { return lrint(cast(double) x); }

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    ///
    extern(D) long llrintl(real x) { return llrint(cast(double) x); }

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);
    ///
    extern(D) pure real roundl(real x) { return round(cast(double) x); }

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);
    ///
    extern(D) c_long lroundl(real x) { return lround(cast(double) x); }

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);
    ///
    extern(D) long llroundl(real x) { return llround(cast(double) x); }

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);
    ///
    extern(D) pure real truncl(real x) { return trunc(cast(double) x); }

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);
    ///
    extern(D) real fmodl(real x, real y) { return fmod(cast(double) x, cast(double) y); }

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);
    ///
    extern(D) real remainderl(real x, real y) { return remainder(cast(double) x, cast(double) y); }

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);
    ///
    extern(D) real remquol(real x, real y, int* quo) { return remquo(cast(double) x, cast(double) y, quo); }

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);
    ///
    extern(D) pure real copysignl(real x, real y) { return copysign(cast(double) x, cast(double) y); }

    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    extern(D) pure real nanl(char* tagp) { return nan(tagp); }

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);
    ///
    extern(D) real nextafterl(real x, real y) { return nextafter(cast(double) x, cast(double) y); }

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);
    ///
    extern(D) real nexttowardl(real x, real y) { return nexttoward(cast(double) x, cast(double) y); }

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);
    ///
    extern(D) real fdiml(real x, real y) { return fdim(cast(double) x, cast(double) y); }

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);
    ///
    extern(D) pure real fmaxl(real x, real y) { return fmax(cast(double) x, cast(double) y); }

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);
    ///
    extern(D) pure real fminl(real x, real y) { return fmin(cast(double) x, cast(double) y); }

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
    ///
    extern(D) pure real fmal(real x, real y, real z) { return fma(cast(double) x, cast(double) y, cast(double) z); }
}
else
{
    ///
    double  acos(double x);
    ///
    float   acosf(float x);
    ///
    real    acosl(real x);

    ///
    double  asin(double x);
    ///
    float   asinf(float x);
    ///
    real    asinl(real x);

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);
    ///
    pure real    atanl(real x);

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);
    ///
    real    atan2l(real y, real x);

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);
    ///
    pure real    cosl(real x);

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);
    ///
    pure real    sinl(real x);

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);
    ///
    pure real    tanl(real x);

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    ///
    real    acoshl(real x);

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    ///
    pure real    asinhl(real x);

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    ///
    real    atanhl(real x);

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    ///
    real    coshl(real x);

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    ///
    real    sinhl(real x);

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);
    ///
    pure real    tanhl(real x);

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    real    expl(real x);

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);
    ///
    real    exp2l(real x);

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    ///
    real    expm1l(real x);

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);
    ///
    pure real    frexpl(real value, int* exp);

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);
    ///
    int     ilogbl(real x);

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);
    ///
    real    ldexpl(real x, int exp);

    ///
    double  log(double x);
    ///
    float   logf(float x);
    ///
    real    logl(real x);

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    ///
    real    log10l(real x);

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    ///
    real    log1pl(real x);

    ///
    double  log2(double x);
    ///
    float   log2f(float x);
    ///
    real    log2l(real x);

    ///
    double  logb(double x);
    ///
    float   logbf(float x);
    ///
    real    logbl(real x);

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);
    ///
    pure real    modfl(real value, real *iptr);

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);
    ///
    real    scalbnl(real x, int n);

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);
    ///
    real    scalblnl(real x, c_long n);

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    ///
    pure real    cbrtl(real x);

    ///
    pure double  fabs(double x);
    version (CRuntime_Microsoft)
    {
    }
    else
    {
        ///
        pure float   fabsf(float x);
        ///
        pure real    fabsl(real x);
    }

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);
    ///
    real    hypotl(real x, real y);

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    ///
    real    powl(real x, real y);

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);
    ///
    real    sqrtl(real x);

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    pure real    erfl(real x);

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    real    erfcl(real x);

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    real    lgammal(real x);

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    real    tgammal(real x);

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);
    ///
    pure real    ceill(real x);

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);
    ///
    pure real    floorl(real x);

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);
    ///
    pure real    nearbyintl(real x);

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);
    ///
    pure real    rintl(real x);

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);
    ///
    c_long  lrintl(real x);

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    ///
    long    llrintl(real x);

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);
    ///
    pure real    roundl(real x);

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);
    ///
    c_long  lroundl(real x);

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);
    ///
    long    llroundl(real x);

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);
    ///
    pure real    truncl(real x);

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);
    ///
    real    fmodl(real x, real y);

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);
    ///
    real    remainderl(real x, real y);

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);
    ///
    real    remquol(real x, real y, int* quo);

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);
    ///
    pure real    copysignl(real x, real y);

    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    pure real    nanl(char* tagp);

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);
    ///
    real    nextafterl(real x, real y);

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);
    ///
    real    nexttowardl(real x, real y);

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);
    ///
    real    fdiml(real x, real y);

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);
    ///
    pure real    fmaxl(real x, real y);

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);
    ///
    pure real    fminl(real x, real y);

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
    ///
    pure real    fmal(real x, real y, real z);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_signal.h.html, _signal.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_signal.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.signal;

extern (C):
@system:
nothrow:
@nogc:

// this should be volatile
///
alias int sig_atomic_t;

private alias void function(int) sigfn_t;

version (Posix)
{
    ///
    enum SIG_ERR    = cast(sigfn_t) -1;
    ///
    enum SIG_DFL    = cast(sigfn_t) 0;
    ///
    enum SIG_IGN    = cast(sigfn_t) 1;

    // standard C signals
    ///
    enum SIGABRT    = 6;  // Abnormal termination
    ///
    enum SIGFPE     = 8;  // Floating-point error
    ///
    enum SIGILL     = 4;  // Illegal hardware instruction
    ///
    enum SIGINT     = 2;  // Terminal interrupt character
    ///
    enum SIGSEGV    = 11; // Invalid memory reference
    ///
    enum SIGTERM    = 15; // Termination
}
else version (Windows)
{
    ///
    enum SIG_ERR    = cast(sigfn_t) -1;
    ///
    enum SIG_DFL    = cast(sigfn_t) 0;
    ///
    enum SIG_IGN    = cast(sigfn_t) 1;

    // standard C signals
    ///
    enum SIGABRT    = 22; // Abnormal termination
    ///
    enum SIGFPE     = 8;  // Floating-point error
    ///
    enum SIGILL     = 4;  // Illegal hardware instruction
    ///
    enum SIGINT     = 2;  // Terminal interrupt character
    ///
    enum SIGSEGV    = 11; // Invalid memory reference
    ///
    enum SIGTERM    = 15; // Termination
}

///
sigfn_t signal(int sig, sigfn_t func);
///
int     raise(int sig);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_stdarg.h.html, _stdarg.h)
 *
 * Copyright: Copyright Digital Mars 2000 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Walter Bright, Hauke Duden
 * Standards: ISO/IEC 9899:1999 (E)
 * Source: $(DRUNTIMESRC core/stdc/_stdarg.d)
 */

/* NOTE: This file has been patched from the original DMD distribution to
 * work with the GDC compiler.
 */
module core.stdc.stdarg;

@system:
//@nogc:    // Not yet, need to make TypeInfo's member functions @nogc first
nothrow:

version (GNU)
{
    import gcc.builtins;
    alias __builtin_va_list __gnuc_va_list;


    /*********************
     * The argument pointer type.
     */
    alias __gnuc_va_list va_list;


    /**********
     * Initialize ap.
     * parmn should be the last named parameter.
     */
    void va_start(T)(out va_list ap, ref T parmn);


    /************
     * Retrieve and return the next value that is type T.
     */
    T va_arg(T)(ref va_list ap);


    /*************
     * Retrieve and store through parmn the next value that is of type T.
     */
    void va_arg(T)(ref va_list ap, ref T parmn);


    /*************
     * Retrieve and store through parmn the next value that is of TypeInfo ti.
     * Used when the static type is not known.
     */
    version (X86)
    {
        ///
        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)
        {
            auto p = ap;
            auto tsize = ti.tsize;
            ap = cast(va_list)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
            parmn[0..tsize] = p[0..tsize];
        }
    }
    else version (X86_64)
    {
        /// Layout of this struct must match __builtin_va_list for C ABI compatibility
        struct __va_list
        {
            uint offset_regs = 6 * 8;            // no regs
            uint offset_fpregs = 6 * 8 + 8 * 16; // no fp regs
            void* stack_args;
            void* reg_args;
        }

        ///
        void va_arg()(ref va_list apx, TypeInfo ti, void* parmn)
        {
            __va_list* ap = cast(__va_list*)apx;
            TypeInfo arg1, arg2;
            if (!ti.argTypes(arg1, arg2))
            {
                bool inXMMregister(TypeInfo arg) pure nothrow @safe
                {
                    return (arg.flags & 2) != 0;
                }

                TypeInfo_Vector v1 = arg1 ? cast(TypeInfo_Vector)arg1 : null;
                if (arg1 && (arg1.tsize() <= 8 || v1))
                {   // Arg is passed in one register
                    auto tsize = arg1.tsize();
                    void* p;
                    bool stack = false;
                    auto offset_fpregs_save = ap.offset_fpregs;
                    auto offset_regs_save = ap.offset_regs;
                L1:
                    if (inXMMregister(arg1) || v1)
                    {   // Passed in XMM register
                        if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)
                        {
                            p = ap.reg_args + ap.offset_fpregs;
                            ap.offset_fpregs += 16;
                        }
                        else
                        {
                            p = ap.stack_args;
                            ap.stack_args += (tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                            stack = true;
                        }
                    }
                    else
                    {   // Passed in regular register
                        if (ap.offset_regs < 6 * 8 && !stack)
                        {
                            p = ap.reg_args + ap.offset_regs;
                            ap.offset_regs += 8;
                        }
                        else
                        {
                            p = ap.stack_args;
                            ap.stack_args += 8;
                            stack = true;
                        }
                    }
                    parmn[0..tsize] = p[0..tsize];

                    if (arg2)
                    {
                        if (inXMMregister(arg2))
                        {   // Passed in XMM register
                            if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)
                            {
                                p = ap.reg_args + ap.offset_fpregs;
                                ap.offset_fpregs += 16;
                            }
                            else
                            {
                                if (!stack)
                                {   // arg1 is really on the stack, so rewind and redo
                                    ap.offset_fpregs = offset_fpregs_save;
                                    ap.offset_regs = offset_regs_save;
                                    stack = true;
                                    goto L1;
                                }
                                p = ap.stack_args;
                                ap.stack_args += (arg2.tsize() + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                            }
                        }
                        else
                        {   // Passed in regular register
                            if (ap.offset_regs < 6 * 8 && !stack)
                            {
                                p = ap.reg_args + ap.offset_regs;
                                ap.offset_regs += 8;
                            }
                            else
                            {
                                if (!stack)
                                {   // arg1 is really on the stack, so rewind and redo
                                    ap.offset_fpregs = offset_fpregs_save;
                                    ap.offset_regs = offset_regs_save;
                                    stack = true;
                                    goto L1;
                                }
                                p = ap.stack_args;
                                ap.stack_args += 8;
                            }
                        }
                        auto sz = ti.tsize() - 8;
                        (parmn + 8)[0..sz] = p[0..sz];
                    }
                }
                else
                {   // Always passed in memory
                    // The arg may have more strict alignment than the stack
                    auto talign = ti.talign();
                    auto tsize = ti.tsize();
                    auto p = cast(void*)((cast(size_t)ap.stack_args + talign - 1) & ~(talign - 1));
                    ap.stack_args = cast(void*)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
                    parmn[0..tsize] = p[0..tsize];
                }
            }
            else
            {
                assert(false, "not a valid argument type for va_arg");
            }
        }
    }
    else version (ARM)
    {
        ///
        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)
        {
            auto p = *cast(void**) &ap;
            auto tsize = ti.tsize();
            *cast(void**) &ap += ( tsize + size_t.sizeof - 1 ) & ~( size_t.sizeof - 1 );
            parmn[0..tsize] = p[0..tsize];
        }
    }
    else
    {
        ///
        void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)
        {
            static assert(false, "Unsupported platform");
        }
    }


    /***********************
     * End use of ap.
     */
    alias __builtin_va_end va_end;


    /***********************
     * Make a copy of ap.
     */
    alias __builtin_va_copy va_copy;

}
else version (X86)
{
    /*********************
     * The argument pointer type.
     */
    alias char* va_list;

    /**********
     * Initialize ap.
     * For 32 bit code, parmn should be the last named parameter.
     * For 64 bit code, parmn should be __va_argsave.
     */
    void va_start(T)(out va_list ap, ref T parmn)
    {
        ap = cast(va_list)( cast(void*) &parmn + ( ( T.sizeof + int.sizeof - 1 ) & ~( int.sizeof - 1 ) ) );
    }

    /************
     * Retrieve and return the next value that is type T.
     * Should use the other va_arg instead, as this won't work for 64 bit code.
     */
    T va_arg(T)(ref va_list ap)
    {
        T arg = *cast(T*) ap;
        ap = cast(va_list)( cast(void*) ap + ( ( T.sizeof + int.sizeof - 1 ) & ~( int.sizeof - 1 ) ) );
        return arg;
    }

    /************
     * Retrieve and return the next value that is type T.
     * This is the preferred version.
     */
    void va_arg(T)(ref va_list ap, ref T parmn)
    {
        parmn = *cast(T*)ap;
        ap = cast(va_list)(cast(void*)ap + ((T.sizeof + int.sizeof - 1) & ~(int.sizeof - 1)));
    }

    /*************
     * Retrieve and store through parmn the next value that is of TypeInfo ti.
     * Used when the static type is not known.
     */
    void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)
    {
        // Wait until everyone updates to get TypeInfo.talign
        //auto talign = ti.talign;
        //auto p = cast(void*)(cast(size_t)ap + talign - 1) & ~(talign - 1);
        auto p = ap;
        auto tsize = ti.tsize;
        ap = cast(va_list)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
        parmn[0..tsize] = p[0..tsize];
    }

    /***********************
     * End use of ap.
     */
    void va_end(va_list ap)
    {
    }

    ///
    void va_copy(out va_list dest, va_list src)
    {
        dest = src;
    }
}
else version (Windows) // Win64
{   /* Win64 is characterized by all arguments fitting into a register size.
     * Smaller ones are padded out to register size, and larger ones are passed by
     * reference.
     */

    /*********************
     * The argument pointer type.
     */
    alias char* va_list;

    /**********
     * Initialize ap.
     * parmn should be the last named parameter.
     */
    void va_start(T)(out va_list ap, ref T parmn); // Compiler intrinsic

    /************
     * Retrieve and return the next value that is type T.
     */
    T va_arg(T)(ref va_list ap)
    {
        static if (T.sizeof > size_t.sizeof)
            T arg = **cast(T**)ap;
        else
            T arg = *cast(T*)ap;
        ap = cast(va_list)(cast(void*)ap + ((size_t.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
        return arg;
    }

    /************
     * Retrieve and return the next value that is type T.
     * This is the preferred version.
     */
    void va_arg(T)(ref va_list ap, ref T parmn)
    {
        static if (T.sizeof > size_t.sizeof)
            parmn = **cast(T**)ap;
        else
            parmn = *cast(T*)ap;
        ap = cast(va_list)(cast(void*)ap + ((size_t.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
    }

    /*************
     * Retrieve and store through parmn the next value that is of TypeInfo ti.
     * Used when the static type is not known.
     */
    void va_arg()(ref va_list ap, TypeInfo ti, void* parmn)
    {
        // Wait until everyone updates to get TypeInfo.talign
        //auto talign = ti.talign;
        //auto p = cast(void*)(cast(size_t)ap + talign - 1) & ~(talign - 1);
        auto p = ap;
        auto tsize = ti.tsize;
        ap = cast(va_list)(cast(size_t)p + ((size_t.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
        void* q = (tsize > size_t.sizeof) ? *cast(void**)p : p;
        parmn[0..tsize] = q[0..tsize];
    }

    /***********************
     * End use of ap.
     */
    void va_end(va_list ap)
    {
    }

    ///
    void va_copy(out va_list dest, va_list src)
    {
        dest = src;
    }
}
else version (X86_64)
{
    // Determine if type is a vector type
    template isVectorType(T)
    {
        enum isVectorType = false;
    }

    template isVectorType(T : __vector(T[N]), size_t N)
    {
        enum isVectorType = true;
    }

    // Layout of this struct must match __gnuc_va_list for C ABI compatibility
    struct __va_list_tag
    {
        uint offset_regs = 6 * 8;            // no regs
        uint offset_fpregs = 6 * 8 + 8 * 16; // no fp regs
        void* stack_args;
        void* reg_args;
    }
    alias __va_list = __va_list_tag;

    align(16) struct __va_argsave_t
    {
        size_t[6] regs;   // RDI,RSI,RDX,RCX,R8,R9
        real[8] fpregs;   // XMM0..XMM7
        __va_list va;
    }

    /*
     * Making it an array of 1 causes va_list to be passed as a pointer in
     * function argument lists
     */
    alias va_list = __va_list*;

    ///
    void va_start(T)(out va_list ap, ref T parmn); // Compiler intrinsic

    ///
    T va_arg(T)(va_list ap)
    {   T a;
        va_arg(ap, a);
        return a;
    }

    ///
    void va_arg(T)(va_list apx, ref T parmn)
    {
        __va_list* ap = cast(__va_list*)apx;
        static if (is(T U == __argTypes))
        {
            static if (U.length == 0 || T.sizeof > 16 || (U[0].sizeof > 8 && !isVectorType!(U[0])))
            {   // Always passed in memory
                // The arg may have more strict alignment than the stack
                auto p = (cast(size_t)ap.stack_args + T.alignof - 1) & ~(T.alignof - 1);
                ap.stack_args = cast(void*)(p + ((T.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
                parmn = *cast(T*)p;
            }
            else static if (U.length == 1)
            {   // Arg is passed in one register
                alias U[0] T1;
                static if (is(T1 == double) || is(T1 == float) || isVectorType!(T1))
                {   // Passed in XMM register
                    if (ap.offset_fpregs < (6 * 8 + 16 * 8))
                    {
                        parmn = *cast(T*)(ap.reg_args + ap.offset_fpregs);
                        ap.offset_fpregs += 16;
                    }
                    else
                    {
                        parmn = *cast(T*)ap.stack_args;
                        ap.stack_args += (T1.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                    }
                }
                else
                {   // Passed in regular register
                    if (ap.offset_regs < 6 * 8 && T.sizeof <= 8)
                    {
                        parmn = *cast(T*)(ap.reg_args + ap.offset_regs);
                        ap.offset_regs += 8;
                    }
                    else
                    {
                        auto p = (cast(size_t)ap.stack_args + T.alignof - 1) & ~(T.alignof - 1);
                        ap.stack_args = cast(void*)(p + ((T.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
                        parmn = *cast(T*)p;
                    }
                }
            }
            else static if (U.length == 2)
            {   // Arg is passed in two registers
                alias U[0] T1;
                alias U[1] T2;
                auto p = cast(void*)&parmn + 8;

                // Both must be in registers, or both on stack, hence 4 cases

                static if ((is(T1 == double) || is(T1 == float)) &&
                           (is(T2 == double) || is(T2 == float)))
                {
                    if (ap.offset_fpregs < (6 * 8 + 16 * 8) - 16)
                    {
                        *cast(T1*)&parmn = *cast(T1*)(ap.reg_args + ap.offset_fpregs);
                        *cast(T2*)p = *cast(T2*)(ap.reg_args + ap.offset_fpregs + 16);
                        ap.offset_fpregs += 32;
                    }
                    else
                    {
                        *cast(T1*)&parmn = *cast(T1*)ap.stack_args;
                        ap.stack_args += (T1.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                        *cast(T2*)p = *cast(T2*)ap.stack_args;
                        ap.stack_args += (T2.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                    }
                }
                else static if (is(T1 == double) || is(T1 == float))
                {
                    void* a = void;
                    if (ap.offset_fpregs < (6 * 8 + 16 * 8) &&
                        ap.offset_regs < 6 * 8 && T2.sizeof <= 8)
                    {
                        *cast(T1*)&parmn = *cast(T1*)(ap.reg_args + ap.offset_fpregs);
                        ap.offset_fpregs += 16;
                        a = ap.reg_args + ap.offset_regs;
                        ap.offset_regs += 8;
                    }
                    else
                    {
                        *cast(T1*)&parmn = *cast(T1*)ap.stack_args;
                        ap.stack_args += (T1.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                        a = ap.stack_args;
                        ap.stack_args += 8;
                    }
                    // Be careful not to go past the size of the actual argument
                    const sz2 = T.sizeof - 8;
                    p[0..sz2] = a[0..sz2];
                }
                else static if (is(T2 == double) || is(T2 == float))
                {
                    if (ap.offset_regs < 6 * 8 && T1.sizeof <= 8 &&
                        ap.offset_fpregs < (6 * 8 + 16 * 8))
                    {
                        *cast(T1*)&parmn = *cast(T1*)(ap.reg_args + ap.offset_regs);
                        ap.offset_regs += 8;
                        *cast(T2*)p = *cast(T2*)(ap.reg_args + ap.offset_fpregs);
                        ap.offset_fpregs += 16;
                    }
                    else
                    {
                        *cast(T1*)&parmn = *cast(T1*)ap.stack_args;
                        ap.stack_args += 8;
                        *cast(T2*)p = *cast(T2*)ap.stack_args;
                        ap.stack_args += (T2.sizeof + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                    }
                }
                else // both in regular registers
                {
                    void* a = void;
                    if (ap.offset_regs < 5 * 8 && T1.sizeof <= 8 && T2.sizeof <= 8)
                    {
                        *cast(T1*)&parmn = *cast(T1*)(ap.reg_args + ap.offset_regs);
                        ap.offset_regs += 8;
                        a = ap.reg_args + ap.offset_regs;
                        ap.offset_regs += 8;
                    }
                    else
                    {
                        *cast(T1*)&parmn = *cast(T1*)ap.stack_args;
                        ap.stack_args += 8;
                        a = ap.stack_args;
                        ap.stack_args += 8;
                    }
                    // Be careful not to go past the size of the actual argument
                    const sz2 = T.sizeof - 8;
                    p[0..sz2] = a[0..sz2];
                }
            }
            else
            {
                static assert(false);
            }
        }
        else
        {
            static assert(false, "not a valid argument type for va_arg");
        }
    }

    ///
    void va_arg()(va_list apx, TypeInfo ti, void* parmn)
    {
        __va_list* ap = cast(__va_list*)apx;
        TypeInfo arg1, arg2;
        if (!ti.argTypes(arg1, arg2))
        {
            bool inXMMregister(TypeInfo arg) pure nothrow @safe
            {
                return (arg.flags & 2) != 0;
            }

            TypeInfo_Vector v1 = arg1 ? cast(TypeInfo_Vector)arg1 : null;
            if (arg1 && (arg1.tsize <= 8 || v1))
            {   // Arg is passed in one register
                auto tsize = arg1.tsize;
                void* p;
                bool stack = false;
                auto offset_fpregs_save = ap.offset_fpregs;
                auto offset_regs_save = ap.offset_regs;
            L1:
                if (inXMMregister(arg1) || v1)
                {   // Passed in XMM register
                    if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)
                    {
                        p = ap.reg_args + ap.offset_fpregs;
                        ap.offset_fpregs += 16;
                    }
                    else
                    {
                        p = ap.stack_args;
                        ap.stack_args += (tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                        stack = true;
                    }
                }
                else
                {   // Passed in regular register
                    if (ap.offset_regs < 6 * 8 && !stack)
                    {
                        p = ap.reg_args + ap.offset_regs;
                        ap.offset_regs += 8;
                    }
                    else
                    {
                        p = ap.stack_args;
                        ap.stack_args += 8;
                        stack = true;
                    }
                }
                parmn[0..tsize] = p[0..tsize];

                if (arg2)
                {
                    if (inXMMregister(arg2))
                    {   // Passed in XMM register
                        if (ap.offset_fpregs < (6 * 8 + 16 * 8) && !stack)
                        {
                            p = ap.reg_args + ap.offset_fpregs;
                            ap.offset_fpregs += 16;
                        }
                        else
                        {
                            if (!stack)
                            {   // arg1 is really on the stack, so rewind and redo
                                ap.offset_fpregs = offset_fpregs_save;
                                ap.offset_regs = offset_regs_save;
                                stack = true;
                                goto L1;
                            }
                            p = ap.stack_args;
                            ap.stack_args += (arg2.tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1);
                        }
                    }
                    else
                    {   // Passed in regular register
                        if (ap.offset_regs < 6 * 8 && !stack)
                        {
                            p = ap.reg_args + ap.offset_regs;
                            ap.offset_regs += 8;
                        }
                        else
                        {
                            if (!stack)
                            {   // arg1 is really on the stack, so rewind and redo
                                ap.offset_fpregs = offset_fpregs_save;
                                ap.offset_regs = offset_regs_save;
                                stack = true;
                                goto L1;
                            }
                            p = ap.stack_args;
                            ap.stack_args += 8;
                        }
                    }
                    auto sz = ti.tsize - 8;
                    (parmn + 8)[0..sz] = p[0..sz];
                }
            }
            else
            {   // Always passed in memory
                // The arg may have more strict alignment than the stack
                auto talign = ti.talign;
                auto tsize = ti.tsize;
                auto p = cast(void*)((cast(size_t)ap.stack_args + talign - 1) & ~(talign - 1));
                ap.stack_args = cast(void*)(cast(size_t)p + ((tsize + size_t.sizeof - 1) & ~(size_t.sizeof - 1)));
                parmn[0..tsize] = p[0..tsize];
            }
        }
        else
        {
            assert(false, "not a valid argument type for va_arg");
        }
    }

    ///
    void va_end(va_list ap)
    {
    }

    import core.stdc.stdlib : alloca;

    ///
    void va_copy(out va_list dest, va_list src, void* storage = alloca(__va_list_tag.sizeof))
    {
        // Instead of copying the pointers, and aliasing the source va_list,
        // the default argument alloca will allocate storage in the caller's
        // stack frame.  This is still not correct (it should be allocated in
        // the place where the va_list variable is declared) but most of the
        // time the caller's stack frame _is_ the place where the va_list is
        // allocated, so in most cases this will now work.
        dest = cast(va_list)storage;
        *dest = *src;
    }
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                              /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_stddef.h.html, _stddef.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_stddef.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.stddef;

extern (C):
@trusted: // Types only.
nothrow:
@nogc:

///
alias nullptr_t = typeof(null);

// size_t and ptrdiff_t are defined in the object module.

version (Windows)
{
    ///
    alias wchar wchar_t;
}
else version (Posix)
{
    ///
    alias dchar wchar_t;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_stdint.h.html, _stdint.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2018
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_stdint.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.stdint;

private import core.stdc.config;
private import core.stdc.stddef; // for wchar_t
private import core.stdc.signal; // for sig_atomic_t
private import core.stdc.wchar_; // for wint_t


// Can't be `private` because of @@@BUG11173@@@.
T _typify(T)(T val) @safe pure nothrow { return val; }

extern (C):
@trusted: // Types and constants only.
nothrow:
@nogc:


static if (is(ucent))
{
    alias int128_t = cent;   ///
    alias uint128_t = ucent; ///
}

version (Windows)
{
    alias int8_t   = byte;   ///
    alias int16_t  = short;  ///
    alias uint8_t  = ubyte;  ///
    alias uint16_t = ushort; ///
    version (CRuntime_DigitalMars)
    {
        alias int32_t  = cpp_long;  ///
        alias uint32_t = cpp_ulong; ///
    }
    else
    {
        alias int32_t  = int;  ///
        alias uint32_t = uint; ///
    }
    alias int64_t  = long;   ///
    alias uint64_t = ulong;  ///

    alias int_least8_t   = byte;     ///
    alias uint_least8_t  = ubyte;    ///
    alias int_least16_t  = short;    ///
    alias uint_least16_t = ushort;   ///
    alias int_least32_t  = int32_t;  ///
    alias uint_least32_t = uint32_t; ///
    alias int_least64_t  = long;     ///
    alias uint_least64_t = ulong;    ///

    alias int_fast8_t   = byte;     ///
    alias uint_fast8_t  = ubyte;    ///
    alias int_fast16_t  = int;      ///
    alias uint_fast16_t = uint;     ///
    alias int_fast32_t  = int32_t;  ///
    alias uint_fast32_t = uint32_t; ///
    alias int_fast64_t  = long;     ///
    alias uint_fast64_t = ulong;    ///

    alias intptr_t  = ptrdiff_t; ///
    alias uintptr_t = size_t;    ///
    alias intmax_t  = long;      ///
    alias uintmax_t = ulong;     ///
}
else version (OSX)
{
    alias int8_t   = byte;          ///
    alias int16_t  = short;         ///
    alias uint8_t  = ubyte;         ///
    alias uint16_t = ushort;        ///
    alias int32_t  = int;           ///
    alias uint32_t = uint;          ///
    alias int64_t  = cpp_longlong;  ///
    alias uint64_t = cpp_ulonglong; ///

    alias int_least8_t   = byte;     ///
    alias uint_least8_t  = ubyte;    ///
    alias int_least16_t  = short;    ///
    alias uint_least16_t = ushort;   ///
    alias int_least32_t  = int;      ///
    alias uint_least32_t = uint;     ///
    alias int_least64_t  = int64_t;  ///
    alias uint_least64_t = uint64_t; ///

    alias int_fast8_t   = byte;     ///
    alias uint_fast8_t  = ubyte;    ///
    alias int_fast16_t  = short;    ///
    alias uint_fast16_t = ushort;   ///
    alias int_fast32_t  = int;      ///
    alias uint_fast32_t = uint;     ///
    alias int_fast64_t  = int64_t;  ///
    alias uint_fast64_t = uint64_t; ///

    alias intptr_t  = cpp_long;  ///
    alias uintptr_t = cpp_ulong; ///
    alias intmax_t  = long;      ///
    alias uintmax_t = ulong;     ///
}
else version (Posix)
{
    alias int8_t   = byte;   ///
    alias int16_t  = short;  ///
    alias uint8_t  = ubyte;  ///
    alias uint16_t = ushort; ///
    alias int32_t  = int;    ///
    alias uint32_t = uint;   ///
    alias int64_t  = long;   ///
    alias uint64_t = ulong;  ///

    alias int_least8_t   = byte;   ///
    alias uint_least8_t  = ubyte;  ///
    alias int_least16_t  = short;  ///
    alias uint_least16_t = ushort; ///
    alias int_least32_t  = int;    ///
    alias uint_least32_t = uint;   ///
    alias int_least64_t  = long;   ///
    alias uint_least64_t = ulong;  ///

    version (FreeBSD)
    {
        alias int_fast8_t   = int;  ///
        alias uint_fast8_t  = uint; ///
        alias int_fast16_t  = int;  ///
        alias uint_fast16_t = uint; ///
        alias int_fast32_t  = int;  ///
        alias uint_fast32_t = uint; ///
    }
    else
    {
        alias int_fast8_t   = byte;      ///
        alias uint_fast8_t  = ubyte;     ///
        alias int_fast16_t  = ptrdiff_t; ///
        alias uint_fast16_t = size_t;    ///
        alias int_fast32_t  = ptrdiff_t; ///
        alias uint_fast32_t = size_t;    ///
    }
    alias int_fast64_t  = long;      ///
    alias uint_fast64_t = ulong;     ///

    alias intptr_t  = ptrdiff_t; ///
    alias uintptr_t = size_t;    ///
    alias intmax_t  = long;      ///
    alias uintmax_t = ulong;     ///
}
else
{
    static assert(0);
}



///
enum int8_t   INT8_MIN  = int8_t.min;
///
enum int8_t   INT8_MAX  = int8_t.max;
///
enum int16_t  INT16_MIN = int16_t.min;
///
enum int16_t  INT16_MAX = int16_t.max;
///
enum int32_t  INT32_MIN = int32_t.min;
///
enum int32_t  INT32_MAX = int32_t.max;
///
enum int64_t  INT64_MIN = int64_t.min;
///
enum int64_t  INT64_MAX = int64_t.max;

///
enum uint8_t  UINT8_MAX  = uint8_t.max;
///
enum uint16_t UINT16_MAX = uint16_t.max;
///
enum uint32_t UINT32_MAX = uint32_t.max;
///
enum uint64_t UINT64_MAX = uint64_t.max;

///
enum int_least8_t    INT_LEAST8_MIN   = int_least8_t.min;
///
enum int_least8_t    INT_LEAST8_MAX   = int_least8_t.max;
///
enum int_least16_t   INT_LEAST16_MIN  = int_least16_t.min;
///
enum int_least16_t   INT_LEAST16_MAX  = int_least16_t.max;
///
enum int_least32_t   INT_LEAST32_MIN  = int_least32_t.min;
///
enum int_least32_t   INT_LEAST32_MAX  = int_least32_t.max;
///
enum int_least64_t   INT_LEAST64_MIN  = int_least64_t.min;
///
enum int_least64_t   INT_LEAST64_MAX  = int_least64_t.max;

///
enum uint_least8_t   UINT_LEAST8_MAX  = uint_least8_t.max;
///
enum uint_least16_t  UINT_LEAST16_MAX = uint_least16_t.max;
///
enum uint_least32_t  UINT_LEAST32_MAX = uint_least32_t.max;
///
enum uint_least64_t  UINT_LEAST64_MAX = uint_least64_t.max;

///
enum int_fast8_t   INT_FAST8_MIN   = int_fast8_t.min;
///
enum int_fast8_t   INT_FAST8_MAX   = int_fast8_t.max;
///
enum int_fast16_t  INT_FAST16_MIN  = int_fast16_t.min;
///
enum int_fast16_t  INT_FAST16_MAX  = int_fast16_t.max;
///
enum int_fast32_t  INT_FAST32_MIN  = int_fast32_t.min;
///
enum int_fast32_t  INT_FAST32_MAX  = int_fast32_t.max;
///
enum int_fast64_t  INT_FAST64_MIN  = int_fast64_t.min;
///
enum int_fast64_t  INT_FAST64_MAX  = int_fast64_t.max;

///
enum uint_fast8_t  UINT_FAST8_MAX  = uint_fast8_t.max;
///
enum uint_fast16_t UINT_FAST16_MAX = uint_fast16_t.max;
///
enum uint_fast32_t UINT_FAST32_MAX = uint_fast32_t.max;
///
enum uint_fast64_t UINT_FAST64_MAX = uint_fast64_t.max;

///
enum intptr_t  INTPTR_MIN  = intptr_t.min;
///
enum intptr_t  INTPTR_MAX  = intptr_t.max;

///
enum uintptr_t UINTPTR_MIN = uintptr_t.min;
///
enum uintptr_t UINTPTR_MAX = uintptr_t.max;

///
enum intmax_t  INTMAX_MIN  = intmax_t.min;
///
enum intmax_t  INTMAX_MAX  = intmax_t.max;

///
enum uintmax_t UINTMAX_MAX = uintmax_t.max;

///
enum ptrdiff_t PTRDIFF_MIN = ptrdiff_t.min;
///
enum ptrdiff_t PTRDIFF_MAX = ptrdiff_t.max;

///
enum sig_atomic_t SIG_ATOMIC_MIN = sig_atomic_t.min;
///
enum sig_atomic_t SIG_ATOMIC_MAX = sig_atomic_t.max;

///
enum size_t  SIZE_MAX  = size_t.max;

///
enum wchar_t WCHAR_MIN = wchar_t.min;
///
enum wchar_t WCHAR_MAX = wchar_t.max;

///
enum wint_t  WINT_MIN  = wint_t.min;
///
enum wint_t  WINT_MAX  = wint_t.max;

///
alias INT8_C  = _typify!int8_t ;
///
alias INT16_C = _typify!int16_t;
///
alias INT32_C = _typify!int32_t;
///
alias INT64_C = _typify!int64_t;

///
alias UINT8_C  = _typify!uint8_t ;
///
alias UINT16_C = _typify!uint16_t;
///
alias UINT32_C = _typify!uint32_t;
///
alias UINT64_C = _typify!uint64_t;

///
alias INTMAX_C  = _typify!intmax_t ;
///
alias UINTMAX_C = _typify!uintmax_t;
                                                                                                                                                                                                                                                                                                                      /**
 * D header file for C99 <stdio.h>
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_stdio.h.html, _stdio.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly,
 *            Alex Rnne Petersen
 * Source:    https://github.com/dlang/druntime/blob/master/src/core/stdc/stdio.d
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.stdio;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

private
{
    import core.stdc.config;
    import core.stdc.stdarg; // for va_list
    import core.stdc.stdint : intptr_t;

  version (FreeBSD)
  {
    import core.sys.posix.sys.types;
  }
  else version (OpenBSD)
  {
    import core.sys.posix.sys.types;
  }
  version (NetBSD)
  {
    import core.sys.posix.sys.types;
  }
  version (DragonFlyBSD)
  {
    import core.sys.posix.sys.types;
  }
}

extern (C):
@system:
nothrow:
@nogc:

version (CRuntime_DigitalMars)
{
    enum
    {
        ///
        BUFSIZ       = 0x4000,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 256, // 255 plus NULL
        ///
        TMP_MAX      = 32767,
        ///
        SYS_OPEN     = 20,      // non-standard
    }

    ///
    enum int     _NFILE     = 60;       // non-standard
    ///
    enum string  _P_tmpdir  = "\\"; // non-standard
    ///
    enum wstring _wP_tmpdir = "\\"; // non-standard
    ///
    enum int     L_tmpnam   = _P_tmpdir.length + 12;
}
else version (CRuntime_Microsoft)
{
    enum
    {
        ///
        BUFSIZ       = 512,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 260,
        /// Actually int.max since Visual Studio 2015.
        TMP_MAX      = 32767,
        ///
        _SYS_OPEN    = 20,      // non-standard
    }

    ///
    enum int     _NFILE     = 512;       // non-standard
    /// Removed since Visual Studio 2015.
    enum string  _P_tmpdir  = "\\"; // non-standard
    /// Removed since Visual Studio 2015.
    enum wstring _wP_tmpdir = "\\"; // non-standard
    /// Actually 260 since Visual Studio 2015.
    enum int     L_tmpnam   = _P_tmpdir.length + 12;
}
else version (CRuntime_Glibc)
{
    enum
    {
        ///
        BUFSIZ       = 8192,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 16,
        ///
        FILENAME_MAX = 4095,
        ///
        TMP_MAX      = 238328,
        ///
        L_tmpnam     = 20
    }
}
else version (CRuntime_Musl)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 1000,
        ///
        FILENAME_MAX = 4096,
        ///
        TMP_MAX      = 10000,
        ///
        L_tmpnam     = 20
    }
}
else version (Darwin)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX      = 308915776,
        ///
        L_tmpnam     = 1024,
    }

    private
    {
        struct __sbuf
        {
            ubyte*  _base;
            int     _size;
        }

        struct __sFILEX
        {

        }
    }
}
else version (FreeBSD)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX      = 308915776,
        ///
        L_tmpnam     = 1024
    }

    struct __sbuf
    {
        ubyte *_base;
        int _size;
    }
}
else version (NetBSD)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX      = 308915776,
        ///
        L_tmpnam     = 1024
    }

    struct __sbuf
    {
        ubyte *_base;
        int _size;
    }
}
else version (OpenBSD)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX      = 0x7fffffff,
        ///
        L_tmpnam     = 1024
    }

    struct __sbuf
    {
        ubyte *_base;
        int _size;
    }
}
else version (DragonFlyBSD)
{
    enum
    {
        BUFSIZ       = 1024,
        EOF          = -1,
        FOPEN_MAX    = 20,
        FILENAME_MAX = 1024,
        TMP_MAX      = 308915776,
        L_tmpnam     = 1024
    }

    struct __sbuf {                     // <sys/sbuf.h>
        byte*            s_buf;         // storage buffer
        int function(void *, const char *, int) sbuf_drain_func;
        void*            s_drain_arg;   // user-supplied drain argument
        int              s_error;       // current error code
        ssize_t          s_size;        // size of storage buffer
        ssize_t          s_len;         // current length of string
        int              s_flags;       // flags
        ssize_t          s_sect_len;    // current length of section
    };

    enum {
        SBUF_FIXEDLEN   = 0x00000000,   // fixed length buffer (default)
        SBUF_AUTOEXTEND = 0x00000001,   // automatically extend buffer
        SBUF_USRFLAGMSK = 0x0000ffff,   // mask of flags the user may specify
        SBUF_DYNAMIC    = 0x00010000,   // s_buf must be freed
        SBUF_FINISHED   = 0x00020000,   // set by sbuf_finish()
        SBUF_DYNSTRUCT  = 0x00080000,   // sbuf must be freed
        SBUF_INSECTION  = 0x00100000,   // set by sbuf_start_section()
    }
}
else version (Solaris)
{
    enum
    {
        ///
        BUFSIZ = 1024,
        ///
        EOF = -1,
        ///
        FOPEN_MAX = _NFILE,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX = 17576,
        ///
        L_tmpnam = 25,
    }

    version (X86)
        ///
        enum int _NFILE = 60;
    else
        ///
        enum int _NFILE = 20;
}
else version (CRuntime_Bionic)
{
    enum
    {
        ///
        BUFSIZ       = 1024,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 20,
        ///
        FILENAME_MAX = 1024,
        ///
        TMP_MAX      = 308915776,
        ///
        L_tmpnam     = 1024
    }

    struct __sbuf
    {
        ubyte* _base;
        int _size;
    }
}
else version (CRuntime_UClibc)
{
    enum
    {
        ///
        BUFSIZ       = 4096,
        ///
        EOF          = -1,
        ///
        FOPEN_MAX    = 16,
        ///
        FILENAME_MAX = 4095,
        ///
        TMP_MAX      = 238328,
        ///
        L_tmpnam     = 20
    }
}
else
{
    static assert( false, "Unsupported platform" );
}

enum
{
    /// Offset is relative to the beginning
    SEEK_SET,
    /// Offset is relative to the current position
    SEEK_CUR,
    /// Offset is relative to the end
    SEEK_END
}

version (CRuntime_DigitalMars)
{
    ///
    alias c_long fpos_t;

    ///
    struct _iobuf
    {
        char* _ptr;
        int   _cnt;
        char* _base;
        int   _flag;
        int   _file;
        int   _charbuf;
        int   _bufsiz;
        char* __tmpnum;
    }

    ///
    alias shared(_iobuf) FILE;
}
else version (CRuntime_Microsoft)
{
    ///
    alias long fpos_t;

    ///
    struct _iobuf
    {
        void* undefined;
    }

    ///
    alias shared(_iobuf) FILE;
}
else version (CRuntime_Glibc)
{
    import core.stdc.wchar_ : mbstate_t;
    ///
    struct fpos_t
    {
        long __pos; // couldn't use off_t because of static if issue
        mbstate_t __state;
    }

    ///
    struct _IO_FILE
    {
        int     _flags;
        char*   _read_ptr;
        char*   _read_end;
        char*   _read_base;
        char*   _write_base;
        char*   _write_ptr;
        char*   _write_end;
        char*   _buf_base;
        char*   _buf_end;
        char*   _save_base;
        char*   _backup_base;
        char*   _save_end;
        void*   _markers;
        _IO_FILE* _chain;
        int     _fileno;
        int     _blksize;
        int     _old_offset;
        ushort  _cur_column;
        byte    _vtable_offset;
        char[1] _shortbuf = 0;
        void*   _lock;
    }

    ///
    alias _IO_FILE _iobuf;
    ///
    alias shared(_IO_FILE) FILE;
}
else version (CRuntime_Musl)
{
    union fpos_t
    {
        char[16] __opaque = 0;
        double __align;
    }
    struct _IO_FILE;

    ///
    alias _IO_FILE _iobuf; // needed for phobos
    ///
    alias shared(_IO_FILE) FILE;
}
else version (Darwin)
{
    ///
    alias long fpos_t;

    ///
    struct __sFILE
    {
        ubyte*    _p;
        int       _r;
        int       _w;
        short     _flags;
        short     _file;
        __sbuf    _bf;
        int       _lbfsize;

        void*     _cookie;
        int     function(void*)                    _close;
        int     function(void*, char*, int)        _read;
        fpos_t  function(void*, fpos_t, int)       _seek;
        int     function(void*, char *, int)       _write;

        __sbuf    _ub;
        __sFILEX* _extra;
        int       _ur;

        ubyte[3]  _ubuf;
        ubyte[1]  _nbuf;

        __sbuf    _lb;

        int       _blksize;
        fpos_t    _offset;
    }

    ///
    alias __sFILE _iobuf;
    ///
    alias shared(__sFILE) FILE;
}
else version (FreeBSD)
{
    // Need to import wchar_ now since __mbstate_t now resides there
    import core.stdc.wchar_ : mbstate_t;

    ///
    alias off_t fpos_t;

    ///
    struct __sFILE
    {
        ubyte*          _p;
        int             _r;
        int             _w;
        short           _flags;
        short           _file;
        __sbuf          _bf;
        int             _lbfsize;

        void*           _cookie;
        int     function(void*)                 _close;
        int     function(void*, char*, int)     _read;
        fpos_t  function(void*, fpos_t, int)    _seek;
        int     function(void*, in char*, int)  _write;

        __sbuf          _ub;
        ubyte*          _up;
        int             _ur;

        ubyte[3]        _ubuf;
        ubyte[1]        _nbuf;

        __sbuf          _lb;

        int             _blksize;
        fpos_t          _offset;

        pthread_mutex_t _fl_mutex;
        pthread_t       _fl_owner;
        int             _fl_count;
        int             _orientation;
        mbstate_t       _mbstate;
    }

    ///
    alias __sFILE _iobuf;
    ///
    alias shared(__sFILE) FILE;
}
else version (NetBSD)
{
    ///
    alias off_t fpos_t;

    ///
    struct __sFILE
    {
        ubyte*          _p;
        int             _r;
        int             _w;
        ushort           _flags;
        short           _file;
        __sbuf          _bf;
        int             _lbfsize;

        void*           _cookie;
        int     function(void*)                 _close;
        ssize_t     function(void*, char*, size_t)     _read;
        fpos_t  function(void*, fpos_t, int)    _seek;
        ssize_t     function(void*, in char*, size_t)  _write;

        __sbuf          _ub;
        ubyte*          _up;
        int             _ur;

        ubyte[3]        _ubuf;
        ubyte[1]        _nbuf;

        int     function(void *)    _flush;
        /* Formerly used by fgetln/fgetwln; kept for binary compatibility */
        char[__sbuf.sizeof - _flush.sizeof]    _lb_unused = void;


        int             _blksize;
        off_t          _offset;
        static assert(off_t.sizeof==8);
    }

    ///
    alias __sFILE _iobuf;
    ///
    alias shared(__sFILE) FILE;
}
else version (OpenBSD)
{
    ///
    alias fpos_t = off_t;

    ///
    struct __sFILE
    {
        ubyte*          _p;
        int             _r;
        int             _w;
        short           _flags;
        short           _file;
        __sbuf          _bf;
        int             _lbfsize;

        void*           _cookie;
        int     function(void*)                         _close;
        int     function(void*, scope char*, int)       _read;
        fpos_t  function(void*, fpos_t, int)            _seek;
        int     function(void*, scope const char*, int) _write;

        __sbuf          _ext;
        ubyte*          _up;
        int             _ur;

        ubyte[3]        _ubuf;
        ubyte[1]        _nbuf;

        __sbuf          _lb;

        int             _blksize;
        fpos_t          _offset;
    }

    ///
    alias shared(__sFILE) FILE;
}
else version (DragonFlyBSD)
{
    alias off_t fpos_t;

    /// See /usr/include/stdio.h
    struct __FILE_public
    {
        ubyte*          *_p;            /* current position in (some) buffer */
        int             _flags;         /* flags, below; this FILE is free if 0 */
        int             _fileno;        /* fileno, if Unix descriptor, else -1 */
        ssize_t         _r;             /* read space left for getc() */
        ssize_t         _w;             /* write space left for putc() */
        ssize_t         _lbfsize;       /* 0 or -_bf._size, for inline putc */
    }

    alias __FILE_public _iobuf;
    alias shared(__FILE_public) FILE;
}
else version (Solaris)
{
    import core.stdc.wchar_ : mbstate_t;

    ///
    alias c_long fpos_t;

    version (D_LP64)
    {
        ///
        struct _iobuf
        {
            char*      _ptr;   /* next character from/to here in buffer */
            char*      _base;  /* the buffer */
            char*      _end;   /* the end of the buffer */
            size_t     _cnt;   /* number of available characters in buffer */
            int        _file;  /* UNIX System file descriptor */
            int        _flag;  /* the state of the stream */
            ubyte[24]  _lock;  //rmutex_t   _lock; /* lock for this structure */
            mbstate_t  _state; /* mbstate_t */
            ubyte[32]  __fill; /* filler to bring size to 128 bytes */
        }
    }
    else
    {
        ///
        struct _iobuf
        {
            char* _ptr;
            int _cnt;
            char* _base;
            char _flag = 0;
            char _magic = 0;
            ushort __flags; // __orientation:2
                            // __ionolock:1
                            // __seekable:1
                            // __extendedfd:1
                            // __xf_nocheck:1
                            // __filler:10
        }
    }
    ///
    alias shared(_iobuf) FILE;
}
else version (CRuntime_Bionic)
{
    import core.sys.posix.sys.types : off_t;
    ///
    alias off_t fpos_t;

    ///
    struct __sFILE
    {
        ubyte*    _p;
        int       _r;
        int       _w;
        short     _flags;
        short     _file;
        __sbuf    _bf;
        int       _lbfsize;

        void*     _cookie;
        int      function(void*)                          _close;
        int      function(void*, scope char*, int)        _read;
        fpos_t   function(void*, fpos_t, int)             _seek;
        int      function(void*, scope const char*, int)  _write;

        __sbuf    _ext;
        ubyte*    _up;
        int       _ur;

        ubyte[3]  _ubuf;
        ubyte[1]  _nbuf;

        __sbuf    _lb;

        int       _blksize;
        fpos_t    _offset;
    }

    ///
    alias __sFILE _iobuf;
    ///
    alias shared(__sFILE) FILE;
}
else version (CRuntime_UClibc)
{
    import core.stdc.wchar_ : mbstate_t;
    import core.stdc.stddef : wchar_t;
    import core.sys.posix.sys.types : ssize_t, pthread_mutex_t;

    alias long off_t;

    ///
    struct fpos_t
    {
        off_t __pos;
        mbstate_t __state;
        int __mblen_pending;
    }

    struct _IO_cookie_io_functions_t
    {
       ssize_t function(void* __cookie, char* __buf, size_t __bufsize)          read;
       ssize_t function(void* __cookie, const char* __buf, size_t __bufsize)    write;
       int function(void* __cookie, off_t* __pos, int __whence)                 seek;
       int function(void* __cookie)                                             close;
    }

    alias _IO_cookie_io_functions_t cookie_io_functions_t;

    ///
    struct __STDIO_FILE_STRUCT
    {
        ushort __modeflags;
        char[2] __ungot_width = 0;
        int __filedes;
        char* __bufstart;
        char* __bufend;
        char* __bufpos;
        char* __bufread;
        char* __bufgetc_u;
        char*__bufputc_u;
        __STDIO_FILE_STRUCT* __nextopen;
        void *__cookie;
        _IO_cookie_io_functions_t __gcs;
        wchar_t[2] __ungot = 0;
        mbstate_t __state;
        void *__unused;
        int __user_locking;
        pthread_mutex_t __lock;
    }

    ///
    alias __STDIO_FILE_STRUCT _iobuf;
    ///
    alias shared(__STDIO_FILE_STRUCT) FILE;
}
else
{
    static assert( false, "Unsupported platform" );
}

enum
{
    ///
    _F_RDWR = 0x0003, // non-standard
    ///
    _F_READ = 0x0001, // non-standard
    ///
    _F_WRIT = 0x0002, // non-standard
    ///
    _F_BUF  = 0x0004, // non-standard
    ///
    _F_LBUF = 0x0008, // non-standard
    ///
    _F_ERR  = 0x0010, // non-standard
    ///
    _F_EOF  = 0x0020, // non-standard
    ///
    _F_BIN  = 0x0040, // non-standard
    ///
    _F_IN   = 0x0080, // non-standard
    ///
    _F_OUT  = 0x0100, // non-standard
    ///
    _F_TERM = 0x0200, // non-standard
}

version (CRuntime_DigitalMars)
{
    enum
    {
        ///
        _IOFBF   = 0,
        ///
        _IOLBF   = 0x40,
        ///
        _IONBF   = 4,
        ///
        _IOREAD  = 1,     // non-standard
        ///
        _IOWRT   = 2,     // non-standard
        ///
        _IOMYBUF = 8,     // non-standard
        ///
        _IOEOF   = 0x10,  // non-standard
        ///
        _IOERR   = 0x20,  // non-standard
        ///
        _IOSTRG  = 0x40,  // non-standard
        ///
        _IORW    = 0x80,  // non-standard
        ///
        _IOTRAN  = 0x100, // non-standard
        ///
        _IOAPP   = 0x200, // non-standard
    }

    extern shared void function() _fcloseallp;

    private extern shared FILE[_NFILE] _iob;

    ///
    enum stdin  = &_iob[0];
    ///
    enum stdout = &_iob[1];
    ///
    enum stderr = &_iob[2];
    ///
    enum stdaux = &_iob[3];
    ///
    enum stdprn = &_iob[4];
}
else version (CRuntime_Microsoft)
{
    enum
    {
        ///
        _IOFBF   = 0,
        ///
        _IOLBF   = 0x40,
        ///
        _IONBF   = 4,
        /// Removed since Visual Studio 2015.
        _IOREAD  = 1,     // non-standard
        /// Removed since Visual Studio 2015.
        _IOWRT   = 2,     // non-standard
        /// Removed since Visual Studio 2015.
        _IOMYBUF = 8,     // non-standard
        /// Removed since Visual Studio 2015.
        _IOEOF   = 0x10,  // non-standard
        /// Removed since Visual Studio 2015.
        _IOERR   = 0x20,  // non-standard
        /// Removed since Visual Studio 2015.
        _IOSTRG  = 0x40,  // non-standard
        /// Removed since Visual Studio 2015.
        _IORW    = 0x80,  // non-standard
        /// Removed since Visual Studio 2015.
        _IOAPP   = 0x200, // non-standard
        /// Removed since Visual Studio 2015.
        _IOAPPEND = 0x200, // non-standard
    }

    extern shared void function() _fcloseallp;

    ///
    shared FILE* stdin;  // = &__iob_func()[0];
    ///
    shared FILE* stdout; // = &__iob_func()[1];
    ///
    shared FILE* stderr; // = &__iob_func()[2];
}
else version (CRuntime_Glibc)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    ///
    extern shared FILE* stdin;
    ///
    extern shared FILE* stdout;
    ///
    extern shared FILE* stderr;
}
else version (Darwin)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    private extern shared FILE* __stdinp;
    private extern shared FILE* __stdoutp;
    private extern shared FILE* __stderrp;

    ///
    alias __stdinp  stdin;
    ///
    alias __stdoutp stdout;
    ///
    alias __stderrp stderr;
}
else version (FreeBSD)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    private extern shared FILE* __stdinp;
    private extern shared FILE* __stdoutp;
    private extern shared FILE* __stderrp;

    ///
    alias __stdinp  stdin;
    ///
    alias __stdoutp stdout;
    ///
    alias __stderrp stderr;
}
else version (NetBSD)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    private extern __gshared FILE[3] __sF;
    @property auto __stdin()() { return &__sF[0]; }
    @property auto __stdout()() { return &__sF[1]; }
    @property auto __stderr()() { return &__sF[2]; }
    ///
    alias __stdin stdin;
    ///
    alias __stdout stdout;
    ///
    alias __stderr stderr;
}
else version (OpenBSD)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    private extern shared FILE[] __sF;

    ///
    shared stdin  = &__sF[0];
    ///
    shared stdout = &__sF[1];
    ///
    shared stderr = &__sF[2];
}
else version (DragonFlyBSD)
{
    enum
    {
        _IOFBF = 0,
        _IOLBF = 1,
        _IONBF = 2,
    }

    private extern shared FILE* __stdinp;
    private extern shared FILE* __stdoutp;
    private extern shared FILE* __stderrp;

    alias __stdinp  stdin;
    alias __stdoutp stdout;
    alias __stderrp stderr;
}
else version (Solaris)
{
    enum
    {
        ///
        _IOFBF = 0x00,
        ///
        _IOLBF = 0x40,
        ///
        _IONBF = 0x04,
        ///
        _IOEOF = 0x20,
        ///
        _IOERR = 0x40,
        ///
        _IOREAD = 0x01,
        ///
        _IOWRT = 0x02,
        ///
        _IORW = 0x80,
        ///
        _IOMYBUF = 0x08,
    }

    private extern shared FILE[_NFILE] __iob;

    ///
    shared stdin = &__iob[0];
    ///
    shared stdout = &__iob[1];
    ///
    shared stderr = &__iob[2];
}
else version (CRuntime_Bionic)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    private extern shared FILE[3] __sF;

    ///
    shared stdin  = &__sF[0];
    ///
    shared stdout = &__sF[1];
    ///
    shared stderr = &__sF[2];
}
else version (CRuntime_Musl)
{
    // needs tail const
    extern shared FILE* stdin;
    ///
    extern shared FILE* stdout;
    ///
    extern shared FILE* stderr;
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }
}
else version (CRuntime_UClibc)
{
    enum
    {
        ///
        _IOFBF = 0,
        ///
        _IOLBF = 1,
        ///
        _IONBF = 2,
    }

    ///
    extern shared FILE* stdin;
    ///
    extern shared FILE* stdout;
    ///
    extern shared FILE* stderr;
}
else
{
    static assert( false, "Unsupported platform" );
}

///
int remove(scope const char* filename);
///
int rename(scope const char* from, scope const char* to);

///
@trusted FILE* tmpfile(); // No unsafe pointer manipulation.
///
char* tmpnam(char* s);

///
int   fclose(FILE* stream);

// No unsafe pointer manipulation.
@trusted
{
    ///
    int   fflush(FILE* stream);
}

///
FILE* fopen(scope const char* filename, scope const char* mode);
///
FILE* freopen(scope const char* filename, scope const char* mode, FILE* stream);

///
void setbuf(FILE* stream, char* buf);
///
int  setvbuf(FILE* stream, char* buf, int mode, size_t size);

version (MinGW)
{
    // Prefer the MinGW versions over the MSVC ones, as the latter don't handle
    // reals at all.
    ///
    int __mingw_fprintf(FILE* stream, scope const char* format, ...);
    ///
    alias __mingw_fprintf fprintf;

    ///
    int __mingw_fscanf(FILE* stream, scope const char* format, ...);
    ///
    alias __mingw_fscanf fscanf;

    ///
    int __mingw_sprintf(scope char* s, scope const char* format, ...);
    ///
    alias __mingw_sprintf sprintf;

    ///
    int __mingw_sscanf(scope const char* s, scope const char* format, ...);
    ///
    alias __mingw_sscanf sscanf;

    ///
    int __mingw_vfprintf(FILE* stream, scope const char* format, va_list arg);
    ///
    alias __mingw_vfprintf vfprintf;

    ///
    int __mingw_vfscanf(FILE* stream, scope const char* format, va_list arg);
    ///
    alias __mingw_vfscanf vfscanf;

    ///
    int __mingw_vsprintf(scope char* s, scope const char* format, va_list arg);
    ///
    alias __mingw_vsprintf vsprintf;

    ///
    int __mingw_vsscanf(scope const char* s, scope const char* format, va_list arg);
    ///
    alias __mingw_vsscanf vsscanf;

    ///
    int __mingw_vprintf(scope const char* format, va_list arg);
    ///
    alias __mingw_vprintf vprintf;

    ///
    int __mingw_vscanf(scope const char* format, va_list arg);
    ///
    alias __mingw_vscanf vscanf;

    ///
    int __mingw_printf(scope const char* format, ...);
    ///
    alias __mingw_printf printf;

    ///
    int __mingw_scanf(scope const char* format, ...);
    ///
    alias __mingw_scanf scanf;
}
else
{
    ///
    int fprintf(FILE* stream, scope const char* format, ...);
    ///
    int fscanf(FILE* stream, scope const char* format, ...);
    ///
    int sprintf(scope char* s, scope const char* format, ...);
    ///
    int sscanf(scope const char* s, scope const char* format, ...);
    ///
    int vfprintf(FILE* stream, scope const char* format, va_list arg);
    ///
    int vfscanf(FILE* stream, scope const char* format, va_list arg);
    ///
    int vsprintf(scope char* s, scope const char* format, va_list arg);
    ///
    int vsscanf(scope const char* s, scope const char* format, va_list arg);
    ///
    int vprintf(scope const char* format, va_list arg);
    ///
    int vscanf(scope const char* format, va_list arg);
    ///
    int printf(scope const char* format, ...);
    ///
    int scanf(scope const char* format, ...);
}

// No unsafe pointer manipulation.
@trusted
{
    ///
    int fgetc(FILE* stream);
    ///
    int fputc(int c, FILE* stream);
}

///
char* fgets(char* s, int n, FILE* stream);
///
int   fputs(scope const char* s, FILE* stream);
///
char* gets(char* s);
///
int   puts(scope const char* s);

// No unsafe pointer manipulation.
extern (D) @trusted
{
    ///
    int getchar()()                 { return getc(stdin);     }
    ///
    int putchar()(int c)            { return putc(c,stdout);  }
    ///
    int getc()(FILE* stream)        { return fgetc(stream);   }
    ///
    int putc()(int c, FILE* stream) { return fputc(c,stream); }
}

///
@trusted int ungetc(int c, FILE* stream); // No unsafe pointer manipulation.

///
size_t fread(scope void* ptr, size_t size, size_t nmemb, FILE* stream);
///
size_t fwrite(scope const void* ptr, size_t size, size_t nmemb, FILE* stream);

// No unsafe pointer manipulation.
@trusted
{
    ///
    int fgetpos(FILE* stream, scope fpos_t * pos);
    ///
    int fsetpos(FILE* stream, scope const fpos_t* pos);

    ///
    int    fseek(FILE* stream, c_long offset, int whence);
    ///
    c_long ftell(FILE* stream);
}

version (MinGW)
{
  // No unsafe pointer manipulation.
  extern (D) @trusted
  {
    ///
    void rewind()(FILE* stream)   { fseek(stream,0L,SEEK_SET); stream._flag = stream._flag & ~_IOERR; }
    ///
    pure void clearerr()(FILE* stream) { stream._flag = stream._flag & ~(_IOERR|_IOEOF); }
    ///
    pure int  feof()(FILE* stream)     { return stream._flag&_IOEOF; }
    ///
    pure int  ferror()(FILE* stream)   { return stream._flag&_IOERR; }
  }
  ///
    int   __mingw_snprintf(scope char* s, size_t n, scope const char* fmt, ...);
    ///
    alias __mingw_snprintf _snprintf;
    ///
    alias __mingw_snprintf snprintf;

    ///
    int   __mingw_vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
    ///
    alias __mingw_vsnprintf _vsnprintf;
    ///
    alias __mingw_vsnprintf vsnprintf;
}
else version (CRuntime_DigitalMars)
{
  // No unsafe pointer manipulation.
  extern (D) @trusted
  {
    ///
    void rewind()(FILE* stream)   { fseek(stream,0L,SEEK_SET); stream._flag= stream._flag & ~_IOERR; }
    ///
    pure void clearerr()(FILE* stream) { stream._flag = stream._flag & ~(_IOERR|_IOEOF); }
    ///
    pure int  feof()(FILE* stream)     { return stream._flag&_IOEOF; }
    ///
    pure int  ferror()(FILE* stream)   { return stream._flag&_IOERR; }
    ///
    pure int  fileno()(FILE* stream)   { return stream._file; }
  }
  ///
    int   _snprintf(scope char* s, size_t n, scope const char* fmt, ...);
    ///
    alias _snprintf snprintf;

    ///
    int   _vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
    ///
    alias _vsnprintf vsnprintf;
}
else version (CRuntime_Microsoft)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE* stream);
    ///
    pure void clearerr(FILE* stream);
    ///
    pure int  feof(FILE* stream);
    ///
    pure int  ferror(FILE* stream);
    ///
    pure int  fileno(FILE* stream);
  }

    ///
    int _snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);

    ///
    int _vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);

    ///
    int _fputc_nolock(int c, FILE *fp);
    ///
    int _fgetc_nolock(FILE *fp);

    ///
    int _lock_file(FILE *fp);
    ///
    int _unlock_file(FILE *fp);

    ///
    intptr_t _get_osfhandle(int fd);
    ///
    int _open_osfhandle(intptr_t osfhandle, int flags);
}
else version (CRuntime_Glibc)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE* stream);
    ///
    pure void clearerr(FILE* stream);
    ///
    pure int  feof(FILE* stream);
    ///
    pure int  ferror(FILE* stream);
    ///
    int  fileno(FILE *);
  }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (Darwin)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE*);
    ///
    pure void clearerr(FILE*);
    ///
    pure int  feof(FILE*);
    ///
    pure int  ferror(FILE*);
    ///
    int  fileno(FILE*);
  }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (FreeBSD)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE*);
    ///
    pure void clearerr(FILE*);
    ///
    pure int  feof(FILE*);
    ///
    pure int  ferror(FILE*);
    ///
    int  fileno(FILE*);
  }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (NetBSD)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE*);
    ///
    pure void clearerr(FILE*);
    ///
    pure int  feof(FILE*);
    ///
    pure int  ferror(FILE*);
    ///
    int  fileno(FILE*);
  }

    ///
    int  snprintf(char* s, size_t n, in char* format, ...);
    ///
    int  vsnprintf(char* s, size_t n, in char* format, va_list arg);
}
else version (OpenBSD)
{
    // No unsafe pointer manipulation.
    @trusted
    {
        ///
        void rewind(FILE*);
    }
    @trusted private
    {
        ///
        pure void clearerr(FILE*);
        alias __clearerr = clearerr;
        ///
        pure int  feof(FILE*);
        alias __feof = feof;
        ///
        pure int  ferror(FILE*);
        alias __ferror = ferror;
        ///
        int  fileno(FILE*);
        alias __fileno = fileno;
    }

    enum __SLBF = 0x0001;
    enum __SNBF = 0x0002;
    enum __SRD  = 0x0004;
    enum __SWR  = 0x0008;
    enum __SRW  = 0x0010;
    enum __SEOF = 0x0020;
    enum __SERR = 0x0040;
    enum __SMBF = 0x0080;
    enum __SAPP = 0x0100;
    enum __SSTR = 0x0200;
    enum __SOPT = 0x0400;
    enum __SNPT = 0x0800;
    enum __SOFF = 0x1000;
    enum __SMOD = 0x2000;
    enum __SALC = 0x4000;
    enum __SIGN = 0x8000;

    extern int __isthreaded;

    extern (D)
    {
        void __sclearerr()(FILE* p)
        {
            p._flags &= ~(__SERR|__SEOF);
        }

        int __sfeof()(FILE* p)
        {
            return (p._flags & __SEOF) != 0;
        }

        int __sferror()(FILE* p)
        {
            return (p._flags & __SERR) != 0;
        }

        int __sfileno()(FILE* p)
        {
            return p._file;
        }

        int clearerr()(FILE* file)
        {
            return !__isthreaded ? __sclearerr(file) : __clearerr(file);
        }

        int feof()(FILE* file)
        {
            return !__isthreaded ? __sfeof(file) : __feof(file);
        }

        int ferror()(FILE* file)
        {
            return !__isthreaded ? __sferror(file) : __ferror(file);
        }

        int fileno()(FILE* file)
        {
            return !__isthreaded ? __sfileno(file) : __fileno(file);
        }
    }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (DragonFlyBSD)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    void rewind(FILE*);
    pure void clearerr(FILE*);
    pure int  feof(FILE*);
    pure int  ferror(FILE*);
    int  fileno(FILE*);
  }
  enum __SLBF = 0x0001;
  enum __SNBF = 0x0002;
  enum __SRD  = 0x0004;
  enum __SWR  = 0x0008;
  enum __SRW  = 0x0010;
  enum __SEOF = 0x0020;
  enum __SERR = 0x0040;
  enum __SMBF = 0x0080;
  enum __SAPP = 0x0100;
  enum __SSTR = 0x0200;
  enum __SOPT = 0x0400;
  enum __SNPT = 0x0800;
  enum __SOFF = 0x1000;
  enum __SMOD = 0x2000;
  enum __SALC = 0x4000;
  enum __SIGN = 0x8000;

  int  snprintf(scope char* s, size_t n, scope const char* format, ...);
  int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (Solaris)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE*);
    ///
    pure void clearerr(FILE*);
    ///
    pure int  feof(FILE*);
    ///
    pure int  ferror(FILE*);
    ///
    int  fileno(FILE*);
  }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (CRuntime_Bionic)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE*);
    ///
    pure void clearerr(FILE*);
    ///
    pure int  feof(FILE*);
    ///
    pure int  ferror(FILE*);
    ///
    int  fileno(FILE*);
  }

  ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (CRuntime_Musl)
{
    @trusted
    {
        ///
        void rewind(FILE* stream);
        ///
        pure void clearerr(FILE* stream);
        ///
        pure int  feof(FILE* stream);
        ///
        pure int  ferror(FILE* stream);
        ///
        int  fileno(FILE *);
    }

    ///
    int snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else version (CRuntime_UClibc)
{
  // No unsafe pointer manipulation.
  @trusted
  {
    ///
    void rewind(FILE* stream);
    ///
    pure void clearerr(FILE* stream);
    ///
    pure int  feof(FILE* stream);
    ///
    pure int  ferror(FILE* stream);
    ///
    int  fileno(FILE *);
  }

    ///
    int  snprintf(scope char* s, size_t n, scope const char* format, ...);
    ///
    int  vsnprintf(scope char* s, size_t n, scope const char* format, va_list arg);
}
else
{
    static assert( false, "Unsupported platform" );
}

///
void perror(scope const char* s);

version (CRuntime_DigitalMars)
{
    version (none)
        import core.sys.windows.windows : HANDLE, _WaitSemaphore, _ReleaseSemaphore;
    else
    {
        // too slow to import windows
        private alias void* HANDLE;
        private void _WaitSemaphore(int iSemaphore);
        private void _ReleaseSemaphore(int iSemaphore);
    }

    enum
    {
        ///
        FHND_APPEND     = 0x04,
        ///
        FHND_DEVICE     = 0x08,
        ///
        FHND_TEXT       = 0x10,
        ///
        FHND_BYTE       = 0x20,
        ///
        FHND_WCHAR      = 0x40,
    }

    private enum _MAX_SEMAPHORES = 10 + _NFILE;
    private enum _semIO = 3;

    private extern __gshared short[_MAX_SEMAPHORES] _iSemLockCtrs;
    private extern __gshared int[_MAX_SEMAPHORES] _iSemThreadIds;
    private extern __gshared int[_MAX_SEMAPHORES] _iSemNestCount;
    private extern __gshared HANDLE[_NFILE] _osfhnd;
    extern shared ubyte[_NFILE] __fhnd_info;

    // this is copied from semlock.h in DMC's runtime.
    private void LockSemaphore()(uint num)
    {
        asm nothrow @nogc
        {
            mov EDX, num;
            lock;
            inc _iSemLockCtrs[EDX * 2];
            jz lsDone;
            push EDX;
            call _WaitSemaphore;
            add ESP, 4;
        }

    lsDone: {}
    }

    // this is copied from semlock.h in DMC's runtime.
    private void UnlockSemaphore()(uint num)
    {
        asm nothrow @nogc
        {
            mov EDX, num;
            lock;
            dec _iSemLockCtrs[EDX * 2];
            js usDone;
            push EDX;
            call _ReleaseSemaphore;
            add ESP, 4;
        }

    usDone: {}
    }

    // This converts a HANDLE to a file descriptor in DMC's runtime
    ///
    int _handleToFD()(HANDLE h, int flags)
    {
        LockSemaphore(_semIO);
        scope(exit) UnlockSemaphore(_semIO);

        foreach (fd; 0 .. _NFILE)
        {
            if (!_osfhnd[fd])
            {
                _osfhnd[fd] = h;
                __fhnd_info[fd] = cast(ubyte)flags;
                return fd;
            }
        }

        return -1;
    }

    ///
    HANDLE _fdToHandle()(int fd)
    {
        // no semaphore is required, once inserted, a file descriptor
        // doesn't change.
        if (fd < 0 || fd >= _NFILE)
            return null;

        return _osfhnd[fd];
    }

    enum
    {
        ///
        STDIN_FILENO  = 0,
        ///
        STDOUT_FILENO = 1,
        ///
        STDERR_FILENO = 2,
    }

    int open(scope const(char)* filename, int flags, ...); ///
    alias _open = open; ///
    int _wopen(scope const wchar* filename, int oflag, ...); ///
    int sopen(scope const char* filename, int oflag, int shflag, ...); ///
    alias _sopen = sopen; ///
    int _wsopen(scope const wchar* filename, int oflag, int shflag, ...); ///
    int close(int fd); ///
    alias _close = close; ///
    FILE *fdopen(int fd, scope const(char)* flags); ///
    alias _fdopen = fdopen; ///
    FILE *_wfdopen(int fd, scope const(wchar)* flags); ///

}
else version (CRuntime_Microsoft)
{
    int _open(scope const char* filename, int oflag, ...); ///
    int _wopen(scope const wchar* filename, int oflag, ...); ///
    int _sopen(scope const char* filename, int oflag, int shflag, ...); ///
    int _wsopen(scope const wchar* filename, int oflag, int shflag, ...); ///
    int _close(int fd); ///
    FILE *_fdopen(int fd, scope const(char)* flags); ///
    FILE *_wfdopen(int fd, scope const(wchar)* flags); ///
}

version (Windows)
{
    // file open flags
    enum
    {
        _O_RDONLY = 0x0000, ///
        O_RDONLY = _O_RDONLY, ///
        _O_WRONLY = 0x0001, ///
        O_WRONLY = _O_WRONLY, ///
        _O_RDWR   = 0x0002, ///
        O_RDWR = _O_RDWR, ///
        _O_APPEND = 0x0008, ///
        O_APPEND = _O_APPEND, ///
        _O_CREAT  = 0x0100, ///
        O_CREAT = _O_CREAT, ///
        _O_TRUNC  = 0x0200, ///
        O_TRUNC = _O_TRUNC, ///
        _O_EXCL   = 0x0400, ///
        O_EXCL = _O_EXCL, ///
        _O_TEXT   = 0x4000, ///
        O_TEXT = _O_TEXT, ///
        _O_BINARY = 0x8000, ///
        O_BINARY = _O_BINARY, ///
    }

    enum
    {
        _S_IREAD  = 0x0100, /// read permission, owner
        S_IREAD = _S_IREAD, /// read permission, owner
        _S_IWRITE = 0x0080, /// write permission, owner
        S_IWRITE = _S_IWRITE, /// write permission, owner
    }

    enum
    {
        _SH_DENYRW = 0x10, /// deny read/write mode
        SH_DENYRW = _SH_DENYRW, /// deny read/write mode
        _SH_DENYWR = 0x20, /// deny write mode
        SH_DENYWR = _SH_DENYWR, /// deny write mode
        _SH_DENYRD = 0x30, /// deny read mode
        SH_DENYRD = _SH_DENYRD, /// deny read mode
        _SH_DENYNO = 0x40, /// deny none mode
        SH_DENYNO = _SH_DENYNO, /// deny none mode
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_stdlib.h.html, _stdlib.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2014.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Standards: ISO/IEC 9899:1999 (E)
 * Source: $(DRUNTIMESRC src/core/stdc/_stdlib.d)
 */

module core.stdc.stdlib;

private import core.stdc.config;
public import core.stdc.stddef; // for wchar_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

extern (C):
@system:

/* Placed outside `nothrow` and `@nogc` in order to not constrain what the callback does.
 */
///
alias _compare_fp_t = int function(const void*, const void*);

nothrow:
@nogc:

///
inout(void)* bsearch(const void* key, inout(void)* base, size_t nmemb, size_t size, _compare_fp_t compar);
///
void    qsort(void* base, size_t nmemb, size_t size, _compare_fp_t compar);

// https://issues.dlang.org/show_bug.cgi?id=17188
@system unittest
{
    struct S
    {
        extern(C) static int cmp(const void*, const void*) { return 0; }
    }
    int[4] arr;
    qsort(arr.ptr, arr[0].sizeof, arr.length, &S.cmp);
    int key;
    bsearch(&key, arr.ptr, arr[0].sizeof, arr.length, &S.cmp);
}

///
struct div_t
{
    int quot,
        rem;
}

///
struct ldiv_t
{
    int quot,
        rem;
}

///
struct lldiv_t
{
    long quot,
         rem;
}

///
enum EXIT_SUCCESS = 0;
///
enum EXIT_FAILURE = 1;
///
enum MB_CUR_MAX   = 1;

///
version (Windows)      enum RAND_MAX = 0x7fff;
else version (CRuntime_Glibc)  enum RAND_MAX = 0x7fffffff;
else version (Darwin)  enum RAND_MAX = 0x7fffffff;
else version (FreeBSD) enum RAND_MAX = 0x7ffffffd;
else version (NetBSD)  enum RAND_MAX = 0x7fffffff;
else version (OpenBSD) enum RAND_MAX = 0x7fffffff;
else version (DragonFlyBSD) enum RAND_MAX = 0x7fffffff;
else version (Solaris) enum RAND_MAX = 0x7fff;
else version (CRuntime_Bionic) enum RAND_MAX = 0x7fffffff;
else version (CRuntime_Musl) enum RAND_MAX = 0x7fffffff;
else version (CRuntime_UClibc) enum RAND_MAX = 0x7fffffff;
else static assert( false, "Unsupported platform" );

///
double  atof(scope const char* nptr);
///
int     atoi(scope const char* nptr);
///
c_long  atol(scope const char* nptr);
///
long    atoll(scope const char* nptr);

///
double  strtod(scope inout(char)* nptr, scope inout(char)** endptr);
///
float   strtof(scope inout(char)* nptr, scope inout(char)** endptr);
///
c_long  strtol(scope inout(char)* nptr, scope inout(char)** endptr, int base);
///
long    strtoll(scope inout(char)* nptr, scope inout(char)** endptr, int base);
///
c_ulong strtoul(scope inout(char)* nptr, scope inout(char)** endptr, int base);
///
ulong   strtoull(scope inout(char)* nptr, scope inout(char)** endptr, int base);

version (CRuntime_Microsoft)
{
    // strtold exists starting from VS2013, so we give it D linkage to avoid link errors
    ///
    extern (D) real strtold(scope inout(char)* nptr, inout(char)** endptr)
    {   // Fake it 'till we make it
        return strtod(nptr, endptr);
    }
}
else version (MinGW)
{
    ///
    real __mingw_strtold(scope inout(char)* nptr, scope inout(char)** endptr);
    ///
    alias __mingw_strtold strtold;
}
else
{
    /// Added to Bionic since Lollipop.
    real strtold(scope inout(char)* nptr, scope inout(char)** endptr);
}

// No unsafe pointer manipulation.
@trusted
{
    /// These two were added to Bionic in Lollipop.
    int     rand();
    ///
    void    srand(uint seed);
}

// We don't mark these @trusted. Given that they return a void*, one has
// to do a pointer cast to do anything sensible with the result. Thus,
// functions using these already have to be @trusted, allowing them to
// call @system stuff anyway.
///
void*   malloc(size_t size);
///
void*   calloc(size_t nmemb, size_t size);
///
void*   realloc(void* ptr, size_t size);
///
void    free(void* ptr);

///
void    abort() @safe;
///
void    exit(int status);
///
int     atexit(void function() func);
///
void    _Exit(int status);

///
char*   getenv(scope const char* name);
///
int     system(scope const char* string);

// These only operate on integer values.
@trusted
{
    ///
    pure int     abs(int j);
    ///
    pure c_long  labs(c_long j);
    ///
    pure long    llabs(long j);

    ///
    div_t   div(int numer, int denom);
    ///
    ldiv_t  ldiv(c_long numer, c_long denom);
    ///
    lldiv_t lldiv(long numer, long denom);
}

///
int     mblen(scope const char* s, size_t n);
///
int     mbtowc(scope wchar_t* pwc, scope const char* s, size_t n);
///
int     wctomb(scope char* s, wchar_t wc);
///
size_t  mbstowcs(scope wchar_t* pwcs, scope const char* s, size_t n);
///
size_t  wcstombs(scope char* s, scope const wchar_t* pwcs, size_t n);

///
version (DigitalMars)
{
    // See malloc comment about @trusted.
    void* alloca(size_t size) pure; // non-standard
}
else version (GNU)
{
    void* alloca(size_t size) pure; // compiler intrinsic
}
else version (LDC)
{
    pragma(LDC_alloca)
    void* alloca(size_t size) pure;
}

version (CRuntime_Microsoft)
{
    ///
    ulong  _strtoui64(scope inout(char)*, scope inout(char)**,int);
    ///
    ulong  _wcstoui64(scope inout(wchar)*, scope inout(wchar)**,int);

    ///
    long  _strtoi64(scope inout(char)*, scope inout(char)**,int);
    ///
    long  _wcstoi64(scope inout(wchar)*, scope inout(wchar)**,int);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_string.h.html, _string.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_string.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.string;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

extern (C):
@system:
nothrow:
@nogc:

///
pure void* memchr(return const void* s, int c, size_t n);
///
pure int   memcmp(scope const void* s1, scope const void* s2, size_t n);
///
pure void* memcpy(return void* s1, scope const void* s2, size_t n);
version (Windows)
{
    ///
    int memicmp(scope const char* s1, scope const char* s2, size_t n);
}
///
pure void* memmove(return void* s1, scope const void* s2, size_t n);
///
pure void* memset(return void* s, int c, size_t n);

///
pure char*  strcpy(return char* s1, scope const char* s2);
///
pure char*  strncpy(return char* s1, scope const char* s2, size_t n);
///
pure char*  strcat(return char* s1, scope const char* s2);
///
pure char*  strncat(return char* s1, scope const char* s2, size_t n);
///
pure int    strcmp(scope const char* s1, scope const char* s2);
///
int    strcoll(scope const char* s1, scope const char* s2);
///
pure int    strncmp(scope const char* s1, scope const char* s2, size_t n);
///
size_t strxfrm(scope char* s1, scope const char* s2, size_t n);
///
pure inout(char)*  strchr(return inout(char)* s, int c);
///
pure size_t strcspn(scope const char* s1, scope const char* s2);
///
pure inout(char)*  strpbrk(return inout(char)* s1, scope const char* s2);
///
pure inout(char)*  strrchr(return inout(char)* s, int c);
///
pure size_t strspn(scope const char* s1, scope const char* s2);
///
pure inout(char)*  strstr(return inout(char)* s1, scope const char* s2);
///
char*  strtok(return char* s1, scope const char* s2);
///
char*  strerror(int errnum);
version (CRuntime_Glibc)
{
    ///
    const(char)* strerror_r(int errnum, return char* buf, size_t buflen);
}
else version (Darwin)
{
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (FreeBSD)
{
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (NetBSD)
{
    int strerror_r(int errnum, char* buf, size_t buflen);
}
else version (OpenBSD)
{
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (DragonFlyBSD)
{
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (Solaris)
{
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (CRuntime_Bionic)
{
    ///
    int strerror_r(int errnum, scope char* buf, size_t buflen);
}
else version (CRuntime_Musl)
{
    ///
    int strerror_r(int errnum, scope char *buf, size_t buflen);
}
else version (CRuntime_UClibc)
{
    ///
    const(char)* strerror_r(int errnum, return char* buf, size_t buflen);
}
///
pure size_t strlen(scope const char* s);
///
char*  strdup(scope const char *s);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_tgmath.h.html, _tgmath.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_tgmath.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.tgmath;

private import core.stdc.config;
private static import core.stdc.math;
private static import core.stdc.complex;

extern (C):
@trusted: // Everything here operates on floating point and integer values.
nothrow:
@nogc:

version (FreeBSD)
{
    ///
    alias core.stdc.math.acos          acos;
    ///
    alias core.stdc.math.acosf         acos;
    ///
    alias core.stdc.math.acosl         acos;

    ///
    alias core.stdc.complex.cacos      acos;
    ///
    alias core.stdc.complex.cacosf     acos;
    ///
    alias core.stdc.complex.cacosl     acos;

    ///
    alias core.stdc.math.asin          asin;
    ///
    alias core.stdc.math.asinf         asin;
    ///
    alias core.stdc.math.asinl         asin;

    ///
    alias core.stdc.complex.casin      asin;
    ///
    alias core.stdc.complex.casinf     asin;
    ///
    alias core.stdc.complex.casinl     asin;

    ///
    alias core.stdc.math.atan          atan;
    ///
    alias core.stdc.math.atanf         atan;
    ///
    alias core.stdc.math.atanl         atan;

    ///
    alias core.stdc.complex.catan      atan;
    ///
    alias core.stdc.complex.catanf     atan;
    ///
    alias core.stdc.complex.catanl     atan;

    ///
    alias core.stdc.math.atan2         atan2;
    ///
    alias core.stdc.math.atan2f        atan2;
    ///
    alias core.stdc.math.atan2l        atan2;

    ///
    alias core.stdc.math.cos           cos;
    ///
    alias core.stdc.math.cosf          cos;
    ///
    alias core.stdc.math.cosl          cos;

    ///
    alias core.stdc.complex.ccos       cos;
    ///
    alias core.stdc.complex.ccosf      cos;
    ///
    alias core.stdc.complex.ccosl      cos;

    ///
    alias core.stdc.math.sin           sin;
    ///
    alias core.stdc.math.sinf          sin;
    ///
    alias core.stdc.math.sinl          sin;

    ///
    alias core.stdc.complex.csin       csin;
    ///
    alias core.stdc.complex.csinf      csin;
    ///
    alias core.stdc.complex.csinl      csin;

    ///
    alias core.stdc.math.tan           tan;
    ///
    alias core.stdc.math.tanf          tan;
    ///
    alias core.stdc.math.tanl          tan;

    ///
    alias core.stdc.complex.ctan       tan;
    ///
    alias core.stdc.complex.ctanf      tan;
    ///
    alias core.stdc.complex.ctanl      tan;

    ///
    alias core.stdc.math.acosh         acosh;
    ///
    alias core.stdc.math.acoshf        acosh;
    ///
    alias core.stdc.math.acoshl        acosh;

    ///
    alias core.stdc.complex.cacosh     acosh;
    ///
    alias core.stdc.complex.cacoshf    acosh;
    ///
    alias core.stdc.complex.cacoshl    acosh;

    ///
    alias core.stdc.math.asinh         asinh;
    ///
    alias core.stdc.math.asinhf        asinh;
    ///
    alias core.stdc.math.asinhl        asinh;

    ///
    alias core.stdc.complex.casinh     asinh;
    ///
    alias core.stdc.complex.casinhf    asinh;
    ///
    alias core.stdc.complex.casinhl    asinh;

    ///
    alias core.stdc.math.atanh         atanh;
    ///
    alias core.stdc.math.atanhf        atanh;
    ///
    alias core.stdc.math.atanhl        atanh;

    ///
    alias core.stdc.complex.catanh     atanh;
    ///
    alias core.stdc.complex.catanhf    atanh;
    ///
    alias core.stdc.complex.catanhl    atanh;

    ///
    alias core.stdc.math.cosh          cosh;
    ///
    alias core.stdc.math.coshf         cosh;
    ///
    alias core.stdc.math.coshl         cosh;

    ///
    alias core.stdc.complex.ccosh      cosh;
    ///
    alias core.stdc.complex.ccoshf     cosh;
    ///
    alias core.stdc.complex.ccoshl     cosh;

    ///
    alias core.stdc.math.sinh          sinh;
    ///
    alias core.stdc.math.sinhf         sinh;
    ///
    alias core.stdc.math.sinhl         sinh;

    ///
    alias core.stdc.complex.csinh      sinh;
    ///
    alias core.stdc.complex.csinhf     sinh;
    ///
    alias core.stdc.complex.csinhl     sinh;

    ///
    alias core.stdc.math.tanh          tanh;
    ///
    alias core.stdc.math.tanhf         tanh;
    ///
    alias core.stdc.math.tanhl         tanh;

    ///
    alias core.stdc.complex.ctanh      tanh;
    ///
    alias core.stdc.complex.ctanhf     tanh;
    ///
    alias core.stdc.complex.ctanhl     tanh;

    ///
    alias core.stdc.math.exp           exp;
    ///
    alias core.stdc.math.expf          exp;
    ///
    alias core.stdc.math.expl          exp;

    ///
    alias core.stdc.complex.cexp       exp;
    ///
    alias core.stdc.complex.cexpf      exp;
    ///
    alias core.stdc.complex.cexpl      exp;

    ///
    alias core.stdc.math.exp2          exp2;
    ///
    alias core.stdc.math.exp2f         exp2;
    ///
    alias core.stdc.math.exp2l         exp2;

    ///
    alias core.stdc.math.expm1         expm1;
    ///
    alias core.stdc.math.expm1f        expm1;
    ///
    alias core.stdc.math.expm1l        expm1;

    ///
    alias core.stdc.math.frexp         frexp;
    ///
    alias core.stdc.math.frexpf        frexp;
    ///
    alias core.stdc.math.frexpl        frexp;

    ///
    alias core.stdc.math.ilogb         ilogb;
    ///
    alias core.stdc.math.ilogbf        ilogb;
    ///
    alias core.stdc.math.ilogbl        ilogb;

    ///
    alias core.stdc.math.ldexp         ldexp;
    ///
    alias core.stdc.math.ldexpf        ldexp;
    ///
    alias core.stdc.math.ldexpl        ldexp;

    ///
    alias core.stdc.math.log           log;
    ///
    alias core.stdc.math.logf          log;
    ///
    alias core.stdc.math.logl          log;

    ///
    alias core.stdc.complex.clog       log;
    ///
    alias core.stdc.complex.clogf      log;
    ///
    alias core.stdc.complex.clogl      log;

    ///
    alias core.stdc.math.log10         log10;
    ///
    alias core.stdc.math.log10f        log10;
    ///
    alias core.stdc.math.log10l        log10;

    ///
    alias core.stdc.math.log1p         log1p;
    ///
    alias core.stdc.math.log1pf        log1p;
    ///
    alias core.stdc.math.log1pl        log1p;

    ///
    alias core.stdc.math.log2          log2;
    ///
    alias core.stdc.math.log2f         log2;
    ///
    alias core.stdc.math.log2l         log2;

    ///
    alias core.stdc.math.logb          logb;
    ///
    alias core.stdc.math.logbf         logb;
    ///
    alias core.stdc.math.logbl         logb;

    ///
    alias core.stdc.math.modf          modf;
    ///
    alias core.stdc.math.modff         modf;
//  alias core.stdc.math.modfl         modf;

    ///
    alias core.stdc.math.scalbn        scalbn;
    ///
    alias core.stdc.math.scalbnf       scalbn;
    ///
    alias core.stdc.math.scalbnl       scalbn;

    ///
    alias core.stdc.math.scalbln       scalbln;
    ///
    alias core.stdc.math.scalblnf      scalbln;
    ///
    alias core.stdc.math.scalblnl      scalbln;

    ///
    alias core.stdc.math.cbrt          cbrt;
    ///
    alias core.stdc.math.cbrtf         cbrt;
    ///
    alias core.stdc.math.cbrtl         cbrt;

    ///
    alias core.stdc.math.fabs          fabs;
    ///
    alias core.stdc.math.fabsf         fabs;
    ///
    alias core.stdc.math.fabsl         fabs;

    ///
    alias core.stdc.complex.cabs       fabs;
    ///
    alias core.stdc.complex.cabsf      fabs;
    ///
    alias core.stdc.complex.cabsl      fabs;

    ///
    alias core.stdc.math.hypot         hypot;
    ///
    alias core.stdc.math.hypotf        hypot;
    ///
    alias core.stdc.math.hypotl        hypot;

    ///
    alias core.stdc.math.pow           pow;
    ///
    alias core.stdc.math.powf          pow;
    ///
    alias core.stdc.math.powl          pow;

    ///
    alias core.stdc.complex.cpow       pow;
    ///
    alias core.stdc.complex.cpowf      pow;
    ///
    alias core.stdc.complex.cpowl      pow;

    ///
    alias core.stdc.math.sqrt          sqrt;
    ///
    alias core.stdc.math.sqrtf         sqrt;
    ///
    alias core.stdc.math.sqrtl         sqrt;

    ///
    alias core.stdc.complex.csqrt      sqrt;
    ///
    alias core.stdc.complex.csqrtf     sqrt;
    ///
    alias core.stdc.complex.csqrtl     sqrt;

    ///
    alias core.stdc.math.erf           erf;
    ///
    alias core.stdc.math.erff          erf;
    ///
    alias core.stdc.math.erfl          erf;

    ///
    alias core.stdc.math.erfc          erfc;
    ///
    alias core.stdc.math.erfcf         erfc;
    ///
    alias core.stdc.math.erfcl         erfc;

    ///
    alias core.stdc.math.lgamma        lgamma;
    ///
    alias core.stdc.math.lgammaf       lgamma;
    ///
    alias core.stdc.math.lgammal       lgamma;

    ///
    alias core.stdc.math.tgamma        tgamma;
    ///
    alias core.stdc.math.tgammaf       tgamma;
    ///
    alias core.stdc.math.tgammal       tgamma;

    ///
    alias core.stdc.math.ceil          ceil;
    ///
    alias core.stdc.math.ceilf         ceil;
    ///
    alias core.stdc.math.ceill         ceil;

    ///
    alias core.stdc.math.floor         floor;
    ///
    alias core.stdc.math.floorf        floor;
    ///
    alias core.stdc.math.floorl        floor;

    ///
    alias core.stdc.math.nearbyint     nearbyint;
    ///
    alias core.stdc.math.nearbyintf    nearbyint;
    ///
    alias core.stdc.math.nearbyintl    nearbyint;

    ///
    alias core.stdc.math.rint          rint;
    ///
    alias core.stdc.math.rintf         rint;
    ///
    alias core.stdc.math.rintl         rint;

    ///
    alias core.stdc.math.lrint         lrint;
    ///
    alias core.stdc.math.lrintf        lrint;
    ///
    alias core.stdc.math.lrintl        lrint;

    ///
    alias core.stdc.math.llrint        llrint;
    ///
    alias core.stdc.math.llrintf       llrint;
    ///
    alias core.stdc.math.llrintl       llrint;

    ///
    alias core.stdc.math.round         round;
    ///
    alias core.stdc.math.roundf        round;
    ///
    alias core.stdc.math.roundl        round;

    ///
    alias core.stdc.math.lround        lround;
    ///
    alias core.stdc.math.lroundf       lround;
    ///
    alias core.stdc.math.lroundl       lround;

    ///
    alias core.stdc.math.llround       llround;
    ///
    alias core.stdc.math.llroundf      llround;
    ///
    alias core.stdc.math.llroundl      llround;

    ///
    alias core.stdc.math.trunc         trunc;
    ///
    alias core.stdc.math.truncf        trunc;
    ///
    alias core.stdc.math.truncl        trunc;

    ///
    alias core.stdc.math.fmod          fmod;
    ///
    alias core.stdc.math.fmodf         fmod;
    ///
    alias core.stdc.math.fmodl         fmod;

    ///
    alias core.stdc.math.remainder     remainder;
    ///
    alias core.stdc.math.remainderf    remainder;
    ///
    alias core.stdc.math.remainderl    remainder;

    ///
    alias core.stdc.math.remquo        remquo;
    ///
    alias core.stdc.math.remquof       remquo;
    ///
    alias core.stdc.math.remquol       remquo;

    ///
    alias core.stdc.math.copysign      copysign;
    ///
    alias core.stdc.math.copysignf     copysign;
    ///
    alias core.stdc.math.copysignl     copysign;

//  alias core.stdc.math.nan           nan;
//  alias core.stdc.math.nanf          nan;
//  alias core.stdc.math.nanl          nan;

    ///
    alias core.stdc.math.nextafter     nextafter;
    ///
    alias core.stdc.math.nextafterf    nextafter;
    ///
    alias core.stdc.math.nextafterl    nextafter;

    ///
    alias core.stdc.math.nexttoward    nexttoward;
    ///
    alias core.stdc.math.nexttowardf   nexttoward;
    ///
    alias core.stdc.math.nexttowardl   nexttoward;

    ///
    alias core.stdc.math.fdim          fdim;
    ///
    alias core.stdc.math.fdimf         fdim;
    ///
    alias core.stdc.math.fdiml         fdim;

    ///
    alias core.stdc.math.fmax          fmax;
    ///
    alias core.stdc.math.fmaxf         fmax;
    ///
    alias core.stdc.math.fmaxl         fmax;

    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fminl         fmin;

    ///
    alias core.stdc.math.fma           fma;
    ///
    alias core.stdc.math.fmaf          fma;
    ///
    alias core.stdc.math.fmal          fma;

    ///
    alias core.stdc.complex.carg       carg;
    ///
    alias core.stdc.complex.cargf      carg;
    ///
    alias core.stdc.complex.cargl      carg;

    ///
    alias core.stdc.complex.cimag      cimag;
    ///
    alias core.stdc.complex.cimagf     cimag;
    ///
    alias core.stdc.complex.cimagl     cimag;

    ///
    alias core.stdc.complex.conj       conj;
    ///
    alias core.stdc.complex.conjf      conj;
    ///
    alias core.stdc.complex.conjl      conj;

    ///
    alias core.stdc.complex.cproj      cproj;
    ///
    alias core.stdc.complex.cprojf     cproj;
    ///
    alias core.stdc.complex.cprojl     cproj;

//  alias core.stdc.complex.creal      creal;
//  alias core.stdc.complex.crealf     creal;
//  alias core.stdc.complex.creall     creal;
}
version (NetBSD)
{
    ///
    alias core.stdc.math.acos          acos;
    ///
    alias core.stdc.math.acosf         acos;
    ///
    alias core.stdc.math.acosl         acos;

    ///
    alias core.stdc.complex.cacos      acos;
    ///
    alias core.stdc.complex.cacosf     acos;
    ///
    alias core.stdc.complex.cacosl     acos;

    ///
    alias core.stdc.math.asin          asin;
    ///
    alias core.stdc.math.asinf         asin;
    ///
    alias core.stdc.math.asinl         asin;

    ///
    alias core.stdc.complex.casin      asin;
    ///
    alias core.stdc.complex.casinf     asin;
    ///
    alias core.stdc.complex.casinl     asin;

    ///
    alias core.stdc.math.atan          atan;
    ///
    alias core.stdc.math.atanf         atan;
    ///
    alias core.stdc.math.atanl         atan;

    ///
    alias core.stdc.complex.catan      atan;
    ///
    alias core.stdc.complex.catanf     atan;
    ///
    alias core.stdc.complex.catanl     atan;

    ///
    alias core.stdc.math.atan2         atan2;
    ///
    alias core.stdc.math.atan2f        atan2;
    ///
    alias core.stdc.math.atan2l        atan2;

    ///
    alias core.stdc.math.cos           cos;
    ///
    alias core.stdc.math.cosf          cos;
    ///
    alias core.stdc.math.cosl          cos;

    ///
    alias core.stdc.complex.ccos       cos;
    ///
    alias core.stdc.complex.ccosf      cos;
    ///
    alias core.stdc.complex.ccosl      cos;

    ///
    alias core.stdc.math.sin           sin;
    ///
    alias core.stdc.math.sinf          sin;
    ///
    alias core.stdc.math.sinl          sin;

    ///
    alias core.stdc.complex.csin       csin;
    ///
    alias core.stdc.complex.csinf      csin;
    ///
    alias core.stdc.complex.csinl      csin;

    ///
    alias core.stdc.math.tan           tan;
    ///
    alias core.stdc.math.tanf          tan;
    ///
    alias core.stdc.math.tanl          tan;

    ///
    alias core.stdc.complex.ctan       tan;
    ///
    alias core.stdc.complex.ctanf      tan;
    ///
    alias core.stdc.complex.ctanl      tan;

    ///
    alias core.stdc.math.acosh         acosh;
    ///
    alias core.stdc.math.acoshf        acosh;
    ///
    alias core.stdc.math.acoshl        acosh;

    ///
    alias core.stdc.complex.cacosh     acosh;
    ///
    alias core.stdc.complex.cacoshf    acosh;
    ///
    alias core.stdc.complex.cacoshl    acosh;

    ///
    alias core.stdc.math.asinh         asinh;
    ///
    alias core.stdc.math.asinhf        asinh;
    ///
    alias core.stdc.math.asinhl        asinh;

    ///
    alias core.stdc.complex.casinh     asinh;
    ///
    alias core.stdc.complex.casinhf    asinh;
    ///
    alias core.stdc.complex.casinhl    asinh;

    ///
    alias core.stdc.math.atanh         atanh;
    ///
    alias core.stdc.math.atanhf        atanh;
    ///
    alias core.stdc.math.atanhl        atanh;

    ///
    alias core.stdc.complex.catanh     atanh;
    ///
    alias core.stdc.complex.catanhf    atanh;
    ///
    alias core.stdc.complex.catanhl    atanh;

    ///
    alias core.stdc.math.cosh          cosh;
    ///
    alias core.stdc.math.coshf         cosh;
    ///
    alias core.stdc.math.coshl         cosh;

    ///
    alias core.stdc.complex.ccosh      cosh;
    ///
    alias core.stdc.complex.ccoshf     cosh;
    ///
    alias core.stdc.complex.ccoshl     cosh;

    ///
    alias core.stdc.math.sinh          sinh;
    ///
    alias core.stdc.math.sinhf         sinh;
    ///
    alias core.stdc.math.sinhl         sinh;

    ///
    alias core.stdc.complex.csinh      sinh;
    ///
    alias core.stdc.complex.csinhf     sinh;
    ///
    alias core.stdc.complex.csinhl     sinh;

    ///
    alias core.stdc.math.tanh          tanh;
    ///
    alias core.stdc.math.tanhf         tanh;
    ///
    alias core.stdc.math.tanhl         tanh;

    ///
    alias core.stdc.complex.ctanh      tanh;
    ///
    alias core.stdc.complex.ctanhf     tanh;
    ///
    alias core.stdc.complex.ctanhl     tanh;

    ///
    alias core.stdc.math.exp           exp;
    ///
    alias core.stdc.math.expf          exp;
    ///
    alias core.stdc.math.expl          exp;

    ///
    alias core.stdc.complex.cexp       exp;
    ///
    alias core.stdc.complex.cexpf      exp;
    ///
    alias core.stdc.complex.cexpl      exp;

    ///
    alias core.stdc.math.exp2          exp2;
    ///
    alias core.stdc.math.exp2f         exp2;
    ///
    alias core.stdc.math.exp2l         exp2;

    ///
    alias core.stdc.math.expm1         expm1;
    ///
    alias core.stdc.math.expm1f        expm1;
    ///
    alias core.stdc.math.expm1l        expm1;

    ///
    alias core.stdc.math.frexp         frexp;
    ///
    alias core.stdc.math.frexpf        frexp;
    ///
    alias core.stdc.math.frexpl        frexp;

    ///
    alias core.stdc.math.ilogb         ilogb;
    ///
    alias core.stdc.math.ilogbf        ilogb;
    ///
    alias core.stdc.math.ilogbl        ilogb;

    ///
    alias core.stdc.math.ldexp         ldexp;
    ///
    alias core.stdc.math.ldexpf        ldexp;
    ///
    alias core.stdc.math.ldexpl        ldexp;

    ///
    alias core.stdc.math.log           log;
    ///
    alias core.stdc.math.logf          log;
    ///
    alias core.stdc.math.logl          log;

    ///
    alias core.stdc.complex.clog       log;
    ///
    alias core.stdc.complex.clogf      log;
    ///
    alias core.stdc.complex.clogl      log;

    ///
    alias core.stdc.math.log10         log10;
    ///
    alias core.stdc.math.log10f        log10;
    ///
    alias core.stdc.math.log10l        log10;

    ///
    alias core.stdc.math.log1p         log1p;
    ///
    alias core.stdc.math.log1pf        log1p;
    ///
    alias core.stdc.math.log1pl        log1p;

    ///
    alias core.stdc.math.log2          log2;
    ///
    alias core.stdc.math.log2f         log2;
    ///
    alias core.stdc.math.log2l         log2;

    ///
    alias core.stdc.math.logb          logb;
    ///
    alias core.stdc.math.logbf         logb;
    ///
    alias core.stdc.math.logbl         logb;

    ///
    alias core.stdc.math.modf          modf;
    ///
    alias core.stdc.math.modff         modf;
//  alias core.stdc.math.modfl         modf;

    ///
    alias core.stdc.math.scalbn        scalbn;
    ///
    alias core.stdc.math.scalbnf       scalbn;
    ///
    alias core.stdc.math.scalbnl       scalbn;

    ///
    alias core.stdc.math.scalbln       scalbln;
    ///
    alias core.stdc.math.scalblnf      scalbln;
    ///
    alias core.stdc.math.scalblnl      scalbln;

    ///
    alias core.stdc.math.cbrt          cbrt;
    ///
    alias core.stdc.math.cbrtf         cbrt;
    ///
    alias core.stdc.math.cbrtl         cbrt;

    ///
    alias core.stdc.math.fabs          fabs;
    ///
    alias core.stdc.math.fabsf         fabs;
    ///
    alias core.stdc.math.fabsl         fabs;

    ///
    alias core.stdc.complex.cabs       fabs;
    ///
    alias core.stdc.complex.cabsf      fabs;
    ///
    alias core.stdc.complex.cabsl      fabs;

    ///
    alias core.stdc.math.hypot         hypot;
    ///
    alias core.stdc.math.hypotf        hypot;
    ///
    alias core.stdc.math.hypotl        hypot;

    ///
    alias core.stdc.math.pow           pow;
    ///
    alias core.stdc.math.powf          pow;
    ///
    alias core.stdc.math.powl          pow;

    ///
    alias core.stdc.complex.cpow       pow;
    ///
    alias core.stdc.complex.cpowf      pow;
    ///
    alias core.stdc.complex.cpowl      pow;

    ///
    alias core.stdc.math.sqrt          sqrt;
    ///
    alias core.stdc.math.sqrtf         sqrt;
    ///
    alias core.stdc.math.sqrtl         sqrt;

    ///
    alias core.stdc.complex.csqrt      sqrt;
    ///
    alias core.stdc.complex.csqrtf     sqrt;
    ///
    alias core.stdc.complex.csqrtl     sqrt;

    ///
    alias core.stdc.math.erf           erf;
    ///
    alias core.stdc.math.erff          erf;
    ///
    alias core.stdc.math.erfl          erf;

    ///
    alias core.stdc.math.erfc          erfc;
    ///
    alias core.stdc.math.erfcf         erfc;
    ///
    alias core.stdc.math.erfcl         erfc;

    ///
    alias core.stdc.math.lgamma        lgamma;
    ///
    alias core.stdc.math.lgammaf       lgamma;
    ///
    alias core.stdc.math.lgammal       lgamma;

    ///
    alias core.stdc.math.tgamma        tgamma;
    ///
    alias core.stdc.math.tgammaf       tgamma;
    ///
    alias core.stdc.math.tgammal       tgamma;

    ///
    alias core.stdc.math.ceil          ceil;
    ///
    alias core.stdc.math.ceilf         ceil;
    ///
    alias core.stdc.math.ceill         ceil;

    ///
    alias core.stdc.math.floor         floor;
    ///
    alias core.stdc.math.floorf        floor;
    ///
    alias core.stdc.math.floorl        floor;

    ///
    alias core.stdc.math.nearbyint     nearbyint;
    ///
    alias core.stdc.math.nearbyintf    nearbyint;
    ///
    alias core.stdc.math.nearbyintl    nearbyint;

    ///
    alias core.stdc.math.rint          rint;
    ///
    alias core.stdc.math.rintf         rint;
    ///
    alias core.stdc.math.rintl         rint;

    ///
    alias core.stdc.math.lrint         lrint;
    ///
    alias core.stdc.math.lrintf        lrint;
    ///
    alias core.stdc.math.lrintl        lrint;

    ///
    alias core.stdc.math.llrint        llrint;
    ///
    alias core.stdc.math.llrintf       llrint;
    ///
    alias core.stdc.math.llrintl       llrint;

    ///
    alias core.stdc.math.round         round;
    ///
    alias core.stdc.math.roundf        round;
    ///
    alias core.stdc.math.roundl        round;

    ///
    alias core.stdc.math.lround        lround;
    ///
    alias core.stdc.math.lroundf       lround;
    ///
    alias core.stdc.math.lroundl       lround;

    ///
    alias core.stdc.math.llround       llroundl;
    ///
    alias core.stdc.math.llroundf      llroundl;
    ///
    alias core.stdc.math.llroundl      llroundl;

    ///
    alias core.stdc.math.trunc         trunc;
    ///
    alias core.stdc.math.truncf        trunc;
    ///
    alias core.stdc.math.truncl        trunc;

    ///
    alias core.stdc.math.fmod          fmod;
    ///
    alias core.stdc.math.fmodf         fmod;
    ///
    alias core.stdc.math.fmodl         fmod;

    ///
    alias core.stdc.math.remainder     remainder;
    ///
    alias core.stdc.math.remainderf    remainder;
    ///
    alias core.stdc.math.remainderl    remainder;

    ///
    alias core.stdc.math.remquo        remquo;
    ///
    alias core.stdc.math.remquof       remquo;
    ///
    alias core.stdc.math.remquol       remquo;

    ///
    alias core.stdc.math.copysign      copysign;
    ///
    alias core.stdc.math.copysignf     copysign;
    ///
    alias core.stdc.math.copysignl     copysign;

//  alias core.stdc.math.nan           nan;
//  alias core.stdc.math.nanf          nan;
//  alias core.stdc.math.nanl          nan;

    ///
    alias core.stdc.math.nextafter     nextafter;
    ///
    alias core.stdc.math.nextafterf    nextafter;
    ///
    alias core.stdc.math.nextafterl    nextafter;

    ///
    alias core.stdc.math.nexttoward    nexttoward;
    ///
    alias core.stdc.math.nexttowardf   nexttoward;
    ///
    alias core.stdc.math.nexttowardl   nexttoward;

    ///
    alias core.stdc.math.fdim          fdim;
    ///
    alias core.stdc.math.fdimf         fdim;
    ///
    alias core.stdc.math.fdiml         fdim;

    ///
    alias core.stdc.math.fmax          fmax;
    ///
    alias core.stdc.math.fmaxf         fmax;
    ///
    alias core.stdc.math.fmaxl         fmax;

    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fminl         fmin;

    ///
    alias core.stdc.math.fma           fma;
    ///
    alias core.stdc.math.fmaf          fma;
    ///
    alias core.stdc.math.fmal          fma;

    ///
    alias core.stdc.complex.carg       carg;
    ///
    alias core.stdc.complex.cargf      carg;
    ///
    alias core.stdc.complex.cargl      carg;

    ///
    alias core.stdc.complex.cimag      cimag;
    ///
    alias core.stdc.complex.cimagf     cimag;
    ///
    alias core.stdc.complex.cimagl     cimag;

    ///
    alias core.stdc.complex.conj       conj;
    ///
    alias core.stdc.complex.conjf      conj;
    ///
    alias core.stdc.complex.conjl      conj;

    ///
    alias core.stdc.complex.cproj      cproj;
    ///
    alias core.stdc.complex.cprojf     cproj;
    ///
    alias core.stdc.complex.cprojl     cproj;

//  alias core.stdc.complex.creal      creal;
//  alias core.stdc.complex.crealf     creal;
//  alias core.stdc.complex.creall     creal;
}
else version (OpenBSD)
{
    ///
    alias core.stdc.math.acos          acos;
    ///
    alias core.stdc.math.acosf         acos;
    ///
    alias core.stdc.math.acosl         acos;

    ///
    alias core.stdc.complex.cacos      acos;
    ///
    alias core.stdc.complex.cacosf     acos;
    ///
    alias core.stdc.complex.cacosl     acos;

    ///
    alias core.stdc.math.asin          asin;
    ///
    alias core.stdc.math.asinf         asin;
    ///
    alias core.stdc.math.asinl         asin;

    ///
    alias core.stdc.complex.casin      asin;
    ///
    alias core.stdc.complex.casinf     asin;
    ///
    alias core.stdc.complex.casinl     asin;

    ///
    alias core.stdc.math.atan          atan;
    ///
    alias core.stdc.math.atanf         atan;
    ///
    alias core.stdc.math.atanl         atan;

    ///
    alias core.stdc.complex.catan      atan;
    ///
    alias core.stdc.complex.catanf     atan;
    ///
    alias core.stdc.complex.catanl     atan;

    ///
    alias core.stdc.math.atan2         atan2;
    ///
    alias core.stdc.math.atan2f        atan2;
    ///
    alias core.stdc.math.atan2l        atan2;

    ///
    alias core.stdc.math.cos           cos;
    ///
    alias core.stdc.math.cosf          cos;
    ///
    alias core.stdc.math.cosl          cos;

    ///
    alias core.stdc.complex.ccos       cos;
    ///
    alias core.stdc.complex.ccosf      cos;
    ///
    alias core.stdc.complex.ccosl      cos;

    ///
    alias core.stdc.math.sin           sin;
    ///
    alias core.stdc.math.sinf          sin;
    ///
    alias core.stdc.math.sinl          sin;

    ///
    alias core.stdc.complex.csin       csin;
    ///
    alias core.stdc.complex.csinf      csin;
    ///
    alias core.stdc.complex.csinl      csin;

    ///
    alias core.stdc.math.tan           tan;
    ///
    alias core.stdc.math.tanf          tan;
    ///
    alias core.stdc.math.tanl          tan;

    ///
    alias core.stdc.complex.ctan       tan;
    ///
    alias core.stdc.complex.ctanf      tan;
    ///
    alias core.stdc.complex.ctanl      tan;

    ///
    alias core.stdc.math.acosh         acosh;
    ///
    alias core.stdc.math.acoshf        acosh;
    ///
    alias core.stdc.math.acoshl        acosh;

    ///
    alias core.stdc.complex.cacosh     acosh;
    ///
    alias core.stdc.complex.cacoshf    acosh;
    ///
    alias core.stdc.complex.cacoshl    acosh;

    ///
    alias core.stdc.math.asinh         asinh;
    ///
    alias core.stdc.math.asinhf        asinh;
    ///
    alias core.stdc.math.asinhl        asinh;

    ///
    alias core.stdc.complex.casinh     asinh;
    ///
    alias core.stdc.complex.casinhf    asinh;
    ///
    alias core.stdc.complex.casinhl    asinh;

    ///
    alias core.stdc.math.atanh         atanh;
    ///
    alias core.stdc.math.atanhf        atanh;
    ///
    alias core.stdc.math.atanhl        atanh;

    ///
    alias core.stdc.complex.catanh     atanh;
    ///
    alias core.stdc.complex.catanhf    atanh;
    ///
    alias core.stdc.complex.catanhl    atanh;

    ///
    alias core.stdc.math.cosh          cosh;
    ///
    alias core.stdc.math.coshf         cosh;
    ///
    alias core.stdc.math.coshl         cosh;

    ///
    alias core.stdc.complex.ccosh      cosh;
    ///
    alias core.stdc.complex.ccoshf     cosh;
    ///
    alias core.stdc.complex.ccoshl     cosh;

    ///
    alias core.stdc.math.sinh          sinh;
    ///
    alias core.stdc.math.sinhf         sinh;
    ///
    alias core.stdc.math.sinhl         sinh;

    ///
    alias core.stdc.complex.csinh      sinh;
    ///
    alias core.stdc.complex.csinhf     sinh;
    ///
    alias core.stdc.complex.csinhl     sinh;

    ///
    alias core.stdc.math.tanh          tanh;
    ///
    alias core.stdc.math.tanhf         tanh;
    ///
    alias core.stdc.math.tanhl         tanh;

    ///
    alias core.stdc.complex.ctanh      tanh;
    ///
    alias core.stdc.complex.ctanhf     tanh;
    ///
    alias core.stdc.complex.ctanhl     tanh;

    ///
    alias core.stdc.math.exp           exp;
    ///
    alias core.stdc.math.expf          exp;
    ///
    alias core.stdc.math.expl          exp;

    ///
    alias core.stdc.complex.cexp       exp;
    ///
    alias core.stdc.complex.cexpf      exp;
    ///
    alias core.stdc.complex.cexpl      exp;

    ///
    alias core.stdc.math.exp2          exp2;
    ///
    alias core.stdc.math.exp2f         exp2;
    ///
    alias core.stdc.math.exp2l         exp2;

    ///
    alias core.stdc.math.expm1         expm1;
    ///
    alias core.stdc.math.expm1f        expm1;
    ///
    alias core.stdc.math.expm1l        expm1;

    ///
    alias core.stdc.math.frexp         frexp;
    ///
    alias core.stdc.math.frexpf        frexp;
    ///
    alias core.stdc.math.frexpl        frexp;

    ///
    alias core.stdc.math.ilogb         ilogb;
    ///
    alias core.stdc.math.ilogbf        ilogb;
    ///
    alias core.stdc.math.ilogbl        ilogb;

    ///
    alias core.stdc.math.ldexp         ldexp;
    ///
    alias core.stdc.math.ldexpf        ldexp;
    ///
    alias core.stdc.math.ldexpl        ldexp;

    ///
    alias core.stdc.math.log           log;
    ///
    alias core.stdc.math.logf          log;
    ///
    alias core.stdc.math.logl          log;

    ///
    alias core.stdc.complex.clog       log;
    ///
    alias core.stdc.complex.clogf      log;
    ///
    alias core.stdc.complex.clogl      log;

    ///
    alias core.stdc.math.log10         log10;
    ///
    alias core.stdc.math.log10f        log10;
    ///
    alias core.stdc.math.log10l        log10;

    ///
    alias core.stdc.math.log1p         log1p;
    ///
    alias core.stdc.math.log1pf        log1p;
    ///
    alias core.stdc.math.log1pl        log1p;

    ///
    alias core.stdc.math.log2          log2;
    ///
    alias core.stdc.math.log2f         log2;
    ///
    alias core.stdc.math.log2l         log2;

    ///
    alias core.stdc.math.logb          logb;
    ///
    alias core.stdc.math.logbf         logb;
    ///
    alias core.stdc.math.logbl         logb;

    ///
    alias core.stdc.math.fmod          fmod;
    ///
    alias core.stdc.math.fmodf         fmod;
    ///
    alias core.stdc.math.fmodl         fmod;

    ///
    alias core.stdc.math.scalbn        scalbn;
    ///
    alias core.stdc.math.scalbnf       scalbn;
    ///
    alias core.stdc.math.scalbnl       scalbn;

    ///
    alias core.stdc.math.scalbln       scalbln;
    ///
    alias core.stdc.math.scalblnf      scalbln;
    ///
    alias core.stdc.math.scalblnl      scalbln;

    ///
    alias core.stdc.math.cbrt          cbrt;
    ///
    alias core.stdc.math.cbrtf         cbrt;
    ///
    alias core.stdc.math.cbrtl         cbrt;

    ///
    alias core.stdc.math.fabs          fabs;
    ///
    alias core.stdc.math.fabsf         fabs;
    ///
    alias core.stdc.math.fabsl         fabs;

    ///
    alias core.stdc.complex.cabs       fabs;
    ///
    alias core.stdc.complex.cabsf      fabs;
    ///
    alias core.stdc.complex.cabsl      fabs;

    ///
    alias core.stdc.math.hypot         hypot;
    ///
    alias core.stdc.math.hypotf        hypot;
    ///
    alias core.stdc.math.hypotl        hypot;

    ///
    alias core.stdc.math.pow           pow;
    ///
    alias core.stdc.math.powf          pow;
    ///
    alias core.stdc.math.powl          pow;

    ///
    alias core.stdc.complex.cpow       pow;
    ///
    alias core.stdc.complex.cpowf      pow;
    ///
    alias core.stdc.complex.cpowl      pow;

    ///
    alias core.stdc.math.sqrt          sqrt;
    ///
    alias core.stdc.math.sqrtf         sqrt;
    ///
    alias core.stdc.math.sqrtl         sqrt;

    ///
    alias core.stdc.complex.csqrt      sqrt;
    ///
    alias core.stdc.complex.csqrtf     sqrt;
    ///
    alias core.stdc.complex.csqrtl     sqrt;

    ///
    alias core.stdc.math.erf           erf;
    ///
    alias core.stdc.math.erff          erf;
    ///
    alias core.stdc.math.erfl          erf;

    ///
    alias core.stdc.math.erfc          erfc;
    ///
    alias core.stdc.math.erfcf         erfc;
    ///
    alias core.stdc.math.erfcl         erfc;

    ///
    alias core.stdc.math.lgamma        lgamma;
    ///
    alias core.stdc.math.lgammaf       lgamma;
    ///
    alias core.stdc.math.lgammal       lgamma;

    ///
    alias core.stdc.math.tgamma        tgamma;
    ///
    alias core.stdc.math.tgammaf       tgamma;
    ///
    alias core.stdc.math.tgammal       tgamma;

    ///
    alias core.stdc.math.ceil          ceil;
    ///
    alias core.stdc.math.ceilf         ceil;
    ///
    alias core.stdc.math.ceill         ceil;

    ///
    alias core.stdc.math.floor         floor;
    ///
    alias core.stdc.math.floorf        floor;
    ///
    alias core.stdc.math.floorl        floor;

    ///
    alias core.stdc.math.nearbyint     nearbyint;
    ///
    alias core.stdc.math.nearbyintf    nearbyint;
    ///
    alias core.stdc.math.nearbyintl    nearbyint;

    ///
    alias core.stdc.math.rint          rint;
    ///
    alias core.stdc.math.rintf         rint;
    ///
    alias core.stdc.math.rintl         rint;

    ///
    alias core.stdc.math.lrint         lrint;
    ///
    alias core.stdc.math.lrintf        lrint;
    ///
    alias core.stdc.math.lrintl        lrint;

    ///
    alias core.stdc.math.llrint        llrint;
    ///
    alias core.stdc.math.llrintf       llrint;
    ///
    alias core.stdc.math.llrintl       llrint;

    ///
    alias core.stdc.math.round         round;
    ///
    alias core.stdc.math.roundf        round;
    ///
    alias core.stdc.math.roundl        round;

    ///
    alias core.stdc.math.lround        lround;
    ///
    alias core.stdc.math.lroundf       lround;
    ///
    alias core.stdc.math.lroundl       lround;

    ///
    alias core.stdc.math.llround       llround;
    ///
    alias core.stdc.math.llroundf      llround;
    ///
    alias core.stdc.math.llroundl      llround;

    ///
    alias core.stdc.math.trunc         trunc;
    ///
    alias core.stdc.math.truncf        trunc;
    ///
    alias core.stdc.math.truncl        trunc;

    ///
    alias core.stdc.math.remainder     remainder;
    ///
    alias core.stdc.math.remainderf    remainder;
    ///
    alias core.stdc.math.remainderl    remainder;

    ///
    alias core.stdc.math.remquo        remquo;
    ///
    alias core.stdc.math.remquof       remquo;
    ///
    alias core.stdc.math.remquol       remquo;

    ///
    alias core.stdc.math.copysign      copysign;
    ///
    alias core.stdc.math.copysignf     copysign;
    ///
    alias core.stdc.math.copysignl     copysign;

    ///
    alias core.stdc.math.nextafter     nextafter;
    ///
    alias core.stdc.math.nextafterf    nextafter;
    ///
    alias core.stdc.math.nextafterl    nextafter;

    ///
    alias core.stdc.math.nexttoward    nexttoward;
    ///
    alias core.stdc.math.nexttowardf   nexttoward;
    ///
    alias core.stdc.math.nexttowardl   nexttoward;

    ///
    alias core.stdc.math.fdim          fdim;
    ///
    alias core.stdc.math.fdimf         fdim;
    ///
    alias core.stdc.math.fdiml         fdim;

    ///
    alias core.stdc.math.fmax          fmax;
    ///
    alias core.stdc.math.fmaxf         fmax;
    ///
    alias core.stdc.math.fmaxl         fmax;

    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fminl         fmin;

    ///
    alias core.stdc.math.fma           fma;
    ///
    alias core.stdc.math.fmaf          fma;
    ///
    alias core.stdc.math.fmal          fma;

    ///
    alias core.stdc.complex.carg       carg;
    ///
    alias core.stdc.complex.cargf      carg;
    ///
    alias core.stdc.complex.cargl      carg;

    ///
    alias core.stdc.complex.cimag      cimag;
    ///
    alias core.stdc.complex.cimagf     cimag;
    ///
    alias core.stdc.complex.cimagl     cimag;

    ///
    alias core.stdc.complex.conj       conj;
    ///
    alias core.stdc.complex.conjf      conj;
    ///
    alias core.stdc.complex.conjl      conj;

    ///
    alias core.stdc.complex.cproj      cproj;
    ///
    alias core.stdc.complex.cprojf     cproj;
    ///
    alias core.stdc.complex.cprojl     cproj;

//  alias core.stdc.complex.creal      creal;
//  alias core.stdc.complex.crealf     creal;
//  alias core.stdc.complex.creall     creal;
}
else
{
    ///
    alias core.stdc.math.acos          acos;
    ///
    alias core.stdc.math.acosf         acos;
    ///
    alias core.stdc.math.acosl         acos;

    ///
    alias core.stdc.complex.cacos      acos;
    ///
    alias core.stdc.complex.cacosf     acos;
    ///
    alias core.stdc.complex.cacosl     acos;

    ///
    alias core.stdc.math.asin          asin;
    ///
    alias core.stdc.math.asinf         asin;
    ///
    alias core.stdc.math.asinl         asin;

    ///
    alias core.stdc.complex.casin      asin;
    ///
    alias core.stdc.complex.casinf     asin;
    ///
    alias core.stdc.complex.casinl     asin;

    ///
    alias core.stdc.math.atan          atan;
    ///
    alias core.stdc.math.atanf         atan;
    ///
    alias core.stdc.math.atanl         atan;

    ///
    alias core.stdc.complex.catan      atan;
    ///
    alias core.stdc.complex.catanf     atan;
    ///
    alias core.stdc.complex.catanl     atan;

    ///
    alias core.stdc.math.atan2         atan2;
    ///
    alias core.stdc.math.atan2f        atan2;
    ///
    alias core.stdc.math.atan2l        atan2;

    ///
    alias core.stdc.math.cos           cos;
    ///
    alias core.stdc.math.cosf          cos;
    ///
    alias core.stdc.math.cosl          cos;

    ///
    alias core.stdc.complex.ccos       cos;
    ///
    alias core.stdc.complex.ccosf      cos;
    ///
    alias core.stdc.complex.ccosl      cos;

    ///
    alias core.stdc.math.sin           sin;
    ///
    alias core.stdc.math.sinf          sin;
    ///
    alias core.stdc.math.sinl          sin;

    ///
    alias core.stdc.complex.csin       csin;
    ///
    alias core.stdc.complex.csinf      csin;
    ///
    alias core.stdc.complex.csinl      csin;

    ///
    alias core.stdc.math.tan           tan;
    ///
    alias core.stdc.math.tanf          tan;
    ///
    alias core.stdc.math.tanl          tan;

    ///
    alias core.stdc.complex.ctan       tan;
    ///
    alias core.stdc.complex.ctanf      tan;
    ///
    alias core.stdc.complex.ctanl      tan;

    ///
    alias core.stdc.math.acosh         acosh;
    ///
    alias core.stdc.math.acoshf        acosh;
    ///
    alias core.stdc.math.acoshl        acosh;

    ///
    alias core.stdc.complex.cacosh     acosh;
    ///
    alias core.stdc.complex.cacoshf    acosh;
    ///
    alias core.stdc.complex.cacoshl    acosh;

    ///
    alias core.stdc.math.asinh         asinh;
    ///
    alias core.stdc.math.asinhf        asinh;
    ///
    alias core.stdc.math.asinhl        asinh;

    ///
    alias core.stdc.complex.casinh     asinh;
    ///
    alias core.stdc.complex.casinhf    asinh;
    ///
    alias core.stdc.complex.casinhl    asinh;

    ///
    alias core.stdc.math.atanh         atanh;
    ///
    alias core.stdc.math.atanhf        atanh;
    ///
    alias core.stdc.math.atanhl        atanh;

    ///
    alias core.stdc.complex.catanh     atanh;
    ///
    alias core.stdc.complex.catanhf    atanh;
    ///
    alias core.stdc.complex.catanhl    atanh;

    ///
    alias core.stdc.math.cosh          cosh;
    ///
    alias core.stdc.math.coshf         cosh;
    ///
    alias core.stdc.math.coshl         cosh;

    ///
    alias core.stdc.complex.ccosh      cosh;
    ///
    alias core.stdc.complex.ccoshf     cosh;
    ///
    alias core.stdc.complex.ccoshl     cosh;

    ///
    alias core.stdc.math.sinh          sinh;
    ///
    alias core.stdc.math.sinhf         sinh;
    ///
    alias core.stdc.math.sinhl         sinh;

    ///
    alias core.stdc.complex.csinh      sinh;
    ///
    alias core.stdc.complex.csinhf     sinh;
    ///
    alias core.stdc.complex.csinhl     sinh;

    ///
    alias core.stdc.math.tanh          tanh;
    ///
    alias core.stdc.math.tanhf         tanh;
    ///
    alias core.stdc.math.tanhl         tanh;

    ///
    alias core.stdc.complex.ctanh      tanh;
    ///
    alias core.stdc.complex.ctanhf     tanh;
    ///
    alias core.stdc.complex.ctanhl     tanh;

    ///
    alias core.stdc.math.exp           exp;
    ///
    alias core.stdc.math.expf          exp;
    ///
    alias core.stdc.math.expl          exp;

    ///
    alias core.stdc.complex.cexp       exp;
    ///
    alias core.stdc.complex.cexpf      exp;
    ///
    alias core.stdc.complex.cexpl      exp;

    ///
    alias core.stdc.math.exp2          exp2;
    ///
    alias core.stdc.math.exp2f         exp2;
    ///
    alias core.stdc.math.exp2l         exp2;

    ///
    alias core.stdc.math.expm1         expm1;
    ///
    alias core.stdc.math.expm1f        expm1;
    ///
    alias core.stdc.math.expm1l        expm1;

    ///
    alias core.stdc.math.frexp         frexp;
    ///
    alias core.stdc.math.frexpf        frexp;
    ///
    alias core.stdc.math.frexpl        frexp;

    ///
    alias core.stdc.math.ilogb         ilogb;
    ///
    alias core.stdc.math.ilogbf        ilogb;
    ///
    alias core.stdc.math.ilogbl        ilogb;

    ///
    alias core.stdc.math.ldexp         ldexp;
    ///
    alias core.stdc.math.ldexpf        ldexp;
    ///
    alias core.stdc.math.ldexpl        ldexp;

    ///
    alias core.stdc.math.log           log;
    ///
    alias core.stdc.math.logf          log;
    ///
    alias core.stdc.math.logl          log;

    ///
    alias core.stdc.complex.clog       log;
    ///
    alias core.stdc.complex.clogf      log;
    ///
    alias core.stdc.complex.clogl      log;

    ///
    alias core.stdc.math.log10         log10;
    ///
    alias core.stdc.math.log10f        log10;
    ///
    alias core.stdc.math.log10l        log10;

    ///
    alias core.stdc.math.log1p         log1p;
    ///
    alias core.stdc.math.log1pf        log1p;
    ///
    alias core.stdc.math.log1pl        log1p;

    ///
    alias core.stdc.math.log2          log2;
    ///
    alias core.stdc.math.log2f         log2;
    ///
    alias core.stdc.math.log2l         log2;

    ///
    alias core.stdc.math.logb          logb;
    ///
    alias core.stdc.math.logbf         logb;
    ///
    alias core.stdc.math.logbl         logb;

    ///
    alias core.stdc.math.modf          modf;
    ///
    alias core.stdc.math.modff         modf;
    ///
    alias core.stdc.math.modfl         modf;

    ///
    alias core.stdc.math.scalbn        scalbn;
    ///
    alias core.stdc.math.scalbnf       scalbn;
    ///
    alias core.stdc.math.scalbnl       scalbn;

    ///
    alias core.stdc.math.scalbln       scalbln;
    ///
    alias core.stdc.math.scalblnf      scalbln;
    ///
    alias core.stdc.math.scalblnl      scalbln;

    ///
    alias core.stdc.math.cbrt          cbrt;
    ///
    alias core.stdc.math.cbrtf         cbrt;
    ///
    alias core.stdc.math.cbrtl         cbrt;

    ///
    alias core.stdc.math.fabs          fabs;
    version (CRuntime_Microsoft)
    {
    }
    else
    {
        ///
        alias core.stdc.math.fabsf         fabs;
        ///
        alias core.stdc.math.fabsl         fabs;
    }

    ///
    alias core.stdc.complex.cabs       fabs;
    ///
    alias core.stdc.complex.cabsf      fabs;
    ///
    alias core.stdc.complex.cabsl      fabs;

    ///
    alias core.stdc.math.hypot         hypot;
    ///
    alias core.stdc.math.hypotf        hypot;
    ///
    alias core.stdc.math.hypotl        hypot;

    ///
    alias core.stdc.math.pow           pow;
    ///
    alias core.stdc.math.powf          pow;
    ///
    alias core.stdc.math.powl          pow;

    ///
    alias core.stdc.complex.cpow       pow;
    ///
    alias core.stdc.complex.cpowf      pow;
    ///
    alias core.stdc.complex.cpowl      pow;

    ///
    alias core.stdc.math.sqrt          sqrt;
    ///
    alias core.stdc.math.sqrtf         sqrt;
    ///
    alias core.stdc.math.sqrtl         sqrt;

    ///
    alias core.stdc.complex.csqrt      sqrt;
    ///
    alias core.stdc.complex.csqrtf     sqrt;
    ///
    alias core.stdc.complex.csqrtl     sqrt;

    ///
    alias core.stdc.math.erf           erf;
    ///
    alias core.stdc.math.erff          erf;
    ///
    alias core.stdc.math.erfl          erf;

    ///
    alias core.stdc.math.erfc          erfc;
    ///
    alias core.stdc.math.erfcf         erfc;
    ///
    alias core.stdc.math.erfcl         erfc;

    ///
    alias core.stdc.math.lgamma        lgamma;
    ///
    alias core.stdc.math.lgammaf       lgamma;
    ///
    alias core.stdc.math.lgammal       lgamma;

    ///
    alias core.stdc.math.tgamma        tgamma;
    ///
    alias core.stdc.math.tgammaf       tgamma;
    ///
    alias core.stdc.math.tgammal       tgamma;

    ///
    alias core.stdc.math.ceil          ceil;
    ///
    alias core.stdc.math.ceilf         ceil;
    ///
    alias core.stdc.math.ceill         ceil;

    ///
    alias core.stdc.math.floor         floor;
    ///
    alias core.stdc.math.floorf        floor;
    ///
    alias core.stdc.math.floorl        floor;

    ///
    alias core.stdc.math.nearbyint     nearbyint;
    ///
    alias core.stdc.math.nearbyintf    nearbyint;
    ///
    alias core.stdc.math.nearbyintl    nearbyint;

    ///
    alias core.stdc.math.rint          rint;
    ///
    alias core.stdc.math.rintf         rint;
    ///
    alias core.stdc.math.rintl         rint;

    ///
    alias core.stdc.math.lrint         lrint;
    ///
    alias core.stdc.math.lrintf        lrint;
    ///
    alias core.stdc.math.lrintl        lrint;

    ///
    alias core.stdc.math.llrint        llrint;
    ///
    alias core.stdc.math.llrintf       llrint;
    ///
    alias core.stdc.math.llrintl       llrint;

    ///
    alias core.stdc.math.round         round;
    ///
    alias core.stdc.math.roundf        round;
    ///
    alias core.stdc.math.roundl        round;

    ///
    alias core.stdc.math.lround        lround;
    ///
    alias core.stdc.math.lroundf       lround;
    ///
    alias core.stdc.math.lroundl       lround;

    ///
    alias core.stdc.math.llround       llround;
    ///
    alias core.stdc.math.llroundf      llround;
    ///
    alias core.stdc.math.llroundl      llround;

    ///
    alias core.stdc.math.trunc         trunc;
    ///
    alias core.stdc.math.truncf        trunc;
    ///
    alias core.stdc.math.truncl        trunc;

    ///
    alias core.stdc.math.fmod          fmod;
    ///
    alias core.stdc.math.fmodf         fmod;
    ///
    alias core.stdc.math.fmodl         fmod;

    ///
    alias core.stdc.math.remainder     remainde+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              r;
    ///
    alias core.stdc.math.remainderf    remainder;
    ///
    alias core.stdc.math.remainderl    remainder;

    ///
    alias core.stdc.math.remquo        remquo;
    ///
    alias core.stdc.math.remquof       remquo;
    ///
    alias core.stdc.math.remquol       remquo;

    ///
    alias core.stdc.math.copysign      copysign;
    ///
    alias core.stdc.math.copysignf     copysign;
    ///
    alias core.stdc.math.copysignl     copysign;

    ///
    alias core.stdc.math.nan           nan;
    ///
    alias core.stdc.math.nanf          nan;
    ///
    alias core.stdc.math.nanl          nan;

    ///
    alias core.stdc.math.nextafter     nextafter;
    ///
    alias core.stdc.math.nextafterf    nextafter;
    ///
    alias core.stdc.math.nextafterl    nextafter;

    ///
    alias core.stdc.math.nexttoward    nexttoward;
    ///
    alias core.stdc.math.nexttowardf   nexttoward;
    ///
    alias core.stdc.math.nexttowardl   nexttoward;

    ///
    alias core.stdc.math.fdim          fdim;
    ///
    alias core.stdc.math.fdimf         fdim;
    ///
    alias core.stdc.math.fdiml         fdim;

    ///
    alias core.stdc.math.fmax          fmax;
    ///
    alias core.stdc.math.fmaxf         fmax;
    ///
    alias core.stdc.math.fmaxl         fmax;

    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fmin          fmin;
    ///
    alias core.stdc.math.fminl         fmin;

    ///
    alias core.stdc.math.fma           fma;
    ///
    alias core.stdc.math.fmaf          fma;
    ///
    alias core.stdc.math.fmal          fma;

    ///
    alias core.stdc.complex.carg       carg;
    ///
    alias core.stdc.complex.cargf      carg;
    ///
    alias core.stdc.complex.cargl      carg;

    ///
    alias core.stdc.complex.cimag      cimag;
    ///
    alias core.stdc.complex.cimagf     cimag;
    ///
    alias core.stdc.complex.cimagl     cimag;

    ///
    alias core.stdc.complex.conj       conj;
    ///
    alias core.stdc.complex.conjf      conj;
    ///
    alias core.stdc.complex.conjl      conj;

    ///
    alias core.stdc.complex.cproj      cproj;
    ///
    alias core.stdc.complex.cprojf     cproj;
    ///
    alias core.stdc.complex.cprojl     cproj;

//  alias core.stdc.complex.creal      creal;
//  alias core.stdc.complex.crealf     creal;
//  alias core.stdc.complex.creall     creal;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_time.h.html, _time.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly,
 *            Alex Rnne Petersen
 * Source:    $(DRUNTIMESRC core/stdc/_time.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.time;

private import core.stdc.config;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

extern (C):
@trusted: // There are only a few functions here that use unsafe C strings.
nothrow:
@nogc:

version (Windows)
{
    ///
    struct tm
    {
        int     tm_sec;     /// seconds after the minute - [0, 60]
        int     tm_min;     /// minutes after the hour - [0, 59]
        int     tm_hour;    /// hours since midnight - [0, 23]
        int     tm_mday;    /// day of the month - [1, 31]
        int     tm_mon;     /// months since January - [0, 11]
        int     tm_year;    /// years since 1900
        int     tm_wday;    /// days since Sunday - [0, 6]
        int     tm_yday;    /// days since January 1 - [0, 365]
        int     tm_isdst;   /// Daylight Saving Time flag
    }
}
else version (Posix)
{
    ///
    struct tm
    {
        int     tm_sec;     /// seconds after the minute [0-60]
        int     tm_min;     /// minutes after the hour [0-59]
        int     tm_hour;    /// hours since midnight [0-23]
        int     tm_mday;    /// day of the month [1-31]
        int     tm_mon;     /// months since January [0-11]
        int     tm_year;    /// years since 1900
        int     tm_wday;    /// days since Sunday [0-6]
        int     tm_yday;    /// days since January 1 [0-365]
        int     tm_isdst;   /// Daylight Savings Time flag
        c_long  tm_gmtoff;  /// offset from CUT in seconds
        char*   tm_zone;    /// timezone abbreviation
    }
}

version (Posix)
{
    public import core.sys.posix.sys.types : time_t, clock_t;
}
else version (Windows)
{
    ///
    alias c_long time_t;
    ///
    alias c_long clock_t;
}

///
version (Windows)
{
    enum clock_t CLOCKS_PER_SEC = 1000;
    clock_t clock();
}
else version (OSX)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000; // was 100 until OSX 10.4/10.5
    version (X86)
        extern (C) pragma(mangle, "clock$UNIX2003") clock_t clock();
    else
        clock_t clock();
}
else version (Darwin) // other Darwins (iOS, TVOS, WatchOS)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else version (FreeBSD)
{
    enum clock_t CLOCKS_PER_SEC = 128;
    clock_t clock();
}
else version (NetBSD)
{
    enum clock_t CLOCKS_PER_SEC = 100;
    clock_t clock();
}
else version (OpenBSD)
{
    enum clock_t CLOCKS_PER_SEC = 100;
    clock_t clock();
}
else version (DragonFlyBSD)
{
    enum clock_t CLOCKS_PER_SEC = 128;
    clock_t clock();
}
else version (Solaris)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else version (CRuntime_Glibc)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else version (CRuntime_Musl)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else version (CRuntime_Bionic)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else version (CRuntime_UClibc)
{
    enum clock_t CLOCKS_PER_SEC = 1_000_000;
    clock_t clock();
}
else
{
    static assert(0, "unsupported system");
}

///
pure double  difftime(time_t time1, time_t time0); // MT-Safe
///
@system time_t  mktime(scope tm* timeptr); // @system: MT-Safe env locale
///
time_t  time(scope time_t* timer);

///
@system char*   asctime(const scope tm* timeptr); // @system: MT-Unsafe race:asctime locale
///
@system char*   ctime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf race:asctime env locale
///
@system tm*     gmtime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf env locale
///
@system tm*     localtime(const scope time_t* timer); // @system: MT-Unsafe race:tmbuf env locale
///
@system size_t  strftime(scope char* s, size_t maxsize, const scope char* format, const scope tm* timeptr); // @system: MT-Safe env locale

version (Windows)
{
    ///
    void  tzset();                           // non-standard
    ///
    void  _tzset();                          // non-standard
    ///
    @system char* _strdate(return scope char* s);                 // non-standard
    ///
    @system char* _strtime(return scope char* s);                 // non-standard

    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (Darwin)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (CRuntime_Glibc)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (FreeBSD)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (NetBSD)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (OpenBSD)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (DragonFlyBSD)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (Solaris)
{
    ///
    void tzset();
    ///
    extern __gshared const(char)*[2] tzname;
}
else version (CRuntime_Bionic)
{
    ///
    void tzset();
    ///
    extern __gshared const(char)*[2] tzname;
}
else version (CRuntime_Musl)
{
    ///
    void tzset();                            // non-standard
    ///
    extern __gshared const(char)*[2] tzname; // non-standard
}
else version (CRuntime_UClibc)
{
    ///
    void tzset();
    ///
    extern __gshared const(char)*[2] tzname;
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_wchar.h.html, _wchar.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_wchar_.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

/* NOTE: This file has been patched from the original DMD distribution to
 * work with the GDC compiler.
 */
module core.stdc.wchar_;

private import core.stdc.config;
private import core.stdc.stdarg; // for va_list
private import core.stdc.stdio;  // for FILE, not exposed per spec
public import core.stdc.stddef;  // for wchar_t
public import core.stdc.time;    // for tm
public import core.stdc.stdint;  // for WCHAR_MIN, WCHAR_MAX

extern (C):
@system:
nothrow:
@nogc:

version (CRuntime_Glibc)
{
    ///
    struct mbstate_t
    {
        int __count;
        union ___value
        {
            wint_t __wch = 0;
            char[4] __wchb;
        }
        ___value __value;
    }
}
else version (FreeBSD)
{
    ///
    union __mbstate_t // <sys/_types.h>
    {
        char[128]   _mbstate8 = 0;
        long        _mbstateL;
    }

    ///
    alias mbstate_t = __mbstate_t;
}
else version (NetBSD)
{
    ///
    union __mbstate_t
    {
        int64_t   __mbstateL;
        char[128] __mbstate8;
    }

    ///
    alias mbstate_t = __mbstate_t;
}
else version (OpenBSD)
{
    ///
    union __mbstate_t
    {
        char[128] __mbstate8 = 0;
        int64_t   __mbstateL;
    }

    ///
    alias mbstate_t = __mbstate_t;
}
else version (DragonFlyBSD)
{
    ///
    union __mbstate_t                   // <sys/stdint.h>
    {
        char[128]   _mbstate8 = 0;
        long        _mbstateL;
    }

    ///
    alias mbstate_t = __mbstate_t;
}
else version (Solaris)
{
    ///
    struct __mbstate_t
    {
        version (D_LP64)
        {
            long[4] __filler;
        }
        else
        {
            int[6] __filler;
        }
    }

    ///
    alias mbstate_t = __mbstate_t;
}
else version (CRuntime_UClibc)
{
    ///
    struct mbstate_t
    {
        wchar_t __mask = 0;
        wchar_t __wc = 0;
    }
}
else
{
    ///
    alias int mbstate_t;
}

///
alias wchar_t wint_t;

///
enum wchar_t WEOF = 0xFFFF;

///
int fwprintf(FILE* stream, in wchar_t* format, ...);
///
int fwscanf(FILE* stream, in wchar_t* format, ...);
int swscanf(in wchar_t* s, in wchar_t* format, ...);
///
int vfwprintf(FILE* stream, in wchar_t* format, va_list arg);
///
int vfwscanf(FILE* stream, in wchar_t* format, va_list arg);
int vswscanf(in wchar_t* s, in wchar_t* format, va_list arg);
///
int vwprintf(in wchar_t* format, va_list arg);
///
int vwscanf(in wchar_t* format, va_list arg);
///
int wprintf(in wchar_t* format, ...);
///
int wscanf(in wchar_t* format, ...);

/*
 * Windows has 2 versions of swprintf and vswprintf.  MinGW defaults to the
 * Microsoft signature.  Alias to match DMD/ANSI signature.
 */
version (MinGW)
{
    ///
    int _snwprintf(wchar_t* s, size_t n, in wchar_t* format, ...);
    alias _snwprintf swprintf;
    ///
    int _vsnwprintf(wchar_t* s, size_t n, in wchar_t* format, va_list arg);
    alias _vsnwprintf vswprintf;	
}
else
{
    ///
    int swprintf(wchar_t* s, size_t n, in wchar_t* format, ...);
    ///
    int vswprintf(wchar_t* s, size_t n, in wchar_t* format, va_list arg);
}

// No unsafe pointer manipulation.
@trusted
{
    ///
    wint_t fgetwc(FILE* stream);
    ///
    wint_t fputwc(wchar_t c, FILE* stream);
}

///
wchar_t* fgetws(wchar_t* s, int n, FILE* stream);
///
int      fputws(in wchar_t* s, FILE* stream);

// No unsafe pointer manipulation.
extern (D) @trusted
{
    ///
    wint_t getwchar()                     { return fgetwc(stdin);     }
    ///
    wint_t putwchar(wchar_t c)            { return fputwc(c,stdout);  }
    ///
    wint_t getwc(FILE* stream)            { return fgetwc(stream);    }
    ///
    wint_t putwc(wchar_t c, FILE* stream) { return fputwc(c, stream); }
}

// No unsafe pointer manipulation.
@trusted
{
    ///
    wint_t ungetwc(wint_t c, FILE* stream);
    ///
    version (CRuntime_Microsoft)
    {
        // MSVC defines this as an inline function.
        int fwide(FILE* stream, int mode) { return mode; }
    }
    else
    {
        int    fwide(FILE* stream, int mode);
    }
}

///
double  wcstod(in wchar_t* nptr, wchar_t** endptr);
///
float   wcstof(in wchar_t* nptr, wchar_t** endptr);
///
real    wcstold(in wchar_t* nptr, wchar_t** endptr);
///
c_long  wcstol(in wchar_t* nptr, wchar_t** endptr, int base);
///
long    wcstoll(in wchar_t* nptr, wchar_t** endptr, int base);
///
c_ulong wcstoul(in wchar_t* nptr, wchar_t** endptr, int base);
///
ulong   wcstoull(in wchar_t* nptr, wchar_t** endptr, int base);

///
pure wchar_t* wcscpy(return wchar_t* s1, scope const wchar_t* s2);
///
pure wchar_t* wcsncpy(return wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure wchar_t* wcscat(return wchar_t* s1, scope const wchar_t* s2);
///
pure wchar_t* wcsncat(return wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure int wcscmp(scope const wchar_t* s1, scope const wchar_t* s2);
///
int      wcscoll(scope const wchar_t* s1, scope const wchar_t* s2);
///
pure int wcsncmp(scope const wchar_t* s1, scope const wchar_t* s2, size_t n);
///
size_t   wcsxfrm(scope wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure inout(wchar_t)* wcschr(return inout(wchar_t)* s, wchar_t c);
///
pure size_t wcscspn(scope const wchar_t* s1, scope const wchar_t* s2);
///
pure inout(wchar_t)* wcspbrk(return inout(wchar_t)* s1, scope const wchar_t* s2);
///
pure inout(wchar_t)* wcsrchr(return inout(wchar_t)* s, wchar_t c);
///
pure size_t wcsspn(scope const wchar_t* s1, scope const wchar_t* s2);
///
pure inout(wchar_t)* wcsstr(return inout(wchar_t)* s1, scope const wchar_t* s2);
///
wchar_t* wcstok(return wchar_t* s1, scope const wchar_t* s2, wchar_t** ptr);
///
pure size_t wcslen(scope const wchar_t* s);

///
pure wchar_t* wmemchr(return const wchar_t* s, wchar_t c, size_t n);
///
pure int      wmemcmp(scope const wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure wchar_t* wmemcpy(return wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure wchar_t* wmemmove(return wchar_t* s1, scope const wchar_t* s2, size_t n);
///
pure wchar_t* wmemset(return wchar_t* s, wchar_t c, size_t n);

///
size_t wcsftime(wchar_t* s, size_t maxsize, in wchar_t* format, in tm* timeptr);

version (Windows)
{
    ///
    wchar_t* _wasctime(tm*);      // non-standard
    ///
    wchar_t* _wctime(time_t*);    // non-standard
    ///
    wchar_t* _wstrdate(wchar_t*); // non-standard
    ///
    wchar_t* _wstrtime(wchar_t*); // non-standard
}

// No unsafe pointer manipulation.
@trusted
{
    ///
    wint_t btowc(int c);
    ///
    int    wctob(wint_t c);
}

///
int    mbsinit(in mbstate_t* ps);
///
size_t mbrlen(in char* s, size_t n, mbstate_t* ps);
///
size_t mbrtowc(wchar_t* pwc, in char* s, size_t n, mbstate_t* ps);
///
size_t wcrtomb(char* s, wchar_t wc, mbstate_t* ps);
///
size_t mbsrtowcs(wchar_t* dst, in char** src, size_t len, mbstate_t* ps);
///
size_t wcsrtombs(char* dst, in wchar_t** src, size_t len, mbstate_t* ps);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_wctype.h.html, _wctype.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_wctype.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.wctype;

public  import core.stdc.wchar_; // for wint_t, WEOF

extern (C):
@trusted: // Only a couple of functions below operate on unsafe C strings.
nothrow:
@nogc:

///
alias wchar_t wctrans_t;
///
alias wchar_t wctype_t;

///
pure int iswalnum(wint_t wc);
///
pure int iswalpha(wint_t wc);
///
pure int iswblank(wint_t wc);
///
pure int iswcntrl(wint_t wc);
///
pure int iswdigit(wint_t wc);
///
pure int iswgraph(wint_t wc);
///
pure int iswlower(wint_t wc);
///
pure int iswprint(wint_t wc);
///
pure int iswpunct(wint_t wc);
///
pure int iswspace(wint_t wc);
///
pure int iswupper(wint_t wc);
///
pure int iswxdigit(wint_t wc);

///
int       iswctype(wint_t wc, wctype_t desc);
///
@system wctype_t  wctype(in char* property);
///
pure wint_t    towlower(wint_t wc);
///
pure wint_t    towupper(wint_t wc);
///
wint_t    towctrans(wint_t wc, wctrans_t desc);
///
@system wctrans_t wctrans(in char* property);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      .      ..     exception.d   
typeinfo.d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  // Written in the D programming language.

/**
 * Interface to C++ <exception>
 *
 * Copyright: Copyright (c) 2016 D Language Foundation
 * License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   $(HTTP digitalmars.com, Walter Bright)
 * Source:    $(DRUNTIMESRC core/stdcpp/_exception.d)
 */

module core.stdcpp.exception;

extern (C++, "std"):

version (CppRuntime_DigitalMars)
{
    import core.stdcpp.typeinfo;

    alias void function() unexpected_handler;
    unexpected_handler set_unexpected(unexpected_handler f) nothrow;
    void unexpected();

    alias void function() terminate_handler;
    terminate_handler set_terminate(terminate_handler f) nothrow;
    void terminate();

    bool uncaught_exception();

    class exception
    {
        this() nothrow { }
        this(const exception) nothrow { }
        //exception operator=(const exception) nothrow { return this; }
        //virtual ~this() nothrow;
        void dtor() { }
        const(char)* what() const nothrow;
    }

    class bad_exception : exception
    {
        this() nothrow { }
        this(const bad_exception) nothrow { }
        //bad_exception operator=(const bad_exception) nothrow { return this; }
        //virtual ~this() nothrow;
        override const(char)* what() const nothrow;
    }
}
else version (CppRuntime_Gcc)
{
    alias void function() unexpected_handler;
    unexpected_handler set_unexpected(unexpected_handler f) nothrow;
    void unexpected();

    alias void function() terminate_handler;
    terminate_handler set_terminate(terminate_handler f) nothrow;
    void terminate();

    pure bool uncaught_exception();

    class exception
    {
        this();
        //virtual ~this();
        void dtor1();
        void dtor2();
        const(char)* what() const;
    }

    class bad_exception : exception
    {
        this();
        //virtual ~this();
        override const(char)* what() const;
    }
}
else version (CppRuntime_Microsoft)
{
    class exception
    {
        this();
        this(const exception);
        //exception operator=(const exception) { return this; }
            //virtual ~this();
        void dtor() { }
        const(char)* what() const;

    private:
        const(char)* mywhat;
        bool dofree;
    }

    class bad_exception : exception
    {
        this(const(char)* msg = "bad exception");
        //virtual ~this();
    }
}
else
    static assert(0, "Missing std::exception binding for this platform");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Written in the D programming language.

/**
 * Interface to C++ <typeinfo>
 *
 * Copyright: Copyright (c) 2016 D Language Foundation
 * License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   $(HTTP digitalmars.com, Walter Bright)
 * Source:    $(DRUNTIMESRC core/stdcpp/_typeinfo.d)
 */

module core.stdcpp.typeinfo;

version (CppRuntime_DigitalMars)
{
    import core.stdcpp.exception;

    extern (C++, "std"):

    class type_info
    {
        void* pdata;

    public:
        //virtual ~this();
        void dtor() { }     // reserve slot in vtbl[]

        //bool operator==(const type_info rhs) const;
        //bool operator!=(const type_info rhs) const;
        final bool before(const type_info rhs) const;
        final const(char)* name() const;
    protected:
        //type_info();
    private:
        //this(const type_info rhs);
        //type_info operator=(const type_info rhs);
    }

    class bad_cast : exception
    {
        this() nothrow { }
        this(const bad_cast) nothrow { }
        //bad_cast operator=(const bad_cast) nothrow { return this; }
        //virtual ~this() nothrow;
        override const(char)* what() const nothrow;
    }

    class bad_typeid : exception
    {
        this() nothrow { }
        this(const bad_typeid) nothrow { }
        //bad_typeid operator=(const bad_typeid) nothrow { return this; }
        //virtual ~this() nothrow;
        override const (char)* what() const nothrow;
    }
}
else version (CppRuntime_Microsoft)
{
    import core.stdcpp.exception;

    extern (C++, "std"):

    struct __type_info_node
    {
        void* _MemPtr;
        __type_info_node* _Next;
    }

    extern __gshared __type_info_node __type_info_root_node;

    class type_info
    {
        //virtual ~this();
        void dtor() { }     // reserve slot in vtbl[]
        //bool operator==(const type_info rhs) const;
        //bool operator!=(const type_info rhs) const;
        final bool before(const type_info rhs) const;
        final const(char)* name(__type_info_node* p = &__type_info_root_node) const;

    private:
        void* pdata;
        char[1] _name;
        //type_info operator=(const type_info rhs);
    }

    class bad_cast : exception
    {
        this(const(char)* msg = "bad cast");
        //virtual ~this();
    }

    class bad_typeid : exception
    {
        this(const(char)* msg = "bad typeid");
        //virtual ~this();
    }
}
else version (CppRuntime_Gcc)
{
    import core.stdcpp.exception;

    extern (C++, "__cxxabiv1")
    {
        class __class_type_info;
    }

    extern (C++, "std"):

    class type_info
    {
        void dtor1();                           // consume destructor slot in vtbl[]
        void dtor2();                           // consume destructor slot in vtbl[]
        final const(char)* name()() const nothrow {
            return _name[0] == '*' ? _name + 1 : _name;
        }
        final bool before()(const type_info _arg) const {
            import core.stdc.string : strcmp;
            return (_name[0] == '*' && _arg._name[0] == '*')
                ? _name < _arg._name
                : strcmp(_name, _arg._name) < 0;
        }
        //bool operator==(const type_info) const;
        bool __is_pointer_p() const;
        bool __is_function_p() const;
        bool __do_catch(const type_info, void**, uint) const;
        bool __do_upcast(const __class_type_info, void**) const;

        const(char)* _name;
        this(const(char)*);
    }

    class bad_cast : exception
    {
        this();
        //~this();
        override const(char)* what() const;
    }

    class bad_typeid : exception
    {
        this();
        //~this();
        override const(char)* what() const;
    }
}
else
    static assert(0, "Missing std::type_info binding for this platform");
                                                                                                                                                                                                                                                                       .      ..     	barrier.d      condition.d    config.d   exception.d    mutex.d    	rwmutex.d     xsemaphore.d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * The barrier module provides a primitive for synchronizing the progress of
 * a group of threads.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/sync/_barrier.d)
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sync.barrier;


public import core.sync.exception;
private import core.sync.condition;
private import core.sync.mutex;

version (Posix)
{
    private import core.stdc.errno;
    private import core.sys.posix.pthread;
}


////////////////////////////////////////////////////////////////////////////////
// Barrier
//
// void wait();
////////////////////////////////////////////////////////////////////////////////


/**
 * This class represents a barrier across which threads may only travel in
 * groups of a specific size.
 */
class Barrier
{
    ////////////////////////////////////////////////////////////////////////////
    // Initialization
    ////////////////////////////////////////////////////////////////////////////


    /**
     * Initializes a barrier object which releases threads in groups of limit
     * in size.
     *
     * Params:
     *  limit = The number of waiting threads to release in unison.
     *
     * Throws:
     *  SyncError on error.
     */
    this( uint limit )
    in
    {
        assert( limit > 0 );
    }
    body
    {
        m_lock  = new Mutex;
        m_cond  = new Condition( m_lock );
        m_group = 0;
        m_limit = limit;
        m_count = limit;
    }


    ////////////////////////////////////////////////////////////////////////////
    // General Actions
    ////////////////////////////////////////////////////////////////////////////


    /**
     * Wait for the pre-determined number of threads and then proceed.
     *
     * Throws:
     *  SyncError on error.
     */
    void wait()
    {
        synchronized( m_lock )
        {
            uint group = m_group;

            if ( --m_count == 0 )
            {
                m_group++;
                m_count = m_limit;
                m_cond.notifyAll();
            }
            while ( group == m_group )
                m_cond.wait();
        }
    }


private:
    Mutex       m_lock;
    Condition   m_cond;
    uint        m_group;
    uint        m_limit;
    uint        m_count;
}


////////////////////////////////////////////////////////////////////////////////
// Unit Tests
////////////////////////////////////////////////////////////////////////////////


version (unittest)
{
    private import core.thread;


    unittest
    {
        int  numThreads = 10;
        auto barrier    = new Barrier( numThreads );
        auto synInfo    = new Object;
        int  numReady   = 0;
        int  numPassed  = 0;

        void threadFn()
        {
            synchronized( synInfo )
            {
                ++numReady;
            }
            barrier.wait();
            synchronized( synInfo )
            {
                ++numPassed;
            }
        }

        auto group = new ThreadGroup;

        for ( int i = 0; i < numThreads; ++i )
        {
            group.create( &threadFn );
        }
        group.joinAll();
        assert( numReady == numThreads && numPassed == numThreads );
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * The condition module provides a primitive for synchronized condition
 * checking.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/sync/_condition.d)
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sync.condition;


public import core.sync.exception;
public import core.sync.mutex;
public import core.time;

version (Windows)
{
    private import core.sync.semaphore;
    private import core.sys.windows.basetsd /+: HANDLE+/;
    private import core.sys.windows.winbase /+: CloseHandle, CreateSemaphoreA, CRITICAL_SECTION,
        DeleteCriticalSection, EnterCriticalSection, INFINITE, InitializeCriticalSection,
        LeaveCriticalSection, ReleaseSemaphore, WAIT_OBJECT_0, WaitForSingleObject+/;
    private import core.sys.windows.windef /+: BOOL, DWORD+/;
    private import core.sys.windows.winerror /+: WAIT_TIMEOUT+/;
}
else version (Posix)
{
    private import core.sync.config;
    private import core.stdc.errno;
    private import core.sys.posix.pthread;
    private import core.sys.posix.time;
}
else
{
    static assert(false, "Platform not supported");
}


////////////////////////////////////////////////////////////////////////////////
// Condition
//
// void wait();
// void notify();
// void notifyAll();
////////////////////////////////////////////////////////////////////////////////


/**
 * This class represents a condition variable as conceived by C.A.R. Hoare.  As
 * per Mesa type monitors however, "signal" has been replaced with "notify" to
 * indicate that control is not transferred to the waiter when a notification
 * is sent.
 */
class Condition
{
    ////////////////////////////////////////////////////////////////////////////
    // Initialization
    ////////////////////////////////////////////////////////////////////////////

    /**
     * Initializes a condition object which is associated with the supplied
     * mutex object.
     *
     * Params:
     *  m = The mutex with which this condition will be associated.
     *
     * Throws:
     *  SyncError on error.
     */
    this( Mutex m ) nothrow @safe
    {
        version (Windows)
        {
            m_blockLock = CreateSemaphoreA( null, 1, 1, null );
            if ( m_blockLock == m_blockLock.init )
                throw new SyncError( "Unable to initialize condition" );
            scope(failure) CloseHandle( m_blockLock );

            m_blockQueue = CreateSemaphoreA( null, 0, int.max, null );
            if ( m_blockQueue == m_blockQueue.init )
                throw new SyncError( "Unable to initialize condition" );
            scope(failure) CloseHandle( m_blockQueue );

            InitializeCriticalSection( &m_unblockLock );
            m_assocMutex = m;
        }
        else version (Posix)
        {
            m_assocMutex = m;
            int rc = pthread_cond_init( &m_hndl, null );
            if ( rc )
                throw new SyncError( "Unable to initialize condition" );
        }
    }


    ~this()
    {
        version (Windows)
        {
            BOOL rc = CloseHandle( m_blockLock );
            assert( rc, "Unable to destroy condition" );
            rc = CloseHandle( m_blockQueue );
            assert( rc, "Unable to destroy condition" );
            DeleteCriticalSection( &m_unblockLock );
        }
        else version (Posix)
        {
            int rc = pthread_cond_destroy( &m_hndl );
            assert( !rc, "Unable to destroy condition" );
        }
    }


    ////////////////////////////////////////////////////////////////////////////
    // General Properties
    ////////////////////////////////////////////////////////////////////////////


    /**
     * Gets the mutex associated with this condition.
     *
     * Returns:
     *  The mutex associated with this condition.
     */
    @property Mutex mutex()
    {
        return m_assocMutex;
    }

    // undocumented function for internal use
    final @property Mutex mutex_nothrow() pure nothrow @safe @nogc
    {
        return m_assocMutex;
    }


    ////////////////////////////////////////////////////////////////////////////
    // General Actions
    ////////////////////////////////////////////////////////////////////////////


    /**
     * Wait until notified.
     *
     * Throws:
     *  SyncError on error.
     */
    void wait()
    {
        version (Windows)
        {
            timedWait( INFINITE );
        }
        else version (Posix)
        {
            int rc = pthread_cond_wait( &m_hndl, m_assocMutex.handleAddr() );
            if ( rc )
                throw new SyncError( "Unable to wait for condition" );
        }
    }


    /**
     * Suspends the calling thread until a notification occurs or until the
     * supplied time period has elapsed.
     *
     * Params:
     *  val = The time to wait.
     *
     * In:
     *  val must be non-negative.
     *
     * Throws:
     *  SyncError on error.
     *
     * Returns:
     *  true if notified before the timeout and false if not.
     */
    bool wait( Duration val )
    in
    {
        assert( !val.isNegative );
    }
    body
    {
        version (Windows)
        {
            auto maxWaitMillis = dur!("msecs")( uint.max - 1 );

            while ( val > maxWaitMillis )
            {
                if ( timedWait( cast(uint)
                               maxWaitMillis.total!"msecs" ) )
                    return true;
                val -= maxWaitMillis;
            }
            return timedWait( cast(uint) val.total!"msecs" );
        }
        else version (Posix)
        {
            timespec t = void;
            mktspec( t, val );

            int rc = pthread_cond_timedwait( &m_hndl,
                                             m_assocMutex.handleAddr(),
                                             &t );
            if ( !rc )
                return true;
            if ( rc == ETIMEDOUT )
                return false;
            throw new SyncError( "Unable to wait for condition" );
        }
    }


    /**
     * Notifies one waiter.
     *
     * Throws:
     *  SyncError on error.
     */
    void notify()
    {
        version (Windows)
        {
            notify( false );
        }
        else version (Posix)
        {
            int rc = pthread_cond_signal( &m_hndl );
            if ( rc )
                throw new SyncError( "Unable to notify condition" );
        }
    }


    /**
     * Notifies all waiters.
     *
     * Throws:
     *  SyncError on error.
     */
    void notifyAll()
    {
        version (Windows)
        {
            notify( true );
        }
        else version (Posix)
        {
            int rc = pthread_cond_broadcast( &m_hndl );
            if ( rc )
                throw new SyncError( "Unable to notify condition" );
        }
    }


private:
    version (Windows)
    {
        bool timedWait( DWORD timeout )
        {
            int   numSignalsLeft;
            int   numWaitersGone;
            DWORD rc;

            rc = WaitForSingleObject( m_blockLock, INFINITE );
            assert( rc == WAIT_OBJECT_0 );

            m_numWaitersBlocked++;

            rc = ReleaseSemaphore( m_blockLock, 1, null );
            assert( rc );

            m_assocMutex.unlock();
            scope(failure) m_assocMutex.lock();

            rc = WaitForSingleObject( m_blockQueue, timeout );
            assert( rc == WAIT_OBJECT_0 || rc == WAIT_TIMEOUT );
            bool timedOut = (rc == WAIT_TIMEOUT);

            EnterCriticalSection( &m_unblockLock );
            scope(failure) LeaveCriticalSection( &m_unblockLock );

            if ( (numSignalsLeft = m_numWaitersToUnblock) != 0 )
            {
                if ( timedOut )
                {
                    // timeout (or canceled)
                    if ( m_numWaitersBlocked != 0 )
                    {
                        m_numWaitersBlocked--;
                        // do not unblock next waiter below (already unblocked)
                        numSignalsLeft = 0;
                    }
                    else
                    {
                        // spurious wakeup pending!!
                        m_numWaitersGone = 1;
                    }
                }
                if ( --m_numWaitersToUnblock == 0 )
                {
                    if ( m_numWaitersBlocked != 0 )
                    {
                        // open the gate
                        rc = ReleaseSemaphore( m_blockLock, 1, null );
                        assert( rc );
                        // do not open the gate below again
                        numSignalsLeft = 0;
                    }
                    else if ( (numWaitersGone = m_numWaitersGone) != 0 )
                    {
                        m_numWaitersGone = 0;
                    }
                }
            }
            else if ( ++m_numWaitersGone == int.max / 2 )
            {
                // timeout/canceled or spurious event :-)
                rc = WaitForSingleObject( m_blockLock, INFINITE );
                assert( rc == WAIT_OBJECT_0 );
                // something is going on here - test of timeouts?
                m_numWaitersBlocked -= m_numWaitersGone;
                rc = ReleaseSemaphore( m_blockLock, 1, null );
                assert( rc == WAIT_OBJECT_0 );
                m_numWaitersGone = 0;
            }

            LeaveCriticalSection( &m_unblockLock );

            if ( numSignalsLeft == 1 )
            {
                // better now than spurious later (same as ResetEvent)
                for ( ; numWaitersGone > 0; --numWaitersGone )
                {
                    rc = WaitForSingleObject( m_blockQueue, INFINITE );
                    assert( rc == WAIT_OBJECT_0 );
                }
                // open the gate
                rc = ReleaseSemaphore( m_blockLock, 1, null );
                assert( rc );
            }
            else if ( numSignalsLeft != 0 )
            {
                // unblock next waiter
                rc = ReleaseSemaphore( m_blockQueue, 1, null );
                assert( rc );
            }
            m_assocMutex.lock();
            return !timedOut;
        }


        void notify( bool all )
        {
            DWORD rc;

            EnterCriticalSection( &m_unblockLock );
            scope(failure) LeaveCriticalSection( &m_unblockLock );

            if ( m_numWaitersToUnblock != 0 )
            {
                if ( m_numWaitersBlocked == 0 )
                {
                    LeaveCriticalSection( &m_unblockLock );
                    return;
                }
                if ( all )
                {
                    m_numWaitersToUnblock += m_numWaitersBlocked;
                    m_numWaitersBlocked = 0;
                }
                else
                {
                    m_numWaitersToUnblock++;
                    m_numWaitersBlocked--;
                }
                LeaveCriticalSection( &m_unblockLock );
            }
            else if ( m_numWaitersBlocked > m_numWaitersGone )
            {
                rc = WaitForSingleObject( m_blockLock, INFINITE );
                assert( rc == WAIT_OBJECT_0 );
                if ( 0 != m_numWaitersGone )
                {
                    m_numWaitersBlocked -= m_numWaitersGone;
                    m_numWaitersGone = 0;
                }
                if ( all )
                {
                    m_numWaitersToUnblock = m_numWaitersBlocked;
                    m_numWaitersBlocked = 0;
                }
                else
                {
                    m_numWaitersToUnblock = 1;
                    m_numWaitersBlocked--;
                }
                LeaveCriticalSection( &m_unblockLock );
                rc = ReleaseSemaphore( m_blockQueue, 1, null );
                assert( rc );
            }
            else
            {
                LeaveCriticalSection( &m_unblockLock );
            }
        }


        // NOTE: This implementation uses Algorithm 8c as described here:
        //       http://groups.google.com/group/comp.programming.threads/
        //              browse_frm/thread/1692bdec8040ba40/e7a5f9d40e86503a
        HANDLE              m_blockLock;    // auto-reset event (now semaphore)
        HANDLE              m_blockQueue;   // auto-reset event (now semaphore)
        Mutex               m_assocMutex;   // external mutex/CS
        CRITICAL_SECTION    m_unblockLock;  // internal mutex/CS
        int                 m_numWaitersGone        = 0;
        int                 m_numWaitersBlocked     = 0;
        int                 m_numWaitersToUnblock   = 0;
    }
    else version (Posix)
    {
        Mutex               m_assocMutex;
        pthread_cond_t      m_hndl;
    }
}


////////////////////////////////////////////////////////////////////////////////
// Unit Tests
////////////////////////////////////////////////////////////////////////////////


version (unittest)
{
    private import core.thread;
    private import core.sync.mutex;
    private import core.sync.semaphore;


    void testNotify()
    {
        auto mutex      = new Mutex;
        auto condReady  = new Condition( mutex );
        auto semDone    = new Semaphore;
        auto synLoop    = new Object;
        int  numWaiters = 10;
        int  numTries   = 10;
        int  numReady   = 0;
        int  numTotal   = 0;
        int  numDone    = 0;
        int  numPost    = 0;

        void waiter()
        {
            for ( int i = 0; i < numTries; ++i )
            {
                synchronized( mutex )
                {
                    while ( numReady < 1 )
                    {
                        condReady.wait();
                    }
                    --numReady;
                    ++numTotal;
                }

                synchronized( synLoop )
                {
                    ++numDone;
                }
                semDone.wait();
            }
        }

        auto group = new ThreadGroup;

        for ( int i = 0; i < numWaiters; ++i )
            group.create( &waiter );

        for ( int i = 0; i < numTries; ++i )
        {
            for ( int j = 0; j < numWaiters; ++j )
            {
                synchronized( mutex )
                {
                    ++numReady;
                    condReady.notify();
                }
            }
            while ( true )
            {
                synchronized( synLoop )
                {
                    if ( numDone >= numWaiters )
                        break;
                }
                Thread.yield();
            }
            for ( int j = 0; j < numWaiters; ++j )
            {
                semDone.notify();
            }
        }

        group.joinAll();
        assert( numTotal == numWaiters * numTries );
    }


    void testNotifyAll()
    {
        auto mutex      = new Mutex;
        auto condReady  = new Condition( mutex );
        int  numWaiters = 10;
        int  numReady   = 0;
        int  numDone    = 0;
        bool alert      = false;

        void waiter()
        {
            synchronized( mutex )
            {
                ++numReady;
                while ( !alert )
                    condReady.wait();
                ++numDone;
            }
        }

        auto group = new ThreadGroup;

        for ( int i = 0; i < numWaiters; ++i )
            group.create( &waiter );

        while ( true )
        {
            synchronized( mutex )
            {
                if ( numReady >= numWaiters )
                {
                    alert = true;
                    condReady.notifyAll();
                    break;
                }
            }
            Thread.yield();
        }
        group.joinAll();
        assert( numReady == numWaiters && numDone == numWaiters );
    }


    void testWaitTimeout()
    {
        auto mutex      = new Mutex;
        auto condReady  = new Condition( mutex );
        bool waiting    = false;
        bool alertedOne = true;
        bool alertedTwo = true;

        void waiter()
        {
            synchronized( mutex )
            {
                waiting    = true;
                // we never want to miss the notification (30s)
                alertedOne = condReady.wait( dur!"seconds"(30) );
                // but we don't want to wait long for the timeout (10ms)
                alertedTwo = condReady.wait( dur!"msecs"(10) );
            }
        }

        auto thread = new Thread( &waiter );
        thread.start();

        while ( true )
        {
            synchronized( mutex )
            {
                if ( waiting )
                {
                    condReady.notify();
                    break;
                }
            }
            Thread.yield();
        }
        thread.join();
        assert( waiting );
        assert( alertedOne );
        assert( !alertedTwo );
    }


    unittest
    {
        testNotify();
        testNotifyAll();
        testWaitTimeout();
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * The config module contains utility routines and configuration information
 * specific to this package.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(WEB www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/sync/_config.d)
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sync.config;


version (Posix)
{
    private import core.sys.posix.time;
    private import core.sys.posix.sys.time;
    private import core.time;


    void mktspec( ref timespec t ) nothrow
    {
        static if ( false && is( typeof( clock_gettime ) ) )
        {
            clock_gettime( CLOCK_REALTIME, &t );
        }
        else
        {
            timeval tv;

            gettimeofday( &tv, null );
            (cast(byte*) &t)[0 .. t.sizeof] = 0;
            t.tv_sec  = cast(typeof(t.tv_sec))  tv.tv_sec;
            t.tv_nsec = cast(typeof(t.tv_nsec)) tv.tv_usec * 1_000;
        }
    }


    void mktspec( ref timespec t, Duration delta ) nothrow
    {
        mktspec( t );
        mvtspec( t, delta );
    }


    void mvtspec( ref timespec t, Duration delta ) nothrow
    {
        auto val  = delta;
             val += dur!"seconds"( t.tv_sec );
             val += dur!"nsecs"( t.tv_nsec );

        //auto val = delta + dur!"seconds"( t.tv_sec ) +
        //                 + dur!"nsecs"( t.tv_nsec );

        if ( val.total!"seconds" > t.tv_sec.max )
        {
            t.tv_sec  = t.tv_sec.max;
            t.tv_nsec = cast(typeof(t.tv_nsec)) val.split!("seconds", "nsecs")().nsecs;
        }
        else
            val.split!("seconds", "nsecs")(t.tv_sec, t.tv_nsec);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * Define base class for synchronization exceptions.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/sync/_exception.d)
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sync.exception;


/**
 * Base class for synchronization errors.
 */
class SyncError : Error
{
    @safe pure nothrow this(string msg, string file = __FILE__, size_t line = __LINE__, Throwable next = null)
    {
        super(msg, file, line, next);
    }

    @safe pure nothrow this(string msg, Throwable next, string file = __FILE__, size_t line = __LINE__)
    {
        super(msg, file, line, next);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * The mutex module provides a primitive for maintaining mutually exclusive
 * access.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/sync/_mutex.d)
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sync.mutex;


public import core.sync.exception;

version (Windows)
{
    private import core.sys.windows.winbase /+: CRITICAL_SECTION, DeleteCriticalSection,
        EnterCriticalSection, InitializeCriticalSection, LeaveCriticalSection,
        TryEnterCriticalSection+/;
}
else version (Posix)
{
    private import core.sys.posix.pthread;
}
else
{
    static assert(false, "Platform not supported");
}

////////////////////////////////////////////////////////////////////////////////
// Mutex
//
// void lock();
// void unlock();
// bool tryLock();
////////////////////////////////////////////////////////////////////////////////


/**
 * This class represents a general purpose, recursive mutex.
 *
 * Implemented using `pthread_mutex` on Posix and `CRITICAL_SECTION`
 * on Windows.
 */
class Mutex :
    Object.Monitor
{
    ////////////////////////////////////////////////////////////////////////////
    // Initialization
    ////////////////////////////////////////////////////////////////////////////


    /**
     * Initializes a mutex object.
     *
     */
    this() @trusted nothrow @nogc
    {
        this(true);
    }

    /// ditto
    this() shared @trusted nothrow @nogc
    {
        this(true);
    }

    // Undocumented, useful only in Mutex.this().
    private this(this Q)(bool _unused_) @trusted nothrow @nogc
        if (is(Q == Mutex) || is(Q == shared Mutex))
    {
        version (Windows)
        {
            InitializeCriticalSection(cast(CRITICAL_SECTION*) &m_hndl);
        }
        else version (Posix)
        {
            import core.internal.abort : abort;
            pthread_mutexattr_t attr = void;

            !pthread_mutexattr_init(&attr) ||
                abort("Error: pthread_mutexattr_init failed.");

            scope (exit) !pthread_mutexattr_destroy(&attr) ||
                abort("Error: pthread_mutexattr_destroy failed.");

            !pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE) ||
                abort("Error: pthread_mutexattr_settype failed.");

            !pthread_mutex_init(cast(pthread_mutex_t*) &m_hndl, &attr) ||
                abort("Error: pthread_mutex_init failed.");
        }

        m_proxy.link = this;
        this.__monitor = cast(void*) &m_proxy;
    }


    /**
     * Initializes a mutex object and sets it as the monitor for `obj`.
     *
     * In:
     *  `obj` must not already have a monitor.
     */
    this(Object obj) @trusted nothrow @nogc
    {
        this(obj, true);
    }

    /// ditto
    this(Object obj) shared @trusted nothrow @nogc
    {
        this(obj, true);
    }

    // Undocumented, useful only in Mutex.this(Object).
    private this(this Q)(Object obj, bool _unused_) @trusted nothrow @nogc
        if (is(Q == Mutex) || is(Q == shared Mutex))
    in
    {
        assert(obj !is null,
            "The provided object must not be null.");
        assert(obj.__monitor is null,
            "The provided object has a monitor already set!");
    }
    body
    {
        this();
        obj.__monitor = cast(void*) &m_proxy;
    }


    ~this() @trusted nothrow @nogc
    {
        version (Windows)
        {
            DeleteCriticalSection(&m_hndl);
        }
        else version (Posix)
        {
            import core.internal.abort : abort;
            !pthread_mutex_destroy(&m_hndl) ||
                abort("Error: pthread_mutex_destroy failed.");
        }
        this.__monitor = null;
    }


    ////////////////////////////////////////////////////////////////////////////
    // General Actions
    /////////////////////