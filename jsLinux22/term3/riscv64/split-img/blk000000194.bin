   UINT  LeadingZero;
    UINT  Grouping;
    LPSTR lpDecimalSep;
    LPSTR lpThousandSep;
    UINT  NegativeOrder;
}
alias NUMBERFMTA* LPNUMBERFMTA;

struct NUMBERFMTW {
    UINT   NumDigits;
    UINT   LeadingZero;
    UINT   Grouping;
    LPWSTR lpDecimalSep;
    LPWSTR lpThousandSep;
    UINT   NegativeOrder;
}
alias NUMBERFMTW* LPNUMBERFMTW;

extern (Windows) nothrow @nogc {
    int CompareStringA(LCID, DWORD, LPCSTR, int, LPCSTR, int);
    int CompareStringW(LCID, DWORD, LPCWSTR, int, LPCWSTR, int);
    LCID ConvertDefaultLocale(LCID);
    BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA, LCID, CALID, CALTYPE);
    BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW, LCID, CALID, CALTYPE);
    BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA, LCID, DWORD);
    BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW, LCID, DWORD);
    BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA, DWORD);
    BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW, DWORD);
    BOOL EnumSystemGeoID(GEOCLASS, GEOID, GEO_ENUMPROC);
    BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA, DWORD);
    BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW, DWORD);
    BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA, LCID, DWORD);
    BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW, LCID, DWORD);
    int FoldStringA(DWORD, LPCSTR, int, LPSTR, int);
    int FoldStringW(DWORD, LPCWSTR, int, LPWSTR, int);
    UINT GetACP();
    int GetCalendarInfoA(LCID, CALID, CALTYPE, LPSTR, int, LPDWORD);
    int GetCalendarInfoW(LCID, CALID, CALTYPE, LPWSTR, int, LPDWORD);
    BOOL GetCPInfo(UINT, LPCPINFO);
    BOOL GetCPInfoExA(UINT, DWORD, LPCPINFOEXA);
    BOOL GetCPInfoExW(UINT, DWORD, LPCPINFOEXW);
    int GetCurrencyFormatA(LCID, DWORD, LPCSTR,  const(CURRENCYFMTA)*, LPSTR, int);
    int GetCurrencyFormatW(LCID, DWORD, LPCWSTR,  const(CURRENCYFMTW)*, LPWSTR,
      int);
    int GetDateFormatA(LCID, DWORD,  const(SYSTEMTIME)*, LPCSTR, LPSTR, int);
    int GetDateFormatW(LCID, DWORD,  const(SYSTEMTIME)*, LPCWSTR, LPWSTR, int);
    int GetGeoInfoA(GEOID, GEOTYPE, LPSTR, int, LANGID);
    int GetGeoInfoW(GEOID, GEOTYPE, LPWSTR, int, LANGID);
    int GetLocaleInfoA(LCID, LCTYPE, LPSTR, int);
    int GetLocaleInfoW(LCID, LCTYPE, LPWSTR, int);
    BOOL GetNLSVersion(NLS_FUNCTION, LCID, LPNLSVERSIONINFO);
    int GetNumberFormatA(LCID, DWORD, LPCSTR,  const(NUMBERFMTA)*, LPSTR, int);
    int GetNumberFormatW(LCID, DWORD, LPCWSTR,  const(NUMBERFMTW)*, LPWSTR, int);
    UINT GetOEMCP();
    BOOL GetStringTypeA(LCID, DWORD, LPCSTR, int, LPWORD);
    BOOL GetStringTypeW(DWORD, LPCWSTR, int, LPWORD);
    BOOL GetStringTypeExA(LCID, DWORD, LPCSTR, int, LPWORD);
    BOOL GetStringTypeExW(LCID, DWORD, LPCWSTR, int, LPWORD);
    LANGID GetSystemDefaultLangID();
    LCID GetSystemDefaultLCID();
    LCID GetThreadLocale();
    int GetTimeFormatA(LCID, DWORD,  const(SYSTEMTIME)*, LPCSTR, LPSTR, int);
    int GetTimeFormatW(LCID, DWORD,  const(SYSTEMTIME)*, LPCWSTR, LPWSTR, int);
    LANGID GetUserDefaultLangID();
    LCID GetUserDefaultLCID();
    GEOID GetUserGeoID(GEOCLASS);
    BOOL IsDBCSLeadByte(BYTE);
    BOOL IsDBCSLeadByteEx(UINT, BYTE);
    BOOL IsNLSDefinedString(NLS_FUNCTION, DWORD, LPNLSVERSIONINFO, LPCWSTR,
      int);
    BOOL IsValidCodePage(UINT);
    BOOL IsValidLocale(LCID, DWORD);
    int LCMapStringA(LCID, DWORD, LPCSTR, int, LPSTR, int);
    int LCMapStringW(LCID, DWORD, LPCWSTR, int, LPWSTR, int);
    int MultiByteToWideChar(UINT, DWORD, LPCSTR, int, LPWSTR, int);
    int SetCalendarInfoA(LCID, CALID, CALTYPE, LPCSTR);
    int SetCalendarInfoW(LCID, CALID, CALTYPE, LPCWSTR);
    BOOL SetLocaleInfoA(LCID, LCTYPE, LPCSTR);
    BOOL SetLocaleInfoW(LCID, LCTYPE, LPCWSTR);
    BOOL SetThreadLocale(LCID);
    BOOL SetUserGeoID(GEOID);
    int WideCharToMultiByte(UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR,
      LPBOOL);

    static if (_WIN32_WINNT >= 0x410) {
        BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA, LCID, CALID, CALTYPE);
        BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW, LCID, CALID, CALTYPE);
        BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA, LCID, DWORD);
        BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW, LCID, DWORD);
        BOOL IsValidLanguageGroup(LGRPID, DWORD);
    }

    static if (_WIN32_WINNT >= 0x500) {
        LANGID GetSystemDefaultUILanguage();
        LANGID GetUserDefaultUILanguage();

        BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA, DWORD,
          LONG_PTR);
        BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW, DWORD,
          LONG_PTR);
        BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA, LGRPID,
          DWORD, LONG_PTR);
        BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW, LGRPID,
          DWORD, LONG_PTR);
        BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA, DWORD, LONG_PTR);
        BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW, DWORD, LONG_PTR);
    }
}

version (Unicode) {
    alias CALINFO_ENUMPROCW CALINFO_ENUMPROC;
    alias CALINFO_ENUMPROCEXW CALINFO_ENUMPROCEX;
    alias LOCALE_ENUMPROCW LOCALE_ENUMPROC;
    alias CODEPAGE_ENUMPROCW CODEPAGE_ENUMPROC;
    alias DATEFMT_ENUMPROCW DATEFMT_ENUMPROC;
    alias DATEFMT_ENUMPROCEXW DATEFMT_ENUMPROCEX;
    alias TIMEFMT_ENUMPROCW TIMEFMT_ENUMPROC;
    alias LANGUAGEGROUP_ENUMPROCW LANGUAGEGROUP_ENUMPROC;
    alias LANGGROUPLOCALE_ENUMPROCW LANGGROUPLOCALE_ENUMPROC;
    alias UILANGUAGE_ENUMPROCW UILANGUAGE_ENUMPROC;
    alias CPINFOEXW CPINFOEX;
    alias LPCPINFOEXW LPCPINFOEX;
    alias CURRENCYFMTW CURRENCYFMT;
    alias LPCURRENCYFMTW LPCURRENCYFMT;
    alias NUMBERFMTW NUMBERFMT;
    alias LPNUMBERFMTW LPNUMBERFMT;
    alias CompareStringW CompareString;
    alias EnumCalendarInfoW EnumCalendarInfo;
    alias EnumSystemCodePagesW EnumSystemCodePages;
    alias EnumSystemLocalesW EnumSystemLocales;
    alias EnumTimeFormatsW EnumTimeFormats;
    alias FoldStringW FoldString;
    alias GetCalendarInfoW GetCalendarInfo;
    alias GetCPInfoExW GetCPInfoEx;
    alias GetCurrencyFormatW GetCurrencyFormat;
    alias GetDateFormatW GetDateFormat;
    alias GetGeoInfoW GetGeoInfo;
    alias GetLocaleInfoW GetLocaleInfo;
    alias GetNumberFormatW GetNumberFormat;
    alias GetStringTypeExW GetStringTypeEx;
    alias GetTimeFormatW GetTimeFormat;
    alias LCMapStringW LCMapString;
    alias SetCalendarInfoW SetCalendarInfo;
    alias SetLocaleInfoW SetLocaleInfo;

    static if (_WIN32_WINNT >= 0x410) {
        alias EnumCalendarInfoExW EnumCalendarInfoEx;
        alias EnumDateFormatsExW EnumDateFormatsEx;
    }

    static if (_WIN32_WINNT >= 0x500) {
        alias EnumSystemLanguageGroupsW EnumSystemLanguageGroups;
        alias EnumLanguageGroupLocalesW EnumLanguageGroupLocales;
        alias EnumUILanguagesW EnumUILanguages;
    }

} else {
    alias CALINFO_ENUMPROCA CALINFO_ENUMPROC;
    alias CALINFO_ENUMPROCEXA CALINFO_ENUMPROCEX;
    alias LOCALE_ENUMPROCA LOCALE_ENUMPROC;
    alias CODEPAGE_ENUMPROCA CODEPAGE_ENUMPROC;
    alias DATEFMT_ENUMPROCA DATEFMT_ENUMPROC;
    alias DATEFMT_ENUMPROCEXA DATEFMT_ENUMPROCEX;
    alias TIMEFMT_ENUMPROCA TIMEFMT_ENUMPROC;
    alias LANGUAGEGROUP_ENUMPROCA LANGUAGEGROUP_ENUMPROC;
    alias LANGGROUPLOCALE_ENUMPROCA LANGGROUPLOCALE_ENUMPROC;
    alias UILANGUAGE_ENUMPROCA UILANGUAGE_ENUMPROC;
    alias CPINFOEXA CPINFOEX;
    alias LPCPINFOEXA LPCPINFOEX;
    alias CURRENCYFMTA CURRENCYFMT;
    alias LPCURRENCYFMTA LPCURRENCYFMT;
    alias NUMBERFMTA NUMBERFMT;
    alias LPNUMBERFMTA LPNUMBERFMT;
    alias CompareStringA CompareString;
    alias EnumCalendarInfoA EnumCalendarInfo;
    alias EnumSystemCodePagesA EnumSystemCodePages;
    alias EnumSystemLocalesA EnumSystemLocales;
    alias EnumTimeFormatsA EnumTimeFormats;
    alias FoldStringA FoldString;
    alias GetCalendarInfoA GetCalendarInfo;
    alias GetCPInfoExA GetCPInfoEx;
    alias GetCurrencyFormatA GetCurrencyFormat;
    alias GetDateFormatA GetDateFormat;
    alias GetGeoInfoA GetGeoInfo;
    alias GetLocaleInfoA GetLocaleInfo;
    alias GetNumberFormatA GetNumberFormat;
    alias GetStringTypeExA GetStringTypeEx;
    alias GetTimeFormatA GetTimeFormat;
    alias LCMapStringA LCMapString;
    alias SetCalendarInfoA SetCalendarInfo;
    alias SetLocaleInfoA SetLocaleInfo;

    static if (_WIN32_WINNT >= 0x410) {
        alias EnumCalendarInfoExA EnumCalendarInfoEx;
        alias EnumDateFormatsExA EnumDateFormatsEx;
    }

    static if (_WIN32_WINNT >= 0x500) {
        alias EnumSystemLanguageGroupsA EnumSystemLanguageGroups;
        alias EnumLanguageGroupLocalesA EnumLanguageGroupLocales;
        alias EnumUILanguagesA EnumUILanguages;
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * Windows API header module
 *
 * Translated from MinGW API for MS-Windows 3.12
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winnt.d)
 */
module core.sys.windows.winnt;
version (Windows):

version (ANSI) {} else version = Unicode;

public import core.sys.windows.basetsd, core.sys.windows.windef, core.sys.windows.winerror;
private import core.sys.windows.w32api;

/* Translation Notes:
The following macros are unneeded for D:
FIELD_OFFSET(t,f), CONTAINING_RECORD(address, type, field)
*/

alias void   VOID;
alias char   CHAR, CCHAR;
alias wchar  WCHAR;
alias bool   BOOLEAN;
alias byte   FCHAR;
alias ubyte  UCHAR;
alias short  SHORT;
alias ushort LANGID, FSHORT;
alias uint   LCID, FLONG, ACCESS_MASK;
alias long   LONGLONG, USN;
alias ulong  DWORDLONG, ULONGLONG;

alias void*  PVOID, LPVOID;
alias char*  PSZ, PCHAR, PCCHAR, LPCH, PCH, LPSTR, PSTR;
alias wchar* PWCHAR, LPWCH, PWCH, LPWSTR, PWSTR;
alias bool*  PBOOLEAN;
alias ubyte* PUCHAR;
alias short* PSHORT;
alias int*   PLONG;
alias uint*  PLCID, PACCESS_MASK;
alias long*  PLONGLONG;
alias ulong* PDWORDLONG, PULONGLONG;

// FIXME(MinGW) for __WIN64
alias void*  PVOID64;

// const versions
alias const(char)*  PCCH, LPCCH, PCSTR, LPCSTR;
alias const(wchar)* LPCWCH, PCWCH, LPCWSTR, PCWSTR;

version (Unicode) {
    alias WCHAR TCHAR, _TCHAR;
} else {
    alias CHAR TCHAR, _TCHAR;
}

alias TCHAR         TBYTE;
alias TCHAR*        PTCH , PTBYTE, LPTCH , PTSTR , LPTSTR , LP, PTCHAR;
alias const(TCHAR)* PCTCH,         LPCTCH, PCTSTR, LPCTSTR            ;

enum char ANSI_NULL = '\0';
enum wchar UNICODE_NULL = '\0';

enum APPLICATION_ERROR_MASK       = 0x20000000;
enum ERROR_SEVERITY_SUCCESS       = 0x00000000;
enum ERROR_SEVERITY_INFORMATIONAL = 0x40000000;
enum ERROR_SEVERITY_WARNING       = 0x80000000;
enum ERROR_SEVERITY_ERROR         = 0xC0000000;

// MinGW: also in ddk/ntifs.h
enum : USHORT {
    COMPRESSION_FORMAT_NONE     = 0x0000,
    COMPRESSION_FORMAT_DEFAULT  = 0x0001,
    COMPRESSION_FORMAT_LZNT1    = 0x0002,
    COMPRESSION_ENGINE_STANDARD = 0x0000,
    COMPRESSION_ENGINE_MAXIMUM  = 0x0100,
    COMPRESSION_ENGINE_HIBER    = 0x0200
}

// ACCESS_DENIED_OBJECT_ACE, etc
enum DWORD
    ACE_OBJECT_TYPE_PRESENT           = 0x00000001,
    ACE_INHERITED_OBJECT_TYPE_PRESENT = 0x00000002;

// ACE_HEADER.AceType
// also in ddk/ntifs.h
enum : BYTE {
    ACCESS_ALLOWED_ACE_TYPE,
    ACCESS_DENIED_ACE_TYPE,
    SYSTEM_AUDIT_ACE_TYPE,
    SYSTEM_ALARM_ACE_TYPE
}

// ACE_HEADER.AceFlags
enum BYTE
    OBJECT_INHERIT_ACE         = 0x01,
    CONTAINER_INHERIT_ACE      = 0x02,
    NO_PROPAGATE_INHERIT_ACE   = 0x04,
    INHERIT_ONLY_ACE           = 0x08,
    INHERITED_ACE              = 0x10,
    VALID_INHERIT_FLAGS        = 0x1F,
    SUCCESSFUL_ACCESS_ACE_FLAG = 0x40,
    FAILED_ACCESS_ACE_FLAG     = 0x80;

// Access Mask Format
enum ACCESS_MASK
    DELETE                   = 0x00010000,
    READ_CONTROL             = 0x00020000,
    WRITE_DAC                = 0x00040000,
    WRITE_OWNER              = 0x00080000,
    SYNCHRONIZE              = 0x00100000,
    ACCESS_SYSTEM_SECURITY   = 0x01000000,
    MAXIMUM_ALLOWED          = 0x02000000,
    GENERIC_READ             = 0x80000000,
    GENERIC_WRITE            = 0x40000000,
    GENERIC_EXECUTE          = 0x20000000,
    GENERIC_ALL              = 0x10000000,
    STANDARD_RIGHTS_REQUIRED = 0x000F0000,
    STANDARD_RIGHTS_READ     = 0x00020000,
    STANDARD_RIGHTS_WRITE    = 0x00020000,
    STANDARD_RIGHTS_EXECUTE  = 0x00020000,
    STANDARD_RIGHTS_ALL      = 0x001F0000,
    SPECIFIC_RIGHTS_ALL      = 0x0000FFFF;


enum DWORD INVALID_FILE_ATTRIBUTES = -1;

// MinGW: Also in ddk/winddk.h
enum DWORD
    FILE_LIST_DIRECTORY       = 0x00000001,
    FILE_READ_DATA            = 0x00000001,
    FILE_ADD_FILE             = 0x00000002,
    FILE_WRITE_DATA           = 0x00000002,
    FILE_ADD_SUBDIRECTORY     = 0x00000004,
    FILE_APPEND_DATA          = 0x00000004,
    FILE_CREATE_PIPE_INSTANCE = 0x00000004,
    FILE_READ_EA              = 0x00000008,
    FILE_READ_PROPERTIES      = 0x00000008,
    FILE_WRITE_EA             = 0x00000010,
    FILE_WRITE_PROPERTIES     = 0x00000010,
    FILE_EXECUTE              = 0x00000020,
    FILE_TRAVERSE             = 0x00000020,
    FILE_DELETE_CHILD         = 0x00000040,
    FILE_READ_ATTRIBUTES      = 0x00000080,
    FILE_WRITE_ATTRIBUTES     = 0x00000100;

enum DWORD
    FILE_SHARE_READ        = 0x00000001,
    FILE_SHARE_WRITE       = 0x00000002,
    FILE_SHARE_DELETE      = 0x00000004,
    FILE_SHARE_VALID_FLAGS = 0x00000007;

enum DWORD
    FILE_ATTRIBUTE_READONLY            = 0x00000001,
    FILE_ATTRIBUTE_HIDDEN              = 0x00000002,
    FILE_ATTRIBUTE_SYSTEM              = 0x00000004,
    FILE_ATTRIBUTE_DIRECTORY           = 0x00000010,
    FILE_ATTRIBUTE_ARCHIVE             = 0x00000020,
    FILE_ATTRIBUTE_DEVICE              = 0x00000040,
    FILE_ATTRIBUTE_NORMAL              = 0x00000080,
    FILE_ATTRIBUTE_TEMPORARY           = 0x00000100,
    FILE_ATTRIBUTE_SPARSE_FILE         = 0x00000200,
    FILE_ATTRIBUTE_REPARSE_POINT       = 0x00000400,
    FILE_ATTRIBUTE_COMPRESSED          = 0x00000800,
    FILE_ATTRIBUTE_OFFLINE             = 0x00001000,
    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000,
    FILE_ATTRIBUTE_ENCRYPTED           = 0x00004000,
    FILE_ATTRIBUTE_VALID_FLAGS         = 0x00007fb7,
    FILE_ATTRIBUTE_VALID_SET_FLAGS     = 0x000031a7;

// These are not documented on MSDN
enum FILE_COPY_STRUCTURED_STORAGE = 0x00000041;
enum FILE_STRUCTURED_STORAGE      = 0x00000441;

// Nor are these
enum FILE_VALID_OPTION_FLAGS          = 0x00ffffff;
enum FILE_VALID_PIPE_OPTION_FLAGS     = 0x00000032;
enum FILE_VALID_MAILSLOT_OPTION_FLAGS = 0x00000032;
enum FILE_VALID_SET_FLAGS             = 0x00000036;

enum ULONG
    FILE_SUPERSEDE           = 0x00000000,
    FILE_OPEN                = 0x00000001,
    FILE_CREATE              = 0x00000002,
    FILE_OPEN_IF             = 0x00000003,
    FILE_OVERWRITE           = 0x00000004,
    FILE_OVERWRITE_IF        = 0x00000005,
    FILE_MAXIMUM_DISPOSITION = 0x00000005;

enum ULONG
    FILE_DIRECTORY_FILE            = 0x00000001,
    FILE_WRITE_THROUGH             = 0x00000002,
    FILE_SEQUENTIAL_ONLY           = 0x00000004,
    FILE_NO_INTERMEDIATE_BUFFERING = 0x00000008,
    FILE_SYNCHRONOUS_IO_ALERT      = 0x00000010,
    FILE_SYNCHRONOUS_IO_NONALERT   = 0x00000020,
    FILE_NON_DIRECTORY_FILE        = 0x00000040,
    FILE_CREATE_TREE_CONNECTION    = 0x00000080,
    FILE_COMPLETE_IF_OPLOCKED      = 0x00000100,
    FILE_NO_EA_KNOWLEDGE           = 0x00000200,
    FILE_OPEN_FOR_RECOVERY         = 0x00000400,
    FILE_RANDOM_ACCESS             = 0x00000800,
    FILE_DELETE_ON_CLOSE           = 0x00001000,
    FILE_OPEN_BY_FILE_ID           = 0x00002000,
    FILE_OPEN_FOR_BACKUP_INTENT    = 0x00004000,
    FILE_NO_COMPRESSION            = 0x00008000,
    FILE_RESERVE_OPFILTER          = 0x00100000,
    FILE_OPEN_REPARSE_POINT        = 0x00200000,
    FILE_OPEN_NO_RECALL            = 0x00400000,
    FILE_OPEN_FOR_FREE_SPACE_QUERY = 0x00800000;


enum ACCESS_MASK
    FILE_ALL_ACCESS      = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x01FF,
    FILE_GENERIC_EXECUTE = STANDARD_RIGHTS_EXECUTE | FILE_READ_ATTRIBUTES
                           | FILE_EXECUTE | SYNCHRONIZE,
    FILE_GENERIC_READ    = STANDARD_RIGHTS_READ | FILE_READ_DATA
                           | FILE_READ_ATTRIBUTES | FILE_READ_EA | SYNCHRONIZE,
    FILE_GENERIC_WRITE   = STANDARD_RIGHTS_WRITE | FILE_WRITE_DATA
                           | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA | FILE_APPEND_DATA
                           | SYNCHRONIZE;

// MinGW: end winddk.h
// MinGW: also in ddk/ntifs.h
enum DWORD
    FILE_NOTIFY_CHANGE_FILE_NAME    = 0x00000001,
    FILE_NOTIFY_CHANGE_DIR_NAME     = 0x00000002,
    FILE_NOTIFY_CHANGE_NAME         = 0x00000003,
    FILE_NOTIFY_CHANGE_ATTRIBUTES   = 0x00000004,
    FILE_NOTIFY_CHANGE_SIZE         = 0x00000008,
    FILE_NOTIFY_CHANGE_LAST_WRITE   = 0x00000010,
    FILE_NOTIFY_CHANGE_LAST_ACCESS  = 0x00000020,
    FILE_NOTIFY_CHANGE_CREATION     = 0x00000040,
    FILE_NOTIFY_CHANGE_EA           = 0x00000080,
    FILE_NOTIFY_CHANGE_SECURITY     = 0x00000100,
    FILE_NOTIFY_CHANGE_STREAM_NAME  = 0x00000200,
    FILE_NOTIFY_CHANGE_STREAM_SIZE  = 0x00000400,
    FILE_NOTIFY_CHANGE_STREAM_WRITE = 0x00000800,
    FILE_NOTIFY_VALID_MASK          = 0x00000fff;

enum DWORD
    FILE_CASE_SENSITIVE_SEARCH      = 0x00000001,
    FILE_CASE_PRESERVED_NAMES       = 0x00000002,
    FILE_UNICODE_ON_DISK            = 0x00000004,
    FILE_PERSISTENT_ACLS            = 0x00000008,
    FILE_FILE_COMPRESSION           = 0x00000010,
    FILE_VOLUME_QUOTAS              = 0x00000020,
    FILE_SUPPORTS_SPARSE_FILES      = 0x00000040,
    FILE_SUPPORTS_REPARSE_POINTS    = 0x00000080,
    FILE_SUPPORTS_REMOTE_STORAGE    = 0x00000100,
    FS_LFN_APIS                     = 0x00004000,
    FILE_VOLUME_IS_COMPRESSED       = 0x00008000,
    FILE_SUPPORTS_OBJECT_IDS        = 0x00010000,
    FILE_SUPPORTS_ENCRYPTION        = 0x00020000,
    FILE_NAMED_STREAMS              = 0x00040000,
    FILE_READ_ONLY_VOLUME           = 0x00080000,
    FILE_SEQUENTIAL_WRITE_ONCE      = 0x00100000,
    FILE_SUPPORTS_TRANSACTIONS      = 0x00200000;

// These are not documented on MSDN
enum ACCESS_MASK
    IO_COMPLETION_QUERY_STATE  = 1,
    IO_COMPLETION_MODIFY_STATE = 2,
    IO_COMPLETION_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 3;
// MinGW: end ntifs.h

// MinGW: also in ddk/winddk.h
enum DWORD
    DUPLICATE_CLOSE_SOURCE    = 1,
    DUPLICATE_SAME_ACCESS     = 2,
    DUPLICATE_SAME_ATTRIBUTES = 4;
// MinGW: end winddk.k

enum DWORD
    MAILSLOT_NO_MESSAGE   = -1,
    MAILSLOT_WAIT_FOREVER = -1;

enum ACCESS_MASK
    PROCESS_TERMINATE         = 0x0001,
    PROCESS_CREATE_THREAD     = 0x0002,
    PROCESS_SET_SESSIONID     = 0x0004,
    PROCESS_VM_OPERATION      = 0x0008,
    PROCESS_VM_READ           = 0x0010,
    PROCESS_VM_WRITE          = 0x0020,
    PROCESS_DUP_HANDLE        = 0x0040,
    PROCESS_CREATE_PROCESS    = 0x0080,
    PROCESS_SET_QUOTA         = 0x0100,
    PROCESS_SET_INFORMATION   = 0x0200,
    PROCESS_QUERY_INFORMATION = 0x0400,
    PROCESS_ALL_ACCESS        = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x0FFF;

enum ACCESS_MASK
    THREAD_TERMINATE            = 0x0001,
    THREAD_SUSPEND_RESUME       = 0x0002,
    THREAD_GET_CONTEXT          = 0x0008,
    THREAD_SET_CONTEXT          = 0x0010,
    THREAD_SET_INFORMATION      = 0x0020,
    THREAD_QUERY_INFORMATION    = 0x0040,
    THREAD_SET_THREAD_TOKEN     = 0x0080,
    THREAD_IMPERSONATE          = 0x0100,
    THREAD_DIRECT_IMPERSONATION = 0x0200,
    THREAD_ALL_ACCESS           = STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3FF;

// These are not documented on MSDN
enum THREAD_BASE_PRIORITY_LOWRT =  15;
enum THREAD_BASE_PRIORITY_MAX   =   2;
enum THREAD_BASE_PRIORITY_MIN   =  -2;
enum THREAD_BASE_PRIORITY_IDLE  = -15;

enum DWORD EXCEPTION_NONCONTINUABLE      =  1;
enum size_t EXCEPTION_MAXIMUM_PARAMETERS = 15;

// These are not documented on MSDN
enum ACCESS_MASK
    MUTANT_QUERY_STATE = 1,
    MUTANT_ALL_ACCESS =  STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | MUTANT_QUERY_STATE;

enum ACCESS_MASK
    TIMER_QUERY_STATE  = 1,
    TIMER_MODIFY_STATE = 2,
    TIMER_ALL_ACCESS   = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | TIMER_QUERY_STATE
                         | TIMER_MODIFY_STATE;

enum SID_IDENTIFIER_AUTHORITY
    SECURITY_NULL_SID_AUTHORITY        = {[5: 0]},
    SECURITY_WORLD_SID_AUTHORITY       = {[5: 1]},
    SECURITY_LOCAL_SID_AUTHORITY       = {[5: 2]},
    SECURITY_CREATOR_SID_AUTHORITY     = {[5: 3]},
    SECURITY_NON_UNIQUE_AUTHORITY      = {[5: 4]},
    SECURITY_NT_AUTHORITY              = {[5: 5]},
    SECURITY_MANDATORY_LABEL_AUTHORITY = {[5: 6]};

enum DWORD
    SECURITY_NULL_RID                   =  0,
    SECURITY_WORLD_RID                  =  0,
    SECURITY_LOCAL_RID                  =  0,
    SECURITY_CREATOR_OWNER_RID          =  0,
    SECURITY_CREATOR_GROUP_RID          =  1,
    SECURITY_DIALUP_RID                 =  1,
    SECURITY_NETWORK_RID                =  2,
    SECURITY_BATCH_RID                  =  3,
    SECURITY_INTERACTIVE_RID            =  4,
    SECURITY_LOGON_IDS_RID              =  5,
    SECURITY_SERVICE_RID                =  6,
    SECURITY_LOCAL_SYSTEM_RID           = 18,
    SECURITY_BUILTIN_DOMAIN_RID         = 32,
    SECURITY_PRINCIPAL_SELF_RID         = 10,
    SECURITY_CREATOR_OWNER_SERVER_RID   =  2,
    SECURITY_CREATOR_GROUP_SERVER_RID   =  3,
    SECURITY_LOGON_IDS_RID_COUNT        =  3,
    SECURITY_ANONYMOUS_LOGON_RID        =  7,
    SECURITY_PROXY_RID                  =  8,
    SECURITY_ENTERPRISE_CONTROLLERS_RID =  9,
    SECURITY_SERVER_LOGON_RID           = SECURITY_ENTERPRISE_CONTROLLERS_RID,
    SECURITY_AUTHENTICATED_USER_RID     = 11,
    SECURITY_RESTRICTED_CODE_RID        = 12,
    SECURITY_NT_NON_UNIQUE_RID          = 21,
    SID_REVISION                        =  1;

enum : DWORD {
    DOMAIN_USER_RID_ADMIN        = 0x01F4,
    DOMAIN_USER_RID_GUEST        = 0x01F5,
    DOMAIN_GROUP_RID_ADMINS      = 0x0200,
    DOMAIN_GROUP_RID_USERS       = 0x0201,
    DOMAIN_ALIAS_RID_ADMINS      = 0x0220,
    DOMAIN_ALIAS_RID_USERS       = 0x0221,
    DOMAIN_ALIAS_RID_GUESTS      = 0x0222,
    DOMAIN_ALIAS_RID_POWER_USERS = 0x0223,
    DOMAIN_ALIAS_RID_ACCOUNT_OPS = 0x0224,
    DOMAIN_ALIAS_RID_SYSTEM_OPS  = 0x0225,
    DOMAIN_ALIAS_RID_PRINT_OPS   = 0x0226,
    DOMAIN_ALIAS_RID_BACKUP_OPS  = 0x0227,
    DOMAIN_ALIAS_RID_REPLICATOR  = 0x0228
}

enum : WORD {
    SECURITY_MANDATORY_UNTRUSTED_RID         = 0,
    SECURITY_MANDATORY_LOW_RID               = 0x1000,
    SECURITY_MANDATORY_MEDIUM_RID            = 0x2000,
    SECURITY_MANDATORY_HIGH_RID              = 0x3000,
    SECURITY_MANDATORY_SYSTEM_RID            = 0x4000,
    SECURITY_MANDATORY_PROTECTED_PROCESS_RID = 0x5000,
    SECURITY_MANDATORY_MAXIMUM_USER_RID      = SECURITY_MANDATORY_SYSTEM_RID
}

const TCHAR[]
    SE_CREATE_TOKEN_NAME           = "SeCreateTokenPrivilege",
    SE_ASSIGNPRIMARYTOKEN_NAME     = "SeAssignPrimaryTokenPrivilege",
    SE_LOCK_MEMORY_NAME            = "SeLockMemoryPrivilege",
    SE_INCREASE_QUOTA_NAME         = "SeIncreaseQuotaPrivilege",
    SE_UNSOLICITED_INPUT_NAME      = "SeUnsolicitedInputPrivilege",
    SE_MACHINE_ACCOUNT_NAME        = "SeMachineAccountPrivilege",
    SE_TCB_NAME                    = "SeTcbPrivilege",
    SE_SECURITY_NAME               = "SeSecurityPrivilege",
    SE_TAKE_OWNERSHIP_NAME         = "SeTakeOwnershipPrivilege",
    SE_LOAD_DRIVER_NAME            = "SeLoadDriverPrivilege",
    SE_SYSTEM_PROFILE_NAME         = "SeSystemProfilePrivilege",
    SE_SYSTEMTIME_NAME             = "SeSystemtimePrivilege",
    SE_PROF_SINGLE_PROCESS_NAME    = "SeProfileSingleProcessPrivilege",
    SE_INC_BASE_PRIORITY_NAME      = "SeIncreaseBasePriorityPrivilege",
    SE_CREATE_PAGEFILE_NAME        = "SeCreatePagefilePrivilege",
    SE_CREATE_PERMANENT_NAME       = "SeCreatePermanentPrivilege",
    SE_BACKUP_NAME                 = "SeBackupPrivilege",
    SE_RESTORE_NAME                = "SeRestorePrivilege",
    SE_SHUTDOWN_NAME               = "SeShutdownPrivilege",
    SE_DEBUG_NAME                  = "SeDebugPrivilege",
    SE_AUDIT_NAME                  = "SeAuditPrivilege",
    SE_SYSTEM_ENVIRONMENT_NAME     = "SeSystemEnvironmentPrivilege",
    SE_CHANGE_NOTIFY_NAME          = "SeChangeNotifyPrivilege",
    SE_REMOTE_SHUTDOWN_NAME        = "SeRemoteShutdownPrivilege",
    SE_CREATE_GLOBAL_NAME          = "SeCreateGlobalPrivilege",
    SE_UNDOCK_NAME                 = "SeUndockPrivilege",
    SE_MANAGE_VOLUME_NAME          = "SeManageVolumePrivilege",
    SE_IMPERSONATE_NAME            = "SeImpersonatePrivilege",
    SE_ENABLE_DELEGATION_NAME      = "SeEnableDelegationPrivilege",
    SE_SYNC_AGENT_NAME             = "SeSyncAgentPrivilege",
    SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege",
    SE_RELABEL_NAME                = "SeRelabelPrivilege",
    SE_INCREASE_WORKING_SET_NAME   = "SeIncreaseWorkingSetPrivilege",
    SE_TIME_ZONE_NAME              = "SeTimeZonePrivilege",
    SE_CREATE_SYMBOLIC_LINK_NAME   = "SeCreateSymbolicLinkPrivilege";

enum DWORD
    SE_GROUP_MANDATORY          = 0x00000001,
    SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002,
    SE_GROUP_ENABLED            = 0x00000004,
    SE_GROUP_OWNER              = 0x00000008,
    SE_GROUP_USE_FOR_DENY_ONLY  = 0x00000010,
    SE_GROUP_INTEGRITY          = 0x00000020,
    SE_GROUP_INTEGRITY_ENABLED  = 0x00000040,
    SE_GROUP_RESOURCE           = 0x20000000,
    SE_GROUP_LOGON_ID           = 0xC0000000;

// Primary language identifiers
enum : USHORT {
    LANG_NEUTRAL,
    LANG_ARABIC,
    LANG_BULGARIAN,
    LANG_CATALAN,
    LANG_CHINESE,
    LANG_CZECH,
    LANG_DANISH,
    LANG_GERMAN,
    LANG_GREEK,
    LANG_ENGLISH,
    LANG_SPANISH,
    LANG_FINNISH,
    LANG_FRENCH,
    LANG_HEBREW,
    LANG_HUNGARIAN,
    LANG_ICELANDIC,
    LANG_ITALIAN,
    LANG_JAPANESE,
    LANG_KOREAN,
    LANG_DUTCH,
    LANG_NORWEGIAN,
    LANG_POLISH,
    LANG_PORTUGUESE,    // = 0x16
    LANG_ROMANIAN          = 0x18,
    LANG_RUSSIAN,
    LANG_CROATIAN,      // = 0x1A
    LANG_SERBIAN           = 0x1A,
    LANG_BOSNIAN           = 0x1A,
    LANG_SLOVAK,
    LANG_ALBANIAN,
    LANG_SWEDISH,
    LANG_THAI,
    LANG_TURKISH,
    LANG_URDU,
    LANG_INDONESIAN,
    LANG_UKRAINIAN,
    LANG_BELARUSIAN,
    LANG_SLOVENIAN,
    LANG_ESTONIAN,
    LANG_LATVIAN,
    LANG_LITHUANIAN,    // = 0x27
    LANG_FARSI             = 0x29,
    LANG_PERSIAN           = 0x29,
    LANG_VIETNAMESE,
    LANG_ARMENIAN,
    LANG_AZERI,
    LANG_BASQUE,
    LANG_LOWER_SORBIAN, // = 0x2E
    LANG_UPPER_SORBIAN     = 0x2E,
    LANG_MACEDONIAN,    // = 0x2F
    LANG_TSWANA            = 0x32,
    LANG_XHOSA             = 0x34,
    LANG_ZULU,
    LANG_AFRIKAANS,
    LANG_GEORGIAN,
    LANG_FAEROESE,
    LANG_HINDI,
    LANG_MALTESE,
    LANG_SAMI,
    LANG_IRISH,         // = 0x3C
    LANG_MALAY             = 0x3E,
    LANG_KAZAK,
    LANG_KYRGYZ,
    LANG_SWAHILI,       // = 0x41
    LANG_UZBEK             = 0x43,
    LANG_TATAR,
    LANG_BENGALI,
    LANG_PUNJABI,
    LANG_GUJARATI,
    LANG_ORIYA,
    LANG_TAMIL,
    LANG_TELUGU,
    LANG_KANNADA,
    LANG_MALAYALAM,
    LANG_ASSAMESE,
    LANG_MARATHI,
    LANG_SANSKRIT,
    LANG_MONGOLIAN,
    LANG_TIBETAN,
    LANG_WELSH,
    LANG_KHMER,
    LANG_LAO,           // = 0x54
    LANG_GALICIAN          = 0x56,
    LANG_KONKANI,
    LANG_MANIPURI,
    LANG_SINDHI,
    LANG_SYRIAC,
    LANG_SINHALESE,     // = 0x5B
    LANG_INUKTITUT         = 0x5D,
    LANG_AMHARIC,
    LANG_TAMAZIGHT,
    LANG_KASHMIRI,
    LANG_NEPALI,
    LANG_FRISIAN,
    LANG_PASHTO,
    LANG_FILIPINO,
    LANG_DIVEHI,        // = 0x65
    LANG_HAUSA             = 0x68,
    LANG_YORUBA            = 0x6A,
    LANG_QUECHUA,
    LANG_SOTHO,
    LANG_BASHKIR,
    LANG_LUXEMBOURGISH,
    LANG_GREENLANDIC,
    LANG_IGBO,          // = 0x70
    LANG_TIGRIGNA          = 0x73,
    LANG_YI                = 0x78,
    LANG_MAPUDUNGUN        = 0x7A,
    LANG_MOHAWK            = 0x7C,
    LANG_BRETON            = 0x7E,
    LANG_UIGHUR            = 0x80,
    LANG_MAORI,
    LANG_OCCITAN,
    LANG_CORSICAN,
    LANG_ALSATIAN,
    LANG_YAKUT,
    LANG_KICHE,
    LANG_KINYARWANDA,
    LANG_WOLOF,         // = 0x88
    LANG_DARI              = 0x8C,
    LANG_MALAGASY,      // = 0x8D

    LANG_SERBIAN_NEUTRAL   = 0x7C1A,
    LANG_BOSNIAN_NEUTRAL   = 0x781A,

    LANG_INVARIANT         = 0x7F
}


// Sublanguage identifiers
enum : USHORT {
    SUBLANG_NEUTRAL,
    SUBLANG_DEFAULT,
    SUBLANG_SYS_DEFAULT,
    SUBLANG_CUSTOM_DEFAULT,                  // =  3
    SUBLANG_UI_CUSTOM_DEFAULT                   =  3,
    SUBLANG_CUSTOM_UNSPECIFIED,              // =  4

    SUBLANG_AFRIKAANS_SOUTH_AFRICA              =  1,
    SUBLANG_ALBANIAN_ALBANIA                    =  1,
    SUBLANG_ALSATIAN_FRANCE                     =  1,
    SUBLANG_AMHARIC_ETHIOPIA                    =  1,

    SUBLANG_ARABIC_SAUDI_ARABIA                 =  1,
    SUBLANG_ARABIC_IRAQ,
    SUBLANG_ARABIC_EGYPT,
    SUBLANG_ARABIC_LIBYA,
    SUBLANG_ARABIC_ALGERIA,
    SUBLANG_ARABIC_MOROCCO,
    SUBLANG_ARABIC_TUNISIA,
    SUBLANG_ARABIC_OMAN,
    SUBLANG_ARABIC_YEMEN,
    SUBLANG_ARABIC_SYRIA,
    SUBLANG_ARABIC_JORDAN,
    SUBLANG_ARABIC_LEBANON,
    SUBLANG_ARABIC_KUWAIT,
    SUBLANG_ARABIC_UAE,
    SUBLANG_ARABIC_BAHRAIN,
    SUBLANG_ARABIC_QATAR,                    // = 16

    SUBLANG_ARMENIAN_ARMENIA                    =  1,
    SUBLANG_ASSAMESE_INDIA                      =  1,

    SUBLANG_AZERI_LATIN                         =  1,
    SUBLANG_AZERI_CYRILLIC,                  // =  2

    SUBLANG_BASHKIR_RUSSIA                      =  1,
    SUBLANG_BASQUE_BASQUE                       =  1,
    SUBLANG_BELARUSIAN_BELARUS                  =  1,
    SUBLANG_BENGALI_INDIA                       =  1,

    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN    =  5,
    SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC =  8,

    SUBLANG_BRETON_FRANCE                       =  1,
    SUBLANG_BULGARIAN_BULGARIA                  =  1,
    SUBLANG_CATALAN_CATALAN                     =  1,

    SUBLANG_CHINESE_TRADITIONAL                 =  1,
    SUBLANG_CHINESE_SIMPLIFIED,
    SUBLANG_CHINESE_HONGKONG,
    SUBLANG_CHINESE_SINGAPORE,
    SUBLANG_CHINESE_MACAU,                   // =  5

    SUBLANG_CORSICAN_FRANCE                     =  1,

    SUBLANG_CROATIAN_CROATIA                    =  1,
    SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN   =  4,

    SUBLANG_CZECH_CZECH_REPUBLIC                =  1,
    SUBLANG_DANISH_DENMARK                      =  1,
    SUBLANG_DIVEHI_MALDIVES                     =  1,

    SUBLANG_DUTCH                               =  1,
    SUBLANG_DUTCH_BELGIAN,                   // =  2

    SUBLANG_ENGLISH_US                          =  1,
    SUBLANG_ENGLISH_UK,
    SUBLANG_ENGLISH_AUS,
    SUBLANG_ENGLISH_CAN,
    SUBLANG_ENGLISH_NZ,
    SUBLANG_ENGLISH_EIRE,                    // =  6
    SUBLANG_ENGLISH_IRELAND                     =  6,
    SUBLANG_ENGLISH_SOUTH_AFRICA,
    SUBLANG_ENGLISH_JAMAICA,
    SUBLANG_ENGLISH_CARIBBEAN,
    SUBLANG_ENGLISH_BELIZE,
    SUBLANG_ENGLISH_TRINIDAD,
    SUBLANG_ENGLISH_ZIMBABWE,
    SUBLANG_ENGLISH_PHILIPPINES,             // = 13
    SUBLANG_ENGLISH_INDIA                       = 16,
    SUBLANG_ENGLISH_MALAYSIA,
    SUBLANG_ENGLISH_SINGAPORE,               // = 18

    SUBLANG_ESTONIAN_ESTONIA                    =  1,
    SUBLANG_FAEROESE_FAROE_ISLANDS              =  1,
    SUBLANG_FILIPINO_PHILIPPINES                =  1,
    SUBLANG_FINNISH_FINLAND                     =  1,

    SUBLANG_FRENCH                              =  1,
    SUBLANG_FRENCH_BELGIAN,
    SUBLANG_FRENCH_CANADIAN,
    SUBLANG_FRENCH_SWISS,
    SUBLANG_FRENCH_LUXEMBOURG,
    SUBLANG_FRENCH_MONACO,                   // =  6

    SUBLANG_FRISIAN_NETHERLANDS                 =  1,
    SUBLANG_GALICIAN_GALICIAN                   =  1,
    SUBLANG_GEORGIAN_GEORGIA                    =  1,

    SUBLANG_GERMAN                              =  1,
    SUBLANG_GERMAN_SWISS,
    SUBLANG_GERMAN_AUSTRIAN,
    SUBLANG_GERMAN_LUXEMBOURG,
    SUBLANG_GERMAN_LIECHTENSTEIN,            // =  5

    SUBLANG_GREEK_GREECE                        =  1,
    SUBLANG_GREENLANDIC_GREENLAND               =  1,
    SUBLANG_GUJARATI_INDIA                      =  1,
    SUBLANG_HAUSA_NIGERIA                       =  1,
    SUBLANG_HEBREW_ISRAEL                       =  1,
    SUBLANG_HINDI_INDIA                         =  1,
    SUBLANG_HUNGARIAN_HUNGARY                   =  1,
    SUBLANG_ICELANDIC_ICELAND                   =  1,
    SUBLANG_IGBO_NIGERIA                        =  1,
    SUBLANG_INDONESIAN_INDONESIA                =  1,

    SUBLANG_INUKTITUT_CANADA                    =  1,
    SUBLANG_INUKTITUT_CANADA_LATIN              =  1,

    SUBLANG_IRISH_IRELAND                       =  1,

    SUBLANG_ITALIAN                             =  1,
    SUBLANG_ITALIAN_SWISS,                   // =  2

    SUBLANG_JAPANESE_JAPAN                      =  1,

    SUBLANG_KASHMIRI_INDIA                      =  2,
    SUBLANG_KASHMIRI_SASIA                      =  2,

    SUBLANG_KAZAK_KAZAKHSTAN                    =  1,
    SUBLANG_KHMER_CAMBODIA                      =  1,
    SUBLANG_KICHE_GUATEMALA                     =  1,
    SUBLANG_KINYARWANDA_RWANDA                  =  1,
    SUBLANG_KONKANI_INDIA                       =  1,
    SUBLANG_KOREAN                              =  1,
    SUBLANG_KOREAN_JOHAB                        =  2,
    SUBLANG_KYRGYZ_KYRGYZSTAN                   =  1,
    SUBLANG_LAO_LAO_PDR                         =  1,
    SUBLANG_LATVIAN_LATVIA                      =  1,

    SUBLANG_LITHUANIAN                          =  1,
    SUBLANG_LITHUANIAN_LITHUANIA                =  1,

    SUBLANG_LOWER_SORBIAN_GERMANY               =  1,
    SUBLANG_LUXEMBOURGISH_LUXEMBOURG            =  1,
    SUBLANG_MACEDONIAN_MACEDONIA                =  1,
    SUBLANG_MALAYALAM_INDIA                     =  1,
    SUBLANG_MALTESE_MALTA                       =  1,
    SUBLANG_MAORI_NEW_ZEALAND                   =  1,
    SUBLANG_MAPUDUNGUN_CHILE                    =  1,
    SUBLANG_MARATHI_INDIA                       =  1,
    SUBLANG_MOHAWK_MOHAWK                       =  1,

    SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA         =  1,
    SUBLANG_MONGOLIAN_PRC,                   // =  2

    SUBLANG_MALAY_MALAYSIA                      =  1,
    SUBLANG_MALAY_BRUNEI_DARUSSALAM,         // =  2

    SUBLANG_NEPALI_NEPAL                        =  1,
    SUBLANG_NEPALI_INDIA,                    // =  2

    SUBLANG_NORWEGIAN_BOKMAL                    =  1,
    SUBLANG_NORWEGIAN_NYNORSK,               // =  2

    SUBLANG_OCCITAN_FRANCE                      =  1,
    SUBLANG_ORIYA_INDIA                         =  1,
    SUBLANG_PASHTO_AFGHANISTAN                  =  1,
    SUBLANG_PERSIAN_IRAN                        =  1,
    SUBLANG_POLISH_POLAND                       =  1,

    SUBLANG_PORTUGUESE_BRAZILIAN                =  1,
    SUBLANG_PORTUGUESE                          =  2,
    SUBLANG_PORTUGUESE_PORTUGAL,             // =  2

    SUBLANG_PUNJABI_INDIA                       =  1,

    SUBLANG_QUECHUA_BOLIVIA                     =  1,
    SUBLANG_QUECHUA_ECUADOR,
    SUBLANG_QUECHUA_PERU,                    // =  3

    SUBLANG_ROMANIAN_ROMANIA                    =  1,
    SUBLANG_ROMANSH_SWITZERLAND                 =  1,
    SUBLANG_RUSSIAN_RUSSIA                      =  1,

    SUBLANG_SAMI_NORTHERN_NORWAY                =  1,
    SUBLANG_SAMI_NORTHERN_SWEDEN,
    SUBLANG_SAMI_NORTHERN_FINLAND,           // =  3
    SUBLANG_SAMI_SKOLT_FINLAND                  =  3,
    SUBLANG_SAMI_INARI_FINLAND                  =  3,
    SUBLANG_SAMI_LULE_NORWAY,
    SUBLANG_SAMI_LULE_SWEDEN,
    SUBLANG_SAMI_SOUTHERN_NORWAY,
    SUBLANG_SAMI_SOUTHERN_SWEDEN,            // =  7

    SUBLANG_SANSKRIT_INDIA                      =  1,

    SUBLANG_SERBIAN_LATIN                       =  2,
    SUBLANG_SERBIAN_CYRILLIC,                // =  3
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN    =  6,
    SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC =  7,

    SUBLANG_SINDHI_AFGHANISTAN                  =  2,
    SUBLANG_SINHALESE_SRI_LANKA                 =  1,
    SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA         =  1,
    SUBLANG_SLOVAK_SLOVAKIA                     =  1,
    SUBLANG_SLOVENIAN_SLOVENIA                  =  1,

    SUBLANG_SPANISH                             =  1,
    SUBLANG_SPANISH_MEXICAN,
    SUBLANG_SPANISH_MODERN,
    SUBLANG_SPANISH_GUATEMALA,
    SUBLANG_SPANISH_COSTA_RICA,
    SUBLANG_SPANISH_PANAMA,
    SUBLANG_SPANISH_DOMINICAN_REPUBLIC,
    SUBLANG_SPANISH_VENEZUELA,
    SUBLANG_SPANISH_COLOMBIA,
    SUBLANG_SPANISH_PERU,
    SUBLANG_SPANISH_ARGENTINA,
    SUBLANG_SPANISH_ECUADOR,
    SUBLANG_SPANISH_CHILE,
    SUBLANG_SPANISH_URUGUAY,
    SUBLANG_SPANISH_PARAGUAY,
    SUBLANG_SPANISH_BOLIVIA,
    SUBLANG_SPANISH_EL_SALVADOR,
    SUBLANG_SPANISH_HONDURAS,
    SUBLANG_SPANISH_NICARAGUA,
    SUBLANG_SPANISH_PUERTO_RICO,
    SUBLANG_SPANISH_US,                      // = 21

    SUBLANG_SWEDISH                             =  1,
    SUBLANG_SWEDISH_SWEDEN                      =  1,
    SUBLANG_SWEDISH_FINLAND,                 // =  2

    SUBLANG_SYRIAC                              =  1,
    SUBLANG_TAJIK_TAJIKISTAN                    =  1,
    SUBLANG_TAMAZIGHT_ALGERIA_LATIN             =  2,
    SUBLANG_TAMIL_INDIA                         =  1,
    SUBLANG_TATAR_RUSSIA                        =  1,
    SUBLANG_TELUGU_INDIA                        =  1,
    SUBLANG_THAI_THAILAND                       =  1,
    SUBLANG_TIBETAN_PRC                         =  1,
    SUBLANG_TIBETAN_BHUTAN                      =  2,
    SUBLANG_TIGRIGNA_ERITREA                    =  1,
    SUBLANG_TSWANA_SOUTH_AFRICA                 =  1,
    SUBLANG_TURKISH_TURKEY                      =  1,
    SUBLANG_TURKMEN_TURKMENISTAN                =  1,
    SUBLANG_UIGHUR_PRC                          =  1,
    SUBLANG_UKRAINIAN_UKRAINE                   =  1,
    SUBLANG_UPPER_SORBIAN_GERMANY               =  1,

    SUBLANG_URDU_PAKISTAN                       =  1,
    SUBLANG_URDU_INDIA,                      // =  2

    SUBLANG_UZBEK_LATIN                         =  1,
    SUBLANG_UZBEK_CYRILLIC,                  // =  2

    SUBLANG_VIETNAMESE_VIETNAM                  =  1,
    SUBLANG_WELSH_UNITED_KINGDOM                =  1,
    SUBLANG_WOLOF_SENEGAL                       =  1,
    SUBLANG_YORUBA_NIGERIA                      =  1,
    SUBLANG_XHOSA_SOUTH_AFRICA                  =  1,
    SUBLANG_YAKUT_RUSSIA                        =  1,
    SUBLANG_YI_PRC                              =  1,
    SUBLANG_ZULU_SOUTH_AFRICA                   =  1
}

// This is not documented on MSDN
enum NLS_VALID_LOCALE_MASK = 1048575;

// Sorting identifiers
enum : WORD {
    SORT_DEFAULT              = 0,
    SORT_JAPANESE_XJIS        = 0,
    SORT_JAPANESE_UNICODE     = 1,
    SORT_CHINESE_BIG5         = 0,
    SORT_CHINESE_PRCP         = 0,
    SORT_CHINESE_UNICODE      = 1,
    SORT_CHINESE_PRC          = 2,
    SORT_CHINESE_BOPOMOFO     = 3,
    SORT_KOREAN_KSC           = 0,
    SORT_KOREAN_UNICODE       = 1,
    SORT_GERMAN_PHONE_BOOK    = 1,
    SORT_HUNGARIAN_DEFAULT    = 0,
    SORT_HUNGARIAN_TECHNICAL  = 1,
    SORT_GEORGIAN_TRADITIONAL = 0,
    SORT_GEORGIAN_MODERN      = 1
}

pure nothrow @nogc {
    WORD MAKELANGID(/*USHORT*/uint p, /*USHORT*/ uint s) { return cast(WORD)((s << 10) | p); }
    WORD PRIMARYLANGID(/*WORD*/uint lgid) { return cast(WORD)(lgid & 0x3FF); }
    WORD SUBLANGID(/*WORD*/uint lgid) { return cast(WORD)(lgid >>> 10); }

    DWORD MAKELCID(/*WORD*/uint lgid, /*WORD*/uint srtid) { return (cast(DWORD) srtid << 16) | cast(DWORD) lgid; }
    // ???
    //DWORD MAKESORTLCID(WORD lgid, WORD srtid, WORD ver) { return (MAKELCID(lgid, srtid)) | ((cast(DWORD)ver) << 20); }
    WORD LANGIDFROMLCID(LCID lcid) { return cast(WORD) lcid; }
    WORD SORTIDFROMLCID(LCID lcid) { return cast(WORD) ((lcid >>> 16) & 0x0F); }
    WORD SORTVERSIONFROMLCID(LCID lcid) { return cast(WORD) ((lcid >>> 20) & 0x0F); }
}

enum WORD LANG_SYSTEM_DEFAULT = (SUBLANG_SYS_DEFAULT << 10) | LANG_NEUTRAL;
enum WORD LANG_USER_DEFAULT   = (SUBLANG_DEFAULT << 10) | LANG_NEUTRAL;
enum DWORD LOCALE_NEUTRAL     = (SORT_DEFAULT << 16)
                                 | (SUBLANG_NEUTRAL << 10) | LANG_NEUTRAL;

// ---
enum : BYTE {
    ACL_REVISION    = 2,
    ACL_REVISION_DS = 4
}

// These are not documented on MSDN
enum : BYTE {
    ACL_REVISION1    = 1,
    ACL_REVISION2,
    ACL_REVISION3,
    ACL_REVISION4 // = 4
}

enum BYTE
    MIN_ACL_REVISION = 2,
    MAX_ACL_REVISION = 4;

/+
// These aren't necessary for D.
enum MINCHAR=0x80;
enum MAXCHAR=0x7f;
enum MINSHORT=0x8000;
enum MAXSHORT=0x7fff;
enum MINLONG=0x80000000;
enum MAXLONG=0x7fffffff;
enum MAXBYTE=0xff;
enum MAXWORD=0xffff;
enum MAXDWORD=0xffffffff;
+/

// SYSTEM_INFO.dwProcessorType
enum : DWORD {
    PROCESSOR_INTEL_386     =   386,
    PROCESSOR_INTEL_486     =   486,
    PROCESSOR_INTEL_PENTIUM =   586,
    PROCESSOR_MIPS_R4000    =  4000,
    PROCESSOR_ALPHA_21064   = 21064,
    PROCESSOR_INTEL_IA64    =  2200
}

// SYSTEM_INFO.wProcessorArchitecture
enum : WORD {
    PROCESSOR_ARCHITECTURE_INTEL,
    PROCESSOR_ARCHITECTURE_MIPS,
    PROCESSOR_ARCHITECTURE_ALPHA,
    PROCESSOR_ARCHITECTURE_PPC,
    PROCESSOR_ARCHITECTURE_SHX,
    PROCESSOR_ARCHITECTURE_ARM,
    PROCESSOR_ARCHITECTURE_IA64,
    PROCESSOR_ARCHITECTURE_ALPHA64,
    PROCESSOR_ARCHITECTURE_MSIL,
    PROCESSOR_ARCHITECTURE_AMD64,
    PROCESSOR_ARCHITECTURE_IA32_ON_WIN64, // = 10
    PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
}

// IsProcessorFeaturePresent()
enum : DWORD {
    PF_FLOATING_POINT_PRECISION_ERRATA,
    PF_FLOATING_POINT_EMULATED,
    PF_COMPARE_EXCHANGE_DOUBLE,
    PF_MMX_INSTRUCTIONS_AVAILABLE,
    PF_PPC_MOVEMEM_64BIT_OK,
    PF_ALPHA_BYTE_INSTRUCTIONS,
    PF_XMMI_INSTRUCTIONS_AVAILABLE,
    PF_3DNOW_INSTRUCTIONS_AVAILABLE,
    PF_RDTSC_INSTRUCTION_AVAILABLE,
    PF_PAE_ENABLED,
    PF_XMMI64_INSTRUCTIONS_AVAILABLE
}

// MinGW: also in ddk/ntifs.h
enum : DWORD {
    FILE_ACTION_ADDED = 1,
    FILE_ACTION_REMOVED,
    FILE_ACTION_MODIFIED,
    FILE_ACTION_RENAMED_OLD_NAME,
    FILE_ACTION_RENAMED_NEW_NAME,
    FILE_ACTION_ADDED_STREAM,
    FILE_ACTION_REMOVED_STREAM,
    FILE_ACTION_MODIFIED_STREAM,
    FILE_ACTION_REMOVED_BY_DELETE,
    FILE_ACTION_ID_NOT_TUNNELLED,
    FILE_ACTION_TUNNELLED_ID_COLLISION // = 11
}
// MinGW: end ntifs.h

enum DWORD
    HEAP_NO_SERIALIZE             = 0x01,
    HEAP_GROWABLE                 = 0x02,
    HEAP_GENERATE_EXCEPTIONS      = 0x04,
    HEAP_ZERO_MEMORY              = 0x08,
    HEAP_REALLOC_IN_PLACE_ONLY    = 0x10,
    HEAP_TAIL_CHECKING_ENABLED    = 0x20,
    HEAP_FREE_CHECKING_ENABLED    = 0x40,
    HEAP_DISABLE_COALESCE_ON_FREE = 0x80;

// These are not documented on MSDN
enum HEAP_CREATE_ALIGN_16       = 0;
enum HEAP_CREATE_ENABLE_TRACING = 0x020000;
enum HEAP_MAXIMUM_TAG           = 0x000FFF;
enum HEAP_PSEUDO_TAG_FLAG       = 0x008000;
enum HEAP_TAG_SHIFT             = 16;
// ???
//MACRO #define HEAP_MAKE_TAG_FLAGS(b,o) ((DWORD)((b)+(o)<<16)))

enum ACCESS_MASK
    KEY_QUERY_VALUE        = 0x000001,
    KEY_SET_VALUE          = 0x000002,
    KEY_CREATE_SUB_KEY     = 0x000004,
    KEY_ENUMERATE_SUB_KEYS = 0x000008,
    KEY_NOTIFY             = 0x000010,
    KEY_CREATE_LINK        = 0x000020,
    KEY_WRITE              = 0x020006,
    KEY_EXECUTE            = 0x020019,
    KEY_READ               = 0x020019,
    KEY_ALL_ACCESS         = 0x0F003F;

static if (_WIN32_WINNT >= 0x502) {
enum ACCESS_MASK
        KEY_WOW64_64KEY    = 0x000100,
        KEY_WOW64_32KEY    = 0x000200;
}

enum DWORD
    REG_WHOLE_HIVE_VOLATILE = 1,
    REG_REFRESH_HIVE        = 2,
    REG_NO_LAZY_FLUSH       = 4;

enum DWORD
    REG_OPTION_RESERVED       =  0,
    REG_OPTION_NON_VOLATILE   =  0,
    REG_OPTION_VOLATILE       =  1,
    REG_OPTION_CREATE_LINK    =  2,
    REG_OPTION_BACKUP_RESTORE =  4,
    REG_OPTION_OPEN_LINK      =  8,
    REG_LEGAL_OPTION          = 15;

enum SECURITY_INFORMATION
    OWNER_SECURITY_INFORMATION            = 0x00000001,
    GROUP_SECURITY_INFORMATION            = 0x00000002,
    DACL_SECURITY_INFORMATION             = 0x00000004,
    SACL_SECURITY_INFORMATION             = 0x00000008,
    LABEL_SECURITY_INFORMATION            = 0x00000010,
    UNPROTECTED_SACL_SECURITY_INFORMATION = 0x10000000,
    UNPROTECTED_DACL_SECURITY_INFORMATION = 0x20000000,
    PROTECTED_SACL_SECURITY_INFORMATION   = 0x40000000,
    PROTECTED_DACL_SECURITY_INFORMATION   = 0x80000000;

enum DWORD MAXIMUM_PROCESSORS = 32;

// VirtualAlloc(), etc
// -------------------

enum : DWORD {
    PAGE_NOACCESS          = 0x0001,
    PAGE_READONLY          = 0x0002,
    PAGE_READWRITE         = 0x0004,
    PAGE_WRITECOPY         = 0x0008,
    PAGE_EXECUTE           = 0x0010,
    PAGE_EXECUTE_READ      = 0x0020,
    PAGE_EXECUTE_READWRITE = 0x0040,
    PAGE_EXECUTE_WRITECOPY = 0x0080,
    PAGE_GUARD             = 0x0100,
    PAGE_NOCACHE           = 0x0200
}

enum : DWORD {
    MEM_COMMIT      = 0x00001000,
    MEM_RESERVE     = 0x00002000,
    MEM_DECOMMIT    = 0x00004000,
    MEM_RELEASE     = 0x00008000,
    MEM_FREE        = 0x00010000,
    MEM_PRIVATE     = 0x00020000,
    MEM_MAPPED      = 0x00040000,
    MEM_RESET       = 0x00080000,
    MEM_TOP_DOWN    = 0x00100000,
    MEM_WRITE_WATCH = 0x00200000, // MinGW (???): 98/Me
    MEM_PHYSICAL    = 0x00400000,
    MEM_4MB_PAGES   = 0x80000000
}

// MinGW: also in ddk/ntifs.h
// CreateFileMapping()
enum DWORD
    SEC_BASED     = 0x00200000,
    SEC_NO_CHANGE = 0x00400000,
    SEC_FILE      = 0x00800000,
    SEC_IMAGE     = 0x01000000,
    SEC_VLM       = 0x02000000,
    SEC_RESERVE   = 0x04000000,
    SEC_COMMIT    = 0x08000000,
    SEC_NOCACHE   = 0x10000000,
    MEM_IMAGE     = SEC_IMAGE;
// MinGW: end ntifs.h

// ???
enum ACCESS_MASK
    SECTION_QUERY       = 0x000001,
    SECTION_MAP_WRITE   = 0x000002,
    SECTION_MAP_READ    = 0x000004,
    SECTION_MAP_EXECUTE = 0x000008,
    SECTION_EXTEND_SIZE = 0x000010,
    SECTION_ALL_ACCESS  = 0x0F001F;

// These are not documented on MSDN
enum MESSAGE_RESOURCE_UNICODE = 1;
enum RTL_CRITSECT_TYPE        = 0;
enum RTL_RESOURCE_TYPE        = 1;

// COFF file format
// ----------------

// IMAGE_FILE_HEADER.Characteristics
enum WORD
    IMAGE_FILE_RELOCS_STRIPPED         = 0x0001,
    IMAGE_FILE_EXECUTABLE_IMAGE        = 0x0002,
    IMAGE_FILE_LINE_NUMS_STRIPPED      = 0x0004,
    IMAGE_FILE_LOCAL_SYMS_STRIPPED     = 0x0008,
    IMAGE_FILE_AGGRESIVE_WS_TRIM       = 0x0010,
    IMAGE_FILE_LARGE_ADDRESS_AWARE     = 0x0020,
    IMAGE_FILE_BYTES_REVERSED_LO       = 0x0080,
    IMAGE_FILE_32BIT_MACHINE           = 0x0100,
    IMAGE_FILE_DEBUG_STRIPPED          = 0x0200,
    IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 0x0400,
    IMAGE_FILE_NET_RUN_FROM_SWAP       = 0x0800,
    IMAGE_FILE_SYSTEM                  = 0x1000,
    IMAGE_FILE_DLL                     = 0x2000,
    IMAGE_FILE_UP_SYSTEM_ONLY          = 0x4000,
    IMAGE_FILE_BYTES_REVERSED_HI       = 0x8000;

// IMAGE_FILE_HEADER.Machine
enum : WORD {
    IMAGE_FILE_MACHINE_UNKNOWN   = 0x0000,
    IMAGE_FILE_MACHINE_I386      = 0x014C,
    IMAGE_FILE_MACHINE_R3000     = 0x0162,
    IMAGE_FILE_MACHINE_R4000     = 0x0166,
    IMAGE_FILE_MACHINE_R10000    = 0x0168,
    IMAGE_FILE_MACHINE_WCEMIPSV2 = 0x0169,
    IMAGE_FILE_MACHINE_ALPHA     = 0x0184,
    IMAGE_FILE_MACHINE_SH3       = 0x01A2,
    IMAGE_FILE_MACHINE_SH3DSP    = 0x01A3,
    IMAGE_FILE_MACHINE_SH4       = 0x01A6,
    IMAGE_FILE_MACHINE_SH5       = 0x01A8,
    IMAGE_FILE_MACHINE_ARM       = 0x01C0,
    IMAGE_FILE_MACHINE_THUMB     = 0x01C2,
    IMAGE_FILE_MACHINE_AM33      = 0x01D3,
    IMAGE_FILE_MACHINE_POWERPC   = 0x01F0,
    IMAGE_FILE_MACHINE_POWERPCFP = 0x01F1,
    IMAGE_FILE_MACHINE_IA64      = 0x0200,
    IMAGE_FILE_MACHINE_MIPS16    = 0x0266,
    IMAGE_FILE_MACHINE_MIPSFPU   = 0x0366,
    IMAGE_FILE_MACHINE_MIPSFPU16 = 0x0466,
    IMAGE_FILE_MACHINE_EBC       = 0x0EBC,
    IMAGE_FILE_MACHINE_AMD64     = 0x8664,
    IMAGE_FILE_MACHINE_M32R      = 0x9041
}

// ???
enum  {
    IMAGE_DOS_SIGNATURE    = 0x5A4D,
    IMAGE_OS2_SIGNATURE    = 0x454E,
    IMAGE_OS2_SIGNATURE_LE = 0x454C,
    IMAGE_VXD_SIGNATURE    = 0x454C,
    IMAGE_NT_SIGNATURE     = 0x4550
}

// IMAGE_OPTIONAL_HEADER.Magic
enum : WORD {
    IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x010B,
    IMAGE_ROM_OPTIONAL_HDR_MAGIC  = 0x0107,
    IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x020B
}

// IMAGE_OPTIONAL_HEADER.Subsystem
enum : WORD {
    IMAGE_SUBSYSTEM_UNKNOWN                  =  0,
    IMAGE_SUBSYSTEM_NATIVE,
    IMAGE_SUBSYSTEM_WINDOWS_GUI,
    IMAGE_SUBSYSTEM_WINDOWS_CUI,          // =  3
    IMAGE_SUBSYSTEM_OS2_CUI                  =  5,
    IMAGE_SUBSYSTEM_POSIX_CUI                =  7,
    IMAGE_SUBSYSTEM_NATIVE_WINDOWS,
    IMAGE_SUBSYSTEM_WINDOWS_CE_GUI,
    IMAGE_SUBSYSTEM_EFI_APPLICATION,
    IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER,
    IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER,
    IMAGE_SUBSYSTEM_EFI_ROM,
    IMAGE_SUBSYSTEM_XBOX,                 // = 14
    IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16
}

// IMAGE_OPTIONAL_HEADER.DllCharacteristics
enum WORD
    IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE         = 0x0040,
    IMAGE_DLL_CHARACTERISTICS_FORCE_INTEGRITY      = 0x0080,
    IMAGE_DLL_CHARACTERISTICS_NX_COMPAT            = 0x0100,
    IMAGE_DLLCHARACTERISTICS_NO_ISOLATION          = 0x0200,
    IMAGE_DLLCHARACTERISTICS_NO_SEH                = 0x0400,
    IMAGE_DLLCHARACTERISTICS_NO_BIND               = 0x0800,
    IMAGE_DLLCHARACTERISTICS_WDM_DRIVER            = 0x2000,
    IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 0x8000;

// ???
enum IMAGE_SEPARATE_DEBUG_SIGNATURE = 0x4944;

enum size_t
    IMAGE_NUMBEROF_DIRECTORY_ENTRIES =  16,
    IMAGE_SIZEOF_ROM_OPTIONAL_HEADER =  56,
    IMAGE_SIZEOF_STD_OPTIONAL_HEADER =  28,
    IMAGE_SIZEOF_NT_OPTIONAL_HEADER  = 224,
    IMAGE_SIZEOF_SHORT_NAME          =   8,
    IMAGE_SIZEOF_SECTION_HEADER      =  40,
    IMAGE_SIZEOF_SYMBOL              =  18,
    IMAGE_SIZEOF_AUX_SYMBOL          =  18,
    IMAGE_SIZEOF_RELOCATION          =  10,
    IMAGE_SIZEOF_BASE_RELOCATION     =   8,
    IMAGE_SIZEOF_LINENUMBER          =   6,
    IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR  =  60,
    SIZEOF_RFPO_DATA                 =  16;

PIMAGE_SECTION_HEADER IMAGE_FIRST_SECTION(PIMAGE_NT_HEADERS h) {
    return cast(PIMAGE_SECTION_HEADER)
        (&h.OptionalHeader + h.FileHeader.SizeOfOptionalHeader);
}

// ImageDirectoryEntryToDataEx()
enum : USHORT {
    IMAGE_DIRECTORY_ENTRY_EXPORT             =  0,
    IMAGE_DIRECTORY_ENTRY_IMPORT,
    IMAGE_DIRECTORY_ENTRY_RESOURCE,
    IMAGE_DIRECTORY_ENTRY_EXCEPTION,
    IMAGE_DIRECTORY_ENTRY_SECURITY,
    IMAGE_DIRECTORY_ENTRY_BASERELOC,
    IMAGE_DIRECTORY_ENTRY_DEBUG,
    IMAGE_DIRECTORY_ENTRY_COPYRIGHT,      // =  7
    IMAGE_DIRECTORY_ENTRY_ARCHITECTURE       =  7,
    IMAGE_DIRECTORY_ENTRY_GLOBALPTR,
    IMAGE_DIRECTORY_ENTRY_TLS,
    IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,
    IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT,
    IMAGE_DIRECTORY_ENTRY_IAT,
    IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
    IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, // = 14
}

// IMAGE_SECTION_HEADER.Characteristics
enum DWORD
    IMAGE_SCN_TYPE_REG               = 0x00000000,
    IMAGE_SCN_TYPE_DSECT             = 0x00000001,
    IMAGE_SCN_TYPE_NOLOAD            = 0x00000002,
    IMAGE_SCN_TYPE_GROUP             = 0x00000004,
    IMAGE_SCN_TYPE_NO_PAD            = 0x00000008,
    IMAGE_SCN_TYPE_COPY              = 0x00000010,
    IMAGE_SCN_CNT_CODE               = 0x00000020,
    IMAGE_SCN_CNT_INITIALIZED_DATA   = 0x00000040,
    IMAGE_SCN_CNT_UNINITIALIZED_DATA = 0x00000080,
    IMAGE_SCN_LNK_OTHER              = 0x00000100,
    IMAGE_SCN_LNK_INFO               = 0x00000200,
    IMAGE_SCN_TYPE_OVER              = 0x00000400,
    IMAGE_SCN_LNK_REMOVE             = 0x00000800,
    IMAGE_SCN_LNK_COMDAT             = 0x00001000,
    IMAGE_SCN_MEM_FARDATA            = 0x00008000,
    IMAGE_SCN_GPREL                  = 0x00008000,
    IMAGE_SCN_MEM_PURGEABLE          = 0x00020000,
    IMAGE_SCN_MEM_16BIT              = 0x00020000,
    IMAGE_SCN_MEM_LOCKED             = 0x00040000,
    IMAGE_SCN_MEM_PRELOAD            = 0x00080000,
    IMAGE_SCN_ALIGN_1BYTES           = 0x00100000,
    IMAGE_SCN_ALIGN_2BYTES           = 0x00200000,
    IMAGE_SCN_ALIGN_4BYTES           = 0x00300000,
    IMAGE_SCN_ALIGN_8BYTES           = 0x00400000,
    IMAGE_SCN_ALIGN_16BYTES          = 0x00500000,
    IMAGE_SCN_ALIGN_32BYTES          = 0x00600000,
    IMAGE_SCN_ALIGN_64BYTES          = 0x00700000,
    IMAGE_SCN_ALIGN_128BYTES         = 0x00800000,
    IMAGE_SCN_ALIGN_256BYTES         = 0x00900000,
    IMAGE_SCN_ALIGN_512BYTES         = 0x00A00000,
    IMAGE_SCN_ALIGN_1024BYTES        = 0x00B00000,
    IMAGE_SCN_ALIGN_2048BYTES        = 0x00C00000,
    IMAGE_SCN_ALIGN_4096BYTES        = 0x00D00000,
    IMAGE_SCN_ALIGN_8192BYTES        = 0x00E00000,
    IMAGE_SCN_LNK_NRELOC_OVFL        = 0x01000000,
    IMAGE_SCN_MEM_DISCARDABLE        = 0x02000000,
    IMAGE_SCN_MEM_NOT_CACHED         = 0x04000000,
    IMAGE_SCN_MEM_NOT_PAGED          = 0x08000000,
    IMAGE_SCN_MEM_SHARED             = 0x10000000,
    IMAGE_SCN_MEM_EXECUTE            = 0x20000000,
    IMAGE_SCN_MEM_READ               = 0x40000000,
    IMAGE_SCN_MEM_WRITE              = 0x80000000;

/*  The following constants are mostlydocumented at
 *  http://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/pecoff.doc
 *  but don't seem to be defined in the HTML docs.
 */
enum : SHORT {
    IMAGE_SYM_UNDEFINED =  0,
    IMAGE_SYM_ABSOLUTE  = -1,
    IMAGE_SYM_DEBUG     = -2
}

enum : ubyte {
    IMAGE_SYM_TYPE_NULL,
    IMAGE_SYM_TYPE_VOID,
    IMAGE_SYM_TYPE_CHAR,
    IMAGE_SYM_TYPE_SHORT,
    IMAGE_SYM_TYPE_INT,
    IMAGE_SYM_TYPE_LONG,
    IMAGE_SYM_TYPE_FLOAT,
    IMAGE_SYM_TYPE_DOUBLE,
    IMAGE_SYM_TYPE_STRUCT,
    IMAGE_SYM_TYPE_UNION,
    IMAGE_SYM_TYPE_ENUM,
    IMAGE_SYM_TYPE_MOE,
    IMAGE_SYM_TYPE_BYTE,
    IMAGE_SYM_TYPE_WORD,
    IMAGE_SYM_TYPE_UINT,
    IMAGE_SYM_TYPE_DWORD // = 15
}
enum IMAGE_SYM_TYPE_PCODE = 32768; // ???

enum : ubyte {
    IMAGE_SYM_DTYPE_NULL,
    IMAGE_SYM_DTYPE_POINTER,
    IMAGE_SYM_DTYPE_FUNCTION,
    IMAGE_SYM_DTYPE_ARRAY
}

enum : BYTE {
    IMAGE_SYM_CLASS_END_OF_FUNCTION  = 0xFF,
    IMAGE_SYM_CLASS_NULL             =   0,
    IMAGE_SYM_CLASS_AUTOMATIC,
    IMAGE_SYM_CLASS_EXTERNAL,
    IMAGE_SYM_CLASS_STATIC,
    IMAGE_SYM_CLASS_REGISTER,
    IMAGE_SYM_CLASS_EXTERNAL_DEF,
    IMAGE_SYM_CLASS_LABEL,
    IMAGE_SYM_CLASS_UNDEFINED_LABEL,
    IMAGE_SYM_CLASS_MEMBER_OF_STRUCT,
    IMAGE_SYM_CLASS_ARGUMENT,
    IMAGE_SYM_CLASS_STRUCT_TAG,
    IMAGE_SYM_CLASS_MEMBER_OF_UNION,
    IMAGE_SYM_CLASS_UNION_TAG,
    IMAGE_SYM_CLASS_TYPE_DEFINITION,
    IMAGE_SYM_CLASS_UNDEFINED_STATIC,
    IMAGE_SYM_CLASS_ENUM_TAG,
    IMAGE_SYM_CLASS_MEMBER_OF_ENUM,
    IMAGE_SYM_CLASS_REGISTER_PARAM,
    IMAGE_SYM_CLASS_BIT_FIELD,    // =  18
    IMAGE_SYM_CLASS_FAR_EXTERNAL     =  68,
    IMAGE_SYM_CLASS_BLOCK            = 100,
    IMAGE_SYM_CLASS_FUNCTION,
    IMAGE_SYM_CLASS_END_OF_STRUCT,
    IMAGE_SYM_CLASS_FILE,
    IMAGE_SYM_CLASS_SECTION,
    IMAGE_SYM_CLASS_WEAK_EXTERNAL,// = 105
    IMAGE_SYM_CLASS_CLR_TOKEN        = 107
}

enum : BYTE {
    IMAGE_COMDAT_SELECT_NODUPLICATES = 1,
    IMAGE_COMDAT_SELECT_ANY,
    IMAGE_COMDAT_SELECT_SAME_SIZE,
    IMAGE_COMDAT_SELECT_EXACT_MATCH,
    IMAGE_COMDAT_SELECT_ASSOCIATIVE,
    IMAGE_COMDAT_SELECT_LARGEST,
    IMAGE_COMDAT_SELECT_NEWEST    // = 7
}

enum : DWORD {
    IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1,
    IMAGE_WEAK_EXTERN_SEARCH_LIBRARY,
    IMAGE_WEAK_EXTERN_SEARCH_ALIAS
}

enum : WORD {
    IMAGE_REL_I386_ABSOLUTE       = 0x0000,
    IMAGE_REL_I386_DIR16          = 0x0001,
    IMAGE_REL_I386_REL16          = 0x0002,
    IMAGE_REL_I386_DIR32          = 0x0006,
    IMAGE_REL_I386_DIR32NB        = 0x0007,
    IMAGE_REL_I386_SEG12          = 0x0009,
    IMAGE_REL_I386_SECTION        = 0x000A,
    IMAGE_REL_I386_SECREL         = 0x000B,
    IMAGE_REL_I386_TOKEN          = 0x000C,
    IMAGE_REL_I386_SECREL7        = 0x000D,
    IMAGE_REL_I386_REL32          = 0x0014
}

enum : WORD {
    IMAGE_REL_AMD64_ABSOLUTE      = 0x0000,
    IMAGE_REL_AMD64_ADDR64        = 0x0001,
    IMAGE_REL_AMD64_ADDR32        = 0x0002,
    IMAGE_REL_AMD64_ADDR32NB      = 0x0003,
    IMAGE_REL_AMD64_REL32         = 0x0004,
    IMAGE_REL_AMD64_REL32_1       = 0x0005,
    IMAGE_REL_AMD64_REL32_2       = 0x0006,
    IMAGE_REL_AMD64_REL32_3       = 0x0007,
    IMAGE_REL_AMD64_REL32_4       = 0x0008,
    IMAGE_REL_AMD64_REL32_5       = 0x0009,
    IMAGE_REL_AMD64_SECTION       = 0x000A,
    IMAGE_REL_AMD64_SECREL        = 0x000B,
    IMAGE_REL_AMD64_SECREL7       = 0x000C,
    IMAGE_REL_AMD64_TOKEN         = 0x000D,
    IMAGE_REL_AMD64_SREL32        = 0x000E,
    IMAGE_REL_AMD64_PAIR          = 0x000F,
    IMAGE_REL_AMD64_SSPAN32       = 0x0010
}

enum : WORD {
    IMAGE_REL_IA64_ABSOLUTE       = 0x0000,
    IMAGE_REL_IA64_IMM14          = 0x0001,
    IMAGE_REL_IA64_IMM22          = 0x0002,
    IMAGE_REL_IA64_IMM64          = 0x0003,
    IMAGE_REL_IA64_DIR32          = 0x0004,
    IMAGE_REL_IA64_DIR64          = 0x0005,
    IMAGE_REL_IA64_PCREL21B       = 0x0006,
    IMAGE_REL_IA64_PCREL21M       = 0x0007,
    IMAGE_REL_IA64_PCREL21F       = 0x0008,
    IMAGE_REL_IA64_GPREL22        = 0x0009,
    IMAGE_REL_IA64_LTOFF22        = 0x000A,
    IMAGE_REL_IA64_SECTION        = 0x000B,
    IMAGE_REL_IA64_SECREL22       = 0x000C,
    IMAGE_REL_IA64_SECREL64I      = 0x000D,
    IMAGE_REL_IA64_SECREL32       = 0x000E,
    IMAGE_REL_IA64_DIR32NB        = 0x0010,
    IMAGE_REL_IA64_SREL14         = 0x0011,
    IMAGE_REL_IA64_SREL22         = 0x0012,
    IMAGE_REL_IA64_SREL32         = 0x0013,
    IMAGE_REL_IA64_UREL32     0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          = 0x0014,
    IMAGE_REL_IA64_PCREL60X       = 0x0015,
    IMAGE_REL_IA64_PCREL60B       = 0x0016,
    IMAGE_REL_IA64_PCREL60F       = 0x0017,
    IMAGE_REL_IA64_PCREL60I       = 0x0018,
    IMAGE_REL_IA64_PCREL60M       = 0x0019,
    IMAGE_REL_IA64_IMMGPREL64     = 0x001A,
    IMAGE_REL_IA64_TOKEN          = 0x001B,
    IMAGE_REL_IA64_GPREL32        = 0x001C,
    IMAGE_REL_IA64_ADDEND         = 0x001F
}

enum : WORD {
    IMAGE_REL_SH3_ABSOLUTE        = 0x0000,
    IMAGE_REL_SH3_DIRECT16        = 0x0001,
    IMAGE_REL_SH3_DIRECT32        = 0x0002,
    IMAGE_REL_SH3_DIRECT8         = 0x0003,
    IMAGE_REL_SH3_DIRECT8_WORD    = 0x0004,
    IMAGE_REL_SH3_DIRECT8_LONG    = 0x0005,
    IMAGE_REL_SH3_DIRECT4         = 0x0006,
    IMAGE_REL_SH3_DIRECT4_WORD    = 0x0007,
    IMAGE_REL_SH3_DIRECT4_LONG    = 0x0008,
    IMAGE_REL_SH3_PCREL8_WORD     = 0x0009,
    IMAGE_REL_SH3_PCREL8_LONG     = 0x000A,
    IMAGE_REL_SH3_PCREL12_WORD    = 0x000B,
    IMAGE_REL_SH3_STARTOF_SECTION = 0x000C,
    IMAGE_REL_SH3_SIZEOF_SECTION  = 0x000D,
    IMAGE_REL_SH3_SECTION         = 0x000E,
    IMAGE_REL_SH3_SECREL          = 0x000F,
    IMAGE_REL_SH3_DIRECT32_NB     = 0x0010,
    IMAGE_REL_SH3_GPREL4_LONG     = 0x0011,
    IMAGE_REL_SH3_TOKEN           = 0x0012,
    IMAGE_REL_SHM_PCRELPT         = 0x0013,
    IMAGE_REL_SHM_REFLO           = 0x0014,
    IMAGE_REL_SHM_REFHALF         = 0x0015,
    IMAGE_REL_SHM_RELLO           = 0x0016,
    IMAGE_REL_SHM_RELHALF         = 0x0017,
    IMAGE_REL_SHM_PAIR            = 0x0018,
    IMAGE_REL_SHM_NOMODE          = 0x8000
}

enum : WORD {
    IMAGE_REL_M32R_ABSOLUTE       = 0x0000,
    IMAGE_REL_M32R_ADDR32         = 0x0001,
    IMAGE_REL_M32R_ADDR32NB       = 0x0002,
    IMAGE_REL_M32R_ADDR24         = 0x0003,
    IMAGE_REL_M32R_GPREL16        = 0x0004,
    IMAGE_REL_M32R_PCREL24        = 0x0005,
    IMAGE_REL_M32R_PCREL16        = 0x0006,
    IMAGE_REL_M32R_PCREL8         = 0x0007,
    IMAGE_REL_M32R_REFHALF        = 0x0008,
    IMAGE_REL_M32R_REFHI          = 0x0009,
    IMAGE_REL_M32R_REFLO          = 0x000A,
    IMAGE_REL_M32R_PAIR           = 0x000B,
    IMAGE_REL_M32R_SECTION        = 0x000C,
    IMAGE_REL_M32R_SECREL         = 0x000D,
    IMAGE_REL_M32R_TOKEN          = 0x000E
}

enum : WORD {
    IMAGE_REL_MIPS_ABSOLUTE       = 0x0000,
    IMAGE_REL_MIPS_REFHALF        = 0x0001,
    IMAGE_REL_MIPS_REFWORD        = 0x0002,
    IMAGE_REL_MIPS_JMPADDR        = 0x0003,
    IMAGE_REL_MIPS_REFHI          = 0x0004,
    IMAGE_REL_MIPS_REFLO          = 0x0005,
    IMAGE_REL_MIPS_GPREL          = 0x0006,
    IMAGE_REL_MIPS_LITERAL        = 0x0007,
    IMAGE_REL_MIPS_SECTION        = 0x000A,
    IMAGE_REL_MIPS_SECREL         = 0x000B,
    IMAGE_REL_MIPS_SECRELLO       = 0x000C,
    IMAGE_REL_MIPS_SECRELHI       = 0x000D,
    IMAGE_REL_MIPS_JMPADDR16      = 0x0010,
    IMAGE_REL_MIPS_REFWORDNB      = 0x0022,
    IMAGE_REL_MIPS_PAIR           = 0x0025
}


enum : WORD {
    IMAGE_REL_ALPHA_ABSOLUTE,
    IMAGE_REL_ALPHA_REFLONG,
    IMAGE_REL_ALPHA_REFQUAD,
    IMAGE_REL_ALPHA_GPREL32,
    IMAGE_REL_ALPHA_LITERAL,
    IMAGE_REL_ALPHA_LITUSE,
    IMAGE_REL_ALPHA_GPDISP,
    IMAGE_REL_ALPHA_BRADDR,
    IMAGE_REL_ALPHA_HINT,
    IMAGE_REL_ALPHA_INLINE_REFLONG,
    IMAGE_REL_ALPHA_REFHI,
    IMAGE_REL_ALPHA_REFLO,
    IMAGE_REL_ALPHA_PAIR,
    IMAGE_REL_ALPHA_MATCH,
    IMAGE_REL_ALPHA_SECTION,
    IMAGE_REL_ALPHA_SECREL,
    IMAGE_REL_ALPHA_REFLONGNB,
    IMAGE_REL_ALPHA_SECRELLO,
    IMAGE_REL_ALPHA_SECRELHI // = 18
}

enum : WORD {
    IMAGE_REL_PPC_ABSOLUTE,
    IMAGE_REL_PPC_ADDR64,
    IMAGE_REL_PPC_ADDR32,
    IMAGE_REL_PPC_ADDR24,
    IMAGE_REL_PPC_ADDR16,
    IMAGE_REL_PPC_ADDR14,
    IMAGE_REL_PPC_REL24,
    IMAGE_REL_PPC_REL14,
    IMAGE_REL_PPC_TOCREL16,
    IMAGE_REL_PPC_TOCREL14,
    IMAGE_REL_PPC_ADDR32NB,
    IMAGE_REL_PPC_SECREL,
    IMAGE_REL_PPC_SECTION,
    IMAGE_REL_PPC_IFGLUE,
    IMAGE_REL_PPC_IMGLUE,
    IMAGE_REL_PPC_SECREL16,
    IMAGE_REL_PPC_REFHI,
    IMAGE_REL_PPC_REFLO,
    IMAGE_REL_PPC_PAIR // = 18
}

// ???
enum IMAGE_REL_PPC_TYPEMASK = 0x00FF;
enum IMAGE_REL_PPC_NEG      = 0x0100;
enum IMAGE_REL_PPC_BRTAKEN  = 0x0200;
enum IMAGE_REL_PPC_BRNTAKEN = 0x0400;
enum IMAGE_REL_PPC_TOCDEFN  = 0x0800;

enum {
    IMAGE_REL_BASED_ABSOLUTE,
    IMAGE_REL_BASED_HIGH,
    IMAGE_REL_BASED_LOW,
    IMAGE_REL_BASED_HIGHLOW,
    IMAGE_REL_BASED_HIGHADJ,
    IMAGE_REL_BASED_MIPS_JMPADDR
}
// End of constants documented in pecoff.doc

enum size_t IMAGE_ARCHIVE_START_SIZE = 8;

const TCHAR[]
    IMAGE_ARCHIVE_START            = "!<arch>\n",
    IMAGE_ARCHIVE_END              = "`\n",
    IMAGE_ARCHIVE_PAD              = "\n",
    IMAGE_ARCHIVE_LINKER_MEMBER    = "/               ",
    IMAGE_ARCHIVE_LONGNAMES_MEMBER = "//              ";

enum IMAGE_ORDINAL_FLAG32 = 0x80000000;

ulong IMAGE_ORDINAL64(ulong Ordinal) { return Ordinal & 0xFFFF; }
uint IMAGE_ORDINAL32(uint Ordinal)   { return Ordinal & 0xFFFF; }

bool IMAGE_SNAP_BY_ORDINAL32(uint Ordinal) {
    return (Ordinal & IMAGE_ORDINAL_FLAG32) != 0;
}

enum ulong IMAGE_ORDINAL_FLAG64 = 0x8000000000000000;

bool IMAGE_SNAP_BY_ORDINAL64(ulong Ordinal) {
    return (Ordinal & IMAGE_ORDINAL_FLAG64) != 0;
}

// ???
enum IMAGE_RESOURCE_NAME_IS_STRING    = 0x80000000;
enum IMAGE_RESOURCE_DATA_IS_DIRECTORY = 0x80000000;

enum : DWORD {
    IMAGE_DEBUG_TYPE_UNKNOWN,
    IMAGE_DEBUG_TYPE_COFF,
    IMAGE_DEBUG_TYPE_CODEVIEW,
    IMAGE_DEBUG_TYPE_FPO,
    IMAGE_DEBUG_TYPE_MISC,
    IMAGE_DEBUG_TYPE_EXCEPTION,
    IMAGE_DEBUG_TYPE_FIXUP,
    IMAGE_DEBUG_TYPE_OMAP_TO_SRC,
    IMAGE_DEBUG_TYPE_OMAP_FROM_SRC,
    IMAGE_DEBUG_TYPE_BORLAND // = 9
}

enum : ubyte {
    FRAME_FPO,
    FRAME_TRAP,
    FRAME_TSS,
    FRAME_NONFPO
}

// ???
enum IMAGE_DEBUG_MISC_EXENAME = 1;

// ???
enum N_BTMASK = 0x000F;
enum N_TMASK  = 0x0030;
enum N_TMASK1 = 0x00C0;
enum N_TMASK2 = 0x00F0;
enum N_BTSHFT = 4;
enum N_TSHIFT = 2;

enum int
    IS_TEXT_UNICODE_ASCII16            = 0x0001,
    IS_TEXT_UNICODE_STATISTICS         = 0x0002,
    IS_TEXT_UNICODE_CONTROLS           = 0x0004,
    IS_TEXT_UNICODE_SIGNATURE          = 0x0008,
    IS_TEXT_UNICODE_REVERSE_ASCII16    = 0x0010,
    IS_TEXT_UNICODE_REVERSE_STATISTICS = 0x0020,
    IS_TEXT_UNICODE_REVERSE_CONTROLS   = 0x0040,
    IS_TEXT_UNICODE_REVERSE_SIGNATURE  = 0x0080,
    IS_TEXT_UNICODE_ILLEGAL_CHARS      = 0x0100,
    IS_TEXT_UNICODE_ODD_LENGTH         = 0x0200,
    IS_TEXT_UNICODE_NULL_BYTES         = 0x1000,
    IS_TEXT_UNICODE_UNICODE_MASK       = 0x000F,
    IS_TEXT_UNICODE_REVERSE_MASK       = 0x00F0,
    IS_TEXT_UNICODE_NOT_UNICODE_MASK   = 0x0F00,
    IS_TEXT_UNICODE_NOT_ASCII_MASK     = 0xF000;

enum DWORD
    SERVICE_KERNEL_DRIVER       = 0x0001,
    SERVICE_FILE_SYSTEM_DRIVER  = 0x0002,
    SERVICE_ADAPTER             = 0x0004,
    SERVICE_RECOGNIZER_DRIVER   = 0x0008,
    SERVICE_WIN32_OWN_PROCESS   = 0x0010,
    SERVICE_WIN32_SHARE_PROCESS = 0x0020,
    SERVICE_INTERACTIVE_PROCESS = 0x0100,
    SERVICE_DRIVER              = 0x000B,
    SERVICE_WIN32               = 0x0030,
    SERVICE_TYPE_ALL            = 0x013F;

enum : DWORD {
    SERVICE_BOOT_START   = 0,
    SERVICE_SYSTEM_START = 1,
    SERVICE_AUTO_START   = 2,
    SERVICE_DEMAND_START = 3,
    SERVICE_DISABLED     = 4
}

enum : DWORD {
    SERVICE_ERROR_IGNORE   = 0,
    SERVICE_ERROR_NORMAL   = 1,
    SERVICE_ERROR_SEVERE   = 2,
    SERVICE_ERROR_CRITICAL = 3
}


enum uint
    SE_OWNER_DEFAULTED          = 0x0001,
    SE_GROUP_DEFAULTED          = 0x0002,
    SE_DACL_PRESENT             = 0x0004,
    SE_DACL_DEFAULTED           = 0x0008,
    SE_SACL_PRESENT             = 0x0010,
    SE_SACL_DEFAULTED           = 0x0020,
    SE_DACL_AUTO_INHERIT_REQ    = 0x0100,
    SE_SACL_AUTO_INHERIT_REQ    = 0x0200,
    SE_DACL_AUTO_INHERITED      = 0x0400,
    SE_SACL_AUTO_INHERITED      = 0x0800,
    SE_DACL_PROTECTED           = 0x1000,
    SE_SACL_PROTECTED           = 0x2000,
    SE_SELF_RELATIVE            = 0x8000;

enum SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
}
alias SECURITY_IMPERSONATION_LEVEL* PSECURITY_IMPERSONATION_LEVEL;

alias BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
alias BOOLEAN* PSECURITY_CONTEXT_TRACKING_MODE;

enum size_t SECURITY_DESCRIPTOR_MIN_LENGTH = 20;

enum DWORD
    SECURITY_DESCRIPTOR_REVISION  = 1,
    SECURITY_DESCRIPTOR_REVISION1 = 1;

enum DWORD
    SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001,
    SE_PRIVILEGE_ENABLED            = 0x00000002,
    SE_PRIVILEGE_USED_FOR_ACCESS    = 0x80000000;

enum DWORD PRIVILEGE_SET_ALL_NECESSARY = 1;

enum SECURITY_IMPERSONATION_LEVEL
    SECURITY_MAX_IMPERSONATION_LEVEL = SECURITY_IMPERSONATION_LEVEL.SecurityDelegation,
    DEFAULT_IMPERSONATION_LEVEL      = SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation;

enum BOOLEAN
    SECURITY_DYNAMIC_TRACKING = true,
    SECURITY_STATIC_TRACKING  = false;

// also in ddk/ntifs.h
enum DWORD
    TOKEN_ASSIGN_PRIMARY    = 0x0001,
    TOKEN_DUPLICATE         = 0x0002,
    TOKEN_IMPERSONATE       = 0x0004,
    TOKEN_QUERY             = 0x0008,
    TOKEN_QUERY_SOURCE      = 0x0010,
    TOKEN_ADJUST_PRIVILEGES = 0x0020,
    TOKEN_ADJUST_GROUPS     = 0x0040,
    TOKEN_ADJUST_DEFAULT    = 0x0080,

    TOKEN_ALL_ACCESS        = STANDARD_RIGHTS_REQUIRED
                              | TOKEN_ASSIGN_PRIMARY
                              | TOKEN_DUPLICATE
                              | TOKEN_IMPERSONATE
                              | TOKEN_QUERY
                              | TOKEN_QUERY_SOURCE
                              | TOKEN_ADJUST_PRIVILEGES
                              | TOKEN_ADJUST_GROUPS
                              | TOKEN_ADJUST_DEFAULT,
    TOKEN_READ              = STANDARD_RIGHTS_READ | TOKEN_QUERY,
    TOKEN_WRITE             = STANDARD_RIGHTS_WRITE
                              | TOKEN_ADJUST_PRIVILEGES
                              | TOKEN_ADJUST_GROUPS
                              | TOKEN_ADJUST_DEFAULT,
    TOKEN_EXECUTE           = STANDARD_RIGHTS_EXECUTE;

enum size_t TOKEN_SOURCE_LENGTH = 8;
// end ddk/ntifs.h

enum : DWORD {
    DLL_PROCESS_DETACH,
    DLL_PROCESS_ATTACH,
    DLL_THREAD_ATTACH,
    DLL_THREAD_DETACH
}

enum : DWORD {
    DBG_CONTINUE              = 0x00010002,
    DBG_TERMINATE_THREAD      = 0x40010003,
    DBG_TERMINATE_PROCESS     = 0x40010004,
    DBG_CONTROL_C             = 0x40010005,
    DBG_CONTROL_BREAK         = 0x40010008,
    DBG_EXCEPTION_NOT_HANDLED = 0x80010001
}

enum : DWORD {
    TAPE_ABSOLUTE_POSITION,
    TAPE_LOGICAL_POSITION,
    TAPE_PSEUDO_LOGICAL_POSITION
}

enum : DWORD {
    TAPE_REWIND,
    TAPE_ABSOLUTE_BLOCK,
    TAPE_LOGICAL_BLOCK,
    TAPE_PSEUDO_LOGICAL_BLOCK,
    TAPE_SPACE_END_OF_DATA,
    TAPE_SPACE_RELATIVE_BLOCKS,
    TAPE_SPACE_FILEMARKS,
    TAPE_SPACE_SEQUENTIAL_FMKS,
    TAPE_SPACE_SETMARKS,
    TAPE_SPACE_SEQUENTIAL_SMKS
}

enum DWORD
    TAPE_DRIVE_FIXED            = 0x00000001,
    TAPE_DRIVE_SELECT           = 0x00000002,
    TAPE_DRIVE_INITIATOR        = 0x00000004,
    TAPE_DRIVE_ERASE_SHORT      = 0x00000010,
    TAPE_DRIVE_ERASE_LONG       = 0x00000020,
    TAPE_DRIVE_ERASE_BOP_ONLY   = 0x00000040,
    TAPE_DRIVE_ERASE_IMMEDIATE  = 0x00000080,
    TAPE_DRIVE_TAPE_CAPACITY    = 0x00000100,
    TAPE_DRIVE_TAPE_REMAINING   = 0x00000200,
    TAPE_DRIVE_FIXED_BLOCK      = 0x00000400,
    TAPE_DRIVE_VARIABLE_BLOCK   = 0x00000800,
    TAPE_DRIVE_WRITE_PROTECT    = 0x00001000,
    TAPE_DRIVE_EOT_WZ_SIZE      = 0x00002000,
    TAPE_DRIVE_ECC              = 0x00010000,
    TAPE_DRIVE_COMPRESSION      = 0x00020000,
    TAPE_DRIVE_PADDING          = 0x00040000,
    TAPE_DRIVE_REPORT_SMKS      = 0x00080000,
    TAPE_DRIVE_GET_ABSOLUTE_BLK = 0x00100000,
    TAPE_DRIVE_GET_LOGICAL_BLK  = 0x00200000,
    TAPE_DRIVE_SET_EOT_WZ_SIZE  = 0x00400000,
    TAPE_DRIVE_EJECT_MEDIA      = 0x01000000,
    TAPE_DRIVE_CLEAN_REQUESTS   = 0x02000000,
    TAPE_DRIVE_SET_CMP_BOP_ONLY = 0x04000000,
    TAPE_DRIVE_RESERVED_BIT     = 0x80000000;

enum DWORD
    TAPE_DRIVE_LOAD_UNLOAD      = 0x80000001,
    TAPE_DRIVE_TENSION          = 0x80000002,
    TAPE_DRIVE_LOCK_UNLOCK      = 0x80000004,
    TAPE_DRIVE_REWIND_IMMEDIATE = 0x80000008,
    TAPE_DRIVE_SET_BLOCK_SIZE   = 0x80000010,
    TAPE_DRIVE_LOAD_UNLD_IMMED  = 0x80000020,
    TAPE_DRIVE_TENSION_IMMED    = 0x80000040,
    TAPE_DRIVE_LOCK_UNLK_IMMED  = 0x80000080,
    TAPE_DRIVE_SET_ECC          = 0x80000100,
    TAPE_DRIVE_SET_COMPRESSION  = 0x80000200,
    TAPE_DRIVE_SET_PADDING      = 0x80000400,
    TAPE_DRIVE_SET_REPORT_SMKS  = 0x80000800,
    TAPE_DRIVE_ABSOLUTE_BLK     = 0x80001000,
    TAPE_DRIVE_ABS_BLK_IMMED    = 0x80002000,
    TAPE_DRIVE_LOGICAL_BLK      = 0x80004000,
    TAPE_DRIVE_LOG_BLK_IMMED    = 0x80008000,
    TAPE_DRIVE_END_OF_DATA      = 0x80010000,
    TAPE_DRIVE_RELATIVE_BLKS    = 0x80020000,
    TAPE_DRIVE_FILEMARKS        = 0x80040000,
    TAPE_DRIVE_SEQUENTIAL_FMKS  = 0x80080000,
    TAPE_DRIVE_SETMARKS         = 0x80100000,
    TAPE_DRIVE_SEQUENTIAL_SMKS  = 0x80200000,
    TAPE_DRIVE_REVERSE_POSITION = 0x80400000,
    TAPE_DRIVE_SPACE_IMMEDIATE  = 0x80800000,
    TAPE_DRIVE_WRITE_SETMARKS   = 0x81000000,
    TAPE_DRIVE_WRITE_FILEMARKS  = 0x82000000,
    TAPE_DRIVE_WRITE_SHORT_FMKS = 0x84000000,
    TAPE_DRIVE_WRITE_LONG_FMKS  = 0x88000000,
    TAPE_DRIVE_WRITE_MARK_IMMED = 0x90000000,
    TAPE_DRIVE_FORMAT           = 0xA0000000,
    TAPE_DRIVE_FORMAT_IMMEDIATE = 0xC0000000,
    TAPE_DRIVE_HIGH_FEATURES    = 0x80000000;

enum : DWORD {
    TAPE_FIXED_PARTITIONS     = 0,
    TAPE_SELECT_PARTITIONS    = 1,
    TAPE_INITIATOR_PARTITIONS = 2
}

enum : DWORD {
    TAPE_SETMARKS,
    TAPE_FILEMARKS,
    TAPE_SHORT_FILEMARKS,
    TAPE_LONG_FILEMARKS
}

enum : DWORD {
    TAPE_ERASE_SHORT,
    TAPE_ERASE_LONG
}

enum : DWORD {
    TAPE_LOAD,
    TAPE_UNLOAD,
    TAPE_TENSION,
    TAPE_LOCK,
    TAPE_UNLOCK,
    TAPE_FORMAT
}

enum : ULONG32 {
    VER_PLATFORM_WIN32s,
    VER_PLATFORM_WIN32_WINDOWS,
    VER_PLATFORM_WIN32_NT
}

enum : UCHAR {
    VER_NT_WORKSTATION = 1,
    VER_NT_DOMAIN_CONTROLLER,
    VER_NT_SERVER
}

enum USHORT
    VER_SUITE_SMALLBUSINESS            = 0x0001,
    VER_SUITE_ENTERPRISE               = 0x0002,
    VER_SUITE_BACKOFFICE               = 0x0004,
    VER_SUITE_TERMINAL                 = 0x0010,
    VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x0020,
    VER_SUITE_EMBEDDEDNT               = 0x0040,
    VER_SUITE_DATACENTER               = 0x0080,
    VER_SUITE_SINGLEUSERTS             = 0x0100,
    VER_SUITE_PERSONAL                 = 0x0200,
    VER_SUITE_BLADE                    = 0x0400,
    VER_SUITE_STORAGE_SERVER           = 0x2000,
    VER_SUITE_COMPUTE_SERVER           = 0x4000;

enum ULONG
    WT_EXECUTEDEFAULT            = 0x00000000,
    WT_EXECUTEINIOTHREAD         = 0x00000001,
    WT_EXECUTEINWAITTHREAD       = 0x00000004,
    WT_EXECUTEONLYONCE           = 0x00000008,
    WT_EXECUTELONGFUNCTION       = 0x00000010,
    WT_EXECUTEINTIMERTHREAD      = 0x00000020,
    WT_EXECUTEINPERSISTENTTHREAD = 0x00000080,
    WT_TRANSFER_IMPERSONATION    = 0x00000100;

static if (_WIN32_WINNT >= 0x500) {
enum DWORD
        VER_MINORVERSION     = 0x01,
        VER_MAJORVERSION     = 0x02,
        VER_BUILDNUMBER      = 0x04,
        VER_PLATFORMID       = 0x08,
        VER_SERVICEPACKMINOR = 0x10,
        VER_SERVICEPACKMAJOR = 0x20,
        VER_SUITENAME        = 0x40,
        VER_PRODUCT_TYPE     = 0x80;

    enum : DWORD {
        VER_EQUAL = 1,
        VER_GREATER,
        VER_GREATER_EQUAL,
        VER_LESS,
        VER_LESS_EQUAL,
        VER_AND,
        VER_OR // = 7
    }
}

static if (_WIN32_WINNT >= 0x501) {
    enum : ULONG {
        ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION       = 1,
        ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION,
        ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION,
        ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION,
        ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
        ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION,
        ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION, // = 7
        ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES             = 9
    }
}

// Macros
BYTE BTYPE(BYTE x) { return cast(BYTE) (x & N_BTMASK); }
bool ISPTR(uint x) { return (x & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT); }
bool ISFCN(uint x) { return (x & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT); }
bool ISARY(uint x) { return (x & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT); }
bool ISTAG(uint x) {
    return x == IMAGE_SYM_CLASS_STRUCT_TAG
        || x == IMAGE_SYM_CLASS_UNION_TAG
        || x == IMAGE_SYM_CLASS_ENUM_TAG;
}
uint INCREF(uint x) {
    return ((x & ~N_BTMASK) << N_TSHIFT) | (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT)
      | (x & N_BTMASK);
}
uint DECREF(uint x) { return ((x >>> N_TSHIFT) & ~N_BTMASK) | (x & N_BTMASK); }

enum DWORD TLS_MINIMUM_AVAILABLE = 64;

enum ULONG
    IO_REPARSE_TAG_RESERVED_ZERO  = 0,
    IO_REPARSE_TAG_RESERVED_ONE   = 1,
    IO_REPARSE_TAG_RESERVED_RANGE = IO_REPARSE_TAG_RESERVED_ONE,
    IO_REPARSE_TAG_SYMBOLIC_LINK  = IO_REPARSE_TAG_RESERVED_ZERO,
    IO_REPARSE_TAG_MOUNT_POINT    = 0xA0000003,
    IO_REPARSE_TAG_SYMLINK        = 0xA000000C,
    IO_REPARSE_TAG_VALID_VALUES   = 0xE000FFFF;

/*  Although these are semantically boolean, they are documented and
 *  implemented to return ULONG; this behaviour is preserved for compatibility
 */
ULONG IsReparseTagMicrosoft(ULONG x)     { return x & 0x80000000; }
ULONG IsReparseTagHighLatency(ULONG x)   { return x & 0x40000000; }
ULONG IsReparseTagNameSurrogate(ULONG x) { return x & 0x20000000; }

bool IsReparseTagValid(ULONG x) {
    return !(x & ~IO_REPARSE_TAG_VALID_VALUES) && (x > IO_REPARSE_TAG_RESERVED_RANGE);
}

// Doesn't seem to make sense, but anyway....
ULONG WT_SET_MAX_THREADPOOL_THREADS(ref ULONG Flags, ushort Limit) {
    return Flags |= Limit << 16;
}

import core.sys.windows.basetyps;
/* also in core.sys.windows.basetyps
struct GUID {
    uint  Data1;
    ushort Data2;
    ushort Data3;
    ubyte  Data4[8];
}
alias GUID* REFGUID, LPGUID;
*/

struct GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
}
alias GENERIC_MAPPING* PGENERIC_MAPPING;

struct ACE_HEADER {
    BYTE AceType;
    BYTE AceFlags;
    WORD AceSize;
}
alias ACE_HEADER* PACE_HEADER;

struct ACCESS_ALLOWED_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       SidStart;
}
alias ACCESS_ALLOWED_ACE* PACCESS_ALLOWED_ACE;

struct ACCESS_DENIED_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       SidStart;
}
alias ACCESS_DENIED_ACE* PACCESS_DENIED_ACE;

struct SYSTEM_AUDIT_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       SidStart;
}
alias SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

struct SYSTEM_ALARM_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       SidStart;
}
alias SYSTEM_ALARM_ACE* PSYSTEM_ALARM_ACE;

struct ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       Flags;
    GUID        ObjectType;
    GUID        InheritedObjectType;
    DWORD       SidStart;
}
alias ACCESS_ALLOWED_OBJECT_ACE* PACCESS_ALLOWED_OBJECT_ACE;

struct ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       Flags;
    GUID        ObjectType;
    GUID        InheritedObjectType;
    DWORD       SidStart;
}
alias ACCESS_DENIED_OBJECT_ACE* PACCESS_DENIED_OBJECT_ACE;

struct SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       Flags;
    GUID        ObjectType;
    GUID        InheritedObjectType;
    DWORD       SidStart;
}
alias SYSTEM_AUDIT_OBJECT_ACE* PSYSTEM_AUDIT_OBJECT_ACE;

struct SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER  Header;
    ACCESS_MASK Mask;
    DWORD       Flags;
    GUID        ObjectType;
    GUID        InheritedObjectType;
    DWORD       SidStart;
}
alias SYSTEM_ALARM_OBJECT_ACE* PSYSTEM_ALARM_OBJECT_ACE;

struct ACL {
    BYTE AclRevision;
    BYTE Sbz1;
    WORD AclSize;
    WORD AceCount;
    WORD Sbz2;
}
alias ACL* PACL;

struct ACL_REVISION_INFORMATION {
    DWORD AclRevision;
}

struct ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
}

version (X86) {
    // ???
enum SIZE_OF_80387_REGISTERS     = 80;
enum CONTEXT_i386                = 0x010000;
enum CONTEXT_i486                = 0x010000;
enum CONTEXT_CONTROL             = CONTEXT_i386 | 0x01;
enum CONTEXT_INTEGER             = CONTEXT_i386 | 0x02;
enum CONTEXT_SEGMENTS            = CONTEXT_i386 | 0x04;
enum CONTEXT_FLOATING_POINT      = CONTEXT_i386 | 0x08;
enum CONTEXT_DEBUG_REGISTERS     = CONTEXT_i386 | 0x10;
enum CONTEXT_EXTENDED_REGISTERS  = CONTEXT_i386 | 0x20;
enum CONTEXT_FULL                = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS;
enum CONTEXT_ALL                 = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS |
                                        CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS |
                                        CONTEXT_EXTENDED_REGISTERS;

enum MAXIMUM_SUPPORTED_EXTENSION = 512;

    struct FLOATING_SAVE_AREA {
        DWORD    ControlWord;
        DWORD    StatusWord;
        DWORD    TagWord;
        DWORD    ErrorOffset;
        DWORD    ErrorSelector;
        DWORD    DataOffset;
        DWORD    DataSelector;
        BYTE[80] RegisterArea;
        DWORD    Cr0NpxState;
    }

    struct CONTEXT {
        DWORD ContextFlags;
        DWORD Dr0;
        DWORD Dr1;
        DWORD Dr2;
        DWORD Dr3;
        DWORD Dr6;
        DWORD Dr7;
        FLOATING_SAVE_AREA FloatSave;
        DWORD SegGs;
        DWORD SegFs;
        DWORD SegEs;
        DWORD SegDs;
        DWORD Edi;
        DWORD Esi;
        DWORD Ebx;
        DWORD Edx;
        DWORD Ecx;
        DWORD Eax;
        DWORD Ebp;
        DWORD Eip;
        DWORD SegCs;
        DWORD EFlags;
        DWORD Esp;
        DWORD SegSs;
        BYTE[MAXIMUM_SUPPORTED_EXTENSION] ExtendedRegisters;
    }

} else version (X86_64)
{
enum CONTEXT_AMD64 = 0x100000;

enum CONTEXT_CONTROL         = (CONTEXT_AMD64 | 0x1L);
enum CONTEXT_INTEGER         = (CONTEXT_AMD64 | 0x2L);
enum CONTEXT_SEGMENTS        = (CONTEXT_AMD64 | 0x4L);
enum CONTEXT_FLOATING_POINT  = (CONTEXT_AMD64 | 0x8L);
enum CONTEXT_DEBUG_REGISTERS = (CONTEXT_AMD64 | 0x10L);

enum CONTEXT_FULL = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_FLOATING_POINT);
enum CONTEXT_ALL  = (CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS);

enum CONTEXT_EXCEPTION_ACTIVE    = 0x8000000;
enum CONTEXT_SERVICE_ACTIVE      = 0x10000000;
enum CONTEXT_EXCEPTION_REQUEST   = 0x40000000;
enum CONTEXT_EXCEPTION_REPORTING = 0x80000000;

enum INITIAL_MXCSR = 0x1f80;
enum INITIAL_FPCSR = 0x027f;

    align(16) struct M128A
    {
        ULONGLONG Low;
        LONGLONG High;
    }
    alias M128A* PM128A;

    struct XMM_SAVE_AREA32
    {
        WORD ControlWord;
        WORD StatusWord;
        BYTE TagWord;
        BYTE Reserved1;
        WORD ErrorOpcode;
        DWORD ErrorOffset;
        WORD ErrorSelector;
        WORD Reserved2;
        DWORD DataOffset;
        WORD DataSelector;
        WORD Reserved3;
        DWORD MxCsr;
        DWORD MxCsr_Mask;
        M128A[8] FloatRegisters;
        M128A[16] XmmRegisters;
        BYTE[96] Reserved4;
    }
    alias XMM_SAVE_AREA32 PXMM_SAVE_AREA32;
enum LEGACY_SAVE_AREA_LENGTH = XMM_SAVE_AREA32.sizeof;

    align(16) struct CONTEXT
    {
        DWORD64 P1Home;
        DWORD64 P2Home;
        DWORD64 P3Home;
        DWORD64 P4Home;
        DWORD64 P5Home;
        DWORD64 P6Home;
        DWORD ContextFlags;
        DWORD MxCsr;
        WORD SegCs;
        WORD SegDs;
        WORD SegEs;
        WORD SegFs;
        WORD SegGs;
        WORD SegSs;
        DWORD EFlags;
        DWORD64 Dr0;
        DWORD64 Dr1;
        DWORD64 Dr2;
        DWORD64 Dr3;
        DWORD64 Dr6;
        DWORD64 Dr7;
        DWORD64 Rax;
        DWORD64 Rcx;
        DWORD64 Rdx;
        DWORD64 Rbx;
        DWORD64 Rsp;
        DWORD64 Rbp;
        DWORD64 Rsi;
        DWORD64 Rdi;
        DWORD64 R8;
        DWORD64 R9;
        DWORD64 R10;
        DWORD64 R11;
        DWORD64 R12;
        DWORD64 R13;
        DWORD64 R14;
        DWORD64 R15;
        DWORD64 Rip;
        union
        {
            XMM_SAVE_AREA32 FltSave;
            XMM_SAVE_AREA32 FloatSave;
            struct
            {
                M128A[2] Header;
                M128A[8] Legacy;
                M128A Xmm0;
                M128A Xmm1;
                M128A Xmm2;
                M128A Xmm3;
                M128A Xmm4;
                M128A Xmm5;
                M128A Xmm6;
                M128A Xmm7;
                M128A Xmm8;
                M128A Xmm9;
                M128A Xmm10;
                M128A Xmm11;
                M128A Xmm12;
                M128A Xmm13;
                M128A Xmm14;
                M128A Xmm15;
            };
        };
        M128A[26] VectorRegister;
        DWORD64 VectorControl;
        DWORD64 DebugControl;
        DWORD64 LastBranchToRip;
        DWORD64 LastBranchFromRip;
        DWORD64 LastExceptionToRip;
        DWORD64 LastExceptionFromRip;
    }

} else {
    static assert(false, "Unsupported CPU");
    // Versions for PowerPC, Alpha, SHX, and MIPS removed.
}

alias CONTEXT* PCONTEXT, LPCONTEXT;

struct EXCEPTION_RECORD {
    DWORD ExceptionCode;
    DWORD ExceptionFlags;
    EXCEPTION_RECORD* ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR[EXCEPTION_MAXIMUM_PARAMETERS] ExceptionInformation;
}
alias EXCEPTION_RECORD* PEXCEPTION_RECORD, LPEXCEPTION_RECORD;

struct EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT          ContextRecord;
}
alias EXCEPTION_POINTERS* PEXCEPTION_POINTERS, LPEXCEPTION_POINTERS;

union LARGE_INTEGER {
    struct {
        uint LowPart;
        int  HighPart;
    }
    long QuadPart;
}
alias LARGE_INTEGER* PLARGE_INTEGER;

union ULARGE_INTEGER {
    struct {
        uint LowPart;
        uint HighPart;
    }
    ulong QuadPart;
}
alias ULARGE_INTEGER* PULARGE_INTEGER;

alias LARGE_INTEGER LUID;
alias LUID* PLUID;

enum LUID SYSTEM_LUID = { QuadPart:999 };

align(4) struct LUID_AND_ATTRIBUTES {
    LUID  Luid;
    DWORD Attributes;
}
alias LUID_AND_ATTRIBUTES* PLUID_AND_ATTRIBUTES;

align(4) struct PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES _Privilege;

    LUID_AND_ATTRIBUTES* Privilege() return { return &_Privilege; }
}
alias PRIVILEGE_SET* PPRIVILEGE_SET;

struct SECURITY_ATTRIBUTES {
    DWORD  nLength;
    LPVOID lpSecurityDescriptor;
    BOOL   bInheritHandle;
}
alias SECURITY_ATTRIBUTES* PSECURITY_ATTRIBUTES, LPSECURITY_ATTRIBUTES;

struct SECURITY_QUALITY_OF_SERVICE {
    DWORD   Length;
    SECURITY_IMPERSONATION_LEVEL   ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
}
alias SECURITY_QUALITY_OF_SERVICE* PSECURITY_QUALITY_OF_SERVICE;

alias PVOID PACCESS_TOKEN;

struct SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN       CopyOnOpen;
    BOOLEAN       EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
}
alias SE_IMPERSONATION_STATE* PSE_IMPERSONATION_STATE;

struct SID_IDENTIFIER_AUTHORITY {
    BYTE[6] Value;
}
alias SID_IDENTIFIER_AUTHORITY* PSID_IDENTIFIER_AUTHORITY, LPSID_IDENTIFIER_AUTHORITY;

alias PVOID PSID;

struct SID {
    BYTE  Revision;
    BYTE  SubAuthorityCount;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    DWORD _SubAuthority;

    DWORD* SubAuthority() return { return &_SubAuthority; }
}
alias SID* PISID;

struct SID_AND_ATTRIBUTES {
    PSID  Sid;
    DWORD Attributes;
}
alias SID_AND_ATTRIBUTES* PSID_AND_ATTRIBUTES;

struct TOKEN_SOURCE {
    CHAR[TOKEN_SOURCE_LENGTH] SourceName = 0;
    LUID SourceIdentifier;
}
alias TOKEN_SOURCE* PTOKEN_SOURCE;

struct TOKEN_CONTROL {
    LUID         TokenId;
    LUID         AuthenticationId;
    LUID         ModifiedId;
    TOKEN_SOURCE TokenSource;
}
alias TOKEN_CONTROL* PTOKEN_CONTROL;

struct TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
}
alias TOKEN_DEFAULT_DACL* PTOKEN_DEFAULT_DACL;

struct TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES _Groups;

    SID_AND_ATTRIBUTES* Groups() return { return &_Groups; }
}
alias TOKEN_GROUPS* PTOKEN_GROUPS, LPTOKEN_GROUPS;

struct TOKEN_OWNER {
    PSID Owner;
}
alias TOKEN_OWNER* PTOKEN_OWNER;

struct TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
}
alias TOKEN_PRIMARY_GROUP* PTOKEN_PRIMARY_GROUP;

struct TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES _Privileges;

    LUID_AND_ATTRIBUTES* Privileges() return { return &_Privileges; }
}
alias TOKEN_PRIVILEGES* PTOKEN_PRIVILEGES, LPTOKEN_PRIVILEGES;

enum TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
}
alias TOKEN_TYPE* PTOKEN_TYPE;

struct TOKEN_STATISTICS {
    LUID          TokenId;
    LUID          AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE    TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD         DynamicCharged;
    DWORD         DynamicAvailable;
    DWORD         GroupCount;
    DWORD         PrivilegeCount;
    LUID          ModifiedId;
}
alias TOKEN_STATISTICS* PTOKEN_STATISTICS;

struct TOKEN_USER {
    SID_AND_ATTRIBUTES User;
}
alias TOKEN_USER* PTOKEN_USER;

alias DWORD SECURITY_INFORMATION;
alias SECURITY_INFORMATION* PSECURITY_INFORMATION;
alias WORD SECURITY_DESCRIPTOR_CONTROL;
alias SECURITY_DESCRIPTOR_CONTROL* PSECURITY_DESCRIPTOR_CONTROL;

struct SECURITY_DESCRIPTOR {
    BYTE Revision;
    BYTE Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    PSID Owner;
    PSID Group;
    PACL Sacl;
    PACL Dacl;
}
alias SECURITY_DESCRIPTOR* PSECURITY_DESCRIPTOR, PISECURITY_DESCRIPTOR;

enum TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin
}

enum SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer
}
alias SID_NAME_USE* PSID_NAME_USE;

struct QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
}
alias QUOTA_LIMITS* PQUOTA_LIMITS;

struct IO_COUNTERS {
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
}
alias IO_COUNTERS* PIO_COUNTERS;

struct FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength = 0;
    WCHAR _FileName = 0;

    WCHAR* FileName() return { return &_FileName; }
}
alias FILE_NOTIFY_INFORMATION* PFILE_NOTIFY_INFORMATION;

struct TAPE_ERASE {
    DWORD   Type;
    BOOLEAN Immediate;
}
alias TAPE_ERASE* PTAPE_ERASE;

struct TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD   DefaultBlockSize;
    DWORD   MaximumBlockSize;
    DWORD   MinimumBlockSize;
    DWORD   MaximumPartitionCount;
    DWORD   FeaturesLow;
    DWORD   FeaturesHigh;
    DWORD   EOTWarningZoneSize;
}
alias TAPE_GET_DRIVE_PARAMETERS* PTAPE_GET_DRIVE_PARAMETERS;

struct TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD         BlockSize;
    DWORD         PartitionCount;
    BOOLEAN       WriteProtected;
}
alias TAPE_GET_MEDIA_PARAMETERS* PTAPE_GET_MEDIA_PARAMETERS;

struct TAPE_GET_POSITION {
    ULONG Type;
    ULONG Partition;
    ULONG OffsetLow;
    ULONG OffsetHigh;
}
alias TAPE_GET_POSITION* PTAPE_GET_POSITION;

struct TAPE_PREPARE {
    DWORD   Operation;
    BOOLEAN Immediate;
}
alias TAPE_PREPARE* PTAPE_PREPARE;

struct TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG   EOTWarningZoneSize;
}
alias TAPE_SET_DRIVE_PARAMETERS* PTAPE_SET_DRIVE_PARAMETERS;

struct TAPE_SET_MEDIA_PARAMETERS {
    ULONG BlockSize;
}
alias TAPE_SET_MEDIA_PARAMETERS* PTAPE_SET_MEDIA_PARAMETERS;

struct TAPE_SET_POSITION {
    DWORD         Method;
    DWORD         Partition;
    LARGE_INTEGER Offset;
    BOOLEAN       Immediate;
}
alias TAPE_SET_POSITION* PTAPE_SET_POSITION;

struct TAPE_WRITE_MARKS {
    DWORD   Type;
    DWORD   Count;
    BOOLEAN Immediate;
}
alias TAPE_WRITE_MARKS* PTAPE_WRITE_MARKS;

struct TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
}
alias TAPE_CREATE_PARTITION* PTAPE_CREATE_PARTITION;

struct MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
}
alias MEMORY_BASIC_INFORMATION* PMEMORY_BASIC_INFORMATION;

struct MESSAGE_RESOURCE_ENTRY {
    WORD Length;
    WORD Flags;
    BYTE _Text;

    BYTE* Text() return { return &_Text; }
}
alias MESSAGE_RESOURCE_ENTRY* PMESSAGE_RESOURCE_ENTRY;

struct MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
}
alias MESSAGE_RESOURCE_BLOCK* PMESSAGE_RESOURCE_BLOCK;

struct MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK _Blocks;

    MESSAGE_RESOURCE_BLOCK* Blocks() return { return &_Blocks; }
}
alias MESSAGE_RESOURCE_DATA* PMESSAGE_RESOURCE_DATA;

struct LIST_ENTRY {
    LIST_ENTRY* Flink;
    LIST_ENTRY* Blink;
}
alias LIST_ENTRY* PLIST_ENTRY;
alias LIST_ENTRY _LIST_ENTRY;

struct SINGLE_LIST_ENTRY {
    SINGLE_LIST_ENTRY* Next;
}

version (Win64) {
    align (16)
    struct SLIST_ENTRY {
        SLIST_ENTRY* Next;
    }
} else {
    alias SINGLE_LIST_ENTRY SLIST_ENTRY;
}
alias SINGLE_LIST_ENTRY* PSINGLE_LIST_ENTRY, PSLIST_ENTRY;

union SLIST_HEADER {
    ULONGLONG       Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD        Depth;
        WORD        Sequence;
    }
}
alias SLIST_HEADER* PSLIST_HEADER;

struct RTL_CRITICAL_SECTION_DEBUG {
    WORD       Type;
    WORD       CreatorBackTraceIndex;
    RTL_CRITICAL_SECTION* CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD      EntryCount;
    DWORD      ContentionCount;
    DWORD[2]   Spare;
}
alias RTL_CRITICAL_SECTION_DEBUG* PRTL_CRITICAL_SECTION_DEBUG;
alias RTL_CRITICAL_SECTION_DEBUG _RTL_CRITICAL_SECTION_DEBUG;

struct RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
    LONG   LockCount;
    LONG   RecursionCount;
    HANDLE OwningThread;
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;
    alias Reserved = SpinCount;
}
alias RTL_CRITICAL_SECTION* PRTL_CRITICAL_SECTION;
alias RTL_CRITICAL_SECTION _RTL_CRITICAL_SECTION;

struct EVENTLOGRECORD {
    DWORD Length;
    DWORD Reserved;
    DWORD RecordNumber;
    DWORD TimeGenerated;
    DWORD TimeWritten;
    DWORD EventID;
    WORD  EventType;
    WORD  NumStrings;
    WORD  EventCategory;
    WORD  ReservedFlags;
    DWORD ClosingRecordNumber;
    DWORD StringOffset;
    DWORD UserSidLength;
    DWORD UserSidOffset;
    DWORD DataLength;
    DWORD DataOffset;
}
alias EVENTLOGRECORD* PEVENTLOGRECORD;

struct OSVERSIONINFOA {
    DWORD     dwOSVersionInfoSize = OSVERSIONINFOA.sizeof;
    DWORD     dwMajorVersion;
    DWORD     dwMinorVersion;
    DWORD     dwBuildNumber;
    DWORD     dwPlatformId;
    CHAR[128] szCSDVersion = 0;
}
alias OSVERSIONINFOA* POSVERSIONINFOA, LPOSVERSIONINFOA;

struct OSVERSIONINFOW {
    DWORD      dwOSVersionInfoSize = OSVERSIONINFOW.sizeof;
    DWORD      dwMajorVersion;
    DWORD      dwMinorVersion;
    DWORD      dwBuildNumber;
    DWORD      dwPlatformId;
    WCHAR[128] szCSDVersion = 0;
}
alias OSVERSIONINFOW* POSVERSIONINFOW, LPOSVERSIONINFOW;

struct OSVERSIONINFOEXA {
    DWORD     dwOSVersionInfoSize;
    DWORD     dwMajorVersion;
    DWORD     dwMinorVersion;
    DWORD     dwBuildNumber;
    DWORD     dwPlatformId;
    CHAR[128] szCSDVersion = 0;
    WORD      wServicePackMajor;
    WORD      wServicePackMinor;
    WORD      wSuiteMask;
    BYTE      wProductType;
    BYTE      wReserved;
}
alias OSVERSIONINFOEXA* POSVERSIONINFOEXA, LPOSVERSIONINFOEXA;

struct OSVERSIONINFOEXW {
    DWORD      dwOSVersionInfoSize;
    DWORD      dwMajorVersion;
    DWORD      dwMinorVersion;
    DWORD      dwBuildNumber;
    DWORD      dwPlatformId;
    WCHAR[128] szCSDVersion = 0;
    WORD       wServicePackMajor;
    WORD       wServicePackMinor;
    WORD       wSuiteMask;
    BYTE       wProductType;
    BYTE       wReserved;
}
alias OSVERSIONINFOEXW* POSVERSIONINFOEXW, LPOSVERSIONINFOEXW;

align(2) struct IMAGE_VXD_HEADER {
    WORD     e32_magic;
    BYTE     e32_border;
    BYTE     e32_worder;
    DWORD    e32_level;
    WORD     e32_cpu;
    WORD     e32_os;
    DWORD    e32_ver;
    DWORD    e32_mflags;
    DWORD    e32_mpages;
    DWORD    e32_startobj;
    DWORD    e32_eip;
    DWORD    e32_stackobj;
    DWORD    e32_esp;
    DWORD    e32_pagesize;
    DWORD    e32_lastpagesize;
    DWORD    e32_fixupsize;
    DWORD    e32_fixupsum;
    DWORD    e32_ldrsize;
    DWORD    e32_ldrsum;
    DWORD    e32_objtab;
    DWORD    e32_objcnt;
    DWORD    e32_objmap;
    DWORD    e32_itermap;
    DWORD    e32_rsrctab;
    DWORD    e32_rsrccnt;
    DWORD    e32_restab;
    DWORD    e32_enttab;
    DWORD    e32_dirtab;
    DWORD    e32_dircnt;
    DWORD    e32_fpagetab;
    DWORD    e32_frectab;
    DWORD    e32_impmod;
    DWORD    e32_impmodcnt;
    DWORD    e32_impproc;
    DWORD    e32_pagesum;
    DWORD    e32_datapage;
    DWORD    e32_preload;
    DWORD    e32_nrestab;
    DWORD    e32_cbnrestab;
    DWORD    e32_nressum;
    DWORD    e32_autodata;
    DWORD    e32_debuginfo;
    DWORD    e32_debuglen;
    DWORD    e32_instpreload;
    DWORD    e32_instdemand;
    DWORD    e32_heapsize;
    BYTE[12] e32_res3;
    DWORD    e32_winresoff;
    DWORD    e32_winreslen;
    WORD     e32_devid;
    WORD     e32_ddkver;
}
alias IMAGE_VXD_HEADER* PIMAGE_VXD_HEADER;

align(4):
struct IMAGE_FILE_HEADER {
    WORD  Machine;
    WORD  NumberOfSections;
    DWORD TimeDateStamp;
    DWORD PointerToSymbolTable;
    DWORD NumberOfSymbols;
    WORD  SizeOfOptionalHeader;
    WORD  Characteristics;
}
alias IMAGE_FILE_HEADER* PIMAGE_FILE_HEADER;
// const IMAGE_SIZEOF_FILE_HEADER = IMAGE_FILE_HEADER.sizeof;

struct IMAGE_DATA_DIRECTORY {
    DWORD VirtualAddress;
    DWORD Size;
}
alias IMAGE_DATA_DIRECTORY* PIMAGE_DATA_DIRECTORY;

struct IMAGE_OPTIONAL_HEADER32 {
    WORD  Magic;
    BYTE  MajorLinkerVersion;
    BYTE  MinorLinkerVersion;
    DWORD SizeOfCode;
    DWORD SizeOfInitializedData;
    DWORD SizeOfUninitializedData;
    DWORD AddressOfEntryPoint;
    DWORD BaseOfCode;
    DWORD BaseOfData;
    DWORD ImageBase;
    DWORD SectionAlignment;
    DWORD FileAlignment;
    WORD  MajorOperatingSystemVersion;
    WORD  MinorOperatingSystemVersion;
    WORD  MajorImageVersion;
    WORD  MinorImageVersion;
    WORD  MajorSubsystemVersion;
    WORD  MinorSubsystemVersion;
    DWORD Win32VersionValue;
    DWORD SizeOfImage;
    DWORD SizeOfHeaders;
    DWORD CheckSum;
    WORD  Subsystem;
    WORD  DllCharacteristics;
    DWORD SizeOfStackReserve;
    DWORD SizeOfStackCommit;
    DWORD SizeOfHeapReserve;
    DWORD SizeOfHeapCommit;
    DWORD LoaderFlags;
    DWORD NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] DataDirectory;
}
alias IMAGE_OPTIONAL_HEADER32* PIMAGE_OPTIONAL_HEADER32;

struct IMAGE_OPTIONAL_HEADER64 {
    WORD      Magic;
    BYTE      MajorLinkerVersion;
    BYTE      MinorLinkerVersion;
    DWORD     SizeOfCode;
    DWORD     SizeOfInitializedData;
    DWORD     SizeOfUninitializedData;
    DWORD     AddressOfEntryPoint;
    DWORD     BaseOfCode;
    ULONGLONG ImageBase;
    DWORD     SectionAlignment;
    DWORD     FileAlignment;
    WORD      MajorOperatingSystemVersion;
    WORD      MinorOperatingSystemVersion;
    WORD      MajorImageVersion;
    WORD      MinorImageVersion;
    WORD      MajorSubsystemVersion;
    WORD      MinorSubsystemVersion;
    DWORD     Win32VersionValue;
    DWORD     SizeOfImage;
    DWORD     SizeOfHeaders;
    DWORD     CheckSum;
    WORD      Subsystem;
    WORD      DllCharacteristics;
    ULONGLONG SizeOfStackReserve;
    ULONGLONG SizeOfStackCommit;
    ULONGLONG SizeOfHeapReserve;
    ULONGLONG SizeOfHeapCommit;
    DWORD     LoaderFlags;
    DWORD     NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] DataDirectory;
}
alias IMAGE_OPTIONAL_HEADER64* PIMAGE_OPTIONAL_HEADER64;

struct IMAGE_ROM_OPTIONAL_HEADER {
    WORD     Magic;
    BYTE     MajorLinkerVersion;
    BYTE     MinorLinkerVersion;
    DWORD    SizeOfCode;
    DWORD    SizeOfInitializedData;
    DWORD    SizeOfUninitializedData;
    DWORD    AddressOfEntryPoint;
    DWORD    BaseOfCode;
    DWORD    BaseOfData;
    DWORD    BaseOfBss;
    DWORD    GprMask;
    DWORD[4] CprMask;
    DWORD    GpValue;
}
alias IMAGE_ROM_OPTIONAL_HEADER* PIMAGE_ROM_OPTIONAL_HEADER;

align(2):
struct IMAGE_DOS_HEADER {
    WORD     e_magic;
    WORD     e_cblp;
    WORD     e_cp;
    WORD     e_crlc;
    WORD     e_cparhdr;
    WORD     e_minalloc;
    WORD     e_maxalloc;
    WORD     e_ss;
    WORD     e_sp;
    WORD     e_csum;
    WORD     e_ip;
    WORD     e_cs;
    WORD     e_lfarlc;
    WORD     e_ovno;
    WORD[4] e_res;
    WORD     e_oemid;
    WORD     e_oeminfo;
    WORD[10] e_res2;
    LONG     e_lfanew;
}
alias IMAGE_DOS_HEADER* PIMAGE_DOS_HEADER;

struct IMAGE_OS2_HEADER {
    WORD ne_magic;
    CHAR ne_ver = 0;
    CHAR ne_rev = 0;
    WORD ne_enttab;
    WORD ne_cbenttab;
    LONG ne_crc;
    WORD ne_flags;
    WORD ne_autodata;
    WORD ne_heap;
    WORD ne_stack;
    LONG ne_csip;
    LONG ne_sssp;
    WORD ne_cseg;
    WORD ne_cmod;
    WORD ne_cbnrestab;
    WORD ne_segtab;
    WORD ne_rsrctab;
    WORD ne_restab;
    WORD ne_modtab;
    WORD ne_imptab;
    LONG ne_nrestab;
    WORD ne_cmovent;
    WORD ne_align;
    WORD ne_cres;
    BYTE ne_exetyp;
    BYTE ne_flagsothers;
    WORD ne_pretthunks;
    WORD ne_psegrefbytes;
    WORD ne_swaparea;
    WORD ne_expver;
}
alias IMAGE_OS2_HEADER* PIMAGE_OS2_HEADER;

align(4) struct IMAGE_NT_HEADERS32 {
    DWORD                 Signature;
    IMAGE_FILE_HEADER     FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
}
alias IMAGE_NT_HEADERS32* PIMAGE_NT_HEADERS32;

align(4) struct IMAGE_NT_HEADERS64 {
    DWORD                 Signature;
    IMAGE_FILE_HEADER     FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
}
alias IMAGE_NT_HEADERS64* PIMAGE_NT_HEADERS64;

struct IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER         FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
}
alias IMAGE_ROM_HEADERS* PIMAGE_ROM_HEADERS;

struct IMAGE_SECTION_HEADER {
    BYTE[IMAGE_SIZEOF_SHORT_NAME] Name;
    union _Misc {
        DWORD PhysicalAddress;
        DWORD VirtualSize;
    }
    _Misc Misc;
    DWORD VirtualAddress;
    DWORD SizeOfRawData;
    DWORD PointerToRawData;
    DWORD PointerToRelocations;
    DWORD PointerToLinenumbers;
    WORD  NumberOfRelocations;
    WORD  NumberOfLinenumbers;
    DWORD Characteristics;
}
alias IMAGE_SECTION_HEADER* PIMAGE_SECTION_HEADER;

struct IMAGE_SYMBOL {
    union _N {
        BYTE[8]   ShortName;
        struct _Name {
            DWORD Short;
            DWORD Long;
        }
        _Name Name;
        DWORD[2]  LongName; // PBYTE[2]
    }
    _N    N;
    DWORD Value;
    SHORT SectionNumber;
    WORD  Type;
    BYTE  StorageClass;
    BYTE  NumberOfAuxSymbols;
}
alias IMAGE_SYMBOL* PIMAGE_SYMBOL;

union IMAGE_AUX_SYMBOL {
    struct _Sym {
        DWORD           TagIndex;
        union _Misc {
            struct _LnSz {
                WORD    Linenumber;
                WORD    Size;
            }
            _LnSz       LnSz;
            DWORD       TotalSize;
        }
        _Misc Misc;
        union _FcnAry {
            struct _Function {
                DWORD   PointerToLinenumber;
                DWORD   PointerToNextFunction;
            }
            _Function   Function;
            struct _Array {
                WORD[4] Dimension;
            }
            _Array      Array;
        }
        _FcnAry         FcnAry;
        WORD            TvIndex;
    }
    _Sym                Sym;
    struct _File {
        BYTE[IMAGE_SIZEOF_SYMBOL] Name;
    }
    _File               File;
    struct _Section {
        DWORD           Length;
        WORD            NumberOfRelocations;
        WORD            NumberOfLinenumbers;
        DWORD           CheckSum;
        SHORT           Number;
        BYTE            Selection;
    }
    _Section            Section;
}
alias IMAGE_AUX_SYMBOL* PIMAGE_AUX_SYMBOL;

struct IMAGE_COFF_SYMBOLS_HEADER {
    DWORD NumberOfSymbols;
    DWORD LvaToFirstSymbol;
    DWORD NumberOfLinenumbers;
    DWORD LvaToFirstLinenumber;
    DWORD RvaToFirstByteOfCode;
    DWORD RvaToLastByteOfCode;
    DWORD RvaToFirstByteOfData;
    DWORD RvaToLastByteOfData;
}
alias IMAGE_COFF_SYMBOLS_HEADER* PIMAGE_COFF_SYMBOLS_HEADER;

struct IMAGE_RELOCATION {
    union {
        DWORD VirtualAddress;
        DWORD RelocCount;
    }
    DWORD     SymbolTableIndex;
    WORD      Type;
}
alias IMAGE_RELOCATION* PIMAGE_RELOCATION;

align(4) struct IMAGE_BASE_RELOCATION {
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
}
alias IMAGE_BASE_RELOCATION* PIMAGE_BASE_RELOCATION;

align(2) struct IMAGE_LINENUMBER {
    union _Type {
        DWORD SymbolTableIndex;
        DWORD VirtualAddress;
    }
    _Type Type;
    WORD  Linenumber;
}
alias IMAGE_LINENUMBER* PIMAGE_LINENUMBER;

align(4):
struct IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE[16] Name;
    BYTE[12] Date;
    BYTE[6]  UserID;
    BYTE[6]  GroupID;
    BYTE[8]  Mode;
    BYTE[10] Size;
    BYTE[2]  EndHeader;
}
alias IMAGE_ARCHIVE_MEMBER_HEADER* PIMAGE_ARCHIVE_MEMBER_HEADER;

struct IMAGE_EXPORT_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Name;
    DWORD Base;
    DWORD NumberOfFunctions;
    DWORD NumberOfNames;
    DWORD AddressOfFunctions;
    DWORD AddressOfNames;
    DWORD AddressOfNameOrdinals;
}
alias IMAGE_EXPORT_DIRECTORY* PIMAGE_EXPORT_DIRECTORY;

struct IMAGE_IMPORT_BY_NAME {
    WORD Hint;
    BYTE _Name;

    BYTE* Name() return { return &_Name; }
}
alias IMAGE_IMPORT_BY_NAME* PIMAGE_IMPORT_BY_NAME;

struct IMAGE_THUNK_DATA32 {
    union _u1 {
        DWORD ForwarderString;
        DWORD Function;
        DWORD Ordinal;
        DWORD AddressOfData;
    }
    _u1 u1;
}
alias IMAGE_THUNK_DATA32* PIMAGE_THUNK_DATA32;

struct IMAGE_THUNK_DATA64 {
    union _u1 {
        ULONGLONG ForwarderString;
        ULONGLONG Function;
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;
    }
    _u1 u1;
}
alias IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;

struct IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD Characteristics;
        DWORD OriginalFirstThunk;
    }
    DWORD TimeDateStamp;
    DWORD ForwarderChain;
    DWORD Name;
    DWORD FirstThunk;
}
alias IMAGE_IMPORT_DESCRIPTOR* PIMAGE_IMPORT_DESCRIPTOR;

struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD TimeDateStamp;
    WORD  OffsetModuleName;
    WORD  NumberOfModuleForwarderRefs;
}
alias IMAGE_BOUND_IMPORT_DESCRIPTOR* PIMAGE_BOUND_IMPORT_DESCRIPTOR;

struct IMAGE_BOUND_FORWARDER_REF {
    DWORD TimeDateStamp;
    WORD  OffsetModuleName;
    WORD  Reserved;
}
alias IMAGE_BOUND_FORWARDER_REF* PIMAGE_BOUND_FORWARDER_REF;

struct IMAGE_TLS_DIRECTORY32 {
    DWORD StartAddressOfRawData;
    DWORD EndAddressOfRawData;
    DWORD AddressOfIndex;
    DWORD AddressOfCallBacks;
    DWORD SizeOfZeroFill;
    DWORD Characteristics;
}
alias IMAGE_TLS_DIRECTORY32* PIMAGE_TLS_DIRECTORY32;

struct IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;
    ULONGLONG AddressOfCallBacks;
    DWORD     SizeOfZeroFill;
    DWORD     Characteristics;
}
alias IMAGE_TLS_DIRECTORY64* PIMAGE_TLS_DIRECTORY64;

struct IMAGE_RESOURCE_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    WORD  NumberOfNamedEntries;
    WORD  NumberOfIdEntries;
}
alias IMAGE_RESOURCE_DIRECTORY* PIMAGE_RESOURCE_DIRECTORY;

struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        /+struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        }+/
        DWORD Name;
        WORD Id;
    }
    DWORD OffsetToData;
        /+struct {
            DWORD OffsetToDirectory:31;
            DWORD DataIsDirectory:1;
        }+/

    uint NameOffset()        { return Name & 0x7FFFFFFF; }
    bool NameIsString()      { return cast(bool)(Name & 0x80000000); }
    uint OffsetToDirectory() { return OffsetToData & 0x7FFFFFFF; }
    bool DataIsDirectory()   { return cast(bool)(OffsetToData & 0x80000000); }

    uint NameOffset(uint n) {
        Name = (Name & 0x80000000) | (n & 0x7FFFFFFF);
        return n & 0x7FFFFFFF;
    }

    bool NameIsString(bool n) {
        Name = (Name & 0x7FFFFFFF) | (n << 31); return n;
    }

    uint OffsetToDirectory(uint o) {
        OffsetToData = (OffsetToData & 0x80000000) | (o & 0x7FFFFFFF);
        return o & 0x7FFFFFFF;
    }

    bool DataIsDirectory(bool d) {
        OffsetToData = (OffsetToData & 0x7FFFFFFF) | (d << 31); return d;
    }
}
alias IMAGE_RESOURCE_DIRECTORY_ENTRY* PIMAGE_RESOURCE_DIRECTORY_ENTRY;

struct IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD Length;
    CHAR _NameString = 0;

    CHAR* NameString() return { return &_NameString; }
}
alias IMAGE_RESOURCE_DIRECTORY_STRING* PIMAGE_RESOURCE_DIRECTORY_STRING;

struct IMAGE_RESOURCE_DIR_STRING_U {
    WORD  Length;
    WCHAR _NameString = 0;

    WCHAR* NameString() return { return &_NameString; }
}
alias IMAGE_RESOURCE_DIR_STRING_U* PIMAGE_RESOURCE_DIR_STRING_U;

struct IMAGE_RESOURCE_DATA_ENTRY {
    DWORD OffsetToData;
    DWORD Size;
    DWORD CodePage;
    DWORD Reserved;
}
alias IMAGE_RESOURCE_DATA_ENTRY* PIMAGE_RESOURCE_DATA_ENTRY;

struct IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD    Characteristics;
    DWORD    TimeDateStamp;
    WORD     MajorVersion;
    WORD     MinorVersion;
    DWORD    GlobalFlagsClear;
    DWORD    GlobalFlagsSet;
    DWORD    CriticalSectionDefaultTimeout;
    DWORD    DeCommitFreeBlockThreshold;
    DWORD    DeCommitTotalFreeThreshold;
    PVOID    LockPrefixTable;
    DWORD    MaximumAllocationSize;
    DWORD    VirtualMemoryThreshold;
    DWORD    ProcessHeapFlags;
    DWORD[4] Reserved;
}
alias IMAGE_LOAD_CONFIG_DIRECTORY32* PIMAGE_LOAD_CONFIG_DIRECTORY32;

struct IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD     Characteristics;
    DWORD     TimeDateStamp;
    WORD      MajorVersion;
    WORD      MinorVersion;
    DWORD     GlobalFlagsClear;
    DWORD     GlobalFlagsSet;
    DWORD     CriticalSectionDefaultTimeout;
    ULONGLONG DeCommitFreeBlockThreshold;
    ULONGLONG DeCommitTotalFreeThreshold;
    ULONGLONG LockPrefixTable;
    ULONGLONG MaximumAllocationSize;
    ULONGLONG VirtualMemoryThreshold;
    ULONGLONG ProcessAffinityMask;
    DWORD     ProcessHeapFlags;
    WORD      CSDFlags;
    WORD      Reserved1;
    ULONGLONG EditList;
    DWORD[2]  Reserved;
}
alias IMAGE_LOAD_CONFIG_DIRECTORY64* PIMAGE_LOAD_CONFIG_DIRECTORY64;

version (Win64) {
    alias IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
} else {
    alias IMAGE_LOAD_CONFIG_DIRECTORY32 IMAGE_LOAD_CONFIG_DIRECTORY;
}
alias IMAGE_LOAD_CONFIG_DIRECTORY* PIMAGE_LOAD_CONFIG_DIRECTORY;

// Note versions for Alpha, Alpha64, ARM removed.
struct IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    }
}
alias IMAGE_RUNTIME_FUNCTION_ENTRY* PIMAGE_RUNTIME_FUNCTION_ENTRY;

struct IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    uint      FuncStart;
    union {
        ubyte PrologLen;
        uint  _bf;
    }
/+
    unsigned int FuncLen:22;
    unsigned int ThirtyTwoBit:1;
    unsigned int ExceptionFlag:1;
+/
    uint FuncLen()       { return (_bf >> 8) & 0x3FFFFF; }
    bool ThirtyTwoBit()  { return cast(bool)(_bf & 0x40000000); }
    bool ExceptionFlag() { return cast(bool)(_bf & 0x80000000); }

    uint FuncLen(uint f) {
        _bf = (_bf & ~0x3FFFFF00) | ((f & 0x3FFFFF) << 8); return f & 0x3FFFFF;
    }

    bool ThirtyTwoBit(bool t) {
        _bf = (_bf & ~0x40000000) | (t << 30); return t;
    }

    bool ExceptionFlag(bool e) {
        _bf = (_bf & ~0x80000000) | (e << 31); return e;
    }
}
alias IMAGE_CE_RUNTIME_FUNCTION_ENTRY* PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

struct IMAGE_DEBUG_DIRECTORY {
    DWORD Characteristics;
    DWORD TimeDateStamp;
    WORD  MajorVersion;
    WORD  MinorVersion;
    DWORD Type;
    DWORD SizeOfData;
    DWORD AddressOfRawData;
    DWORD PointerToRawData;
}
alias IMAGE_DEBUG_DIRECTORY* PIMAGE_DEBUG_DIRECTORY;

struct FPO_DATA {
    DWORD  ulOffStart;
    DWORD  cbProcSize;
    DWORD  cdwLocals;
    WORD   cdwParams;
    ubyte  cbProlog;
    ubyte  _bf;
/+
    WORD cbRegs:3;
    WORD fHasSEH:1;
    WORD fUseBP:1;
    WORD reserved:1;
    WORD cbFrame:2;
+/
    ubyte cbRegs()  { return cast(ubyte)(_bf & 0x07); }
    bool fHasSEH()  { return cast(bool)(_bf & 0x08); }
    bool fUseBP()   { return cast(bool)(_bf & 0x10); }
    bool reserved() { return cast(bool)(_bf & 0x20); }
    ubyte cbFrame() { return cast(ubyte)(_bf >> 6); }

    ubyte cbRegs(ubyte c) {
        _bf = cast(ubyte) ((_bf & ~0x07) | (c & 0x07));
        return cast(ubyte)(c & 0x07);
    }

    bool fHasSEH(bool f)  { _bf = cast(ubyte)((_bf & ~0x08) | (f << 3)); return f; }
    bool fUseBP(bool f)   { _bf = cast(ubyte)((_bf & ~0x10) | (f << 4)); return f; }
    bool reserved(bool r) { _bf = cast(ubyte)((_bf & ~0x20) | (r << 5)); return r; }

    ubyte cbFrame(ubyte c) {
        _bf = cast(ubyte) ((_bf & ~0xC0) | ((c & 0x03) << 6));
        return cast(ubyte)(c & 0x03);
    }
}
alias FPO_DATA* PFPO_DATA;

struct IMAGE_DEBUG_MISC {
    DWORD   DataType;
    DWORD   Length;
    BOOLEAN Unicode;
    BYTE[3] Reserved;
    BYTE    _Data;

    BYTE*   Data() return { return &_Data; }
}
alias IMAGE_DEBUG_MISC* PIMAGE_DEBUG_MISC;

struct IMAGE_FUNCTION_ENTRY {
    DWORD StartingAddress;
    DWORD EndingAddress;
    DWORD EndOfPrologue;
}
alias IMAGE_FUNCTION_ENTRY* PIMAGE_FUNCTION_ENTRY;

struct IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG     StartingAddress;
    ULONGLONG     EndingAddress;
    union {
        ULONGLONG EndOfPrologue;
        ULONGLONG UnwindInfoAddress;
    }
}
alias IMAGE_FUNCTION_ENTRY64* PIMAGE_FUNCTION_ENTRY64;

struct IMAGE_SEPARATE_DEBUG_HEADER {
    WORD     Signature;
    WORD     Flags;
    WORD     Machine;
    WORD     Characteristics;
    DWORD    TimeDateStamp;
    DWORD    CheckSum;
    DWORD    ImageBase;
    DWORD    SizeOfImage;
    DWORD    NumberOfSections;
    DWORD    ExportedNamesSize;
    DWORD    DebugDirectorySize;
    DWORD    SectionAlignment;
    DWORD[2] Reserved;
}
alias IMAGE_SEPARATE_DEBUG_HEADER* PIMAGE_SEPARATE_DEBUG_HEADER;

enum SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
}

enum SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
}

enum SERVICE_ERROR_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
}
alias SERVICE_ERROR_TYPE _CM_ERROR_CONTROL_TYPE;

//DAC: According to MSJ, 'UnderTheHood', May 1996, this
// structure is not documented in any official Microsoft header file.
alias void EXCEPTION_REGISTRATION_RECORD;

align:
struct NT_TIB {
    EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        DWORD Version;
    }
    PVOID ArbitraryUserPointer;
    NT_TIB *Self;
}
alias NT_TIB* PNT_TIB;

struct REPARSE_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    union {
        struct _GenericReparseBuffer {
            BYTE  _DataBuffer;

            BYTE* DataBuffer() return { return &_DataBuffer; }
        }
        _GenericReparseBuffer GenericReparseBuffer;
        struct _SymbolicLinkReparseBuffer {
            WORD  SubstituteNameOffset;
            WORD  SubstituteNameLength;
            WORD  PrintNameOffset;
            WORD  PrintNameLength;
            // ??? This is in MinGW, but absent in MSDN docs
            ULONG Flags;
            WCHAR _PathBuffer = 0;

            WCHAR* PathBuffer() return { return &_PathBuffer; }
        }
        _SymbolicLinkReparseBuffer SymbolicLinkReparseBuffer;
        struct _MountPointReparseBuffer {
            WORD  SubstituteNameOffset;
            WORD  SubstituteNameLength;
            WORD  PrintNameOffset;
            WORD  PrintNameLength;
            WCHAR _PathBuffer = 0;

            WCHAR* PathBuffer() return { return &_PathBuffer; }
        }
        _MountPointReparseBuffer MountPointReparseBuffer;
    }
}
alias REPARSE_DATA_BUFFER *PREPARSE_DATA_BUFFER;

struct REPARSE_GUID_DATA_BUFFER {
    DWORD    ReparseTag;
    WORD     ReparseDataLength;
    WORD     Reserved;
    GUID     ReparseGuid;
    struct _GenericReparseBuffer {
        BYTE _DataBuffer;

        BYTE* DataBuffer() return { return &_DataBuffer; }
    }
    _GenericReparseBuffer GenericReparseBuffer;
}
alias REPARSE_GUID_DATA_BUFFER* PREPARSE_GUID_DATA_BUFFER;

enum size_t
    REPARSE_DATA_BUFFER_HEADER_SIZE = REPARSE_DATA_BUFFER.GenericReparseBuffer.offsetof,
    REPARSE_GUID_DATA_BUFFER_HEADER_SIZE = REPARSE_GUID_DATA_BUFFER.GenericReparseBuffer.offsetof,
    MAXIMUM_REPARSE_DATA_BUFFER_SIZE = 16384;


struct REPARSE_POINT_INFORMATION {
    WORD ReparseDataLength;
    WORD UnparsedNameLength;
}
alias REPARSE_POINT_INFORMATION* PREPARSE_POINT_INFORMATION;

union FILE_SEGMENT_ELEMENT {
    PVOID64   Buffer;
    ULONGLONG Alignment;
}
alias FILE_SEGMENT_ELEMENT* PFILE_SEGMENT_ELEMENT;

// JOBOBJECT_BASIC_LIMIT_INFORMATION.LimitFlags constants
enum DWORD
    JOB_OBJECT_LIMIT_WORKINGSET                 = 0x0001,
    JOB_OBJECT_LIMIT_PROCESS_TIME               = 0x0002,
    JOB_OBJECT_LIMIT_JOB_TIME                   = 0x0004,
    JOB_OBJECT_LIMIT_ACTIVE_PROCESS             = 0x0008,
    JOB_OBJECT_LIMIT_AFFINITY                   = 0x0010,
    JOB_OBJECT_LIMIT_PRIORITY_CLASS             = 0x0020,
    JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME          = 0x0040,
    JOB_OBJECT_LIMIT_SCHEDULING_CLASS           = 0x0080,
    JOB_OBJECT_LIMIT_PROCESS_MEMORY             = 0x0100,
    JOB_OBJECT_LIMIT_JOB_MEMORY                 = 0x0200,
    JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x0400,
    JOB_OBJECT_BREAKAWAY_OK                     = 0x0800,
    JOB_OBJECT_SILENT_BREAKAWAY                 = 0x1000;

// JOBOBJECT_BASIC_UI_RESTRICTIONS.UIRestrictionsClass constants
enum DWORD
    JOB_OBJECT_UILIMIT_HANDLES          = 0x0001,
    JOB_OBJECT_UILIMIT_READCLIPBOARD    = 0x0002,
    JOB_OBJECT_UILIMIT_WRITECLIPBOARD   = 0x0004,
    JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x0008,
    JOB_OBJECT_UILIMIT_DISPLAYSETTINGS  = 0x0010,
    JOB_OBJECT_UILIMIT_GLOBALATOMS      = 0x0020,
    JOB_OBJECT_UILIMIT_DESKTOP          = 0x0040,
    JOB_OBJECT_UILIMIT_EXITWINDOWS      = 0x0080;

// JOBOBJECT_SECURITY_LIMIT_INFORMATION.SecurityLimitFlags constants
enum DWORD
    JOB_OBJECT_SECURITY_NO_ADMIN         = 0x0001,
    JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x0002,
    JOB_OBJECT_SECURITY_ONLY_TOKEN       = 0x0004,
    JOB_OBJECT_SECURITY_FILTER_TOKENS    = 0x0008;

// JOBOBJECT_END_OF_JOB_TIME_INFORMATION.EndOfJobTimeAction constants
enum : DWORD {
    JOB_OBJECT_TERMINATE_AT_END_OF_JOB,
    JOB_OBJECT_POST_AT_END_OF_JOB
}

enum : DWORD {
    JOB_OBJECT_MSG_END_OF_JOB_TIME = 1,
    JOB_OBJECT_MSG_END_OF_PROCESS_TIME,
    JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT,
    JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO,
    JOB_OBJECT_MSG_NEW_PROCESS,
    JOB_OBJECT_MSG_EXIT_PROCESS,
    JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS,
    JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT,
    JOB_OBJECT_MSG_JOB_MEMORY_LIMIT
}

enum JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    MaxJobObjectInfoClass
}

struct JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD         TotalPageFaultCount;
    DWORD         TotalProcesses;
    DWORD         ActiveProcesses;
    DWORD         TotalTerminatedProcesses;
}
alias JOBOBJECT_BASIC_ACCOUNTING_INFORMATION* PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

struct JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD         LimitFlags;
    SIZE_T        MinimumWorkingSetSize;
    SIZE_T        MaximumWorkingSetSize;
    DWORD         ActiveProcessLimit;
    ULONG_PTR     Affinity;
    DWORD         PriorityClass;
    DWORD         SchedulingClass;
}
alias JOBOBJECT_BASIC_LIMIT_INFORMATION* PJOBOBJECT_BASIC_LIMIT_INFORMATION;

struct JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD     NumberOfAssignedProcesses;
    DWORD     NumberOfProcessIdsInList;
    ULONG_PTR _ProcessIdList;

    ULONG_PTR* ProcessIdList() return { return &_ProcessIdList; }
}
alias JOBOBJECT_BASIC_PROCESS_ID_LIST* PJOBOBJECT_BASIC_PROCESS_ID_LIST;

struct JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
}
alias JOBOBJECT_BASIC_UI_RESTRICTIONS* PJOBOBJECT_BASIC_UI_RESTRICTIONS;

struct JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD             SecurityLimitFlags;
    HANDLE            JobToken;
    PTOKEN_GROUPS     SidsToDisable;
    PTOKEN_PRIVILEGES PrivilegesToDelete;
    PTOKEN_GROUPS     RestrictedSids;
}
alias JOBOBJECT_SECURITY_LIMIT_INFORMATION* PJOBOBJECT_SECURITY_LIMIT_INFORMATION;

struct JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
}
alias JOBOBJECT_END_OF_JOB_TIME_INFORMATION* PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

struct JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID  CompletionKey;
    HANDLE CompletionPort;
}
alias JOBOBJECT_ASSOCIATE_COMPLETION_PORT* PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

struct JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
}
alias JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

struct JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T      ProcessMemoryLimit;
    SIZE_T      JobMemoryLimit;
    SIZE_T      PeakProcessMemoryUsed;
    SIZE_T      PeakJobMemoryUsed;
}
alias JOBOBJECT_EXTENDED_LIMIT_INFORMATION* PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

struct JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
}
alias JOBOBJECT_JOBSET_INFORMATION* PJOBOBJECT_JOBSET_INFORMATION;

// MinGW: Making these defines conditional on _WIN32_WINNT will break ddk includes
//static if (_WIN32_WINNT >= 0x500) {

enum DWORD
    ES_SYSTEM_REQUIRED  = 0x00000001,
    ES_DISPLAY_REQUIRED = 0x00000002,
    ES_USER_PRESENT     = 0x00000004,
    ES_CONTINUOUS       = 0x80000000;

enum LATENCY_TIME {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
}
alias LATENCY_TIME* PLATENCY_TIME;

enum SYSTEM_POWER_STATE {
    PowerSystemUnspecified,
    PowerSystemWorking,
    PowerSystemSleeping1,
    PowerSystemSleeping2,
    PowerSystemSleeping3,
    PowerSystemHibernate,
    PowerSystemShutdown,
    PowerSystemMaximum
}
alias SYSTEM_POWER_STATE* PSYSTEM_POWER_STATE;

enum POWER_SYSTEM_MAXIMUM = SYSTEM_POWER_STATE.PowerSystemMaximum;

enum POWER_ACTION {
    PowerActionNone,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
}
alias POWER_ACTION* PPOWER_ACTION;

static if (_WIN32_WINNT >= 0x600) {
    enum SYSTEM_POWER_CONDITION {
        PoAc,
        PoDc,
        PoHot,
        PoConditionMaximum
    }
    alias SYSTEM_POWER_CONDITION* PSYSTEM_POWER_CONDITION;
}

enum DEVICE_POWER_STATE {
    PowerDeviceUnspecified,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
}
alias DEVICE_POWER_STATE* PDEVICE_POWER_STATE;

align(4):
struct BATTERY_REPORTING_SCALE {
    DWORD Granularity;
    DWORD Capacity;
}
alias BATTERY_REPORTING_SCALE* PBATTERY_REPORTING_SCALE;

struct POWER_ACTION_POLICY {
    POWER_ACTION Action;
    ULONG        Flags;
    ULONG        EventCode;
}
alias POWER_ACTION_POLICY* PPOWER_ACTION_POLICY;

// POWER_ACTION_POLICY.Flags constants
enum ULONG
    POWER_ACTION_QUERY_ALLOWED  = 0x00000001,
    POWER_ACTION_UI_ALLOWED     = 0x00000002,
    POWER_ACTION_OVERRIDE_APPS  = 0x00000004,
    POWER_ACTION_LIGHTEST_FIRST = 0x10000000,
    POWER_ACTION_LOCK_CONSOLE   = 0x20000000,
    POWER_ACTION_DISABLE_WAKES  = 0x40000000,
    POWER_ACTION_CRITICAL       = 0x80000000;

// POWER_ACTION_POLICY.EventCode constants
enum ULONG
    POWER_LEVEL_USER_NOTIFY_TEXT  = 0x00000001,
    POWER_LEVEL_USER_NOTIFY_SOUND = 0x00000002,
    POWER_LEVEL_USER_NOTIFY_EXEC  = 0x00000004,
    POWER_USER_NOTIFY_BUTTON      = 0x00000008,
    POWER_USER_NOTIFY_SHUTDOWN    = 0x00000010,
    POWER_FORCE_TRIGGER_RESET     = 0x80000000;

enum size_t
    DISCHARGE_POLICY_CRITICAL = 0,
    DISCHARGE_POLICY_LOW      = 1,
    NUM_DISCHARGE_POLICIES    = 4;

enum : BYTE {
    PO_THROTTLE_NONE,
    PO_THROTTLE_CONSTANT,
    PO_THROTTLE_DEGRADE,
    PO_THROTTLE_ADAPTIVE,
    PO_THROTTLE_MAXIMUM
}

struct SYSTEM_POWER_LEVEL {
    BOOLEAN             Enable;
    UCHAR[3]            Spare;
    ULONG               BatteryLevel;
    POWER_ACTION_POLICY PowerPolicy;
    SYSTEM_POWER_STATE  MinSystemState;
}
alias SYSTEM_POWER_LEVEL* PSYSTEM_POWER_LEVEL;

struct SYSTEM_POWER_POLICY {
    ULONG               Revision;
    POWER_ACTION_POLICY PowerButton;
    POWER_ACTION_POLICY SleepButton;
    POWER_ACTION_POLICY LidClose;
    SYSTEM_POWER_STATE  LidOpenWake;
    ULONG               Reserved;
    POWER_ACTION_POLICY Idle;
    ULONG               IdleTimeout;
    UCHAR               IdleSensitivity;
    UCHAR               DynamicThrottle;
    UCHAR[2]            Spare2;
    SYSTEM_POWER_STATE  MinSleep;
    SYSTEM_POWER_STATE  MaxSleep;
    SYSTEM_POWER_STATE  ReducedLatencySleep;
    ULONG               WinLogonFlags;
    ULONG               Spare3;
    ULONG               DozeS4Timeout;
    ULONG               BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL[NUM_DISCHARGE_POLICIES] DischargePolicy;
    ULONG               VideoTimeout;
    BOOLEAN             VideoDimDisplay;
    ULONG[3]            VideoReserved;
    ULONG               SpindownTimeout;
    BOOLEAN             OptimizeForPower;
    UCHAR               FanThrottleTolerance;
    UCHAR               ForcedThrottle;
    UCHAR               MinThrottle;
    POWER_ACTION_POLICY OverThrottled;
}
alias SYSTEM_POWER_POLICY* PSYSTEM_POWER_POLICY;

struct SYSTEM_POWER_CAPABILITIES {
    BOOLEAN                    PowerButtonPresent;
    BOOLEAN                    SleepButtonPresent;
    BOOLEAN                    LidPresent;
    BOOLEAN                    SystemS1;
    BOOLEAN                    SystemS2;
    BOOLEAN                    SystemS3;
    BOOLEAN                    SystemS4;
    BOOLEAN                    SystemS5;
    BOOLEAN                    HiberFilePresent;
    BOOLEAN                    FullWake;
    BOOLEAN                    VideoDimPresent;
    BOOLEAN                    ApmPresent;
    BOOLEAN                    UpsPresent;
    BOOLEAN                    ThermalControl;
    BOOLEAN                    ProcessorThrottle;
    UCHAR                      ProcessorMinThrottle;
    UCHAR                      ProcessorMaxThrottle;
    UCHAR[4]                   spare2;
    BOOLEAN                    DiskSpinDown;
    UCHAR[8]                   spare3;
    BOOLEAN                    SystemBatteriesPresent;
    BOOLEAN                    BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE[3] BatteryScale;
    SYSTEM_POWER_STATE         AcOnLineWake;
    SYSTEM_POWER_STATE         SoftLidWake;
    SYSTEM_POWER_STATE         RtcWake;
    SYSTEM_POWER_STATE         MinDeviceWakeState;
    SYSTEM_POWER_STATE         DefaultLowLatencyWake;
}
alias SYSTEM_POWER_CAPABILITIES* PSYSTEM_POWER_CAPABILITIES;

struct SYSTEM_BATTERY_STATE {
    BOOLEAN    AcOnLine;
    BOOLEAN    BatteryPresent;
    BOOLEAN    Charging;
    BOOLEAN    Discharging;
    BOOLEAN[4] Spare1;
    ULONG      MaxCapacity;
    ULONG      RemainingCapacity;
    ULONG      Rate;
    ULONG      EstimatedTime;
    ULONG      DefaultAlert1;
    ULONG      DefaultAlert2;
}
alias SYSTEM_BATTERY_STATE* PSYSTEM_BATTERY_STATE;

enum POWER_INFORMATION_LEVEL {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,
    LastSleepTime,
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent
}

//#if 1 /* (WIN32_WINNT >= 0x0500) */
struct SYSTEM_POWER_INFORMATION {
    ULONG MaxIdlenessAllowed;
    ULONG Idleness;
    ULONG TimeRemaining;
    UCHAR CoolingMode;
}
alias SYSTEM_POWER_INFORMATION* PSYSTEM_POWER_INFORMATION;
//#endif

struct PROCESSOR_POWER_POLICY_INFO {
    ULONG    TimeCheck;
    ULONG    DemoteLimit;
    ULONG    PromoteLimit;
    UCHAR    DemotePercent;
    UCHAR    PromotePercent;
    UCHAR[2] Spare;
    uint     _bf;

    bool AllowDemotion()  { return cast(bool)(_bf & 1); }
    bool AllowPromotion() { return cast(bool)(_bf & 2); }

    bool AllowDemotion(bool a)  { _bf = (_bf & ~1) | a; return a; }
    bool AllowPromotion(bool a) { _bf = (_bf & ~2) | (a << 1); return a; }
/+
    ULONG  AllowDemotion : 1;
    ULONG  AllowPromotion : 1;
    ULONG  Reserved : 30;
+/
}
alias PROCESSOR_POWER_POLICY_INFO* PPROCESSOR_POWER_POLICY_INFO;

struct PROCESSOR_POWER_POLICY {
    ULONG    Revision;
    UCHAR    DynamicThrottle;
    UCHAR[3] Spare;
    ULONG    Reserved;
    ULONG    PolicyCount;
    PROCESSOR_POWER_POLICY_INFO[3] Policy;
}
alias PROCESSOR_POWER_POLICY* PPROCESSOR_POWER_POLICY;

struct ADMINISTRATOR_POWER_POLICY {
    SYSTEM_POWER_STATE MinSleep;
    SYSTEM_POWER_STATE MaxSleep;
    ULONG              MinVideoTimeout;
    ULONG              MaxVideoTimeout;
    ULONG              MinSpindownTimeout;
    ULONG              MaxSpindownTimeout;
}
alias ADMINISTRATOR_POWER_POLICY* PADMINISTRATOR_POWER_POLICY;

//}//#endif /* _WIN32_WINNT >= 0x500 */

extern (Windows) {
    alias void function(PVOID, DWORD, PVOID) PIMAGE_TLS_CALLBACK;

    static if (_WIN32_WINNT >= 0x500) {
        alias LONG function(PEXCEPTION_POINTERS) PVECTORED_EXCEPTION_HANDLER;
        alias void function(PVOID, BOOLEAN) WAITORTIMERCALLBACKFUNC;
    }
}

static if (_WIN32_WINNT >= 0x501) {
    enum HEAP_INFORMATION_CLASS {
        HeapCompatibilityInformation
    }

    enum ACTIVATION_CONTEXT_INFO_CLASS {
        ActivationContextBasicInformation = 1,
        ActivationContextDetailedInformation,
        AssemblyDetailedInformationInActivationContext,
        FileInformationInAssemblyOfAssemblyInActivationContext
    }

    align struct ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
        DWORD         ulFlags;
        DWORD         ulEncodedAssemblyIdentityLength;
        DWORD         ulManifestPathType;
        DWORD         ulManifestPathLength;
        LARGE_INTEGER liManifestLastWriteTime;
        DWORD         ulPolicyPathType;
        DWORD         ulPolicyPathLength;
        LARGE_INTEGER liPolicyLastWriteTime;
        DWORD         ulMetadataSatelliteRosterIndex;
        DWORD         ulManifestVersionMajor;
        DWORD         ulManifestVersionMinor;
        DWORD         ulPolicyVersionMajor;
        DWORD         ulPolicyVersionMinor;
        DWORD         ulAssemblyDirectoryNameLength;
        PCWSTR        lpAssemblyEncodedAssemblyIdentity;
        PCWSTR        lpAssemblyManifestPath;
        PCWSTR        lpAssemblyPolicyPath;
        PCWSTR        lpAssemblyDirectoryName;
    }
    alias ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION*
      PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
    alias const(ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)*
      PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

    struct ACTIVATION_CONTEXT_DETAILED_INFORMATION {
        DWORD  dwFlags;
        DWORD  ulFormatVersion;
        DWORD  ulAssemblyCount;
        DWORD  ulRootManifestPathType;
        DWORD  ulRootManifestPathChars;
        DWORD  ulRootConfigurationPathType;
        DWORD  ulRootConfigurationPathChars;
        DWORD  ulAppDirPathType;
        DWORD  ulAppDirPathChars;
        PCWSTR lpRootManifestPath;
        PCWSTR lpRootConfigurationPath;
        PCWSTR lpAppDirPath;
    }
    alias ACTIVATION_CONTEXT_DETAILED_INFORMATION*
      PACTIVATION_CONTEXT_DETAILED_INFORMATION;
    alias const(ACTIVATION_CONTEXT_DETAILED_INFORMATION)*
      PCACTIVATION_CONTEXT_DETAILED_INFORMATION;

    struct ACTIVATION_CONTEXT_QUERY_INDEX {
        ULONG ulAssemblyIndex;
        ULONG ulFileIndexInAssembly;
    }
    alias ACTIVATION_CONTEXT_QUERY_INDEX*        PACTIVATION_CONTEXT_QUERY_INDEX;
    alias const(ACTIVATION_CONTEXT_QUERY_INDEX)* PCACTIVATION_CONTEXT_QUERY_INDEX;

    struct ASSEMBLY_FILE_DETAILED_INFORMATION {
        DWORD  ulFlags;
        DWORD  ulFilenameLength;
        DWORD  ulPathLength;
        PCWSTR lpFileName;
        PCWSTR lpFilePath;
    }
    alias ASSEMBLY_FILE_DETAILED_INFORMATION*
      PASSEMBLY_FILE_DETAILED_INFORMATION;
    alias const(ASSEMBLY_FILE_DETAILED_INFORMATION)*
      PCASSEMBLY_FILE_DETAILED_INFORMATION;
}

version (Unicode) {
    alias OSVERSIONINFOW OSVERSIONINFO;
    alias OSVERSIONINFOEXW OSVERSIONINFOEX;
} else {
    alias OSVERSIONINFOA OSVERSIONINFO;
    alias OSVERSIONINFOEXA OSVERSIONINFOEX;
}

alias OSVERSIONINFO*   POSVERSIONINFO,   LPOSVERSIONINFO;
alias OSVERSIONINFOEX* POSVERSIONINFOEX, LPOSVERSIONINFOEX;


static if (_WIN32_WINNT >= 0x500) {
    extern (Windows) ULONGLONG VerSetConditionMask(ULONGLONG, DWORD, BYTE);
}

version (Win64) {
enum WORD IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR64_MAGIC;

    alias IMAGE_ORDINAL_FLAG64 IMAGE_ORDINAL_FLAG;
    alias IMAGE_SNAP_BY_ORDINAL64 IMAGE_SNAP_BY_ORDINAL;
    alias IMAGE_ORDINAL64 IMAGE_ORDINAL;
    alias IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
    alias IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
    alias IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
    alias IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
} else {
enum WORD IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR32_MAGIC;

    alias IMAGE_ORDINAL_FLAG32 IMAGE_ORDINAL_FLAG;
    alias IMAGE_ORDINAL32 IMAGE_ORDINAL;
    alias IMAGE_SNAP_BY_ORDINAL32 IMAGE_SNAP_BY_ORDINAL;
    alias IMAGE_OPTIONAL_HEADER32 IMAGE_OPTIONAL_HEADER;
    alias IMAGE_NT_HEADERS32 IMAGE_NT_HEADERS;
    alias IMAGE_THUNK_DATA32 IMAGE_THUNK_DATA;
    alias IMAGE_TLS_DIRECTORY32 IMAGE_TLS_DIRECTORY;
}

alias IMAGE_OPTIONAL_HEADER* PIMAGE_OPTIONAL_HEADER;
alias IMAGE_NT_HEADERS* PIMAGE_NT_HEADERS;
alias IMAGE_THUNK_DATA* PIMAGE_THUNK_DATA;
alias IMAGE_TLS_DIRECTORY* PIMAGE_TLS_DIRECTORY;

// TODO: MinGW implements these in assembly.  How to translate?
PVOID GetCurrentFiber();
PVOID GetFiberData();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winperf.d)
 */
module core.sys.windows.winperf;
version (Windows):

import core.sys.windows.windef;
import core.sys.windows.winbase; // for SYSTEMTIME

enum PERF_DATA_VERSION=1;
enum PERF_DATA_REVISION=1;
enum PERF_NO_INSTANCES=-1;
enum PERF_SIZE_DWORD=0;
enum PERF_SIZE_LARGE=256;
enum PERF_SIZE_ZERO=512;
enum PERF_SIZE_VARIABLE_LEN=768;
enum PERF_TYPE_NUMBER=0;
enum PERF_TYPE_COUNTER=1024;
enum PERF_TYPE_TEXT=2048;
enum PERF_TYPE_ZERO=0xC00;
enum PERF_NUMBER_HEX=0;
enum PERF_NUMBER_DECIMAL=0x10000;
enum PERF_NUMBER_DEC_1000=0x20000;
enum PERF_COUNTER_VALUE=0;
enum PERF_COUNTER_RATE=0x10000;
enum PERF_COUNTER_FRACTION=0x20000;
enum PERF_COUNTER_BASE=0x30000;
enum PERF_COUNTER_ELAPSED=0x40000;
enum PERF_COUNTER_QUEUELEN=0x50000;
enum PERF_COUNTER_HISTOGRAM=0x60000;
enum PERF_TEXT_UNICODE=0;
enum PERF_TEXT_ASCII=0x10000;
enum PERF_TIMER_TICK=0;
enum PERF_TIMER_100NS=0x100000;
enum PERF_OBJECT_TIMER=0x200000;
enum PERF_DELTA_COUNTER=0x400000;
enum PERF_DELTA_BASE=0x800000;
enum PERF_INVERSE_COUNTER=0x1000000;
enum PERF_MULTI_COUNTER=0x2000000;
enum PERF_DISPLAY_NO_SUFFIX=0;
enum PERF_DISPLAY_PER_SEC=0x10000000;
enum PERF_DISPLAY_PERCENT=0x20000000;
enum PERF_DISPLAY_SECONDS=0x30000000;
enum PERF_DISPLAY_NOSHOW=0x40000000;
enum PERF_COUNTER_HISTOGRAM_TYPE=0x80000000;
enum PERF_NO_UNIQUE_ID=(-1);
enum PERF_DETAIL_NOVICE=100;
enum PERF_DETAIL_ADVANCED=200;
enum PERF_DETAIL_EXPERT=300;
enum PERF_DETAIL_WIZARD=400;
enum PERF_COUNTER_COUNTER=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_DISPLAY_PER_SEC);
enum PERF_COUNTER_TIMER=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_COUNTER_QUEUELEN_TYPE=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_QUEUELEN|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_BULK_COUNT=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_DISPLAY_PER_SEC);
enum PERF_COUNTER_TEXT=(PERF_SIZE_VARIABLE_LEN|PERF_TYPE_TEXT|PERF_TEXT_UNICODE|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_RAWCOUNT=(PERF_SIZE_DWORD|PERF_TYPE_NUMBER|PERF_NUMBER_DECIMAL|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_LARGE_RAWCOUNT=(PERF_SIZE_LARGE|PERF_TYPE_NUMBER|PERF_NUMBER_DECIMAL|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_RAWCOUNT_HEX=(PERF_SIZE_DWORD|PERF_TYPE_NUMBER|PERF_NUMBER_HEX|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_LARGE_RAWCOUNT_HEX=(PERF_SIZE_LARGE|PERF_TYPE_NUMBER|PERF_NUMBER_HEX|PERF_DISPLAY_NO_SUFFIX);
enum PERF_SAMPLE_FRACTION=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_FRACTION|PERF_DELTA_COUNTER|PERF_DELTA_BASE|PERF_DISPLAY_PERCENT);
enum PERF_SAMPLE_COUNTER=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_DISPLAY_NO_SUFFIX);
enum PERF_COUNTER_NODATA=(PERF_SIZE_ZERO|PERF_DISPLAY_NOSHOW);
enum PERF_COUNTER_TIMER_INV=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_TICK|PERF_DELTA_COUNTER|PERF_INVERSE_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_SAMPLE_BASE=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_BASE|PERF_DISPLAY_NOSHOW|1);
enum PERF_AVERAGE_TIMER=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_FRACTION|PERF_DISPLAY_SECONDS);
enum PERF_AVERAGE_BASE=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_BASE|PERF_DISPLAY_NOSHOW|2);
enum PERF_AVERAGE_BULK=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_FRACTION|PERF_DISPLAY_NOSHOW);
enum PERF_100NSEC_TIMER=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_100NS|PERF_DELTA_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_100NSEC_TIMER_INV=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_100NS|PERF_DELTA_COUNTER|PERF_INVERSE_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_COUNTER_MULTI_TIMER=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_DELTA_COUNTER|PERF_TIMER_TICK|PERF_MULTI_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_COUNTER_MULTI_TIMER_INV=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_RATE|PERF_DELTA_COUNTER|PERF_MULTI_COUNTER|PERF_TIMER_TICK|PERF_INVERSE_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_COUNTER_MULTI_BASE=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_BASE|PERF_MULTI_COUNTER|PERF_DISPLAY_NOSHOW);
enum PERF_100NSEC_MULTI_TIMER=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_DELTA_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_100NS|PERF_MULTI_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_100NSEC_MULTI_TIMER_INV=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_DELTA_COUNTER|PERF_COUNTER_RATE|PERF_TIMER_100NS|PERF_MULTI_COUNTER|PERF_INVERSE_COUNTER|PERF_DISPLAY_PERCENT);
enum PERF_RAW_FRACTION=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_FRACTION|PERF_DISPLAY_PERCENT);
enum PERF_RAW_BASE=(PERF_SIZE_DWORD|PERF_TYPE_COUNTER|PERF_COUNTER_BASE|PERF_DISPLAY_NOSHOW|3);
enum PERF_ELAPSED_TIME=(PERF_SIZE_LARGE|PERF_TYPE_COUNTER|PERF_COUNTER_ELAPSED|PERF_OBJECT_TIMER|PERF_DISPLAY_SECONDS);

struct PERF_DATA_BLOCK {
    WCHAR[4] Signature = 0;
    DWORD LittleEndian;
    DWORD Version;
    DWORD Revision;
    DWORD TotalByteLength;
    DWORD HeaderLength;
    DWORD NumObjectTypes;
    LONG DefaultObject;
    SYSTEMTIME SystemTime;
    LARGE_INTEGER PerfTime;
    LARGE_INTEGER PerfFreq;
    LARGE_INTEGER PerfTime100nSec;
    DWORD SystemNameLength;
    DWORD SystemNameOffset;
}
alias PERF_DATA_BLOCK * PPERF_DATA_BLOCK;

struct PERF_OBJECT_TYPE {
    DWORD TotalByteLength;
    DWORD DefinitionLength;
    DWORD HeaderLength;
    DWORD ObjectNameTitleIndex;
version (Win64) {
    DWORD ObjectNameTitle;
} else {
    LPWSTR ObjectNameTitle;
}
    DWORD ObjectHelpTitleIndex;
version (Win64) {
    DWORD ObjectHelpTitle;
} else {
    LPWSTR ObjectHelpTitle;
}
    DWORD DetailLevel;
    DWORD NumCounters;
    LONG DefaultCounter;
    LONG NumInstances;
    DWORD CodePage;
    LARGE_INTEGER PerfTime;
    LARGE_INTEGER PerfFreq;
}
alias PERF_OBJECT_TYPE * PPERF_OBJECT_TYPE;

struct PERF_COUNTER_DEFINITION {
    DWORD ByteLength;
    DWORD CounterNameTitleIndex;
version (Win64) {
    DWORD CounterNameTitle;
} else {
    LPWSTR CounterNameTitle;
}
    DWORD CounterHelpTitleIndex;
version (Win64) {
    DWORD CounterHelpTitle;
} else {
    LPWSTR CounterHelpTitle;
}
    LONG DefaultScale;
    DWORD DetailLevel;
    DWORD CounterType;
    DWORD CounterSize;
    DWORD CounterOffset;
}
alias PERF_COUNTER_DEFINITION * PPERF_COUNTER_DEFINITION;

struct PERF_INSTANCE_DEFINITION {
    DWORD ByteLength;
    DWORD ParentObjectTitleIndex;
    DWORD ParentObjectInstance;
    LONG UniqueID;
    DWORD NameOffset;
    DWORD NameLength;
}
alias PERF_INSTANCE_DEFINITION * PPERF_INSTANCE_DEFINITION;

struct PERF_COUNTER_BLOCK {
    DWORD ByteLength;
}
alias PERF_COUNTER_BLOCK * PPERF_COUNTER_BLOCK;

extern (Windows):
alias DWORD function (LPWSTR) PM_OPEN_PROC;
alias DWORD function (LPWSTR,PVOID*,PDWORD,PDWORD) PM_COLLECT_PROC;
alias DWORD function () PM_CLOSE_PROC;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winreg.d)
 */
module core.sys.windows.winreg;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "advapi32");

private import core.sys.windows.w32api, core.sys.windows.winbase, core.sys.windows.windef;

enum : HKEY { // for some reason, DMD errors if I don't give all the values explicitly
    HKEY_CLASSES_ROOT        = cast(HKEY) 0x80000000,
    HKEY_CURRENT_USER        = cast(HKEY) 0x80000001,
    HKEY_LOCAL_MACHINE       = cast(HKEY) 0x80000002,
    HKEY_USERS               = cast(HKEY) 0x80000003,
    HKEY_PERFORMANCE_DATA    = cast(HKEY) 0x80000004,
    HKEY_CURRENT_CONFIG      = cast(HKEY) 0x80000005,
    HKEY_DYN_DATA            = cast(HKEY) 0x80000006,
    HKEY_PERFORMANCE_TEXT    = cast(HKEY) 0x80000050,
    HKEY_PERFORMANCE_NLSTEXT = cast(HKEY) 0x80000060,
}

//enum : DWORD {
//    REG_OPTION_NON_VOLATILE,
//    REG_OPTION_VOLATILE
//}

enum : DWORD {
    REG_CREATED_NEW_KEY = 1,
    REG_OPENED_EXISTING_KEY
}

enum : DWORD {
    REG_NONE                       = 0,
    REG_SZ,
    REG_EXPAND_SZ,
    REG_BINARY,
    REG_DWORD_LITTLE_ENDIAN,
    REG_DWORD                      = REG_DWORD_LITTLE_ENDIAN,
    REG_DWORD_BIG_ENDIAN,
    REG_LINK,
    REG_MULTI_SZ,
    REG_RESOURCE_LIST,
    REG_FULL_RESOURCE_DESCRIPTOR,
    REG_RESOURCE_REQUIREMENTS_LIST,
    REG_QWORD_LITTLE_ENDIAN,
    REG_QWORD                      = REG_QWORD_LITTLE_ENDIAN
}

enum DWORD
    REG_NOTIFY_CHANGE_NAME       = 1,
    REG_NOTIFY_CHANGE_ATTRIBUTES = 2,
    REG_NOTIFY_CHANGE_LAST_SET   = 4,
    REG_NOTIFY_CHANGE_SECURITY   = 8;

alias ACCESS_MASK REGSAM;

struct VALENTA {
    LPSTR ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}
alias VALENTA* PVALENTA;

struct VALENTW {
    LPWSTR ve_valuename;
    DWORD  ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD  ve_type;
}
alias VALENTW* PVALENTW;

// RRF - Registry Routine Flags (for RegGetValue)
static if (_WIN32_WINNT >= 0x600) {
    enum : DWORD {
        RRF_RT_REG_NONE      = 0x00000001,
        RRF_RT_REG_SZ        = 0x00000002,
        RRF_RT_REG_EXPAND_SZ = 0x00000004,
        RRF_RT_REG_BINARY    = 0x00000008,
        RRF_RT_REG_DWORD     = 0x00000010,
        RRF_RT_REG_MULTI_SZ  = 0x00000020,
        RRF_RT_REG_QWORD     = 0x00000040,
        RRF_RT_DWORD         = RRF_RT_REG_BINARY | RRF_RT_REG_DWORD,
        RRF_RT_QWORD         = RRF_RT_REG_BINARY | RRF_RT_REG_QWORD,
        RRF_RT_ANY           = 0x0000FFFF,
        RRF_NOEXPAND         = 0x10000000,
        RRF_ZEROONFAILURE    = 0x20000000
    }
}

extern (Windows) nothrow @nogc {
    LONG RegCloseKey(in HKEY);
    LONG RegConnectRegistryA(LPCSTR, HKEY, PHKEY);
    LONG RegConnectRegistryW(LPCWSTR, HKEY, PHKEY);
    LONG RegCreateKeyExA(in HKEY, LPCSTR, DWORD, LPSTR, DWORD, REGSAM,
      LPSECURITY_ATTRIBUTES, PHKEY, PDWORD);
    LONG RegCreateKeyExW(in HKEY, LPCWSTR, DWORD, LPWSTR, DWORD, REGSAM,
      LPSECURITY_ATTRIBUTES, PHKEY, PDWORD);
    LONG RegDeleteKeyA(in HKEY, LPCSTR);
    LONG RegDeleteKeyW(in HKEY, LPCWSTR);
    LONG RegDeleteValueA(in HKEY, LPCSTR);
    LONG RegDeleteValueW(in HKEY, LPCWSTR);
    LONG RegEnumKeyExA(in HKEY, DWORD, LPSTR, PDWORD, PDWORD, LPSTR, PDWORD,
      PFILETIME);
    LONG RegEnumKeyExW(in HKEY, DWORD, LPWSTR, PDWORD, PDWORD, LPWSTR, PDWORD,
      PFILETIME);
    LONG RegEnumValueA(in HKEY, DWORD, LPSTR, PDWORD, PDWORD, PDWORD, LPBYTE,
      PDWORD);
    LONG RegEnumValueW(in HKEY, DWORD, LPWSTR, PDWORD, PDWORD, PDWORD, LPBYTE,
      PDWORD);
    LONG RegFlushKey(in HKEY);
    LONG RegLoadKeyA(in HKEY, LPCSTR, LPCSTR);
    LONG RegLoadKeyW(in HKEY, LPCWSTR, LPCWSTR);
    LONG RegOpenKeyExA(in HKEY, LPCSTR, DWORD, REGSAM, PHKEY);
    LONG RegOpenKeyExW(in HKEY, LPCWSTR, DWORD, REGSAM, PHKEY);
    LONG RegQueryInfoKeyA(in HKEY, LPSTR, PDWORD, PDWORD, PDWORD, PDWORD,
      PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PFILETIME);
    LONG RegQueryInfoKeyW(in HKEY, LPWSTR, PDWORD, PDWORD, PDWORD, PDWORD,
      PDWORD, PDWORD, PDWORD, PDWORD, PDWORD, PFILETIME);
    LONG RegQueryMultipleValuesA(in HKEY, PVALENTA, DWORD, LPSTR, LPDWORD);
    LONG RegQueryMultipleValuesW(in HKEY, PVALENTW, DWORD, LPWSTR, LPDWORD);
    LONG RegQueryValueExA(in HKEY, LPCSTR, LPDWORD, LPDWORD, /*LPBYTE*/LPVOID, LPDWORD);
    LONG RegQueryValueExW(in HKEY, LPCWSTR, LPDWORD, LPDWORD, /*LPBYTE*/LPVOID, LPDWORD);
    LONG RegReplaceKeyA(in HKEY, LPCSTR, LPCSTR, LPCSTR);
    LONG RegReplaceKeyW(in HKEY, LPCWSTR, LPCWSTR, LPCWSTR);
    LONG RegSaveKeyA(in HKEY, LPCSTR, LPSECURITY_ATTRIBUTES);
    LONG RegSaveKeyW(in HKEY, LPCWSTR, LPSECURITY_ATTRIBUTES);
    LONG RegSetKeySecurity(in HKEY, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR);
    LONG RegSetValueExA(in HKEY, LPCSTR, DWORD, DWORD, const(BYTE)*, DWORD);
    LONG RegSetValueExW(in HKEY, LPCWSTR, DWORD, DWORD, const(BYTE)*, DWORD);
    LONG RegUnLoadKeyA(in HKEY, LPCSTR);
    LONG RegUnLoadKeyW(in HKEY, LPCWSTR);
    LONG RegNotifyChangeKeyValue(in HKEY, BOOL, DWORD, HANDLE, BOOL);

    BOOL AbortSystemShutdownA(LPCSTR);
    BOOL AbortSystemShutdownW(LPCWSTR);
    BOOL InitiateSystemShutdownA(LPSTR, LPSTR, DWORD, BOOL, BOOL);
    BOOL InitiateSystemShutdownW(LPWSTR, LPWSTR, DWORD, BOOL, BOOL);
    LONG RegGetKeySecurity(in HKEY, SECURITY_INFORMATION,
      PSECURITY_DESCRIPTOR, PDWORD);
    LONG RegRestoreKeyA(in HKEY, LPCSTR, DWORD);
    LONG RegRestoreKeyW(in HKEY, LPCWSTR, DWORD);
    LONG RegSetKeySecurity(in HKEY, SECURITY_INFORMATION,
      PSECURITY_DESCRIPTOR);

    static if (_WIN32_WINNT >= 0x500) {
        LONG RegDisablePredefinedCache();
        LONG RegOpenCurrentUser(REGSAM, PHKEY);
        LONG RegOpenUserClassesRoot(HANDLE, DWORD, REGSAM, PHKEY);
    }

    static if (_WIN32_WINNT >= 0x501) {
        LONG RegSaveKeyExA(in HKEY, LPCSTR, LPSECURITY_ATTRIBUTES, DWORD);
        LONG RegSaveKeyExW(in HKEY, LPCWSTR, LPSECURITY_ATTRIBUTES, DWORD);
    }

    static if (_WIN32_WINNT >= 0x600) {
        LONG RegGetValueA(in HKEY hkey, LPCSTR lpSubKey, LPCSTR lpValue,
          DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
        LONG RegGetValueW(in HKEY hkey, LPCWSTR lpSubKey, LPCWSTR lpValue,
          DWORD dwFlags, LPDWORD pdwType, PVOID pvData, LPDWORD pcbData);
    }

    //deprecated {
        LONG RegCreateKeyA(in HKEY, LPCSTR, PHKEY);
        LONG RegCreateKeyW(in HKEY, LPCWSTR, PHKEY);
        LONG RegEnumKeyA(in HKEY, DWORD, LPSTR, DWORD);
        LONG RegEnumKeyW(in HKEY, DWORD, LPWSTR, DWORD);
        LONG RegOpenKeyA(in HKEY, LPCSTR, PHKEY);
        LONG RegOpenKeyW(in HKEY, LPCWSTR, PHKEY);
        LONG RegQueryValueA(in HKEY, LPCSTR, LPSTR, PLONG);
        LONG RegQueryValueW(in HKEY, LPCWSTR, LPWSTR, PLONG);
        LONG RegSetValueA(in HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
        LONG RegSetValueW(in HKEY, LPCWSTR, DWORD, LPCWSTR, DWORD);
    //}
}

version (Unicode) {
    alias VALENTW VALENT;
    alias RegConnectRegistryW RegConnectRegistry;
    alias RegCreateKeyExW RegCreateKeyEx;
    alias RegDeleteKeyW RegDeleteKey;
    alias RegDeleteValueW RegDeleteValue;
    alias RegEnumKeyExW RegEnumKeyEx;
    alias RegEnumValueW RegEnumValue;
    alias RegLoadKeyW RegLoadKey;
    alias RegOpenKeyExW RegOpenKeyEx;
    alias RegQueryInfoKeyW RegQueryInfoKey;
    alias RegQueryMultipleValuesW RegQueryMultipleValues;
    alias RegQueryValueExW RegQueryValueEx;
    alias RegReplaceKeyW RegReplaceKey;
    alias RegSaveKeyW RegSaveKey;
    alias RegSetValueExW RegSetValueEx;
    alias RegUnLoadKeyW RegUnLoadKey;

    alias AbortSystemShutdownW AbortSystemShutdown;
    alias InitiateSystemShutdownW InitiateSystemShutdown;
    alias RegRestoreKeyW RegRestoreKey;
    static if (_WIN32_WINNT >= 0x501) {
        alias RegSaveKeyExA RegSaveKeyEx;
    }
    static if (_WIN32_WINNT >= 0x600) {
        alias RegGetValueW RegGetValue;
    }
    //deprecated {
        alias RegCreateKeyW RegCreateKey;
        alias RegEnumKeyW RegEnumKey;
        alias RegOpenKeyW RegOpenKey;
        alias RegQueryValueW RegQueryValue;
        alias RegSetValueW RegSetValue;
    //}
} else {
    alias VALENTA VALENT;
    alias RegConnectRegistryA RegConnectRegistry;
    alias RegCreateKeyExA RegCreateKeyEx;
    alias RegDeleteKeyA RegDeleteKey;
    alias RegDeleteValueA RegDeleteValue;
    alias RegEnumKeyExA RegEnumKeyEx;
    alias RegEnumValueA RegEnumValue;
    alias RegLoadKeyA RegLoadKey;
    alias RegOpenKeyExA RegOpenKeyEx;
    alias RegQueryInfoKeyA RegQueryInfoKey;
    alias RegQueryMultipleValuesA RegQueryMultipleValues;
    alias RegQueryValueExA RegQueryValueEx;
    alias RegReplaceKeyA RegReplaceKey;
    alias RegSaveKeyA RegSaveKey;
    alias RegSetValueExA RegSetValueEx;
    alias RegUnLoadKeyA RegUnLoadKey;
    alias AbortSystemShutdownA AbortSystemShutdown;
    alias InitiateSystemShutdownA InitiateSystemShutdown;
    alias RegRestoreKeyW RegRestoreKey;
    static if (_WIN32_WINNT >= 0x501) {
        alias RegSaveKeyExA RegSaveKeyEx;
    }
    static if (_WIN32_WINNT >= 0x600) {
        alias RegGetValueA RegGetValue;
    }
    //deprecated {
        alias RegCreateKeyA RegCreateKey;
        alias RegEnumKeyA RegEnumKey;
        alias RegOpenKeyA RegOpenKey;
        alias RegQueryValueA RegQueryValue;
        alias RegSetValueA RegSetValue;
    //}
}

alias VALENT* PVALENT;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /*
    Written by Christopher E. Miller
    $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
*/


module core.sys.windows.winsock2;
version (Windows):

pragma(lib, "ws2_32");

extern(Windows):
nothrow:

alias SOCKET = size_t;
alias socklen_t = int;

enum SOCKET INVALID_SOCKET = cast(SOCKET)~0;
enum int SOCKET_ERROR = -1;

enum WSADESCRIPTION_LEN = 256;
enum WSASYS_STATUS_LEN = 128;

struct WSADATA
{
    ushort wVersion;
    ushort wHighVersion;
    char[WSADESCRIPTION_LEN + 1] szDescription = 0;
    char[WSASYS_STATUS_LEN + 1] szSystemStatus = 0;
    ushort iMaxSockets;
    ushort iMaxUdpDg;
    char* lpVendorInfo;
}
alias LPWSADATA = WSADATA*;


enum int IOCPARM_MASK =  0x7F;
enum int IOC_IN =        cast(int)0x80000000;
enum int FIONBIO =       cast(int)(IOC_IN | ((uint.sizeof & IOCPARM_MASK) << 16) | (102 << 8) | 126);

enum NI_MAXHOST = 1025;
enum NI_MAXSERV = 32;

@nogc
{
int WSAStartup(ushort wVersionRequested, LPWSADATA lpWSAData);
int WSACleanup();
SOCKET socket(int af, int type, int protocol);
int ioctlsocket(SOCKET s, int cmd, uint* argp);
int bind(SOCKET s, const(sockaddr)* name, socklen_t namelen);
int connect(SOCKET s, const(sockaddr)* name, socklen_t namelen);
int listen(SOCKET s, int backlog);
SOCKET accept(SOCKET s, sockaddr* addr, socklen_t* addrlen);
int closesocket(SOCKET s);
int shutdown(SOCKET s, int how);
int getpeername(SOCKET s, sockaddr* name, socklen_t* namelen);
int getsockname(SOCKET s, sockaddr* name, socklen_t* namelen);
int send(SOCKET s, const(void)* buf, int len, int flags);
int sendto(SOCKET s, const(void)* buf, int len, int flags, const(sockaddr)* to, socklen_t tolen);
int recv(SOCKET s, void* buf, int len, int flags);
int recvfrom(SOCKET s, void* buf, int len, int flags, sockaddr* from, socklen_t* fromlen);
int getsockopt(SOCKET s, int level, int optname, void* optval, socklen_t* optlen);
int setsockopt(SOCKET s, int level, int optname, const(void)* optval, socklen_t optlen);
uint inet_addr(const char* cp);
int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* errorfds, const(timeval)* timeout);
char* inet_ntoa(in_addr ina);
hostent* gethostbyname(const char* name);
hostent* gethostbyaddr(const(void)* addr, int len, int type);
protoent* getprotobyname(const char* name);
protoent* getprotobynumber(int number);
servent* getservbyname(const char* name, const char* proto);
servent* getservbyport(int port, const char* proto);
}

enum: int
{
    NI_NOFQDN =          0x01,
    NI_NUMERICHOST =     0x02,
    NI_NAMEREQD =        0x04,
    NI_NUMERICSERV =     0x08,
    NI_DGRAM  =          0x10,
}

@nogc
{
int gethostname(const char* name, int namelen);
int getaddrinfo(const(char)* nodename, const(char)* servname, const(addrinfo)* hints, addrinfo** res);
void freeaddrinfo(addrinfo* ai);
int getnameinfo(const(sockaddr)* sa, socklen_t salen, char* host, uint hostlen, char* serv, uint servlen, int flags);
}

enum WSABASEERR = 10000;

enum: int
{
    /*
     * Windows Sockets definitions of regular Microsoft C error constants
     */
    WSAEINTR = (WSABASEERR+4),
    WSAEBADF = (WSABASEERR+9),
    WSAEACCES = (WSABASEERR+13),
    WSAEFAULT = (WSABASEERR+14),
    WSAEINVAL = (WSABASEERR+22),
    WSAEMFILE = (WSABASEERR+24),

    /*
     * Windows Sockets definitions of regular Berkeley error constants
     */
    WSAEWOULDBLOCK = (WSABASEERR+35),
    WSAEINPROGRESS = (WSABASEERR+36),
    WSAEALREADY = (WSABASEERR+37),
    WSAENOTSOCK = (WSABASEERR+38),
    WSAEDESTADDRREQ = (WSABASEERR+39),
    WSAEMSGSIZE = (WSABASEERR+40),
    WSAEPROTOTYPE = (WSABASEERR+41),
    WSAENOPROTOOPT = (WSABASEERR+42),
    WSAEPROTONOSUPPORT = (WSABASEERR+43),
    WSAESOCKTNOSUPPORT = (WSABASEERR+44),
    WSAEOPNOTSUPP = (WSABASEERR+45),
    WSAEPFNOSUPPORT = (WSABASEERR+46),
    WSAEAFNOSUPPORT = (WSABASEERR+47),
    WSAEADDRINUSE = (WSABASEERR+48),
    WSAEADDRNOTAVAIL = (WSABASEERR+49),
    WSAENETDOWN = (WSABASEERR+50),
    WSAENETUNREACH = (WSABASEERR+51),
    WSAENETRESET = (WSABASEERR+52),
    WSAECONNABORTED = (WSABASEERR+53),
    WSAECONNRESET = (WSABASEERR+54),
    WSAENOBUFS = (WSABASEERR+55),
    WSAEISCONN = (WSABASEERR+56),
    WSAENOTCONN = (WSABASEERR+57),
    WSAESHUTDOWN = (WSABASEERR+58),
    WSAETOOMANYREFS = (WSABASEERR+59),
    WSAETIMEDOUT = (WSABASEERR+60),
    WSAECONNREFUSED = (WSABASEERR+61),
    WSAELOOP = (WSABASEERR+62),
    WSAENAMETOOLONG = (WSABASEERR+63),
    WSAEHOSTDOWN = (WSABASEERR+64),
    WSAEHOSTUNREACH = (WSABASEERR+65),
    WSAENOTEMPTY = (WSABASEERR+66),
    WSAEPROCLIM = (WSABASEERR+67),
    WSAEUSERS = (WSABASEERR+68),
    WSAEDQUOT = (WSABASEERR+69),
    WSAESTALE = (WSABASEERR+70),
    WSAEREMOTE = (WSABASEERR+71),

    /*
     * Extended Windows Sockets error constant definitions
     */
    WSASYSNOTREADY = (WSABASEERR+91),
    WSAVERNOTSUPPORTED = (WSABASEERR+92),
    WSANOTINITIALISED = (WSABASEERR+93),

    /* Authoritative Answer: Host not found */
    WSAHOST_NOT_FOUND = (WSABASEERR+1001),
    HOST_NOT_FOUND = WSAHOST_NOT_FOUND,

    /* Non-Authoritative: Host not found, or SERVERFAIL */
    WSATRY_AGAIN = (WSABASEERR+1002),
    TRY_AGAIN = WSATRY_AGAIN,

    /* Non recoverable errors, FORMERR, REFUSED, NOTIMP */
    WSANO_RECOVERY = (WSABASEERR+1003),
    NO_RECOVERY = WSANO_RECOVERY,

    /* Valid name, no data record of requested type */
    WSANO_DATA = (WSABASEERR+1004),
    NO_DATA = WSANO_DATA,

    /* no address, look for MX record */
    WSANO_ADDRESS = WSANO_DATA,
    NO_ADDRESS = WSANO_ADDRESS
}

/*
 * Windows Sockets errors redefined as regular Berkeley error constants
 */
enum: int
{
    EWOULDBLOCK = WSAEWOULDBLOCK,
    EINPROGRESS = WSAEINPROGRESS,
    EALREADY = WSAEALREADY,
    ENOTSOCK = WSAENOTSOCK,
    EDESTADDRREQ = WSAEDESTADDRREQ,
    EMSGSIZE = WSAEMSGSIZE,
    EPROTOTYPE = WSAEPROTOTYPE,
    ENOPROTOOPT = WSAENOPROTOOPT,
    EPROTONOSUPPORT = WSAEPROTONOSUPPORT,
    ESOCKTNOSUPPORT = WSAESOCKTNOSUPPORT,
    EOPNOTSUPP = WSAEOPNOTSUPP,
    EPFNOSUPPORT = WSAEPFNOSUPPORT,
    EAFNOSUPPORT = WSAEAFNOSUPPORT,
    EADDRINUSE = WSAEADDRINUSE,
    EADDRNOTAVAIL = WSAEADDRNOTAVAIL,
    ENETDOWN = WSAENETDOWN,
    ENETUNREACH = WSAENETUNREACH,
    ENETRESET = WSAENETRESET,
    ECONNABORTED = WSAECONNABORTED,
    ECONNRESET = WSAECONNRESET,
    ENOBUFS = WSAENOBUFS,
    EISCONN = WSAEISCONN,
    ENOTCONN = WSAENOTCONN,
    ESHUTDOWN = WSAESHUTDOWN,
    ETOOMANYREFS = WSAETOOMANYREFS,
    ETIMEDOUT = WSAETIMEDOUT,
    ECONNREFUSED = WSAECONNREFUSED,
    ELOOP = WSAELOOP,
    ENAMETOOLONG = WSAENAMETOOLONG,
    EHOSTDOWN = WSAEHOSTDOWN,
    EHOSTUNREACH = WSAEHOSTUNREACH,
    ENOTEMPTY = WSAENOTEMPTY,
    EPROCLIM = WSAEPROCLIM,
    EUSERS = WSAEUSERS,
    EDQUOT = WSAEDQUOT,
    ESTALE = WSAESTALE,
    EREMOTE = WSAEREMOTE
}

enum: int
{
    EAI_NONAME    = WSAHOST_NOT_FOUND,
}

int WSAGetLastError() @trusted @nogc;


enum: int
{
    AF_UNSPEC =     0,

    AF_UNIX =       1,
    AF_INET =       2,
    AF_IMPLINK =    3,
    AF_PUP =        4,
    AF_CHAOS =      5,
    AF_NS =         6,
    AF_IPX =        AF_NS,
    AF_ISO =        7,
    AF_OSI =        AF_ISO,
    AF_ECMA =       8,
    AF_DATAKIT =    9,
    AF_CCITT =      10,
    AF_SNA =        11,
    AF_DECnet =     12,
    AF_DLI =        13,
    AF_LAT =        14,
    AF_HYLINK =     15,
    AF_APPLETALK =  16,
    AF_NETBIOS =    17,
    AF_VOICEVIEW =  18,
    AF_FIREFOX =    19,
    AF_UNKNOWN1 =   20,
    AF_BAN =        21,
    AF_ATM =        22,
    AF_INET6 =      23,
    AF_CLUSTER =    24,
    AF_12844 =      25,
    AF_IRDA =       26,
    AF_NETDES =     28,

    AF_MAX =        29,


    PF_UNSPEC     = AF_UNSPEC,

    PF_UNIX =       AF_UNIX,
    PF_INET =       AF_INET,
    PF_IMPLINK =    AF_IMPLINK,
    PF_PUP =        AF_PUP,
    PF_CHAOS =      AF_CHAOS,
    PF_NS =         AF_NS,
    PF_IPX =        AF_IPX,
    PF_ISO =        AF_ISO,
    PF_OSI =        AF_OSI,
    PF_ECMA =       AF_ECMA,
    PF_DATAKIT =    AF_DATAKIT,
    PF_CCITT =      AF_CCITT,
    PF_SNA =        AF_SNA,
    PF_DECnet =     AF_DECnet,
    PF_DLI =        AF_DLI,
    PF_LAT =        AF_LAT,
    PF_HYLINK =     AF_HYLINK,
    PF_APPLETALK =  AF_APPLETALK,
    PF_VOICEVIEW =  AF_VOICEVIEW,
    PF_FIREFOX =    AF_FIREFOX,
    PF_UNKNOWN1 =   AF_UNKNOWN1,
    PF_BAN =        AF_BAN,
    PF_INET6 =      AF_INET6,

    PF_MAX        = AF_MAX,
}


enum: int
{
    SOL_SOCKET = 0xFFFF,
}


enum: int
{
    SO_DEBUG =        0x0001,
    SO_ACCEPTCONN =   0x0002,
    SO_REUSEADDR =    0x0004,
    SO_KEEPALIVE =    0x0008,
    SO_DONTROUTE =    0x0010,
    SO_BROADCAST =    0x0020,
    SO_USELOOPBACK =  0x0040,
    SO_LINGER =       0x0080,
    SO_DONTLINGER =   ~SO_LINGER,
    SO_OOBINLINE =    0x0100,
    SO_SNDBUF =       0x1001,
    SO_RCVBUF =       0x1002,
    SO_SNDLOWAT =     0x1003,
    SO_RCVLOWAT =     0x1004,
    SO_SNDTIMEO =     0x1005,
    SO_RCVTIMEO =     0x1006,
    SO_ERROR =        0x1007,
    SO_TYPE =         0x1008,
    SO_EXCLUSIVEADDRUSE = ~SO_REUSEADDR,

    TCP_NODELAY =    1,

    IP_OPTIONS                  = 1,

    IP_HDRINCL                  = 2,
    IP_TOS                      = 3,
    IP_TTL                      = 4,
    IP_MULTICAST_IF             = 9,
    IP_MULTICAST_TTL            = 10,
    IP_MULTICAST_LOOP           = 11,
    IP_ADD_MEMBERSHIP           = 12,
    IP_DROP_MEMBERSHIP          = 13,
    IP_DONTFRAGMENT             = 14,
    IP_ADD_SOURCE_MEMBERSHIP    = 15,
    IP_DROP_SOURCE_MEMBERSHIP   = 16,
    IP_BLOCK_SOURCE             = 17,
    IP_UNBLOCK_SOURCE           = 18,
    IP_PKTINFO                  = 19,

    IPV6_UNICAST_HOPS =    4,
    IPV6_MULTICAST_IF =    9,
    IPV6_MULTICAST_HOPS =  10,
    IPV6_MULTICAST_LOOP =  11,
    IPV6_ADD_MEMBERSHIP =  12,
    IPV6_DROP_MEMBERSHIP = 13,
    IPV6_JOIN_GROUP =      IPV6_ADD_MEMBERSHIP,
    IPV6_LEAVE_GROUP =     IPV6_DROP_MEMBERSHIP,
    IPV6_V6ONLY = 27,
}


/// Default FD_SETSIZE value.
/// In C/C++, it is redefinable by #define-ing the macro before #include-ing
/// winsock.h. In D, use the $(D FD_CREATE) function to allocate a $(D fd_set)
/// of an arbitrary size.
enum int FD_SETSIZE = 64;


struct fd_set_custom(uint SETSIZE)
{
    uint fd_count;
    SOCKET[SETSIZE] fd_array;
}

alias fd_set = fd_set_custom!FD_SETSIZE;

// Removes.
void FD_CLR(SOCKET fd, fd_set* set) pure @nogc
{
    uint c = set.fd_count;
    SOCKET* start = set.fd_array.ptr;
    SOCKET* stop = start + c;

    for (; start != stop; start++)
    {
        if (*start == fd)
            goto found;
    }
    return; //not found

    found:
    for (++start; start != stop; start++)
    {
        *(start - 1) = *start;
    }

    set.fd_count = c - 1;
}


// Tests.
int FD_ISSET(SOCKET fd, const(fd_set)* set) pure @nogc
{
const(SOCKET)* start = set.fd_array.ptr;
const(SOCKET)* stop = start + set.fd_count;

    for (; start != stop; start++)
    {
        if (*start == fd)
            return true;
    }
    return false;
}


// Adds.
void FD_SET(SOCKET fd, fd_set* set)     pure @nogc
{
    uint c = set.fd_count;
    set.fd_array.ptr[c] = fd;
    set.fd_count = c + 1;
}


// Resets to zero.
void FD_ZERO(fd_set* set) pure @nogc
{
    set.fd_count = 0;
}


/// Creates a new $(D fd_set) with the specified capacity.
fd_set* FD_CREATE(uint capacity) pure
{
    // Take into account alignment (SOCKET may be 64-bit and require 64-bit alignment on 64-bit systems)
    size_t size = (fd_set_custom!1).sizeof - SOCKET.sizeof + (SOCKET.sizeof * capacity);
    auto data = new ubyte[size];
    auto set = cast(fd_set*)data.ptr;
    FD_ZERO(set);
    return set;
}

struct linger
{
    ushort l_onoff;
    ushort l_linger;
}


struct protoent
{
    char* p_name;
    char** p_aliases;
    short p_proto;
}


struct servent
{
    char* s_name;
    char** s_aliases;

    version (Win64)
    {
        char* s_proto;
        short s_port;
    }
    else version (Win32)
    {
        short s_port;
        char* s_proto;
    }
}


/+
union in6_addr
{
    private union _u_t
    {
        ubyte[16] Byte;
        ushort[8] Word;
    }
    _u_t u;
}


struct in_addr6
{
    ubyte[16] s6_addr;
}
+/

@safe pure @nogc
{
    ushort htons(ushort x);
    uint htonl(uint x);
    ushort ntohs(ushort x);
    uint ntohl(uint x);
}


enum: int
{
    SOCK_STREAM =     1,
    SOCK_DGRAM =      2,
    SOCK_RAW =        3,
    SOCK_RDM =        4,
    SOCK_SEQPACKET =  5,
}


enum: int
{
    IPPROTO_IP =    0,
    IPPROTO_ICMP =  1,
    IPPROTO_IGMP =  2,
    IPPROTO_GGP =   3,
    IPPROTO_TCP =   6,
    IPPROTO_PUP =   12,
    IPPROTO_UDP =   17,
    IPPROTO_IDP =   22,
    IPPROTO_IPV6 =  41,
    IPPROTO_ND =    77,
    IPPROTO_RAW =   255,

    IPPROTO_MAX =   256,
}


enum: int
{
    MSG_OOB =        0x1,
    MSG_PEEK =       0x2,
    MSG_DONTROUTE =  0x4
}


enum: int
{
    SD_RECEIVE =  0,
    SD_SEND =     1,
    SD_BOTH =     2,
}


enum: uint
{
    INADDR_ANY =        0,
    INADDR_LOOPBACK =   0x7F000001,
    INADDR_BROADCAST =  0xFFFFFFFF,
    INADDR_NONE =       0xFFFFFFFF,
    ADDR_ANY =          INADDR_ANY,
}


enum: int
{
    AI_PASSIVE = 0x1,
    AI_CANONNAME = 0x2,
    AI_NUMERICHOST = 0x4,
    AI_ADDRCONFIG = 0x0400,
    AI_NON_AUTHORITATIVE = 0x04000,
    AI_SECURE = 0x08000,
    AI_RETURN_PREFERRED_NAMES = 0x010000,
}


struct timeval
{
    int tv_sec;
    int tv_usec;
}


union in_addr
{
    private union _S_un_t
    {
        private struct _S_un_b_t
        {
            ubyte s_b1, s_b2, s_b3, s_b4;
        }
        _S_un_b_t S_un_b;

        private struct _S_un_w_t
        {
            ushort s_w1, s_w2;
        }
        _S_un_w_t S_un_w;

        uint S_addr;
    }
    _S_un_t S_un;

    uint s_addr;

    struct
    {
        ubyte s_net, s_host;

        union
        {
            ushort s_imp;

            struct
            {
                ubyte s_lh, s_impno;
            }
        }
    }
}


union in6_addr
{
    private union _in6_u_t
    {
        ubyte[16] u6_addr8;
        ushort[8] u6_addr16;
        uint[4] u6_addr32;
    }
    _in6_u_t in6_u;

    ubyte[16] s6_addr8;
    ushort[8] s6_addr16;
    uint[4] s6_addr32;

    alias s6_addr = s6_addr8;
}


enum in6_addr IN6ADDR_ANY = { s6_addr8: [0] };
enum in6_addr IN6ADDR_LOOPBACK = { s6_addr8: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1] };
//alias IN6ADDR_ANY_INIT = IN6ADDR_ANY;
//alias IN6ADDR_LOOPBACK_INIT = IN6ADDR_LOOPBACK;

enum int INET_ADDRSTRLEN = 16;
enum int INET6_ADDRSTRLEN = 46;




struct sockaddr
{
    short sa_family;
    ubyte[14] sa_data;
}
alias sockaddr SOCKADDR;
alias SOCKADDR* PSOCKADDR, LPSOCKADDR;

struct sockaddr_storage
{
    short     ss_family;
    char[6]   __ss_pad1 = void;
    long      __ss_align;
    char[112] __ss_pad2 = void;
}
alias sockaddr_storage SOCKADDR_STORAGE;
alias SOCKADDR_STORAGE* PSOCKADDR_STORAGE;

struct sockaddr_in
{
    short sin_family = AF_INET;
    ushort sin_port;
    in_addr sin_addr;
    ubyte[8] sin_zero;
}
alias sockaddr_in SOCKADDR_IN;
alias SOCKADDR_IN* PSOCKADDR_IN, LPSOCKADDR_IN;


struct sockaddr_in6
{
    short sin6_family = AF_INET6;
    ushort sin6_port;
    uint sin6_flowinfo;
    in6_addr sin6_addr;
    uint sin6_scope_id;
}


struct addrinfo
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    size_t ai_addrlen;
    char* ai_canonname;
    sockaddr* ai_addr;
    addrinfo* ai_next;
}


struct hostent
{
    char* h_name;
    char** h_aliases;
    short h_addrtype;
    short h_length;
    char** h_addr_list;


    char* h_addr() @safe pure nothrow @nogc
    {
        return h_addr_list[0];
    }
}

// Note: These are Winsock2!!
struct WSAOVERLAPPED;
alias LPWSAOVERLAPPED = WSAOVERLAPPED*;
alias LPWSAOVERLAPPED_COMPLETION_ROUTINE = void function(uint, uint, LPWSAOVERLAPPED, uint);
int WSAIoctl(SOCKET s, uint dwIoControlCode,
    void* lpvInBuffer, uint cbInBuffer,
    void* lpvOutBuffer, uint cbOutBuffer,
    uint* lpcbBytesReturned,
    LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);


enum IOC_VENDOR = 0x18000000;
enum SIO_KEEPALIVE_VALS = IOC_IN | IOC_VENDOR | 4;

/* Argument structure for SIO_KEEPALIVE_VALS */
struct tcp_keepalive
{
    uint onoff;
    uint keepalivetime;
    uint keepaliveinterval;
}
                                                                                                                                                                                    /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winspool.d)
 */
module core.sys.windows.winspool;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "winspool");

private import core.sys.windows.w32api, core.sys.windows.windef, core.sys.windows.wingdi;
private import core.sys.windows.winbase; // for SYSTEMTIME

// FIXME: clean up Windows version support

enum DI_CHANNEL=1;
enum DI_CHANNEL_WRITE=2;
enum DI_READ_SPOOL_JOB=3;

enum FORM_BUILTIN=1;

enum JOB_CONTROL_PAUSE=1;
enum JOB_CONTROL_RESUME=2;
enum JOB_CONTROL_CANCEL=3;
enum JOB_CONTROL_RESTART=4;
enum JOB_CONTROL_DELETE=5;
enum JOB_STATUS_PAUSED=1;
enum JOB_STATUS_ERROR=2;
enum JOB_STATUS_DELETING=4;
enum JOB_STATUS_SPOOLING=8;
enum JOB_STATUS_PRINTING=16;
enum JOB_STATUS_OFFLINE=32;
enum JOB_STATUS_PAPEROUT=0x40;
enum JOB_STATUS_PRINTED=0x80;
enum JOB_STATUS_DELETED=0x100;
enum JOB_STATUS_BLOCKED_DEVQ=0x200;
enum JOB_STATUS_USER_INTERVENTION=0x400;

enum JOB_POSITION_UNSPECIFIED=0;

enum JOB_NOTIFY_TYPE=1;

enum JOB_NOTIFY_FIELD_PRINTER_NAME=0;
enum JOB_NOTIFY_FIELD_MACHINE_NAME=1;
enum JOB_NOTIFY_FIELD_PORT_NAME=2;
enum JOB_NOTIFY_FIELD_USER_NAME=3;
enum JOB_NOTIFY_FIELD_NOTIFY_NAME=4;
enum JOB_NOTIFY_FIELD_DATATYPE=5;
enum JOB_NOTIFY_FIELD_PRINT_PROCESSOR=6;
enum JOB_NOTIFY_FIELD_PARAMETERS=7;
enum JOB_NOTIFY_FIELD_DRIVER_NAME=8;
enum JOB_NOTIFY_FIELD_DEVMODE=9;
enum JOB_NOTIFY_FIELD_STATUS=10;
enum JOB_NOTIFY_FIELD_STATUS_STRING=11;
enum JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR=12;
enum JOB_NOTIFY_FIELD_DOCUMENT=13;
enum JOB_NOTIFY_FIELD_PRIORITY=14;
enum JOB_NOTIFY_FIELD_POSITION=15;
enum JOB_NOTIFY_FIELD_SUBMITTED=16;
enum JOB_NOTIFY_FIELD_START_TIME=17;
enum JOB_NOTIFY_FIELD_UNTIL_TIME=18;
enum JOB_NOTIFY_FIELD_TIME=19;
enum JOB_NOTIFY_FIELD_TOTAL_PAGES=20;
enum JOB_NOTIFY_FIELD_PAGES_PRINTED=21;
enum JOB_NOTIFY_FIELD_TOTAL_BYTES=22;
enum JOB_NOTIFY_FIELD_BYTES_PRINTED=23;

enum JOB_ACCESS_ADMINISTER = 16;
enum JOB_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | JOB_ACCESS_ADMINISTER;
enum JOB_READ       = STANDARD_RIGHTS_READ     | JOB_ACCESS_ADMINISTER;
enum JOB_WRITE      = STANDARD_RIGHTS_WRITE    | JOB_ACCESS_ADMINISTER;
enum JOB_EXECUTE    = STANDARD_RIGHTS_EXECUTE  | JOB_ACCESS_ADMINISTER;

enum PRINTER_NOTIFY_OPTIONS_REFRESH=1;
enum PRINTER_ACCESS_ADMINISTER=4;
enum PRINTER_ACCESS_USE=8;

enum PRINTER_ERROR_INFORMATION=0x80000000;
enum PRINTER_ERROR_WARNING=0x40000000;
enum PRINTER_ERROR_SEVERE=0x20000000;
enum PRINTER_ERROR_OUTOFPAPER=1;
enum PRINTER_ERROR_JAM=2;
enum PRINTER_ERROR_OUTOFTONER=4;

enum PRINTER_CONTROL_PAUSE=1;
enum PRINTER_CONTROL_RESUME=2;
enum PRINTER_CONTROL_PURGE=3;
enum PRINTER_CONTROL_SET_STATUS=4;

enum PRINTER_STATUS_PAUSED = 1;
enum PRINTER_STATUS_ERROR = 2;
enum PRINTER_STATUS_PENDING_DELETION = 4;
enum PRINTER_STATUS_PAPER_JAM = 8;
enum PRINTER_STATUS_PAPER_OUT = 0x10;
enum PRINTER_STATUS_MANUAL_FEED = 0x20;
enum PRINTER_STATUS_PAPER_PROBLEM = 0x40;
enum PRINTER_STATUS_OFFLINE = 0x80;
enum PRINTER_STATUS_IO_ACTIVE = 0x100;
enum PRINTER_STATUS_BUSY = 0x200;
enum PRINTER_STATUS_PRINTING = 0x400;
enum PRINTER_STATUS_OUTPUT_BIN_FULL = 0x800;
enum PRINTER_STATUS_NOT_AVAILABLE = 0x1000;
enum PRINTER_STATUS_WAITING = 0x2000;
enum PRINTER_STATUS_PROCESSING = 0x4000;
enum PRINTER_STATUS_INITIALIZING = 0x8000;
enum PRINTER_STATUS_WARMING_UP = 0x10000;
enum PRINTER_STATUS_TONER_LOW = 0x20000;
enum PRINTER_STATUS_NO_TONER = 0x40000;
enum PRINTER_STATUS_PAGE_PUNT = 0x80000;
enum PRINTER_STATUS_USER_INTERVENTION = 0x100000;
enum PRINTER_STATUS_OUT_OF_MEMORY = 0x200000;
enum PRINTER_STATUS_DOOR_OPEN = 0x400000;
enum PRINTER_STATUS_SERVER_UNKNOWN = 0x800000;
enum PRINTER_STATUS_POWER_SAVE = 0x1000000;

enum PRINTER_ATTRIBUTE_QUEUED=1;
enum PRINTER_ATTRIBUTE_DIRECT=2;
enum PRINTER_ATTRIBUTE_DEFAULT=4;
enum PRINTER_ATTRIBUTE_SHARED=8;
enum PRINTER_ATTRIBUTE_NETWORK=0x10;
enum PRINTER_ATTRIBUTE_HIDDEN=0x20;
enum PRINTER_ATTRIBUTE_LOCAL=0x40;
enum PRINTER_ATTRIBUTE_ENABLE_DEVQ=0x80;
enum PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS=0x100;
enum PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST=0x200;
enum PRINTER_ATTRIBUTE_WORK_OFFLINE=0x400;
enum PRINTER_ATTRIBUTE_ENABLE_BIDI=0x800;
enum PRINTER_ATTRIBUTE_RAW_ONLY=0x1000;
enum PRINTER_ATTRIBUTE_PUBLISHED=0x2000;

enum PRINTER_ENUM_DEFAULT=1;
enum PRINTER_ENUM_LOCAL=2;
enum PRINTER_ENUM_CONNECTIONS=4;
enum PRINTER_ENUM_FAVORITE=4;
enum PRINTER_ENUM_NAME=8;
enum PRINTER_ENUM_REMOTE=16;
enum PRINTER_ENUM_SHARED=32;
enum PRINTER_ENUM_NETWORK=0x40;
enum PRINTER_ENUM_EXPAND=0x4000;
enum PRINTER_ENUM_CONTAINER=0x8000;
enum PRINTER_ENUM_ICONMASK=0xff0000;
enum PRINTER_ENUM_ICON1=0x10000;
enum PRINTER_ENUM_ICON2=0x20000;
enum PRINTER_ENUM_ICON3=0x40000;
enum PRINTER_ENUM_ICON4=0x80000;
enum PRINTER_ENUM_ICON5=0x100000;
enum PRINTER_ENUM_ICON6=0x200000;
enum PRINTER_ENUM_ICON7=0x400000;
enum PRINTER_ENUM_ICON8=0x800000;

enum PRINTER_NOTIFY_TYPE=0;

enum PRINTER_NOTIFY_FIELD_SERVER_NAME=0;
enum PRINTER_NOTIFY_FIELD_PRINTER_NAME=1;
enum PRINTER_NOTIFY_FIELD_SHARE_NAME=2;
enum PRINTER_NOTIFY_FIELD_PORT_NAME=3;
enum PRINTER_NOTIFY_FIELD_DRIVER_NAME=4;
enum PRINTER_NOTIFY_FIELD_COMMENT=5;
enum PRINTER_NOTIFY_FIELD_LOCATION=6;
enum PRINTER_NOTIFY_FIELD_DEVMODE=7;
enum PRINTER_NOTIFY_FIELD_SEPFILE=8;
enum PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR=9;
enum PRINTER_NOTIFY_FIELD_PARAMETERS=10;
enum PRINTER_NOTIFY_FIELD_DATATYPE=11;
enum PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR=12;
enum PRINTER_NOTIFY_FIELD_ATTRIBUTES=13;
enum PRINTER_NOTIFY_FIELD_PRIORITY=14;
enum PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY=15;
enum PRINTER_NOTIFY_FIELD_START_TIME=16;
enum PRINTER_NOTIFY_FIELD_UNTIL_TIME=17;
enum PRINTER_NOTIFY_FIELD_STATUS=18;
enum PRINTER_NOTIFY_FIELD_STATUS_STRING=19;
enum PRINTER_NOTIFY_FIELD_CJOBS=20;
enum PRINTER_NOTIFY_FIELD_AVERAGE_PPM=21;
enum PRINTER_NOTIFY_FIELD_TOTAL_PAGES=22;
enum PRINTER_NOTIFY_FIELD_PAGES_PRINTED=23;
enum PRINTER_NOTIFY_FIELD_TOTAL_BYTES=24;
enum PRINTER_NOTIFY_FIELD_BYTES_PRINTED=25;

enum PRINTER_CHANGE_ADD_PRINTER=1;
enum PRINTER_CHANGE_SET_PRINTER=2;
enum PRINTER_CHANGE_DELETE_PRINTER=4;
enum PRINTER_CHANGE_FAILED_CONNECTION_PRINTER=8;
enum PRINTER_CHANGE_PRINTER=0xFF;
enum PRINTER_CHANGE_ADD_JOB=0x100;
enum PRINTER_CHANGE_SET_JOB=0x200;
enum PRINTER_CHANGE_DELETE_JOB=0x400;
enum PRINTER_CHANGE_WRITE_JOB=0x800;
enum PRINTER_CHANGE_JOB=0xFF00;
enum PRINTER_CHANGE_ADD_FORM=0x10000;
enum PRINTER_CHANGE_SET_FORM=0x20000;
enum PRINTER_CHANGE_DELETE_FORM=0x40000;
enum PRINTER_CHANGE_FORM=0x70000;
enum PRINTER_CHANGE_ADD_PORT=0x100000;
enum PRINTER_CHANGE_CONFIGURE_PORT=0x200000;
enum PRINTER_CHANGE_DELETE_PORT=0x400000;
enum PRINTER_CHANGE_PORT=0x700000;
enum PRINTER_CHANGE_ADD_PRINT_PROCESSOR=0x1000000;
enum PRINTER_CHANGE_DELETE_PRINT_PROCESSOR=0x4000000;
enum PRINTER_CHANGE_PRINT_PROCESSOR=0x7000000;
enum PRINTER_CHANGE_ADD_PRINTER_DRIVER=0x10000000;
enum PRINTER_CHANGE_SET_PRINTER_DRIVER=0x20000000;
enum PRINTER_CHANGE_DELETE_PRINTER_DRIVER=0x40000000;
enum PRINTER_CHANGE_PRINTER_DRIVER=0x70000000;
enum PRINTER_CHANGE_TIMEOUT=0x80000000;
enum PRINTER_CHANGE_ALL=0x7777FFFF;

enum PRINTER_NOTIFY_INFO_DISCARDED=1;
enum PRINTER_ALL_ACCESS=(STANDARD_RIGHTS_REQUIRED|PRINTER_ACCESS_ADMINISTER|PRINTER_ACCESS_USE);
enum PRINTER_READ=(STANDARD_RIGHTS_READ|PRINTER_ACCESS_USE);
enum PRINTER_WRITE=(STANDARD_RIGHTS_WRITE|PRINTER_ACCESS_USE);
enum PRINTER_EXECUTE=(STANDARD_RIGHTS_EXECUTE|PRINTER_ACCESS_USE);
enum NO_PRIORITY=0;
enum MAX_PRIORITY=99;
enum MIN_PRIORITY=1;
enum DEF_PRIORITY=1;
enum PORT_TYPE_WRITE=1;
enum PORT_TYPE_READ=2;
enum PORT_TYPE_REDIRECTED=4;
enum PORT_TYPE_NET_ATTACHED=8;
enum SERVER_ACCESS_ADMINISTER=1;
enum SERVER_ACCESS_ENUMERATE=2;

enum SERVER_ALL_ACCESS=(STANDARD_RIGHTS_REQUIRED|SERVER_ACCESS_ADMINISTER|SERVER_ACCESS_ENUMERATE);
enum SERVER_READ=(STANDARD_RIGHTS_READ|SERVER_ACCESS_ENUMERATE);
enum SERVER_WRITE=(STANDARD_RIGHTS_WRITE|SERVER_ACCESS_ADMINISTER|SERVER_ACCESS_ENUMERATE);
enum SERVER_EXECUTE=(STANDARD_RIGHTS_EXECUTE|SERVER_ACCESS_ENUMERATE);

enum PORT_STATUS_TYPE_ERROR=1;
enum PORT_STATUS_TYPE_WARNING=2;
enum PORT_STATUS_TYPE_INFO=3;

enum PORT_STATUS_OFFLINE=1;
enum PORT_STATUS_PAPER_JAM=2;
enum PORT_STATUS_PAPER_OUT=3;
enum PORT_STATUS_OUTPUT_BIN_FULL=4;
enum PORT_STATUS_PAPER_PROBLEM=5;
enum PORT_STATUS_NO_TONER=6;
enum PORT_STATUS_DOOR_OPEN=7;
enum PORT_STATUS_USER_INTERVENTION=8;
enum PORT_STATUS_OUT_OF_MEMORY=9;
enum PORT_STATUS_TONER_LOW=10;
enum PORT_STATUS_WARMING_UP=11;
enum PORT_STATUS_POWER_SAVE=12;

struct ADDJOB_INFO_1A {
    LPSTR Path;
    DWORD JobId;
}
alias ADDJOB_INFO_1A* PADDJOB_INFO_1A, LPADDJOB_INFO_1A;

struct ADDJOB_INFO_1W {
    LPWSTR Path;
    DWORD JobId;
}
alias ADDJOB_INFO_1W* PADDJOB_INFO_1W, LPADDJOB_INFO_1W;

struct DATATYPES_INFO_1A {
    LPSTR pName;
}
alias DATATYPES_INFO_1A* PDATATYPES_INFO_1A, LPDATATYPES_INFO_1A;

struct DATATYPES_INFO_1W {
    LPWSTR pName;
}
alias DATATYPES_INFO_1W* PDATATYPES_INFO_1W, LPDATATYPES_INFO_1W;

struct JOB_INFO_1A {
    DWORD JobId;
    LPSTR pPrinterName;
    LPSTR pMachineName;
    LPSTR pUserName;
    LPSTR pDocument;
    LPSTR pDatatype;
    LPSTR pStatus;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD TotalPages;
    DWORD PagesPrinted;
    SYSTEMTIME Submitted;
}
alias JOB_INFO_1A* PJOB_INFO_1A, LPJOB_INFO_1A;

struct JOB_INFO_1W {
    DWORD JobId;
    LPWSTR pPrinterName;
    LPWSTR pMachineName;
    LPWSTR pUserName;
    LPWSTR pDocument;
    LPWSTR pDatatype;
    LPWSTR pStatus;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD TotalPages;
    DWORD PagesPrinted;
    SYSTEMTIME Submitted;
}
alias JOB_INFO_1W* PJOB_INFO_1W, LPJOB_INFO_1W;

struct JOB_INFO_2A {
    DWORD JobId;
    LPSTR pPrinterName;
    LPSTR pMachineName;
    LPSTR pUserName;
    LPSTR pDocument;
    LPSTR pNotifyName;
    LPSTR pDatatype;
    LPSTR pPrintProcessor;
    LPSTR pParameters;
    LPSTR pDriverName;
    LPDEVMODEA pDevMode;
    LPSTR pStatus;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD TotalPages;
    DWORD Size;
    SYSTEMTIME Submitted;
    DWORD Time;
    DWORD PagesPrinted;
}
alias JOB_INFO_2A* PJOB_INFO_2A, LPJOB_INFO_2A;

struct JOB_INFO_2W {
    DWORD JobId;
    LPWSTR pPrinterName;
    LPWSTR pMachineName;
    LPWSTR pUserName;
    LPWSTR pDocument;
    LPWSTR pNotifyName;
    LPWSTR pDatatype;
    LPWSTR pPrintProcessor;
    LPWSTR pParameters;
    LPWSTR pDriverName;
    LPDEVMODEW pDevMode;
    LPWSTR pStatus;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD Status;
    DWORD Priority;
    DWORD Position;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD TotalPages;
    DWORD Size;
    SYSTEMTIME Submitted;
    DWORD Time;
    DWORD PagesPrinted;
}
alias JOB_INFO_2W* PJOB_INFO_2W, LPJOB_INFO_2W;

struct DOC_INFO_1A {
    LPSTR pDocName;
    LPSTR pOutputFile;
    LPSTR pDatatype;
}
alias DOC_INFO_1A* PDOC_INFO_1A, LPDOC_INFO_1A;

struct DOC_INFO_1W {
    LPWSTR pDocName;
    LPWSTR pOutputFile;
    LPWSTR pDatatype;
}
alias DOC_INFO_1W* PDOC_INFO_1W, LPDOC_INFO_1W;

struct DOC_INFO_2A {
    LPSTR pDocName;
    LPSTR pOutputFile;
    LPSTR pDatatype;
    DWORD dwMode;
    DWORD JobId;
}
alias DOC_INFO_2A* PDOC_INFO_2A, LPDOC_INFO_2A;

struct DOC_INFO_2W {
    LPWSTR pDocName;
    LPWSTR pOutputFile;
    LPWSTR pDatatype;
    DWORD  dwMode;
    DWORD  JobId;
}
alias DOC_INFO_2W* PDOC_INFO_2W, LPDOC_INFO_2W;

struct DRIVER_INFO_1A {
    LPSTR pName;
}
alias DRIVER_INFO_1A* PDRIVER_INFO_1A, LPDRIVER_INFO_1A;

struct DRIVER_INFO_1W {
    LPWSTR pName;
}
alias DRIVER_INFO_1W* PDRIVER_INFO_1W, LPDRIVER_INFO_1W;

struct DRIVER_INFO_2A {
    DWORD cVersion;
    LPSTR pName;
    LPSTR pEnvironment;
    LPSTR pDriverPath;
    LPSTR pDataFile;
    LPSTR pConfigFile;
}
alias DRIVER_INFO_2A* PDRIVER_INFO_2A, LPDRIVER_INFO_2A;

struct DRIVER_INFO_2W {
    DWORD  cVersion;
    LPWSTR pName;
    LPWSTR pEnvironment;
    LPWSTR pDriverPath;
    LPWSTR pDataFile;
    LPWSTR pConfigFile;
}
alias DRIVER_INFO_2W* PDRIVER_INFO_2W, LPDRIVER_INFO_2W;

struct DRIVER_INFO_3A {
    DWORD cVersion;
    LPSTR pName;
    LPSTR pEnvironment;
    LPSTR pDriverPath;
    LPSTR pDataFile;
    LPSTR pConfigFile;
    LPSTR pHelpFile;
    LPSTR pDependentFiles;
    LPSTR pMonitorName;
    LPSTR pDefaultDataType;
}
alias DRIVER_INFO_3A* PDRIVER_INFO_3A, LPDRIVER_INFO_3A;

struct DRIVER_INFO_3W {
    DWORD  cVersion;
    LPWSTR pName;
    LPWSTR pEnvironment;
    LPWSTR pDriverPath;
    LPWSTR pDataFile;
    LPWSTR pConfigFile;
    LPWSTR pHelpFile;
    LPWSTR pDependentFiles;
    LPWSTR pMonitorName;
    LPWSTR pDefaultDataType;
}
alias DRIVER_INFO_3W* PDRIVER_INFO_3W, LPDRIVER_INFO_3W;

struct MONITOR_INFO_1A {
    LPSTR pName;
}
alias MONITOR_INFO_1A* PMONITOR_INFO_1A, LPMONITOR_INFO_1A;

struct MONITOR_INFO_1W {
    LPWSTR pName;
}
alias MONITOR_INFO_1W* PMONITOR_INFO_1W, LPMONITOR_INFO_1W;

struct PORT_INFO_1A {
    LPSTR pName;
}
alias PORT_INFO_1A* PPORT_INFO_1A, LPPORT_INFO_1A;

struct PORT_INFO_1W {
    LPWSTR pName;
}
alias PORT_INFO_1W* PPORT_INFO_1W, LPPORT_INFO_1W;

struct MONITOR_INFO_2A {
    LPSTR pName;
    LPSTR pEnvironment;
    LPSTR pDLLName;
}
alias MONITOR_INFO_2A* PMONITOR_INFO_2A, LPMONITOR_INFO_2A;

struct MONITOR_INFO_2W {
    LPWSTR pName;
    LPWSTR pEnvironment;
    LPWSTR pDLLName;
}
alias MONITOR_INFO_2W* PMONITOR_INFO_2W, LPMONITOR_INFO_2W;

struct PORT_INFO_2A {
    LPSTR pPortName;
    LPSTR pMonitorName;
    LPSTR pDescription;
    DWORD fPortType;
    DWORD Reserved;
}
alias PORT_INFO_2A* PPORT_INFO_2A, LPPORT_INFO_2A;

struct PORT_INFO_2W {
    LPWSTR pPortName;
    LPWSTR pMonitorName;
    LPWSTR pDescription;
    DWORD fPortType;
    DWORD Reserved;
}
alias PORT_INFO_2W* PPORT_INFO_2W, LPPORT_INFO_2W;

struct PORT_INFO_3A {
    DWORD dwStatus;
    LPSTR pszStatus;
    DWORD dwSeverity;
}
alias PORT_INFO_3A* PPORT_INFO_3A, LPPORT_INFO_3A;

struct PORT_INFO_3W {
    DWORD dwStatus;
    LPWSTR pszStatus;
    DWORD dwSeverity;
}
alias PORT_INFO_3W* PPORT_INFO_3W, LPPORT_INFO_3W;

struct PRINTER_INFO_1A {
    DWORD Flags;
    LPSTR pDescription;
    LPSTR pName;
    LPSTR pComment;
}
alias PRINTER_INFO_1A* PPRINTER_INFO_1A, LPPRINTER_INFO_1A;

struct PRINTER_INFO_1W {
    DWORD  Flags;
    LPWSTR pDescription;
    LPWSTR pName;
    LPWSTR pComment;
}
alias PRINTER_INFO_1W* PPRINTER_INFO_1W, LPPRINTER_INFO_1W;

struct PRINTER_INFO_2A {
    LPSTR pServerName;
    LPSTR pPrinterName;
    LPSTR pShareName;
    LPSTR pPortName;
    LPSTR pDriverName;
    LPSTR pComment;
    LPSTR pLocation;
    LPDEVMODEA pDevMode;
    LPSTR pSepFile;
    LPSTR pPrintProcessor;
    LPSTR pDatatype;
    LPSTR pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD Attributes;
    DWORD Priority;
    DWORD DefaultPriority;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD Status;
    DWORD cJobs;
    DWORD AveragePPM;
}
alias PRINTER_INFO_2A* PPRINTER_INFO_2A, LPPRINTER_INFO_2A;

struct PRINTER_INFO_2W {
    LPWSTR pServerName;
    LPWSTR pPrinterName;
    LPWSTR pShareName;
    LPWSTR pPortName;
    LPWSTR pDriverName;
    LPWSTR pComment;
    LPWSTR pLocation;
    LPDEVMODEW pDevMode;
    LPWSTR pSepFile;
    LPWSTR pPrintProcessor;
    LPWSTR pDatatype;
    LPWSTR pParameters;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    DWORD Attributes;
    DWORD Priority;
    DWORD DefaultPriority;
    DWORD StartTime;
    DWORD UntilTime;
    DWORD Status;
    DWORD cJobs;
    DWORD AveragePPM;
}
alias PRINTER_INFO_2W* PPRINTER_INFO_2W, LPPRINTER_INFO_2W;

struct PRINTER_INFO_3 {
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
}
alias PRINTER_INFO_3* PPRINTER_INFO_3, LPPRINTER_INFO_3;

struct PRINTER_INFO_4A {
    LPSTR pPrinterName;
    LPSTR pServerName;
    DWORD Attributes;
}
alias PRINTER_INFO_4A* PPRINTER_INFO_4A, LPPRINTER_INFO_4A;

struct PRINTER_INFO_4W {
    LPWSTR pPrinterName;
    LPWSTR pServerName;
    DWORD Attributes;
}
alias PRINTER_INFO_4W* PPRINTER_INFO_4W, LPPRINTER_INFO_4W;

struct PRINTER_INFO_5A {
    LPSTR pPrinterName;
    LPSTR pPortName;
    DWORD Attributes;
    DWORD DeviceNotSelectedTimeout;
    DWORD TransmissionRetryTimeout;
}
alias PRINTER_INFO_5A* PPRINTER_INFO_5A, LPPRINTER_INFO_5A;

struct PRINTER_INFO_5W {
    LPWSTR pPrinterName;
    LPWSTR pPortName;
    DWORD Attributes;
    DWORD DeviceNotSelectedTimeout;
    DWORD TransmissionRetryTimeout;
}
alias PRINTER_INFO_5W* PPRINTER_INFO_5W, LPPRINTER_INFO_5W;

struct PRINTER_INFO_6 {
    DWORD dwStatus;
}
alias PRINTER_INFO_6* PPRINTER_INFO_6, LPPRINTER_INFO_6;

struct PRINTPROCESSOR_INFO_1A {
    LPSTR pName;
}
alias PRINTPROCESSOR_INFO_1A* PPRINTPROCESSOR_INFO_1A, LPPRINTPROCESSOR_INFO_1A;

struct PRINTPROCESSOR_INFO_1W {
    LPWSTR pName;
}
alias PRINTPROCESSOR_INFO_1W* PPRINTPROCESSOR_INFO_1W, LPPRINTPROCESSOR_INFO_1W;

struct PRINTER_NOTIFY_INFO_DATA {
    WORD  Type;
    WORD  Field;
    DWORD Reserved;
    DWORD Id;
    union _NotifyData {
        DWORD[2] adwData;
        struct _Data {
            DWORD cbBuf;
            PVOID pBuf;
        }
        _Data Data;
    }
    _NotifyData NotifyData;
}
alias PRINTER_NOTIFY_INFO_DATA* PPRINTER_NOTIFY_INFO_DATA, LPPRINTER_NOTIFY_INFO_DATA;

struct PRINTER_NOTIFY_INFO {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    PRINTER_NOTIFY_INFO_DATA[1] aData;
}
alias PRINTER_NOTIFY_INFO* PPRINTER_NOTIFY_INFO, LPPRINTER_NOTIFY_INFO;

struct FORM_INFO_1A {
    DWORD Flags;
    LPSTR pName;
    SIZEL Size;
    RECTL ImageableArea;
}
alias FORM_INFO_1A* PFORM_INFO_1A, LPFORM_INFO_1A;

struct FORM_INFO_1W {
    DWORD  Flags;
    LPWSTR pName;
    SIZEL  Size;
    RECTL  ImageableArea;
}
alias FORM_INFO_1W* PFORM_INFO_1W, LPFORM_INFO_1W;

struct PRINTER_DEFAULTSA {
    LPSTR       pDatatype;
    LPDEVMODE   pDevMode;
    ACCESS_MASK DesiredAccess;
}
alias PRINTER_DEFAULTSA* PPRINTER_DEFAULTSA, LPPRINTER_DEFAULTSA;

struct PRINTER_DEFAULTSW {
    LPWSTR pDatatype;
    LPDEVMODE pDevMode;
    ACCESS_MASK DesiredAccess;
}
alias PRINTER_DEFAULTSW* PPRINTER_DEFAULTSW, LPPRINTER_DEFAULTSW;

extern (Windows):
BOOL AbortPrinter(HANDLE);
BOOL AddFormA(HANDLE, DWORD, PBYTE);
BOOL AddFormW(HANDLE, DWORD, PBYTE);
BOOL AddJobA(HANDLE, DWORD, PBYTE, DWORD, PDWORD);
BOOL AddJobW(HANDLE, DWORD, PBYTE, DWORD, PDWORD);
BOOL AddMonitorA(LPSTR, DWORD, PBYTE);
BOOL AddMonitorW(LPWSTR, DWORD, PBYTE);
BOOL AddPortA(LPSTR, HWND, LPSTR);
BOOL AddPortW(LPWSTR, HWND, LPWSTR);
HANDLE AddPrinterA(LPSTR, DWORD, PBYTE);
HANDLE AddPrinterW(LPWSTR, DWORD, PBYTE);
BOOL AddPrinterConnectionA(LPSTR);
BOOL AddPrinterConnectionW(LPWSTR);
BOOL AddPrinterDriverA(LPSTR, DWORD, PBYTE);
BOOL AddPrinterDriverW(LPWSTR, DWORD, PBYTE);
BOOL AddPrintProcessorA(LPSTR, LPSTR, LPSTR, LPSTR);
BOOL AddPrintProcessorW(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
BOOL AddPrintProvidorA(LPSTR, DWORD, PBYTE);
BOOL AddPrintProvidorW(LPWSTR, DWORD, PBYTE);
LONG AdvancedDocumentPropertiesA(HWND, HANDLE, LPSTR, PDEVMODE, PDEVMODEA);
LONG AdvancedDocumentPropertiesW(HWND, HANDLE, LPWSTR, PDEVMODE, PDEVMODEW);
BOOL ClosePrinter(HANDLE);
BOOL ConfigurePortA(LPSTR, HWND, LPSTR);
BOOL ConfigurePortW(LPWSTR, HWND, LPWSTR);
HANDLE ConnectToPrinterDlg(HWND, DWORD);
BOOL DeleteFormA(HANDLE, LPSTR);
BOOL DeleteFormW(HANDLE, LPWSTR);
BOOL DeleteMonitorA(LPSTR, LPSTR, LPSTR);
BOOL DeleteMonitorW(LPWSTR, LPWSTR, LPWSTR);
BOOL DeletePortA(LPSTR, HWND, LPSTR);
BOOL DeletePortW(LPWSTR, HWND, LPWSTR);
BOOL DeletePrinter(HANDLE);
BOOL DeletePrinterConnectionA(LPSTR);
BOOL DeletePrinterConnectionW(LPWSTR);
DWORD DeletePrinterDataA(HANDLE, LPSTR);
DWORD DeletePrinterDataW(HANDLE, LPWSTR);
BOOL DeletePrinterDriverA(LPSTR, LPSTR, LPSTR);
BOOL DeletePrinterDriverW(LPWSTR, LPWSTR, LPWSTR);
BOOL DeletePrintProcessorA(LPSTR, LPSTR, LPSTR);
BOOL DeletePrintProcessorW(LPWSTR, LPWSTR, LPWSTR);
BOOL DeletePrintProvidorA(LPSTR, LPSTR, LPSTR);
BOOL DeletePrintProvidorW(LPWSTR, LPWSTR, LPWSTR);
LONG DocumentPropertiesA(HWND, HANDLE, LPSTR, PDEVMODEA, PDEVMODEA, DWORD);
LONG DocumentPropertiesW(HWND, HANDLE, LPWSTR, PDEVMODEW, PDEVMODEW, DWORD);
BOOL EndDocPrinter(HANDLE);
BOOL EndPagePrinter(HANDLE);
BOOL EnumFormsA(HANDLE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumFormsW(HANDLE, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumJobsA(HANDLE, DWORD, DWORD, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumJobsW(HANDLE, DWORD, DWORD, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumMonitorsA(LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumMonitorsW(LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPortsA(LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPortsW(LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
DWORD EnumPrinterDataA(HANDLE, DWORD, LPSTR, DWORD, PDWORD, PDWORD, PBYTE, DWORD, PDWORD);
DWORD EnumPrinterDataW(HANDLE, DWORD, LPWSTR, DWORD, PDWORD, PDWORD, PBYTE, DWORD, PDWORD);
BOOL EnumPrinterDriversA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrinterDriversW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintersA(DWORD, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintersW(DWORD, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintProcessorDatatypesA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintProcessorDatatypesW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintProcessorsA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL EnumPrintProcessorsW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD, PDWORD);
BOOL FindClosePrinterChangeNotification(HANDLE);
HANDLE FindFirstPrinterChangeNotification(HANDLE, DWORD, DWORD, PVOID);
HANDLE FindNextPrinterChangeNotification(HANDLE, PDWORD, PVOID, PVOID*);
BOOL FreePrinterNotifyInfo(PPRINTER_NOTIFY_INFO);

static if (_WIN32_WINNT >= 0x500) {
BOOL GetDefaultPrinterA(LPSTR, LPDWORD);
BOOL GetDefaultPrinterW(LPWSTR, LPDWORD);
}

BOOL GetFormA(HANDLE, LPSTR, DWORD, PBYTE, DWORD, PDWORD);
BOOL GetFormW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD, PDWORD);
BOOL GetJobA(HANDLE, DWORD, DWORD, PBYTE, DWORD, PDWORD);
BOOL GetJobW(HANDLE, DWORD, DWORD, PBYTE, DWORD, PDWORD);
BOOL GetPrinterA(HANDLE, DWORD, PBYTE, DWORD, PDWORD);
BOOL GetPrinterW(HANDLE, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDataA(HANDLE, LPSTR, PDWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDataW(HANDLE, LPWSTR, PDWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDriverA(HANDLE, LPSTR, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDriverW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDriverDirectoryA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrinterDriverDirectoryW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrintProcessorDirectoryA(LPSTR, LPSTR, DWORD, PBYTE, DWORD, PDWORD);
DWORD GetPrintProcessorDirectoryW(LPWSTR, LPWSTR, DWORD, PBYTE, DWORD, PDWORD);
BOOL OpenPrinterA(LPSTR, PHANDLE, LPPRINTER_DEFAULTSA);
BOOL OpenPrinterW(LPWSTR, PHANDLE, LPPRINTER_DEFAULTSW);
DWORD PrinterMessageBoxA(HANDLE, DWORD, HWND, LPSTR, LPSTR, DWORD);
DWORD PrinterMessageBoxW(HANDLE, DWORD, HWND, LPWSTR, LPWSTR, DWORD);
BOOL PrinterProperties(HWND, HANDLE);
BOOL ReadPrinter(HANDLE, PVOID, DWORD, PDWORD);
BOOL ResetPrinterA(HANDLE, LPPRINTER_DEFAULTSA);
BOOL ResetPrinterW(HANDLE, LPPRINTER_DEFAULTSW);
BOOL ScheduleJob(HANDLE, DWORD);
BOOL SetFormA(HANDLE, LPSTR, DWORD, PBYTE);
BOOL SetFormW(HANDLE, LPWSTR, DWORD, PBYTE);
BOOL SetJobA(HANDLE, DWORD, DWORD, PBYTE, DWORD);
BOOL SetJobW(HANDLE, DWORD, DWORD, PBYTE, DWORD);
BOOL SetPrinterA(HANDLE, DWORD, PBYTE, DWORD);
BOOL SetPrinterW(HANDLE, DWORD, PBYTE, DWORD);
BOOL SetPrinterDataA(HANDLE, LPSTR, DWORD, PBYTE, DWORD);
BOOL SetPrinterDataW(HANDLE, LPWSTR, DWORD, PBYTE, DWORD);
DWORD StartDocPrinterA(HANDLE, DWORD, PBYTE);
DWORD StartDocPrinterW(HANDLE, DWORD, PBYTE);
BOOL StartPagePrinter(HANDLE);
DWORD WaitForPrinterChange(HANDLE, DWORD);
BOOL WritePrinter(HANDLE, PVOID, DWORD, PDWORD);

version (Unicode) {

alias JOB_INFO_1W JOB_INFO_1;
alias JOB_INFO_2W JOB_INFO_2;
alias ADDJOB_INFO_1W ADDJOB_INFO_1;
alias DATATYPES_INFO_1W DATATYPES_INFO_1;
alias MONITOR_INFO_1W MONITOR_INFO_1;
alias MONITOR_INFO_2W MONITOR_INFO_2;
alias DOC_INFO_1W DOC_INFO_1;
alias DOC_INFO_2W DOC_INFO_2;
alias PORT_INFO_1W PORT_INFO_1;
alias PORT_INFO_2W PORT_INFO_2;
alias PORT_INFO_3W PORT_INFO_3;
alias DRIVER_INFO_2W DRIVER_INFO_2;
alias PRINTER_INFO_1W PRINTER_INFO_1;
alias PRINTER_INFO_2W PRINTER_INFO_2;
alias PRINTER_INFO_4W PRINTER_INFO_4;
alias PRINTER_INFO_5W PRINTER_INFO_5;
alias PRINTPROCESSOR_INFO_1W PRINTPROCESSOR_INFO_1;
alias FORM_INFO_1W FORM_INFO_1;
alias PRINTER_DEFAULTSW PRINTER_DEFAULTS;

alias AddFormW AddForm;
alias AddJobW AddJob;
alias AddMonitorW AddMonitor;
alias AddPortW AddPort;
alias AddPrinterW AddPrinter;
alias AddPrinterConnectionW AddPrinterConnection;
alias AddPrinterDriverW AddPrinterDriver;
alias AddPrintProcessorW AddPrintProcessor;
alias AddPrintProvidorW AddPrintProvidor;
alias AdvancedDocumentPropertiesW AdvancedDocumentProperties;
alias ConfigurePortW ConfigurePort;
alias DeleteFormW DeleteForm;
alias DeleteMonitorW DeleteMonitor;
alias DeletePortW DeletePort;
alias DeletePrinterConnectionW DeletePrinterConnection;
alias DeletePrinterDataW DeletePrinterData;
alias DeletePrinterDriverW DeletePrinterDriver;
alias DeletePrintProcessorW DeletePrintProcessor;
alias DeletePrintProvidorW DeletePrintProvidor;
alias DocumentPropertiesW DocumentProperties;
alias EnumFormsW EnumForms;
alias EnumJobsW EnumJobs;
alias EnumMonitorsW EnumMonitors;
alias EnumPortsW EnumPorts;
alias EnumPrinterDataW EnumPrinterData;
alias EnumPrinterDriversW EnumPrinterDrivers;
alias EnumPrintersW EnumPrinters;
alias EnumPrintProcessorDatatypesW EnumPrintProcessorDatatypes;
alias EnumPrintProcessorsW EnumPrintProcessors;

static if (_WIN32_WINNT >= 0x500) {
alias GetDefaultPrinterW GetDefaultPrinter;
}

alias GetFormW GetForm;
alias GetJobW GetJob;
alias GetPrinterW GetPrinter;
alias GetPrinterDataW GetPrinterData;
alias GetPrinterDriverW GetPrinterDriver;
alias GetPrinterDriverDirectoryW GetPrinterDriverDirectory;
alias GetPrintProcessorDirectoryW GetPrintProcessorDirectory;
alias OpenPrinterW OpenPrinter;
alias PrinterMessageBoxW PrinterMessageBox;
alias ResetPrinterW ResetPrinter;
alias SetFormW SetForm;
alias SetJobW SetJob;
alias SetPrinterW SetPrinter;
alias SetPrinterDataW SetPrinterData;
alias StartDocPrinterW StartDocPrinter;

} else {

alias JOB_INFO_1A JOB_INFO_1;
alias JOB_INFO_2A JOB_INFO_2;
alias ADDJOB_INFO_1A ADDJOB_INFO_1;
alias DATATYPES_INFO_1A DATATYPES_INFO_1;
alias MONITOR_INFO_1A MONITOR_INFO_1;
alias MONITOR_INFO_2A MONITOR_INFO_2;
alias DOC_INFO_1A DOC_INFO_1;
alias DOC_INFO_2A DOC_INFO_2;
alias PORT_INFO_1A PORT_INFO_1;
alias PORT_INFO_2A PORT_INFO_2;
alias PORT_INFO_3A PORT_INFO_3;
alias DRIVER_INFO_2A DRIVER_INFO_2;
alias PRINTER_INFO_1A PRINTER_INFO_1;
alias PRINTER_INFO_2A PRINTER_INFO_2;
alias PRINTER_INFO_4A PRINTER_INFO_4;
alias PRINTER_INFO_5A PRINTER_INFO_5;
alias PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
alias FORM_INFO_1A FORM_INFO_1;
alias PRINTER_DEFAULTSA PRINTER_DEFAULTS;

alias AddFormA AddForm;
alias AddJobA AddJob;
alias AddMonitorA AddMonitor;
alias AddPortA AddPort;
alias AddPrinterA AddPrinter;
alias AddPrinterConnectionA AddPrinterConnection;
alias AddPrinterDriverA AddPrinterDriver;
alias AddPrintProcessorA AddPrintProcessor;
alias AddPrintProvidorA AddPrintProvidor;
alias AdvancedDocumentPropertiesA AdvancedDocumentProperties;
alias ConfigurePortA ConfigurePort;
alias DeleteFormA DeleteForm;
alias DeleteMonitorA DeleteMonitor;
alias DeletePortA DeletePort;
alias DeletePrinterConnectionA DeletePrinterConnection;
alias DeletePrinterDataA DeletePrinterData;
alias DeletePrinterDriverA DeletePrinterDriver;
alias DeletePrintProcessorA DeletePrintProcessor;
alias DeletePrintProvidorA DeletePrintProvidor;
alias DocumentPropertiesA DocumentProperties;
alias EnumFormsA EnumForms;
alias EnumJobsA EnumJobs;
alias EnumMonitorsA EnumMonitors;
alias EnumPortsA EnumPorts;
alias EnumPrinterDataA EnumPrinterData;
alias EnumPrinterDriversA EnumPrinterDrivers;
alias EnumPrintersA EnumPrinters;
alias EnumPrintProcessorDatatypesA EnumPrintProcessorDatatypes;
alias EnumPrintProcessorsA EnumPrintProcessors;

static if (_WIN32_WINNT >= 0x500) {
alias GetDefaultPrinterA GetDefaultPrinter;
}

alias GetFormA GetForm;
alias GetJobA GetJob;
alias GetPrinterA GetPrinter;
alias GetPrinterDataA GetPrinterData;
alias GetPrinterDriverA GetPrinterDriver;
alias GetPrinterDriverDirectoryA GetPrinterDriverDirectory;
alias GetPrintProcessorDirectoryA GetPrintProcessorDirectory;
alias OpenPrinterA OpenPrinter;
alias PrinterMessageBoxA PrinterMessageBox;
alias ResetPrinterA ResetPrinter;
alias SetFormA SetForm;
alias SetJobA SetJob;
alias SetPrinterA SetPrinter;
alias SetPrinterDataA SetPrinterData;
alias StartDocPrinterA StartDocPrinter;
}

alias JOB_INFO_1* PJOB_INFO_1, LPJOB_INFO_1;
alias JOB_INFO_2* PJOB_INFO_2, LPJOB_INFO_2;
alias ADDJOB_INFO_1* PADDJOB_INFO_1, LPADDJOB_INFO_1;
alias DATATYPES_INFO_1* PDATATYPES_INFO_1, LPDATATYPES_INFO_1;
alias MONITOR_INFO_1* PMONITOR_INFO_1, LPMONITOR_INFO_1;
alias MONITOR_INFO_2* PMONITOR_INFO_2, LPMONITOR_INFO_2;
alias DOC_INFO_1* PDOC_INFO_1, LPDOC_INFO_1;
alias DOC_INFO_2* PDOC_INFO_2, LPDOC_INFO_2;
alias PORT_INFO_1* PPORT_INFO_1, LPPORT_INFO_1;
alias PORT_INFO_2* PPORT_INFO_2, LPPORT_INFO_2;
alias PORT_INFO_3* PPORT_INFO_3, LPPORT_INFO_3;
alias DRIVER_INFO_2* PDRIVER_INFO_2, LPDRIVER_INFO_2;
alias PRINTER_INFO_1* PPRINTER_INFO_1, LPPRINTER_INFO_1;
alias PRINTER_INFO_2* PPRINTER_INFO_2, LPPRINTER_INFO_2;
alias PRINTER_INFO_4* PPRINTER_INFO_4, LPPRINTER_INFO_4;
alias PRINTER_INFO_5* PPRINTER_INFO_5, LPPRINTER_INFO_5;
alias PRINTPROCESSOR_INFO_1* PPRINTPROCESSOR_INFO_1, LPPRINTPROCESSOR_INFO_1;
alias FORM_INFO_1* PFORM_INFO_1, LPFORM_INFO_1;
alias PRINTER_DEFAULTS* PPRINTER_DEFAULTS, LPPRINTER_DEFAULTS;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winsvc.d)
 */
module core.sys.windows.winsvc;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "advapi32");

private import core.sys.windows.w32api, core.sys.windows.windef;

// FIXME: check Windows version support

const TCHAR[]
    SERVICES_ACTIVE_DATABASE = "ServicesActive",
    SERVICES_FAILED_DATABASE = "ServicesFailed";

const TCHAR SC_GROUP_IDENTIFIER = '+';

enum DWORD
    SC_MANAGER_ALL_ACCESS         = 0xf003f,
    SC_MANAGER_CONNECT            =  1,
    SC_MANAGER_CREATE_SERVICE     =  2,
    SC_MANAGER_ENUMERATE_SERVICE  =  4,
    SC_MANAGER_LOCK               =  8,
    SC_MANAGER_QUERY_LOCK_STATUS  = 16,
    SC_MANAGER_MODIFY_BOOT_CONFIG = 32;

enum DWORD SERVICE_NO_CHANGE = 0xffffffff;

enum : DWORD {
    SERVICE_STOPPED = 1,
    SERVICE_START_PENDING,
    SERVICE_STOP_PENDING,
    SERVICE_RUNNING,
    SERVICE_CONTINUE_PENDING,
    SERVICE_PAUSE_PENDING,
    SERVICE_PAUSED // = 7
}

enum DWORD
    SERVICE_ACCEPT_STOP                  =   1,
    SERVICE_ACCEPT_PAUSE_CONTINUE        =   2,
    SERVICE_ACCEPT_SHUTDOWN              =   4,
    SERVICE_ACCEPT_PARAMCHANGE           =   8,
    SERVICE_ACCEPT_NETBINDCHANGE         =  16,
    SERVICE_ACCEPT_HARDWAREPROFILECHANGE =  32,
    SERVICE_ACCEPT_POWEREVENT            =  64,
    SERVICE_ACCEPT_SESSIONCHANGE         = 128;

enum : DWORD {
    SERVICE_CONTROL_STOP = 1,
    SERVICE_CONTROL_PAUSE,
    SERVICE_CONTROL_CONTINUE,
    SERVICE_CONTROL_INTERROGATE,
    SERVICE_CONTROL_SHUTDOWN,
    SERVICE_CONTROL_PARAMCHANGE,
    SERVICE_CONTROL_NETBINDADD,
    SERVICE_CONTROL_NETBINDREMOVE,
    SERVICE_CONTROL_NETBINDENABLE,
    SERVICE_CONTROL_NETBINDDISABLE,
    SERVICE_CONTROL_DEVICEEVENT,
    SERVICE_CONTROL_HARDWAREPROFILECHANGE,
    SERVICE_CONTROL_POWEREVENT,
    SERVICE_CONTROL_SESSIONCHANGE, // = 14
}

enum : DWORD {
    SERVICE_ACTIVE = 1,
    SERVICE_INACTIVE,
    SERVICE_STATE_ALL
}

enum DWORD
    SERVICE_QUERY_CONFIG         = 0x0001,
    SERVICE_CHANGE_CONFIG        = 0x0002,
    SERVICE_QUERY_STATUS         = 0x0004,
    SERVICE_ENUMERATE_DEPENDENTS = 0x0008,
    SERVICE_START                = 0x0010,
    SERVICE_STOP                 = 0x0020,
    SERVICE_PAUSE_CONTINUE       = 0x0040,
    SERVICE_INTERROGATE          = 0x0080,
    SERVICE_USER_DEFINED_CONTROL = 0x0100,
    SERVICE_ALL_ACCESS           = 0x01FF | STANDARD_RIGHTS_REQUIRED;

// This is not documented on the MSDN site
enum SERVICE_RUNS_IN_SYSTEM_PROCESS = 1;

enum : DWORD {
    SERVICE_CONFIG_DESCRIPTION         = 1,
    SERVICE_CONFIG_FAILURE_ACTIONS,
    SERVICE_CONFIG_DELAYED_AUTO_START_INFO,
    SERVICE_CONFIG_FAILURE_ACTIONS_FLAG,
    SERVICE_CONFIG_SERVICE_SID_INFO,
    SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO,
    SERVICE_CONFIG_PRESHUTDOWN_INFO // = 7
}

struct SERVICE_STATUS {
    DWORD dwServiceType;
    DWORD dwCurrentState;
    DWORD dwControlsAccepted;
    DWORD dwWin32ExitCode;
    DWORD dwServiceSpecificExitCode;
    DWORD dwCheckPoint;
    DWORD dwWaitHint;
}
alias SERVICE_STATUS* LPSERVICE_STATUS;

struct ENUM_SERVICE_STATUSA {
    LPSTR          lpServiceName;
    LPSTR          lpDisplayName;
    SERVICE_STATUS ServiceStatus;
}
alias ENUM_SERVICE_STATUSA* LPENUM_SERVICE_STATUSA;

struct ENUM_SERVICE_STATUSW {
    LPWSTR         lpServiceName;
    LPWSTR         lpDisplayName;
    SERVICE_STATUS ServiceStatus;
}
alias ENUM_SERVICE_STATUSW* LPENUM_SERVICE_STATUSW;

struct QUERY_SERVICE_CONFIGA {
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPSTR lpBinaryPathName;
    LPSTR lpLoadOrderGroup;
    DWORD dwTagId;
    LPSTR lpDependencies;
    LPSTR lpServiceStartName;
    LPSTR lpDisplayName;
}
alias QUERY_SERVICE_CONFIGA* LPQUERY_SERVICE_CONFIGA;

struct QUERY_SERVICE_CONFIGW {
    DWORD  dwServiceType;
    DWORD  dwStartType;
    DWORD  dwErrorControl;
    LPWSTR lpBinaryPathName;
    LPWSTR lpLoadOrderGroup;
    DWORD  dwTagId;
    LPWSTR lpDependencies;
    LPWSTR lpServiceStartName;
    LPWSTR lpDisplayName;
}
alias QUERY_SERVICE_CONFIGW* LPQUERY_SERVICE_CONFIGW;

struct QUERY_SERVICE_LOCK_STATUSA {
    DWORD fIsLocked;
    LPSTR lpLockOwner;
    DWORD dwLockDuration;
}
alias QUERY_SERVICE_LOCK_STATUSA* LPQUERY_SERVICE_LOCK_STATUSA;

struct QUERY_SERVICE_LOCK_STATUSW {
    DWORD  fIsLocked;
    LPWSTR lpLockOwner;
    DWORD  dwLockDuration;
}
alias QUERY_SERVICE_LOCK_STATUSW* LPQUERY_SERVICE_LOCK_STATUSW;

extern (Windows) {
    alias void function(DWORD, LPSTR*)  LPSERVICE_MAIN_FUNCTIONA;
    alias void function(DWORD, LPWSTR*) LPSERVICE_MAIN_FUNCTIONW;
}

struct SERVICE_TABLE_ENTRYA {
    LPSTR                    lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
}
alias SERVICE_TABLE_ENTRYA* LPSERVICE_TABLE_ENTRYA;

struct SERVICE_TABLE_ENTRYW {
    LPWSTR                   lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
}
alias SERVICE_TABLE_ENTRYW* LPSERVICE_TABLE_ENTRYW;

mixin DECLARE_HANDLE!("SC_HANDLE");
alias SC_HANDLE* LPSC_HANDLE;
alias void* SC_LOCK;
mixin DECLARE_HANDLE!("SERVICE_STATUS_HANDLE");

extern (Windows) {
    alias void function(DWORD) LPHANDLER_FUNCTION;
    alias DWORD function(DWORD, DWORD, LPVOID, LPVOID) LPHANDLER_FUNCTION_EX;
}

static if (_WIN32_WINNT >= 0x500) {
    struct SERVICE_STATUS_PROCESS {
        DWORD dwServiceType;
        DWORD dwCurrentState;
        DWORD dwControlsAccepted;
        DWORD dwWin32ExitCode;
        DWORD dwServiceSpecificExitCode;
        DWORD dwCheckPoint;
        DWORD dwWaitHint;
        DWORD dwProcessId;
        DWORD dwServiceFlags;
    }
    alias SERVICE_STATUS_PROCESS* LPSERVICE_STATUS_PROCESS;

    enum SC_STATUS_TYPE {
        SC_STATUS_PROCESS_INFO = 0
    }

    enum SC_ENUM_TYPE {
        SC_ENUM_PROCESS_INFO = 0
    }

    struct ENUM_SERVICE_STATUS_PROCESSA {
        LPSTR                  lpServiceName;
        LPSTR                  lpDisplayName;
        SERVICE_STATUS_PROCESS ServiceStatusProcess;
    }
    alias ENUM_SERVICE_STATUS_PROCESSA* LPENUM_SERVICE_STATUS_PROCESSA;

    struct ENUM_SERVICE_STATUS_PROCESSW {
        LPWSTR                 lpServiceName;
        LPWSTR                 lpDisplayName;
        SERVICE_STATUS_PROCESS ServiceStatusProcess;
    }
    alias ENUM_SERVICE_STATUS_PROCESSW* LPENUM_SERVICE_STATUS_PROCESSW;

    struct SERVICE_DESCRIPTIONA {
        LPSTR lpDescription;
    }
    alias SERVICE_DESCRIPTIONA* LPSERVICE_DESCRIPTIONA;

    struct SERVICE_DESCRIPTIONW {
        LPWSTR lpDescription;
    }
    alias SERVICE_DESCRIPTIONW* LPSERVICE_DESCRIPTIONW;

    enum SC_ACTION_TYPE {
        SC_ACTION_NONE,
        SC_ACTION_RESTART,
        SC_ACTION_REBOOT,
        SC_ACTION_RUN_COMMAND
    }

    struct SC_ACTION {
        SC_ACTION_TYPE Type;
        DWORD          Delay;
    }
    alias SC_ACTION* LPSC_ACTION;

    struct SERVICE_FAILURE_ACTIONSA {
        DWORD      dwResetPeriod;
        LPSTR      lpRebootMsg;
        LPSTR      lpCommand;
        DWORD      cActions;
        SC_ACTION* lpsaActions;
    }
    alias SERVICE_FAILURE_ACTIONSA* LPSERVICE_FAILURE_ACTIONSA;

    struct SERVICE_FAILURE_ACTIONSW {
        DWORD      dwResetPeriod;
        LPWSTR     lpRebootMsg;
        LPWSTR     lpCommand;
        DWORD      cActions;
        SC_ACTION* lpsaActions;
    }
    alias SERVICE_FAILURE_ACTIONSW* LPSERVICE_FAILURE_ACTIONSW;
}

extern (Windows) {
    BOOL ChangeServiceConfigA(SC_HANDLE, DWORD, DWORD, DWORD, LPCSTR,
      LPCSTR, LPDWORD, LPCSTR, LPCSTR, LPCSTR, LPCSTR);
    BOOL ChangeServiceConfigW(SC_HANDLE, DWORD, DWORD, DWORD, LPCWSTR,
      LPCWSTR, LPDWORD, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR);
    BOOL CloseServiceHandle(SC_HANDLE);
    BOOL ControlService(SC_HANDLE, DWORD, LPSERVICE_STATUS);
    SC_HANDLE CreateServiceA(SC_HANDLE, LPCSTR, LPCSTR, DWORD, DWORD,
      DWORD, DWORD, LPCSTR, LPCSTR, PDWORD, LPCSTR, LPCSTR, LPCSTR);
    SC_HANDLE CreateServiceW(SC_HANDLE, LPCWSTR, LPCWSTR, DWORD, DWORD,
      DWORD, DWORD, LPCWSTR, LPCWSTR, PDWORD, LPCWSTR, LPCWSTR, LPCWSTR);
    BOOL DeleteService(SC_HANDLE);
    BOOL EnumDependentServicesA(SC_HANDLE, DWORD, LPENUM_SERVICE_STATUSA,
      DWORD, PDWORD, PDWORD);
    BOOL EnumDependentServicesW(SC_HANDLE, DWORD, LPENUM_SERVICE_STATUSW,
      DWORD, PDWORD, PDWORD);
    BOOL EnumServicesStatusA(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSA,
      DWORD, PDWORD, PDWORD, PDWORD);
    BOOL EnumServicesStatusW(SC_HANDLE, DWORD, DWORD, LPENUM_SERVICE_STATUSW,
      DWORD, PDWORD, PDWORD, PDWORD);
    BOOL GetServiceDisplayNameA(SC_HANDLE, LPCSTR, LPSTR, PDWORD);
    BOOL GetServiceDisplayNameW(SC_HANDLE, LPCWSTR, LPWSTR, PDWORD);
    BOOL GetServiceKeyNameA(SC_HANDLE, LPCSTR, LPSTR, PDWORD);
    BOOL GetServiceKeyNameW(SC_HANDLE, LPCWSTR, LPWSTR, PDWORD);
    SC_LOCK LockServiceDatabase(SC_HANDLE);
    BOOL NotifyBootConfigStatus(BOOL);
    SC_HANDLE OpenSCManagerA(LPCSTR, LPCSTR, DWORD);
    SC_HANDLE OpenSCManagerW(LPCWSTR, LPCWSTR, DWORD);
    SC_HANDLE OpenServiceA(SC_HANDLE, LPCSTR, DWORD);
    SC_HANDLE OpenServiceW(SC_HANDLE, LPCWSTR, DWORD);
    BOOL QueryServiceConfigA(SC_HANDLE, LPQUERY_SERVICE_CONFIGA, DWORD,
      PDWORD);
    BOOL QueryServiceConfigW(SC_HANDLE, LPQUERY_SERVICE_CONFIGW, DWORD,
      PDWORD);
    BOOL QueryServiceLockStatusA(SC_HANDLE, LPQUERY_SERVICE_LOCK_STATUSA,
      DWORD, PDWORD);
    BOOL QueryServiceLockStatusW(SC_HANDLE, LPQUERY_SERVICE_LOCK_STATUSW,
      DWORD, PDWORD);
    BOOL QueryServiceObjectSecurity(SC_HANDLE, SECURITY_INFORMATION,
      PSECURITY_DESCRIPTOR, DWORD, LPDWORD);
    BOOL QueryServiceStatus(SC_HANDLE, LPSERVICE_STATUS);
    SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerA(LPCSTR,
      LPHANDLER_FUNCTION);
    SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerW(LPCWSTR,
      LPHANDLER_FUNCTION);
    BOOL SetServiceObjectSecurity(SC_HANDLE, SECURITY_INFORMATION,
      PSECURITY_DESCRIPTOR);
    BOOL SetServiceStatus(SERVICE_STATUS_HANDLE, LPSERVICE_STATUS);
    BOOL StartServiceA(SC_HANDLE, DWORD, LPCSTR*);
    BOOL StartServiceW(SC_HANDLE, DWORD, LPCWSTR*);
    BOOL StartServiceCtrlDispatcherA(LPSERVICE_TABLE_ENTRYA);
    BOOL StartServiceCtrlDispatcherW(LPSERVICE_TABLE_ENTRYW);
    BOOL UnlockServiceDatabase(SC_LOCK);

    static if (_WIN32_WINNT >= 0x500) {
        BOOL EnumServicesStatusExA(SC_HANDLE, SC_ENUM_TYPE, DWORD, DWORD, LPBYTE,
          DWORD, LPDWORD, LPDWORD, LPDWORD, LPCSTR);
        BOOL EnumServicesStatusExW(SC_HANDLE, SC_ENUM_TYPE, DWORD, DWORD, LPBYTE,
          DWORD, LPDWORD, LPDWORD, LPDWORD, LPCWSTR);
        BOOL QueryServiceConfig2A(SC_HANDLE, DWORD, LPBYTE, DWORD, LPDWORD);
        BOOL QueryServiceConfig2W(SC_HANDLE, DWORD, LPBYTE, DWORD, LPDWORD);
        BOOL QueryServiceStatusEx(SC_HANDLE, SC_STATUS_TYPE, LPBYTE, DWORD,
          LPDWORD);
        SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExA(LPCSTR,
          LPHANDLER_FUNCTION_EX, LPVOID);
        SERVICE_STATUS_HANDLE RegisterServiceCtrlHandlerExW(LPCWSTR,
          LPHANDLER_FUNCTION_EX, LPVOID);
    }

    static if (_WIN32_WINNT >= 0x501) {
        BOOL ChangeServiceConfig2A(SC_HANDLE, DWORD, LPVOID);
        BOOL ChangeServiceConfig2W(SC_HANDLE, DWORD, LPVOID);
    }
}

version (Unicode) {
    alias ENUM_SERVICE_STATUSW ENUM_SERVICE_STATUS;
    alias QUERY_SERVICE_CONFIGW QUERY_SERVICE_CONFIG;
    alias QUERY_SERVICE_LOCK_STATUSW QUERY_SERVICE_LOCK_STATUS;
    alias LPSERVICE_MAIN_FUNCTIONW LPSERVICE_MAIN_FUNCTION;
    alias SERVICE_TABLE_ENTRYW SERVICE_TABLE_ENTRY;
    alias ChangeServiceConfigW ChangeServiceConfig;
    alias CreateServiceW CreateService;
    alias EnumDependentServicesW EnumDependentServices;
    alias EnumServicesStatusW EnumServicesStatus;
    alias GetServiceDisplayNameW GetServiceDisplayName;
    alias GetServiceKeyNameW GetServiceKeyName;
    alias OpenSCManagerW OpenSCManager;
    alias OpenServiceW OpenService;
    alias QueryServiceConfigW QueryServiceConfig;
    alias QueryServiceLockStatusW QueryServiceLockStatus;
    alias RegisterServiceCtrlHandlerW RegisterServiceCtrlHandler;
    alias StartServiceW StartService;
    alias StartServiceCtrlDispatcherW StartServiceCtrlDispatcher;

    static if (_WIN32_WINNT >= 0x500) {
        alias ENUM_SERVICE_STATUS_PROCESSW ENUM_SERVICE_STATUS_PROCESS;
        alias SERVICE_DESCRIPTIONW SERVICE_DESCRIPTION;
        alias SERVICE_FAILURE_ACTIONSW SERVICE_FAILURE_ACTIONS;
        alias EnumServicesStatusExW EnumServicesStatusEx;
        alias QueryServiceConfig2W QueryServiceConfig2;
        alias RegisterServiceCtrlHandlerExW RegisterServiceCtrlHandlerEx;
    }

    static if (_WIN32_WINNT >= 0x501) {
        alias ChangeServiceConfig2W ChangeServiceConfig2;
    }

} else {
    alias ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
    alias QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
    alias QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
    alias LPSERVICE_MAIN_FUNCTIONA LPSERVICE_MAIN_FUNCTION;
    alias SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
    alias ChangeServiceConfigA ChangeServiceConfig;
    alias CreateServiceA CreateService;
    alias EnumDependentServicesA EnumDependentServices;
    alias EnumServicesStatusA EnumServicesStatus;
    alias GetServiceDisplayNameA GetServiceDisplayName;
    alias GetServiceKeyNameA GetServiceKeyName;
    alias OpenSCManagerA OpenSCManager;
    alias OpenServiceA OpenService;
    alias QueryServiceConfigA QueryServiceConfig;
    alias QueryServiceLockStatusA QueryServiceLockStatus;
    alias RegisterServiceCtrlHandlerA RegisterServiceCtrlHandler;
    alias StartServiceA StartService;
    alias StartServiceCtrlDispatcherA StartServiceCtrlDispatcher;

    static if (_WIN32_WINNT >= 0x500) {
        alias ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
        alias SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
        alias SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
        alias EnumServicesStatusExA EnumServicesStatusEx;
        alias QueryServiceConfig2A QueryServiceConfig2;
        alias RegisterServiceCtrlHandlerExA RegisterServiceCtrlHandlerEx;
    }

    static if (_WIN32_WINNT >= 0x501) {
        alias ChangeServiceConfig2A ChangeServiceConfig2;
    }

}

alias ENUM_SERVICE_STATUS* LPENUM_SERVICE_STATUS;
alias QUERY_SERVICE_CONFIG* LPQUERY_SERVICE_CONFIG;
alias QUERY_SERVICE_LOCK_STATUS* LPQUERY_SERVICE_LOCK_STATUS;
alias SERVICE_TABLE_ENTRY* LPSERVICE_TABLE_ENTRY;

static if (_WIN32_WINNT >= 0x500) {
    alias ENUM_SERVICE_STATUS_PROCESS* LPENUM_SERVICE_STATUS_PROCESS;
    alias SERVICE_DESCRIPTION* LPSERVICE_DESCRIPTION;
    alias SERVICE_FAILURE_ACTIONS* LPSERVICE_FAILURE_ACTIONS;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_winuser.d)
 */
module core.sys.windows.winuser;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "user32");

// Conversion Notes:
// The following macros were for win16 only, and are not included in this file:
//#define EnumTaskWindows(h, f, p) EnumThreadWindows((DWORD)h, f, p)
//#define PostAppMessageA(t, m, w, l) PostThreadMessageA((DWORD)t, m, w, l)
//#define PostAppMessageW(t, m, w, l) PostThreadMessageW((DWORD)t, m, w, l)
//#define GetSysModalWindow() (NULL)
//#define SetSysModalWindow(h) (NULL)
//#define GetWindowTask(hWnd) ((HANDLE)GetWindowThreadProcessId(hWnd, NULL))
//#define DefHookProc(c, p, lp, h) CallNextHookEx((HHOOK)*h, c, p, lp)

private import core.sys.windows.w32api, core.sys.windows.winbase, core.sys.windows.wingdi;
private import core.sys.windows.windef; // for HMONITOR

// FIXME: clean up Windows version support

LPTSTR MAKEINTATOM_T()(int i) {
    return cast(LPTSTR) i;
}

enum LPTSTR WC_DIALOG = MAKEINTATOM_T(0x8002);

enum {
    FAPPCOMMAND_MOUSE = 0x8000,
    FAPPCOMMAND_KEY   = 0,
    FAPPCOMMAND_OEM   = 0x1000,
    FAPPCOMMAND_MASK  = 0xF000
}

enum {
    MNGO_NOINTERFACE = 0,
    MNGO_NOERROR,
    MNGOF_TOPGAP     = 1,
    MNGOF_BOTTOMGAP
}

enum {
    FVIRTKEY  = 1,
    FNOINVERT = 2,
    FSHIFT    = 4,
    FCONTROL  = 8,
    FALT      = 16
}

enum {
    ATF_TIMEOUTON     = 1,
    ATF_ONOFFFEEDBACK = 2,
    ATF_AVAILABLE     = 4 // May be obsolete. Not in recent MS docs.
}

enum {
    WH_MIN             = -1,
    WH_MSGFILTER       = -1,
    WH_JOURNALRECORD,
    WH_JOURNALPLAYBACK,
    WH_KEYBOARD,
    WH_GETMESSAGE,
    WH_CALLWNDPROC,
    WH_CBT,
    WH_SYSMSGFILTER,
    WH_MOUSE,
    WH_HARDWARE,
    WH_DEBUG,
    WH_SHELL,
    WH_FOREGROUNDIDLE,
    WH_CALLWNDPROCRET,
    WH_KEYBOARD_LL,
    WH_MOUSE_LL,    // = 14
    WH_MAX             = 14,
    WH_MINHOOK         = WH_MIN,
    WH_MAXHOOK         = WH_MAX
}

enum {
    HC_ACTION       = 0,
    HC_GETNEXT,
    HC_SKIP,
    HC_NOREMOVE, // = 3
    HC_NOREM        = HC_NOREMOVE,
    HC_SYSMODALON,
    HC_SYSMODALOFF
}

enum {
    HCBT_MOVESIZE    = 0,
    HCBT_MINMAX,
    HCBT_QS,
    HCBT_CREATEWND,
    HCBT_DESTROYWND,
    HCBT_ACTIVATE,
    HCBT_CLICKSKIPPED,
    HCBT_KEYSKIPPED,
    HCBT_SYSCOMMAND,
    HCBT_SETFOCUS // = 9
}

enum {
    CF_TEXT                = 0x0001,
    CF_BITMAP,
    CF_METAFILEPICT,
    CF_SYLK,
    CF_DIF,
    CF_TIFF,
    CF_OEMTEXT,
    CF_DIB,
    CF_PALETTE,
    CF_PENDATA,
    CF_RIFF,
    CF_WAVE,
    CF_UNICODETEXT,
    CF_ENHMETAFILE,
    CF_HDROP,
    CF_LOCALE,
    CF_DIBV5,
    CF_MAX,             // = 0x0012
    CF_OWNERDISPLAY        = 0x0080,
    CF_DSPTEXT,
    CF_DSPBITMAP,
    CF_DSPMETAFILEPICT, // = 0x0083
    CF_DSPENHMETAFILE      = 0x008E,
    CF_PRIVATEFIRST        = 0x0200,
    CF_PRIVATELAST         = 0x02FF,
    CF_GDIOBJFIRST         = 0x0300,
    CF_GDIOBJLAST          = 0x03FF
}

enum HKL_PREV = 0;
enum HKL_NEXT = 1;

enum KLF_ACTIVATE       = 1;
enum KLF_SUBSTITUTE_OK  = 2;
enum KLF_UNLOADPREVIOUS = 4;
enum KLF_REORDER        = 8;
enum KLF_REPLACELANG    = 16;
enum KLF_NOTELLSHELL    = 128;
enum KLF_SETFORPROCESS  = 256;
enum KL_NAMELENGTH      = 9;

enum MF_ENABLED = 0;
enum MF_GRAYED = 1;
enum MF_DISABLED = 2;
enum MF_BITMAP = 4;
enum MF_CHECKED = 8;
enum MF_MENUBARBREAK = 32;
enum MF_MENUBREAK = 64;
enum MF_OWNERDRAW = 256;
enum MF_POPUP = 16;
enum MF_SEPARATOR = 0x800;
enum MF_STRING = 0;
enum MF_UNCHECKED = 0;
enum MF_DEFAULT = 4096;
enum MF_SYSMENU = 0x2000;
enum MF_HELP = 0x4000;
enum MF_END = 128;
enum MF_RIGHTJUSTIFY = 0x4000;
enum MF_MOUSESELECT = 0x8000;
enum MF_INSERT = 0;
enum MF_CHANGE = 128;
enum MF_APPEND = 256;
enum MF_DELETE = 512;
enum MF_REMOVE = 4096;
enum MF_USECHECKBITMAPS = 512;
enum MF_UNHILITE = 0;
enum MF_HILITE = 128;

// Also defined in dbt.h
enum BSM_ALLCOMPONENTS      = 0;
enum BSM_VXDS               = 1;
enum BSM_NETDRIVER          = 2;
enum BSM_INSTALLABLEDRIVERS = 4;
enum BSM_APPLICATIONS       = 8;
enum BSM_ALLDESKTOPS        = 16;

enum {
    BSF_QUERY              = 0x0001,
    BSF_IGNORECURRENTTASK  = 0x0002,
    BSF_FLUSHDISK          = 0x0004,
    BSF_NOHANG             = 0x0008,
    BSF_POSTMESSAGE        = 0x0010,
    BSF_FORCEIFHUNG        = 0x0020,
    BSF_NOTIMEOUTIFNOTHUNG = 0x0040,
    BSF_ALLOWSFW           = 0x0080,
    BSF_SENDNOTIFYMESSAGE  = 0x0100
}
static if (_WIN32_WINNT >= 0x501) {
    enum {
        BSF_RETURNHDESK    = 0x0200,
        BSF_LUID           = 0x0400
    }
}

enum BROADCAST_QUERY_DENY = 1112363332;
enum DWORD ENUM_CURRENT_SETTINGS  = -1;
enum DWORD ENUM_REGISTRY_SETTINGS = -2;

enum CDS_UPDATEREGISTRY = 1;
enum CDS_TEST           = 2;
enum CDS_FULLSCREEN     = 4;
enum CDS_GLOBAL         = 8;
enum CDS_SET_PRIMARY    = 16;
enum CDS_NORESET        = 0x10000000;
enum CDS_SETRECT        = 0x20000000;
enum CDS_RESET          = 0x40000000;

enum {
    DISP_CHANGE_BADPARAM   = -5,
    DISP_CHANGE_BADFLAGS,
    DISP_CHANGE_NOTUPDATED,
    DISP_CHANGE_BADMODE,
    DISP_CHANGE_FAILED,
    DISP_CHANGE_SUCCESSFUL,
    DISP_CHANGE_RESTART // =  1
}

enum BST_UNCHECKED     = 0;
enum BST_CHECKED       = 1;
enum BST_INDETERMINATE = 2;
enum BST_PUSHED        = 4;
enum BST_FOCUS         = 8;

enum MF_BYCOMMAND  = 0;
enum MF_BYPOSITION = 1024;
// [Redefined] MF_UNCHECKED = 0
// [Redefined] MF_HILITE = 128
// [Redefined] MF_UNHILITE = 0

enum CWP_ALL             = 0;
enum CWP_SKIPINVISIBLE   = 1;
enum CWP_SKIPDISABLED    = 2;
enum CWP_SKIPTRANSPARENT = 4;

enum IMAGE_BITMAP = 0;
enum IMAGE_ICON = 1;
enum IMAGE_CURSOR = 2;
enum IMAGE_ENHMETAFILE = 3;

enum DF_ALLOWOTHERACCOUNTHOOK = 1;

enum DESKTOP_READOBJECTS     = 1;
enum DESKTOP_CREATEWINDOW    = 2;
enum DESKTOP_CREATEMENU      = 4;
enum DESKTOP_HOOKCONTROL     = 8;
enum DESKTOP_JOURNALRECORD   = 16;
enum DESKTOP_JOURNALPLAYBACK = 32;
enum DESKTOP_ENUMERATE       = 64;
enum DESKTOP_WRITEOBJECTS    = 128;
enum DESKTOP_SWITCHDESKTOP   = 256;

enum int CW_USEDEFAULT = 0x80000000;

enum {
    WS_OVERLAPPED       = 0,
    WS_TILED            = WS_OVERLAPPED,
    WS_MAXIMIZEBOX      = 0x00010000,
    WS_MINIMIZEBOX      = 0x00020000,
    WS_TABSTOP          = 0x00010000,
    WS_GROUP            = 0x00020000,
    WS_THICKFRAME       = 0x00040000,
    WS_SIZEBOX          = WS_THICKFRAME,
    WS_SYSMENU          = 0x00080000,
    WS_HSCROLL          = 0x00100000,
    WS_VSCROLL          = 0x00200000,
    WS_DLGFRAME         = 0x00400000,
    WS_BORDER           = 0x00800000,
    WS_CAPTION          = 0x00c00000,
    WS_OVERLAPPEDWINDOW = WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX,
    WS_TILEDWINDOW      = WS_OVERLAPPEDWINDOW,
    WS_MAXIMIZE         = 0x01000000,
    WS_CLIPCHILDREN     = 0x02000000,
    WS_CLIPSIBLINGS     = 0x04000000,
    WS_DISABLED         = 0x08000000,
    WS_VISIBLE          = 0x10000000,
    WS_MINIMIZE         = 0x20000000,
    WS_ICONIC           = WS_MINIMIZE,
    WS_CHILD            = 0x40000000,
    WS_CHILDWINDOW      = 0x40000000,
    WS_POPUP            = 0x80000000,
    WS_POPUPWINDOW      = WS_POPUP|WS_BORDER|WS_SYSMENU,
}

enum MDIS_ALLCHILDSTYLES = 1;

enum BS_3STATE = 5;
enum BS_AUTO3STATE = 6;
enum BS_AUTOCHECKBOX = 3;
enum BS_AUTORADIOBUTTON = 9;
enum BS_BITMAP = 128;
enum BS_BOTTOM = 0x800;
enum BS_CENTER = 0x300;
enum BS_CHECKBOX = 2;
enum BS_DEFPUSHBUTTON = 1;
enum BS_GROUPBOX = 7;
enum BS_ICON = 64;
enum BS_LEFT = 256;
enum BS_LEFTTEXT = 32;
enum BS_MULTILINE = 0x2000;
enum BS_NOTIFY = 0x4000;
enum BS_OWNERDRAW = 0xb;
enum BS_PUSHBUTTON = 0;
enum BS_PUSHLIKE = 4096;
enum BS_RADIOBUTTON = 4;
enum BS_RIGHT = 512;
enum BS_RIGHTBUTTON = 32;
enum BS_TEXT = 0;
enum BS_TOP = 0x400;
enum BS_USERBUTTON = 8;
enum BS_VCENTER = 0xc00;
enum BS_FLAT = 0x8000;

enum CBS_AUTOHSCROLL = 64;
enum CBS_DISABLENOSCROLL = 0x800;
enum CBS_DROPDOWN = 2;
enum CBS_DROPDOWNLIST = 3;
enum CBS_HASSTRINGS = 512;
enum CBS_LOWERCASE = 0x4000;
enum CBS_NOINTEGRALHEIGHT = 0x400;
enum CBS_OEMCONVERT = 128;
enum CBS_OWNERDRAWFIXED = 16;
enum CBS_OWNERDRAWVARIABLE = 32;
enum CBS_SIMPLE = 1;
enum CBS_SORT = 256;
enum CBS_UPPERCASE = 0x2000;

enum ES_AUTOHSCROLL = 128;
enum ES_AUTOVSCROLL = 64;
enum ES_CENTER = 1;
enum ES_LEFT = 0;
enum ES_LOWERCASE = 16;
enum ES_MULTILINE = 4;
enum ES_NOHIDESEL = 256;
enum ES_NUMBER = 0x2000;
enum ES_OEMCONVERT = 0x400;
enum ES_PASSWORD = 32;
enum ES_READONLY = 0x800;
enum ES_RIGHT = 2;
enum ES_UPPERCASE = 8;
enum ES_WANTRETURN = 4096;

enum LBS_DISABLENOSCROLL = 4096;
enum LBS_EXTENDEDSEL = 0x800;
enum LBS_HASSTRINGS = 64;
enum LBS_MULTICOLUMN = 512;
enum LBS_MULTIPLESEL = 8;
enum LBS_NODATA = 0x2000;
enum LBS_NOINTEGRALHEIGHT = 256;
enum LBS_NOREDRAW = 4;
enum LBS_NOSEL = 0x4000;
enum LBS_NOTIFY = 1;
enum LBS_OWNERDRAWFIXED = 16;
enum LBS_OWNERDRAWVARIABLE = 32;
enum LBS_SORT = 2;
enum LBS_STANDARD = 0xa00003;
enum LBS_USETABSTOPS = 128;
enum LBS_WANTKEYBOARDINPUT = 0x400;

enum SBS_BOTTOMALIGN = 4;
enum SBS_HORZ = 0;
enum SBS_LEFTALIGN = 2;
enum SBS_RIGHTALIGN = 4;
enum SBS_SIZEBOX = 8;
enum SBS_SIZEBOXBOTTOMRIGHTALIGN = 4;
enum SBS_SIZEBOXTOPLEFTALIGN = 2;
enum SBS_SIZEGRIP = 16;
enum SBS_TOPALIGN = 2;
enum SBS_VERT = 1;

enum SS_BITMAP = 14;
enum SS_BLACKFRAME = 7;
enum SS_BLACKRECT = 4;
enum SS_CENTER = 1;
enum SS_CENTERIMAGE = 512;
enum SS_ENHMETAFILE = 15;
enum SS_ETCHEDFRAME = 18;
enum SS_ETCHEDHORZ = 16;
enum SS_ETCHEDVERT = 17;
enum SS_GRAYFRAME = 8;
enum SS_GRAYRECT = 5;
enum SS_ICON = 3;
enum SS_LEFT = 0;
enum SS_LEFTNOWORDWRAP = 0xc;
enum SS_NOPREFIX = 128;
enum SS_NOTIFY = 256;
enum SS_OWNERDRAW = 0xd;
enum SS_REALSIZEIMAGE = 0x800;
enum SS_RIGHT = 2;
enum SS_RIGHTJUST = 0x400;
enum SS_SIMPLE = 11;
enum SS_SUNKEN = 4096;
enum SS_WHITEFRAME = 9;
enum SS_WHITERECT = 6;
enum SS_USERITEM = 10;
enum SS_TYPEMASK = 0x0000001FL;
enum SS_ENDELLIPSIS = 0x00004000L;
enum SS_PATHELLIPSIS = 0x00008000L;
enum SS_WORDELLIPSIS = 0x0000C000L;
enum SS_ELLIPSISMASK = 0x0000C000L;

enum DS_ABSALIGN      = 0x0001;
enum DS_3DLOOK        = 0x0004;
enum DS_SYSMODAL      = 0x0002;
enum DS_FIXEDSYS      = 0x0008;
enum DS_NOFAILCREATE  = 0x0010;
enum DS_LOCALEDIT     = 0x0020;
enum DS_SETFONT       = 0x0040;
enum DS_MODALFRAME    = 0x0080;
enum DS_NOIDLEMSG     = 0x0100;
enum DS_SETFOREGROUND = 0x0200;
enum DS_CONTROL       = 0x0400;
enum DS_CENTER        = 0x0800;
enum DS_CENTERMOUSE   = 0x1000;
enum DS_CONTEXTHELP   = 0x2000;
enum DS_SHELLFONT     = DS_SETFONT | DS_FIXEDSYS;

enum WS_EX_ACCEPTFILES = 16;
enum WS_EX_APPWINDOW = 0x40000;
enum WS_EX_CLIENTEDGE = 512;
enum WS_EX_COMPOSITED = 0x2000000;  // XP
enum WS_EX_CONTEXTHELP = 0x400;
enum WS_EX_CONTROLPARENT = 0x10000;
enum WS_EX_DLGMODALFRAME = 1;
enum WS_EX_LAYERED = 0x80000;  // w2k
enum WS_EX_LAYOUTRTL = 0x400000;  // w98, w2k
enum WS_EX_LEFT = 0;
enum WS_EX_LEFTSCROLLBAR = 0x4000;
enum WS_EX_LTRREADING = 0;
enum WS_EX_MDICHILD = 64;
enum WS_EX_NOACTIVATE = 0x8000000;  // w2k
enum WS_EX_NOINHERITLAYOUT = 0x100000;  // w2k
enum WS_EX_NOPARENTNOTIFY = 4;
enum WS_EX_NOREDIRECTIONBITMAP = 0x00200000; // w8, s2012
enum WS_EX_OVERLAPPEDWINDOW = 0x300;
enum WS_EX_PALETTEWINDOW = 0x188;
enum WS_EX_RIGHT = 0x1000;
enum WS_EX_RIGHTSCROLLBAR = 0;
enum WS_EX_RTLREADING = 0x2000;
enum WS_EX_STATICEDGE = 0x20000;
enum WS_EX_TOOLWINDOW = 128;
enum WS_EX_TOPMOST = 8;
enum WS_EX_TRANSPARENT = 32;
enum WS_EX_WINDOWEDGE = 256;

enum WINSTA_ENUMDESKTOPS      = 1;
enum WINSTA_READATTRIBUTES    = 2;
enum WINSTA_ACCESSCLIPBOARD   = 4;
enum WINSTA_CREATEDESKTOP     = 8;
enum WINSTA_WRITEATTRIBUTES   = 16;
enum WINSTA_ACCESSGLOBALATOMS = 32;
enum WINSTA_EXITWINDOWS       = 64;
enum WINSTA_ENUMERATE         = 256;
enum WINSTA_READSCREEN        = 512;

enum DDL_READWRITE = 0;
enum DDL_READONLY  = 1;
enum DDL_HIDDEN    = 2;
enum DDL_SYSTEM    = 4;
enum DDL_DIRECTORY = 16;
enum DDL_ARCHIVE   = 32;
enum DDL_POSTMSGS  = 8192;
enum DDL_DRIVES    = 16384;
enum DDL_EXCLUSIVE = 32768;

enum {
    DC_ACTIVE       = 0x0001,
    DC_SMALLCAP     = 0x0002,
    DC_ICON         = 0x0004,
    DC_TEXT         = 0x0008,
    DC_INBUTTON     = 0x0010,
    DC_GRADIENT     = 0x0020
}
static if (_WIN32_WINNT >= 0x501) {
    enum DC_BUTTONS = 0x1000;
}

// Where are these documented?
//enum DC_CAPTION = DC_ICON|DC_TEXT|DC_BUTTONS;
//enum DC_NC      = DC_CAPTION|DC_FRAME;

enum BDR_RAISEDOUTER = 1;
enum BDR_SUNKENOUTER = 2;
enum BDR_RAISEDINNER = 4;
enum BDR_SUNKENINNER = 8;
enum BDR_OUTER       = 3;
enum BDR_INNER       = 0xc;
enum BDR_RAISED      = 5;
enum BDR_SUNKEN      = 10;

enum EDGE_RAISED = BDR_RAISEDOUTER|BDR_RAISEDINNER;
enum EDGE_SUNKEN = BDR_SUNKENOUTER|BDR_SUNKENINNER;
enum EDGE_ETCHED = BDR_SUNKENOUTER|BDR_RAISEDINNER;
enum EDGE_BUMP   = BDR_RAISEDOUTER|BDR_SUNKENINNER;

enum BF_LEFT                    = 1;
enum BF_TOP                     = 2;
enum BF_RIGHT                   = 4;
enum BF_BOTTOM                  = 8;
enum BF_TOPLEFT                 = BF_TOP|BF_LEFT;
enum BF_TOPRIGHT                = BF_TOP|BF_RIGHT;
enum BF_BOTTOMLEFT              = BF_BOTTOM|BF_LEFT;
enum BF_BOTTOMRIGHT             = BF_BOTTOM|BF_RIGHT;
enum BF_RECT                    = BF_LEFT|BF_TOP|BF_RIGHT|BF_BOTTOM ;
enum BF_DIAGONAL                = 16;
enum BF_DIAGONAL_ENDTOPRIGHT    = BF_DIAGONAL|BF_TOP|BF_RIGHT;
enum BF_DIAGONAL_ENDTOPLEFT     = BF_DIAGONAL|BF_TOP|BF_LEFT;
enum BF_DIAGONAL_ENDBOTTOMLEFT  = BF_DIAGONAL|BF_BOTTOM|BF_LEFT;
enum BF_DIAGONAL_ENDBOTTOMRIGHT = BF_DIAGONAL|BF_BOTTOM|BF_RIGHT;
enum BF_MIDDLE                  = 0x800;
enum BF_SOFT                    = 0x1000;
enum BF_ADJUST                  = 0x2000;
enum BF_FLAT                    = 0x4000;
enum BF_MONO                    = 0x8000;

enum {
    DFC_CAPTION      = 1,
    DFC_MENU,
    DFC_SCROLL,
    DFC_BUTTON,
    DFC_POPUPMENU // = 5
}

enum {
    DFCS_CAPTIONCLOSE,
    DFCS_CAPTIONMIN,
    DFCS_CAPTIONMAX,
    DFCS_CAPTIONRESTORE,
    DFCS_CAPTIONHELP // = 4
}

enum {
    DFCS_MENUARROW      = 0,
    DFCS_MENUCHECK      = 1,
    DFCS_MENUBULLET     = 2,
    DFCS_MENUARROWRIGHT = 4
}

enum {
    DFCS_SCROLLUP            =  0,
    DFCS_SCROLLDOWN          =  1,
    DFCS_SCROLLLEFT          =  2,
    DFCS_SCROLLRIGHT         =  3,
    DFCS_SCROLLCOMBOBOX      =  5,
    DFCS_SCROLLSIZEGRIP      =  8,
    DFCS_SCROLLSIZEGRIPRIGHT = 16
}

enum {
    DFCS_BUTTONCHECK         = 0,
    DFCS_BUTTONRADIOIMAGE    = 0x0001,
    DFCS_BUTTONRADIOMASK     = 0x0002,
    DFCS_BUTTONRADIO         = 0x0004,
    DFCS_BUTTON3STATE        = 0x0008,
    DFCS_BUTTONPUSH          = 0x0010,
    DFCS_INACTIVE            = 0x0100,
    DFCS_PUSHED              = 0x0200,
    DFCS_CHECKED             = 0x0400,
    DFCS_TRANSPARENT         = 0x0800,
    DFCS_HOT                 = 0x1000,
    DFCS_ADJUSTRECT          = 0x2000,
    DFCS_FLAT                = 0x4000,
    DFCS_MONO                = 0x8000
}

enum {
    DST_COMPLEX = 0,
    DST_TEXT,
    DST_PREFIXTEXT,
    DST_ICON,
    DST_BITMAP // = 4
}

enum DSS_NORMAL = 0;
enum DSS_UNION = 16;
enum DSS_DISABLED = 32;
enum DSS_MONO = 128;
enum DSS_RIGHT = 0x8000;

enum DT_BOTTOM = 8;
enum DT_CALCRECT = 1024;
enum DT_CENTER = 1;
enum DT_EDITCONTROL = 8192;
enum DT_END_ELLIPSIS = 32768;
enum DT_PATH_ELLIPSIS = 16384;
enum DT_WORD_ELLIPSIS = 0x40000;
enum DT_EXPANDTABS = 64;
enum DT_EXTERNALLEADING = 512;
enum DT_LEFT = 0;
enum DT_MODIFYSTRING = 65536;
enum DT_NOCLIP = 256;
enum DT_NOPREFIX = 2048;
enum DT_RIGHT = 2;
enum DT_RTLREADING = 131072;
enum DT_SINGLELINE = 32;
enum DT_TABSTOP = 128;
enum DT_TOP = 0;
enum DT_VCENTER = 4;
enum DT_WORDBREAK = 16;
enum DT_INTERNAL = 4096;

enum WB_ISDELIMITER = 2;
enum WB_LEFT = 0;
enum WB_RIGHT = 1;

enum SB_HORZ = 0;
enum SB_VERT = 1;
enum SB_CTL = 2;
enum SB_BOTH = 3;

enum ESB_DISABLE_BOTH = 3;
enum ESB_DISABLE_DOWN = 2;
enum ESB_DISABLE_LEFT = 1;
enum ESB_DISABLE_LTUP = 1;
enum ESB_DISABLE_RIGHT = 2;
enum ESB_DISABLE_RTDN = 2;
enum ESB_DISABLE_UP = 1;
enum ESB_ENABLE_BOTH = 0;

enum SB_LINEUP = 0;
enum SB_LINEDOWN = 1;
enum SB_LINELEFT = 0;
enum SB_LINERIGHT = 1;
enum SB_PAGEUP = 2;
enum SB_PAGEDOWN = 3;
enum SB_PAGELEFT = 2;
enum SB_PAGERIGHT = 3;
enum SB_THUMBPOSITION = 4;
enum SB_THUMBTRACK = 5;
enum SB_ENDSCROLL = 8;
enum SB_LEFT = 6;
enum SB_RIGHT = 7;
enum SB_BOTTOM = 7;
enum SB_TOP = 6;

//MACRO #define IS_INTRESOURCE(i) (((ULONG_PTR)(i) >> 16) == 0)

template MAKEINTRESOURCE_T(WORD i) {
    enum LPTSTR MAKEINTRESOURCE_T = cast(LPTSTR)(i);
}

nothrow @nogc {
    LPSTR MAKEINTRESOURCEA(/*WORD*/uint i) {
        return cast(LPSTR) i;
    }

    LPWSTR MAKEINTRESOURCEW(/*WORD*/uint i) {
        return cast(LPWSTR) i;
    }
}

enum RT_CURSOR       = MAKEINTRESOURCE_T!(1);
enum RT_BITMAP       = MAKEINTRESOURCE_T!(2);
enum RT_ICON         = MAKEINTRESOURCE_T!(3);
enum RT_MENU         = MAKEINTRESOURCE_T!(4);
enum RT_DIALOG       = MAKEINTRESOURCE_T!(5);
enum RT_STRING       = MAKEINTRESOURCE_T!(6);
enum RT_FONTDIR      = MAKEINTRESOURCE_T!(7);
enum RT_FONT         = MAKEINTRESOURCE_T!(8);
enum RT_ACCELERATOR  = MAKEINTRESOURCE_T!(9);
enum RT_RCDATA       = MAKEINTRESOURCE_T!(10);
enum RT_MESSAGETABLE = MAKEINTRESOURCE_T!(11);

enum RT_GROUP_CURSOR = MAKEINTRESOURCE_T!(12);
enum RT_GROUP_ICON   = MAKEINTRESOURCE_T!(14);
enum RT_VERSION      = MAKEINTRESOURCE_T!(16);
enum RT_DLGINCLUDE   = MAKEINTRESOURCE_T!(17);
enum RT_PLUGPLAY     = MAKEINTRESOURCE_T!(19);
enum RT_VXD          = MAKEINTRESOURCE_T!(20);
enum RT_ANICURSOR    = MAKEINTRESOURCE_T!(21);
enum RT_ANIICON      = MAKEINTRESOURCE_T!(22);
enum RT_HTML         = MAKEINTRESOURCE_T!(23);
enum RT_MANIFEST     = MAKEINTRESOURCE_T!(24);

enum CREATEPROCESS_MANIFEST_RESOURCE_ID                 = MAKEINTRESOURCE_T!(1);
enum ISOLATIONAWARE_MANIFEST_RESOURCE_ID                = MAKEINTRESOURCE_T!(2);
enum ISOLATIONAWARE_NOSTATICIMPORT_MANIFEST_RESOURCE_ID = MAKEINTRESOURCE_T!(3);

enum {
    EWX_LOGOFF      =  0,
    EWX_SHUTDOWN    =  1,
    EWX_REBOOT      =  2,
    EWX_FORCE       =  4,
    EWX_POWEROFF    =  8,
    EWX_FORCEIFHUNG = 16
}

enum CS_BYTEALIGNCLIENT = 4096;
enum CS_BYTEALIGNWINDOW = 8192;
enum CS_KEYCVTWINDOW = 4;
enum CS_NOKEYCVT = 256;
enum CS_CLASSDC = 64;
enum CS_DBLCLKS = 8;
enum CS_GLOBALCLASS = 16384;
enum CS_HREDRAW = 2;
enum CS_NOCLOSE = 512;
enum CS_OWNDC = 32;
enum CS_PARENTDC = 128;
enum CS_SAVEBITS = 2048;
enum CS_VREDRAW = 1;
enum CS_IME = 0x10000;

enum GCW_ATOM = -32;
enum GCL_CBCLSEXTRA = -20;
enum GCL_CBWNDEXTRA = -18;
enum GCL_HBRBACKGROUND = -10;
enum GCL_HCURSOR = -12;
enum GCL_HICON = -14;
enum GCL_HICONSM = -34;
enum GCL_HMODULE = -16;
enum GCL_MENUNAME = -8;
enum GCL_STYLE = -26;
enum GCL_WNDPROC = -24;

alias GCL_HICONSM GCLP_HICONSM;
alias GCL_HICON GCLP_HICON;
alias GCL_HCURSOR GCLP_HCURSOR;
alias GCL_HBRBACKGROUND GCLP_HBRBACKGROUND;
alias GCL_HMODULE  GCLP_HMODULE;
alias GCL_MENUNAME GCLP_MENUNAME;
alias GCL_WNDPROC  GCLP_WNDPROC;

enum {
    IDC_ARROW       = MAKEINTRESOURCE_T!(32512),
    IDC_IBEAM       = MAKEINTRESOURCE_T!(32513),
    IDC_WAIT        = MAKEINTRESOURCE_T!(32514),
    IDC_CROSS       = MAKEINTRESOURCE_T!(32515),
    IDC_UPARROW     = MAKEINTRESOURCE_T!(32516),
    IDC_SIZE        = MAKEINTRESOURCE_T!(32640),
    IDC_ICON        = MAKEINTRESOURCE_T!(32641),
    IDC_SIZENWSE    = MAKEINTRESOURCE_T!(32642),
    IDC_SIZENESW    = MAKEINTRESOURCE_T!(32643),
    IDC_SIZEWE      = MAKEINTRESOURCE_T!(32644),
    IDC_SIZENS      = MAKEINTRESOURCE_T!(32645),
    IDC_SIZEALL     = MAKEINTRESOURCE_T!(32646),
    IDC_NO          = MAKEINTRESOURCE_T!(32648),
    IDC_HAND        = MAKEINTRESOURCE_T!(32649),
    IDC_APPSTARTING = MAKEINTRESOURCE_T!(32650),
    IDC_HELP        = MAKEINTRESOURCE_T!(32651),
    IDI_APPLICATION = MAKEINTRESOURCE_T!(32512),
    IDI_HAND        = MAKEINTRESOURCE_T!(32513),
    IDI_QUESTION    = MAKEINTRESOURCE_T!(32514),
    IDI_EXCLAMATION = MAKEINTRESOURCE_T!(32515),
    IDI_ASTERISK    = MAKEINTRESOURCE_T!(32516),
    IDI_WINLOGO     = MAKEINTRESOURCE_T!(32517),
    IDI_WARNING     = IDI_EXCLAMATION,
    IDI_ERROR       = IDI_HAND,
    IDI_INFORMATION = IDI_ASTERISK
}
static if (_WIN32_WINNT >= 0x600) {
    enum IDI_SHIELD = MAKEINTRESOURCE_T!(32518);
}

enum {
    MIIM_STATE      = 0x0001,
    MIIM_ID         = 0x0002,
    MIIM_SUBMENU    = 0x0004,
    MIIM_CHECKMARKS = 0x0008,
    MIIM_TYPE       = 0x0010,
    MIIM_DATA       = 0x0020,
    MIIM_STRING     = 0x0040,
    MIIM_BITMAP     = 0x0080,
    MIIM_FTYPE      = 0x0100
}

enum {
    MFT_BITMAP       = 0x0004,
    MFT_MENUBARBREAK = 0x0020,
    MFT_MENUBREAK    = 0x0040,
    MFT_OWNERDRAW    = 0x0100,
    MFT_RADIOCHECK   = 0x0200,
    MFT_RIGHTJUSTIFY = 0x4000,
    MFT_SEPARATOR    = 0x0800,
    MFT_RIGHTORDER   = 0x2000,
    MFT_STRING       = 0
}

enum {
    MFS_CHECKED   = 8,
    MFS_DEFAULT   = 4096,
    MFS_DISABLED  = 3,
    MFS_ENABLED   = 0,
    MFS_GRAYED    = 3,
    MFS_HILITE    = 128,
    MFS_UNCHECKED = 0,
    MFS_UNHILITE  = 0
}

enum {
    GW_HWNDFIRST = 0,
    GW_HWNDLAST,
    GW_HWNDNEXT,
    GW_HWNDPREV,
    GW_OWNER,
    GW_CHILD  // = 5
}

enum {
    SW_HIDE            =  0,
    SW_NORMAL          =  1,
    SW_SHOWNORMAL      =  1,
    SW_SHOWMINIMIZED   =  2,
    SW_MAXIMIZE        =  3,
    SW_SHOWMAXIMIZED   =  3,
    SW_SHOWNOACTIVATE  =  4,
    SW_SHOW            =  5,
    SW_MINIMIZE        =  6,
    SW_SHOWMINNOACTIVE =  7,
    SW_SHOWNA          =  8,
    SW_RESTORE         =  9,
    SW_SHOWDEFAULT     = 10,
    SW_FORCEMINIMIZE   = 11,
    SW_MAX             = 11
}

enum {
    SW_PARENTCLOSING  = 1,
    SW_OTHERZOOM,
    SW_PARENTOPENING,
    SW_OTHERUNZOOM // = 4
}

enum { // is this a different SW from the previous?
    SW_SCROLLCHILDREN = 0x01,
    SW_INVALIDATE     = 0x02,
    SW_ERASE          = 0x04,
    SW_SMOOTHSCROLL   = 0x10
}

enum {
    MB_OK                        = 0,
    MB_OKCANCEL,
    MB_ABORTRETRYIGNORE,
    MB_YESNOCANCEL,
    MB_YESNO,
    MB_RETRYCANCEL,
    MB_CANCELTRYCONTINUE,     // = 6
    MB_TYPEMASK                  = 0x0000000F,
    MB_ICONHAND                  = 0x00000010,
    MB_ICONSTOP                  = MB_ICONHAND,
    MB_ICONERROR                 = MB_ICONHAND,
    MB_ICONQUESTION              = 0x00000020,
    MB_ICONEXCLAMATION           = 0x00000030,
    MB_ICONWARNING               = MB_ICONEXCLAMATION,
    MB_ICONASTERISK              = 0x00000040,
    MB_ICONINFORMATION           = MB_ICONASTERISK,
    MB_USERICON                  = 0x00000080,
    MB_ICONMASK                  = 0x000000F0,

    MB_DEFBUTTON1                = 0,
    MB_DEFBUTTON2                = 0x00000100,
    MB_DEFBUTTON3                = 0x00000200,
    MB_DEFBUTTON4                = 0x00000300,
    MB_DEFMASK                   = 0x00000F00,

    MB_APPLMODAL                 = 0,
    MB_SYSTEMMODAL               = 0x00001000,
    MB_TASKMODAL                 = 0x00002000,
    MB_MODEMASK                  = 0x00003000,

    MB_HELP                      = 0x00004000,
    MB_NOFOCUS                   = 0x00008000,
    MB_MISCMASK                  = 0x0000C000,

    MB_SETFOREGROUND             = 0x00010000,
    MB_DEFAULT_DESKTOP_ONLY      = 0x00020000,
    MB_TOPMOST                   = 0x00040000,
    MB_SERVICE_NOTIFICATION_NT3X = 0x00040000,
    MB_RIGHT                     = 0x00080000,
    MB_RTLREADING                = 0x00100000,
    MB_SERVICE_NOTIFICATION      = 0x00200000
}

enum {
    IDOK          = 1,
    IDCANCEL,
    IDABORT,
    IDRETRY,
    IDIGNORE,
    IDYES,
    IDNO,
    IDCLOSE,
    IDHELP,
    IDTRYAGAIN,
    IDCONTINUE // = 11
}

enum GWL_EXSTYLE = -20;
enum GWL_STYLE = -16;
enum GWL_WNDPROC = -4;
enum GWLP_WNDPROC = -4;
enum GWL_HINSTANCE = -6;
enum GWLP_HINSTANCE = -6;
enum GWL_HWNDPARENT = -8;
enum GWLP_HWNDPARENT = -8;
enum GWL_ID = -12;
enum GWLP_ID = -12;
enum GWL_USERDATA = -21;
enum GWLP_USERDATA = -21;

enum DWL_DLGPROC = 4;
enum DWLP_DLGPROC = 4;
enum DWL_MSGRESULT = 0;
enum DWLP_MSGRESULT = 0;
enum DWL_USER = 8;
enum DWLP_USER = 8;

enum QS_KEY            = 1;
enum QS_MOUSEMOVE      = 2;
enum QS_MOUSEBUTTON    = 4;
enum QS_MOUSE          = 6;
enum QS_POSTMESSAGE    = 8;
enum QS_TIMER          = 16;
enum QS_PAINT          = 32;
enum QS_SENDMESSAGE    = 64;
enum QS_HOTKEY         = 128;
enum QS_ALLPOSTMESSAGE = 256;
static if (_WIN32_WINNT >= 0x501) {
enum QS_RAWINPUT       = 1024;
enum QS_INPUT          = 1031;
enum QS_ALLEVENTS      = 1215;
enum QS_ALLINPUT       = 1279;
} else {
enum QS_INPUT          = 7;
enum QS_ALLEVENTS      = 191;
enum QS_ALLINPUT       = 255;
}

enum MWMO_WAITALL        = 1;
enum MWMO_ALERTABLE      = 2;
enum MWMO_INPUTAVAILABLE = 4;

enum COLOR_3DDKSHADOW = 21;
enum COLOR_3DFACE = 15;
enum COLOR_3DHILIGHT = 20;
enum COLOR_3DHIGHLIGHT = 20;
enum COLOR_3DLIGHT = 22;
enum COLOR_BTNHILIGHT = 20;
enum COLOR_3DSHADOW = 16;
enum COLOR_ACTIVEBORDER = 10;
enum COLOR_ACTIVECAPTION = 2;
enum COLOR_APPWORKSPACE = 12;
enum COLOR_BACKGROUND = 1;
enum COLOR_DESKTOP = 1;
enum COLOR_BTNFACE = 15;
enum COLOR_BTNHIGHLIGHT = 20;
enum COLOR_BTNSHADOW = 16;
enum COLOR_BTNTEXT = 18;
enum COLOR_CAPTIONTEXT = 9;
enum COLOR_GRAYTEXT = 17;
enum COLOR_HIGHLIGHT = 13;
enum COLOR_HIGHLIGHTTEXT = 14;
enum COLOR_INACTIVEBORDER = 11;
enum COLOR_INACTIVECAPTION = 3;
enum COLOR_INACTIVECAPTIONTEXT = 19;
enum COLOR_INFOBK = 24;
enum COLOR_INFOTEXT = 23;
enum COLOR_MENU = 4;
enum COLOR_MENUTEXT = 7;
enum COLOR_SCROLLBAR = 0;
enum COLOR_WINDOW = 5;
enum COLOR_WINDOWFRAME = 6;
enum COLOR_WINDOWTEXT = 8;
enum COLOR_HOTLIGHT = 26;
enum COLOR_GRADIENTACTIVECAPTION = 27;
enum COLOR_GRADIENTINACTIVECAPTION = 28;

enum CTLCOLOR_MSGBOX = 0;
enum CTLCOLOR_EDIT = 1;
enum CTLCOLOR_LISTBOX = 2;
enum CTLCOLOR_BTN = 3;
enum CTLCOLOR_DLG = 4;
enum CTLCOLOR_SCROLLBAR = 5;
enum CTLCOLOR_STATIC = 6;
enum CTLCOLOR_MAX = 7;

// For GetSystemMetrics()
enum : int {
    SM_CXSCREEN = 0,
    SM_CYSCREEN,
    SM_CXVSCROLL,
    SM_CYHSCROLL,
    SM_CYCAPTION,
    SM_CXBORDER,
    SM_CYBORDER,
    SM_CXDLGFRAME,    // = 7
    SM_CXFIXEDFRAME      = SM_CXDLGFRAME,
    SM_CYDLGFRAME,    // = 8
    SM_CYFIXEDFRAME      = SM_CYDLGFRAME,
    SM_CYVTHUMB,      // = 9
    SM_CXHTHUMB,
    SM_CXICON,
    SM_CYICON,
    SM_CXCURSOR,
    SM_CYCURSOR,
    SM_CYMENU,
    SM_CXFULLSCREEN,
    SM_CYFULLSCREEN,
    SM_CYKANJIWINDOW,
    SM_MOUSEPRESENT,
    SM_CYVSCROLL,
    SM_CXHSCROLL,
    SM_DEBUG,
    SM_SWAPBUTTON,
    SM_RESERVED1,
    SM_RESERVED2,
    SM_RESERVED3,
    SM_RESERVED4,
    SM_CXMIN,
    SM_CYMIN,
    SM_CXSIZE,
    SM_CYSIZE,
    SM_CXSIZEFRAME,   // = 32,
    SM_CXFRAME           = SM_CXSIZEFRAME,
    SM_CYSIZEFRAME,   // = 33
    SM_CYFRAME           = SM_CYSIZEFRAME,
    SM_CXMINTRACK,
    SM_CYMINTRACK,
    SM_CXDOUBLECLK,
    SM_CYDOUBLECLK,
    SM_CXICONSPACING,
    SM_CYICONSPACING,
    SM_MENUDROPALIGNMENT,
    SM_PENWINDOWS,
    SM_DBCSENABLED,
    SM_CMOUSEBUTTONS,
    SM_SECURE,
    SM_CXEDGE,
    SM_CYEDGE,
    SM_CXMINSPACING,
    SM_CYMINSPACING,
    SM_CXSMICON,
    SM_CYSMICON,
    SM_CYSMCAPTION,
    SM_CXSMSIZE,
    SM_CYSMSIZE,
    SM_CXMENUSIZE,
    SM_CYMENUSIZE,
    SM_ARRANGE,
    SM_CXMINIMIZED,
    SM_CYMINIMIZED,
    SM_CXMAXTRACK,
    SM_CYMAXTRACK,
    SM_CXMAXIMIZED,
    SM_CYMAXIMIZED,
    SM_NETWORK,       // = 63
    SM_CLEANBOOT         = 67,
    SM_CXDRAG,
    SM_CYDRAG,
    SM_SHOWSOUNDS,
    SM_CXMENUCHECK,
    SM_CYMENUCHECK,
    SM_SLOWMACHINE,
    SM_MIDEASTENABLED,
    SM_MOUSEWHEELPRESENT,
    SM_XVIRTUALSCREEN,
    SM_YVIRTUALSCREEN,
    SM_CXVIRTUALSCREEN,
    SM_CYVIRTUALSCREEN,
    SM_CMONITORS,
    SM_SAMEDISPLAYFORMAT,
    SM_IMMENABLED,
    SM_CXFOCUSBORDER,
    SM_CYFOCUSBORDER, // = 84
    SM_TABLETPC          = 86,
    SM_MEDIACENTER,
    SM_STARTER,       // = 88
    SM_CMETRICS          = 88,
    SM_SERVERR2,
    SM_REMOTESESSION     = 0x1000,
}
static if (_WIN32_WINNT >= 0x501) {
    enum {  // These are only for WinXP and later
        SM_SHUTTINGDOWN  = 0x2000,
        SM_REMOTECONTROL = 0x2001
    }
}

enum ARW_BOTTOMLEFT = 0;
enum ARW_BOTTOMRIGHT = 1;
enum ARW_HIDE = 8;
enum ARW_TOPLEFT = 2;
enum ARW_TOPRIGHT = 3;
enum ARW_DOWN = 4;
enum ARW_LEFT = 0;
enum ARW_RIGHT = 0;
enum ARW_UP = 4;

enum UOI_FLAGS = 1;
enum UOI_NAME = 2;
enum UOI_TYPE = 3;
enum UOI_USER_SID = 4;

// For the fuLoad parameter of LoadImage()
enum : UINT {
    LR_DEFAULTCOLOR     = 0,
    LR_MONOCHROME       = 0x0001,
    LR_COLOR            = 0x0002,
    LR_COPYRETURNORG    = 0x0004,
    LR_COPYDELETEORG    = 0x0008,
    LR_LOADFROMFILE     = 0x0010,
    LR_LOADTRANSPARENT  = 0x0020,
    LR_DEFAULTSIZE      = 0x0040,
    LR_VGACOLOR         = 0x0080,
    LR_LOADREALSIZE     = 0x0080,
    LR_LOADMAP3DCOLORS  = 0x1000,
    LR_CREATEDIBSECTION = 0x2000,
    LR_COPYFROMRESOURCE = 0x4000,
    LR_SHARED           = 0x8000
}

enum {
    KEYEVENTF_EXTENDEDKEY = 1,
    KEYEVENTF_KEYUP       = 2,
    KEYEVENTF_UNICODE     = 4,
    KEYEVENTF_SCANCODE    = 8
}

enum OBM_BTNCORNERS = 32758;
enum OBM_BTSIZE = 32761;
enum OBM_CHECK = 32760;
enum OBM_CHECKBOXES = 32759;
enum OBM_CLOSE = 32754;
enum OBM_COMBO = 32738;
enum OBM_DNARROW = 32752;
enum OBM_DNARROWD = 32742;
enum OBM_DNARROWI = 32736;
enum OBM_LFARROW = 32750;
enum OBM_LFARROWI = 32734;
enum OBM_LFARROWD = 32740;
enum OBM_MNARROW = 32739;
enum OBM_OLD_CLOSE = 32767;
enum OBM_OLD_DNARROW = 32764;
enum OBM_OLD_LFARROW = 32762;
enum OBM_OLD_REDUCE = 32757;
enum OBM_OLD_RESTORE = 32755;
enum OBM_OLD_RGARROW = 32763;
enum OBM_OLD_UPARROW = 32765;
enum OBM_OLD_ZOOM = 32756;
enum OBM_REDUCE = 32749;
enum OBM_REDUCED = 32746;
enum OBM_RESTORE = 32747;
enum OBM_RESTORED = 32744;
enum OBM_RGARROW = 32751;
enum OBM_RGARROWD = 32741;
enum OBM_RGARROWI = 32735;
enum OBM_SIZE = 32766;
enum OBM_UPARROW = 32753;
enum OBM_UPARROWD = 32743;
enum OBM_UPARROWI = 32737;
enum OBM_ZOOM = 32748;
enum OBM_ZOOMD = 32745;

enum OCR_NORMAL = 32512;
enum OCR_IBEAM = 32513;
enum OCR_WAIT = 32514;
enum OCR_CROSS = 32515;
enum OCR_UP = 32516;
enum OCR_SIZE = 32640;
enum OCR_ICON = 32641;
enum OCR_SIZENWSE = 32642;
enum OCR_SIZENESW = 32643;
enum OCR_SIZEWE = 32644;
enum OCR_SIZENS = 32645;
enum OCR_SIZEALL = 32646;
enum OCR_NO = 32648;
enum OCR_APPSTARTING = 32650;

enum OIC_SAMPLE = 32512;
enum OIC_HAND = 32513;
enum OIC_QUES = 32514;
enum OIC_BANG = 32515;
enum OIC_NOTE = 32516;
enum OIC_WINLOGO = 32517;
enum OIC_WARNING = OIC_BANG;
enum OIC_ERROR = OIC_HAND;
enum OIC_INFORMATION = OIC_NOTE;

enum HELPINFO_MENUITEM = 2;
enum HELPINFO_WINDOW = 1;

static if (_WIN32_WINNT >= 0x501) {
    enum {
        WTS_CONSOLE_CONNECT = 1,
        WTS_CONSOLE_DISCONNECT,
        WTS_REMOTE_CONNECT,
        WTS_REMOTE_DISCONNECT,
        WTS_SESSION_LOGON,
        WTS_SESSION_LOGOFF,
        WTS_SESSION_LOCK,
        WTS_SESSION_UNLOCK,
        WTS_SESSION_REMOTE_CONTROL // = 9
    }
}

enum MSGF_DIALOGBOX = 0;
enum MSGF_MESSAGEBOX = 1;
enum MSGF_MENU = 2;
enum MSGF_MOVE = 3;
enum MSGF_SIZE = 4;
enum MSGF_SCROLLBAR = 5;
enum MSGF_NEXTWINDOW = 6;
enum MSGF_MAINLOOP = 8;
enum MSGF_USER = 4096;

enum {
    MOUSEEVENTF_MOVE       = 0x0001,
    MOUSEEVENTF_LEFTDOWN   = 0x0002,
    MOUSEEVENTF_LEFTUP     = 0x0004,
    MOUSEEVENTF_RIGHTDOWN  = 0x0008,
    MOUSEEVENTF_RIGHTUP    = 0x0010,
    MOUSEEVENTF_MIDDLEDOWN = 0x0020,
    MOUSEEVENTF_MIDDLEUP   = 0x0040,
    MOUSEEVENTF_XDOWN      = 0x0080,
    MOUSEEVENTF_XUP        = 0x0100,
    MOUSEEVENTF_WHEEL      = 0x0800,
    MOUSEEVENTF_ABSOLUTE   = 0x8000
}

enum PM_NOREMOVE = 0;
enum PM_REMOVE = 1;
enum PM_NOYIELD = 2;

enum : HWND {
    HWND_BROADCAST = cast(HWND) 0xFFFF,
    HWND_MESSAGE   = cast(HWND)     -3,
    HWND_NOTOPMOST = cast(HWND)     -2,
    HWND_TOPMOST   = cast(HWND)     -1,
    HWND_TOP       = cast(HWND)      0,
    HWND_DESKTOP   = cast(HWND)      0,
    HWND_BOTTOM    = cast(HWND)      1
}

enum RDW_INVALIDATE      = 1;
enum RDW_INTERNALPAINT   = 2;
enum RDW_ERASE           = 4;
enum RDW_VALIDATE        = 8;
enum RDW_NOINTERNALPAINT = 16;
enum RDW_NOERASE         = 32;
enum RDW_NOCHILDREN      = 64;
enum RDW_ALLCHILDREN     = 128;
enum RDW_UPDATENOW       = 256;
enum RDW_ERASENOW        = 512;
enum RDW_FRAME           = 1024;
enum RDW_NOFRAME         = 2048;

enum {
    SMTO_NORMAL             = 0,
    SMTO_BLOCK              = 1,
    SMTO_ABORTIFHUNG        = 2,
    SMTO_NOTIMEOUTIFNOTHUNG = 8
}

enum SIF_ALL = 23;
enum SIF_PAGE = 2;
enum SIF_POS = 4;
enum SIF_RANGE = 1;
enum SIF_DISABLENOSCROLL = 8;
enum SIF_TRACKPOS = 16;

enum SWP_DRAWFRAME = 32;
enum SWP_FRAMECHANGED = 32;
enum SWP_HIDEWINDOW = 128;
enum SWP_NOACTIVATE = 16;
enum SWP_NOCOPYBITS = 256;
enum SWP_NOMOVE = 2;
enum SWP_NOSIZE = 1;
enum SWP_NOREDRAW = 8;
enum SWP_NOZORDER = 4;
enum SWP_SHOWWINDOW = 64;
enum SWP_NOOWNERZORDER = 512;
enum SWP_NOREPOSITION = 512;
enum SWP_NOSENDCHANGING = 1024;
en