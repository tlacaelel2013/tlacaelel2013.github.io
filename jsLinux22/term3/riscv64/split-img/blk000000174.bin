
    DIVSS = 0xF30F5E,
    DIVSD = 0xF20F5E,
    DIVPS = 0x000F5E,
    DIVPD = 0x660F5E,

    PAND  = 0x660FDB,
    POR   = 0x660FEB,

    UCOMISS = 0x000F2E,
    UCOMISD = 0x660F2E,

    XORPS = 0x000F57,
    XORPD = 0x660F57,

    // Use STO and LOD instead of MOV to distinguish the direction
    STOSS  = 0xF30F11,
    STOSD  = 0xF20F11,
    STOAPS = 0x000F29,
    STOAPD = 0x660F29,
    STODQA = 0x660F7F,
    STOD   = 0x660F7E,        // MOVD reg/mem64, xmm   66 0F 7E /r
    STOQ   = 0x660FD6,

    LODSS  = 0xF30F10,
    LODSD  = 0xF20F10,
    LODAPS = 0x000F28,
    LODAPD = 0x660F28,
    LODDQA = 0x660F6F,
    LODD   = 0x660F6E,        // MOVD xmm, reg/mem64   66 0F 6E /r
    LODQ   = 0xF30F7E,

    LODDQU   = 0xF30F6F,      // MOVDQU xmm1, xmm2/mem128  F3 0F 6F /r
    STODQU   = 0xF30F7F,      // MOVDQU xmm1/mem128, xmm2  F3 0F 7F /r
    MOVDQ2Q  = 0xF20FD6,      // MOVDQ2Q mmx, xmm          F2 0F D6 /r
    MOVHLPS  = 0x0F12,        // MOVHLPS xmm1, xmm2        0F 12 /r
    LODHPD   = 0x660F16,
    STOHPD   = 0x660F17,      // MOVHPD mem64, xmm         66 0F 17 /r
    LODHPS   = 0x0F16,
    STOHPS   = 0x0F17,
    MOVLHPS  = 0x0F16,
    LODLPD   = 0x660F12,
    STOLPD   = 0x660F13,
    LODLPS   = 0x0F12,
    STOLPS   = 0x0F13,
    MOVMSKPD = 0x660F50,
    MOVMSKPS = 0x0F50,
    MOVNTDQ  = 0x660FE7,
    MOVNTI   = 0x0FC3,
    MOVNTPD  = 0x660F2B,
    MOVNTPS  = 0x0F2B,
    MOVNTQ   = 0x0FE7,
    MOVQ2DQ  = 0xF30FD6,
    LODUPD   = 0x660F10,
    STOUPD   = 0x660F11,
    LODUPS   = 0x0F10,
    STOUPS   = 0x0F11,

    PACKSSDW = 0x660F6B,
    PACKSSWB = 0x660F63,
    PACKUSWB = 0x660F67,
    PADDSB = 0x660FEC,
    PADDSW = 0x660FED,
    PADDUSB = 0x660FDC,
    PADDUSW = 0x660FDD,
    PANDN = 0x660FDF,
    PCMPEQB = 0x660F74,
    PCMPEQD = 0x660F76,
    PCMPEQW = 0x660F75,
    PCMPGTB = 0x660F64,
    PCMPGTD = 0x660F66,
    PCMPGTW = 0x660F65,
    PMADDWD = 0x660FF5,
    PSLLW = 0x660FF1,
    PSLLD = 0x660FF2,
    PSLLQ = 0x660FF3,
    PSRAW = 0x660FE1,
    PSRAD = 0x660FE2,
    PSRLW = 0x660FD1,
    PSRLD = 0x660FD2,
    PSRLQ = 0x660FD3,
    PSUBSB = 0x660FE8,
    PSUBSW = 0x660FE9,
    PSUBUSB = 0x660FD8,
    PSUBUSW = 0x660FD9,
    PUNPCKHBW = 0x660F68,
    PUNPCKHDQ = 0x660F6A,
    PUNPCKHWD = 0x660F69,
    PUNPCKLBW = 0x660F60,
    PUNPCKLDQ = 0x660F62,
    PUNPCKLWD = 0x660F61,
    PXOR = 0x660FEF,
    ANDPD = 0x660F54,
    ANDPS = 0x0F54,
    ANDNPD = 0x660F55,
    ANDNPS = 0x0F55,
    CMPPS = 0x0FC2,
    CMPPD = 0x660FC2,
    CMPSD = 0xF20FC2,
    CMPSS = 0xF30FC2,
    COMISD = 0x660F2F,
    COMISS = 0x0F2F,
    CVTDQ2PD = 0xF30FE6,
    CVTDQ2PS = 0x0F5B,
    CVTPD2DQ = 0xF20FE6,
    CVTPD2PI = 0x660F2D,
    CVTPD2PS = 0x660F5A,
    CVTPI2PD = 0x660F2A,
    CVTPI2PS = 0x0F2A,
    CVTPS2DQ = 0x660F5B,
    CVTPS2PD = 0x0F5A,
    CVTPS2PI = 0x0F2D,
    CVTSD2SI = 0xF20F2D,
    CVTSD2SS = 0xF20F5A,
    CVTSI2SD = 0xF20F2A,
    CVTSI2SS = 0xF30F2A,
    CVTSS2SD = 0xF30F5A,
    CVTSS2SI = 0xF30F2D,
    CVTTPD2PI = 0x660F2C,
    CVTTPD2DQ = 0x660FE6,
    CVTTPS2DQ = 0xF30F5B,
    CVTTPS2PI = 0x0F2C,
    CVTTSD2SI = 0xF20F2C,
    CVTTSS2SI = 0xF30F2C,
    MASKMOVDQU = 0x660FF7,
    MASKMOVQ = 0x0FF7,
    MAXPD = 0x660F5F,
    MAXPS = 0x0F5F,
    MAXSD = 0xF20F5F,
    MAXSS = 0xF30F5F,
    MINPD = 0x660F5D,
    MINPS = 0x0F5D,
    MINSD = 0xF20F5D,
    MINSS = 0xF30F5D,
    ORPD = 0x660F56,
    ORPS = 0x0F56,
    PAVGB = 0x660FE0,
    PAVGW = 0x660FE3,
    PMAXSW = 0x660FEE,
    //PINSRW = 0x660FC4,
    PMAXUB = 0x660FDE,
    PMINSW = 0x660FEA,
    PMINUB = 0x660FDA,
    //PMOVMSKB = 0x660FD7,
    PMULHUW = 0x660FE4,
    PMULHW = 0x660FE5,
    PMULUDQ = 0x660FF4,
    PSADBW = 0x660FF6,
    PUNPCKHQDQ = 0x660F6D,
    PUNPCKLQDQ = 0x660F6C,
    RCPPS = 0x0F53,
    RCPSS = 0xF30F53,
    RSQRTPS = 0x0F52,
    RSQRTSS = 0xF30F52,
    SQRTPD = 0x660F51,
    SHUFPD = 0x660FC6,
    SHUFPS = 0x0FC6,
    SQRTPS = 0x0F51,
    SQRTSD = 0xF20F51,
    SQRTSS = 0xF30F51,
    UNPCKHPD = 0x660F15,
    UNPCKHPS = 0x0F15,
    UNPCKLPD = 0x660F14,
    UNPCKLPS = 0x0F14,

    PSHUFD = 0x660F70,
    PSHUFHW = 0xF30F70,
    PSHUFLW = 0xF20F70,
    PSHUFW = 0x0F70,
    PSLLDQ = 0x07660F73,
    PSRLDQ = 0x03660F73,

    //PREFETCH = 0x0F18,

// SSE3 Pentium 4 (Prescott)

    ADDSUBPD = 0x660FD0,
    ADDSUBPS = 0xF20FD0,
    HADDPD   = 0x660F7C,
    HADDPS   = 0xF20F7C,
    HSUBPD   = 0x660F7D,
    HSUBPS   = 0xF20F7D,
    MOVDDUP  = 0xF20F12,
    MOVSHDUP = 0xF30F16,
    MOVSLDUP = 0xF30F12,
    LDDQU    = 0xF20FF0,
    MONITOR  = 0x0F01C8,
    MWAIT    = 0x0F01C9,

// SSSE3
    PALIGNR = 0x660F3A0F,
    PHADDD = 0x660F3802,
    PHADDW = 0x660F3801,
    PHADDSW = 0x660F3803,
    PABSB = 0x660F381C,
    PABSD = 0x660F381E,
    PABSW = 0x660F381D,
    PSIGNB = 0x660F3808,
    PSIGND = 0x660F380A,
    PSIGNW = 0x660F3809,
    PSHUFB = 0x660F3800,
    PMADDUBSW = 0x660F3804,
    PMULHRSW = 0x660F380B,
    PHSUBD = 0x660F3806,
    PHSUBW = 0x660F3805,
    PHSUBSW = 0x660F3807,

// SSE4.1

    BLENDPD   = 0x660F3A0D,
    BLENDPS   = 0x660F3A0C,
    BLENDVPD  = 0x660F3815,
    BLENDVPS  = 0x660F3814,
    DPPD      = 0x660F3A41,
    DPPS      = 0x660F3A40,
    EXTRACTPS = 0x660F3A17,
    INSERTPS  = 0x660F3A21,
    MPSADBW   = 0x660F3A42,
    PBLENDVB  = 0x660F3810,
    PBLENDW   = 0x660F3A0E,
    PEXTRD    = 0x660F3A16,
    PEXTRQ    = 0x660F3A16,
    PINSRB    = 0x660F3A20,
    PINSRD    = 0x660F3A22,
    PINSRQ    = 0x660F3A22,

    MOVNTDQA = 0x660F382A,
    PACKUSDW = 0x660F382B,
    PCMPEQQ = 0x660F3829,
    PEXTRB = 0x660F3A14,
    PHMINPOSUW = 0x660F3841,
    PMAXSB = 0x660F383C,
    PMAXSD = 0x660F383D,
    PMAXUD = 0x660F383F,
    PMAXUW = 0x660F383E,
    PMINSB = 0x660F3838,
    PMINSD = 0x660F3839,
    PMINUD = 0x660F383B,
    PMINUW = 0x660F383A,
    PMOVSXBW = 0x660F3820,
    PMOVSXBD = 0x660F3821,
    PMOVSXBQ = 0x660F3822,
    PMOVSXWD = 0x660F3823,
    PMOVSXWQ = 0x660F3824,
    PMOVSXDQ = 0x660F3825,
    PMOVZXBW = 0x660F3830,
    PMOVZXBD = 0x660F3831,
    PMOVZXBQ = 0x660F3832,
    PMOVZXWD = 0x660F3833,
    PMOVZXWQ = 0x660F3834,
    PMOVZXDQ = 0x660F3835,
    PMULDQ   = 0x660F3828,
    PMULLD   = 0x660F3840,
    PTEST    = 0x660F3817,

    ROUNDPD = 0x660F3A09,
    ROUNDPS = 0x660F3A08,
    ROUNDSD = 0x660F3A0B,
    ROUNDSS = 0x660F3A0A,

// SSE4.2
    PCMPESTRI  = 0x660F3A61,
    PCMPESTRM  = 0x660F3A60,
    PCMPISTRI  = 0x660F3A63,
    PCMPISTRM  = 0x660F3A62,
    PCMPGTQ    = 0x660F3837,
    //CRC32

// SSE4a (AMD only)
    // EXTRQ,INSERTQ,MOVNTSD,MOVNTSS

// POPCNT and LZCNT (have their own CPUID bits)
    POPCNT     = 0xF30FB8,
    // LZCNT
  }

  /**
   * Generate two operand instruction with XMM 128 bit operands.
   *
   * This is a compiler magic function - it doesn't behave like
   * regular D functions.
   *
   * Parameters:
   *      opcode  any of the XMM opcodes; it must be a compile time constant
   *      op1     first operand
   *      op2     second operand
   * Returns:
   *      result of opcode
   */
  pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2);

  /**
   * Unary SIMD instructions.
   */
  pure @safe void16 __simd(XMM opcode, void16 op1);
  pure @safe void16 __simd(XMM opcode, double d);       ///
  pure @safe void16 __simd(XMM opcode, float f);        ///

  /****
   * For instructions:
   * CMPPD, CMPSS, CMPSD, CMPPS,
   * PSHUFD, PSHUFHW, PSHUFLW,
   * BLENDPD, BLENDPS, DPPD, DPPS,
   * MPSADBW, PBLENDW,
   * ROUNDPD, ROUNDPS, ROUNDSD, ROUNDSS
   * Parameters:
   *      opcode  any of the above XMM opcodes; it must be a compile time constant
   *      op1     first operand
   *      op2     second operand
   *      imm8    third operand; must be a compile time constant
   * Returns:
   *      result of opcode
   */
  pure @safe void16 __simd(XMM opcode, void16 op1, void16 op2, ubyte imm8);

  /***
   * For instructions with the imm8 version:
   * PSLLD, PSLLQ, PSLLW, PSRAD, PSRAW, PSRLD, PSRLQ, PSRLW,
   * PSRLDQ, PSLLDQ
   * Parameters:
   *      opcode  any of the XMM opcodes; it must be a compile time constant
   *      op1     first operand
   *      imm8    second operand; must be a compile time constant
   * Returns:
   *      result of opcode
   */
  pure @safe void16 __simd_ib(XMM opcode, void16 op1, ubyte imm8);

  /*****
   * For "store" operations of the form:
   *    op1 op= op2
   * Returns:
   *    op2
   * These cannot be marked as pure, as semantic() doesn't check them.
   */
  @safe void16 __simd_sto(XMM opcode, void16 op1, void16 op2);
  @safe void16 __simd_sto(XMM opcode, double op1, void16 op2); ///
  @safe void16 __simd_sto(XMM opcode, float op1, void16 op2);  ///

  /* The following use overloading to ensure correct typing.
   * Compile with inlining on for best performance.
   */

  pure @safe short8 pcmpeq()(short8 v1, short8 v2)
  {
      return __simd(XMM.PCMPEQW, v1, v2);
  }

  pure @safe ushort8 pcmpeq()(ushort8 v1, ushort8 v2)
  {
      return __simd(XMM.PCMPEQW, v1, v2);
  }

  /*********************
   * Emit prefetch instruction.
   * Params:
   *    address = address to be prefetched
   *    writeFetch = true for write fetch, false for read fetch
   *    locality = 0..3 (0 meaning least local, 3 meaning most local)
   * Note:
   *    The Intel mappings are:
   *    $(TABLE
   *    $(THEAD writeFetch, locality, Instruction)
   *    $(TROW false, 0, prefetchnta)
   *    $(TROW false, 1, prefetch2)
   *    $(TROW false, 2, prefetch1)
   *    $(TROW false, 3, prefetch0)
   *    $(TROW false, 0, prefetchw)
   *    $(TROW false, 1, prefetchw)
   *    $(TROW false, 2, prefetchw)
   *    $(TROW false, 3, prefetchw)
   *    )
   */
  void prefetch(bool writeFetch, ubyte locality)(const(void)* address)
  {
        static if (writeFetch)
            __prefetch(address, 4);
        else static if (locality < 4)
            __prefetch(address, 3 - locality);
        else
            static assert(0, "0..3 expected for locality");
  }

  private void __prefetch(const(void*) address, ubyte encoding);

  /*************************************
   * Load unaligned vector from address.
   * This is a compiler intrinsic.
   * Params:
   *    p = pointer to vector
   * Returns:
   *    vector
   */

  V loadUnaligned(V)(const V* p)
        if (is(V == void16) ||
            is(V == byte16) ||
            is(V == ubyte16) ||
            is(V == short8) ||
            is(V == ushort8) ||
            is(V == int4) ||
            is(V == uint4) ||
            is(V == long2) ||
            is(V == ulong2))
  {
        pragma(inline, true);
        static if (is(V == double2))
            return cast(V)__simd(XMM.LODUPD, *cast(const void16*)p);
        else static if (is(V == float4))
            return cast(V)__simd(XMM.LODUPS, *cast(const void16*)p);
        else
            return cast(V)__simd(XMM.LODDQU, *cast(const void16*)p);
  }

  /*************************************
   * Store vector to unaligned address.
   * This is a compiler intrinsic.
   * Params:
   *    p = pointer to vector
   *    value = value to store
   * Returns:
   *    value
   */

  V storeUnaligned(V)(V* p, V value)
        if (is(V == void16) ||
            is(V == byte16) ||
            is(V == ubyte16) ||
            is(V == short8) ||
            is(V == ushort8) ||
            is(V == int4) ||
            is(V == uint4) ||
            is(V == long2) ||
            is(V == ulong2))
  {
        pragma(inline, true);
        static if (is(V == double2))
            return cast(V)__simd_sto(XMM.STOUPD, *cast(void16*)p, value);
        else static if (is(V == float4))
            return cast(V)__simd_sto(XMM.STOUPS, *cast(void16*)p, value);
        else
            return cast(V)__simd_sto(XMM.STODQU, *cast(void16*)p, value);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          ¥   .   ‘   ..  ¦   	assert_.d   §   	complex.d   ¨   config.d©   ctype.d ª   errno.d «   fenv.d  ¬   float_.d­   
inttypes.d  ®   limits.d¯   locale.d°   math.d  ±   signal.d²   stdarg.d³   stddef.d´   stdint.dµ   stdio.d ¶   stdlib.d·   string.d¸   tgmath.d¹   time.d  º   wchar_.d»  Œwctype.d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_assert.h.html, _assert.h)
 *
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Source:    $(DRUNTIMESRC core/stdc/_assert_.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

/****************************
 * These are the various functions called by the assert() macro.
 * They are all noreturn functions, although D doesn't have a specific attribute for that.
 */

module core.stdc.assert_;

extern (C):
@trusted:
nothrow:
@nogc:

version (CRuntime_DigitalMars)
{
    /***
     * Assert failure function in the Digital Mars C library.
     */
    void _assert(const(void)* exp, const(void)* file, uint line);
}
else version (CRuntime_Microsoft)
{
    /***
     * Assert failure function in the Microsoft C library.
     * `_assert` is not in assert.h, but it is in the library.
     */
    void _wassert(const(wchar)* exp, const(wchar)* file, uint line);
    ///
    void _assert(const(char)* exp, const(char)* file, uint line);
}
else version (OSX)
{
    /***
     * Assert failure function in the OSX C library.
     */
    void __assert_rtn(const(char)* func, const(char)* file, uint line, const(char)* exp);
}
else version (FreeBSD)
{
    /***
     * Assert failure function in the FreeBSD C library.
     */
    void __assert(const(char)* exp, const(char)* file, uint line);
}
else version (NetBSD)
{
    /***
     * Assert failure function in the NetBSD C library.
     */
    void __assert(const(char)* file, int line, const(char)* exp);
}
else version (DragonFlyBSD)
{
    /***
     * Assert failure function in the DragonFlyBSD C library.
     */
    void __assert(const(char)* exp, const(char)* file, uint line);
}
else version (CRuntime_Glibc)
{
    /***
     * Assert failure functions in the GLIBC library.
     */
    void __assert(const(char)* exp, const(char)* file, uint line);
    ///
    void __assert_fail(const(char)* exp, const(char)* file, uint line, const(char)* func);
    ///
    void __assert_perror_fail(int errnum, const(char)* file, uint line, const(char)* func);
}
else version (CRuntime_Bionic)
{
    void __assert(const(char)* __file, int __line, const(char)* __msg);
}
else version (CRuntime_Musl)
{
     /***
     * Assert failure function in the Musl C library.
     */
    void __assert_fail(const(char)* exp, const(char)* file, uint line, const(char)* func);
}
else version (CRuntime_UClibc)
{
    void __assert(const(char)* exp, const(char)* file, uint line, const(char)* func);
}
else version (Solaris)
{
    void __assert_c99(const(char)* exp, const(char)* file, uint line, const(char)* func);
}
else
{
    static assert(0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_complex.h.html, _complex.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_complex.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.complex;

extern (C):
@trusted: // All of these operate on floating point values only.
nothrow:
@nogc:

///
alias creal complex;
///
alias ireal imaginary;
///
cdouble cacos(cdouble z);
///
cfloat  cacosf(cfloat z);
///
creal   cacosl(creal z);

///
cdouble casin(cdouble z);
///
cfloat  casinf(cfloat z);
///
creal   casinl(creal z);

///
cdouble catan(cdouble z);
///
cfloat  catanf(cfloat z);
///
creal   catanl(creal z);

///
cdouble ccos(cdouble z);
///
cfloat  ccosf(cfloat z);
///
creal   ccosl(creal z);

///
cdouble csin(cdouble z);
///
cfloat  csinf(cfloat z);
///
creal   csinl(creal z);

///
cdouble ctan(cdouble z);
///
cfloat  ctanf(cfloat z);
///
creal   ctanl(creal z);

///
cdouble cacosh(cdouble z);
///
cfloat  cacoshf(cfloat z);
///
creal   cacoshl(creal z);

///
cdouble casinh(cdouble z);
///
cfloat  casinhf(cfloat z);
///
creal   casinhl(creal z);

///
cdouble catanh(cdouble z);
///
cfloat  catanhf(cfloat z);
///
creal   catanhl(creal z);

///
cdouble ccosh(cdouble z);
///
cfloat  ccoshf(cfloat z);
///
creal   ccoshl(creal z);

///
cdouble csinh(cdouble z);
///
cfloat  csinhf(cfloat z);
///
creal   csinhl(creal z);

///
cdouble ctanh(cdouble z);
///
cfloat  ctanhf(cfloat z);
///
creal   ctanhl(creal z);

///
cdouble cexp(cdouble z);
///
cfloat  cexpf(cfloat z);
///
creal   cexpl(creal z);

///
cdouble clog(cdouble z);
///
cfloat  clogf(cfloat z);
///
creal   clogl(creal z);

///
 double cabs(cdouble z);
 ///
 float  cabsf(cfloat z);
 ///
 real   cabsl(creal z);

 ///
cdouble cpow(cdouble x, cdouble y);
///
cfloat  cpowf(cfloat x, cfloat y);
///
creal   cpowl(creal x, creal y);

///
cdouble csqrt(cdouble z);
///
cfloat  csqrtf(cfloat z);
///
creal   csqrtl(creal z);

///
 double carg(cdouble z);
 ///
 float  cargf(cfloat z);
 ///
 real   cargl(creal z);

 ///
 double cimag(cdouble z);
 ///
 float  cimagf(cfloat z);
 ///
 real   cimagl(creal z);

 ///
cdouble conj(cdouble z);
///
cfloat  conjf(cfloat z);
///
creal   conjl(creal z);

///
cdouble cproj(cdouble z);
///
cfloat  cprojf(cfloat z);
///
creal   cprojl(creal z);

// double creal(cdouble z);
///
 float  crealf(cfloat z);
 ///
 real   creall(creal z);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /***
 * D compatible types that correspond to various basic types in associated
 * C and C++ compilers.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_config.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

/* NOTE: This file has been patched from the original DMD distribution to
 * work with the GDC compiler.
 */
module core.stdc.config;

version (StdDdoc)
{
    private
    {
        version (Posix)
            enum isPosix = true;
        else
            enum isPosix = false;
        static if (isPosix && (void*).sizeof > int.sizeof)
        {
            alias ddoc_long = long;
            alias ddoc_ulong = ulong;
        }
        else
        {
            alias ddoc_long = int;
            alias ddoc_ulong = uint;
        }
    }

    /***
     * Used for a signed integer type that corresponds in size to the associated
     * C compiler's `long` type.
     */
    alias c_long = ddoc_long;

    /***
     * Used for an unsigned integer type that corresponds in size to the associated
     * C compiler's `unsigned long` type.
     */
    alias c_ulong = ddoc_ulong;

    /***
     * Used for a signed integer type that corresponds in size and mangling to the associated
     * C++ compiler's `long` type.
     */
    alias cpp_long = c_long;

    /***
     * Used for an unsigned integer type that corresponds in size and mangling to the associated
     * C++ compiler's `unsigned long` type.
     */
    alias cpp_ulong = c_ulong;

    /***
     * Used for a signed integer type that corresponds in size and mangling to the associated
     * C++ compiler's `long long` type.
     */
    alias cpp_longlong = long;

    /***
     * Used for an unsigned integer type that corresponds in size and mangling to the associated
     * C++ compiler's `unsigned long long` type.
     */
    alias cpp_ulonglong = ulong;

    /***
     * Used for a floating point type that corresponds in size and mangling to the associated
     * C++ compiler's `long double` type.
     */
    alias c_long_double = real;

    /***
     * Used for an unsigned integer type that corresponds in size and mangling to the associated
     * C++ compiler's `size_t` type.
     */
    alias cpp_size_t = size_t;

    /***
     * Used for a signed integer type that corresponds in size and mangling to the associated
     * C++ compiler's `ptrdiff_t` type.
     */
    alias cpp_ptrdiff_t = ptrdiff_t;
}
else
{

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (GNU)
{
    import gcc.builtins;

    alias __builtin_clong  c_long;
    alias __builtin_culong c_ulong;

    enum __c_long  : __builtin_clong;
    enum __c_ulong : __builtin_culong;

    alias __c_long  cpp_long;
    alias __c_ulong cpp_ulong;

    enum __c_longlong  : __builtin_clonglong;
    enum __c_ulonglong : __builtin_culonglong;

    alias __c_longlong  cpp_longlong;
    alias __c_ulonglong cpp_ulonglong;
}
else version (Windows)
{
    enum __c_long  : int;
    enum __c_ulong : uint;

    alias int   c_long;
    alias uint  c_ulong;

    alias __c_long   cpp_long;
    alias __c_ulong  cpp_ulong;

    alias long  cpp_longlong;
    alias ulong cpp_ulonglong;
}
else version (Posix)
{
  static if ( (void*).sizeof > int.sizeof )
  {
    enum __c_longlong  : long;
    enum __c_ulonglong : ulong;

    alias long  c_long;
    alias ulong c_ulong;

    alias long   cpp_long;
    alias ulong  cpp_ulong;

    alias __c_longlong  cpp_longlong;
    alias __c_ulonglong cpp_ulonglong;
  }
  else
  {
    enum __c_long  : int;
    enum __c_ulong : uint;

    alias int   c_long;
    alias uint  c_ulong;

    alias __c_long   cpp_long;
    alias __c_ulong  cpp_ulong;

    alias long  cpp_longlong;
    alias ulong cpp_ulonglong;
  }
}

version (CRuntime_Microsoft)
{
    /* long double is 64 bits, not 80 bits, but is mangled differently
     * than double. To distinguish double from long double, create a wrapper to represent
     * long double, then recognize that wrapper specially in the compiler
     * to generate the correct name mangling and correct function call/return
     * ABI conformance.
     */
    enum __c_long_double : double;

    alias __c_long_double c_long_double;
}
else version (DigitalMars)
{
    version (X86)
    {
        alias real c_long_double;
    }
    else version (X86_64)
    {
        version (linux)
            alias real c_long_double;
        else version (FreeBSD)
            alias real c_long_double;
        else version (OpenBSD)
            alias real c_long_double;
        else version (NetBSD)
            alias real c_long_double;
        else version (DragonFlyBSD)
            alias real c_long_double;
        else version (Solaris)
            alias real c_long_double;
        else version (Darwin)
            alias real c_long_double;
    }
}
else version (GNU)
    alias real c_long_double;
else version (LDC)
    alias real c_long_double;
else version (SDC)
{
    version (X86)
        alias real c_long_double;
    else version (X86_64)
        alias real c_long_double;
}

static assert(is(c_long_double), "c_long_double needs to be declared for this platform/architecture.");

version (Darwin)
{
    alias cpp_size_t = cpp_ulong;
    version (D_LP64)
        alias cpp_ptrdiff_t = cpp_long;
    else
        alias cpp_ptrdiff_t = ptrdiff_t;
}
else
{
    alias cpp_size_t = size_t;
    alias cpp_ptrdiff_t = ptrdiff_t;
}
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_ctype.h.html, _ctype.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_ctype.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.ctype;

extern (C):
@trusted: // All of these operate on integers only.
nothrow:
@nogc:

    ///
pure int isalnum(int c);
///
pure int isalpha(int c);
///
pure int isblank(int c);
///
pure int iscntrl(int c);
///
pure int isdigit(int c);
///
pure int isgraph(int c);
///
pure int islower(int c);
///
pure int isprint(int c);
///
pure int ispunct(int c);
///
pure int isspace(int c);
///
pure int isupper(int c);
///
pure int isxdigit(int c);
///
pure int tolower(int c);
///
pure int toupper(int c);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_errno.h.html, _errno.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly, Alex RÃ¸nne Petersen
 * Source:    https://github.com/dlang/druntime/blob/master/src/core/stdc/errno.d
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.errno;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (ARM)     version = ARM_Any;
version (AArch64) version = ARM_Any;
version (HPPA)    version = HPPA_Any;
version (MIPS32)  version = MIPS_Any;
version (MIPS64)  version = MIPS_Any;
version (PPC)     version = PPC_Any;
version (PPC64)   version = PPC_Any;
version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;
version (S390)    version = IBMZ_Any;
version (SPARC)   version = SPARC_Any;
version (SPARC64) version = SPARC_Any;
version (SystemZ) version = IBMZ_Any;
version (X86)     version = X86_Any;
version (X86_64)  version = X86_Any;

@trusted: // Only manipulates errno.
nothrow:
@nogc:

version (CRuntime_DigitalMars)
{
    extern (C)
    {
        ref int _errno();
        alias errno = _errno;
    }
}
else version (CRuntime_Microsoft)
{
    extern (C)
    {
        ref int _errno();
        alias errno = _errno;
    }
}
else version (CRuntime_Glibc)
{
    extern (C)
    {
        ref int __errno_location();
        alias errno = __errno_location;
    }
}
else version (CRuntime_Musl)
{
    extern (C)
    {
        ref int __errno_location();
        alias errno = __errno_location;
    }
}
else version (OpenBSD)
{
    // https://github.com/openbsd/src/blob/master/include/errno.h
    extern (C)
    {
        ref int __errno();
        alias errno = __errno;
    }
}
else version (NetBSD)
{
    // https://github.com/NetBSD/src/blob/trunk/include/errno.h
    extern (C)
    {
        ref int __errno();
        alias errno = __errno;
    }
}
else version (FreeBSD)
{
    extern (C)
    {
        ref int __error();
        alias errno = __error;
    }
}
else version (DragonFlyBSD)
{
    extern (C)
    {
        pragma(mangle, "errno") int __errno;
        ref int __error() {
            return __errno;
        }
        alias errno = __error;
    }
}
else version (CRuntime_Bionic)
{
    extern (C)
    {
        ref int __errno();
        alias errno = __errno;
    }
}
else version (CRuntime_UClibc)
{
    extern (C)
    {
        ref int __errno_location();
        alias errno = __errno_location;
    }
}
else version (Darwin)
{
    extern (C)
    {
        ref int __error();
        alias errno = __error;
    }
}
else version (Solaris)
{
    extern (C)
    {
        ref int ___errno();
        alias errno = ___errno;
    }
}
else
{
    ///
    @property int errno() { return getErrno(); }
    ///
    @property int errno(int n) { return setErrno(n); }

    extern (C)
    {
        private int getErrno();      // for internal use
        private int setErrno(int);   // for internal use
    }
}

extern (C):


version (Windows)
{
    enum EPERM              = 1;        /// Operation not permitted
    enum ENOENT             = 2;        /// No such file or directory
    enum ESRCH              = 3;        /// No such process
    enum EINTR              = 4;        /// Interrupted system call
    enum EIO                = 5;        /// I/O error
    enum ENXIO              = 6;        /// No such device or address
    enum E2BIG              = 7;        /// Argument list too long
    enum ENOEXEC            = 8;        /// Exec format error
    enum EBADF              = 9;        /// Bad file number
    enum ECHILD             = 10;       /// No child processes
    enum EAGAIN             = 11;       /// Try again
    enum ENOMEM             = 12;       /// Out of memory
    enum EACCES             = 13;       /// Permission denied
    enum EFAULT             = 14;       /// Bad address
    enum EBUSY              = 16;       /// Device or resource busy
    enum EEXIST             = 17;       /// File exists
    enum EXDEV              = 18;       /// Cross-device link
    enum ENODEV             = 19;       /// No such device
    enum ENOTDIR            = 20;       /// Not a directory
    enum EISDIR             = 21;       /// Is a directory
    enum EINVAL             = 22;       /// Invalid argument
    enum ENFILE             = 23;       /// File table overflow
    enum EMFILE             = 24;       /// Too many open files
    enum ENOTTY             = 25;       /// Not a typewriter
    enum EFBIG              = 27;       /// File too large
    enum ENOSPC             = 28;       /// No space left on device
    enum ESPIPE             = 29;       /// Illegal seek
    enum EROFS              = 30;       /// Read-only file system
    enum EMLINK             = 31;       /// Too many links
    enum EPIPE              = 32;       /// Broken pipe
    enum EDOM               = 33;       /// Math argument out of domain of func
    enum ERANGE             = 34;       /// Math result not representable
    enum EDEADLK            = 36;       /// Resource deadlock would occur
    enum ENAMETOOLONG       = 38;       /// File name too long
    enum ENOLCK             = 39;       /// No record locks available
    enum ENOSYS             = 40;       /// Function not implemented
    enum ENOTEMPTY          = 41;       /// Directory not empty
    enum EILSEQ             = 42;       /// Illegal byte sequence
    enum EDEADLOCK          = EDEADLK;  /// Resource deadlock would occur
}
else version (linux)
{
    enum EPERM              = 1;  ///
    enum ENOENT             = 2;  ///
    enum ESRCH              = 3;  ///
    enum EINTR              = 4;  ///
    enum EIO                = 5;  ///
    enum ENXIO              = 6;  ///
    enum E2BIG              = 7;  ///
    enum ENOEXEC            = 8;  ///
    enum EBADF              = 9;  ///
    enum ECHILD             = 10; ///
    enum EAGAIN             = 11; ///
    enum ENOMEM             = 12; ///
    enum EACCES             = 13; ///
    enum EFAULT             = 14; ///
    enum ENOTBLK            = 15; ///
    enum EBUSY              = 16; ///
    enum EEXIST             = 17; ///
    enum EXDEV              = 18; ///
    enum ENODEV             = 19; ///
    enum ENOTDIR            = 20; ///
    enum EISDIR             = 21; ///
    enum EINVAL             = 22; ///
    enum ENFILE             = 23; ///
    enum EMFILE             = 24; ///
    enum ENOTTY             = 25; ///
    enum ETXTBSY            = 26; ///
    enum EFBIG              = 27; ///
    enum ENOSPC             = 28; ///
    enum ESPIPE             = 29; ///
    enum EROFS              = 30; ///
    enum EMLINK             = 31; ///
    enum EPIPE              = 32; ///
    enum EDOM               = 33; ///
    enum ERANGE             = 34; ///

    version (X86_Any)
    {
        enum EDEADLK            = 35;         ///
        enum ENAMETOOLONG       = 36;         ///
        enum ENOLCK             = 37;         ///
        enum ENOSYS             = 38;         ///
        enum ENOTEMPTY          = 39;         ///
        enum ELOOP              = 40;         ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOMSG             = 42;         ///
        enum EIDRM              = 43;         ///
        enum ECHRNG             = 44;         ///
        enum EL2NSYNC           = 45;         ///
        enum EL3HLT             = 46;         ///
        enum EL3RST             = 47;         ///
        enum ELNRNG             = 48;         ///
        enum EUNATCH            = 49;         ///
        enum ENOCSI             = 50;         ///
        enum EL2HLT             = 51;         ///
        enum EBADE              = 52;         ///
        enum EBADR              = 53;         ///
        enum EXFULL             = 54;         ///
        enum ENOANO             = 55;         ///
        enum EBADRQC            = 56;         ///
        enum EBADSLT            = 57;         ///
        enum EDEADLOCK          = EDEADLK;    ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EMULTIHOP          = 72;         ///
        enum EDOTDOT            = 73;         ///
        enum EBADMSG            = 74;         ///
        enum EOVERFLOW          = 75;         ///
        enum ENOTUNIQ           = 76;         ///
        enum EBADFD             = 77;         ///
        enum EREMCHG            = 78;         ///
        enum ELIBACC            = 79;         ///
        enum ELIBBAD            = 80;         ///
        enum ELIBSCN            = 81;         ///
        enum ELIBMAX            = 82;         ///
        enum ELIBEXEC           = 83;         ///
        enum EILSEQ             = 84;         ///
        enum ERESTART           = 85;         ///
        enum ESTRPIPE           = 86;         ///
        enum EUSERS             = 87;         ///
        enum ENOTSOCK           = 88;         ///
        enum EDESTADDRREQ       = 89;         ///
        enum EMSGSIZE           = 90;         ///
        enum EPROTOTYPE         = 91;         ///
        enum ENOPROTOOPT        = 92;         ///
        enum EPROTONOSUPPORT    = 93;         ///
        enum ESOCKTNOSUPPORT    = 94;         ///
        enum EOPNOTSUPP         = 95;         ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 96;         ///
        enum EAFNOSUPPORT       = 97;         ///
        enum EADDRINUSE         = 98;         ///
        enum EADDRNOTAVAIL      = 99;         ///
        enum ENETDOWN           = 100;        ///
        enum ENETUNREACH        = 101;        ///
        enum ENETRESET          = 102;        ///
        enum ECONNABORTED       = 103;        ///
        enum ECONNRESET         = 104;        ///
        enum ENOBUFS            = 105;        ///
        enum EISCONN            = 106;        ///
        enum ENOTCONN           = 107;        ///
        enum ESHUTDOWN          = 108;        ///
        enum ETOOMANYREFS       = 109;        ///
        enum ETIMEDOUT          = 110;        ///
        enum ECONNREFUSED       = 111;        ///
        enum EHOSTDOWN          = 112;        ///
        enum EHOSTUNREACH       = 113;        ///
        enum EALREADY           = 114;        ///
        enum EINPROGRESS        = 115;        ///
        enum ESTALE             = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EDQUOT             = 122;        ///
        enum ENOMEDIUM          = 123;        ///
        enum EMEDIUMTYPE        = 124;        ///
        enum ECANCELED          = 125;        ///
        enum ENOKEY             = 126;        ///
        enum EKEYEXPIRED        = 127;        ///
        enum EKEYREVOKED        = 128;        ///
        enum EKEYREJECTED       = 129;        ///
        enum EOWNERDEAD         = 130;        ///
        enum ENOTRECOVERABLE    = 131;        ///
        enum ERFKILL            = 132;        ///
        enum EHWPOISON          = 133;        ///
    }
    else version (ARM_Any)
    {
        enum EDEADLK            = 35;         ///
        enum ENAMETOOLONG       = 36;         ///
        enum ENOLCK             = 37;         ///
        enum ENOSYS             = 38;         ///
        enum ENOTEMPTY          = 39;         ///
        enum ELOOP              = 40;         ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOMSG             = 42;         ///
        enum EIDRM              = 43;         ///
        enum ECHRNG             = 44;         ///
        enum EL2NSYNC           = 45;         ///
        enum EL3HLT             = 46;         ///
        enum EL3RST             = 47;         ///
        enum ELNRNG             = 48;         ///
        enum EUNATCH            = 49;         ///
        enum ENOCSI             = 50;         ///
        enum EL2HLT             = 51;         ///
        enum EBADE              = 52;         ///
        enum EBADR              = 53;         ///
        enum EXFULL             = 54;         ///
        enum ENOANO             = 55;         ///
        enum EBADRQC            = 56;         ///
        enum EBADSLT            = 57;         ///
        enum EDEADLOCK          = EDEADLK;    ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EMULTIHOP          = 72;         ///
        enum EDOTDOT            = 73;         ///
        enum EBADMSG            = 74;         ///
        enum EOVERFLOW          = 75;         ///
        enum ENOTUNIQ           = 76;         ///
        enum EBADFD             = 77;         ///
        enum EREMCHG            = 78;         ///
        enum ELIBACC            = 79;         ///
        enum ELIBBAD            = 80;         ///
        enum ELIBSCN            = 81;         ///
        enum ELIBMAX            = 82;         ///
        enum ELIBEXEC           = 83;         ///
        enum EILSEQ             = 84;         ///
        enum ERESTART           = 85;         ///
        enum ESTRPIPE           = 86;         ///
        enum EUSERS             = 87;         ///
        enum ENOTSOCK           = 88;         ///
        enum EDESTADDRREQ       = 89;         ///
        enum EMSGSIZE           = 90;         ///
        enum EPROTOTYPE         = 91;         ///
        enum ENOPROTOOPT        = 92;         ///
        enum EPROTONOSUPPORT    = 93;         ///
        enum ESOCKTNOSUPPORT    = 94;         ///
        enum EOPNOTSUPP         = 95;         ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 96;         ///
        enum EAFNOSUPPORT       = 97;         ///
        enum EADDRINUSE         = 98;         ///
        enum EADDRNOTAVAIL      = 99;         ///
        enum ENETDOWN           = 100;        ///
        enum ENETUNREACH        = 101;        ///
        enum ENETRESET          = 102;        ///
        enum ECONNABORTED       = 103;        ///
        enum ECONNRESET         = 104;        ///
        enum ENOBUFS            = 105;        ///
        enum EISCONN            = 106;        ///
        enum ENOTCONN           = 107;        ///
        enum ESHUTDOWN          = 108;        ///
        enum ETOOMANYREFS       = 109;        ///
        enum ETIMEDOUT          = 110;        ///
        enum ECONNREFUSED       = 111;        ///
        enum EHOSTDOWN          = 112;        ///
        enum EHOSTUNREACH       = 113;        ///
        enum EALREADY           = 114;        ///
        enum EINPROGRESS        = 115;        ///
        enum ESTALE             = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EDQUOT             = 122;        ///
        enum ENOMEDIUM          = 123;        ///
        enum EMEDIUMTYPE        = 124;        ///
        enum ECANCELED          = 125;        ///
        enum ENOKEY             = 126;        ///
        enum EKEYEXPIRED        = 127;        ///
        enum EKEYREVOKED        = 128;        ///
        enum EKEYREJECTED       = 129;        ///
        enum EOWNERDEAD         = 130;        ///
        enum ENOTRECOVERABLE    = 131;        ///
        enum ERFKILL            = 132;        ///
        enum EHWPOISON          = 133;        ///
    }
    else version (HPPA_Any)
    {
        enum ENOMSG             = 35;         ///
        enum EIDRM              = 36;         ///
        enum ECHRNG             = 37;         ///
        enum EL2NSYNC           = 38;         ///
        enum EL3HLT             = 39;         ///
        enum EL3RST             = 40;         ///
        enum ELNRNG             = 41;         ///
        enum EUNATCH            = 42;         ///
        enum ENOCSI             = 43;         ///
        enum EL2HLT             = 44;         ///
        enum EDEADLK            = 45;         ///
        enum EDEADLOCK          = EDEADLK;    ///
        enum ENOLCK             = 46;         ///
        enum EILSEQ             = 47;         ///
        enum ENONET             = 50;         ///
        enum ENODATA            = 51;         ///
        enum ETIME              = 52;         ///
        enum ENOSR              = 53;         ///
        enum ENOSTR             = 54;         ///
        enum ENOPKG             = 55;         ///
        enum ENOLINK            = 57;         ///
        enum EADV               = 58;         ///
        enum ESRMNT             = 59;         ///
        enum ECOMM              = 60;         ///
        enum EPROTO             = 61;         ///
        enum EMULTIHOP          = 64;         ///
        enum EDOTDOT            = 66;         ///
        enum EBADMSG            = 67;         ///
        enum EUSERS             = 68;         ///
        enum EDQUOT             = 69;         ///
        enum ESTALE             = 70;         ///
        enum EREMOTE            = 71;         ///
        enum EOVERFLOW          = 72;         ///
        enum EBADE              = 160;        ///
        enum EBADR              = 161;        ///
        enum EXFULL             = 162;        ///
        enum ENOANO             = 163;        ///
        enum EBADRQC            = 164;        ///
        enum EBADSLT            = 165;        ///
        enum EBFONT             = 166;        ///
        enum ENOTUNIQ           = 167;        ///
        enum EBADFD             = 168;        ///
        enum EREMCHG            = 169;        ///
        enum ELIBACC            = 170;        ///
        enum ELIBBAD            = 171;        ///
        enum ELIBSCN            = 172;        ///
        enum ELIBMAX            = 173;        ///
        enum ELIBEXEC           = 174;        ///
        enum ERESTART           = 175;        ///
        enum ESTRPIPE           = 176;        ///
        enum EUCLEAN            = 177;        ///
        enum ENOTNAM            = 178;        ///
        enum ENAVAIL            = 179;        ///
        enum EISNAM             = 180;        ///
        enum EREMOTEIO          = 181;        ///
        enum ENOMEDIUM          = 182;        ///
        enum EMEDIUMTYPE        = 183;        ///
        enum ENOKEY             = 184;        ///
        enum EKEYEXPIRED        = 185;        ///
        enum EKEYREVOKED        = 186;        ///
        enum EKEYREJECTED       = 187;        ///
        enum ENOSYM             = 215;        ///
        enum ENOTSOCK           = 216;        ///
        enum EDESTADDRREQ       = 217;        ///
        enum EMSGSIZE           = 218;        ///
        enum EPROTOTYPE         = 219;        ///
        enum ENOPROTOOPT        = 220;        ///
        enum EPROTONOSUPPORT    = 221;        ///
        enum ESOCKTNOSUPPORT    = 221;        ///
        enum EOPNOTSUPP         = 223;        ///
        enum EPFNOSUPPORT       = 224;        ///
        enum EAFNOSUPPORT       = 225;        ///
        enum EADDRINUSE         = 226;        ///
        enum EADDRNOTAVAIL      = 227;        ///
        enum ENETDOWN           = 228;        ///
        enum ENETUNREACH        = 229;        ///
        enum ENETRESET          = 230;        ///
        enum ECONNABORTED       = 231;        ///
        enum ECONNRESET         = 232;        ///
        enum ENOBUFS            = 233;        ///
        enum EISCONN            = 234;        ///
        enum ENOTCONN           = 235;        ///
        enum ESHUTDOWN          = 236;        ///
        enum ETOOMANYREFS       = 237;        ///
        enum ETIMEDOUT          = 238;        ///
        enum ECONNREFUSED       = 239;        ///
        enum EREFUSED           = ECONNREFUSED; ///
        enum EREMOTERELEASE     = 240;        ///
        enum EHOSTDOWN          = 241;        ///
        enum EHOSTUNREACH       = 242;        ///
        enum EALREADY           = 244;        ///
        enum EINPROGRESS        = 245;        ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOTEMPTY          = 247;        ///
        enum ENAMETOOLONG       = 248;        ///
        enum ELOOP              = 249;        ///
        enum ENOSYS             = 251;        ///
        enum ECANCELLED         = 253;        ///
        enum ECANCELED          = ECANCELLED;  ///
        enum EOWNERDEAD         = 254;        ///
        enum ENOTRECOVERABLE    = 255;        ///
        enum ERFKILL            = 256;        ///
        enum EHWPOISON          = 257;        ///
    }
    else version (MIPS_Any)
    {
        enum ENOMSG             = 35;         ///
        enum EIDRM              = 36;         ///
        enum ECHRNG             = 37;         ///
        enum EL2NSYNC           = 38;         ///
        enum EL3HLT             = 39;         ///
        enum EL3RST             = 40;         ///
        enum ELNRNG             = 41;         ///
        enum EUNATCH            = 42;         ///
        enum ENOCSI             = 43;         ///
        enum EL2HLT             = 44;         ///
        enum EDEADLK            = 45;         ///
        enum ENOLCK             = 46;         ///
        enum EBADE              = 50;         ///
        enum EBADR              = 51;         ///
        enum EXFULL             = 52;         ///
        enum ENOANO             = 53;         ///
        enum EBADRQC            = 54;         ///
        enum EBADSLT            = 55;         ///
        enum EDEADLOCK          = 56;         ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EDOTDOT            = 73;         ///
        enum EMULTIHOP          = 74;         ///
        enum EBADMSG            = 77;         ///
        enum ENAMETOOLONG       = 78;         ///
        enum EOVERFLOW          = 79;         ///
        enum ENOTUNIQ           = 80;         ///
        enum EBADFD             = 81;         ///
        enum EREMCHG            = 82;         ///
        enum ELIBACC            = 83;         ///
        enum ELIBBAD            = 84;         ///
        enum ELIBSCN            = 85;         ///
        enum ELIBMAX            = 86;         ///
        enum ELIBEXEC           = 87;         ///
        enum EILSEQ             = 88;         ///
        enum ENOSYS             = 89;         ///
        enum ELOOP              = 90;         ///
        enum ERESTART           = 91;         ///
        enum ESTRPIPE           = 92;         ///
        enum ENOTEMPTY          = 93;         ///
        enum EUSERS             = 94;         ///
        enum ENOTSOCK           = 95;         ///
        enum EDESTADDRREQ       = 96;         ///
        enum EMSGSIZE           = 97;         ///
        enum EPROTOTYPE         = 98;         ///
        enum ENOPROTOOPT        = 99;         ///
        enum EPROTONOSUPPORT    = 120;        ///
        enum ESOCKTNOSUPPORT    = 121;        ///
        enum EOPNOTSUPP         = 122;        ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 123;        ///
        enum EAFNOSUPPORT       = 124;        ///
        enum EADDRINUSE         = 125;        ///
        enum EADDRNOTAVAIL      = 126;        ///
        enum ENETDOWN           = 127;        ///
        enum ENETUNREACH        = 128;        ///
        enum ENETRESET          = 129;        ///
        enum ECONNABORTED       = 130;        ///
        enum ECONNRESET         = 131;        ///
        enum ENOBUFS            = 132;        ///
        enum EISCONN            = 133;        ///
        enum ENOTCONN           = 134;        ///
        enum EUCLEAN            = 135;        ///
        enum ENOTNAM            = 137;        ///
        enum ENAVAIL            = 138;        ///
        enum EISNAM             = 139;        ///
        enum EREMOTEIO          = 140;        ///
        enum EINIT              = 141;        ///
        enum EREMDEV            = 142;        ///
        enum ESHUTDOWN          = 143;        ///
        enum ETOOMANYREFS       = 144;        ///
        enum ETIMEDOUT          = 145;        ///
        enum ECONNREFUSED       = 146;        ///
        enum EHOSTDOWN          = 147;        ///
        enum EHOSTUNREACH       = 148;        ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum EALREADY           = 149;        ///
        enum EINPROGRESS        = 150;        ///
        enum ESTALE             = 151;        ///
        enum ECANCELED          = 158;        ///
        enum ENOMEDIUM          = 159;        ///
        enum EMEDIUMTYPE        = 160;        ///
        enum ENOKEY             = 161;        ///
        enum EKEYEXPIRED        = 162;        ///
        enum EKEYREVOKED        = 163;        ///
        enum EKEYREJECTED       = 164;        ///
        enum EOWNERDEAD         = 165;        ///
        enum ENOTRECOVERABLE    = 166;        ///
        enum ERFKILL            = 167;        ///
        enum EHWPOISON          = 168;        ///
        enum EDQUOT             = 1133;       ///
    }
    else version (PPC_Any)
    {
        enum EDEADLK            = 35;         ///
        enum ENAMETOOLONG       = 36;         ///
        enum ENOLCK             = 37;         ///
        enum ENOSYS             = 38;         ///
        enum ENOTEMPTY          = 39;         ///
        enum ELOOP              = 40;         ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOMSG             = 42;         ///
        enum EIDRM              = 43;         ///
        enum ECHRNG             = 44;         ///
        enum EL2NSYNC           = 45;         ///
        enum EL3HLT             = 46;         ///
        enum EL3RST             = 47;         ///
        enum ELNRNG             = 48;         ///
        enum EUNATCH            = 49;         ///
        enum ENOCSI             = 50;         ///
        enum EL2HLT             = 51;         ///
        enum EBADE              = 52;         ///
        enum EBADR              = 53;         ///
        enum EXFULL             = 54;         ///
        enum ENOANO             = 55;         ///
        enum EBADRQC            = 56;         ///
        enum EBADSLT            = 57;         ///
        enum EDEADLOCK          = 58;         ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EMULTIHOP          = 72;         ///
        enum EDOTDOT            = 73;         ///
        enum EBADMSG            = 74;         ///
        enum EOVERFLOW          = 75;         ///
        enum ENOTUNIQ           = 76;         ///
        enum EBADFD             = 77;         ///
        enum EREMCHG            = 78;         ///
        enum ELIBACC            = 79;         ///
        enum ELIBBAD            = 80;         ///
        enum ELIBSCN            = 81;         ///
        enum ELIBMAX            = 82;         ///
        enum ELIBEXEC           = 83;         ///
        enum EILSEQ             = 84;         ///
        enum ERESTART           = 85;         ///
        enum ESTRPIPE           = 86;         ///
        enum EUSERS             = 87;         ///
        enum ENOTSOCK           = 88;         ///
        enum EDESTADDRREQ       = 89;         ///
        enum EMSGSIZE           = 90;         ///
        enum EPROTOTYPE         = 91;         ///
        enum ENOPROTOOPT        = 92;         ///
        enum EPROTONOSUPPORT    = 93;         ///
        enum ESOCKTNOSUPPORT    = 94;         ///
        enum EOPNOTSUPP         = 95;         ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 96;         ///
        enum EAFNOSUPPORT       = 97;         ///
        enum EADDRINUSE         = 98;         ///
        enum EADDRNOTAVAIL      = 99;         ///
        enum ENETDOWN           = 100;        ///
        enum ENETUNREACH        = 101;        ///
        enum ENETRESET          = 102;        ///
        enum ECONNABORTED       = 103;        ///
        enum ECONNRESET         = 104;        ///
        enum ENOBUFS            = 105;        ///
        enum EISCONN            = 106;        ///
        enum ENOTCONN           = 107;        ///
        enum ESHUTDOWN          = 108;        ///
        enum ETOOMANYREFS       = 109;        ///
        enum ETIMEDOUT          = 110;        ///
        enum ECONNREFUSED       = 111;        ///
        enum EHOSTDOWN          = 112;        ///
        enum EHOSTUNREACH       = 113;        ///
        enum EALREADY           = 114;        ///
        enum EINPROGRESS        = 115;        ///
        enum ESTALE             = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EDQUOT             = 122;        ///
        enum ENOMEDIUM          = 123;        ///
        enum EMEDIUMTYPE        = 124;        ///
        enum ECANCELED          = 125;        ///
        enum ENOKEY             = 126;        ///
        enum EKEYEXPIRED        = 127;        ///
        enum EKEYREVOKED        = 128;        ///
        enum EKEYREJECTED       = 129;        ///
        enum EOWNERDEAD         = 130;        ///
        enum ENOTRECOVERABLE    = 131;        ///
        enum ERFKILL            = 132;        ///
        enum EHWPOISON          = 133;        ///
    }
    else version (RISCV_Any)
    {
        enum EDEADLK            = 35;         ///
        enum ENAMETOOLONG       = 36;         ///
        enum ENOLCK             = 37;         ///
        enum ENOSYS             = 38;         ///
        enum ENOTEMPTY          = 39;         ///
        enum ELOOP              = 40;         ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOMSG             = 42;         ///
        enum EIDRM              = 43;         ///
        enum ECHRNG             = 44;         ///
        enum EL2NSYNC           = 45;         ///
        enum EL3HLT             = 46;         ///
        enum EL3RST             = 47;         ///
        enum ELNRNG             = 48;         ///
        enum EUNATCH            = 49;         ///
        enum ENOCSI             = 50;         ///
        enum EL2HLT             = 51;         ///
        enum EBADE              = 52;         ///
        enum EBADR              = 53;         ///
        enum EXFULL             = 54;         ///
        enum ENOANO             = 55;         ///
        enum EBADRQC            = 56;         ///
        enum EBADSLT            = 57;         ///
        enum EDEADLOCK          = EDEADLK;    ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EMULTIHOP          = 72;         ///
        enum EDOTDOT            = 73;         ///
        enum EBADMSG            = 74;         ///
        enum EOVERFLOW          = 75;         ///
        enum ENOTUNIQ           = 76;         ///
        enum EBADFD             = 77;         ///
        enum EREMCHG            = 78;         ///
        enum ELIBACC            = 79;         ///
        enum ELIBBAD            = 80;         ///
        enum ELIBSCN            = 81;         ///
        enum ELIBMAX            = 82;         ///
        enum ELIBEXEC           = 83;         ///
        enum EILSEQ             = 84;         ///
        enum ERESTART           = 85;         ///
        enum ESTRPIPE           = 86;         ///
        enum EUSERS             = 87;         ///
        enum ENOTSOCK           = 88;         ///
        enum EDESTADDRREQ       = 89;         ///
        enum EMSGSIZE           = 90;         ///
        enum EPROTOTYPE         = 91;         ///
        enum ENOPROTOOPT        = 92;         ///
        enum EPROTONOSUPPORT    = 93;         ///
        enum ESOCKTNOSUPPORT    = 94;         ///
        enum EOPNOTSUPP         = 95;         ///
        enum EPFNOSUPPORT       = 96;         ///
        enum EAFNOSUPPORT       = 97;         ///
        enum EADDRINUSE         = 98;         ///
        enum EADDRNOTAVAIL      = 99;         ///
        enum ENETDOWN           = 100;        ///
        enum ENETUNREACH        = 101;        ///
        enum ENETRESET          = 102;        ///
        enum ECONNABORTED       = 103;        ///
        enum ECONNRESET         = 104;        ///
        enum ENOBUFS            = 105;        ///
        enum EISCONN            = 106;        ///
        enum ENOTCONN           = 107;        ///
        enum ESHUTDOWN          = 108;        ///
        enum ETOOMANYREFS       = 109;        ///
        enum ETIMEDOUT          = 110;        ///
        enum ECONNREFUSED       = 111;        ///
        enum EHOSTDOWN          = 112;        ///
        enum EHOSTUNREACH       = 113;        ///
        enum EALREADY           = 114;        ///
        enum EINPROGRESS        = 115;        ///
        enum ESTALE             = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EDQUOT             = 122;        ///
        enum ENOMEDIUM          = 123;        ///
        enum EMEDIUMTYPE        = 124;        ///
        enum ECANCELED          = 125;        ///
        enum ENOKEY             = 126;        ///
        enum EKEYEXPIRED        = 127;        ///
        enum EKEYREVOKED        = 128;        ///
        enum EKEYREJECTED       = 129;        ///
        enum EOWNERDEAD         = 130;        ///
        enum ENOTRECOVERABLE    = 131;        ///
        enum ERFKILL            = 132;        ///
        enum EHWPOISON          = 133;        ///
    }
    else version (SPARC_Any)
    {
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum EINPROGRESS        = 36;         ///
        enum EALREADY           = 37;         ///
        enum ENOTSOCK           = 38;         ///
        enum EDESTADDRREQ       = 39;         ///
        enum EMSGSIZE           = 40;         ///
        enum EPROTOTYPE         = 41;         ///
        enum ENOPROTOOPT        = 42;         ///
        enum EPROTONOSUPPORT    = 43;         ///
        enum ESOCKTNOSUPPORT    = 44;         ///
        enum EOPNOTSUPP         = 45;         ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 46;         ///
        enum EAFNOSUPPORT       = 47;         ///
        enum EADDRINUSE         = 48;         ///
        enum EADDRNOTAVAIL      = 49;         ///
        enum ENETDOWN           = 50;         ///
        enum ENETUNREACH        = 51;         ///
        enum ENETRESET          = 52;         ///
        enum ECONNABORTED       = 53;         ///
        enum ECONNRESET         = 54;         ///
        enum ENOBUFS            = 55;         ///
        enum EISCONN            = 56;         ///
        enum ENOTCONN           = 57;         ///
        enum ESHUTDOWN          = 58;         ///
        enum ETOOMANYREFS       = 59;         ///
        enum ETIMEDOUT          = 60;         ///
        enum ECONNREFUSED       = 61;         ///
        enum ELOOP              = 62;         ///
        enum ENAMETOOLONG       = 63;         ///
        enum EHOSTDOWN          = 64;         ///
        enum EHOSTUNREACH       = 65;         ///
        enum ENOTEMPTY          = 66;         ///
        enum EPROCLIM           = 67;         ///
        enum EUSERS             = 68;         ///
        enum EDQUOT             = 69;         ///
        enum ESTALE             = 70;         ///
        enum EREMOTE            = 71;         ///
        enum ENOSTR             = 72;         ///
        enum ETIME              = 73;         ///
        enum ENOSR              = 74;         ///
        enum ENOMSG             = 75;         ///
        enum EBADMSG            = 76;         ///
        enum EIDRM              = 77;         ///
        enum EDEADLK            = 78;         ///
        enum ENOLCK             = 79;         ///
        enum ENONET             = 80;         ///
        enum ERREMOTE           = 81;         ///
        enum ENOLINK            = 82;         ///
        enum EADV               = 83;         ///
        enum ESRMNT             = 84;         ///
        enum ECOMM              = 85;         ///
        enum EPROTO             = 86;         ///
        enum EMULTIHOP          = 87;         ///
        enum EDOTDOT            = 88;         ///
        enum EREMCHG            = 89;         ///
        enum ENOSYS             = 90;         ///
        enum ESTRPIPE           = 91;         ///
        enum EOVERFLOW          = 92;         ///
        enum EBADFD             = 93;         ///
        enum ECHRNG             = 94;         ///
        enum EL2NSYNC           = 95;         ///
        enum EL3HLT             = 96;         ///
        enum EL3RST             = 97;         ///
        enum ELNRNG             = 98;         ///
        enum EUNATCH            = 99;         ///
        enum ENOCSI             = 100;        ///
        enum EL2HLT             = 101;        ///
        enum EBADE              = 102;        ///
        enum EBADR              = 103;        ///
        enum EXFULL             = 104;        ///
        enum ENOANO             = 105;        ///
        enum EBADRQC            = 106;        ///
        enum EBADSLT            = 107;        ///
        enum EDEADLOCK          = 108;        ///
        enum EBFONT             = 109;        ///
        enum ELIBEXEC           = 110;        ///
        enum ENODATA            = 111;        ///
        enum ELIBBAD            = 112;        ///
        enum ENOPKG             = 113;        ///
        enum ELIBACC            = 114;        ///
        enum ENOTUNIQ           = 115;        ///
        enum ERESTART           = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EILSEQ             = 122;        ///
        enum ELIBMAX            = 123;        ///
        enum ELIBSCN            = 124;        ///
        enum ENOMEDIUM          = 125;        ///
        enum EMEDIUMTYPE        = 126;        ///
        enum ECANCELED          = 127;        ///
        enum ENOKEY             = 128;        ///
        enum EKEYEXPIRED        = 129;        ///
        enum EKEYREVOKED        = 130;        ///
        enum EKEYREJECTED       = 131;        ///
        enum EOWNERDEAD         = 132;        ///
        enum ENOTRECOVERABLE    = 133;        ///
        enum ERFKILL            = 134;        ///
        enum EHWPOISON          = 135;        ///
    }
    else version (IBMZ_Any)
    {
        enum EDEADLK            = 35;         ///
        enum ENAMETOOLONG       = 36;         ///
        enum ENOLCK             = 37;         ///
        enum ENOSYS             = 38;         ///
        enum ENOTEMPTY          = 39;         ///
        enum ELOOP              = 40;         ///
        enum EWOULDBLOCK        = EAGAIN;     ///
        enum ENOMSG             = 42;         ///
        enum EIDRM              = 43;         ///
        enum ECHRNG             = 44;         ///
        enum EL2NSYNC           = 45;         ///
        enum EL3HLT             = 46;         ///
        enum EL3RST             = 47;         ///
        enum ELNRNG             = 48;         ///
        enum EUNATCH            = 49;         ///
        enum ENOCSI             = 50;         ///
        enum EL2HLT             = 51;         ///
        enum EBADE              = 52;         ///
        enum EBADR              = 53;         ///
        enum EXFULL             = 54;         ///
        enum ENOANO             = 55;         ///
        enum EBADRQC            = 56;         ///
        enum EBADSLT            = 57;         ///
        enum EDEADLOCK          = EDEADLK;    ///
        enum EBFONT             = 59;         ///
        enum ENOSTR             = 60;         ///
        enum ENODATA            = 61;         ///
        enum ETIME              = 62;         ///
        enum ENOSR              = 63;         ///
        enum ENONET             = 64;         ///
        enum ENOPKG             = 65;         ///
        enum EREMOTE            = 66;         ///
        enum ENOLINK            = 67;         ///
        enum EADV               = 68;         ///
        enum ESRMNT             = 69;         ///
        enum ECOMM              = 70;         ///
        enum EPROTO             = 71;         ///
        enum EMULTIHOP          = 72;         ///
        enum EDOTDOT            = 73;         ///
        enum EBADMSG            = 74;         ///
        enum EOVERFLOW          = 75;         ///
        enum ENOTUNIQ           = 76;         ///
        enum EBADFD             = 77;         ///
        enum EREMCHG            = 78;         ///
        enum ELIBACC            = 79;         ///
        enum ELIBBAD            = 80;         ///
        enum ELIBSCN            = 81;         ///
        enum ELIBMAX            = 82;         ///
        enum ELIBEXEC           = 83;         ///
        enum EILSEQ             = 84;         ///
        enum ERESTART           = 85;         ///
        enum ESTRPIPE           = 86;         ///
        enum EUSERS             = 87;         ///
        enum ENOTSOCK           = 88;         ///
        enum EDESTADDRREQ       = 89;         ///
        enum EMSGSIZE           = 90;         ///
        enum EPROTOTYPE         = 91;         ///
        enum ENOPROTOOPT        = 92;         ///
        enum EPROTONOSUPPORT    = 93;         ///
        enum ESOCKTNOSUPPORT    = 94;         ///
        enum EOPNOTSUPP         = 95;         ///
        enum ENOTSUP            = EOPNOTSUPP; ///
        enum EPFNOSUPPORT       = 96;         ///
        enum EAFNOSUPPORT       = 97;         ///
        enum EADDRINUSE         = 98;         ///
        enum EADDRNOTAVAIL      = 99;         ///
        enum ENETDOWN           = 100;        ///
        enum ENETUNREACH        = 101;        ///
        enum ENETRESET          = 102;        ///
        enum ECONNABORTED       = 103;        ///
        enum ECONNRESET         = 104;        ///
        enum ENOBUFS            = 105;        ///
        enum EISCONN            = 106;        ///
        enum ENOTCONN           = 107;        ///
        enum ESHUTDOWN          = 108;        ///
        enum ETOOMANYREFS       = 109;        ///
        enum ETIMEDOUT          = 110;        ///
        enum ECONNREFUSED       = 111;        ///
        enum EHOSTDOWN          = 112;        ///
        enum EHOSTUNREACH       = 113;        ///
        enum EALREADY           = 114;        ///
        enum EINPROGRESS        = 115;        ///
        enum ESTALE             = 116;        ///
        enum EUCLEAN            = 117;        ///
        enum ENOTNAM            = 118;        ///
        enum ENAVAIL            = 119;        ///
        enum EISNAM             = 120;        ///
        enum EREMOTEIO          = 121;        ///
        enum EDQUOT             = 122;        ///
        enum ENOMEDIUM          = 123;        ///
        enum EMEDIUMTYPE        = 124;        ///
        enum ECANCELED          = 125;        ///
        enum ENOKEY             = 126;        ///
        enum EKEYEXPIRED        = 127;        ///
        enum EKEYREVOKED        = 128;        ///
        enum EKEYREJECTED       = 129;        ///
        enum EOWNERDEAD         = 130;        ///
        enum ENOTRECOVERABLE    = 131;        ///
        enum ERFKILL            = 132;        ///
        enum EHWPOISON          = 133;        ///
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else version (Darwin)
{
    enum EPERM              = 1;        /// Operation not permitted
    enum ENOENT             = 2;        /// No such file or directory
    enum ESRCH              = 3;        /// No such process
    enum EINTR              = 4;        /// Interrupted system call
    enum EIO                = 5;        /// Input/output error
    enum ENXIO              = 6;        /// Device not configured
    enum E2BIG              = 7;        /// Argument list too long
    enum ENOEXEC            = 8;        /// Exec format error
    enum EBADF              = 9;        /// Bad file descriptor
    enum ECHILD             = 10;       /// No child processes
    enum EDEADLK            = 11;       /// Resource deadlock avoided
    enum ENOMEM             = 12;       /// Cannot allocate memory
    enum EACCES             = 13;       /// Permission denied
    enum EFAULT             = 14;       /// Bad address
    enum EBUSY              = 16;       /// Device busy
    enum EEXIST             = 17;       /// File exists
    enum EXDEV              = 18;       /// Cross-device link
    enum ENODEV             = 19;       /// Operation not supported by device
    enum ENOTDIR            = 20;       /// Not a directory
    enum EISDIR             = 21;       /// Is a directory
    enum EINVAL             = 22;       /// Invalid argume–+  —+  ˜+  ™+  š+  ›+  œ+  +                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  nt
    enum ENFILE             = 23;       /// Too many open files in system
    enum EMFILE             = 24;       /// Too many open files
    enum ENOTTY             = 25;       /// Inappropriate ioctl for device
    enum ETXTBSY            = 26;       /// Text file busy
    enum EFBIG              = 27;       /// File too large
    enum ENOSPC             = 28;       /// No space left on device
    enum ESPIPE             = 29;       /// Illegal seek
    enum EROFS              = 30;       /// Read-only file system
    enum EMLINK             = 31;       /// Too many links
    enum EPIPE              = 32;       /// Broken pipe
    enum EDOM               = 33;       /// Numerical argument out of domain
    enum ERANGE             = 34;       /// Result too large
    enum EAGAIN             = 35;       /// Resource temporarily unavailable
    enum EWOULDBLOCK        = EAGAIN;   /// Operation would block
    enum EINPROGRESS        = 36;       /// Operation now in progress
    enum EALREADY           = 37;       /// Operation already in progress
    enum ENOTSOCK           = 38;       /// Socket operation on non-socket
    enum EDESTADDRREQ       = 39;       /// Destination address required
    enum EMSGSIZE           = 40;       /// Message too long
    enum EPROTOTYPE         = 41;       /// Protocol wrong type for socket
    enum ENOPROTOOPT        = 42;       /// Protocol not available
    enum EPROTONOSUPPORT    = 43;       /// Protocol not supported
    enum ENOTSUP            = 45;       /// Operation not supported
    enum EOPNOTSUPP         = ENOTSUP;  /// Operation not supported on socket
    enum EAFNOSUPPORT       = 47;       /// Address family not supported by protocol family
    enum EADDRINUSE         = 48;       /// Address already in use
    enum EADDRNOTAVAIL      = 49;       /// Can't assign requested address
    enum ENETDOWN           = 50;       /// Network is down
    enum ENETUNREACH        = 51;       /// Network is unreachable
    enum ENETRESET          = 52;       /// Network dropped connection on reset
    enum ECONNABORTED       = 53;       /// Software caused connection abort
    enum ECONNRESET         = 54;       /// Connection reset by peer
    enum ENOBUFS            = 55;       /// No buffer space available
    enum EISCONN            = 56;       /// Socket is already connected
    enum ENOTCONN           = 57;       /// Socket is not connected
    enum ETIMEDOUT          = 60;       /// Operation timed out
    enum ECONNREFUSED       = 61;       /// Connection refused
    enum ELOOP              = 62;       /// Too many levels of symbolic links
    enum ENAMETOOLONG       = 63;       /// File name too long
    enum EHOSTUNREACH       = 65;       /// No route to host
    enum ENOTEMPTY          = 66;       /// Directory not empty
    enum EDQUOT             = 69;       /// Disc quota exceeded
    enum ESTALE             = 70;       /// Stale NFS file handle
    enum ENOLCK             = 77;       /// No locks available
    enum ENOSYS             = 78;       /// Function not implemented
    enum EOVERFLOW          = 84;       /// Value too large to be stored in data type
    enum ECANCELED          = 89;       /// Operation canceled
    enum EIDRM              = 90;       /// Identifier removed
    enum ENOMSG             = 91;       /// No message of desired type
    enum EILSEQ             = 92;       /// Illegal byte sequence
    enum EBADMSG            = 94;       /// Bad message
    enum EMULTIHOP          = 95;       /// Reserved
    enum ENODATA            = 96;       /// No message available on STREAM
    enum ENOLINK            = 97;       /// Reserved
    enum ENOSR              = 98;       /// No STREAM resources
    enum ENOSTR             = 99;       /// Not a STREAM
    enum EPROTO             = 100;      /// Protocol error
    enum ETIME              = 101;      /// STREAM ioctl timeout
    enum ELAST              = 101;      /// Must be equal largest errno
}
else version (FreeBSD)
{
    enum EPERM              = 1;        /// Operation not permitted
    enum ENOENT             = 2;        /// No such file or directory
    enum ESRCH              = 3;        /// No such process
    enum EINTR              = 4;        /// Interrupted system call
    enum EIO                = 5;        /// Input/output error
    enum ENXIO              = 6;        /// Device not configured
    enum E2BIG              = 7;        /// Argument list too long
    enum ENOEXEC            = 8;        /// Exec format error
    enum EBADF              = 9;        /// Bad file descriptor
    enum ECHILD             = 10;       /// No child processes
    enum EDEADLK            = 11;       /// Resource deadlock avoided
    enum ENOMEM             = 12;       /// Cannot allocate memory
    enum EACCES             = 13;       /// Permission denied
    enum EFAULT             = 14;       /// Bad address
    enum ENOTBLK            = 15;       /// Block device required
    enum EBUSY              = 16;       /// Device busy
    enum EEXIST             = 17;       /// File exists
    enum EXDEV              = 18;       /// Cross-device link
    enum ENODEV             = 19;       /// Operation not supported by device
    enum ENOTDIR            = 20;       /// Not a directory
    enum EISDIR             = 21;       /// Is a directory
    enum EINVAL             = 22;       /// Invalid argument
    enum ENFILE             = 23;       /// Too many open files in system
    enum EMFILE             = 24;       /// Too many open files
    enum ENOTTY             = 25;       /// Inappropriate ioctl for device
    enum ETXTBSY            = 26;       /// Text file busy
    enum EFBIG              = 27;       /// File too large
    enum ENOSPC             = 28;       /// No space left on device
    enum ESPIPE             = 29;       /// Illegal seek
    enum EROFS              = 30;       /// Read-only file system
    enum EMLINK             = 31;       /// Too many links
    enum EPIPE              = 32;       /// Broken pipe
    enum EDOM               = 33;       /// Numerical argument out of domain
    enum ERANGE             = 34;       /// Result too large
    enum EAGAIN             = 35;       /// Resource temporarily unavailable
    enum EWOULDBLOCK        = EAGAIN;   /// Operation would block
    enum EINPROGRESS        = 36;       /// Operation now in progress
    enum EALREADY           = 37;       /// Operation already in progress
    enum ENOTSOCK           = 38;       /// Socket operation on non-socket
    enum EDESTADDRREQ       = 39;       /// Destination address required
    enum EMSGSIZE           = 40;       /// Message too long
    enum EPROTOTYPE         = 41;       /// Protocol wrong type for socket
    enum ENOPROTOOPT        = 42;       /// Protocol not available
    enum EPROTONOSUPPORT    = 43;       /// Protocol not supported
    enum ENOTSUP            = 45;       /// Operation not supported
    enum EOPNOTSUPP         = ENOTSUP;  /// Operation not supported on socket
    enum EAFNOSUPPORT       = 47;       /// Address family not supported by protocol family
    enum EADDRINUSE         = 48;       /// Address already in use
    enum EADDRNOTAVAIL      = 49;       /// Can't assign requested address
    enum ENETDOWN           = 50;       /// Network is down
    enum ENETUNREACH        = 51;       /// Network is unreachable
    enum ENETRESET          = 52;       /// Network dropped connection on reset
    enum ECONNABORTED       = 53;       /// Software caused connection abort
    enum ECONNRESET         = 54;       /// Connection reset by peer
    enum ENOBUFS            = 55;       /// No buffer space available
    enum EISCONN            = 56;       /// Socket is already connected
    enum ENOTCONN           = 57;       /// Socket is not connected
    enum ESHUTDOWN          = 58;       /// Can't send after socket shutdown
    enum ETOOMANYREFS       = 59;       /// Too many refrences; can't splice
    enum ETIMEDOUT          = 60;       /// Operation timed out
    enum ECONNREFUSED       = 61;       /// Connection refused
    enum ELOOP              = 62;       /// Too many levels of symbolic links
    enum ENAMETOOLONG       = 63;       /// File name too long
    enum EHOSTUNREACH       = 65;       /// No route to host
    enum ENOTEMPTY          = 66;       /// Directory not empty
    enum EPROCLIM           = 67;       /// Too many processes
    enum EUSERS             = 68;       /// Too many users
    enum EDQUOT             = 69;       /// Disc quota exceeded
    enum ESTALE             = 70;       /// Stale NFS file handle
    enum EREMOTE            = 71;       /// Too many levels of remote in path
    enum EBADRPC            = 72;       /// RPC struct is bad
    enum ERPCMISMATCH       = 73;       /// RPC version wrong
    enum EPROGUNAVAIL       = 74;       /// RPC prog. not avail
    enum EPROGMISMATCH      = 75;       /// Program version wrong
    enum EPROCUNAVAIL       = 76;       /// Bad procedure for program
    enum ENOLCK             = 77;       /// No locks available
    enum ENOSYS             = 78;       /// Function not implemented
    enum EFTYPE             = 79;       /// Inappropriate file type or format
    enum EAUTH              = 80;       /// Authentication error
    enum ENEEDAUTH          = 81;       /// Need authenticator
    enum EIDRM              = 82;       /// Itendifier removed
    enum ENOMSG             = 83;       /// No message of desired type
    enum EOVERFLOW          = 84;       /// Value too large to be stored in data type
    enum ECANCELED          = 85;       /// Operation canceled
    enum EILSEQ             = 86;       /// Illegal byte sequence
    enum ENOATTR            = 87;       /// Attribute not found
    enum EDOOFUS            = 88;       /// Programming error
    enum EBADMSG            = 89;       /// Bad message
    enum EMULTIHOP          = 90;       /// Multihop attempted
    enum ENOLINK            = 91;       /// Link has been severed
    enum EPROTO             = 92;       /// Protocol error
    enum ELAST              = 92;       /// Must be equal largest errno
}
else version (NetBSD)
{
    // http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/sys/errno.h
    enum EPERM           = 1;
    enum ENOENT          = 2;
    enum ESRCH           = 3;
    enum EINTR           = 4;
    enum EIO             = 5;
    enum ENXIO           = 6;
    enum E2BIG           = 7;
    enum ENOEXEC         = 8;
    enum EBADF           = 9;
    enum ECHILD          = 10;
    enum EDEADLK         = 11;
    ///
    enum ENOMEM          = 12;
    enum EACCES          = 13;
    enum EFAULT          = 14;
    enum ENOTBLK         = 15;
    enum EBUSY           = 16;
    enum EEXIST          = 17;
    enum EXDEV           = 18;
    enum ENODEV          = 19;
    enum ENOTDIR         = 20;
    enum EISDIR          = 21;
    enum EINVAL          = 22;
    enum ENFILE          = 23;
    enum EMFILE          = 24;
    enum ENOTTY          = 25;
    enum ETXTBSY         = 26;
    enum EFBIG           = 27;
    enum ENOSPC          = 28;
    enum ESPIPE          = 29;
    enum EROFS           = 30;
    enum EMLINK          = 31;
    enum EPIPE           = 32;
    ///
    enum EDOM            = 33;
    enum ERANGE          = 34;

    ///
    enum EAGAIN          = 35;
    enum EWOULDBLOCK     = EAGAIN;
    enum EINPROGRESS     = 36;
    enum EALREADY        = 37;

    ///
    enum ENOTSOCK        = 38;
    enum EDESTADDRREQ    = 39;
    enum EMSGSIZE        = 40;
    enum EPROTOTYPE      = 41;
    enum ENOPROTOOPT     = 42;
    enum EPROTONOSUPPORT = 43;
    enum ESOCKTNOSUPPORT = 44;
    enum EOPNOTSUPP      = 45;
    enum EPFNOSUPPORT    = 46;
    enum EAFNOSUPPORT    = 47;
    enum EADDRINUSE      = 48;
    enum EADDRNOTAVAIL   = 49;

    ///
    enum ENETDOWN        = 50;
    enum ENETUNREACH     = 51;
    enum ENETRESET       = 52;
    enum ECONNABORTED    = 53;
    enum ECONNRESET      = 54;
    enum ENOBUFS         = 55;
    enum EISCONN         = 56;
    enum ENOTCONN        = 57;
    enum ESHUTDOWN       = 58;
    enum ETOOMANYREFS    = 59;
    enum ETIMEDOUT       = 60;
    enum ECONNREFUSED    = 61;
    enum ELOOP           = 62;
    enum ENAMETOOLONG    = 63;

    ///
    enum EHOSTDOWN       = 64;
    enum EHOSTUNREACH    = 65;
    enum ENOTEMPTY       = 66;

    ///
    enum EPROCLIM        = 67;
    enum EUSERS          = 68;
    enum EDQUOT          = 69;

    ///
    enum ESTALE          = 70;
    enum EREMOTE         = 71;
    enum EBADRPC         = 72;
    enum ERPCMISMATCH    = 73;
    enum EPROGUNAVAIL    = 74;
    enum EPROGMISMATCH   = 75;
    enum EPROCUNAVAIL    = 76;

    enum ENOLCK          = 77;
    enum ENOSYS          = 78;

    enum EFTYPE          = 79;
    enum EAUTH           = 80;
    enum ENEEDAUTH       = 81;

    ///
    enum EIDRM           = 82;
    enum ENOMSG          = 83;
    enum EOVERFLOW       = 84;
    ///
    enum EILSEQ          = 85;

    ///
    enum ENOTSUP         = 86;

    ///
    enum ECANCELED       = 87;

    ///
    enum EBADMSG         = 88;

    ///
    enum ENODATA         = 89;
    enum ENOSR           = 90;
    enum ENOSTR          = 91;
    enum ETIME           = 92;

    ///
    enum ENOATTR         = 93;

    ///
    enum EMULTIHOP       = 94;
    enum ENOLINK         = 95;
    enum EPROTO          = 96;
}
else version (OpenBSD)
{
    enum EPERM              = 1;        /// Operation not permitted
    enum ENOENT             = 2;        /// No such file or directory
    enum ESRCH              = 3;        /// No such process
    enum EINTR              = 4;        /// Interrupted system call
    enum EIO                = 5;        /// Input/output error
    enum ENXIO              = 6;        /// Device not configured
    enum E2BIG              = 7;        /// Argument list too long
    enum ENOEXEC            = 8;        /// Exec format error
    enum EBADF              = 9;        /// Bad file descriptor
    enum ECHILD             = 10;       /// No child processes
    enum EDEADLK            = 11;       /// Resource deadlock avoided
    enum ENOMEM             = 12;       /// Cannot allocate memory
    enum EACCES             = 13;       /// Permission denied
    enum EFAULT             = 14;       /// Bad address
    enum ENOTBLK            = 15;       /// Block device required
    enum EBUSY              = 16;       /// Device busy
    enum EEXIST             = 17;       /// File exists
    enum EXDEV              = 18;       /// Cross-device link
    enum ENODEV             = 19;       /// Operation not supported by device
    enum ENOTDIR            = 20;       /// Not a directory
    enum EISDIR             = 21;       /// Is a directory
    enum EINVAL             = 22;       /// Invalid argument
    enum ENFILE             = 23;       /// Too many open files in system
    enum EMFILE             = 24;       /// Too many open files
    enum ENOTTY             = 25;       /// Inappropriate ioctl for device
    enum ETXTBSY            = 26;       /// Text file busy
    enum EFBIG              = 27;       /// File too large
    enum ENOSPC             = 28;       /// No space left on device
    enum ESPIPE             = 29;       /// Illegal seek
    enum EROFS              = 30;       /// Read-only file system
    enum EMLINK             = 31;       /// Too many links
    enum EPIPE              = 32;       /// Broken pipe
    enum EDOM               = 33;       /// Numerical argument out of domain
    enum ERANGE             = 34;       /// Result too large
    enum EAGAIN             = 35;       /// Resource temporarily unavailable
    enum EWOULDBLOCK        = EAGAIN;   /// Operation would block
    enum EINPROGRESS        = 36;       /// Operation now in progress
    enum EALREADY           = 37;       /// Operation already in progress
    enum ENOTSOCK           = 38;       /// Socket operation on non-socket
    enum EDESTADDRREQ       = 39;       /// Destination address required
    enum EMSGSIZE           = 40;       /// Message too long
    enum EPROTOTYPE         = 41;       /// Protocol wrong type for socket
    enum ENOPROTOOPT        = 42;       /// Protocol not available
    enum EPROTONOSUPPORT    = 43;       /// Protocol not supported
    enum ESOCKTNOSUPPORT    = 44;       /// Socket type not supported
    enum EOPNOTSUPP         = 45;       /// Operation not supported
    enum EPFNOSUPPORT       = 46;       /// Protocol family not supported
    enum EAFNOSUPPORT       = 47;       /// Address family not supported by protocol family
    enum EADDRINUSE         = 48;       /// Address already in use
    enum EADDRNOTAVAIL      = 49;       /// Can't assign requested address
    enum ENETDOWN           = 50;       /// Network is down
    enum ENETUNREACH        = 51;       /// Network is unreachable
    enum ENETRESET          = 52;       /// Network dropped connection on reset
    enum ECONNABORTED       = 53;       /// Software caused connection abort
    enum ECONNRESET         = 54;       /// Connection reset by peer
    enum ENOBUFS            = 55;       /// No buffer space available
    enum EISCONN            = 56;       /// Socket is already connected
    enum ENOTCONN           = 57;       /// Socket is not connected
    enum ESHUTDOWN          = 58;       /// Can't send after socket shutdown
    enum ETOOMANYREFS       = 59;       /// Too many references: can't splice
    enum ETIMEDOUT          = 60;       /// Operation timed out
    enum ECONNREFUSED       = 61;       /// Connection refused
    enum ELOOP              = 62;       /// Too many levels of symbolic links
    enum ENAMETOOLONG       = 63;       /// File name too long
    enum EHOSTDOWN          = 64;       /// Host is down
    enum EHOSTUNREACH       = 65;       /// No route to host
    enum ENOTEMPTY          = 66;       /// Directory not empty
    enum EPROCLIM           = 67;       /// Too many processes
    enum EUSERS             = 68;       /// Too many users
    enum EDQUOT             = 69;       /// Disk quota exceeded
    enum ESTALE             = 70;       /// Stale NFS file handle
    enum EREMOTE            = 71;       /// Too many levels of remote in path
    enum EBADRPC            = 72;       /// RPC struct is bad
    enum ERPCMISMATCH       = 73;       /// RPC version wrong
    enum EPROGUNAVAIL       = 74;       /// RPC program not available
    enum EPROGMISMATCH      = 75;       /// Program version wrong
    enum EPROCUNAVAIL       = 76;       /// Bad procedure for program
    enum ENOLCK             = 77;       /// No locks available
    enum ENOSYS             = 78;       /// Function not implemented
    enum EFTYPE             = 79;       /// Inappropriate file type or format
    enum EAUTH              = 80;       /// Authentication error
    enum ENEEDAUTH          = 81;       /// Need authenticator
    enum EIPSEC             = 82;       /// IPsec processing failure
    enum ENOATTR            = 83;       /// Attribute not found
    enum EILSEQ             = 84;       /// Illegal byte sequence
    enum ENOMEDIUM          = 85;       /// No medium found
    enum EMEDIUMTYPE        = 86;       /// Wrong medium type
    enum EOVERFLOW          = 87;       /// Value too large to be stored in data type
    enum ECANCELED          = 88;       /// Operation canceled
    enum EIDRM              = 89;       /// Identifier removed
    enum ENOMSG             = 90;       /// No message of desired type
    enum ENOTSUP            = 91;       /// Not supported
    enum ELAST              = 91;       /// Must be equal largest errno
}
else version (DragonFlyBSD)
{
    enum EPERM              = 1;
    enum ENOENT             = 2;
    enum ESRCH              = 3;
    enum EINTR              = 4;
    enum EIO                = 5;
    enum ENXIO              = 6;
    enum E2BIG              = 7;
    enum ENOEXEC            = 8;
    enum EBADF              = 9;
    enum ECHILD             = 10;
    enum EDEADLK            = 11;
    enum ENOMEM             = 12;
    enum EACCES             = 13;
    enum EFAULT             = 14;
    enum ENOTBLK            = 15;
    enum EBUSY              = 16;
    enum EEXIST             = 17;
    enum EXDEV              = 18;
    enum ENODEV             = 19;
    enum ENOTDIR            = 20;
    enum EISDIR             = 21;
    enum EINVAL             = 22;
    enum ENFILE             = 23;
    enum EMFILE             = 24;
    enum ENOTTY             = 25;
    enum ETXTBSY            = 26;
    enum EFBIG              = 27;
    enum ENOSPC             = 28;
    enum ESPIPE             = 29;
    enum EROFS              = 30;
    enum EMLINK             = 31;
    enum EPIPE              = 32;
    enum EDOM               = 33;
    enum ERANGE             = 34;
    enum EAGAIN             = 35;
    enum EWOULDBLOCK        = EAGAIN;
    enum EINPROGRESS        = 36;
    enum EALREADY           = 37;
    enum ENOTSOCK           = 38;
    enum EDESTADDRREQ       = 39;
    enum EMSGSIZE           = 40;
    enum EPROTOTYPE         = 41;
    enum ENOPROTOOPT        = 42;
    enum EPROTONOSUPPORT    = 43;
    enum ENOTSUP            = 45;
    enum EOPNOTSUPP         = ENOTSUP;
    enum EPFNOSUPPORT       = 46;
    enum EAFNOSUPPORT       = 47;
    enum EADDRINUSE         = 48;
    enum EADDRNOTAVAIL      = 49;
    enum ENETDOWN           = 50;
    enum ENETUNREACH        = 51;
    enum ENETRESET          = 52;
    enum ECONNABORTED       = 53;
    enum ECONNRESET         = 54;
    enum ENOBUFS            = 55;
    enum EISCONN            = 56;
    enum ENOTCONN           = 57;
    enum ESHUTDOWN          = 58;
    enum ETOOMANYREFS       = 59;
    enum ETIMEDOUT          = 60;
    enum ECONNREFUSED       = 61;
    enum ELOOP              = 62;
    enum ENAMETOOLONG       = 63;
    enum EHOSTUNREACH       = 65;
    enum ENOTEMPTY          = 66;
    enum EPROCLIM           = 67;
    enum EUSERS             = 68;
    enum EDQUOT             = 69;
    enum ESTALE             = 70;
    enum EREMOTE            = 71;
    enum EBADRPC            = 72;
    enum ERPCMISMATCH       = 73;
    enum EPROGUNAVAIL       = 74;
    enum EPROGMISMATCH      = 75;
    enum EPROCUNAVAIL       = 76;
    enum ENOLCK             = 77;
    enum ENOSYS             = 78;
    enum EFTYPE             = 79;
    enum EAUTH              = 80;
    enum ENEEDAUTH          = 81;
    enum EIDRM              = 82;
    enum ENOMSG             = 83;
    enum EOVERFLOW          = 84;
    enum ECANCELED          = 85;
    enum EILSEQ             = 86;
    enum ENOATTR            = 87;
    enum EDOOFUS            = 88;
    enum EBADMSG            = 89;
    enum EMULTIHOP          = 90;
    enum ENOLINK            = 91;
    enum EPROTO             = 92;
    enum ENOMEDIUM          = 93;
    enum EUNUSED94          = 94;
    enum EUNUSED95          = 95;
    enum EUNUSED96          = 96;
    enum EUNUSED97          = 97;
    enum EUNUSED98          = 98;
    enum EASYNC             = 99;
    enum ELAST              = 99;
}
else version (Solaris)
{
    enum EPERM =  1       /** Not super-user                       */;
    enum ENOENT = 2       /** No such file or directory            */;
    enum ESRCH =  3       /** No such process                      */;
    enum EINTR =  4       /** interrupted system call              */;
    enum EIO =    5       /** I/O error                            */;
    enum ENXIO =  6       /** No such device or address            */;
    enum E2BIG =  7       /** Arg list too long                    */;
    enum ENOEXEC = 8       /** Exec format error                    */;
    enum EBADF =  9       /** Bad file number                      */;
    enum ECHILD = 10      /** No children                          */;
    enum EAGAIN = 11      /** Resource temporarily unavailable     */;
    enum ENOMEM = 12      /** Not enough core                      */;
    enum EACCES = 13      /** Permission denied                    */;
    enum EFAULT = 14      /** Bad address                          */;
    enum ENOTBLK = 15      /** Block device required                */;
    enum EBUSY =  16      /** Mount device busy                    */;
    enum EEXIST = 17      /** File exists                          */;
    enum EXDEV =  18      /** Cross-device link                    */;
    enum ENODEV = 19      /** No such device                       */;
    enum ENOTDIR = 20      /** Not a directory                      */;
    enum EISDIR = 21      /** Is a directory                       */;
    enum EINVAL = 22      /** Invalid argument                     */;
    enum ENFILE = 23      /** File table overflow                  */;
    enum EMFILE = 24      /** Too many open files                  */;
    enum ENOTTY = 25      /** Inappropriate ioctl for device       */;
    enum ETXTBSY = 26      /** Text file busy                       */;
    enum EFBIG =  27      /** File too large                       */;
    enum ENOSPC = 28      /** No space left on device              */;
    enum ESPIPE = 29      /** Illegal seek                         */;
    enum EROFS =  30      /** Read only file system                */;
    enum EMLINK = 31      /** Too many links                       */;
    enum EPIPE =  32      /** Broken pipe                          */;
    enum EDOM =   33      /** Math arg out of domain of func       */;
    enum ERANGE = 34      /** Math result not representable        */;
    enum ENOMSG = 35      /** No message of desired type           */;
    enum EIDRM =  36      /** Identifier removed                   */;
    enum ECHRNG = 37      /** Channel number out of range          */;
    enum EL2NSYNC = 38     /** Level 2 not synchronized             */;
    enum EL3HLT = 39      /** Level 3 halted                       */;
    enum EL3RST = 40      /** Level 3 reset                        */;
    enum ELNRNG = 41      /** Link number out of range             */;
    enum EUNATCH = 42      /** Protocol driver not attached         */;
    enum ENOCSI = 43      /** No CSI structure available           */;
    enum EL2HLT = 44      /** Level 2 halted                       */;
    enum EDEADLK = 45      /** Deadlock condition.                  */;
    enum ENOLCK = 46      /** No record locks available.           */;
    enum ECANCELED = 47    /** Operation canceled                   */;
    enum ENOTSUP = 48      /** Operation not supported              */;
    enum EDQUOT = 49      /** Disc quota exceeded                  */;
    enum EBADE =  50      /** invalid exchange                     */;
    enum EBADR =  51      /** invalid request descriptor           */;
    enum EXFULL = 52      /** exchange full                        */;
    enum ENOANO = 53      /** no anode                             */;
    enum EBADRQC = 54      /** invalid request code                 */;
    enum EBADSLT = 55      /** invalid slot                         */;
    enum EDEADLOCK = 56    /** file locking deadlock error          */;
    enum EBFONT = 57      /** bad font file fmt                    */;
    enum EOWNERDEAD =     58      /** process died with the lock */;
    enum ENOTRECOVERABLE = 59      /** lock is not recoverable */;
    enum ENOSTR = 60      /** Device not a stream                  */;
    enum ENODATA = 61      /** no data (for no delay io)            */;
    enum ETIME =  62      /** timer expired                        */;
    enum ENOSR =  63      /** out of streams resources             */;
    enum ENONET = 64      /** Machine is not on the network        */;
    enum ENOPKG = 65      /** Package not installed                */;
    enum EREMOTE = 66      /** The object is remote                 */;
    enum ENOLINK = 67      /** the link has been severed            */;
    enum EADV =   68      /** advertise error                      */;
    enum ESRMNT = 69      /** srmount error                        */;
    enum ECOMM =  70      /** Communication error on send          */;
    enum EPROTO = 71      /** Protocol error                       */;
    enum ELOCKUNMAPPED =  72      /** locked lock was unmapped */;
    enum ENOTACTIVE = 73   /** Facility is not active               */;
    enum EMULTIHOP = 74    /** multihop attempted                   */;
    enum EBADMSG = 77      /** trying to read unreadable message    */;
    enum ENAMETOOLONG = 78 /** path name is too long                */;
    enum EOVERFLOW = 79    /** value too large to be stored in data type */;
    enum ENOTUNIQ = 80     /** given log. name not unique           */;
    enum EBADFD =  81      /** f.d. invalid for this operation      */;
    enum EREMCHG = 82      /** Remote address changed               */;
    enum ELIBACC = 83      /** Can't access a needed shared lib.    */;
    enum ELIBBAD = 84      /** Accessing a corrupted shared lib.    */;
    enum ELIBSCN = 85      /** .lib section in a.out corrupted.     */;
    enum ELIBMAX = 86      /** Attempting to link in too many libs. */;
    enum ELIBEXEC = 87     /** Attempting to exec a shared library. */;
    enum EILSEQ = 88      /** Illegal byte sequence.               */;
    enum ENOSYS = 89      /** Unsupported file system operation    */;
    enum ELOOP =  90      /** Symbolic link loop                   */;
    enum ERESTART = 91     /** Restartable system call              */;
    enum ESTRPIPE = 92     /** if pipe/FIFO, don't sleep in stream head */;
    enum ENOTEMPTY = 93    /** directory not empty                  */;
    enum EUSERS = 94      /** Too many users (for UFS)             */;
    enum ENOTSOCK =       95      /** Socket operation on non-socket */;
    enum EDESTADDRREQ =   96      /** Destination address required */;
    enum EMSGSIZE =       97      /** Message too long */;
    enum EPROTOTYPE =     98      /** Protocol wrong type for socket */;
    enum ENOPROTOOPT =    99      /** Protocol not available */;
    enum EPROTONOSUPPORT = 120     /** Protocol not supported */;
    enum ESOCKTNOSUPPORT = 121     /** Socket type not supported */;
    enum EOPNOTSUPP =     122     /** Operation not supported on socket */;
    enum EPFNOSUPPORT =   123     /** Protocol family not supported */;
    enum EAFNOSUPPORT =   124     /** Address family not supported by the protocol family */;
    enum EADDRINUSE =     125     /** Address already in use */;
    enum EADDRNOTAVAIL =   126     /** Can't assign requested address */;
    enum ENETDOWN =       127     /** Network is down */;
    enum ENETUNREACH =    128     /** Network is unreachable */;
    enum ENETRESET =      129     /** Network dropped connection because of reset */;
    enum ECONNABORTED =   130     /** Software caused connection abort */;
    enum ECONNRESET =     131     /** Connection reset by peer */;
    enum ENOBUFS =        132     /** No buffer space available */;
    enum EISCONN =        133     /** Socket is already connected */;
    enum ENOTCONN =       134     /** Socket is not connected */;
    enum ESHUTDOWN =      143     /** Can't send after socket shutdown */;
    enum ETOOMANYREFS =   144     /** Too many references: can't splice */;
    enum ETIMEDOUT =      145     /** Connection timed out */;
    enum ECONNREFUSED =   146     /** Connection refused */;
    enum EHOSTDOWN =      147     /** Host is down */;
    enum EHOSTUNREACH =   148     /** No route to host */;
    enum EWOULDBLOCK =    EAGAIN;      /** Resource temporarily unavailable     */;
    enum EALREADY =       149     /** operation already in progress */;
    enum EINPROGRESS =    150     /** operation now in progress */;
    enum ESTALE =         151     /** Stale NFS file handle */;
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_fenv.h.html, _fenv.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_fenv.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.fenv;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

extern (C):
@system:
nothrow:
@nogc:

version (ARM)     version = ARM_Any;
version (AArch64) version = ARM_Any;
version (HPPA)    version = HPPA_Any;
version (MIPS32)  version = MIPS_Any;
version (MIPS64)  version = MIPS_Any;
version (PPC)     version = PPC_Any;
version (PPC64)   version = PPC_Any;
version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;
version (S390)    version = IBMZ_Any;
version (SPARC)   version = SPARC_Any;
version (SPARC64) version = SPARC_Any;
version (SystemZ) version = IBMZ_Any;
version (X86)     version = X86_Any;
version (X86_64)  version = X86_Any;

version (MinGW)
    version = GNUFP;
version (CRuntime_Glibc)
    version = GNUFP;

version (GNUFP)
{
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86/fpu/bits/fenv.h
    version (X86)
    {
        struct fenv_t
        {
            ushort __control_word;
            ushort __unused1;
            ushort __status_word;
            ushort __unused2;
            ushort __tags;
            ushort __unused3;
            uint   __eip;
            ushort __cs_selector;
            ushort __opcode;
            uint   __data_offset;
            ushort __data_selector;
            ushort __unused5;
        }

        alias fexcept_t = ushort;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/x86/fpu/bits/fenv.h
    else version (X86_64)
    {
        struct fenv_t
        {
            ushort __control_word;
            ushort __unused1;
            ushort __status_word;
            ushort __unused2;
            ushort __tags;
            ushort __unused3;
            uint   __eip;
            ushort __cs_selector;
            ushort __opcode;
            uint   __data_offset;
            ushort __data_selector;
            ushort __unused5;
            uint   __mxcsr;
        }

        alias fexcept_t = ushort;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/hppa/bits/fenv.h
    else version (HPPA_Any)
    {
        struct fenv_t
        {
            uint    __status_word;
            uint[7] __exception;
        }

        alias fexcept_t = uint;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/mips/bits/fenv.h
    else version (MIPS_Any)
    {
        struct fenv_t
        {
            uint   __fp_control_register;
        }

        alias fexcept_t = ushort;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/aarch64/bits/fenv.h
    else version (AArch64)
    {
        struct fenv_t
        {
            uint __fpcr;
            uint __fpsr;
        }

        alias fexcept_t = uint;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/arm/bits/fenv.h
    else version (ARM)
    {
        struct fenv_t
        {
            uint __cw;
        }

        alias fexcept_t = uint;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/powerpc/bits/fenv.h
    else version (PPC_Any)
    {
        alias fenv_t = double;
        alias fexcept_t = uint;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/riscv/bits/fenv.h
    else version (RISCV_Any)
    {
        alias fenv_t = uint;
        alias fexcept_t = uint;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/sparc/fpu/bits/fenv.h
    else version (SPARC64)
    {
        alias fenv_t = ulong;
        alias fexcept_t = ulong;
    }
    // https://sourceware.org/git/?p=glibc.git;a=blob;f=sysdeps/s390/fpu/bits/fenv.h
    else version (IBMZ_Any)
    {
        struct fenv_t
        {
            fexcept_t __fpc;
            void*     __unused;
        }

        alias fexcept_t = uint;
    }
    else
    {
        static assert(0, "Unimplemented architecture");
    }
}
else version (CRuntime_DigitalMars)
{
    struct fenv_t
    {
        ushort    status;
        ushort    control;
        ushort    round;
        ushort[2] reserved;
    }
    alias fexcept_t = int;
}
else version (CRuntime_Microsoft)
{
    struct fenv_t
    {
        uint ctl;
        uint stat;
    }

    alias fexcept_t = uint;
}
else version (Darwin)
{
    version (BigEndian)
    {
        alias uint fenv_t;
        alias uint fexcept_t;
    }
    version (LittleEndian)
    {
        struct fenv_t
        {
            ushort  __control;
            ushort  __status;
            uint    __mxcsr;
            byte[8] __reserved;
        }

        alias ushort fexcept_t;
    }
}
else version (FreeBSD)
{
    struct fenv_t
    {
        ushort __control;
        ushort __mxcsr_hi;
        ushort __status;
        ushort __mxcsr_lo;
        uint __tag;
        byte[16] __other;
    }

    alias ushort fexcept_t;
}
else version (NetBSD)
{
    version (X86_64)
    {
        struct fenv_t
        {
            struct _x87
            {
                    uint control;       /* Control word register */
                    uint status;        /* Status word register */
                    uint tag;           /* Tag word register */
                    uint[4] others;     /* EIP, Pointer Selector, etc */
            };
            _x87 x87;

            uint mxcsr;                 /* Control and status register */
        }
   }
   version (X86)
   {
        struct fenv_t
        {
            struct _x87
            {
                    ushort control;       /* Control word register */
                    ushort unused1;
                    ushort status;        /* Status word register */
                    ushort unused2;
                    ushort tag;           /* Tag word register */
                    ushort unused3;
                    uint[4] others;     /* EIP, Pointer Selector, etc */
            };
            _x87 x87;
            uint32_t mxcsr;                 /* Control and status register */
        };

    }

    alias uint fexcept_t;
}
else version (OpenBSD)
{
    struct fenv_t
    {
        struct __x87
        {
            uint    __control;
            uint    __status;
            uint    __tag;
            uint[4] __others;
        }
    }
    uint __mxcsr;

    alias fexcept_t = uint;
}
else version (DragonFlyBSD)
{
    struct fenv_t
    {
        struct _x87
        {
                uint control;
                uint status;
                uint tag;
                uint[4] others;
        };
        _x87 x87;

        uint mxcsr;
    }

    alias uint fexcept_t;
}
else version (CRuntime_Bionic)
{
    version (X86)
    {
        struct fenv_t
        {
            ushort   __control;
            ushort   __mxcsr_hi;
            ushort   __status;
            ushort   __mxcsr_lo;
            uint     __tag;
            byte[16] __other;
        }

        alias ushort fexcept_t;
    }
    else version (ARM)
    {
        alias uint fenv_t;
        alias uint fexcept_t;
    }
    else version (AArch64)
    {
        struct fenv_t
        {
            uint   __control;
            uint   __status;
        }

        alias uint fexcept_t;
    }
    else version (X86_64)
    {
        struct fenv_t
        {
            struct _x87
            {
                uint    __control;
                uint    __status;
                uint    __tag;
                uint[4] __others;
            }
            _x87 __x87;

            uint __mxcsr;
        }

        alias uint fexcept_t;
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else version (Solaris)
{
    import core.stdc.config : c_ulong;

    enum FEX_NUM_EXC = 12;

    struct fex_handler_t
    {
        int             __mode;
        void function() __handler;
    }

    struct fenv_t
    {
        fex_handler_t[FEX_NUM_EXC]  __handler;
        c_ulong                     __fsr;
    }

    alias int fexcept_t;
}
else version (CRuntime_Musl)
{
    version (X86_64)
    {
        struct fenv_t
        {
            ushort __control_word;
            ushort __unused1;
            ushort __status_word;
            ushort __unused2;
            ushort __tags;
            ushort __unused3;
            uint   __eip;
            ushort __cs_selector;
            ushort __opcode;
            uint   __data_offset;
            ushort __data_selector;
            ushort __unused5;
            uint   __mxcsr;
        }
        alias ushort fexcept_t;
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else version (CRuntime_UClibc)
{
    version (X86)
    {
        struct fenv_t
        {
            ushort __control_word;
            ushort __unused1;
            ushort __status_word;
            ushort __unused2;
            ushort __tags;
            ushort __unused3;
            uint   __eip;
            ushort __cs_selector;
            ushort __opcode;
            uint   __data_offset;
            ushort __data_selector;
            ushort __unused5;
        }

        alias fexcept_t = ushort;
    }
    else version (X86_64)
    {
        struct fenv_t
        {
            ushort __control_word;
            ushort __unused1;
            ushort __status_word;
            ushort __unused2;
            ushort __tags;
            ushort __unused3;
            uint   __eip;
            ushort __cs_selector;
            ushort __opcode;
            uint   __data_offset;
            ushort __data_selector;
            ushort __unused5;
            uint   __mxcsr;
        }

        alias fexcept_t = ushort;
    }
    else version (MIPS32)
    {
        struct fenv_t
        {
            uint __fp_control_register;
        }

        alias fexcept_t = ushort;
    }
    else version (ARM)
    {
        struct fenv_t
        {
            uint __cw;
        }

        alias fexcept_t = uint;
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else
{
    static assert( false, "Unsupported platform" );
}

version (CRuntime_Microsoft)
{
    enum
    {
        FE_INEXACT      = 1, ///
        FE_UNDERFLOW    = 2, ///
        FE_OVERFLOW     = 4, ///
        FE_DIVBYZERO    = 8, ///
        FE_INVALID      = 0x10, ///
        FE_ALL_EXCEPT   = 0x1F, ///
        FE_TONEAREST    = 0, ///
        FE_UPWARD       = 0x100, ///
        FE_DOWNWARD     = 0x200, ///
        FE_TOWARDZERO   = 0x300, ///
    }
}
else version (Solaris)
{
    version (SPARC_Any)
    {
        enum
        {
            FE_TONEAREST    = 0,
            FE_TOWARDZERO   = 1,
            FE_UPWARD       = 2,
            FE_DOWNWARD     = 3,
        }

        enum
        {
            FE_INEXACT      = 0x01,
            FE_DIVBYZERO    = 0x02,
            FE_UNDERFLOW    = 0x04,
            FE_OVERFLOW     = 0x08,
            FE_INVALID      = 0x10,
            FE_ALL_EXCEPT   = 0x1f,
        }

    }
    else version (X86_Any)
    {
        enum
        {
            FE_TONEAREST    = 0,
            FE_DOWNWARD     = 1,
            FE_UPWARD       = 2,
            FE_TOWARDZERO   = 3,
        }

        enum
        {
            FE_INVALID      = 0x01,
            FE_DIVBYZERO    = 0x04,
            FE_OVERFLOW     = 0x08,
            FE_UNDERFLOW    = 0x10,
            FE_INEXACT      = 0x20,
            FE_ALL_EXCEPT   = 0x3d,
        }
    }
    else
    {
        static assert(0, "Unimplemented architecture");
    }
}
else
{
    version (X86)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INVALID      = 0x01, ///
            FE_DENORMAL     = 0x02, /// non-standard
            FE_DIVBYZERO    = 0x04, ///
            FE_OVERFLOW     = 0x08, ///
            FE_UNDERFLOW    = 0x10, ///
            FE_INEXACT      = 0x20, ///
            FE_ALL_EXCEPT   = 0x3F, ///
        }

        // The ix87 FPU supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0, ///
            FE_DOWNWARD     = 0x400, ///
            FE_UPWARD       = 0x800, ///
            FE_TOWARDZERO   = 0xC00, ///
        }
    }
    else version (X86_64)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INVALID      = 0x01, ///
            FE_DENORMAL     = 0x02, /// non-standard
            FE_DIVBYZERO    = 0x04, ///
            FE_OVERFLOW     = 0x08, ///
            FE_UNDERFLOW    = 0x10, ///
            FE_INEXACT      = 0x20, ///
            FE_ALL_EXCEPT   = 0x3F, ///
        }

        // The ix87 FPU supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0, ///
            FE_DOWNWARD     = 0x400, ///
            FE_UPWARD       = 0x800, ///
            FE_TOWARDZERO   = 0xC00, ///
        }
    }
    else version (ARM_Any)
    {
        // Define bits representing exceptions in the FPU status word.
        enum
        {
            FE_INVALID      = 1,  ///
            FE_DIVBYZERO    = 2,  ///
            FE_OVERFLOW     = 4,  ///
            FE_UNDERFLOW    = 8,  ///
            FE_INEXACT      = 16, ///
            FE_ALL_EXCEPT   = 31, ///
        }

        // VFP supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0,        ///
            FE_UPWARD       = 0x400000, ///
            FE_DOWNWARD     = 0x800000, ///
            FE_TOWARDZERO   = 0xC00000, ///
        }
    }
    else version (HPPA_Any)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INEXACT      = 0x01, ///
            FE_UNDERFLOW    = 0x02, ///
            FE_OVERFLOW     = 0x04, ///
            FE_DIVBYZERO    = 0x08, ///
            FE_INVALID      = 0x10, ///
            FE_ALL_EXCEPT   = 0x1F, ///
        }

        // The HPPA FPU supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    =   0x0, ///
            FE_TOWARDZERO   = 0x200, ///
            FE_UPWARD       = 0x400, ///
            FE_DOWNWARD     = 0x600, ///
        }
    }
    else version (MIPS_Any)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INEXACT      = 0x04, ///
            FE_UNDERFLOW    = 0x08, ///
            FE_OVERFLOW     = 0x10, ///
            FE_DIVBYZERO    = 0x20, ///
            FE_INVALID      = 0x40, ///
            FE_ALL_EXCEPT   = 0x7C, ///
        }

        // The MIPS FPU supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0x0, ///
            FE_TOWARDZERO   = 0x1, ///
            FE_UPWARD       = 0x2, ///
            FE_DOWNWARD     = 0x3, ///
        }
    }
    else version (PPC_Any)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INEXACT                    = 0x2000000,  ///
            FE_DIVBYZERO                  = 0x4000000,  ///
            FE_UNDERFLOW                  = 0x8000000,  ///
            FE_OVERFLOW                   = 0x10000000, ///
            FE_INVALID                    = 0x20000000, ///
            FE_INVALID_SNAN               = 0x1000000,  /// non-standard
            FE_INVALID_ISI                = 0x800000,   /// non-standard
            FE_INVALID_IDI                = 0x400000,   /// non-standard
            FE_INVALID_ZDZ                = 0x200000,   /// non-standard
            FE_INVALID_IMZ                = 0x100000,   /// non-standard
            FE_INVALID_COMPARE            = 0x80000,    /// non-standard
            FE_INVALID_SOFTWARE           = 0x400,      /// non-standard
            FE_INVALID_SQRT               = 0x200,      /// non-standard
            FE_INVALID_INTEGER_CONVERSION = 0x100,      /// non-standard
            FE_ALL_INVALID                = 0x1F80700,  /// non-standard
            FE_ALL_EXCEPT                 = 0x3E000000, ///
        }

        // PowerPC chips support all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0, ///
            FE_TOWARDZERO   = 1, ///
            FE_UPWARD       = 2, ///
            FE_DOWNWARD     = 3, ///
        }
    }
    else version (RISCV_Any)
    {
        // Define bits representing exceptions in the FPSR status word.
        enum
        {
            FE_INEXACT      = 0x01, ///
            FE_UNDERFLOW    = 0x02, ///
            FE_OVERFLOW     = 0x04, ///
            FE_DIVBYZERO    = 0x08, ///
            FE_INVALID      = 0x10, ///
            FE_ALL_EXCEPT   = 0x1f, ///
        }

        // Define bits representing rounding modes in the FPCR Rmode field.
        enum
        {
            FE_TONEAREST    = 0x0, ///
            FE_TOWARDZERO   = 0x1, ///
            FE_DOWNWARD     = 0x2, ///
            FE_UPWARD       = 0x3, ///
        }
    }
    else version (SPARC_Any)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INVALID      = 0x200, ///
            FE_OVERFLOW     = 0x100, ///
            FE_UNDERFLOW    = 0x80,  ///
            FE_DIVBYZERO    = 0x40,  ///
            FE_INEXACT      = 0x20,  ///
            FE_ALL_EXCEPT   = 0x3E0, ///
        }

        // The Sparc FPU supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0x0,        ///
            FE_TOWARDZERO   = 0x40000000, ///
            FE_UPWARD       = 0x80000000, ///
            FE_DOWNWARD     = 0xc0000000, ///
        }
    }
    else version (IBMZ_Any)
    {
        // Define bits representing the exception.
        enum
        {
            FE_INVALID      = 0x80, ///
            FE_DIVBYZERO    = 0x40, ///
            FE_OVERFLOW     = 0x20, ///
            FE_UNDERFLOW    = 0x10, ///
            FE_INEXACT      = 0x08, ///
            FE_ALL_EXCEPT   = 0xF8, ///
        }

        // SystemZ supports all of the four defined rounding modes.
        enum
        {
            FE_TONEAREST    = 0x0, ///
            FE_DOWNWARD     = 0x3, ///
            FE_UPWARD       = 0x2, ///
            FE_TOWARDZERO   = 0x1, ///
        }
    }
    else
    {
        static assert(0, "Unimplemented architecture");
    }

}

version (GNUFP)
{
    ///
    enum FE_DFL_ENV = cast(fenv_t*)(-1);
}
else version (CRuntime_DigitalMars)
{
    private extern __gshared fenv_t _FE_DFL_ENV;
    ///
    enum fenv_t* FE_DFL_ENV = &_FE_DFL_ENV;
}
else version (CRuntime_Microsoft)
{
    private extern __gshared fenv_t _Fenv0;
    ///
    enum FE_DFL_ENV = &_Fenv0;
}
else version (Darwin)
{
    private extern __gshared fenv_t _FE_DFL_ENV;
    ///
    enum FE_DFL_ENV = &_FE_DFL_ENV;
}
else version (FreeBSD)
{
    private extern const fenv_t __fe_dfl_env;
    ///
    enum FE_DFL_ENV = &__fe_dfl_env;
}
else version (NetBSD)
{
    private extern const fenv_t __fe_dfl_env;
    ///
    enum FE_DFL_ENV = &__fe_dfl_env;
}
else version (OpenBSD)
{
    private extern const fenv_t __fe_dfl_env;
    ///
    enum FE_DFL_ENV = &__fe_dfl_env;
}
else version (DragonFlyBSD)
{
    private extern const fenv_t __fe_dfl_env;
    ///
    enum FE_DFL_ENV = &__fe_dfl_env;
}
else version (CRuntime_Bionic)
{
    private extern const fenv_t __fe_dfl_env;
    ///
    enum FE_DFL_ENV = &__fe_dfl_env;
}
else version (Solaris)
{
    private extern const fenv_t __fenv_def_env;
    ///
    enum FE_DFL_ENV = &__fenv_def_env;
}
else version (CRuntime_Musl)
{
    ///
    enum FE_DFL_ENV = cast(fenv_t*)(-1);
}
else version (CRuntime_UClibc)
{
    ///
    enum FE_DFL_ENV = cast(fenv_t*)(-1);
}
else
{
    static assert( false, "Unsupported platform" );
}

///
int feclearexcept(int excepts);

///
int fetestexcept(int excepts);
///
int feholdexcept(fenv_t* envp);

///
int fegetexceptflag(fexcept_t* flagp, int excepts);
///
int fesetexceptflag(in fexcept_t* flagp, int excepts);

///
int fegetround();
///
int fesetround(int round);

///
int fegetenv(fenv_t* envp);
///
int fesetenv(in fenv_t* envp);

// MS define feraiseexcept() and feupdateenv() inline.
version (CRuntime_Microsoft) // supported since MSVCRT 12 (VS 2013) only
{
    ///
    int feraiseexcept()(int excepts)
    {
        struct Entry
        {
            int    exceptVal;
            double num;
            double denom;
        }
        static __gshared immutable(Entry[5]) table =
        [ // Raise exception by evaluating num / denom:
            { FE_INVALID,   0.0,    0.0    },
            { FE_DIVBYZERO, 1.0,    0.0    },
            { FE_OVERFLOW,  1e+300, 1e-300 },
            { FE_UNDERFLOW, 1e-300, 1e+300 },
            { FE_INEXACT,   2.0,    3.0    }
        ];

        if ((excepts &= FE_ALL_EXCEPT) == 0)
            return 0;

        // Raise the exceptions not masked:
        double ans = void;
        foreach (i; 0 .. table.length)
        {
            if ((excepts & table[i].exceptVal) != 0)
                ans = table[i].num / table[i].denom;
        }

        return 0;
    }

    ///
    int feupdateenv()(in fenv_t* envp)
    {
        int excepts = fetestexcept(FE_ALL_EXCEPT);
        return (fesetenv(envp) != 0 || feraiseexcept(excepts) != 0 ? 1 : 0);
    }
}
else
{
    ///
    int feraiseexcept(int excepts);
    ///
    int feupdateenv(in fenv_t* envp);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_float.h.html, _float.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_float_.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.float_;

extern (C):
@trusted: // Constants only.
nothrow:
@nogc:

///
enum FLT_ROUNDS                 = 1;
///
enum FLT_EVAL_METHOD    = 2;
///
enum FLT_RADIX                  = 2;

///
enum DECIMAL_DIG                = real.dig;
///
enum FLT_DIG                    = float.dig;
///
enum DBL_DIG                    = double.dig;
///
enum LDBL_DIG                   = real.dig;

///
enum FLT_MANT_DIG               = float.mant_dig;
///
enum DBL_MANT_DIG               = double.mant_dig;
///
enum LDBL_MANT_DIG              = real.mant_dig;

///
enum FLT_MIN                    = float.min_normal;
///
enum DBL_MIN                    = double.min_normal;
///
enum LDBL_MIN                   = real.min_normal;

///
enum FLT_MAX                    = float.max;
///
enum DBL_MAX                    = double.max;
///
enum LDBL_MAX                   = real.max;

///
enum FLT_EPSILON                = float.epsilon;
///
enum DBL_EPSILON                = double.epsilon;
///
enum LDBL_EPSILON               = real.epsilon;

///
enum FLT_MIN_EXP                = float.min_exp;
///
enum DBL_MIN_EXP                = double.min_exp;
///
enum LDBL_MIN_EXP               = real.min_exp;

///
enum FLT_MAX_EXP                = float.max_exp;
///
enum DBL_MAX_EXP                = double.max_exp;
///
enum LDBL_MAX_EXP               = real.max_exp;

///
enum FLT_MIN_10_EXP             = float.min_10_exp;
///
enum DBL_MIN_10_EXP             = double.min_10_exp;
///
enum LDBL_MIN_10_EXP    = real.min_10_exp;

///
enum FLT_MAX_10_EXP             = float.max_10_exp;
///
enum DBL_MAX_10_EXP             = double.max_10_exp;
///
enum LDBL_MAX_10_EXP    = real.max_10_exp;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_inttypes.h.html, _inttypes.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_inttypes.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.inttypes;

public import core.stdc.stddef; // for wchar_t
public import core.stdc.stdint; // required by spec

extern (C):
@trusted: // Types and constants only.
nothrow:
@nogc:

///
struct imaxdiv_t
{
    intmax_t    quot,
                rem;
}

private alias immutable(char)* _cstr;

///
enum _cstr PRId8            = "hhd";
///
enum _cstr PRId16           = "hd";
///
enum _cstr PRId32           = "ld";
///
enum _cstr PRId64           = "lld";

///
enum _cstr PRIdLEAST8       = "hhd";
///
enum _cstr PRIdLEAST16      = "hd";
///
enum _cstr PRIdLEAST32      = "ld";
///
enum _cstr PRIdLEAST64      = "lld";

///
enum _cstr PRIdFAST8        = "hhd";
///
enum _cstr PRIdFAST16       = "d";
///
enum _cstr PRIdFAST32       = "ld";
///
enum _cstr PRIdFAST64       = "lld";

///
enum _cstr PRIi8            = "hhi";
///
enum _cstr PRIi16           = "hi";
///
enum _cstr PRIi32           = "li";
///
enum _cstr PRIi64           = "lli";

///
enum _cstr PRIiLEAST8       = "hhi";
///
enum _cstr PRIiLEAST16      = "hi";
///
enum _cstr PRIiLEAST32      = "li";
///
enum _cstr PRIiLEAST64      = "lli";

///
enum _cstr PRIiFAST8        = "hhi";
///
enum _cstr PRIiFAST16       = "i";
///
enum _cstr PRIiFAST32       = "li";
///
enum _cstr PRIiFAST64       = "lli";

///
enum _cstr PRIo8            = "hho";
///
enum _cstr PRIo16           = "ho";
///
enum _cstr PRIo32           = "lo";
///
enum _cstr PRIo64           = "llo";

///
enum _cstr PRIoLEAST8       = "hho";
///
enum _cstr PRIoLEAST16      = "ho";
///
enum _cstr PRIoLEAST32      = "lo";
///
enum _cstr PRIoLEAST64      = "llo";

///
enum _cstr PRIoFAST8        = "hho";
///
enum _cstr PRIoFAST16       = "o";
///
enum _cstr PRIoFAST32       = "lo";
///
enum _cstr PRIoFAST64       = "llo";

///
enum _cstr PRIu8            = "hhu";
///
enum _cstr PRIu16           = "hu";
///
enum _cstr PRIu32           = "lu";
///
enum _cstr PRIu64           = "llu";

///
enum _cstr PRIuLEAST8       = "hhu";
///
enum _cstr PRIuLEAST16      = "hu";
///
enum _cstr PRIuLEAST32      = "lu";
///
enum _cstr PRIuLEAST64      = "llu";

///
enum _cstr PRIuFAST8        = "hhu";
///
enum _cstr PRIuFAST16       = "u";
///
enum _cstr PRIuFAST32       = "lu";
///
enum _cstr PRIuFAST64       = "llu";

///
enum _cstr PRIx8            = "hhx";
///
enum _cstr PRIx16           = "hx";
///
enum _cstr PRIx32           = "lx";
///
enum _cstr PRIx64           = "llx";

///
enum _cstr PRIxLEAST8       = "hhx";
///
enum _cstr PRIxLEAST16      = "hx";
///
enum _cstr PRIxLEAST32      = "lx";
///
enum _cstr PRIxLEAST64      = "llx";

///
enum _cstr PRIxFAST8        = "hhx";
///
enum _cstr PRIxFAST16       = "x";
///
enum _cstr PRIxFAST32       = "lx";
///
enum _cstr PRIxFAST64       = "llx";

///
enum _cstr PRIX8            = "hhX";
///
enum _cstr PRIX16           = "hX";
///
enum _cstr PRIX32           = "lX";
///
enum _cstr PRIX64           = "llX";

///
enum _cstr PRIXLEAST8       = "hhX";
///
enum _cstr PRIXLEAST16      = "hX";
///
enum _cstr PRIXLEAST32      = "lX";
///
enum _cstr PRIXLEAST64      = "llX";

///
enum _cstr PRIXFAST8        = "hhX";
///
enum _cstr PRIXFAST16       = "X";
///
enum _cstr PRIXFAST32       = "lX";
///
enum _cstr PRIXFAST64       = "llX";

///
enum _cstr SCNd8            = "hhd";
///
enum _cstr SCNd16           = "hd";
///
enum _cstr SCNd32           = "ld";
///
enum _cstr SCNd64           = "lld";

///
enum _cstr SCNdLEAST8       = "hhd";
///
enum _cstr SCNdLEAST16      = "hd";
///
enum _cstr SCNdLEAST32      = "ld";
///
enum _cstr SCNdLEAST64      = "lld";

///
enum _cstr SCNdFAST8        = "hhd";
///
enum _cstr SCNdFAST16       = "d";
///
enum _cstr SCNdFAST32       = "ld";
///
enum _cstr SCNdFAST64       = "lld";

///
enum _cstr SCNi8            = "hhd";
///
enum _cstr SCNi16           = "hi";
///
enum _cstr SCNi32           = "li";
///
enum _cstr SCNi64           = "lli";

///
enum _cstr SCNiLEAST8       = "hhd";
///
enum _cstr SCNiLEAST16      = "hi";
///
enum _cstr SCNiLEAST32      = "li";
///
enum _cstr SCNiLEAST64      = "lli";

///
enum _cstr SCNiFAST8        = "hhd";
///
enum _cstr SCNiFAST16       = "i";
///
enum _cstr SCNiFAST32       = "li";
///
enum _cstr SCNiFAST64       = "lli";

///
enum _cstr SCNo8            = "hhd";
///
enum _cstr SCNo16           = "ho";
///
enum _cstr SCNo32           = "lo";
///
enum _cstr SCNo64           = "llo";

///
enum _cstr SCNoLEAST8       = "hhd";
///
enum _cstr SCNoLEAST16      = "ho";
///
enum _cstr SCNoLEAST32      = "lo";
///
enum _cstr SCNoLEAST64      = "llo";

///
enum _cstr SCNoFAST8        = "hhd";
///
enum _cstr SCNoFAST16       = "o";
///
enum _cstr SCNoFAST32       = "lo";
///
enum _cstr SCNoFAST64       = "llo";

///
enum _cstr SCNu8            = "hhd";
///
enum _cstr SCNu16           = "hu";
///
enum _cstr SCNu32           = "lu";
///
enum _cstr SCNu64           = "llu";

///
enum _cstr SCNuLEAST8       = "hhd";
///
enum _cstr SCNuLEAST16      = "hu";
///
enum _cstr SCNuLEAST32      = "lu";
///
enum _cstr SCNuLEAST64      = "llu";

///
enum _cstr SCNuFAST8        = "hhd";
///
enum _cstr SCNuFAST16       = "u";
///
enum _cstr SCNuFAST32       = "lu";
///
enum _cstr SCNuFAST64       = "llu";

///
enum _cstr SCNx8            = "hhd";
///
enum _cstr SCNx16           = "hx";
///
enum _cstr SCNx32           = "lx";
///
enum _cstr SCNx64           = "llx";

///
enum _cstr SCNxLEAST8       = "hhd";
///
enum _cstr SCNxLEAST16      = "hx";
///
enum _cstr SCNxLEAST32      = "lx";
///
enum _cstr SCNxLEAST64      = "llx";

///
enum _cstr SCNxFAST8        = "hhd";
///
enum _cstr SCNxFAST16       = "x";
///
enum _cstr SCNxFAST32       = "lx";
///
enum _cstr SCNxFAST64       = "llx";

version (D_LP64)
{
    ///
    enum _cstr PRIdMAX      = PRId64;
    ///
    enum _cstr PRIiMAX      = PRIi64;
    ///
    enum _cstr PRIoMAX      = PRIo64;
    ///
    enum _cstr PRIuMAX      = PRIu64;
    ///
    enum _cstr PRIxMAX      = PRIx64;
    ///
    enum _cstr PRIXMAX      = PRIX64;

    ///
    enum _cstr SCNdMAX      = SCNd64;
    ///
    enum _cstr SCNiMAX      = SCNi64;
    ///
    enum _cstr SCNoMAX      = SCNo64;
    ///
    enum _cstr SCNuMAX      = SCNu64;
    ///
    enum _cstr SCNxMAX      = SCNx64;

    ///
    enum _cstr PRIdPTR      = PRId64;
    ///
    enum _cstr PRIiPTR      = PRIi64;
    ///
    enum _cstr PRIoPTR      = PRIo64;
    ///
    enum _cstr PRIuPTR      = PRIu64;
    ///
    enum _cstr PRIxPTR      = PRIx64;
    ///
    enum _cstr PRIXPTR      = PRIX64;

    ///
    enum _cstr SCNdPTR      = SCNd64;
    ///
    enum _cstr SCNiPTR      = SCNi64;
    ///
    enum _cstr SCNoPTR      = SCNo64;
    ///
    enum _cstr SCNuPTR      = SCNu64;
    ///
    enum _cstr SCNxPTR      = SCNx64;
}
else
{
    ///
    enum _cstr PRIdMAX      = PRId32;
    ///
    enum _cstr PRIiMAX      = PRIi32;
    ///
    enum _cstr PRIoMAX      = PRIo32;
    ///
    enum _cstr PRIuMAX      = PRIu32;
    ///
    enum _cstr PRIxMAX      = PRIx32;
    ///
    enum _cstr PRIXMAX      = PRIX32;

    ///
    enum _cstr SCNdMAX      = SCNd32;
    ///
    enum _cstr SCNiMAX      = SCNi32;
    ///
    enum _cstr SCNoMAX      = SCNo32;
    ///
    enum _cstr SCNuMAX      = SCNu32;
    ///
    enum _cstr SCNxMAX      = SCNx32;

    ///
    enum _cstr PRIdPTR      = PRId32;
    ///
    enum _cstr PRIiPTR      = PRIi32;
    ///
    enum _cstr PRIoPTR      = PRIo32;
    ///
    enum _cstr PRIuPTR      = PRIu32;
    ///
    enum _cstr PRIxPTR      = PRIx32;
    ///
    enum _cstr PRIXPTR      = PRIX32;

    ///
    enum _cstr SCNdPTR      = SCNd32;
    ///
    enum _cstr SCNiPTR      = SCNi32;
    ///
    enum _cstr SCNoPTR      = SCNo32;
    ///
    enum _cstr SCNuPTR      = SCNu32;
    ///
    enum _cstr SCNxPTR      = SCNx32;
}

///
intmax_t  imaxabs(intmax_t j);
///
imaxdiv_t imaxdiv(intmax_t numer, intmax_t denom);
///
intmax_t  strtoimax(in char* nptr, char** endptr, int base);
///
uintmax_t strtoumax(in char* nptr, char** endptr, int base);
///
intmax_t  wcstoimax(in wchar_t* nptr, wchar_t** endptr, int base);
///
uintmax_t wcstoumax(in wchar_t* nptr, wchar_t** endptr, int base);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_limits.h.html, _limits.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_limits.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.limits;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

private import core.stdc.config;

extern (C):
@trusted: // Constants only.
nothrow:
@nogc:

//
// Numerical limits
//

///
enum CHAR_BIT       = 8;
///
enum SCHAR_MIN      = byte.min;
///
enum SCHAR_MAX      = byte.max;
///
enum UCHAR_MAX      = ubyte.max;
///
enum CHAR_MIN       = char.min;
///
enum CHAR_MAX       = char.max;
///
enum MB_LEN_MAX     = 2;
///
enum SHRT_MIN       = short.min;
///
enum SHRT_MAX       = short.max;
///
enum USHRT_MAX      = ushort.max;
///
enum INT_MIN        = int.min;
///
enum INT_MAX        = int.max;
///
enum UINT_MAX       = uint.max;
///
enum LONG_MIN       = c_long.min;
///
enum LONG_MAX       = c_long.max;
///
enum ULONG_MAX      = c_ulong.max;
///
enum LLONG_MIN      = long.min;
///
enum LLONG_MAX      = long.max;
///
enum ULLONG_MAX     = ulong.max;

//
// File system limits
//

version (Darwin)
{
    ///
    enum MAX_CANON      = 1024;
    ///
    enum MAX_INPUT      = 1024;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 512;
}

version (DragonFlyBSD)
{
    ///
    enum MAX_CANON      = 255;
    ///
    enum MAX_INPUT      = 255;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 512;
}
else version (FreeBSD)
{
    ///
    enum MAX_CANON      = 255;
    ///
    enum MAX_INPUT      = 255;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 512;
}
else version (linux)
{
    ///
    enum MAX_CANON      = 255;
    ///
    enum MAX_INPUT      = 255;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 4096;
    ///
    enum PIPE_BUF       = 4096;
}
else version (NetBSD)
{
    ///
    enum MAX_CANON      = 255;
    ///
    enum MAX_INPUT      = 255;
    ///
    enum NAME_MAX       = 511;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 512;
}
else version (OpenBSD)
{
    ///
    enum MAX_CANON      = 255;
    ///
    enum MAX_INPUT      = 255;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 512;
}
else version (Solaris)
{
    ///
    enum MAX_CANON      = 256;
    ///
    enum MAX_INPUT      = 512;
    ///
    enum NAME_MAX       = 255;
    ///
    enum PATH_MAX       = 1024;
    ///
    enum PIPE_BUF       = 5120;
}
else version (Windows)
{
    ///
    enum MAX_CANON      = 256;
    ///
    enum MAX_INPUT      = 256;
    ///
    enum NAME_MAX       = 256;
    ///
    enum PATH_MAX       = 260;
    ///
    enum PIPE_BUF       = 5120;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_locale.h.html, _locale.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_locale.d)
 * Standards: ISO/IEC 9899:1999 (E)
 */

module core.stdc.locale;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

extern (C):
@trusted: // Only setlocale operates on C strings.
nothrow:
@nogc:

///
struct lconv
{
    char* decimal_point;
    char* thousands_sep;
    char* grouping;
    char* int_curr_symbol;
    char* currency_symbol;
    char* mon_decimal_point;
    char* mon_thousands_sep;
    char* mon_grouping;
    char* positive_sign;
    char* negative_sign;
    byte  int_frac_digits;
    byte  frac_digits;
    byte  p_cs_precedes;
    byte  p_sep_by_space;
    byte  n_cs_precedes;
    byte  n_sep_by_space;
    byte  p_sign_posn;
    byte  n_sign_posn;
    byte  int_p_cs_precedes;
    byte  int_p_sep_by_space;
    byte  int_n_cs_precedes;
    byte  int_n_sep_by_space;
    byte  int_p_sign_posn;
    byte  int_n_sign_posn;
}

version (CRuntime_Glibc)
{
    ///
    enum LC_CTYPE          = 0;
    ///
    enum LC_NUMERIC        = 1;
    ///
    enum LC_TIME           = 2;
    ///
    enum LC_COLLATE        = 3;
    ///
    enum LC_MONETARY       = 4;
    ///
    enum LC_MESSAGES       = 5;
    ///
    enum LC_ALL            = 6;
    ///
    enum LC_PAPER          = 7;  // non-standard
    ///
    enum LC_NAME           = 8;  // non-standard
    ///
    enum LC_ADDRESS        = 9;  // non-standard
    ///
    enum LC_TELEPHONE      = 10; // non-standard
    ///
    enum LC_MEASUREMENT    = 11; // non-standard
    ///
    enum LC_IDENTIFICATION = 12; // non-standard
}
else version (Windows)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
}
else version (Darwin)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
    ///
    enum LC_MESSAGES       = 6;
}
else version (FreeBSD)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
    ///
    enum LC_MESSAGES       = 6;
}
else version (NetBSD)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
    ///
    enum LC_MESSAGES       = 6;
}
else version (OpenBSD)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
    ///
    enum LC_MESSAGES       = 6;
}
else version (DragonFlyBSD)
{
    ///
    enum LC_ALL            = 0;
    ///
    enum LC_COLLATE        = 1;
    ///
    enum LC_CTYPE          = 2;
    ///
    enum LC_MONETARY       = 3;
    ///
    enum LC_NUMERIC        = 4;
    ///
    enum LC_TIME           = 5;
    ///
    enum LC_MESSAGES       = 6;
}
else version (CRuntime_Bionic)
{
    enum
    {
        ///
        LC_CTYPE          = 0,
        ///
        LC_NUMERIC        = 1,
        ///
        LC_TIME           = 2,
        ///
        LC_COLLATE        = 3,
        ///
        LC_MONETARY       = 4,
        ///
        LC_MESSAGES       = 5,
        ///
        LC_ALL            = 6,
        ///
        LC_PAPER          = 7,
        ///
        LC_NAME           = 8,
        ///
        LC_ADDRESS        = 9,
        ///
        LC_TELEPHONE      = 10,
        ///
        LC_MEASUREMENT    = 11,
        ///
        LC_IDENTIFICATION = 12,
    }
}
else version (Solaris)
{
    ///
    enum LC_CTYPE       = 0;
    ///
    enum LC_NUMERIC     = 1;
    ///
    enum LC_TIME        = 2;
    ///
    enum LC_COLLATE     = 3;
    ///
    enum LC_MONETARY    = 4;
    ///
    enum LC_MESSAGES    = 5;
    ///
    enum LC_ALL         = 6;
}
else version (CRuntime_Musl)
{
    ///
    enum LC_CTYPE          = 0;
    ///
    enum LC_NUMERIC        = 1;
    ///
    enum LC_TIME           = 2;
    ///
    enum LC_COLLATE        = 3;
    ///
    enum LC_MONETARY       = 4;
    ///
    enum LC_MESSAGES       = 5;
    ///
    enum LC_ALL            = 6;
}
else version (CRuntime_UClibc)
{
    ///
    enum LC_CTYPE          = 0;
    ///
    enum LC_NUMERIC        = 1;
    ///
    enum LC_TIME           = 2;
    ///
    enum LC_COLLATE        = 3;
    ///
    enum LC_MONETARY       = 4;
    ///
    enum LC_MESSAGES       = 5;
    ///
    enum LC_ALL            = 6;
    ///
    enum LC_PAPER          = 7;
    ///
    enum LC_NAME           = 8;
    ///
    enum LC_ADDRESS        = 9;
    ///
    enum LC_TELEPHONE      = 10;
    ///
    enum LC_MEASUREMENT    = 11;
    ///
    enum LC_IDENTIFICATION = 12;
}
else
{
    static assert(false, "Unsupported platform");
}

///
@system char*  setlocale(int category, in char* locale);
///
lconv* localeconv();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * D header file for C99.
 *
 * $(C_HEADER_DESCRIPTION pubs.opengroup.org/onlinepubs/009695399/basedefs/_math.h.html, _math.h)
 *
 * Copyright: Copyright Sean Kelly 2005 - 2012.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Sean Kelly
 * Source:    $(DRUNTIMESRC core/stdc/_math.d)
 */

module core.stdc.math;

private import core.stdc.config;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (ARM)     version = ARM_Any;
version (AArch64) version = ARM_Any;
version (HPPA)    version = HPPA_Any;
version (MIPS32)  version = MIPS_Any;
version (MIPS64)  version = MIPS_Any;
version (PPC)     version = PPC_Any;
version (PPC64)   version = PPC_Any;
version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;
version (S390)    version = IBMZ_Any;
version (SPARC)   version = SPARC_Any;
version (SPARC64) version = SPARC_Any;
version (SystemZ) version = IBMZ_Any;
version (X86)     version = X86_Any;
version (X86_64)  version = X86_Any;

extern (C):
@trusted: // All functions here operate on floating point and integer values only.
nothrow:
@nogc:

///
alias float  float_t;
///
alias double double_t;

///
enum double HUGE_VAL      = double.infinity;
///
enum double HUGE_VALF     = float.infinity;
///
enum double HUGE_VALL     = real.infinity;

///
enum float INFINITY       = float.infinity;
///
enum float NAN            = float.nan;

version (FreeBSD)
{
    ///
    enum int FP_ILOGB0        = -int.max;
    ///
    enum int FP_ILOGBNAN      = int.max;
}
else version (NetBSD)
{
    ///
    enum int FP_ILOGB0        = -int.max;
    ///
    enum int FP_ILOGBNAN      = int.max;
}
else version (OpenBSD)
{
    ///
    enum int FP_ILOGB0        = -int.max;
    ///
    enum int FP_ILOGBNAN      = int.max;
}
else version (DragonFlyBSD)
{
    ///
    enum int FP_ILOGB0        = -int.max;
    ///
    enum int FP_ILOGBNAN      = int.max;
}
else version (CRuntime_Bionic)
{
    ///
    enum int FP_ILOGB0        = -int.max;
    ///
    enum int FP_ILOGBNAN      = int.max;
}
else version (CRuntime_UClibc)
{
    version (X86)
    {
        ///
        enum int FP_ILOGB0        = int.min;
        ///
        enum int FP_ILOGBNAN      = int.min;
    }
    else version (X86_64)
    {
        ///
        enum int FP_ILOGB0        = int.min;
        ///
        enum int FP_ILOGBNAN      = int.min;
    }
    else version (MIPS32)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (ARM)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else version (CRuntime_Glibc)
{
    version (X86_Any)
    {
        ///
        enum int FP_ILOGB0        = int.min;
        ///
        enum int FP_ILOGBNAN      = int.min;
    }
    else version (ARM_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (HPPA_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (MIPS_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (PPC_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (RISCV_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (SPARC_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else version (IBMZ_Any)
    {
        ///
        enum int FP_ILOGB0        = -int.max;
        ///
        enum int FP_ILOGBNAN      = int.max;
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }
}
else
{
    ///
    enum int FP_ILOGB0        = int.min;
    ///
    enum int FP_ILOGBNAN      = int.min;
}

///
enum int MATH_ERRNO       = 1;
///
enum int MATH_ERREXCEPT   = 2;
///
enum int math_errhandling = MATH_ERRNO | MATH_ERREXCEPT;

version (none)
{
    //
    // these functions are all macros in C
    //

    //int fpclassify(real-floating x);
    pure int fpclassify(float x);
    pure int fpclassify(double x);
    pure int fpclassify(real x);

    //int isfinite(real-floating x);
    pure int isfinite(float x);
    pure int isfinite(double x);
    pure int isfinite(real x);

    //int isinf(real-floating x);
    pure int isinf(float x);
    pure int isinf(double x);
    pure int isinf(real x);

    //int isnan(real-floating x);
    pure int isnan(float x);
    pure int isnan(double x);
    pure int isnan(real x);

    //int isnormal(real-floating x);
    pure int isnormal(float x);
    pure int isnormal(double x);
    pure int isnormal(real x);

    //int signbit(real-floating x);
    pure int signbit(float x);
    pure int signbit(double x);
    pure int signbit(real x);

    //int isgreater(real-floating x, real-floating y);
    pure int isgreater(float x, float y);
    pure int isgreater(double x, double y);
    pure int isgreater(real x, real y);

    //int isgreaterequal(real-floating x, real-floating y);
    pure int isgreaterequal(float x, float y);
    pure int isgreaterequal(double x, double y);
    pure int isgreaterequal(real x, real y);

    //int isless(real-floating x, real-floating y);
    pure int isless(float x, float y);
    pure int isless(double x, double y);
    pure int isless(real x, real y);

    //int islessequal(real-floating x, real-floating y);
    pure int islessequal(float x, float y);
    pure int islessequal(double x, double y);
    pure int islessequal(real x, real y);

    //int islessgreater(real-floating x, real-floating y);
    pure int islessgreater(float x, float y);
    pure int islessgreater(double x, double y);
    pure int islessgreater(real x, real y);

    //int isunordered(real-floating x, real-floating y);
    pure int isunordered(float x, float y);
    pure int isunordered(double x, double y);
    pure int isunordered(real x, real y);
}

version (CRuntime_DigitalMars)
{
    enum
    {
        ///
        FP_NANS        = 0,
        ///
        FP_NANQ        = 1,
        ///
        FP_INFINITE    = 2,
        ///
        FP_NORMAL      = 3,
        ///
        FP_SUBNORMAL   = 4,
        ///
        FP_ZERO        = 5,
        ///
        FP_NAN         = FP_NANQ,
        ///
        FP_EMPTY       = 6,
        ///
        FP_UNSUPPORTED = 7,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    pure uint __fpclassify_f(float x);
    pure uint __fpclassify_d(double x);
    pure uint __fpclassify_ld(real x);

  extern (D)
  {
    //int fpclassify(real-floating x);
    ///
    pure int fpclassify(float x)     { return __fpclassify_f(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassify_d(x); }
    ///
    pure int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassify_d(x)
            : __fpclassify_ld(x);
    }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return fpclassify(x) >= FP_NORMAL; }
    ///
    pure int isfinite(double x)      { return fpclassify(x) >= FP_NORMAL; }
    ///
    pure int isfinite(real x)        { return fpclassify(x) >= FP_NORMAL; }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(double x)         { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(real x)           { return fpclassify(x) == FP_INFINITE; }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return fpclassify(x) <= FP_NANQ;   }
    ///
    pure int isnan(double x)         { return fpclassify(x) <= FP_NANQ;   }
    ///
    pure int isnan(real x)           { return fpclassify(x) <= FP_NANQ;   }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)     { return (cast(short*)&(x))[1] & 0x8000; }
    ///
    pure int signbit(double x)    { return (cast(short*)&(x))[3] & 0x8000; }
    ///
    pure int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? (cast(short*)&(x))[3] & 0x8000
            : (cast(short*)&(x))[4] & 0x8000;
    }
  }
}
else version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) only
{
  version (all) // legacy stuff to be removed in the future
  {
    enum
    {
        _FPCLASS_SNAN = 1,
        _FPCLASS_QNAN = 2,
        _FPCLASS_NINF = 4,
        _FPCLASS_NN   = 8,
        _FPCLASS_ND   = 0x10,
        _FPCLASS_NZ   = 0x20,
        _FPCLASS_PZ   = 0x40,
        _FPCLASS_PD   = 0x80,
        _FPCLASS_PN   = 0x100,
        _FPCLASS_PINF = 0x200,
    }

    //deprecated("Please use the standard C99 function copysignf() instead.")
    pure float _copysignf(float x, float s);

    //deprecated("_chgsignf(x) is a non-standard MS extension. Please consider using -x instead.")
    pure float _chgsignf(float x);

    version (Win64) // not available in 32-bit runtimes
    {
        //deprecated("Please use the standard C99 function isfinite() instead.")
        pure int _finitef(float x);

        //deprecated("Please use the standard C99 function isnan() instead.")
        pure int _isnanf(float x);

        //deprecated("Please use the standard C99 function fpclassify() instead.")
        pure int _fpclassf(float x);
    }

    //deprecated("Please use the standard C99 function copysign() instead.")
    pure double _copysign(double x, double s);

    //deprecated("_chgsign(x) is a non-standard MS extension. Please consider using -x instead.")
    pure double _chgsign(double x);

    //deprecated("Please use the standard C99 function isfinite() instead.")
    pure int _finite(double x);

    //deprecated("Please use the standard C99 function isnan() instead.")
    pure int _isnan(double x);

    //deprecated("Please use the standard C99 function fpclassify() instead.")
    pure int _fpclass(double x);
  }

    enum
    {
        ///
        FP_SUBNORMAL = -2,
        ///
        FP_NORMAL    = -1,
        ///
        FP_ZERO      =  0,
        ///
        FP_INFINITE  =  1,
        ///
        FP_NAN       =  2,
    }

    pure private short _fdclass(float x);
    pure private short _dclass(double x);

    pure private int _fdsign(float x);
    pure private int _dsign(double x);

  extern(D)
  {
    //int fpclassify(real-floating x);
    ///
    pure int fpclassify()(float x)   { return _fdclass(x); }
    ///
    pure int fpclassify()(double x)  { return _dclass(x);  }
    ///
    pure int fpclassify()(real x)
    {
        static if (real.sizeof == double.sizeof)
            return _dclass(cast(double) x);
        else
            static assert(false, "fpclassify(real) not supported by MS C runtime");
    }

    //int isfinite(real-floating x);
    ///
    pure int isfinite()(float x)     { return fpclassify(x) <= 0; }
    ///
    pure int isfinite()(double x)    { return fpclassify(x) <= 0; }
    ///
    pure int isfinite()(real x)      { return fpclassify(x) <= 0; }

    //int isinf(real-floating x);
    ///
    pure int isinf()(float x)        { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf()(double x)       { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf()(real x)         { return fpclassify(x) == FP_INFINITE; }

    //int isnan(real-floating x);
    version (none) // requires MSVCRT 12+ (VS 2013)
    {
        ///
        pure int isnan(float x)      { return fpclassify(x) == FP_NAN; }
        ///
        pure int isnan(double x)     { return fpclassify(x) == FP_NAN; }
        ///
        pure int isnan(real x)       { return fpclassify(x) == FP_NAN; }
    }
    else // for backward compatibility with older runtimes
    {
        ///
        pure int isnan(float x)      { version (Win64) return _isnanf(x); else return _isnan(cast(double) x); }
        ///
        pure int isnan(double x)     { return _isnan(x); }
        ///
        pure int isnan(real x)       { return _isnan(cast(double) x); }
    }

    //int isnormal(real-floating x);
    ///
    pure int isnormal()(float x)     { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal()(double x)    { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal()(real x)      { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    pure int signbit()(float x)   { return _fdsign(x); }
    ///
    pure int signbit()(double x)  { return _dsign(x);  }
    ///
    pure int signbit()(real x)
    {
        static if (real.sizeof == double.sizeof)
            return _dsign(cast(double) x);
        else
            return (cast(short*)&(x))[4] & 0x8000;
    }
  }
}
else version (CRuntime_Glibc)
{
    enum
    {
        ///
        FP_NAN,
        ///
        FP_INFINITE,
        ///
        FP_ZERO,
        ///
        FP_SUBNORMAL,
        ///
        FP_NORMAL,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    pure int __fpclassifyf(float x);
    pure int __fpclassify(double x);
    pure int __fpclassifyl(real x);

    pure int __finitef(float x);
    pure int __finite(double x);
    pure int __finitel(real x);

    pure int __isinff(float x);
    pure int __isinf(double x);
    pure int __isinfl(real x);

    pure int __isnanf(float x);
    pure int __isnan(double x);
    pure int __isnanl(real x);

    pure int __signbitf(float x);
    pure int __signbit(double x);
    pure int __signbitl(real x);

  extern (D)
  {
    //int fpclassify(real-floating x);
      ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassify(x);  }
    ///
    pure int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassify(x)
            : __fpclassifyl(x);
    }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return __finitef(x); }
    ///
    pure int isfinite(double x)      { return __finite(x);  }
    ///
    pure int isfinite(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __finite(x)
            : __finitel(x);
    }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return __isinff(x);  }
    ///
    pure int isinf(double x)         { return __isinf(x);   }
    ///
    pure int isinf(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isinf(x)
            : __isinfl(x);
    }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return __isnanf(x);  }
    ///
    pure int isnan(double x)         { return __isnan(x);   }
    ///
    pure int isnan(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isnan(x)
            : __isnanl(x);
    }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)     { return __signbitf(x); }
    ///
    pure int signbit(double x)    { return __signbit(x);  }
    ///
    pure int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __signbit(x)
            : __signbitl(x);
    }
  }
}
else version (CRuntime_Musl)
{
    enum
    {
        ///
        FP_NAN,
        ///
        FP_INFINITE,
        ///
        FP_ZERO,
        ///
        FP_SUBNORMAL,
        ///
        FP_NORMAL,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

  pure {
    int __fpclassifyf(float x);
    int __fpclassify(double x);
    int __fpclassifyl(real x);

    int __signbitf(float x);
    int __signbit(double x);
    int __signbitl(real x);
  }

  extern (D) pure
  {
    //int fpclassify(real-floating x);
      ///
    int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    int fpclassify(double x)    { return __fpclassify(x);  }
    ///
    int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassify(x)
            : __fpclassifyl(x);
    }
    private uint __FLOAT_BITS(float __f)
    {
        union __u_t {
            float __f;
            uint __i;
        }
        __u_t __u;
        __u.__f = __f;
        return __u.__i;
    }
    private ulong __DOUBLE_BITS(double __f)
    {
        union __u_t {
            double __f;
            ulong __i;
        }
        __u_t __u;
        __u.__f = __f;
        return __u.__i;
    }

    //int isfinite(real-floating x);
    ///
    int isfinite(float x)       { return (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000; }
    ///
    int isfinite(double x)      { return (__DOUBLE_BITS(x) & -1UL>>1) < 0x7ffUL<<52;  }
    ///
    int isfinite(real x)
    {
        return (real.sizeof == double.sizeof)
            ? isfinite(cast(double)x)
            : __fpclassifyl(x) > FP_INFINITE;
    }

    //int isinf(real-floating x);
    ///
    int isinf(float x)          { return (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000;  }
    ///
    int isinf(double x)         { return (__DOUBLE_BITS(x) & -1UL>>1) == 0x7ffUL<<52;   }
    ///
    int isinf(real x)
    {
        return (real.sizeof == double.sizeof)
            ? isinf(cast(double)x)
            : __fpclassifyl(x) == FP_INFINITE;
    }

    //int isnan(real-floating x);
    ///
    int isnan(float x)          { return (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000;  }
    ///
    int isnan(double x)         { return (__DOUBLE_BITS(x) & -1UL>>1) > 0x7ffUL<<52;   }
    ///
    int isnan(real x)
    {
        return (real.sizeof == double.sizeof)
            ? isnan(cast(double)x)
            : __fpclassifyl(x) == FP_NAN;
    }

    //int isnormal(real-floating x);
    ///
    int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    int signbit(float x)     { return __signbitf(x); }
    ///
    int signbit(double x)    { return __signbit(x);  }
    ///
    int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __signbit(x)
            : __signbitl(x);
    }
  }
}
else version (CRuntime_UClibc)
{
    enum
    {
        ///
        FP_NAN,
        ///
        FP_INFINITE,
        ///
        FP_ZERO,
        ///
        FP_SUBNORMAL,
        ///
        FP_NORMAL,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    int __fpclassifyf(float x);
    int __fpclassify(double x);
    int __fpclassifyl(real x);

    int __finitef(float x);
    int __finite(double x);
    int __finitel(real x);

    int __isinff(float x);
    int __isinf(double x);
    int __isinfl(real x);

    int __isnanf(float x);
    int __isnan(double x);
    int __isnanl(real x);

    int __signbitf(float x);
    int __signbit(double x);
    int __signbitl(real x);

  extern (D)
  {
    ///
    int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    int fpclassify(double x)    { return __fpclassify(x);  }
    ///
    int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassify(x)
            : __fpclassifyl(x);
    }

    ///
    int isfinite(float x)       { return __finitef(x); }
    ///
    int isfinite(double x)      { return __finite(x);  }
    ///
    int isfinite(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __finite(x)
            : __finitel(x);
    }

    ///
    int isinf(float x)          { return __isinff(x);  }
    ///
    int isinf(double x)         { return __isinf(x);   }
    ///
    int isinf(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isinf(x)
            : __isinfl(x);
    }

    ///
    int isnan(float x)          { return __isnanf(x);  }
    ///
    int isnan(double x)         { return __isnan(x);   }
    ///
    int isnan(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isnan(x)
            : __isnanl(x);
    }

    ///
    int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    ///
    int signbit(float x)     { return __signbitf(x); }
    ///
    int signbit(double x)    { return __signbit(x);  }
    ///
    int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __signbit(x)
            : __signbitl(x);
    }
  }
}
else version (MinGW)
{
    enum
    {
        ///
        FP_NAN = 0x0100,
        ///
        FP_NORMAL = 0x0400,
        ///
        FP_INFINITE = FP_NAN | FP_NORMAL,
        ///
        FP_ZERO = 0x0400,
        ///
        FP_SUBNORMAL = FP_NORMAL | FP_ZERO
    }

    pure int __fpclassifyf(float x);
    pure int __fpclassify(double x);
    pure int __fpclassifyl(real x);

    pure int __isnanf(float x);
    pure int __isnan(double x);
    pure int __isnanl(real x);

    pure int __signbitf(float x);
    pure int __signbit(double x);
    pure int __signbitl(real x);

  extern (D)
  {
    //int fpclassify(real-floating x);
      ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassify(x);  }
    ///
    pure int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassify(x)
            : __fpclassifyl(x);
    }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return (fpclassify(x) & FP_NORMAL) == 0; }
    ///
    pure int isfinite(double x)      { return (fpclassify(x) & FP_NORMAL) == 0; }
    ///
    pure int isfinite(real x)        { return (fpclassify(x) & FP_NORMAL) == 0; }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(double x)         { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(real x)           { return fpclassify(x) == FP_INFINITE; }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return __isnanf(x);  }
    ///
    pure int isnan(double x)         { return __isnan(x);   }
    ///
    pure int isnan(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isnan(x)
            : __isnanl(x);
    }

    //int isnormal(real-floating x);
    ///
    int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    int signbit(float x)     { return __signbitf(x); }
    ///
    int signbit(double x)    { return __signbit(x);  }
    ///
    int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __signbit(x)
            : __signbitl(x);
    }
  }
}
else version (Darwin)
{
    enum
    {
        ///
        FP_NAN         = 1,
        ///
        FP_INFINITE    = 2,
        ///
        FP_ZERO        = 3,
        ///
        FP_NORMAL      = 4,
        ///
        FP_SUBNORMAL   = 5,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    pure int __fpclassifyf(float x);
    pure int __fpclassifyd(double x);

    pure int __isfinitef(float x);
    pure int __isfinited(double x);

    pure int __isinff(float x);
    pure int __isinfd(double x);

    pure int __isnanf(float x);
    pure int __isnand(double x);

    // __isnormal family exists, but iOS implementation returns wrong results
    // for subnormals

    pure int __signbitf(float x);
    pure int __signbitd(double x);
    pure int __signbitl(real x);

    // Support of OSX < 10.8 needs legacy function names without "l" suffix
    // with exception of __signbitl.  Otherwise could use else version like
    // other Darwins
    version (OSX)
    {
        pure int __fpclassify(real x);
        pure int __isfinite(real x);
        pure int __isinf(real x);
        pure int __isnan(real x);
        alias __fpclassifyl = __fpclassify;
        alias __isfinitel = __isfinite;
        alias __isinfl = __isinf;
        alias __isnanl = __isnan;
    }
    else
    {
        // Available OSX >= 10.8, iOS >= 6.0, all TVOS and WatchOS
        pure int __fpclassifyl(real x);
        pure int __isfinitel(real x);
        pure int __isinfl(real x);
        pure int __isnanl(real x);
    }

  extern (D)
  {
    //int fpclassify(real-floating x);
    ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    ///
    pure int fpclassify(real x)      { return __fpclassifyl(x); }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return __isfinitef(x); }
    ///
    pure int isfinite(double x)      { return __isfinited(x); }
    ///
    pure int isfinite(real x)        { return __isfinitel(x); }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return __isinff(x); }
    ///
    pure int isinf(double x)         { return __isinfd(x); }
    ///
    pure int isinf(real x)           { return __isinfl(x); }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return __isnanf(x); }
    ///
    pure int isnan(double x)         { return __isnand(x); }
    ///
    pure int isnan(real x)           { return __isnanl(x); }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)     { return __signbitf(x); }
    ///
    pure int signbit(double x)    { return __signbitd(x); }
    ///
    pure int signbit(real x)      { return __signbitl(x); }
  }
}
else version (FreeBSD)
{
    enum
    {
        ///
        FP_INFINITE  = 0x01,
        ///
        FP_NAN       = 0x02,
        ///
        FP_NORMAL    = 0x04,
        ///
        FP_SUBNORMAL = 0x08,
        ///
        FP_ZERO      = 0x10,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    pure int __fpclassifyd(double);
    pure int __fpclassifyf(float);
    pure int __fpclassifyl(real);
    pure int __isfinitef(float);
    pure int __isfinite(double);
    pure int __isfinitel(real);
    pure int __isinff(float);
    pure int __isinfl(real);
    pure int __isnanl(real);
    pure int __isnormalf(float);
    pure int __isnormal(double);
    pure int __isnormall(real);
    pure int __signbit(double);
    pure int __signbitf(float);
    pure int __signbitl(real);

  extern (D)
  {
    //int fpclassify(real-floating x);
      ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    ///
    pure int fpclassify(real x)      { return __fpclassifyl(x); }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return __isfinitef(x); }
    ///
    pure int isfinite(double x)      { return __isfinite(x); }
    ///
    pure int isfinite(real x)        { return __isfinitel(x); }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return __isinff(x); }
    ///
    pure int isinf(double x)         { return __isinfl(x); }
    ///
    pure int isinf(real x)           { return __isinfl(x); }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return __isnanl(x); }
    ///
    pure int isnan(double x)         { return __isnanl(x); }
    ///
    pure int isnan(real x)           { return __isnanl(x); }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return __isnormalf(x); }
    ///
    pure int isnormal(double x)      { return __isnormal(x); }
    ///
    pure int isnormal(real x)        { return __isnormall(x); }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)        { return __signbitf(x); }
    ///
    pure int signbit(double x)       { return __signbit(x); }
    ///
    pure int signbit(real x)         { return __signbit(x); }
  }
}
else version (OpenBSD)
{
    enum
    {
        ///
        FP_INFINITE  = 0x01,
        ///
        FP_NAN       = 0x02,
        ///
        FP_NORMAL    = 0x04,
        ///
        FP_SUBNORMAL = 0x08,
        ///
        FP_ZERO      = 0x10,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 1,
        ///
        FP_FAST_FMAF = 1,
        ///
        FP_FAST_FMAL = 1,
    }

    pure int __fpclassifyd(double);
    pure int __fpclassifyf(float);
    pure int __fpclassifyl(real);
    pure int __isfinitef(float);
    pure int __isfinite(double);
    pure int __isfinitel(real);
    pure int __isinff(float);
    pure int __isinfl(real);
    pure int __isnanl(real);
    pure int __isnormalf(float);
    pure int __isnormal(double);
    pure int __isnormall(real);
    pure int __signbit(double);
    pure int __signbitf(float);
    pure int __signbitl(real);

  extern (D)
  {
    //int fpclassify(real-floating x);
      ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    ///
    pure int fpclassify(real x)      { return __fpclassifyl(x); }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return __isfinitef(x); }
    ///
    pure int isfinite(double x)      { return __isfinite(x); }
    ///
    pure int isfinite(real x)        { return __isfinitel(x); }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return __isinff(x); }
    ///
    pure int isinf(double x)         { return __isinfl(x); }
    ///
    pure int isinf(real x)           { return __isinfl(x); }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return __isnanl(x); }
    ///
    pure int isnan(double x)         { return __isnanl(x); }
    ///
    pure int isnan(real x)           { return __isnanl(x); }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return __isnormalf(x); }
    ///
    pure int isnormal(double x)      { return __isnormal(x); }
    ///
    pure int isnormal(real x)        { return __isnormall(x); }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)        { return __signbitf(x); }
    ///
    pure int signbit(double x)       { return __signbit(x); }
    ///
    pure int signbit(real x)         { return __signbit(x); }
  }
}
else version (NetBSD)
{
    enum
    {
        ///
        FP_INFINITE    = 0,
        ///
        FP_NAN         = 1,
        ///
        FP_NORMAL      = 2,
        ///
        FP_SUBNORMAL   = 3,
        ///
        FP_ZERO        = 4,
    }

    enum
    {
        ///
        FP_FAST_FMA  = 0,
        ///
        FP_FAST_FMAF = 0,
        ///
        FP_FAST_FMAL = 0,
    }

    pure uint __fpclassifyf(float x);
    pure uint __fpclassifyd(double x);
    pure uint __fpclassifyl(real x);

  extern (D)
  {
    //int fpclassify(real-floating x);
    ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    ///
    pure int fpclassify(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __fpclassifyd(x)
            : __fpclassifyl(x);
    }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return fpclassify(x) >= FP_NORMAL; }
    ///
    pure int isfinite(double x)      { return fpclassify(x) >= FP_NORMAL; }
    ///
    pure int isfinite(real x)        { return fpclassify(x) >= FP_NORMAL; }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(double x)         { return fpclassify(x) == FP_INFINITE; }
    ///
    pure int isinf(real x)           { return fpclassify(x) == FP_INFINITE; }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return fpclassify(x) == FP_NAN;   }
    ///
    pure int isnan(double x)         { return fpclassify(x) == FP_NAN;   }
    ///
    pure int isnan(real x)           { return fpclassify(x) == FP_NAN;   }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(double x)      { return fpclassify(x) == FP_NORMAL; }
    ///
    pure int isnormal(real x)        { return fpclassify(x) == FP_NORMAL; }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)     { return (cast(short*)&(x))[1] & 0x8000; }
    ///
    pure int signbit(double x)    { return (cast(short*)&(x))[3] & 0x8000; }
    ///
    pure int signbit(real x)
    {
        return (real.sizeof == double.sizeof)
            ? (cast(short*)&(x))[3] & 0x8000
            : (cast(short*)&(x))[4] & 0x8000;
    }
  }
}
else version (DragonFlyBSD)
{
    enum
    {
        FP_INFINITE  = 0x01,
        FP_NAN       = 0x02,
        FP_NORMAL    = 0x04,
        FP_SUBNORMAL = 0x08,
        FP_ZERO      = 0x10,
    }

    /*
     * /usr/include/math.h : martynas@openbsd believes only F version is true.
       enum FP_FAST_FMA  = 1;
       enum FP_FAST_FMAL = 1;
     */
    enum  FP_FAST_FMAF = 1;

    pure int __fpclassifyd(double);
    pure int __fpclassifyf(float);
    pure int __fpclassifyl(real);
    pure int __isfinitef(float);
    pure int __isfinite(double);
    pure int __isfinitel(real);
    pure int __isinff(float);
    pure int __isinf(double);
    pure int __isinfl(real);
    pure int __isnanf(float);
    pure int __isnan(double);
    pure int __isnanl(real);
    pure int __isnormalf(float);
    pure int __isnormal(double);
    pure int __isnormall(real);
    pure int __signbit(double);
    pure int __signbitf(float);
    pure int __signbitl(real);

  extern (D)
  {
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    pure int fpclassify(real x)      { return __fpclassifyl(x); }

    pure int isfinite(float x)       { return __isfinitef(x); }
    pure int isfinite(double x)      { return __isfinite(x); }
    pure int isfinite(real x)        { return __isfinitel(x); }

    pure int isinf(float x)          { return __isinff(x); }
    pure int isinf(double x)         { return __isinf(x); }
    pure int isinf(real x)           { return __isinfl(x); }

    pure int isnan(float x)          { return __isnanf(x); }
    pure int isnan(double x)         { return __isnan(x); }
    pure int isnan(real x)           { return __isnanl(x); }

    pure int isnormal(float x)       { return __isnormalf(x); }
    pure int isnormal(double x)      { return __isnormal(x); }
    pure int isnormal(real x)        { return __isnormall(x); }

    pure int signbit(float x)        { return __signbitf(x); }
    pure int signbit(double x)       { return __signbit(x); }
    pure int signbit(real x)         { return __signbitl(x); }
  }
}
else version (Solaris)
{
    pure int __isnanf(float x);
    pure int __isnan(double x);
    pure int __isnanl(real x);

  extern (D)
  {
    //int isnan(real-floating x);
      ///
    pure int isnan(float x)          { return __isnanf(x);  }
    ///
    pure int isnan(double x)         { return __isnan(x);   }
    ///
    pure int isnan(real x)
    {
        return (real.sizeof == double.sizeof)
            ? __isnan(x)
            : __isnanl(x);
    }
  }
}
else version (CRuntime_Bionic)
{
    enum
    {
        ///
        FP_INFINITE  = 0x01,
        ///
        FP_NAN       = 0x02,
        ///
        FP_NORMAL    = 0x04,
        ///
        FP_SUBNORMAL = 0x08,
        ///
        FP_ZERO      = 0x10,
    }

    ///
    enum FP_FAST_FMAF;

    pure int __fpclassifyd(double);
    pure int __fpclassifyf(float);
    pure int __fpclassifyl(real);

    pure int __isfinitef(float);
    pure int __isfinite(double);
    pure int __isfinitel(real);

    pure int __isinff(float);
    pure int __isinf(double);
    pure int __isinfl(real);

    pure int isnanf(float);
    pure int isnan(double);
    pure int __isnanl(real);

    pure int __isnormalf(float);
    pure int __isnormal(double);
    pure int __isnormall(real);

    pure int __signbit(double);
    pure int __signbitf(float);
    pure int __signbitl(real);

  extern (D)
  {
    //int fpclassify(real-floating x);
      ///
    pure int fpclassify(float x)     { return __fpclassifyf(x); }
    ///
    pure int fpclassify(double x)    { return __fpclassifyd(x); }
    ///
    pure int fpclassify(real x)      { return __fpclassifyl(x); }

    //int isfinite(real-floating x);
    ///
    pure int isfinite(float x)       { return __isfinitef(x); }
    ///
    pure int isfinite(double x)      { return __isfinite(x); }
    ///
    pure int isfinite(real x)        { return __isfinitel(x); }

    //int isinf(real-floating x);
    ///
    pure int isinf(float x)          { return __isinff(x); }
    ///
    pure int isinf(double x)         { return __isinf(x); }
    ///
    pure int isinf(real x)           { return __isinfl(x); }

    //int isnan(real-floating x);
    ///
    pure int isnan(float x)          { return isnanf(x); }
    ///
    pure int isnan(real x)           { return __isnanl(x); }

    //int isnormal(real-floating x);
    ///
    pure int isnormal(float x)       { return __isnormalf(x); }
    ///
    pure int isnormal(double x)      { return __isnormal(x); }
    ///
    pure int isnormal(real x)        { return __isnormall(x); }

    //int signbit(real-floating x);
    ///
    pure int signbit(float x)        { return __signbitf(x); }
    ///
    pure int signbit(double x)       { return __signbit(x); }
    ///
    pure int signbit(real x)         { return __signbitl(x); }
  }
}

extern (D)
{
    //int isgreater(real-floating x, real-floating y);
    ///
    pure int isgreater(float x, float y)        { return x > y && !isunordered(x, y); }
    ///
    pure int isgreater(double x, double y)      { return x > y && !isunordered(x, y); }
    ///
    pure int isgreater(real x, real y)          { return x > y && !isunordered(x, y); }

    //int isgreaterequal(real-floating x, real-floating y);
    ///
    pure int isgreaterequal(float x, float y)   { return x >= y && !isunordered(x, y); }
    ///
    pure int isgreaterequal(double x, double y) { return x >= y && !isunordered(x, y); }
    ///
    pure int isgreaterequal(real x, real y)     { return x >= y && !isunordered(x, y); }

    //int isless(real-floating x, real-floating y);
    ///
    pure int isless(float x, float y)           { return x < y && !isunordered(x, y); }
    ///
    pure int isless(double x, double y)         { return x < y && !isunordered(x, y); }
    ///
    pure int isless(real x, real y)             { return x < y && !isunordered(x, y); }

    //int islessequal(real-floating x, real-floating y);
    ///
    pure int islessequal(float x, float y)      { return x <= y && !isunordered(x, y); }
    ///
    pure int islessequal(double x, double y)    { return x <= y && !isunordered(x, y); }
    ///
    pure int islessequal(real x, real y)        { return x <= y && !isunordered(x, y); }

    //int islessgreater(real-floating x, real-floating y);
    ///
    pure int islessgreater(float x, float y)    { return x != y && !isunordered(x, y); }
    ///
    pure int islessgreater(double x, double y)  { return x != y && !isunordered(x, y); }
    ///
    pure int islessgreater(real x, real y)      { return x != y && !isunordered(x, y); }

    //int isunordered(real-floating x, real-floating y);
    ///
    pure int isunordered(float x, float y)      { return isnan(x) || isnan(y); }
    ///
    pure int isunordered(double x, double y)    { return isnan(x) || isnan(y); }
    ///
    pure int isunordered(real x, real y)        { return isnan(x) || isnan(y); }
}

/* MS define some functions inline.
 * Additionally, their *l functions work with a 64-bit long double and are thus
 * useless for 80-bit D reals. So we use our own wrapper implementations working
 * internally with reduced 64-bit precision.
 * This also enables relaxing real to 64-bit double.
 */
version (CRuntime_Microsoft) // fully supported since MSVCRT 12 (VS 2013) only
{
    ///
    double  acos(double x);
    ///
    float   acosf(float x);
    ///
    extern(D) real acosl()(real x)   { return acos(cast(double) x); }

    ///
    double  asin(double x);
    ///
    float   asinf(float x);
    ///
    extern(D) real asinl()(real x)   { return asin(cast(double) x); }

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);
    ///
    pure extern(D) real atanl()(real x)   { return atan(cast(double) x); }

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);
    ///
    extern(D) real atan2l()(real y, real x) { return atan2(cast(double) y, cast(double) x); }

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);
    ///
    extern(D) pure real cosl()(real x)    { return cos(cast(double) x); }

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);
    ///
    extern(D) pure real sinl()(real x)    { return sin(cast(double) x); }

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);
    ///
    extern(D) pure real tanl()(real x)    { return tan(cast(double) x); }

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    ///
    extern(D) real acoshl()(real x)  { return acosh(cast(double) x); }

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    ///
    pure extern(D) real asinhl()(real x)  { return asinh(cast(double) x); }

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    ///
    extern(D) real atanhl()(real x)  { return atanh(cast(double) x); }

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    ///
    extern(D) real coshl()(real x)   { return cosh(cast(double) x); }

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    ///
    extern(D) real sinhl()(real x)   { return sinh(cast(double) x); }

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);
    ///
    extern(D) pure real tanhl()(real x)   { return tanh(cast(double) x); }

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    extern(D) real expl()(real x)    { return exp(cast(double) x); }

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);
    ///
    extern(D) real exp2l()(real x)   { return exp2(cast(double) x); }

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    ///
    extern(D) real expm1l()(real x)  { return expm1(cast(double) x); }

    ///
    pure double  frexp(double value, int* exp);
    ///
    extern(D) pure float frexpf()(float value, int* exp) { return cast(float) frexp(value, exp); }
    ///
    extern(D) pure real  frexpl()(real value, int* exp)  { return frexp(cast(double) value, exp); }

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);
    ///
    extern(D) int ilogbl()(real x)   { return ilogb(cast(double) x); }

    ///
    double  ldexp(double x, int exp);
    ///
    extern(D) float ldexpf()(float x, int exp) { return cast(float) ldexp(x, exp); }
    ///
    extern(D) real  ldexpl()(real x, int exp)  { return ldexp(cast(double) x, exp); }

    ///
    double  log(double x);
    ///
    float   logf(float x);
    ///
    extern(D) real logl()(real x)    { return log(cast(double) x); }

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    ///
    extern(D) real log10l()(real x)  { return log10(cast(double) x); }

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    ///
    extern(D) real log1pl()(real x)  { return log1p(cast(double) x); }

    ///
    double  log2(double x);
    ///
    float   log2f(float x);
    ///
    extern(D) real log2l()(real x)   { return log2(cast(double) x); }

    ///
    double  logb(double x);
    ///
    float   logbf(float x);
    ///
    extern(D) real logbl()(real x)   { return logb(cast(double) x); }

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);
    ///
    extern(D) pure real modfl()(real value, real* iptr)
    {
        double i;
        double r = modf(cast(double) value, &i);
        *iptr = i;
        return r;
    }

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);
    ///
    extern(D) real scalbnl()(real x, int n) { return scalbn(cast(double) x, n); }

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);
    ///
    extern(D) real scalblnl()(real x, c_long n) { return scalbln(cast(double) x, n); }

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    ///
    extern(D) pure real cbrtl()(real x)   { return cbrt(cast(double) x); }

    ///
    pure double  fabs(double x);
    ///
    extern(D) pure float fabsf()(float x) { return cast(float) fabs(x); }
    ///
    extern(D) pure real  fabsl()(real x)  { return fabs(cast(double) x); }

    private double _hypot(double x, double y);
    private float  _hypotf(float x, float y);
    ///
    extern(D) double hypot(double x, double y) { return _hypot(x, y); }
    ///
    extern(D) float  hypotf(float x, float y)  { return _hypotf(x, y); }
    ///
    extern(D) real   hypotl(real x, real y)    { return _hypot(cast(double) x, cast(double) y); }

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    ///
    extern(D) real powl()(real x, real y) { return pow(cast(double) x, cast(double) y); }

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);
    ///
    extern(D) real sqrtl()(real x)   { return sqrt(cast(double) x); }

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    extern(D) pure real erfl()(real x)    { return erf(cast(double) x); }

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    extern(D) real erfcl()(real x)   { return erfc(cast(double) x); }

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    extern(D) real lgammal()(real x) { return lgamma(cast(double) x); }

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    extern(D) real tgammal()(real x) { return tgamma(cast(double) x); }

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);
    ///
    extern(D) pure real ceill()(real x)   { return ceil(cast(double) x); }

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);
    ///
    extern(D) pure real floorl()(real x)  { return floor(cast(double) x); }

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);
    ///
    extern(D) pure real nearbyintl()(real x) { return nearbyint(cast(double) x); }

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);
    ///
    extern(D) pure real rintl()(real x)   { return rint(cast(double) x); }

  ¸+  ¹+  º+  »+  ¼+  ½+  ¾+  ¿+  À+  Á+  Â+  Ã+  Ä+  Å+  Æ+  Ç+                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);
    ///
    extern(D) c_long lrintl()(real x) { return lrint(cast(double) x); }

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    ///
    extern(D) long llrintl()(real x) { return llrint(cast(double) x); }

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);
    ///
    extern(D) pure real roundl()(real x)  { return round(cast(double) x); }

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);
    ///
    extern(D) c_long lroundl()(real x) { return lround(cast(double) x); }

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);
    ///
    extern(D) long llroundl()(real x) { return llround(cast(double) x); }

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);
    ///
    extern(D) pure real truncl()(real x)  { return trunc(cast(double) x); }

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);
    ///
    extern(D) real fmodl()(real x, real y) { return fmod(cast(double) x, cast(double) y); }

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);
    ///
    extern(D) real remainderl()(real x, real y) { return remainder(cast(double) x, cast(double) y); }

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);
    ///
    extern(D) real remquol()(real x, real y, int* quo) { return remquo(cast(double) x, cast(double) y, quo); }

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);
    ///
    extern(D) pure real copysignl()(real x, real y) { return copysign(cast(double) x, cast(double) y); }

    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    extern(D) pure real nanl()(char* tagp) { return nan(tagp); }

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);
    ///
    extern(D) real nextafterl()(real x, real y) { return nextafter(cast(double) x, cast(double) y); }

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);
    ///
    extern(D) real nexttowardl()(real x, real y) { return nexttoward(cast(double) x, cast(double) y); }

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);
    ///
    extern(D) real fdiml()(real x, real y) { return fdim(cast(double) x, cast(double) y); }

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);
    ///
    extern(D) pure real fmaxl()(real x, real y) { return fmax(cast(double) x, cast(double) y); }

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);
    ///
    extern(D) pure real fminl()(real x, real y) { return fmin(cast(double) x, cast(double) y); }

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
    ///
    extern(D) pure real fmal()(real x, real y, real z) { return fma(cast(double) x, cast(double) y, cast(double) z); }
}
/* NOTE: freebsd < 8-CURRENT doesn't appear to support *l, but we can
 *       approximate.
 * A lot of them were added in 8.0-RELEASE, and so a lot of these workarounds
 * should then be removed.
 */
// NOTE: FreeBSD 8.0-RELEASE doesn't support log2* nor these *l functions:
//         acoshl, asinhl, atanhl, coshl, sinhl, tanhl, cbrtl, powl, expl,
//         expm1l, logl, log1pl, log10l, erfcl, erfl, lgammal, tgammal;
//       but we can approximate.
else version (FreeBSD)
{
  version (none) // < 8-CURRENT
  {
    extern (D)
    {
        real    acosl(real x) { return acos(x); }
        real    asinl(real x) { return asin(x); }
        pure real    atanl(real x) { return atan(x); }
        real    atan2l(real y, real x) { return atan2(y, x); }
        pure real    cosl(real x) { return cos(x); }
        pure real    sinl(real x) { return sin(x); }
        pure real    tanl(real x) { return tan(x); }
        real    exp2l(real x) { return exp2(x); }
        pure real    frexpl(real value, int* exp) { return frexp(value, exp); }
        int     ilogbl(real x) { return ilogb(x); }
        real    ldexpl(real x, int exp) { return ldexp(x, exp); }
        real    logbl(real x) { return logb(x); }
        //real    modfl(real value, real *iptr); // nontrivial conversion
        real    scalbnl(real x, int n) { return scalbn(x, n); }
        real    scalblnl(real x, c_long n) { return scalbln(x, n); }
        pure real    fabsl(real x) { return fabs(x); }
        real    hypotl(real x, real y) { return hypot(x, y); }
        real    sqrtl(real x) { return sqrt(x); }
        pure real    ceill(real x) { return ceil(x); }
        pure real    floorl(real x) { return floor(x); }
        pure real    nearbyintl(real x) { return nearbyint(x); }
        pure real    rintl(real x) { return rint(x); }
        c_long  lrintl(real x) { return lrint(x); }
        pure real    roundl(real x) { return round(x); }
        c_long  lroundl(real x) { return lround(x); }
        long    llroundl(real x) { return llround(x); }
        pure real    truncl(real x) { return trunc(x); }
        real    fmodl(real x, real y) { return fmod(x, y); }
        real    remainderl(real x, real y) { return remainder(x, y); }
        real    remquol(real x, real y, int* quo) { return remquo(x, y, quo); }
        pure real    copysignl(real x, real y) { return copysign(x, y); }
        //pure double  nan(char* tagp);
        //pure float   nanf(char* tagp);
        //pure real    nanl(char* tagp);
        real    nextafterl(real x, real y) { return nextafter(x, y); }
        real    nexttowardl(real x, real y) { return nexttoward(x, y); }
        real    fdiml(real x, real y) { return fdim(x, y); }
        pure real    fmaxl(real x, real y) { return fmax(x, y); }
        pure real    fminl(real x, real y) { return fmin(x, y); }
        pure real    fmal(real x, real y, real z) { return fma(x, y, z); }
    }
  }
  else
  {
    ///
    real    acosl(real x);
    ///
    real    asinl(real x);
    ///
    pure real    atanl(real x);
    ///
    real    atan2l(real y, real x);
    ///
    pure real    cosl(real x);
    ///
    pure real    sinl(real x);
    ///
    pure real    tanl(real x);
    ///
    real    exp2l(real x);
    ///
    pure real    frexpl(real value, int* exp);
    ///
    int     ilogbl(real x);
    ///
    real    ldexpl(real x, int exp);
    ///
    real    logbl(real x);
    ///
    pure real    modfl(real value, real *iptr);
    ///
    real    scalbnl(real x, int n);
    ///
    real    scalblnl(real x, c_long n);
    ///
    pure real    fabsl(real x);
    ///
    real    hypotl(real x, real y);
    ///
    real    sqrtl(real x);
    ///
    pure real    ceill(real x);
    ///
    pure real    floorl(real x);
    ///
    pure real    nearbyintl(real x);
    ///
    pure real    rintl(real x);
    ///
    c_long  lrintl(real x);
    ///
    pure real    roundl(real x);
    ///
    c_long  lroundl(real x);
    ///
    long    llroundl(real x);
    ///
    pure real    truncl(real x);
    ///
    real    fmodl(real x, real y);
    ///
    real    remainderl(real x, real y);
    ///
    real    remquol(real x, real y, int* quo);
    ///
    pure real    copysignl(real x, real y);
    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    pure real    nanl(char* tagp);
    ///
    real    nextafterl(real x, real y);
    ///
    real    nexttowardl(real x, real y);
    ///
    real    fdiml(real x, real y);
    ///
    pure real    fmaxl(real x, real y);
    ///
    pure real    fminl(real x, real y);
    ///
    pure real    fmal(real x, real y, real z);
  }
  ///
    double  acos(double x);
    ///
    float   acosf(float x);

    ///
    double  asin(double x);
    ///
    float   asinf(float x);

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    ///
    extern(D) real acoshl(real x) { return acosh(x); }

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    ///
    extern(D) pure real asinhl(real x) { return asinh(x); }

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    ///
    extern(D) real atanhl(real x) { return atanh(x); }

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    ///
    extern(D) real coshl(real x) { return cosh(x); }

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    ///
    extern(D) real sinhl(real x) { return sinh(x); }

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);
    ///
    extern(D) pure real tanhl(real x) { return tanh(x); }

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    extern(D) real expl(real x) { return exp(x); }

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    ///
    extern(D) real expm1l(real x) { return expm1(x); }

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);

    ///
    double  log(double x);
    ///
    float   logf(float x);
    ///
    extern(D) real logl(real x) { return log(x); }

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    ///
    extern(D) real log10l(real x) { return log10(x); }

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    ///
    extern(D) real log1pl(real x) { return log1p(x); }

    private enum real ONE_LN2 = 1 / 0x1.62e42fefa39ef358p-1L;
    ///
    extern(D) double log2(double x) { return log(x) * ONE_LN2; }
    ///
    extern(D) float  log2f(float x) { return logf(x) * ONE_LN2; }
    ///
    extern(D) real   log2l(real x)  { return logl(x) * ONE_LN2; }

    ///
    double  logb(double x);
    ///
    float   logbf(float x);

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    ///
    extern(D) pure real cbrtl(real x) { return cbrt(x); }

    ///
    pure double  fabs(double x);
    ///
    pure float   fabsf(float x);

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    ///
    extern(D) real powl(real x, real y) { return pow(x, y); }

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    extern(D) pure real erfl(real x) { return erf(x); }

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    extern(D) real erfcl(real x) { return erfc(x); }

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    extern(D) real lgammal(real x) { return lgamma(x); }

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    extern(D) real tgammal(real x) { return tgamma(x); }

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    ///
    extern(D) long llrintl(real x) { return llrint(x); }

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
}
else version (NetBSD)
{

    ///
    real    acosl(real x);
    ///
    real    asinl(real x);
    ///
    pure real    atanl(real x);
    ///
    real    atan2l(real y, real x);
    ///
    pure real    cosl(real x);
    ///
    pure real    sinl(real x);
    ///
    pure real    tanl(real x);
    ///
    real    exp2l(real x);
    ///
    pure real    frexpl(real value, int* exp);
    ///
    int     ilogbl(real x);
    ///
    real    ldexpl(real x, int exp);
    ///
    real    logbl(real x);
    ///
    pure real    modfl(real value, real *iptr);
    ///
    real    scalbnl(real x, int n);
    ///
    real    scalblnl(real x, c_long n);
    ///
    pure real    fabsl(real x);
    ///
    real    hypotl(real x, real y);
    ///
    real    sqrtl(real x);
    ///
    pure real    ceill(real x);
    ///
    pure real    floorl(real x);
    ///
    pure real    nearbyintl(real x);
    ///
    pure real    rintl(real x);
    ///
    extern(D) c_long lrintl(real x) { return cast(c_long)rintl(x); }
    ///
    pure real    roundl(real x);
    ///
    extern(D) c_long lroundl(real x) { return cast(c_long)roundl(x);}
    ///
    extern(D) long llroundl(real x) { return cast(long)roundl(x);}
    ///
    pure real    truncl(real x);
    ///
    real    fmodl(real x, real y);
    ///
    real    remainderl(real x, real y)  { return remainder(x,y); }
    ///
    real    remquol(real x, real y, int* quo){ return remquo(x,y,quo); }
    ///
    pure real    copysignl(real x, real y);
    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    pure real    nanl(char* tagp);
    ///
    real    nextafterl(real x, real y);
    ///
    extern(D) real nexttowardl(real x, real y) { return nexttoward(cast(double) x, cast(double) y); }
    ///
    real    fdiml(real x, real y);
    ///
    pure real    fmaxl(real x, real y);
    ///
    pure real    fminl(real x, real y);
    ///
    pure real    fmal(real x, real y, real z);

    ///
    double  acos(double x);
    ///
    float   acosf(float x);

    ///
    double  asin(double x);
    ///
    float   asinf(float x);

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);
    ///
    real    acoshl(real x);

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);
    ///
    pure real    asinhl(real x);

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);
    ///
    real    atanhl(real x);

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);
    ///
    real    coshl(real x);

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);
    ///
    real    sinhl(real x);

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);
    ///
    pure real    tanhl(real x);

    ///
    double  exp(double x);
    ///
    float   expf(float x);
    ///
    real    expl(real x);

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);
    ///
    real    expm1l(real x)  { return expm1(cast(double) x); }

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);

    ///
    double  log(double x);
    ///
    float   logf(float x);
    /// NetBSD has no logl. It is just alias log(double)
    real    logl(real x)
    {
        if (x<0) return real.nan;
        if (x==0) return -real.infinity;
        if (isnan(x) || isinf(x)) return x;
        real rs = 0;
        if (x>double.max)
        {
            immutable MAX = log(double.max);
            for (; x>double.max; x /= double.max)
                rs += MAX;
        }
        else if (x<double.min_normal)
        {
            immutable MIN = log(double.min_normal);
            for (; x<double.min_normal; x /= double.min_normal)
                rs += MIN;
        }
        rs += log(x);
        return rs;
    }

    ///
    double  log10(double x);
    ///
    float   log10f(float x);
    ///NetBSD has no log10l. It is just alias log(double)
    real    log10l(real x)
    {
        if (x<0) return real.nan;
        if (x==0) return -real.infinity;
        if (isnan(x) || isinf(x)) return x;

        real rs = 0;
        if (x>double.max)
        {
            immutable MAX = log10(double.max);
            for (; x>double.max; x /= double.max)
                rs += MAX;
        }
        else if (x<double.min_normal)
        {
            immutable MIN = log10(double.min_normal);
            for (; x<double.min_normal; x /= double.min_normal)
                rs += MIN;
        }
        rs += log10(x);
        return rs;
    }


    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);
    ///
    extern(D) real log1pl(real x) { return log1p(cast(double) x); }

    private enum real ONE_LN2 = 1 / 0x1.62e42fefa39ef358p-1L;
    ///
    extern(D) double log2(double x) { return log(x) * ONE_LN2; }
    ///
    extern(D) float log2f(float x) { return logf(x) * ONE_LN2; }
    ///
    real    log2l(real x)  { return logl(x) * ONE_LN2; }

    ///
    double  logb(double x);
    ///
    float   logbf(float x);

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);
    ///
    pure real    cbrtl(real x);

    ///
    pure double  fabs(double x);
    ///
    pure float   fabsf(float x);

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);
    ///
    real    powl(real x, real y);

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    extern(D) pure real erfl(real x) { return erf(cast(double) x); }

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    real    erfcl(real x)  { return erfc(cast(double) x); }

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    real    lgammal(real x){ return lgamma(x); }

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    real    tgammal(real x){ return tgamma(cast(double) x); }

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);
    ///
    extern(D) long llrintl(real x) { return cast(long)rintl(x); }

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
}
else version (OpenBSD)
{
    ///
    real    acosl(real x);
    ///
    real    asinl(real x);
    ///
    pure real    atanl(real x);
    ///
    real    atan2l(real y, real x);
    ///
    pure real    cosl(real x);
    ///
    pure real    sinl(real x);
    ///
    pure real    tanl(real x);
    ///
    real    acoshl(real x);
    ///
    pure real    asinhl(real x);
    ///
    real    atanhl(real x);
    ///
    real    coshl(real x);
    ///
    real    sinhl(real x);
    ///
    pure real    tanhl(real x);
    ///
    real    expl(real x);
    ///
    real    exp2l(real x);
    ///
    real    expm1l(real x);
    ///
    pure real    frexpl(real value, int* exp);
    ///
    int     ilogbl(real x);
    ///
    real    ldexpl(real x, int exp);
    ///
    real    logbl(real x);
    ///
    real    logb10l(real x);
    ///
    real    logb1pl(real x);
    ///
    real    logb2l(real x);
    ///
    real    logbl(real x);
    ///
    pure real    modfl(real value, real *iptr);
    ///
    real    scalbnl(real x, int n);
    ///
    real    scalblnl(real x, c_long n);
    ///
    pure real    cbrtl(real x);
    ///
    pure real    fabsl(real x);
    ///
    real    hypotl(real x, real y);
    ///
    real    powl(real x, real y);
    ///
    real    sqrtl(real x);
    ///
    pure real    ceill(real x);
    ///
    pure real    floorl(real x);
    ///
    pure real    nearbyintl(real x);
    ///
    pure real    rintl(real x);
    ///
    c_long  lrintl(real x);
    ///
    long    llrintl(real x);
    ///
    pure real    roundl(real x);
    ///
    c_long  lroundl(real x);
    ///
    long    llroundl(real x);
    ///
    pure real    truncl(real x);
    ///
    real    fmodl(real x, real y);
    ///
    real    remainderl(real x, real y);
    ///
    real    remquol(real x, real y, int* quo);
    ///
    pure real    copysignl(real x, real y);
    ///
    pure double  nan(char* tagp);
    ///
    pure float   nanf(char* tagp);
    ///
    pure real    nanl(char* tagp);
    ///
    real    nextafterl(real x, real y);
    ///
    real    nexttowardl(real x, real y);
    ///
    real    fdiml(real x, real y);
    ///
    pure real    fmaxl(real x, real y);
    ///
    pure real    fminl(real x, real y);
    ///
    pure real    fmal(real x, real y, real z);

    ///
    double  acos(double x);
    ///
    float   acosf(float x);

    ///
    double  asin(double x);
    ///
    float   asinf(float x);

    ///
    pure double  atan(double x);
    ///
    pure float   atanf(float x);

    ///
    double  atan2(double y, double x);
    ///
    float   atan2f(float y, float x);

    ///
    pure double  cos(double x);
    ///
    pure float   cosf(float x);

    ///
    pure double  sin(double x);
    ///
    pure float   sinf(float x);

    ///
    pure double  tan(double x);
    ///
    pure float   tanf(float x);

    ///
    double  acosh(double x);
    ///
    float   acoshf(float x);

    ///
    pure double  asinh(double x);
    ///
    pure float   asinhf(float x);

    ///
    double  atanh(double x);
    ///
    float   atanhf(float x);

    ///
    double  cosh(double x);
    ///
    float   coshf(float x);

    ///
    double  sinh(double x);
    ///
    float   sinhf(float x);

    ///
    pure double  tanh(double x);
    ///
    pure float   tanhf(float x);

    ///
    double  exp(double x);
    ///
    float   expf(float x);

    ///
    double  exp2(double x);
    ///
    float   exp2f(float x);
    ///
    real    exp2l(real x);

    ///
    double  expm1(double x);
    ///
    float   expm1f(float x);

    ///
    pure double  frexp(double value, int* exp);
    ///
    pure float   frexpf(float value, int* exp);

    ///
    int     ilogb(double x);
    ///
    int     ilogbf(float x);

    ///
    double  ldexp(double x, int exp);
    ///
    float   ldexpf(float x, int exp);

    ///
    double  log(double x);
    ///
    float   logf(float x);

    ///
    double  log10(double x);
    ///
    float   log10f(float x);

    ///
    double  log1p(double x);
    ///
    float   log1pf(float x);

    ///
    double  log2(double x);
    ///
    float   log2f(float x);
    ///
    real    log2l(real x);

    ///
    double  logb(double x);
    ///
    float   logbf(float x);

    ///
    pure double  modf(double value, double* iptr);
    ///
    pure float   modff(float value, float* iptr);

    ///
    double  scalbn(double x, int n);
    ///
    float   scalbnf(float x, int n);

    ///
    double  scalbln(double x, c_long n);
    ///
    float   scalblnf(float x, c_long n);

    ///
    pure double  cbrt(double x);
    ///
    pure float   cbrtf(float x);

    ///
    pure double  fabs(double x);
    ///
    pure float   fabsf(float x);

    ///
    double  hypot(double x, double y);
    ///
    float   hypotf(float x, float y);

    ///
    double  pow(double x, double y);
    ///
    float   powf(float x, float y);

    ///
    double  sqrt(double x);
    ///
    float   sqrtf(float x);

    ///
    pure double  erf(double x);
    ///
    pure float   erff(float x);
    ///
    pure real    erfl(real x);

    ///
    double  erfc(double x);
    ///
    float   erfcf(float x);
    ///
    real    erfcl(real x);

    ///
    double  lgamma(double x);
    ///
    float   lgammaf(float x);
    ///
    real    lgammal(real x);

    ///
    double  tgamma(double x);
    ///
    float   tgammaf(float x);
    ///
    real    tgammal(real x);

    ///
    pure double  ceil(double x);
    ///
    pure float   ceilf(float x);

    ///
    pure double  floor(double x);
    ///
    pure float   floorf(float x);

    ///
    pure double  nearbyint(double x);
    ///
    pure float   nearbyintf(float x);

    ///
    pure double  rint(double x);
    ///
    pure float   rintf(float x);

    ///
    c_long  lrint(double x);
    ///
    c_long  lrintf(float x);

    ///
    long    llrint(double x);
    ///
    long    llrintf(float x);

    ///
    pure double  round(double x);
    ///
    pure float   roundf(float x);

    ///
    c_long  lround(double x);
    ///
    c_long  lroundf(float x);

    ///
    long    llround(double x);
    ///
    long    llroundf(float x);

    ///
    pure double  trunc(double x);
    ///
    pure float   truncf(float x);

    ///
    double  fmod(double x, double y);
    ///
    float   fmodf(float x, float y);

    ///
    double  remainder(double x, double y);
    ///
    float   remainderf(float x, float y);

    ///
    double  remquo(double x, double y, int* quo);
    ///
    float   remquof(float x, float y, int* quo);

    ///
    pure double  copysign(double x, double y);
    ///
    pure float   copysignf(float x, float y);

    ///
    double  nextafter(double x, double y);
    ///
    float   nextafterf(float x, float y);

    ///
    double  nexttoward(double x, real y);
    ///
    float   nexttowardf(float x, real y);

    ///
    double  fdim(double x, double y);
    ///
    float   fdimf(float x, float y);

    ///
    pure double  fmax(double x, double y);
    ///
    pure float   fmaxf(float x, float y);

    ///
    pure double  fmin(double x, double y);
    ///
    pure float   fminf(float x, float y);

    ///
    pure double  fma(double x, double y, double z);
    ///
    pure float   fmaf(float x, float y, float z);
}
else version (DragonFlyBSD)
{
    /* double */
    double acos(double x);
    double asin(double x);
    pure double atan(double x);
    double atan2(double, double);
    pure double cos(double x);
    pure double sin(double x);
    pure double tan(double x);

    double cosh(double x);
    double sinh(double x);
    pure double tanh(double x);

    double exp(double x);
    pure double frexp(double, int *exp);
    double ldexp(double, int exp);
    double log(double x);
    double log10(double x);
    pure double modf(double x, double *iptr);

    double pow(double x, double y);
    double sqrt(double x);

    pure double ceil(double x);
    pure double fabs(double x);
    pure double floor(double x);
    double fmod(double x, double);

    double acosh(double x);
    pure double asinh(double x);
    double atanh(double x);

    double exp2(double x);
    double expm1(double x);
    int ilogb(double x);
    double log1p(double x);
    double log2(double x);
    double logb(double x);
    double scalbn(double x, int n);
    double scalbln(double x, c_long n);

    pure double cbrt(double x);
    double hypot(double x, double y);

    pure double erf(double x);
    double erfc(double x);
    double lgamma(double x);
    double tgamma(double x);

    pure double nearbyint(double x);
    pure double rint(double x);
    c_long lrint(double x);
    long llrint(double x);
    pure double round(double x);
    c_long lround(double x);
    long  llround(double x);
    pure double trunc(double x);

    double remainder(double x , double y);
    double remquo(double x, double y, int * quo);

    pure double copysign(double x, double y);
    pure double nan(const char *);
    double nextafter(double x, double y);
    double nexttoward(double x, real y);

    double fdim(double x, double y);
    pure double fmax(double x, double y);
    pure double fmin(double x, double y);

    pure double fma(double x, double y, double z);

    double j0(double x);
    double j1(double x);
    double jn(int, double);
    double y0(double x);
    double y1(double x);
    double yn(int, double);

    double gamma(double x);
    double scalb(double x, double y);

    double drem(double x, double y);
    int finite(double x);
    double gamma_r(double x, i