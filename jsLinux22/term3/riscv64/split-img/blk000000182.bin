* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (NetBSD)
{
    //http://fxr.watson.org/fxr/source/sys/syslog.h

    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,    /* log the pid with each message */
        LOG_CONS   = 0x02,    /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,    /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,    /* don't delay open */
        LOG_NOWAIT = 0x10,    /* don't wait for console forks: DEPRECATED */
        LOG_PERROR = 0x20,    /* log to stderr as well */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */
        LOG_NTP    = (12<<3), /* NTP subsystem */
        LOG_SECURITY = (13<<3), /* security subsystems (firewalling, etc.) */
        LOG_CONSOLE  = (14<<3), /* /dev/console output */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (DragonFlyBSD)
{
    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,    /* log the pid with each message */
        LOG_CONS   = 0x02,    /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,    /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,    /* don't delay open */
        LOG_NOWAIT = 0x10,    /* don't wait for console forks: DEPRECATED */
        LOG_PERROR = 0x20,    /* log to stderr as well */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */
        LOG_NTP    = (12<<3), /* NTP subsystem */
        LOG_SECURITY = (13<<3), /* security subsystems (firewalling, etc.) */
        LOG_CONSOLE  = (14<<3), /* /dev/console output */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (Solaris)
{
    //http://pubs.opengroup.org/onlinepubs/007904875/basedefs/syslog.h.html

    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID = 0x01,     /* log the pid with each message */
        LOG_CONS   = 0x02,  /* log on the console if errors in sending */
        LOG_NDELAY = 0x08,  /* don't delay open */
        LOG_NOWAIT = 0x10,  /* don't wait for console forks: DEPRECATED */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (CRuntime_UClibc)
{
    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,  /* log the pid with each message */
        LOG_CONS   = 0x02,  /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,  /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,  /* don't delay open */
        LOG_NOWAIT = 0x10,  /* don't wait for console forks: DEPRECATED */
        LOG_PERROR = 0x20,  /* log to stderr as well */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.termios;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for pid_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C):

nothrow:
@nogc:

//
// Required
//
/*
cc_t
speed_t
tcflag_t

NCCS

struct termios
{
    tcflag_t   c_iflag;
    tcflag_t   c_oflag;
    tcflag_t   c_cflag;
    tcflag_t   c_lflag;
    cc_t[NCCS] c_cc;
}

VEOF
VEOL
VERASE
VINTR
VKILL
VMIN
VQUIT
VSTART
VSTOP
VSUSP
VTIME

BRKINT
ICRNL
IGNBRK
IGNCR
IGNPAR
INLCR
INPCK
ISTRIP
IXOFF
IXON
PARMRK

OPOST

B0
B50
B75
B110
B134
B150
B200
B300
B600
B1200
B1800
B2400
B4800
B9600
B19200
B38400

CSIZE
    CS5
    CS6
    CS7
    CS8
CSTOPB
CREAD
PARENB
PARODD
HUPCL
CLOCAL

ECHO
ECHOE
ECHOK
ECHONL
ICANON
IEXTEN
ISIG
NOFLSH
TOSTOP

TCSANOW
TCSADRAIN
TCSAFLUSH

TCIFLUSH
TCIOFLUSH
TCOFLUSH

TCIOFF
TCION
TCOOFF
TCOON

speed_t cfgetispeed(in termios*);
speed_t cfgetospeed(in termios*);
int     cfsetispeed(termios*, speed_t);
int     cfsetospeed(termios*, speed_t);
int     tcdrain(int);
int     tcflow(int, int);
int     tcflush(int, int);
int     tcgetattr(int, termios*);
int     tcsendbreak(int, int);
int     tcsetattr(int, int, in termios*);
*/

version (CRuntime_Glibc)
{
    alias ubyte cc_t;
    alias uint  speed_t;
    alias uint  tcflag_t;

    enum NCCS   = 32;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t       c_line;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VEOF       = 4;
    enum VEOL       = 11;
    enum VERASE     = 2;
    enum VINTR      = 0;
    enum VKILL      = 3;
    enum VMIN       = 6;
    enum VQUIT      = 1;
    enum VSTART     = 8;
    enum VSTOP      = 9;
    enum VSUSP      = 10;
    enum VTIME      = 5;

    enum BRKINT     = 0x0000002; // 0000002
    enum ICRNL      = 0x0000100; // 0000400
    enum IGNBRK     = 0x0000001; // 0000001
    enum IGNCR      = 0x0000080; // 0000200
    enum IGNPAR     = 0x0000004; // 0000004
    enum INLCR      = 0x0000040; // 0000100
    enum INPCK      = 0x0000010; // 0000020
    enum ISTRIP     = 0x0000020; // 0000040
    enum IXOFF      = 0x0001000; // 0010000
    enum IXON       = 0x0000400; // 0002000
    enum PARMRK     = 0x0000008; // 0000010

    enum OPOST      = 0x0000001; // 0000001

    enum B0         = 0x0000000; // 0000000
    enum B50        = 0x0000001; // 0000001
    enum B75        = 0x0000002; // 0000002
    enum B110       = 0x0000003; // 0000003
    enum B134       = 0x0000004; // 0000004
    enum B150       = 0x0000005; // 0000005
    enum B200       = 0x0000006; // 0000006
    enum B300       = 0x0000007; // 0000007
    enum B600       = 0x0000008; // 0000010
    enum B1200      = 0x0000009; // 0000011
    enum B1800      = 0x000000A; // 0000012
    enum B2400      = 0x000000B; // 0000013
    enum B4800      = 0x000000C; // 0000014
    enum B9600      = 0x000000D; // 0000015
    enum B19200     = 0x000000E; // 0000016
    enum B38400     = 0x000000F; // 0000017

    enum CSIZE      = 0x0000030; // 0000060
    enum   CS5      = 0x0000000; // 0000000
    enum   CS6      = 0x0000010; // 0000020
    enum   CS7      = 0x0000020; // 0000040
    enum   CS8      = 0x0000030; // 0000060
    enum CSTOPB     = 0x0000040; // 0000100
    enum CREAD      = 0x0000080; // 0000200
    enum PARENB     = 0x0000100; // 0000400
    enum PARODD     = 0x0000200; // 0001000
    enum HUPCL      = 0x0000400; // 0002000
    enum CLOCAL     = 0x0000800; // 0004000

    enum ECHO       = 0x0000008; // 0000010
    enum ECHOE      = 0x0000010; // 0000020
    enum ECHOK      = 0x0000020; // 0000040
    enum ECHONL     = 0x0000040; // 0000100
    enum ICANON     = 0x0000002; // 0000002
    enum IEXTEN     = 0x0008000; // 0100000
    enum ISIG       = 0x0000001; // 0000001
    enum NOFLSH     = 0x0000080; // 0000200
    enum TOSTOP     = 0x0000100; // 0000400

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 0;
    enum TCOFLUSH   = 1;
    enum TCIOFLUSH  = 2;

    enum TCIOFF     = 2;
    enum TCION      = 3;
    enum TCOOFF     = 0;
    enum TCOON      = 1;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);
}
else version (Darwin)
{
    alias ubyte cc_t;
    alias c_ulong  speed_t;
    alias c_ulong  tcflag_t;

    enum NCCS   = 20;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VEOF       = 0;
    enum VEOL       = 1;
    enum VERASE     = 3;
    enum VINTR      = 8;
    enum VKILL      = 5;
    enum VMIN       = 16;
    enum VQUIT      = 9;
    enum VSTART     = 12;
    enum VSTOP      = 13;
    enum VSUSP      = 10;
    enum VTIME      = 17;

    enum BRKINT     = 0x0000002;
    enum ICRNL      = 0x0000100;
    enum IGNBRK     = 0x0000001;
    enum IGNCR      = 0x0000080;
    enum IGNPAR     = 0x0000004;
    enum INLCR      = 0x0000040;
    enum INPCK      = 0x0000010;
    enum ISTRIP     = 0x0000020;
    enum IXOFF      = 0x0000400;
    enum IXON       = 0x0000200;
    enum PARMRK     = 0x0000008;

    enum OPOST      = 0x0000001;

    enum B0         = 0;
    enum B50        = 50;
    enum B75        = 75;
    enum B110       = 110;
    enum B134       = 134;
    enum B150       = 150;
    enum B200       = 200;
    enum B300       = 300;
    enum B600       = 600;
    enum B1200      = 1200;
    enum B1800      = 1800;
    enum B2400      = 2400;
    enum B4800      = 4800;
    enum B9600      = 9600;
    enum B19200     = 19200;
    enum B38400     = 38400;

    enum CSIZE      = 0x0000300;
    enum   CS5      = 0x0000000;
    enum   CS6      = 0x0000100;
    enum   CS7      = 0x0000200;
    enum   CS8      = 0x0000300;
    enum CSTOPB     = 0x0000400;
    enum CREAD      = 0x0000800;
    enum PARENB     = 0x0001000;
    enum PARODD     = 0x0002000;
    enum HUPCL      = 0x0004000;
    enum CLOCAL     = 0x0008000;

    enum ECHO       = 0x00000008;
    enum ECHOE      = 0x00000002;
    enum ECHOK      = 0x00000004;
    enum ECHONL     = 0x00000010;
    enum ICANON     = 0x00000100;
    enum IEXTEN     = 0x00000400;
    enum ISIG       = 0x00000080;
    enum NOFLSH     = 0x80000000;
    enum TOSTOP     = 0x00400000;

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 1;
    enum TCOFLUSH   = 2;
    enum TCIOFLUSH  = 3;

    enum TCIOFF     = 3;
    enum TCION      = 4;
    enum TCOOFF     = 1;
    enum TCOON      = 2;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);

}
else version (FreeBSD)
{
    alias ubyte cc_t;
    alias uint  speed_t;
    alias uint  tcflag_t;

    enum NCCS   = 20;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VEOF       = 0;
    enum VEOL       = 1;
    enum VERASE     = 3;
    enum VINTR      = 8;
    enum VKILL      = 5;
    enum VMIN       = 16;
    enum VQUIT      = 9;
    enum VSTART     = 12;
    enum VSTOP      = 13;
    enum VSUSP      = 10;
    enum VTIME      = 17;

    enum BRKINT     = 0x0000002;
    enum ICRNL      = 0x0000100;
    enum IGNBRK     = 0x0000001;
    enum IGNCR      = 0x0000080;
    enum IGNPAR     = 0x0000004;
    enum INLCR      = 0x0000040;
    enum INPCK      = 0x0000010;
    enum ISTRIP     = 0x0000020;
    enum IXOFF      = 0x0000400;
    enum IXON       = 0x0000200;
    enum PARMRK     = 0x0000008;

    enum OPOST      = 0x0000001;

    enum B0         = 0;
    enum B50        = 50;
    enum B75        = 75;
    enum B110       = 110;
    enum B134       = 134;
    enum B150       = 150;
    enum B200       = 200;
    enum B300       = 300;
    enum B600       = 600;
    enum B1200      = 1200;
    enum B1800      = 1800;
    enum B2400      = 2400;
    enum B4800      = 4800;
    enum B9600      = 9600;
    enum B19200     = 19200;
    enum B38400     = 38400;

    enum CSIZE      = 0x0000300;
    enum   CS5      = 0x0000000;
    enum   CS6      = 0x0000100;
    enum   CS7      = 0x0000200;
    enum   CS8      = 0x0000300;
    enum CSTOPB     = 0x0000400;
    enum CREAD      = 0x0000800;
    enum PARENB     = 0x0001000;
    enum PARODD     = 0x0002000;
    enum HUPCL      = 0x0004000;
    enum CLOCAL     = 0x0008000;

    enum ECHO       = 0x00000008;
    enum ECHOE      = 0x00000002;
    enum ECHOK      = 0x00000004;
    enum ECHONL     = 0x00000010;
    enum ICANON     = 0x00000100;
    enum IEXTEN     = 0x00000400;
    enum ISIG       = 0x00000080;
    enum NOFLSH     = 0x80000000;
    enum TOSTOP     = 0x00400000;

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 1;
    enum TCOFLUSH   = 2;
    enum TCIOFLUSH  = 3;

    enum TCIOFF     = 3;
    enum TCION      = 4;
    enum TCOOFF     = 1;
    enum TCOON      = 2;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);
}
else version (DragonFlyBSD)
{
    alias ubyte cc_t;
    alias uint  speed_t;
    alias uint  tcflag_t;

    enum NCCS   = 20;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VEOF       = 0;
    enum VEOL       = 1;
    enum VERASE     = 3;
    enum VINTR      = 8;
    enum VKILL      = 5;
    enum VMIN       = 16;
    enum VQUIT      = 9;
    enum VSTART     = 12;
    enum VSTOP      = 13;
    enum VSUSP      = 10;
    enum VTIME      = 17;

    enum BRKINT     = 0x0000002;
    enum ICRNL      = 0x0000100;
    enum IGNBRK     = 0x0000001;
    enum IGNCR      = 0x0000080;
    enum IGNPAR     = 0x0000004;
    enum INLCR      = 0x0000040;
    enum INPCK      = 0x0000010;
    enum ISTRIP     = 0x0000020;
    enum IXOFF      = 0x0000400;
    enum IXON       = 0x0000200;
    enum PARMRK     = 0x0000008;

    enum OPOST      = 0x0000001;

    enum B0         = 0;
    enum B50        = 50;
    enum B75        = 75;
    enum B110       = 110;
    enum B134       = 134;
    enum B150       = 150;
    enum B200       = 200;
    enum B300       = 300;
    enum B600       = 600;
    enum B1200      = 1200;
    enum B1800      = 1800;
    enum B2400      = 2400;
    enum B4800      = 4800;
    enum B9600      = 9600;
    enum B19200     = 19200;
    enum B38400     = 38400;

    enum CSIZE      = 0x0000300;
    enum   CS5      = 0x0000000;
    enum   CS6      = 0x0000100;
    enum   CS7      = 0x0000200;
    enum   CS8      = 0x0000300;
    enum CSTOPB     = 0x0000400;
    enum CREAD      = 0x0000800;
    enum PARENB     = 0x0001000;
    enum PARODD     = 0x0002000;
    enum HUPCL      = 0x0004000;
    enum CLOCAL     = 0x0008000;

    enum ECHO       = 0x00000008;
    enum ECHOE      = 0x00000002;
    enum ECHOK      = 0x00000004;
    enum ECHONL     = 0x00000010;
    enum ICANON     = 0x00000100;
    enum IEXTEN     = 0x00000400;
    enum ISIG       = 0x00000080;
    enum NOFLSH     = 0x80000000;
    enum TOSTOP     = 0x00400000;

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 1;
    enum TCOFLUSH   = 2;
    enum TCIOFLUSH  = 3;

    enum TCIOFF     = 3;
    enum TCION      = 4;
    enum TCOOFF     = 1;
    enum TCOON      = 2;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);
}
else version (NetBSD)
{
    alias ubyte cc_t;
    alias uint  speed_t;
    alias uint  tcflag_t;

    enum NCCS   = 20;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VEOF       = 0;
    enum VEOL       = 1;
    enum VERASE     = 3;
    enum VINTR      = 8;
    enum VKILL      = 5;
    enum VMIN       = 16;
    enum VQUIT      = 9;
    enum VSTART     = 12;
    enum VSTOP      = 13;
    enum VSUSP      = 10;
    enum VTIME      = 17;

    enum BRKINT     = 0x0000002;
    enum ICRNL      = 0x0000100;
    enum IGNBRK     = 0x0000001;
    enum IGNCR      = 0x0000080;
    enum IGNPAR     = 0x0000004;
    enum INLCR      = 0x0000040;
    enum INPCK      = 0x0000010;
    enum ISTRIP     = 0x0000020;
    enum IXOFF      = 0x0000400;
    enum IXON       = 0x0000200;
    enum PARMRK     = 0x0000008;

    enum OPOST      = 0x0000001;

    enum B0         = 0;
    enum B50        = 50;
    enum B75        = 75;
    enum B110       = 110;
    enum B134       = 134;
    enum B150       = 150;
    enum B200       = 200;
    enum B300       = 300;
    enum B600       = 600;
    enum B1200      = 1200;
    enum B1800      = 1800;
    enum B2400      = 2400;
    enum B4800      = 4800;
    enum B9600      = 9600;
    enum B19200     = 19200;
    enum B38400     = 38400;

    enum CSIZE      = 0x0000300;
    enum   CS5      = 0x0000000;
    enum   CS6      = 0x0000100;
    enum   CS7      = 0x0000200;
    enum   CS8      = 0x0000300;
    enum CSTOPB     = 0x0000400;
    enum CREAD      = 0x0000800;
    enum PARENB     = 0x0001000;
    enum PARODD     = 0x0002000;
    enum HUPCL      = 0x0004000;
    enum CLOCAL     = 0x0008000;

    enum ECHO       = 0x00000008;
    enum ECHOE      = 0x00000002;
    enum ECHOK      = 0x00000004;
    enum ECHONL     = 0x00000010;
    enum ICANON     = 0x00000100;
    enum IEXTEN     = 0x00000400;
    enum ISIG       = 0x00000080;
    enum NOFLSH     = 0x80000000;
    enum TOSTOP     = 0x00400000;

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 1;
    enum TCOFLUSH   = 2;
    enum TCIOFLUSH  = 3;

    enum TCIOFF     = 3;
    enum TCION      = 4;
    enum TCOOFF     = 1;
    enum TCOON      = 2;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);
}
else version (Solaris)
{
    alias tcflag_t = uint;
    alias cc_t = ubyte;
    alias speed_t = uint;

    enum NCCS   = 19;

    struct termios
    {
        tcflag_t   c_iflag;    /* input modes */
        tcflag_t   c_oflag;    /* output modes */
        tcflag_t   c_cflag;    /* control modes */
        tcflag_t   c_lflag;    /* line discipline modes */
        cc_t[NCCS] c_cc;       /* control chars */
    }

    /* control characters */
    enum VINTR  = 0;
    enum VQUIT  = 1;
    enum VERASE = 2;
    enum VKILL  = 3;
    enum VEOF   = 4;
    enum VEOL   = 5;
    enum VMIN   = 4;
    enum VTIME  = 5;
    enum VSTART = 8;
    enum VSTOP  = 9;
    enum VSUSP  = 10;

    /* input modes */
    enum IGNBRK = 0x000001;
    enum BRKINT = 0x000002;
    enum IGNPAR = 0x000004;
    enum PARMRK = 0x000008;
    enum INPCK  = 0x000010;
    enum ISTRIP = 0x000020;
    enum INLCR  = 0x000040;
    enum IGNCR  = 0x000080;
    enum ICRNL  = 0x000100;
    enum IXON   = 0x000400;
    enum IXOFF  = 0x001000;

    /* output modes */
    enum OPOST  = 0x000001;

    /* control modes */
    enum CSIZE  = 0x000030;
    enum CS5    = 0x000000;
    enum CS6    = 0x000010;
    enum CS7    = 0x000020;
    enum CS8    = 0x000030;
    enum CSTOPB = 0x000040;
    enum CREAD  = 0x000080;
    enum PARENB = 0x000100;
    enum PARODD = 0x000200;
    enum HUPCL  = 0x000400;
    enum CLOCAL = 0x000800;

    enum CRTSCTS = 0x10000000;

    /* line discipline 0 modes */
    enum ISIG   = 0x000001;
    enum ICANON = 0x000002;
    enum ECHO   = 0x000008;
    enum ECHOE  = 0x000010;
    enum ECHOK  = 0x000020;
    enum ECHONL = 0x000040;
    enum NOFLSH = 0x000080;
    enum TOSTOP = 0x000100;

    enum ECHOCTL = 0x000200;
    enum ECHOPRT = 0x000400;
    enum ECHOKE  = 0x000800;

    enum IEXTEN = 0x008000;  /* POSIX flag - enable POSIX extensions */

    enum _TIOC      = ('T'<<8);
    enum TCSANOW    = (_TIOC|14);
    enum TCSADRAIN  = (_TIOC|15);
    enum TCSAFLUSH  = (_TIOC|16);

    /* termios option flags */
    enum TCIFLUSH   = 0;  /* flush data received but not read */
    enum TCOFLUSH   = 1;  /* flush data written but not transmitted */
    enum TCIOFLUSH  = 2;  /* flush both data both input and output queues */

    enum TCOOFF     = 0;  /* suspend output */
    enum TCOON      = 1;  /* restart suspended output */
    enum TCIOFF     = 2;  /* suspend input */
    enum TCION      = 3;  /* restart suspended input */

    /* Speeds */
    enum B0      = 0;
    enum B50     = 1;
    enum B75     = 2;
    enum B110    = 3;
    enum B134    = 4;
    enum B150    = 5;
    enum B200    = 6;
    enum B300    = 7;
    enum B600    = 8;
    enum B1200   = 9;
    enum B1800   = 10;
    enum B2400   = 11;
    enum B4800   = 12;
    enum B9600   = 13;
    enum B19200  = 14;
    enum B38400  = 15;
    enum B57600  = 16;
    enum B76800  = 17;
    enum B115200 = 18;
    enum B153600 = 19;
    enum B230400 = 20;
    enum B307200 = 21;
    enum B460800 = 22;
    enum B921600 = 23;

    /*
     * POSIX termios functions
     * These functions get mapped into ioctls.
     */
    speed_t cfgetospeed(in termios*);
    int     cfsetospeed(termios*, speed_t);
    speed_t cfgetispeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     tcgetattr(int, termios*);
    int     tcsetattr(int, int, in termios*);
    int     tcsendbreak(int, int);
    int     tcdrain(int);
    int     tcflush(int, int);
    int     tcflow(int, int);
}
else version (CRuntime_UClibc)
{
    alias ubyte cc_t;
    alias uint  speed_t;
    alias uint  tcflag_t;

    enum NCCS   = 32;

    struct termios
    {
        tcflag_t   c_iflag;
        tcflag_t   c_oflag;
        tcflag_t   c_cflag;
        tcflag_t   c_lflag;
        cc_t       c_line;
        cc_t[NCCS] c_cc;
        speed_t    c_ispeed;
        speed_t    c_ospeed;
    }

    enum VINTR      = 0;
    enum VQUIT      = 1;
    enum VERASE     = 2;
    enum VKILL      = 3;
    enum VEOF       = 4;
    enum VTIME      = 5;
    enum VMIN       = 6;
    enum VSWTC      = 7;
    enum VSTART     = 8;
    enum VSTOP      = 9;
    enum VSUSP      = 10;
    enum VEOL       = 11;
    enum VREPRINT   = 12;
    enum VDISCARD   = 13;
    enum VWERASE    = 14;
    enum VLNEXT     = 15;
    enum VEOL2      = 16;

    enum BRKINT     = 0x0000002; // 0000002
    enum ICRNL      = 0x0000100; // 0000400
    enum IGNBRK     = 0x0000001; // 0000001
    enum IGNCR      = 0x0000080; // 0000200
    enum IGNPAR     = 0x0000004; // 0000004
    enum INLCR      = 0x0000040; // 0000100
    enum INPCK      = 0x0000010; // 0000020
    enum ISTRIP     = 0x0000020; // 0000040
    enum IXOFF      = 0x0001000; // 0010000
    enum IXON       = 0x0000400; // 0002000
    enum PARMRK     = 0x0000008; // 0000010

    enum OPOST      = 0x0000001; // 0000001

    enum B0         = 0x0000000; // 0000000
    enum B50        = 0x0000001; // 0000001
    enum B75        = 0x0000002; // 0000002
    enum B110       = 0x0000003; // 0000003
    enum B134       = 0x0000004; // 0000004
    enum B150       = 0x0000005; // 0000005
    enum B200       = 0x0000006; // 0000006
    enum B300       = 0x0000007; // 0000007
    enum B600       = 0x0000008; // 0000010
    enum B1200      = 0x0000009; // 0000011
    enum B1800      = 0x000000A; // 0000012
    enum B2400      = 0x000000B; // 0000013
    enum B4800      = 0x000000C; // 0000014
    enum B9600      = 0x000000D; // 0000015
    enum B19200     = 0x000000E; // 0000016
    enum B38400     = 0x000000F; // 0000017

    enum CSIZE      = 0x0000030; // 0000060
    enum   CS5      = 0x0000000; // 0000000
    enum   CS6      = 0x0000010; // 0000020
    enum   CS7      = 0x0000020; // 0000040
    enum   CS8      = 0x0000030; // 0000060
    enum CSTOPB     = 0x0000040; // 0000100
    enum CREAD      = 0x0000080; // 0000200
    enum PARENB     = 0x0000100; // 0000400
    enum PARODD     = 0x0000200; // 0001000
    enum HUPCL      = 0x0000400; // 0002000
    enum CLOCAL     = 0x0000800; // 0004000

    enum ECHO       = 0x0000008; // 0000010
    enum ECHOE      = 0x0000010; // 0000020
    enum ECHOK      = 0x0000020; // 0000040
    enum ECHONL     = 0x0000040; // 0000100
    enum ICANON     = 0x0000002; // 0000002
    enum IEXTEN     = 0x0008000; // 0100000
    enum ISIG       = 0x0000001; // 0000001
    enum NOFLSH     = 0x0000080; // 0000200
    enum TOSTOP     = 0x0000100; // 0000400

    enum TCSANOW    = 0;
    enum TCSADRAIN  = 1;
    enum TCSAFLUSH  = 2;

    enum TCIFLUSH   = 0;
    enum TCOFLUSH   = 1;
    enum TCIOFLUSH  = 2;

    enum TCIOFF     = 2;
    enum TCION      = 3;
    enum TCOOFF     = 0;
    enum TCOON      = 1;

    speed_t cfgetispeed(in termios*);
    speed_t cfgetospeed(in termios*);
    int     cfsetispeed(termios*, speed_t);
    int     cfsetospeed(termios*, speed_t);
    int     tcdrain(int);
    int     tcflow(int, int);
    int     tcflush(int, int);
    int     tcgetattr(int, termios*);
    int     tcsendbreak(int, int);
    int     tcsetattr(int, int, in termios*);
}

//
// XOpen (XSI)
//
/*
IXANY

ONLCR
OCRNL
ONOCR
ONLRET
OFILL
NLDLY
    NL0
    NL1
CRDLY
    CR0
    CR1
    CR2
    CR3
TABDLY
    TAB0
    TAB1
    TAB2
    TAB3
BSDLY
    BS0
    BS1
VTDLY
    VT0
    VT1
FFDLY
    FF0
    FF1

pid_t   tcgetsid(int);
*/

version (CRuntime_Glibc)
{
    enum IXANY      = 0x0000800; // 0004000

    enum ONLCR      = 0x0000004; // 0000004
    enum OCRNL      = 0x0000008; // 0000010
    enum ONOCR      = 0x0000010; // 0000020
    enum ONLRET     = 0x0000020; // 0000040
    enum OFILL      = 0x0000040; // 0000100
    enum NLDLY      = 0x0000100; // 0000400
    enum   NL0      = 0x0000000; // 0000000
    enum   NL1      = 0x0000100; // 0000400
    enum CRDLY      = 0x0000600; // 0003000
    enum   CR0      = 0x0000000; // 0000000
    enum   CR1      = 0x0000200; // 0001000
    enum   CR2      = 0x0000400; // 0002000
    enum   CR3      = 0x0000600; // 0003000
    enum TABDLY     = 0x0001800; // 0014000
    enum   TAB0     = 0x0000000; // 0000000
    enum   TAB1     = 0x0000800; // 0004000
    enum   TAB2     = 0x0001000; // 0010000
    enum   TAB3     = 0x0001800; // 0014000
    enum BSDLY      = 0x0002000; // 0020000
    enum   BS0      = 0x0000000; // 0000000
    enum   BS1      = 0x0002000; // 0020000
    enum VTDLY      = 0x0004000; // 0040000
    enum   VT0      = 0x0000000; // 0000000
    enum   VT1      = 0x0004000; // 0040000
    enum FFDLY      = 0x0008000; // 0100000
    enum   FF0      = 0x0000000; // 0000000
    enum   FF1      = 0x0008000; // 0100000

    pid_t   tcgetsid(int);
}

else version (Darwin)
{
    enum IXANY      = 0x00000800;

    enum ONLCR      = 0x00000002;
    enum OCRNL      = 0x00000010;
    enum ONOCR      = 0x00000020;
    enum ONLRET     = 0x00000040;
    enum OFILL      = 0x00000080;
    enum NLDLY      = 0x00000300;
    enum   NL0      = 0x00000000;
    enum   NL1      = 0x00000100;
    enum CRDLY      = 0x00003000;
    enum   CR0      = 0x00000000;
    enum   CR1      = 0x00001000;
    enum   CR2      = 0x00002000;
    enum   CR3      = 0x00003000;
    enum TABDLY     = 0x00000c04;
    enum   TAB0     = 0x00000000;
    enum   TAB1     = 0x00000400;
    enum   TAB2     = 0x00000800;
    enum   TAB3     = 0x00000004;
    enum BSDLY      = 0x00008000;
    enum   BS0      = 0x00000000;
    enum   BS1      = 0x00008000;
    enum VTDLY      = 0x00010000;
    enum   VT0      = 0x00000000;
    enum   VT1      = 0x00010000;
    enum FFDLY      = 0x00004000;
    enum   FF0      = 0x00000000;
    enum   FF1      = 0x00004000;

    pid_t tcgetsid (int);
}

else version (FreeBSD)
{
    enum IXANY      = 0x00000800;

    enum ONLCR      = 0x00000002;
    enum OCRNL      = 0x00000010;
    enum ONOCR      = 0x00000020;
    enum ONLRET     = 0x00000040;
    //enum OFILL
    //enum NLDLY
    //enum     NL0
    //enum     NL1
    //enum CRDLY
    //enum     CR0
    //enum     CR1
    //enum     CR2
    //enum     CR3
    enum TABDLY     = 0x00000004;
    enum     TAB0   = 0x00000000;
    //enum     TAB1
    //enum     TAB2
    enum     TAB3   = 0x00000004;
    //enum BSDLY
    //enum     BS0
    //enum     BS1
    //enum VTDLY
    //enum     VT0
    //enum     VT1
    //enum FFDLY
    //enum     FF0
    //enum     FF1

    pid_t   tcgetsid(int);
}
else version (DragonFlyBSD)
{
    enum IXANY      = 0x00000800;

    enum ONLCR      = 0x00000002;
    enum OCRNL      = 0x00000010;
    enum ONOCR      = 0x00000020;
    enum ONLRET     = 0x00000040;
    //enum OFILL
    //enum NLDLY
    //enum     NL0
    //enum     NL1
    //enum CRDLY
    //enum     CR0
    //enum     CR1
    //enum     CR2
    //enum     CR3
    enum TABDLY     = 0x00000004;
    enum     TAB0   = 0x00000000;
    //enum     TAB1
    //enum     TAB2
    enum     TAB3   = 0x00000004;
    //enum BSDLY
    //enum     BS0
    //enum     BS1
    //enum VTDLY
    //enum     VT0
    //enum     VT1
    //enum FFDLY
    //enum     FF0
    //enum     FF1

    pid_t   tcgetsid(int);
}
else version (NetBSD)
{
    enum IXANY      = 0x00000800;

    enum ONLCR      = 0x00000002;
    enum OCRNL      = 0x00000010;
    enum ONOCR      = 0x00000020;
    enum ONLRET     = 0x00000040;
    //enum OFILL
    //enum NLDLY
    //enum     NL0
    //enum     NL1
    //enum CRDLY
    //enum     CR0
    //enum     CR1
    //enum     CR2
    //enum     CR3
    enum TABDLY     = 0x00000004;
    enum     TAB0   = 0x00000000;
    //enum     TAB1
    //enum     TAB2
    enum     TAB3   = 0x00000004;
    //enum BSDLY
    //enum     BS0
    //enum     BS1
    //enum VTDLY
    //enum     VT0
    //enum     VT1
    //enum FFDLY
    //enum     FF0
    //enum     FF1

    pid_t   tcgetsid(int);
}
else version (Solaris)
{
    enum IXANY      = 0x0000800;

    enum ONLCR      = 0x0000004;
    enum OCRNL      = 0x0000008;
    enum ONOCR      = 0x0000010;
    enum ONLRET     = 0x0000020;
    enum OFILL      = 0x0000040;
    enum OFDEL      = 0x0000080;
    enum NLDLY      = 0x0000100;
    enum NL0        = 0x0000000;
    enum NL1        = 0x0000100;
    enum CRDLY      = 0x0000600;
    enum CR0        = 0x0000000;
    enum CR1        = 0x0000200;
    enum CR2        = 0x0000400;
    enum CR3        = 0x0000600;
    enum TABDLY     = 0x0001800;
    enum TAB0       = 0x0000000;
    enum TAB1       = 0x0000800;
    enum TAB2       = 0x0001000;
    enum TAB3       = 0x0001800;
    enum BSDLY      = 0x0002000;
    enum BS0        = 0x0000000;
    enum BS1        = 0x0002000;
    enum VTDLY      = 0x0004000;
    enum VT0        = 0x0000000;
    enum VT1        = 0x0004000;
    enum FFDLY      = 0x0008000;
    enum FF0        = 0x0000000;
    enum FF1        = 0x0008000;
    enum XCASE      = 0x0000004;

    pid_t   tcgetsid(int);
}
else version (CRuntime_UClibc)
{
    enum IXANY      = 0x0000800; // 0004000

    enum ONLCR      = 0x0000004; // 0000004
    enum OCRNL      = 0x0000008; // 0000010
    enum ONOCR      = 0x0000010; // 0000020
    enum ONLRET     = 0x0000020; // 0000040
    enum OFILL      = 0x0000040; // 0000100
    enum NLDLY      = 0x0000100; // 0000400
    enum   NL0      = 0x0000000; // 0000000
    enum   NL1      = 0x0000100; // 0000400
    enum CRDLY      = 0x0000600; // 0003000
    enum   CR0      = 0x0000000; // 0000000
    enum   CR1      = 0x0000200; // 0001000
    enum   CR2      = 0x0000400; // 0002000
    enum   CR3      = 0x0000600; // 0003000
    enum TABDLY     = 0x0001800; // 0014000
    enum   TAB0     = 0x0000000; // 0000000
    enum   TAB1     = 0x0000800; // 0004000
    enum   TAB2     = 0x0001000; // 0010000
    enum   TAB3     = 0x0001800; // 0014000
    enum BSDLY      = 0x0002000; // 0020000
    enum   BS0      = 0x0000000; // 0000000
    enum   BS1      = 0x0002000; // 0020000
    enum VTDLY      = 0x0004000; // 0040000
    enum   VT0      = 0x0000000; // 0000000
    enum   VT1      = 0x0004000; // 0040000
    enum FFDLY      = 0x0008000; // 0100000
    enum   FF0      = 0x0000000; // 0000000
    enum   FF1      = 0x0008000; // 0100000

    pid_t   tcgetsid(int);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly,
              Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.time;

private import core.sys.posix.config;
public import core.stdc.time;
public import core.sys.posix.sys.types;
public import core.sys.posix.signal; // for sigevent

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C):
nothrow:
@nogc:

//
// Required (defined in core.stdc.time)
//
/*
char* asctime(in tm*);
clock_t clock();
char* ctime(in time_t*);
double difftime(time_t, time_t);
tm* gmtime(in time_t*);
tm* localtime(in time_t*);
time_t mktime(tm*);
size_t strftime(char*, size_t, in char*, in tm*);
time_t time(time_t*);
*/

version (CRuntime_Glibc)
{
    time_t timegm(tm*); // non-standard
}
else version (Darwin)
{
    time_t timegm(tm*); // non-standard
}
else version (FreeBSD)
{
    time_t timegm(tm*); // non-standard
}
else version (NetBSD)
{
    time_t timegm(tm*); // non-standard
}
else version (DragonFlyBSD)
{
    time_t timegm(tm*); // non-standard
}
else version (Solaris)
{
    time_t timegm(tm*); // non-standard
}
else version (CRuntime_Bionic)
{
    // Not supported.
}
else version (CRuntime_Musl)
{
    time_t timegm(tm*);
}
else version (CRuntime_UClibc)
{
    time_t timegm(tm*);
}
else
{
    static assert(false, "Unsupported platform");
}

//
// C Extension (CX)
// (defined in core.stdc.time)
//
/*
char* tzname[];
void tzset();
*/

//
// Process CPU-Time Clocks (CPT)
//
/*
int clock_getcpuclockid(pid_t, clockid_t*);
*/

//
// Clock Selection (CS)
//
/*
int clock_nanosleep(clockid_t, int, in timespec*, timespec*);
*/

//
// Monotonic Clock (MON)
//
/*
CLOCK_MONOTONIC
*/

version (linux)
{
    enum CLOCK_MONOTONIC          = 1;
    // To be removed in December 2015.
    static import core.sys.linux.time;
    deprecated("Please import it from core.sys.linux.time instead.")
        alias CLOCK_MONOTONIC_RAW = core.sys.linux.time.CLOCK_MONOTONIC_RAW; // non-standard
    deprecated("Please import it from core.sys.linux.time instead.")
        alias CLOCK_MONOTONIC_COARSE = core.sys.linux.time.CLOCK_MONOTONIC_COARSE; // non-standard
}
else version (FreeBSD)
{   // time.h
    enum CLOCK_MONOTONIC         = 4;
    // To be removed in December 2015.
    static import core.sys.freebsd.time;
    deprecated("Please import it from core.sys.freebsd.time instead.")
        alias CLOCK_MONOTONIC_PRECISE = core.sys.freebsd.time.CLOCK_MONOTONIC_PRECISE;
    deprecated("Please import it from core.sys.freebsd.time instead.")
        alias CLOCK_MONOTONIC_FAST = core.sys.freebsd.time.CLOCK_MONOTONIC_FAST;
}
else version (NetBSD)
{
    // time.h
    enum CLOCK_MONOTONIC         = 3;
}
else version (DragonFlyBSD)
{   // time.h
    enum CLOCK_MONOTONIC         = 4;
    // To be removed in December 2015.
    static import core.sys.dragonflybsd.time;
    deprecated("Please import it from core.sys.dragonflybsd.time instead.")
        alias CLOCK_MONOTONIC_PRECISE = core.sys.dragonflybsd.time.CLOCK_MONOTONIC_PRECISE;
    deprecated("Please import it from core.sys.dragonflybsd.time instead.")
        alias CLOCK_MONOTONIC_FAST = core.sys.dragonflybsd.time.CLOCK_MONOTONIC_FAST;
}
else version (Darwin)
{
    // No CLOCK_MONOTONIC defined
}
else version (Solaris)
{
    enum CLOCK_MONOTONIC = 4;
}
else
{
    static assert(0);
}

//
// Timer (TMR)
//
/*
CLOCK_PROCESS_CPUTIME_ID (TMR|CPT)
CLOCK_THREAD_CPUTIME_ID (TMR|TCT)

NOTE: timespec must be defined in core.sys.posix.signal to break
      a circular import.

struct timespec
{
    time_t  tv_sec;
    int     tv_nsec;
}

struct itimerspec
{
    timespec it_interval;
    timespec it_value;
}

CLOCK_REALTIME
TIMER_ABSTIME

clockid_t
timer_t

int clock_getres(clockid_t, timespec*);
int clock_gettime(clockid_t, timespec*);
int clock_settime(clockid_t, in timespec*);
int nanosleep(in timespec*, timespec*);
int timer_create(clockid_t, sigevent*, timer_t*);
int timer_delete(timer_t);
int timer_gettime(timer_t, itimerspec*);
int timer_getoverrun(timer_t);
int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
*/

version (CRuntime_Glibc)
{
    enum CLOCK_PROCESS_CPUTIME_ID = 2;
    enum CLOCK_THREAD_CPUTIME_ID  = 3;

    // NOTE: See above for why this is commented out.
    //
    //struct timespec
    //{
    //    time_t  tv_sec;
    //    c_long  tv_nsec;
    //}

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME         = 0;
    // To be removed in December 2015.
    static import core.sys.linux.time;
    deprecated("Please import it from core.sys.linux.time instead.")
        alias CLOCK_REALTIME_COARSE = core.sys.linux.time.CLOCK_REALTIME_COARSE; // non-standard
    enum TIMER_ABSTIME          = 0x01;

    alias int clockid_t;
    alias void* timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (Darwin)
{
    int nanosleep(in timespec*, timespec*);
}
else version (FreeBSD)
{
    //enum CLOCK_PROCESS_CPUTIME_ID = ??;
    enum CLOCK_THREAD_CPUTIME_ID  = 15;

    // NOTE: See above for why this is commented out.
    //
    //struct timespec
    //{
    //    time_t  tv_sec;
    //    c_long  tv_nsec;
    //}

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME      = 0;
    enum TIMER_ABSTIME       = 0x01;

    alias int clockid_t; // <sys/_types.h>
    alias int timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (DragonFlyBSD)
{
    enum CLOCK_THREAD_CPUTIME_ID  = 15;

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME      = 0;
    enum TIMER_ABSTIME       = 0x01;

    alias int clockid_t; // <sys/_types.h>
    alias int timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (NetBSD)
{
    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME      = 0;
    enum TIMER_ABSTIME       = 0x01;

    alias int clockid_t; // <sys/_types.h>
    alias int timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (Solaris)
{
    enum CLOCK_PROCESS_CPUTIME_ID = 5; // <sys/time_impl.h>
    enum CLOCK_THREAD_CPUTIME_ID  = 2; // <sys/time_impl.h>

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME = 3; // <sys/time_impl.h>
    enum TIMER_ABSOLUTE = 0x1;

    alias int clockid_t;
    alias int timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int clock_nanosleep(clockid_t, int, in timespec*, timespec*);

    int nanosleep(in timespec*, timespec*);

    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_getoverrun(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (CRuntime_Bionic)
{
    enum CLOCK_PROCESS_CPUTIME_ID = 2;
    enum CLOCK_THREAD_CPUTIME_ID  = 3;

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum CLOCK_REALTIME    = 0;
    enum CLOCK_REALTIME_HR = 4;
    enum TIMER_ABSTIME     = 0x01;

    alias int   clockid_t;
    alias void* timer_t; // Updated since Lollipop

    int clock_getres(int, timespec*);
    int clock_gettime(int, timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(int, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else version (CRuntime_Musl)
{
    alias int clockid_t;
    alias void* timer_t;

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum TIMER_ABSTIME = 1;

    enum CLOCK_REALTIME = 0;
    enum CLOCK_PROCESS_CPUTIME_ID = 2;
    enum CLOCK_THREAD_CPUTIME_ID = 3;
    enum CLOCK_REALTIME_COARSE = 5;
    enum CLOCK_BOOTTIME = 7;
    enum CLOCK_REALTIME_ALARM = 8;
    enum CLOCK_BOOTTIME_ALARM = 9;
    enum CLOCK_SGI_CYCLE = 10;
    enum CLOCK_TAI = 11;

    int nanosleep(in timespec*, timespec*);

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int clock_nanosleep(clockid_t, int, in timespec*, timespec*);
    int clock_getcpuclockid(pid_t, clockid_t *);

    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
    int timer_getoverrun(timer_t);
}
else version (CRuntime_UClibc)
{
    enum CLOCK_REALTIME             = 0;
    enum CLOCK_PROCESS_CPUTIME_ID   = 2;
    enum CLOCK_THREAD_CPUTIME_ID    = 3;

    struct itimerspec
    {
        timespec it_interval;
        timespec it_value;
    }

    enum TIMER_ABSTIME          = 0x01;

    alias int clockid_t;
    alias void* timer_t;

    int clock_getres(clockid_t, timespec*);
    int clock_gettime(clockid_t, timespec*);
    int clock_settime(clockid_t, in timespec*);
    int nanosleep(in timespec*, timespec*);
    int timer_create(clockid_t, sigevent*, timer_t*);
    int timer_delete(timer_t);
    int timer_gettime(timer_t, itimerspec*);
    int timer_getoverrun(timer_t);
    int timer_settime(timer_t, int, in itimerspec*, itimerspec*);
}
else
{
    static assert(false, "Unsupported platform");
}

//
// Thread-Safe Functions (TSF)
//
/*
char* asctime_r(in tm*, char*);
char* ctime_r(in time_t*, char*);
tm*   gmtime_r(in time_t*, tm*);
tm*   localtime_r(in time_t*, tm*);
*/

version (CRuntime_Glibc)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (Darwin)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (FreeBSD)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (NetBSD)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (DragonFlyBSD)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (Solaris)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm* gmtime_r(in time_t*, tm*);
    tm* localtime_r(in time_t*, tm*);
}
else version (CRuntime_Bionic)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm* gmtime_r(in time_t*, tm*);
    tm* localtime_r(in time_t*, tm*);
}
else version (CRuntime_Musl)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else version (CRuntime_UClibc)
{
    char* asctime_r(in tm*, char*);
    char* ctime_r(in time_t*, char*);
    tm*   gmtime_r(in time_t*, tm*);
    tm*   localtime_r(in time_t*, tm*);
}
else
{
    static assert(false, "Unsupported platform");
}

//
// XOpen (XSI)
//
/*
getdate_err

int daylight;
int timezone;

tm* getdate(in char*);
char* strptime(in char*, in char*, tm*);
*/

version (CRuntime_Glibc)
{
    extern __gshared int    daylight;
    extern __gshared c_long timezone;

    tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (Darwin)
{
    extern __gshared c_long timezone;
    extern __gshared int    daylight;

    tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (FreeBSD)
{
    //tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (NetBSD)
{
    tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (DragonFlyBSD)
{
    //tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (Solaris)
{
    extern __gshared c_long timezone, altzone;
    extern __gshared int daylight;

    tm* getdate(in char*);
    char* __strptime_dontzero(in char*, in char*, tm*);
    alias __strptime_dontzero strptime;
}
else version (CRuntime_Bionic)
{
    extern __gshared int    daylight;
    extern __gshared c_long timezone;

    char* strptime(in char*, in char*, tm*);
}
else version (CRuntime_Musl)
{
    tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else version (CRuntime_UClibc)
{
    extern __gshared int    daylight;
    extern __gshared c_long timezone;

    tm*   getdate(in char*);
    char* strptime(in char*, in char*, tm*);
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.ucontext;

private import core.sys.posix.config;
public import core.sys.posix.signal; // for sigset_t, stack_t
private import core.stdc.stdint : uintptr_t;

version (Posix):
extern (C):
nothrow:
@nogc:

version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;
version (S390)    version = IBMZ_Any;
version (SPARC)   version = SPARC_Any;
version (SPARC64) version = SPARC_Any;
version (SystemZ) version = IBMZ_Any;
version (X86)     version = X86_Any;
version (X86_64)  version = X86_Any;

//
// XOpen (XSI)
//
/*
mcontext_t

struct ucontext_t
{
    ucontext_t* uc_link;
    sigset_t    uc_sigmask;
    stack_t     uc_stack;
    mcontext_t  uc_mcontext;
}
*/

version (CRuntime_Glibc)
{

    version (X86_64)
    {
        enum
        {
            REG_R8 = 0,
            REG_R9,
            REG_R10,
            REG_R11,
            REG_R12,
            REG_R13,
            REG_R14,
            REG_R15,
            REG_RDI,
            REG_RSI,
            REG_RBP,
            REG_RBX,
            REG_RDX,
            REG_RAX,
            REG_RCX,
            REG_RSP,
            REG_RIP,
            REG_EFL,
            REG_CSGSFS,     /* Actually short cs, gs, fs, __pad0.  */
            REG_ERR,
            REG_TRAPNO,
            REG_OLDMASK,
            REG_CR2
        }

        private
        {
            struct _libc_fpxreg
            {
                ushort[4] significand;
                ushort    exponent;
                ushort[3] padding;
            }

            struct _libc_xmmreg
            {
                uint[4] element;
            }

            struct _libc_fpstate
            {
                ushort           cwd;
                ushort           swd;
                ushort           ftw;
                ushort           fop;
                ulong            rip;
                ulong            rdp;
                uint             mxcsr;
                uint             mxcr_mask;
                _libc_fpxreg[8]  _st;
                _libc_xmmreg[16] _xmm;
                uint[24]         padding;
            }

            enum NGREG = 23;

            alias c_long            greg_t;
            alias greg_t[NGREG]     gregset_t;
            alias _libc_fpstate*    fpregset_t;
        }

        struct mcontext_t
        {
            gregset_t   gregs;
            fpregset_t  fpregs;
            c_ulong[8]  __reserved1;
        }

        struct ucontext_t
        {
            c_ulong         uc_flags;
            ucontext_t*     uc_link;
            stack_t         uc_stack;
            mcontext_t      uc_mcontext;
            sigset_t        uc_sigmask;
            _libc_fpstate   __fpregs_mem;
        }
    }
    else version (X86)
    {
        enum
        {
            REG_GS = 0,
            REG_FS,
            REG_ES,
            REG_DS,
            REG_EDI,
            REG_ESI,
            REG_EBP,
            REG_ESP,
            REG_EBX,
            REG_EDX,
            REG_ECX,
            REG_EAX,
            REG_TRAPNO,
            REG_ERR,
            REG_EIP,
            REG_CS,
            REG_EFL,
            REG_UESP,
            REG_SS
        }

        private
        {
            struct _libc_fpreg
            {
              ushort[4] significand;
              ushort    exponent;
            }

            struct _libc_fpstate
            {
              c_ulong           cw;
              c_ulong           sw;
              c_ulong           tag;
              c_ulong           ipoff;
              c_ulong           cssel;
              c_ulong           dataoff;
              c_ulong           datasel;
              _libc_fpreg[8]    _st;
              c_ulong           status;
            }

            enum NGREG = 19;

            alias int               greg_t;
            alias greg_t[NGREG]     gregset_t;
            alias _libc_fpstate*    fpregset_t;
        }

        struct mcontext_t
        {
            gregset_t   gregs;
            fpregset_t  fpregs;
            c_ulong     oldmask;
            c_ulong     cr2;
        }

        struct ucontext_t
        {
            c_ulong         uc_flags;
            ucontext_t*     uc_link;
            stack_t         uc_stack;
            mcontext_t      uc_mcontext;
            sigset_t        uc_sigmask;
            _libc_fpstate   __fpregs_mem;
        }
    }
    else version (HPPA)
    {
        private
        {
            enum NGREG  = 80;
            enum NFPREG = 32;

            alias c_ulong greg_t;

            struct gregset_t
            {
                greg_t[32] g_regs;
                greg_t[8] sr_regs;
                greg_t[24] cr_regs;
                greg_t[16] g_pad;
            }

            struct fpregset_t
            {
                double[32] fpregs;
            }
        }

        struct mcontext_t
        {
            greg_t sc_flags;
            greg_t[32] sc_gr;
            fpregset_t sc_fr;
            greg_t[2] sc_iasq;
            greg_t[2] sc_iaoq;
            greg_t sc_sar;
        }

        struct ucontext_t
        {
            c_ulong uc_flags;
            ucontext_t* uc_link;
            stack_t uc_stack;
            mcontext_t uc_mcontext;
            sigset_t uc_sigmask;
        }
    }
    else version (MIPS32)
    {
        private
        {
            enum NGREG  = 32;
            enum NFPREG = 32;

            alias ulong         greg_t;
            alias greg_t[NGREG] gregset_t;

            struct fpregset_t
            {
                union fp_r_t
                {
                    double[NFPREG]  fp_dregs;
                    static struct fp_fregs_t
                    {
                        float   _fp_fregs;
                        uint    _fp_pad;
                    } fp_fregs_t[NFPREG] fp_fregs;
                } fp_r_t fp_r;
            }
        }

        version (MIPS_O32)
        {
            struct mcontext_t
            {
                uint regmask;
                uint status;
                greg_t pc;
                gregset_t gregs;
                fpregset_t fpregs;
                uint fp_owned;
                uint fpc_csr;
                uint fpc_eir;
                uint used_math;
                uint dsp;
                greg_t mdhi;
                greg_t mdlo;
                c_ulong hi1;
                c_ulong lo1;
                c_ulong hi2;
                c_ulong lo2;
                c_ulong hi3;
                c_ulong lo3;
            }
        }
        else
        {
            struct mcontext_t
            {
                gregset_t gregs;
                fpregset_t fpregs;
                greg_t mdhi;
                greg_t hi1;
                greg_t hi2;
                greg_t hi3;
                greg_t mdlo;
                greg_t lo1;
                greg_t lo2;
                greg_t lo3;
                greg_t pc;
                uint fpc_csr;
                uint used_math;
                uint dsp;
                uint reserved;
            }
        }

        struct ucontext_t
        {
            c_ulong     uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            mcontext_t  uc_mcontext;
            sigset_t    uc_sigmask;
        }
    }
    else version (MIPS64)
    {
        private
        {
            enum NGREG  = 32;
            enum NFPREG = 32;

            alias ulong         greg_t;
            alias greg_t[NGREG] gregset_t;

            struct fpregset_t
            {
                union fp_r_t
                {
                    double[NFPREG]  fp_dregs;
                    static struct fp_fregs_t
                    {
                        float   _fp_fregs;
                        uint    _fp_pad;
                    } fp_fregs_t[NFPREG] fp_fregs;
                } fp_r_t fp_r;
            }
        }

        struct mcontext_t
        {
            gregset_t gregs;
            fpregset_t fpregs;
            greg_t mdhi;
            greg_t hi1;
            greg_t hi2;
            greg_t hi3;
            greg_t mdlo;
            greg_t lo1;
            greg_t lo2;
            greg_t lo3;
            greg_t pc;
            uint fpc_csr;
            uint used_math;
            uint dsp;
            uint reserved;
        }

        struct ucontext_t
        {
            c_ulong     uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            mcontext_t  uc_mcontext;
            sigset_t    uc_sigmask;
        }
    }
    else version (PPC)
    {
        private
        {
            enum NGREG  = 48;

            alias c_ulong        greg_t;
            alias greg_t[NGREG]  gregset_t;

            struct fpregset_t
            {
                double[32] fpregs;
                double fpscr;
                uint[2] _pad;
            }

            struct vrregset_t
            {
                uint[32][4] vrregs;
                uint        vrsave;
                uint[2]     __pad;
                uint vscr;
            }

            struct pt_regs
            {
                c_ulong[32] gpr;
                c_ulong     nip;
                c_ulong     msr;
                c_ulong     orig_gpr3;
                c_ulong     ctr;
                c_ulong     link;
                c_ulong     xer;
                c_ulong     ccr;
                c_ulong     mq;
                c_ulong     trap;
                c_ulong     dar;
                c_ulong     dsisr;
                c_ulong     result;
            }
        }

        struct mcontext_t
        {
            gregset_t gregs;
            fpregset_t fpregs;
            align(16) vrregset_t vrregs;
        }

        struct ucontext_t
        {
            c_ulong     uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            int[7]      uc_pad;
            union uc_mcontext
            {
                pt_regs*     regs;
                mcontext_t*  uc_regs;
            }
            sigset_t    uc_sigmask;
            char[mcontext_t.sizeof + 12] uc_reg_space = 0;
        }
    }
    else version (PPC64)
    {
        private
        {
            enum NGREG  = 48;
            enum NFPREG = 33;
            enum NVRREG = 34;

            alias c_ulong        greg_t;
            alias greg_t[NGREG]  gregset_t;
            alias double[NFPREG] fpregset_t;

            struct vscr_t
            {
                uint[3] __pad;
                uint    vscr_word;
            }

            struct vrregset_t
            {
                uint[32][4] vrregs;
                vscr_t      vscr;
                uint        vrsave;
                uint[3]     __pad;
            }

            struct pt_regs
            {
                c_ulong[32] gpr;
                c_ulong     nip;
                c_ulong     msr;
                c_ulong     orig_gpr3;
                c_ulong     ctr;
                c_ulong     link;
                c_ulong     xer;
                c_ulong     ccr;
                c_ulong     softe;
                c_ulong     trap;
                c_ulong     dar;
                c_ulong     dsisr;
                c_ulong     result;
            }
        }

        struct mcontext_t
        {
            c_ulong[4] __unused;
            int signal;
            int __pad0;
            c_ulong handler;
            c_ulong oldmask;
            pt_regs* regs;
            gregset_t gp_regs;
            fpregset_t fp_regs;
            vrregset_t *v_regs;
            c_long[NVRREG+NVRREG+1] vmx_reserve;
        }

        struct ucontext_t
        {
            c_ulong     uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            sigset_t    uc_sigmask;
            mcontext_t  uc_mcontext;
        }
    }
    else version (ARM)
    {
        enum
        {
            R0 = 0,
            R1 = 1,
            R2 = 2,
            R3 = 3,
            R4 = 4,
            R5 = 5,
            R6 = 6,
            R7 = 7,
            R8 = 8,
            R9 = 9,
            R10 = 10,
            R11 = 11,
            R12 = 12,
            R13 = 13,
            R14 = 14,
            R15 = 15
        }

        struct sigcontext
        {
            c_ulong trap_no;
            c_ulong error_code;
            c_ulong oldmask;
            c_ulong arm_r0;
            c_ulong arm_r1;
            c_ulong arm_r2;
            c_ulong arm_r3;
            c_ulong arm_r4;
            c_ulong arm_r5;
            c_ulong arm_r6;
            c_ulong arm_r7;
            c_ulong arm_r8;
            c_ulong arm_r9;
            c_ulong arm_r10;
            c_ulong arm_fp;
            c_ulong arm_ip;
            c_ulong arm_sp;
            c_ulong arm_lr;
            c_ulong arm_pc;
            c_ulong arm_cpsr;
            c_ulong fault_address;
        }

        //alias elf_fpregset_t fpregset_t;
        alias sigcontext mcontext_t;

        struct ucontext_t
        {
            c_ulong uc_flags;
            ucontext_t* uc_link;
            stack_t uc_stack;
            mcontext_t uc_mcontext;
            sigset_t uc_sigmask;
            align(8) c_ulong[128] uc_regspace;
        }
    }
    else version (AArch64)
    {
        alias int greg_t;

        struct sigcontext {
            ulong           fault_address;
            /* AArch64 registers */
            ulong[31]       regs;
            ulong           sp;
            ulong           pc;
            ulong           pstate;
            /* 4K reserved for FP/SIMD state and future expansion */
            align(16) ubyte[4096] __reserved;
        }

        alias sigcontext mcontext_t;

        struct ucontext_t
        {
            c_ulong     uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            sigset_t    uc_sigmask;
            mcontext_t  uc_mcontext;
        }
    }
    else version (RISCV_Any)
    {
        private
        {
            alias c_ulong[32] __riscv_mc_gp_state;

            struct __riscv_mc_f_ext_state
            {
                uint[32] __f;
                uint __fcsr;
            }

            struct __riscv_mc_d_ext_state
            {
                ulong[32] __f;
                uint __fcsr;
            }

            struct __riscv_mc_q_ext_state
            {
                align(16) ulong[64] __f;
                uint __fcsr;
                uint[3] __reserved;
            }

            union __riscv_mc_fp_state
            {
                __riscv_mc_f_ext_state __f;
                __riscv_mc_d_ext_state __d;
                __riscv_mc_q_ext_state __q;
            }
        }

        struct mcontext_t
        {
            __riscv_mc_gp_state __gregs;
            __riscv_mc_fp_state __fpregs;
        }

        struct ucontext_t
        {
            c_ulong     __uc_flags;
            ucontext_t* uc_link;
            stack_t     uc_stack;
            sigset_t    uc_sigmask;
            char[1024 / 8 - sigset_t.sizeof] __reserved = 0;
            mcontext_t  uc_mcontext;
        }
    }
    else version (SPARC64)
    {
        enum MC_NGREG = 19;
        alias mc_greg_t = c_ulong;
        alias mc_gregset_t = mc_greg_t[MC_NGREG];

        struct mc_fq
        {
            c_ulong* mcfq_addr;
            uint     mcfq_insn;
        }

        struct mc_fpu_t
        {
            union mcfpu_fregs_t
            {
                uint[32]    sregs;
                c_ulong[32] dregs;
                real[16]    qregs;
            }
            mcfpu_fregs_t mcfpu_fregs;
            c_ulong       mcfpu_fsr;
            c_ulong       mcfpu_fprs;
            c_ulong       mcfpu_gsr;
            mc_fq*        mcfpu_fq;
            ubyte         mcfpu_qcnt;
            ubyte         mcfpu_qentsz;
            ubyte         mcfpu_enab;
        }

        struct mcontext_t
        {
            mc_gregset_t mc_gregs;
            mc_greg_t    mc_fp;
            mc_greg_t    mc_i7;
            mc_fpu_t     mc_fpregs;
        }

        struct ucontext_t
        {
            ucontext_t* uc_link;
            c_ulong     uc_flags;
            c_ulong     __uc_sigmask;
            mcontext_t  uc_mcontext;
            stack_t     uc_stack;
            sigset_t    uc_sigmask;
        }

        /* Location of the users' stored registers relative to R0.
         * Usage is as an index into a gregset_t array. */
        enum
        {
            REG_PSR = 0,
            REG_PC  = 1,
            REG_nPC = 2,
            REG_Y   = 3,
            REG_G1  = 4,
            REG_G2  = 5,
            REG_G3  = 6,
            REG_G4  = 7,
            REG_G5  = 8,
            REG_G6  = 9,
            REG_G7  = 10,
            REG_O0  = 11,
            REG_O1  = 12,
            REG_O2  = 13,
            REG_O3  = 14,
            REG_O4  = 15,
            REG_O5  = 16,
            REG_O6  = 17,
            REG_O7  = 18,
            REG_ASI = 19,
            REG_FPRS = 20,
        }

        enum NGREG = 21;
        alias greg_t = c_ulong;
        alias gregset_t = greg_t[NGREG];
    }
    else version (IBMZ_Any)
    {
        public import core.sys.posix.signal : sigset_t;

        enum NGREG = 27;

        alias greg_t = c_ulong;
        alias gregset_t = align(8) greg_t[NGREG];

        align(8) struct __psw_t
        {
            c_ulong mask;
            c_ulong addr;
        }

        union fpreg_t
        {
            double d;
            float  f;
        }

        struct fpregset_t
        {
            uint        fpc;
            fpreg_t[16] fprs;
        }

        struct  mcontext_t
        {
            __psw_t     psw;
            c_ulong[16] gregs;
            uint[16]    aregs;
            fpregset_t  fpregs;
        }

        struct ucontext
        {
            c_ulong    uc_flags;
            ucontext*  uc_link;
            stack_t    uc_stack;
            mcontext_t uc_mcontext;
            sigset_t   uc_sigmask;
        }

        alias ucontext_t = ucontext;
    }
    else
        static assert(0, "unimplemented");
}
else version (FreeBSD)
{
    // <machine/ucontext.h>
    version (X86_64)
    {
      alias long __register_t;
      alias uint __uint32_t;
      alias ushort __uint16_t;

      struct mcontext_t {
       __register_t    mc_onstack;
       __register_t    mc_rdi;
       __register_t    mc_rsi;
       __register_t    mc_rdx;
       __register_t    mc_rcx;
       __register_t    mc_r8;
       __register_t    mc_r9;
       __register_t    mc_rax;
       __register_t    mc_rbx;
       __register_t    mc_rbp;
       __register_t    mc_r10;
       __register_t    mc_r11;
       __register_t    mc_r12;
       __register_t    mc_r13;
       __register_t    mc_r14;
       __register_t    mc_r15;
       __uint32_t      mc_trapno;
       __uint16_t      mc_fs;
       __uint16_t      mc_gs;
       __register_t    mc_addr;
       __uint32_t      mc_flags;
       __uint16_t      mc_es;
       __uint16_t      mc_ds;
       __register_t    mc_err;
       __register_t    mc_rip;
       __register_t    mc_cs;
       __register_t    mc_rflags;
       __register_t    mc_rsp;
       __register_t    mc_ss;

       long    mc_len;                 /* sizeof(mcontext_t) */

       long    mc_fpformat;
       long    mc_ownedfp;

       align(16)
       long[64]    mc_fpstate;

       __register_t    mc_fsbase;
       __register_t    mc_gsbase;

       long[6]    mc_spare;
      }
    }
    else version (X86)
    {
        alias int __register_t;

        struct mcontext_t
        {
            __register_t    mc_onstack;
            __register_t    mc_gs;
            __register_t    mc_fs;
            __register_t    mc_es;
            __register_t    mc_ds;
            __register_t    mc_edi;
            __register_t    mc_esi;
            __register_t    mc_ebp;
            __register_t    mc_isp;
            __register_t    mc_ebx;
            __register_t    mc_edx;
            __register_t    mc_ecx;
            __register_t    mc_eax;
            __register_t    mc_trapno;
            __register_t    mc_err;
            __register_t    mc_eip;
            __register_t    mc_cs;
            __register_t    mc_eflags;
            __register_t    mc_esp;
            __register_t    mc_ss;

            int             mc_len;
            int             mc_fpformat;
            int             mc_ownedfp;
            int[1]          mc_spare1;

            align(16)
            int[128]        mc_fpstate;

            __register_t    mc_fsbase;
            __register_t    mc_gsbase;

            int[6]          mc_spare2;
        }
    }
    else version (AArch64)
    {
        alias __register_t = long;

        struct gpregs
        {
            __register_t[30] gp_x;
            __register_t     gp_lr;
            __register_t     gp_sp;
            __register_t     gp_elr;
            uint             gp_spsr;
            int              gp_pad;
        }

        struct fpregs
        {
            ulong[2][32]    fp_q; // __uint128_t
            uint            fp_sr;
            uint            fp_cr;
            int             fp_flags;
            int             fp_pad;
        }

        struct mcontext_t
        {
            gpregs          mc_gpregs;
            fpregs          mc_fpregs;
            int             mc_flags;
            int             mc_pad;
            ulong[8]        mc_spare;
        }
    }

    // <ucontext.h>
    enum UCF_SWAPPED = 0x00000001;

    struct ucontext_t
    {
        sigset_t        uc_sigmask;
        mcontext_t      uc_mcontext;

        ucontext_t*     uc_link;
        stack_t         uc_stack;
        int             uc_flags;
        int[4]          __spare__;
    }
}
else version (NetBSD)
{

    version (X86_64)
    {
      enum { NGREG = 26 };
      alias __greg_t = ulong;
      alias __gregset_t = __greg_t[NGREG];
      alias __fpregset_t = align(8)ubyte[512];

      struct mcontext_t {
        __gregset_t     __gregs;
        __greg_t        _mc_tlsbase;
        __fpregset_t    __fpregs;
      }
    }
    else version (X86)
    {
      enum { NGREG = 19 };
      alias __greg_t = ulong;
      alias __gregset_t = __greg_t[_NGREG];
      struct __fpregset_t{
        union __fp_reg_set{
                struct __fpchip_state{
                        int[27]     __fp_state; /* Environment and registers */
                } ;       /* x87 regs in fsave format */
                struct __fp_xmm_state{
                        ubyte[512]    __fp_xmm;
                } ;       /* x87 and xmm regs in fxsave format */
                int[128]     __fp_fpregs;
        };
        __fpregset_t __fp_reg_set;
        int[33]     __fp_pad;                   /* Historic padding */
      };

      struct mcontext_t {
        __gregset_t     __gregs;
        __fpregset_t    __fpregs;
        __greg_t        _mc_tlsbase;
      }
    }

    struct ucontext_t
    {
        uint    uc_flags;       /* properties */
        ucontext_t *    uc_link;        /* context to resume */
        sigset_t        uc_sigmask;     /* signals blocked in this context */
        stack_t         uc_stack;       /* the stack used by this context */
        mcontext_t      uc_mcontext;    /* machine state */
        /+ todo #if defined(_UC_MACHINE_PAD)
                long            __uc_pad[_UC_MACHINE_PAD];
        #endif
        +/

    }
}
else version (DragonFlyBSD)
{
    // <machine/ucontext.h>
    version (X86_64)
    {
      alias long __register_t;
      alias uint __uint32_t;
      alias ushort __uint16_t;

      struct mcontext_t {
        __register_t    mc_onstack;
        __register_t    mc_rdi;
        __register_t    mc_rsi;
        __register_t    mc_rdx;
        __register_t    mc_rcx;
        __register_t    mc_r8;
        __register_t    mc_r9;
        __register_t    mc_rax;
        __register_t    mc_rbx;
        __register_t    mc_rbp;
        __register_t    mc_r10;
        __register_t    mc_r11;
        __register_t    mc_r12;
        __register_t    mc_r13;
        __register_t    mc_r14;
        __register_t    mc_r15;
        __register_t    mc_xflags;
        __register_t    mc_trapno;
        __register_t    mc_addr;
        __register_t    mc_flags;
        __register_t    mc_err;
        __register_t    mc_rip;
        __register_t    mc_cs;
        __register_t    mc_rflags;
        __register_t    mc_rsp;
        __register_t    mc_ss;

        uint            mc_len;
        uint            mc_fpformat;
        uint            mc_ownedfp;
        uint            mc_reserved;
        uint[8]         mc_unused;
        int[256]        mc_fpregs;
      };  // __attribute__((aligned(64)));
    }
    else
    {
        static assert(0, "Only X86_64 support on DragonFlyBSD");
    }

    // <ucontext.h>
    enum UCF_SWAPPED = 0x00000001;

    struct ucontext_t
    {
        sigset_t        uc_sigmask;
        mcontext_t      uc_mcontext;

        ucontext_t*     uc_link;
        stack_t         uc_stack;
        void            function(ucontext_t *, void *) uc_cofunc;
        void*           uc_arg;
        int[4]          __spare__;
    }
}
else version (Solaris)
{
    private import core.stdc.stdint;

    alias uint[4] upad128_t;

    version (SPARC64)
    {
        enum _NGREG = 21;
        alias long greg_t;
    }
    else version (SPARC)
    {
        enum _NGREG = 19;
        alias int greg_t;
    }
    else version (X86_64)
    {
        enum _NGREG = 28;
        alias long greg_t;
    }
    else version (X86)
    {
        enum _NGREG = 19;
        alias int greg_t;
    }
    else
        static assert(0, "unimplemented");

    alias greg_t[_NGREG] gregset_t;

    version (SPARC64)
    {
        private
        {
            struct _fpq
            {
                uint *fpq_addr;
                uint fpq_instr;
            }

            struct fq
            {
                union
                {
                    double whole;
                    _fpq fpq;
                }
            }
        }

        struct fpregset_t
        {
            union
            {
                uint[32]   fpu_regs;
                double[32] fpu_dregs;
                real[16]   fpu_qregs;
            }
            fq    *fpu_q;
            ulong fpu_fsr;
            ubyte fpu_qcnt;
            ubyte fpu_q_entrysize;
            ubyte fpu_en;
        }
    }
    else version (SPARC)
    {
        private
        {
            struct _fpq
            {
                uint *fpq_addr;
                uint fpq_instr;
            }

            struct fq
            {
                union
                {
                    double whole;
                    _fpq fpq;
                }
            }
        }

        struct fpregset_t
        {
            union
            {
                uint[32]   fpu_regs;
                double[16] fpu_dregs;
            };
            fq    *fpu_q;
            uint  fpu_fsr;
            ubyte fpu_qcnt;
            ubyte fpu_q_entrysize;
            ubyte fpu_en;
        }
    }
    else version (X86_64)
    {
        private
        {
            union _u_st
            {
                ushort[5]   fpr_16;
                upad128_t   __fpr_pad;
            }
        }

        struct fpregset_t
        {
            union fp_reg_set
            {
                struct fpchip_state
                {
                    ushort          cw;
                    ushort          sw;
                    ubyte           fctw;
                    ubyte           __fx_rsvd;
                    ushort          fop;
                    ulong           rip;
                    ulong           rdp;
                    uint            mxcsr;
                    uint            mxcsr_mask;
                    _u_st[8]        st;
                    upad128_t[16]   xmm;
                    upad128_t[6]    __fx_ign2;
                    uint            status;
                    uint            xstatus;
                }
                uint[130]   f_fpregs;
            }
        }
    }
    else version (X86)
    {
        struct fpregset_t
        {
            union u_fp_reg_set
            {
                struct s_fpchip_state
                {
                    uint[27]        state;
                    uint            status;
                    uint            mxcsr;
                    uint            xstatus;
                    uint[2]         __pad;
                    upad128_t[8]    xmm;
                }
                s_fpchip_state    fpchip_state;

                struct s_fp_emul_space
                {
                    ubyte[246]  fp_emul;
                    ubyte[2]    fp_epad;
                }
                s_fp_emul_space   fp_emul_space;
                uint[95]        f_fpregs;
            }
        u_fp_reg_set fp_reg_set;
        }
    }
    else
        static assert(0, "unimplemented");

    version (SPARC_Any)
    {
        private
        {
            struct rwindow
            {
                greg_t[8]     rw_local;
                greg_t[8]     rw_in;
            }

            struct gwindows_t
            {
                int         wbcnt;
                greg_t[31] *spbuf;
                rwindow[31] wbuf;
            }

            struct xrs_t
            {
                uint         xrs_id;
                caddr_t      xrs_ptr;
            }

            struct cxrs_t
            {
                uint         cxrs_id;
                caddr_t      cxrs_ptr;
            }

            alias int64_t[16] asrset_t;
        }

        struct mcontext_t
        {
            gregset_t    gregs;
            gwindows_t   *gwins;
            fpregset_t   fpregs;
            xrs_t        xrs;
            version (SPARC64)
            {
                asrset_t asrs;
                cxrs_t   cxrs;
                c_long[2] filler;
            }
            else version (SPARC)
            {
                cxrs_t   cxrs;
                c_long[17] filler;
            }
        }
    }
    else version (X86_Any)
    {
        private
        {
            struct xrs_t
            {
                uint         xrs_id;
                caddr_t      xrs_ptr;
            }
        }

        struct mcontext_t
        {
            gregset_t   gregs;
            fpregset_t  fpregs;
        }
    }

    struct ucontext_t
    {
        version (SPARC_Any)
            uint    uc_flags;
        else version (X86_Any)
            c_ulong uc_flags;
        ucontext_t  *uc_link;
        sigset_t    uc_sigmask;
        stack_t     uc_stack;
        mcontext_t  uc_mcontext;
        version (SPARC64)
            c_long[4]  uc_filler;
        else version (SPARC)
            c_long[23] uc_filler;
        else version (X86_Any)
        {
            xrs_t      uc_xrs;
            c_long[3]  uc_filler;
        }
    }
}
else version (CRuntime_UClibc)
{
    version (X86_64)
    {
        enum
        {
            REG_R8 = 0,
            REG_R9,
            REG_R10,
            REG_R11,
            REG_R12,
            REG_R13,
            REG_R14,
            REG_R15,
            REG_RDI,
            REG_RSI,
            REG_RBP,
            REG_RBX,
            REG_RDX,
            REG_RAX,
            REG_RCX,
            REG_RSP,
            REG_RIP,
            REG_EFL,
            REG_CSGSFS,     /* Actually short cs, gs, fs, __pad0.  */
            REG_ERR,
            REG_TRAPNO,
            REG_OLDMASK,
            REG_CR2
        }

        alias sigcontext mcontext_t;

        struct ucontext_t
        {
            c_ulong         uc_flags;
            ucontext_t*     uc_link;
            stack_t         uc_stack;
            mcontext_t      uc_mcontext;
            sigset_t        uc_sigmask;
        }
    }
    else version (MIPS32)
    {
        alias greg_t    = ulong;
        enum NGREG      = 32;
        enum NFPREG     = 32;
        alias gregset_t = greg_t[NGREG];

        struct fpregset_t
        {
            union fp_r
            {
                double[NFPREG]  fp_dregs;
                struct _fp_fregs
                {
                    float   _fp_fregs;
                    uint    _fp_pad;
                }
                _fp_fregs[NFPREG] fp_fregs;
            }
        }

        version (MIPS_O32)
        {
            struct mcontext_t
            {
                uint regmask;
                uint status;
                greg_t pc;
                gregset_t gregs;
                fpregset_t fpregs;
                uint fp_owned;
                uint fpc_csr;
                uint fpc_eir;
                uint used_math;
                uint dsp;
                greg_t mdhi;
                greg_t mdlo;
                c_ulong hi1;
                c_ulong lo1;
                c_ulong hi2;
                c_ulong lo2;
                c_ulong hi3;
                c_ulong lo3;
            }
        }
        else
        {
            struct mcontext_t
            {
                gregset_t gregs;
                fpregset_t fpregs;
                greg_t mdhi;
                greg_t hi1;
                greg_t hi2;
                greg_t hi3;
                greg_t mdlo;
                greg_t lo1;
                greg_t lo2;
                greg_t lo3;
                greg_t pc;
                uint fpc_csr;
                uint used_math;
                uint dsp;
                uint reserved;
            }
        }

        struct ucontext_t
        {
            c_ulong uc_flags;
            ucontext_t* uc_link;
            stack_t uc_stack;
            mcontext_t uc_mcontext;
            sigset_t uc_sigmask;
        }
    }
    else version (ARM)
    {
        enum
        {
            R0 = 0,
            R1 = 1,
            R2 = 2,
            R3 = 3,
            R4 = 4,
            R5 = 5,
            R6 = 6,
            R7 = 7,
            R8 = 8,
            R9 = 9,
            R10 = 10,
            R11 = 11,
            R12 = 12,
            R13 = 13,
            R14 = 14,
            R15 = 15
        }

        struct sigcontext
        {
            c_ulong trap_no;
            c_ulong error_code;
            c_ulong oldmask;
            c_ulong arm_r0;
            c_ulong arm_r1;
            c_ulong arm_r2;
            c_ulong arm_r3;
            c_ulong arm_r4;
            c_ulong arm_r5;
            c_ulong arm_r6;
            c_ulong arm_r7;
            c_ulong arm_r8;
            c_ulong arm_r9;
            c_ulong arm_r10;
            c_ulong arm_fp;
            c_ulong arm_ip;
            c_ulong arm_sp;
            c_ulong arm_lr;
            c_ulong arm_pc;
            c_ulong arm_cpsr;
            c_ulong fault_address;
        }

        alias sigcontext mcontext_t;

        struct ucontext_t
        {
            c_ulong uc_flags;
            ucontext_t* uc_link;
            stack_t uc_stack;
            mcontext_t uc_mcontext;
            sigset_t uc_sigmask;
            align(8) c_ulong[128] uc_regspace;
        }
    }
    else
        static assert(0, "unimplemented");
}

//
// Obsolescent (OB)
//
/*
int  getcontext(ucontext_t*);
void makecontext(ucontext_t*, void function(), int, ...);
int  setcontext(in ucontext_t*);
int  swapcontext(ucontext_t*, in ucontext_t*);
*/

static if ( is( ucontext_t ) )
{
    int  getcontext(ucontext_t*);

    version (Solaris)
    {
        version (SPARC_Any)
        {
            void __makecontext_v2(ucontext_t*, void function(), int, ...);
            alias makecontext = __makecontext_v2;
        }
        else
            void makecontext(ucontext_t*, void function(), int, ...);
    }
    else
        void makecontext(ucontext_t*, void function(), int, ...);

    int  setcontext(in ucontext_t*);
    int  swapcontext(ucontext_t*, in ucontext_t*);
}

version (Solaris)
{
    int walkcontext(in ucontext_t*, int function(uintptr_t, int, void*), void*);
    int addrtosymstr(uintptr_t, char*, int);
    int printstack(int);
}

                                                                                                                                                                                                                                                                                                                                                                                     /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.unistd;

private import core.sys.posix.config;
private import core.stdc.stddef;
public import core.sys.posix.inttypes;  // for intptr_t
public import core.sys.posix.sys.types; // for ssize_t, uid_t, gid_t, off_t, pid_t, useconds_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C):
nothrow:
@nogc:

enum STDIN_FILENO  = 0;
enum STDOUT_FILENO = 1;
enum STDERR_FILENO = 2;

extern __gshared char*   optarg;
extern __gshared int     optind;
extern __gshared int     opterr;
extern __gshared int     optopt;

int     access(in char*, int);
uint    alarm(uint) @trusted;
int     chdir(in char*);
int     chown(in char*, uid_t, gid_t);
int     close(int) @trusted;
size_t  confstr(int, char*, size_t);
int     dup(int) @trusted;
int     dup2(int, int) @trusted;
int     execl(in char*, in char*, ...);
int     execle(in char*, in char*, ...);
int     execlp(in char*, in char*, ...);
int     execv(in char*, in char**);
int     execve(in char*, in char**, in char**);
int     execvp(in char*, in char**);
void    _exit(int) @trusted;
int     fchown(int, uid_t, gid_t) @trusted;
pid_t   fork() @trusted;
c_long  fpathconf(int, int) @trusted;
//int     ftruncate(int, off_t);
char*   getcwd(char*, size_t);
gid_t   getegid() @trusted;
uid_t   geteuid() @trusted;
gid_t   getgid() @trusted;
int     getgroups(int, gid_t *);
int     gethostname(char*, size_t);
char*   getlogin() @trusted;
int     getlogin_r(char*, size_t);
int     getopt(int, in char**, in char*);
pid_t   getpgrp() @trusted;
pid_t   getpid() @trusted;
pid_t   getppid() @trusted;
uid_t   getuid() @trusted;
int     isatty(int) @trusted;
int     link(in char*, in char*);
//off_t   lseek(int, off_t, int);
c_long  pathconf(in char*, int);
int     pause() @trusted;
int     pipe(ref int[2]) @trusted;
ssize_t read(int, void*, size_t);
ssize_t readlink(in char*, char*, size_t);
int     rmdir(in char*);
int     setegid(gid_t) @trusted;
int     seteuid(uid_t) @trusted;
int     setgid(gid_t) @trusted;
int     setgroups(size_t, in gid_t*) @trusted;
int     setpgid(pid_t, pid_t) @trusted;
pid_t   setsid() @trusted;
int     setuid(uid_t) @trusted;
uint    sleep(uint) @trusted;
int     symlink(in char*, in char*);
c_long  sysconf(int) @trusted;
pid_t   tcgetpgrp(int) @trusted;
int     tcsetpgrp(int, pid_t) @trusted;
char*   ttyname(int) @trusted;
int     ttyname_r(int, char*, size_t);
int     unlink(in char*);
ssize_t write(int, in void*, size_t);

version (CRuntime_Glibc)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    off_t lseek64(int, off_t, int) @trusted;
    alias lseek64 lseek;
  }
  else
  {
    off_t lseek(int, off_t, int) @trusted;
  }
  static if ( __USE_LARGEFILE64 )
  {
    int   ftruncate64(int, off_t) @trusted;
    alias ftruncate64 ftruncate;
  }
  else
  {
    int   ftruncate(int, off_t) @trusted;
  }
}
else version (FreeBSD)
{
    off_t lseek(int, off_t, int) @trusted;
    int   ftruncate(int, off_t) @trusted;
}
else version (NetBSD)
{
    off_t lseek(int, off_t, int) @trusted;
    int   ftruncate(int, off_t) @trusted;
}
else version (DragonFlyBSD)
{
    off_t lseek(int, off_t, int) @trusted;
    int   ftruncate(int, off_t) @trusted;
}
else version (Solaris)
{
    version (D_LP64)
    {
        off_t   lseek(int, off_t, int) @trusted;
        alias   lseek lseek64;

        int     ftruncate(int, off_t) @trusted;
        alias   ftruncate ftruncate64;
    }
    else
    {
        static if ( __USE_LARGEFILE64 )
        {
            off64_t lseek64(int, off64_t, int) @trusted;
            alias   lseek64 lseek;

            int     ftruncate64(int, off64_t) @trusted;
            alias   ftruncate64 ftruncate;
        }
        else
        {
            off_t   lseek(int, off_t, int) @trusted;
            int     ftruncate(int, off_t) @trusted;
        }
    }
}
else version (Darwin)
{
    off_t lseek(int, off_t, int) @trusted;
    int   ftruncate(int, off_t) @trusted;
}
else version (CRuntime_Bionic)
{
    off_t lseek(int, off_t, int) @trusted;
    int   ftruncate(int, off_t) @trusted;
}
else version (CRuntime_Musl)
{
    int ftruncate(int, off_t) @trusted;
    off_t lseek(int, off_t, int) @trusted;
    alias ftruncate ftruncate64;
    alias lseek lseek64;
}
else version (CRuntime_UClibc)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    off_t lseek64(int, off_t, int) @trusted;
    alias lseek64 lseek;
  }
  else
  {
    off_t lseek(int, off_t, int) @trusted;
  }
  static if ( __USE_LARGEFILE64 )
  {
    int   ftruncate64(int, off_t) @trusted;
    alias ftruncate64 ftruncate;
  }
  else
  {
    int   ftruncate(int, off_t) @trusted;
  }
}

version (CRuntime_Glibc)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _CS_PATH,

        _CS_V6_WIDTH_RESTRICTED_ENVS,

        _CS_GNU_LIBC_VERSION,
        _CS_GNU_LIBPTHREAD_VERSION,

        _CS_LFS_CFLAGS = 1000,
        _CS_LFS_LDFLAGS,
        _CS_LFS_LIBS,
        _CS_LFS_LINTFLAGS,
        _CS_LFS64_CFLAGS,
        _CS_LFS64_LDFLAGS,
        _CS_LFS64_LIBS,
        _CS_LFS64_LINTFLAGS,

        _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
        _CS_XBS5_ILP32_OFF32_LDFLAGS,
        _CS_XBS5_ILP32_OFF32_LIBS,
        _CS_XBS5_ILP32_OFF32_LINTFLAGS,
        _CS_XBS5_ILP32_OFFBIG_CFLAGS,
        _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
        _CS_XBS5_ILP32_OFFBIG_LIBS,
        _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
        _CS_XBS5_LP64_OFF64_CFLAGS,
        _CS_XBS5_LP64_OFF64_LDFLAGS,
        _CS_XBS5_LP64_OFF64_LIBS,
        _CS_XBS5_LP64_OFF64_LINTFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_LIBS,
        _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,

        _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFF32_LIBS,
        _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
        _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LIBS,
        _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
    }

    enum
    {
        _PC_LINK_MAX,
        _PC_MAX_CANON,
        _PC_MAX_INPUT,
        _PC_NAME_MAX,
        _PC_PATH_MAX,
        _PC_PIPE_BUF,
        _PC_CHOWN_RESTRICTED,
        _PC_NO_TRUNC,
        _PC_VDISABLE,
        _PC_SYNC_IO,
        _PC_ASYNC_IO,
        _PC_PRIO_IO,
        _PC_SOCK_MAXBUF,
        _PC_FILESIZEBITS,
        _PC_REC_INCR_XFER_SIZE,
        _PC_REC_MAX_XFER_SIZE,
        _PC_REC_MIN_XFER_SIZE,
        _PC_REC_XFER_ALIGN,
        _PC_ALLOC_SIZE_MIN,
        _PC_SYMLINK_MAX,
        _PC_2_SYMLINKS
    }

    enum
    {
        _SC_ARG_MAX,
        _SC_CHILD_MAX,
        _SC_CLK_TCK,
        _SC_NGROUPS_MAX,
        _SC_OPEN_MAX,
        _SC_STREAM_MAX,
        _SC_TZNAME_MAX,
        _SC_JOB_CONTROL,
        _SC_SAVED_IDS,
        _SC_REALTIME_SIGNALS,
        _SC_PRIORITY_SCHEDULING,
        _SC_TIMERS,
        _SC_ASYNCHRONOUS_IO,
        _SC_PRIORITIZED_IO,
        _SC_SYNCHRONIZED_IO,
        _SC_FSYNC,
        _SC_MAPPED_FILES,
        _SC_MEMLOCK,
        _SC_MEMLOCK_RANGE,
        _SC_MEMORY_PROTECTION,
        _SC_MESSAGE_PASSING,
        _SC_SEMAPHORES,
        _SC_SHARED_MEMORY_OBJECTS,
        _SC_AIO_LISTIO_MAX,
        _SC_AIO_MAX,
        _SC_AIO_PRIO_DELTA_MAX,
        _SC_DELAYTIMER_MAX,
        _SC_MQ_OPEN_MAX,
        _SC_MQ_PRIO_MAX,
        _SC_VERSION,
        _SC_PAGESIZE,
        _SC_PAGE_SIZE = _SC_PAGESIZE,
        _SC_RTSIG_MAX,
        _SC_SEM_NSEMS_MAX,
        _SC_SEM_VALUE_MAX,
        _SC_SIGQUEUE_MAX,
        _SC_TIMER_MAX,

        _SC_BC_BASE_MAX,
        _SC_BC_DIM_MAX,
        _SC_BC_SCALE_MAX,
        _SC_BC_STRING_MAX,
        _SC_COLL_WEIGHTS_MAX,
        _SC_EQUIV_CLASS_MAX,
        _SC_EXPR_NEST_MAX,
        _SC_LINE_MAX,
        _SC_RE_DUP_MAX,
        _SC_CHARCLASS_NAME_MAX,

        _SC_2_VERSION,
        _SC_2_C_BIND,
        _SC_2_C_DEV,
        _SC_2_FORT_DEV,
        _SC_2_FORT_RUN,
        _SC_2_SW_DEV,
        _SC_2_LOCALEDEF,

        _SC_PII,
        _SC_PII_XTI,
        _SC_PII_SOCKET,
        _SC_PII_INTERNET,
        _SC_PII_OSI,
        _SC_POLL,
        _SC_SELECT,
        _SC_UIO_MAXIOV,
        _SC_IOV_MAX = _SC_UIO_MAXIOV,
        _SC_PII_INTERNET_STREAM,
        _SC_PII_INTERNET_DGRAM,
        _SC_PII_OSI_COTS,
        _SC_PII_OSI_CLTS,
        _SC_PII_OSI_M,
        _SC_T_IOV_MAX,

        _SC_THREADS,
        _SC_THREAD_SAFE_FUNCTIONS,
        _SC_GETGR_R_SIZE_MAX,
        _SC_GETPW_R_SIZE_MAX,
        _SC_LOGIN_NAME_MAX,
        _SC_TTY_NAME_MAX,
        _SC_THREAD_DESTRUCTOR_ITERATIONS,
        _SC_THREAD_KEYS_MAX,
        _SC_THREAD_STACK_MIN,
        _SC_THREAD_THREADS_MAX,
        _SC_THREAD_ATTR_STACKADDR,
        _SC_THREAD_ATTR_STACKSIZE,
        _SC_THREAD_PRIORITY_SCHEDULING,
        _SC_THREAD_PRIO_INHERIT,
        _SC_THREAD_PRIO_PROTECT,
        _SC_THREAD_PROCESS_SHARED,

        _SC_NPROCESSORS_CONF,
        _SC_NPROCESSORS_ONLN,
        _SC_PHYS_PAGES,
        _SC_AVPHYS_PAGES,
        _SC_ATEXIT_MAX,
        _SC_PASS_MAX,

        _SC_XOPEN_VERSION,
        _SC_XOPEN_XCU_VERSION,
        _SC_XOPEN_UNIX,
        _SC_XOPEN_CRYPT,
        _SC_XOPEN_ENH_I18N,
        _SC_XOPEN_SHM,

        _SC_2_CHAR_TERM,
        _SC_2_C_VERSION,
        _SC_2_UPE,

        _SC_XOPEN_XPG2,
        _SC_XOPEN_XPG3,
        _SC_XOPEN_XPG4,

        _SC_CHAR_BIT,
        _SC_CHAR_MAX,
        _SC_CHAR_MIN,
        _SC_INT_MAX,
        _SC_INT_MIN,
        _SC_LONG_BIT,
        _SC_WORD_BIT,
        _SC_MB_LEN_MAX,
        _SC_NZERO,
        _SC_SSIZE_MAX,
        _SC_SCHAR_MAX,
        _SC_SCHAR_MIN,
        _SC_SHRT_MAX,
        _SC_SHRT_MIN,
        _SC_UCHAR_MAX,
        _SC_UINT_MAX,
        _SC_ULONG_MAX,
        _SC_USHRT_MAX,

        _SC_NL_ARGMAX,
        _SC_NL_LANGMAX,
        _SC_NL_MSGMAX,
        _SC_NL_NMAX,
        _SC_NL_SETMAX,
        _SC_NL_TEXTMAX,

        _SC_XBS5_ILP32_OFF32,
        _SC_XBS5_ILP32_OFFBIG,
        _SC_XBS5_LP64_OFF64,
        _SC_XBS5_LPBIG_OFFBIG,

        _SC_XOPEN_LEGACY,
        _SC_XOPEN_REALTIME,
        _SC_XOPEN_REALTIME_THREADS,

        _SC_ADVISORY_INFO,
        _SC_BARRIERS,
        _SC_BASE,
        _SC_C_LANG_SUPPORT,
        _SC_C_LANG_SUPPORT_R,
        _SC_CLOCK_SELECTION,
        _SC_CPUTIME,
        _SC_THREAD_CPUTIME,
        _SC_DEVICE_IO,
        _SC_DEVICE_SPECIFIC,
        _SC_DEVICE_SPECIFIC_R,
        _SC_FD_MGMT,
        _SC_FIFO,
        _SC_PIPE,
        _SC_FILE_ATTRIBUTES,
        _SC_FILE_LOCKING,
        _SC_FILE_SYSTEM,
        _SC_MONOTONIC_CLOCK,
        _SC_MULTI_PROCESS,
        _SC_SINGLE_PROCESS,
        _SC_NETWORKING,
        _SC_READER_WRITER_LOCKS,
        _SC_SPIN_LOCKS,
        _SC_REGEXP,
        _SC_REGEX_VERSION,
        _SC_SHELL,
        _SC_SIGNALS,
        _SC_SPAWN,
        _SC_SPORADIC_SERVER,
        _SC_THREAD_SPORADIC_SERVER,
        _SC_SYSTEM_DATABASE,
        _SC_SYSTEM_DATABASE_R,
        _SC_TIMEOUTS,
        _SC_TYPED_MEMORY_OBJECTS,
        _SC_USER_GROUPS,
        _SC_USER_GROUPS_R,
        _SC_2_PBS,
        _SC_2_PBS_ACCOUNTING,
        _SC_2_PBS_LOCATE,
        _SC_2_PBS_MESSAGE,
        _SC_2_PBS_TRACK,
        _SC_SYMLOOP_MAX,
        _SC_STREAMS,
        _SC_2_PBS_CHECKPOINT,

        _SC_V6_ILP32_OFF32,
        _SC_V6_ILP32_OFFBIG,
        _SC_V6_LP64_OFF64,
        _SC_V6_LPBIG_OFFBIG,

        _SC_HOST_NAME_MAX,
        _SC_TRACE,
        _SC_TRACE_EVENT_FILTER,
        _SC_TRACE_INHERIT,
        _SC_TRACE_LOG,

        _SC_LEVEL1_ICACHE_SIZE,
        _SC_LEVEL1_ICACHE_ASSOC,
        _SC_LEVEL1_ICACHE_LINESIZE,
        _SC_LEVEL1_DCACHE_SIZE,
        _SC_LEVEL1_DCACHE_ASSOC,
        _SC_LEVEL1_DCACHE_LINESIZE,
        _SC_LEVEL2_CACHE_SIZE,
        _SC_LEVEL2_CACHE_ASSOC,
        _SC_LEVEL2_CACHE_LINESIZE,
        _SC_LEVEL3_CACHE_SIZE,
        _SC_LEVEL3_CACHE_ASSOC,
        _SC_LEVEL3_CACHE_LINESIZE,
        _SC_LEVEL4_CACHE_SIZE,
        _SC_LEVEL4_CACHE_ASSOC,
        _SC_LEVEL4_CACHE_LINESIZE,

        _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
        _SC_RAW_SOCKETS
    }
}
else version (Darwin)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _SC_ARG_MAX                      =   1,
        _SC_CHILD_MAX                    =   2,
        _SC_CLK_TCK                      =   3,
        _SC_NGROUPS_MAX                  =   4,
        _SC_OPEN_MAX                     =   5,
        _SC_JOB_CONTROL                  =   6,
        _SC_SAVED_IDS                    =   7,
        _SC_VERSION                      =   8,
        _SC_BC_BASE_MAX                  =   9,
        _SC_BC_DIM_MAX                   =  10,
        _SC_BC_SCALE_MAX                 =  11,
        _SC_BC_STRING_MAX                =  12,
        _SC_COLL_WEIGHTS_MAX             =  13,
        _SC_EXPR_NEST_MAX                =  14,
        _SC_LINE_MAX                     =  15,
        _SC_RE_DUP_MAX                   =  16,
        _SC_2_VERSION                    =  17,
        _SC_2_C_BIND                     =  18,
        _SC_2_C_DEV                      =  19,
        _SC_2_CHAR_TERM                  =  20,
        _SC_2_FORT_DEV                   =  21,
        _SC_2_FORT_RUN                   =  22,
        _SC_2_LOCALEDEF                  =  23,
        _SC_2_SW_DEV                     =  24,
        _SC_2_UPE                        =  25,
        _SC_STREAM_MAX                   =  26,
        _SC_TZNAME_MAX                   =  27,
        _SC_ASYNCHRONOUS_IO              =  28,
        _SC_PAGESIZE                     =  29,
        _SC_MEMLOCK                      =  30,
        _SC_MEMLOCK_RANGE                =  31,
        _SC_MEMORY_PROTECTION            =  32,
        _SC_MESSAGE_PASSING              =  33,
        _SC_PRIORITIZED_IO               =  34,
        _SC_PRIORITY_SCHEDULING          =  35,
        _SC_REALTIME_SIGNALS             =  36,
        _SC_SEMAPHORES                   =  37,
        _SC_FSYNC                        =  38,
        _SC_SHARED_MEMORY_OBJECTS        =  39,
        _SC_SYNCHRONIZED_IO              =  40,
        _SC_TIMERS                       =  41,
        _SC_AIO_LISTIO_MAX               =  42,
        _SC_AIO_MAX                      =  43,
        _SC_AIO_PRIO_DELTA_MAX           =  44,
        _SC_DELAYTIMER_MAX               =  45,
        _SC_MQ_OPEN_MAX                  =  46,
        _SC_MAPPED_FILES                 =  47,
        _SC_RTSIG_MAX                    =  48,
        _SC_SEM_NSEMS_MAX                =  49,
        _SC_SEM_VALUE_MAX                =  50,
        _SC_SIGQUEUE_MAX                 =  51,
        _SC_TIMER_MAX                    =  52,
        _SC_IOV_MAX                      =  56,
        _SC_NPROCESSORS_CONF             =  57,
        _SC_NPROCESSORS_ONLN             =  58,
        _SC_2_PBS                        =  59,
        _SC_2_PBS_ACCOUNTING             =  60,
        _SC_2_PBS_CHECKPOINT             =  61,
        _SC_2_PBS_LOCATE                 =  62,
        _SC_2_PBS_MESSAGE                =  63,
        _SC_2_PBS_TRACK                  =  64,
        _SC_ADVISORY_INFO                =  65,
        _SC_BARRIERS                     =  66,
        _SC_CLOCK_SELECTION              =  67,
        _SC_CPUTIME                      =  68,
        _SC_FILE_LOCKING                 =  69,
        _SC_GETGR_R_SIZE_MAX             =  70,
        _SC_GETPW_R_SIZE_MAX             =  71,
        _SC_HOST_NAME_MAX                =  72,
        _SC_LOGIN_NAME_MAX               =  73,
        _SC_MONOTONIC_CLOCK              =  74,
        _SC_MQ_PRIO_MAX                  =  75,
        _SC_READER_WRITER_LOCKS          =  76,
        _SC_REGEXP                       =  77,
        _SC_SHELL                        =  78,
        _SC_SPAWN                        =  79,
        _SC_SPIN_LOCKS                   =  80,
        _SC_SPORADIC_SERVER              =  81,
        _SC_THREAD_ATTR_STACKADDR        =  82,
        _SC_THREAD_ATTR_STACKSIZE        =  83,
        _SC_THREAD_CPUTIME               =  84,
        _SC_THREAD_DESTRUCTOR_ITERATIONS =  85,
        _SC_THREAD_KEYS_MAX              =  86,
        _SC_THREAD_PRIO_INHERIT          =  87,
        _SC_THREAD_PRIO_PROTECT          =  88,
        _SC_THREAD_PRIORITY_SCHEDULING   =  89,
        _SC_THREAD_PROCESS_SHARED        =  90,
        _SC_THREAD_SAFE_FUNCTIONS        =  91,
        _SC_THREAD_SPORADIC_SERVER       =  92,
        _SC_THREAD_STACK_MIN             =  93,
        _SC_THREAD_THREADS_MAX           =  94,
        _SC_TIMEOUTS                     =  95,
        _SC_THREADS                      =  96,
        _SC_TRACE                        =  97,
        _SC_TRACE_EVENT_FILTER           =  98,
        _SC_TRACE_INHERIT                =  99,
        _SC_TRACE_LOG                    = 100,
        _SC_TTY_NAME_MAX                 = 101,
        _SC_TYPED_MEMORY_OBJECTS         = 102,
        _SC_V6_ILP32_OFF32               = 103,
        _SC_V6_ILP32_OFFBIG              = 104,
        _SC_V6_LP64_OFF64                = 105,
        _SC_V6_LPBIG_OFFBIG              = 106,
        _SC_ATEXIT_MAX                   = 107,
        _SC_XOPEN_CRYPT                  = 108,
        _SC_XOPEN_ENH_I18N               = 109,
        _SC_XOPEN_LEGACY                 = 110,
        _SC_XOPEN_REALTIME               = 111,
        _SC_XOPEN_REALTIME_THREADS       = 112,
        _SC_XOPEN_SHM                    = 113,
        _SC_XOPEN_STREAMS                = 114,
        _SC_XOPEN_UNIX                   = 115,
        _SC_XOPEN_VERSION                = 116,
        _SC_IPV6                         = 118,
        _SC_RAW_SOCKETS                  = 119,
        _SC_SYMLOOP_MAX                  = 120,
        _SC_XOPEN_XCU_VERSION            = 121,
        _SC_XBS5_ILP32_OFF32             = 122,
        _SC_XBS5_ILP32_OFFBIG            = 123,
        _SC_XBS5_LP64_OFF64              = 124,
        _SC_XBS5_LPBIG_OFFBIG            = 125,
        _SC_SS_REPL_MAX                  = 126,
        _SC_TRACE_EVENT_NAME_MAX         = 127,
        _SC_TRACE_NAME_MAX               = 128,
        _SC_TRACE_SYS_MAX                = 129,
        _SC_TRACE_USER_EVENT_MAX         = 130,
        _SC_PASS_MAX                     = 131,
    }

    enum _SC_PAGE_SIZE = _SC_PAGESIZE;

    enum
    {
        _CS_PATH                                =     1,
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS         =     2,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS        =     3,
        _CS_POSIX_V6_ILP32_OFF32_LIBS           =     4,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS        =     5,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS       =     6,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS          =     7,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS          =     8,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS         =     9,
        _CS_POSIX_V6_LP64_OFF64_LIBS            =    10,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS        =    11,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS       =    12,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS          =    13,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS      =    14,

        _CS_XBS5_ILP32_OFF32_CFLAGS             =    20,
        _CS_XBS5_ILP32_OFF32_LDFLAGS            =    21,
        _CS_XBS5_ILP32_OFF32_LIBS               =    22,
        _CS_XBS5_ILP32_OFF32_LINTFLAGS          =    23,
        _CS_XBS5_ILP32_OFFBIG_CFLAGS            =    24,
        _CS_XBS5_ILP32_OFFBIG_LDFLAGS           =    25,
        _CS_XBS5_ILP32_OFFBIG_LIBS              =    26,
        _CS_XBS5_ILP32_OFFBIG_LINTFLAGS         =    27,
        _CS_XBS5_LP64_OFF64_CFLAGS              =    28,
        _CS_XBS5_LP64_OFF64_LDFLAGS             =    29,
        _CS_XBS5_LP64_OFF64_LIBS                =    30,
        _CS_XBS5_LP64_OFF64_LINTFLAGS           =    31,
        _CS_XBS5_LPBIG_OFFBIG_CFLAGS            =    32,
        _CS_XBS5_LPBIG_OFFBIG_LDFLAGS           =    33,
        _CS_XBS5_LPBIG_OFFBIG_LIBS              =    34,
        _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS         =    35,

        _CS_DARWIN_USER_DIR                     = 65536,
        _CS_DARWIN_USER_TEMP_DIR                = 65537,
        _CS_DARWIN_USER_CACHE_DIR               = 65538,
    }
}
else version (FreeBSD)
{
    enum F_OK       = 0;
    enum R_OK       = 0x04;
    enum W_OK       = 0x02;
    enum X_OK       = 0x01;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _SC_ARG_MAX                        =   1,
        _SC_CHILD_MAX                      =   2,
        _SC_CLK_TCK                        =   3,
        _SC_NGROUPS_MAX                    =   4,
        _SC_OPEN_MAX                       =   5,
        _SC_JOB_CONTROL                    =   6,
        _SC_SAVED_IDS                      =   7,
        _SC_VERSION                        =   8,
        _SC_BC_BASE_MAX                    =   9,
        _SC_BC_DIM_MAX                     =  10,
        _SC_BC_SCALE_MAX                   =  11,
        _SC_BC_STRING_MAX                  =  12,
        _SC_COLL_WEIGHTS_MAX               =  13,
        _SC_EXPR_NEST_MAX                  =  14,
        _SC_LINE_MAX                       =  15,
        _SC_RE_DUP_MAX                     =  16,
        _SC_2_VERSION                      =  17,
        _SC_2_C_BIND                       =  18,
        _SC_2_C_DEV                        =  19,
        _SC_2_CHAR_TERM                    =  20,
        _SC_2_FORT_DEV                     =  21,
        _SC_2_FORT_RUN                     =  22,
        _SC_2_LOCALEDEF                    =  23,
        _SC_2_SW_DEV                       =  24,
        _SC_2_UPE                          =  25,
        _SC_STREAM_MAX                     =  26,
        _SC_TZNAME_MAX                     =  27,
        _SC_ASYNCHRONOUS_IO                =  28,
        _SC_MAPPED_FILES                   =  29,
        _SC_MEMLOCK                        =  30,
        _SC_MEMLOCK_RANGE                  =  31,
        _SC_MEMORY_PROTECTION              =  32,
        _SC_MESSAGE_PASSING                =  33,
        _SC_PRIORITIZED_IO                 =  34,
        _SC_PRIORITY_SCHEDULING            =  35,
        _SC_REALTIME_SIGNALS               =  36,
        _SC_SEMAPHORES                     =  37,
        _SC_FSYNC                          =  38,
        _SC_SHARED_MEMORY_OBJECTS          =  39,
        _SC_SYNCHRONIZED_IO                =  40,
        _SC_TIMERS                         =  41,
        _SC_AIO_LISTIO_MAX                 =  42,
        _SC_AIO_MAX                        =  43,
        _SC_AIO_PRIO_DELTA_MAX             =  44,
        _SC_DELAYTIMER_MAX                 =  45,
        _SC_MQ_OPEN_MAX                    =  46,
        _SC_PAGESIZE                       =  47,
        _SC_RTSIG_MAX                      =  48,
        _SC_SEM_NSEMS_MAX                  =  49,
        _SC_SEM_VALUE_MAX                  =  50,
        _SC_SIGQUEUE_MAX                   =  51,
        _SC_TIMER_MAX                      =  52,
        _SC_IOV_MAX                        =  56,
        _SC_NPROCESSORS_CONF               =  57,
        _SC_NPROCESSORS_ONLN               =  58,
        _SC_2_PBS                          =  59,
        _SC_2_PBS_ACCOUNTING               =  60,
        _SC_2_PBS_CHECKPOINT               =  61,
        _SC_2_PBS_LOCATE                   =  62,
        _SC_2_PBS_MESSAGE                  =  63,
        _SC_2_PBS_TRACK                    =  64,
        _SC_ADVISORY_INFO                  =  65,
        _SC_BARRIERS                       =  66,
        _SC_CLOCK_SELECTION                =  67,
        _SC_CPUTIME                        =  68,
        _SC_FILE_LOCKING                   =  69,
        _SC_GETGR_R_SIZE_MAX               =  70,
        _SC_GETPW_R_SIZE_MAX               =  71,
        _SC_HOST_NAME_MAX                  =  72,
        _SC_LOGIN_NAME_MAX                 =  73,
        _SC_MONOTONIC_CLOCK                =  74,
        _SC_MQ_PRIO_MAX                    =  75,
        _SC_READER_WRITER_LOCKS            =  76,
        _SC_REGEXP                         =  77,
        _SC_SHELL                          =  78,
        _SC_SPAWN                          =  79,
        _SC_SPIN_LOCKS                     =  80,
        _SC_SPORADIC_SERVER                =  81,
        _SC_THREAD_ATTR_STACKADDR          =  82,
        _SC_THREAD_ATTR_STACKSIZE          =  83,
        _SC_THREAD_CPUTIME                 =  84,
        _SC_THREAD_DESTRUCTOR_ITERATIONS   =  85,
        _SC_THREAD_KEYS_MAX                =  86,
        _SC_THREAD_PRIO_INHERIT            =  87,
        _SC_THREAD_PRIO_PROTECT            =  88,
        _SC_THREAD_PRIORITY_SCHEDULING     =  89,
        _SC_THREAD_PROCESS_SHARED          =  90,
        _SC_THREAD_SAFE_FUNCTIONS          =  91,
        _SC_THREAD_SPORADIC_SERVER         =  92,
        _SC_THREAD_STACK_MIN               =  93,
        _SC_THREAD_THREADS_MAX             =  94,
        _SC_TIMEOUTS                       =  95,
        _SC_THREADS                        =  96,
        _SC_TRACE                          =  97,
        _SC_TRACE_EVENT_FILTER             =  98,
        _SC_TRACE_INHERIT                  =  99,
        _SC_TRACE_LOG                      = 100,
        _SC_TTY_NAME_MAX                   = 101,
        _SC_TYPED_MEMORY_OBJECTS           = 102,
        _SC_V6_ILP32_OFF32                 = 103,
        _SC_V6_ILP32_OFFBIG                = 104,
        _SC_V6_LP64_OFF64                  = 105,
        _SC_V6_LPBIG_OFFBIG                = 106,
        _SC_IPV6                           = 118,
        _SC_RAW_SOCKETS                    = 119,
        _SC_SYMLOOP_MAX                    = 120,
        _SC_ATEXIT_MAX                     = 107,
        _SC_XOPEN_CRYPT                    = 108,
        _SC_XOPEN_ENH_I18N                 = 109,
        _SC_XOPEN_LEGACY                   = 110,
        _SC_XOPEN_REALTIME                 = 111,
        _SC_XOPEN_REALTIME_THREADS         = 112,
        _SC_XOPEN_SHM                      = 113,
        _SC_XOPEN_STREAMS                  = 114,
        _SC_XOPEN_UNIX                     = 115,
        _SC_XOPEN_VERSION                  = 116,
        _SC_XOPEN_XCU_VERSION              = 117,
        _SC_CPUSET_SIZE                    = 122,
        _SC_PHYS_PAGES                     = 121,
    }

    enum _SC_PAGE_SIZE = _SC_PAGESIZE;

    enum
    {
        _CS_PATH                           =   1,
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS    =   2,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS   =   3,
        _CS_POSIX_V6_ILP32_OFF32_LIBS      =   4,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS   =   5,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS  =   6,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS     =   7,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS     =   8,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS    =   9,
        _CS_POSIX_V6_LP64_OFF64_LIBS       =  10,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS   =  11,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS  =  12,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS     =  13,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS =  14,
    }
}
else version (NetBSD)
{
    enum F_OK       = 0;
    enum R_OK       = 0x04;
    enum W_OK       = 0x02;
    enum X_OK       = 0x01;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _SC_ARG_MAX                        =   1,
        _SC_CHILD_MAX                      =   2,
        _O_SC_CLK_TCK                      =   3,
        _SC_NGROUPS_MAX                    =   4,
        _SC_OPEN_MAX                       =   5,
        _SC_JOB_CONTROL                    =   6,
        _SC_SAVED_IDS                      =   7,
        _SC_VERSION                        =   8,
        _SC_BC_BASE_MAX                    =   9,
        _SC_BC_DIM_MAX                     =  10,
        _SC_BC_SCALE_MAX                   =  11,
        _SC_BC_STRING_MAX                  =  12,
        _SC_COLL_WEIGHTS_MAX               =  13,
        _SC_EXPR_NEST_MAX                  =  14,
        _SC_LINE_MAX                       =  15,
        _SC_RE_DUP_MAX                     =  16,
        _SC_2_VERSION                      =  17,
        _SC_2_C_BIND                       =  18,
        _SC_2_C_DEV                        =  19,
        _SC_2_CHAR_TERM                    =  20,
        _SC_2_FORT_DEV                     =  21,
        _SC_2_FORT_RUN                     =  22,
        _SC_2_LOCALEDEF                    =  23,
        _SC_2_SW_DEV                       =  24,
        _SC_2_UPE                          =  25,
        _SC_STREAM_MAX                     =  26,
        _SC_TZNAME_MAX                     =  27,
        _SC_PAGESIZE                       =  28,
        _SC_FSYNC                          =  29,
        _SC_XOPEN_SHM                      =  30,
        _SC_SYNCHRONIZED_IO                =  31,
        _SC_IOV_MAX                        =  32,
        _SC_MAPPED_FILES                   =  33,
        _SC_MEMLOCK                        =  34,
        _SC_MEMLOCK_RANGE                  =  35,
        _SC_MEMORY_PROTECTION              =  36,
        _SC_LOGIN_NAME_MAX                 =  37,
        _SC_MONOTONIC_CLOCK                =  38,
        _SC_CLK_TCK                        =  39,
        _SC_ATEXIT_MAX                     =  40,
        _SC_THREADS                        =  41,
        _SC_SEMAPHORES                     =  42,
        _SC_BARRIERS                       =  43,
        _SC_TIMERS                         =  44,
        _SC_SPIN_LOCKS                     =  45,
        _SC_READER_WRITER_LOCKS            =  46,
        _SC_GETGR_R_SIZE_MAX               =  47,
        _SC_GETPW_R_SIZE_MAX               =  48,
        _SC_CLOCK_SELECTION                =  49,
        _SC_ASYNCHRONOUS_IO                =  50,
        _SC_AIO_LISTIO_MAX                 =  51,
        _SC_AIO_MAX                        =  52,
        _SC_MESSAGE_PASSING     = 53,
        _SC_MQ_OPEN_MAX         = 54,
        _SC_MQ_PRIO_MAX         = 55,
        _SC_PRIORITY_SCHEDULING = 56,
        _SC_THREAD_DESTRUCTOR_ITERATIONS = 57,
        _SC_THREAD_KEYS_MAX             = 58,
        _SC_THREAD_STACK_MIN            = 59,
        _SC_THREAD_THREADS_MAX          = 60,
        _SC_THREAD_ATTR_STACKADDR       = 61,
        _SC_THREAD_ATTR_STACKSIZE       = 62,
        _SC_THREAD_PRIORITY_SCHEDULING  = 63,
        _SC_THREAD_PRIO_INHERIT         = 64,
        _SC_THREAD_PRIO_PROTECT         = 65,
        _SC_THREAD_PROCESS_SHARED       = 66,
        _SC_THREAD_SAFE_FUNCTIONS       = 67,
        _SC_TTY_NAME_MAX                = 68,
        _SC_HOST_NAME_MAX               = 69,
        _SC_PASS_MAX                    = 70,
        _SC_REGEXP                      = 71,
        _SC_SHELL                       = 72,
        _SC_SYMLOOP_MAX                 = 73,

        /* Actually, they are not supported or implemented yet */
        _SC_V6_ILP32_OFF32              = 74,
        _SC_V6_ILP32_OFFBIG             = 75,
        _SC_V6_LP64_OFF64               = 76,
        _SC_V6_LPBIG_OFFBIG             = 77,
        _SC_2_PBS                       = 80,
        _SC_2_PBS_ACCOUNTING            = 81,
        _SC_2_PBS_CHECKPOINT            = 82,
        _SC_2_PBS_LOCATE                = 83,
        _SC_2_PBS_MESSAGE               = 84,
        _SC_2_PBS_TRACK                 = 85,

        /* These are implemented */
        _SC_SPAWN                       = 86,
        _SC_SHARED_MEMORY_OBJECTS       = 87,

        /* Extensions found in Solaris and Linux. */
        _SC_PHYS_PAGES          = 121,

        /* Commonly provided sysconf() extensions */
        _SC_NPROCESSORS_CONF    = 1001,
        _SC_NPROCESSORS_ONLN    = 1002,
        /* Native variables */
        _SC_SCHED_RT_TS         = 2001,
        _SC_SCHED_PRI_MIN       = 2002,
        _SC_SCHED_PRI_MAX       = 2003

    }

    enum _SC_PAGE_SIZE = _SC_PAGESIZE;

    enum
    {
        _CS_PATH                           =   1,
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS    =   2,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS   =   3,
        _CS_POSIX_V6_ILP32_OFF32_LIBS      =   4,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS   =   5,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS  =   6,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS     =   7,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS     =   8,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS    =   9,
        _CS_POSIX_V6_LP64_OFF64_LIBS       =  10,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS   =  11,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS  =  12,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS     =  13,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS =  14,
    }
}
else version (DragonFlyBSD)
{
    enum F_OK       = 0;
    enum R_OK       = 0x04;
    enum W_OK       = 0x02;
    enum X_OK       = 0x01;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _SC_ARG_MAX                        =   1,
        _SC_CHILD_MAX                      =   2,
        _SC_CLK_TCK                        =   3,
        _SC_NGROUPS_MAX                    =   4,
        _SC_OPEN_MAX                       =   5,
        _SC_JOB_CONTROL                    =   6,
        _SC_SAVED_IDS                      =   7,
        _SC_VERSION                        =   8,
        _SC_BC_BASE_MAX                    =   9,
        _SC_BC_DIM_MAX                     =  10,
        _SC_BC_SCALE_MAX                   =  11,
        _SC_BC_STRING_MAX                  =  12,
        _SC_COLL_WEIGHTS_MAX               =  13,
        _SC_EXPR_NEST_MAX                  =  14,
        _SC_LINE_MAX                       =  15,
        _SC_RE_DUP_MAX                     =  16,
        _SC_2_VERSION                      =  17,
        _SC_2_C_BIND                       =  18,
        _SC_2_C_DEV                        =  19,
        _SC_2_CHAR_TERM                    =  20,
        _SC_2_FORT_DEV                     =  21,
        _SC_2_FORT_RUN                     =  22,
        _SC_2_LOCALEDEF                    =  23,
        _SC_2_SW_DEV                       =  24,
        _SC_2_UPE                          =  25,
        _SC_STREAM_MAX                     =  26,
        _SC_TZNAME_MAX                     =  27,
        _SC_ASYNCHRONOUS_IO                =  28,
        _SC_MAPPED_FILES                   =  29,
        _SC_MEMLOCK                        =  30,
        _SC_MEMLOCK_RANGE                  =  31,
        _SC_MEMORY_PROTECTION              =  32,
        _SC_MESSAGE_PASSING                =  33,
        _SC_PRIORITIZED_IO                 =  34,
        _SC_PRIORITY_SCHEDULING            =  35,
        _SC_REALTIME_SIGNALS               =  36,
        _SC_SEMAPHORES                     =  37,
        _SC_FSYNC                          =  38,
        _SC_SHARED_MEMORY_OBJECTS          =  39,
        _SC_SYNCHRONIZED_IO                =  40,
        _SC_TIMERS                         =  41,
        _SC_AIO_LISTIO_MAX                 =  42,
        _SC_AIO_MAX                        =  43,
        _SC_AIO_PRIO_DELTA_MAX             =  44,
        _SC_DELAYTIMER_MAX                 =  45,
        _SC_MQ_OPEN_MAX                    =  46,
        _SC_PAGESIZE                       =  47,
        _SC_RTSIG_MAX                      =  48,
        _SC_SEM_NSEMS_MAX                  =  49,
        _SC_SEM_VALUE_MAX                  =  50,
        _SC_SIGQUEUE_MAX                   =  51,
        _SC_TIMER_MAX                      =  52,
        _SC_IOV_MAX                        =  56,
        _SC_NPROCESSORS_CONF               =  57,
        _SC_NPROCESSORS_ONLN               =  58,
        _SC_2_PBS                          =  59,
        _SC_2_PBS_ACCOUNTING               =  60,
        _SC_2_PBS_CHECKPOINT               =  61,
        _SC_2_PBS_LOCATE                   =  62,
        _SC_2_PBS_MESSAGE                  =  63,
        _SC_2_PBS_TRACK                    =  64,
        _SC_ADVISORY_INFO                  =  65,
        _SC_BARRIERS                       =  66,
        _SC_CLOCK_SELECTION                =  67,
        _SC_CPUTIME                        =  68,
        _SC_FILE_LOCKING                   =  69,
        _SC_GETGR_R_SIZE_MAX               =  70,
        _SC_GETPW_R_SIZE_MAX               =  71,
        _SC_HOST_NAME_MAX                  =  72,
        _SC_LOGIN_NAME_MAX                 =  73,
        _SC_MONOTONIC_CLOCK                =  74,
        _SC_MQ_PRIO_MAX                    =  75,
        _SC_READER_WRITER_LOCKS            =  76,
        _SC_REGEXP                         =  77,
        _SC_SHELL                          =  78,
        _SC_SPAWN                          =  79,
        _SC_SPIN_LOCKS                     =  80,
        _SC_SPORADIC_SERVER                =  81,
        _SC_THREAD_ATTR_STACKADDR          =  82,
        _SC_THREAD_ATTR_STACKSIZE          =  83,
        _SC_THREAD_CPUTIME                 =  84,
        _SC_THREAD_DESTRUCTOR_ITERATIONS   =  85,
        _SC_THREAD_KEYS_MAX                =  86,
        _SC_THREAD_PRIO_INHERIT            =  87,
        _SC_THREAD_PRIO_PROTECT            =  88,
        _SC_THREAD_PRIORITY_SCHEDULING     =  89,
        _SC_THREAD_PROCESS_SHARED          =  90,
        _SC_THREAD_SAFE_FUNCTIONS          =  91,
        _SC_THREAD_SPORADIC_SERVER         =  92,
        _SC_THREAD_STACK_MIN               =  93,
        _SC_THREAD_THREADS_MAX             =  94,
        _SC_TIMEOUTS                       =  95,
        _SC_THREADS                        =  96,
        _SC_TRACE                          =  97,
        _SC_TRACE_EVENT_FILTER             =  98,
        _SC_TRACE_INHERIT                  =  99,
        _SC_TRACE_LOG                      = 100,
        _SC_TTY_NAME_MAX                   = 101,
        _SC_TYPED_MEMORY_OBJECTS           = 102,
        _SC_V6_ILP32_OFF32                 = 103,
        _SC_V6_ILP32_OFFBIG                = 104,
        _SC_V6_LP64_OFF64                  = 105,
        _SC_V6_LPBIG_OFFBIG                = 106,
        _SC_IPV6                           = 118,
        _SC_RAW_SOCKETS                    = 119,
        _SC_SYMLOOP_MAX                    = 120,
        _SC_ATEXIT_MAX                     = 107,
        _SC_XOPEN_CRYPT                    = 108,
        _SC_XOPEN_ENH_I18N                 = 109,
        _SC_XOPEN_LEGACY                   = 110,
        _SC_XOPEN_REALTIME                 = 111,
        _SC_XOPEN_REALTIME_THREADS         = 112,
        _SC_XOPEN_SHM                      = 113,
        _SC_XOPEN_STREAMS                  = 114,
        _SC_XOPEN_UNIX                     = 115,
        _SC_XOPEN_VERSION                  = 116,
        _SC_XOPEN_XCU_VERSION              = 117,
        _SC_CPUSET_SIZE                    = 122,
        _SC_PHYS_PAGES                     = 121,
    }

    enum _SC_PAGE_SIZE = _SC_PAGESIZE;

    enum
    {
        _CS_PATH                           =   1,
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS    =   2,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS   =   3,
        _CS_POSIX_V6_ILP32_OFF32_LIBS      =   4,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS   =   5,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS  =   6,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS     =   7,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS     =   8,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS    =   9,
        _CS_POSIX_V6_LP64_OFF64_LIBS       =  10,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS   =  11,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS  =  12,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS     =  13,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS =  14,
    }
}
else version (CRuntime_Bionic)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum _SC_PAGESIZE         = 0x0027;
    enum _SC_NPROCESSORS_ONLN = 0x0061;
    enum _SC_THREAD_STACK_MIN = 0x004c;
}
else version (Solaris)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        // large file compilation environment configuration
        _CS_LFS_CFLAGS                  = 68,
        _CS_LFS_LDFLAGS                 = 69,
        _CS_LFS_LIBS                    = 70,
        _CS_LFS_LINTFLAGS               = 71,
        // transitional large file interface configuration
        _CS_LFS64_CFLAGS                = 72,
        _CS_LFS64_LDFLAGS               = 73,
        _CS_LFS64_LIBS                  = 74,
        _CS_LFS64_LINTFLAGS             = 75,

        // UNIX 98
        _CS_XBS5_ILP32_OFF32_CFLAGS     = 700,
        _CS_XBS5_ILP32_OFF32_LDFLAGS    = 701,
        _CS_XBS5_ILP32_OFF32_LIBS       = 702,
        _CS_XBS5_ILP32_OFF32_LINTFLAGS  = 703,
        _CS_XBS5_ILP32_OFFBIG_CFLAGS    = 705,
        _CS_XBS5_ILP32_OFFBIG_LDFLAGS   = 706,
        _CS_XBS5_ILP32_OFFBIG_LIBS      = 707,
        _CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 708,
        _CS_XBS5_LP64_OFF64_CFLAGS      = 709,
        _CS_XBS5_LP64_OFF64_LDFLAGS     = 710,
        _CS_XBS5_LP64_OFF64_LIBS        = 711,
        _CS_XBS5_LP64_OFF64_LINTFLAGS   = 712,
        _CS_XBS5_LPBIG_OFFBIG_CFLAGS    = 713,
        _CS_XBS5_LPBIG_OFFBIG_LDFLAGS   = 714,
        _CS_XBS5_LPBIG_OFFBIG_LIBS      = 715,
        _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 716,

        // UNIX 03
        _CS_POSIX_V6_ILP32_OFF32_CFLAGS         = 800,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS        = 801,
        _CS_POSIX_V6_ILP32_OFF32_LIBS           = 802,
        _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS      = 803,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS        = 804,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS       = 805,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS          = 806,
        _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS     = 807,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS          = 808,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS         = 809,
        _CS_POSIX_V6_LP64_OFF64_LIBS            = 810,
        _CS_POSIX_V6_LP64_OFF64_LINTFLAGS       = 811,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS        = 812,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS       = 813,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS          = 814,
        _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS     = 815,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS      = 816
    }

    enum {
        _SC_ARG_MAX                     = 1,
        _SC_CHILD_MAX                   = 2,
        _SC_CLK_TCK                     = 3,
        _SC_NGROUPS_MAX                 = 4,
        _SC_OPEN_MAX                    = 5,
        _SC_JOB_CONTROL                 = 6,
        _SC_SAVED_IDS                   = 7,
        _SC_VERSION                     = 8,

        _SC_PASS_MAX                    = 9,
        _SC_LOGNAME_MAX                 = 10,
        _SC_PAGESIZE                    = 11,
        _SC_XOPEN_VERSION               = 12,
        // 13 reserved for SVr4-ES/MP _SC_NACLS_MAX
        _SC_NPROCESSORS_CONF            = 14,
        _SC_NPROCESSORS_ONLN            = 15,
        _SC_STREAM_MAX                  = 16,
        _SC_TZNAME_MAX                  = 17,

        _SC_AIO_LISTIO_MAX              = 18,
        _SC_AIO_MAX                     = 19,
        _SC_AIO_PRIO_DELTA_MAX          = 20,
        _SC_ASYNCHRONOUS_IO             = 21,
        _SC_DELAYTIMER_MAX              = 22,
        _SC_FSYNC                       = 23,
        _SC_MAPPED_FILES                = 24,
        _SC_MEMLOCK                     = 25,
        _SC_MEMLOCK_RANGE               = 26,
        _SC_MEMORY_PROTECTION           = 27,
        _SC_MESSAGE_PASSING             = 28,
        _SC_MQ_OPEN_MAX                 = 29,
        _SC_MQ_PRIO_MAX                 = 30,
        _SC_PRIORITIZED_IO              = 31,
        _SC_PRIORITY_SCHEDULING         = 32,
        _SC_REALTIME_SIGNALS            = 33,
        _SC_RTSIG_MAX                   = 34,
        _SC_SEMAPHORES                  = 35,
        _SC_SEM_NSEMS_MAX               = 36,
        _SC_SEM_VALUE_MAX               = 37,
        _SC_SHARED_MEMORY_OBJECTS       = 38,
        _SC_SIGQUEUE_MAX                = 39,
        _SC_SIGRT_MIN                   = 40,
        _SC_SIGRT_MAX                   = 41,
        _SC_SYNCHRONIZED_IO             = 42,
        _SC_TIMERS                      = 43,
        _SC_TIMER_MAX                   = 44,

        _SC_2_C_BIND                    = 45,
        _SC_2_C_DEV                     = 46,
        _SC_2_C_VERSION                 = 47,
        _SC_2_FORT_DEV                  = 48,
        _SC_2_FORT_RUN                  = 49,
        _SC_2_LOCALEDEF                 = 50,
        _SC_2_SW_DEV                    = 51,
        _SC_2_UPE                       = 52,
        _SC_2_VERSION                   = 53,
        _SC_BC_BASE_MAX                 = 54,
        _SC_BC_DIM_MAX                  = 55,
        _SC_BC_SCALE_MAX                = 56,
        _SC_BC_STRING_MAX               = 57,
        _SC_COLL_WEIGHTS_MAX            = 58,
        _SC_EXPR_NEST_MAX               = 59,
        _SC_LINE_MAX                    = 60,
        _SC_RE_DUP_MAX                  = 61,
        _SC_XOPEN_CRYPT                 = 62,
        _SC_XOPEN_ENH_I18N              = 63,
        _SC_XOPEN_SHM                   = 64,
        _SC_2_CHAR_TERM                 = 66,
        _SC_XOPEN_XCU_VERSION           = 67,

        _SC_ATEXIT_MAX                  = 76,
        _SC_IOV_MAX                     = 77,
        _SC_XOPEN_UNIX                  = 78,

        _SC_T_IOV_MAX                   = 79,

        _SC_PHYS_PAGES                  = 500,
        _SC_AVPHYS_PAGES                = 501,

        _SC_COHER_BLKSZ         = 503,
        _SC_SPLIT_CACHE         = 504,
        _SC_ICACHE_SZ           = 505,
        _SC_DCACHE_SZ           = 506,
        _SC_ICACHE_LINESZ       = 507,
        _SC_DCACHE_LINESZ       = 508,
        _SC_ICACHE_BLKSZ        = 509,
        _SC_DCACHE_BLKSZ        = 510,
        _SC_DCACHE_TBLKSZ       = 511,
        _SC_ICACHE_ASSOC        = 512,
        _SC_DCACHE_ASSOC        = 513,

        _SC_MAXPID              = 514,
        _SC_STACK_PROT          = 515,
        _SC_NPROCESSORS_MAX     = 516,
        _SC_CPUID_MAX           = 517,
        _SC_EPHID_MAX           = 518,

        _SC_THREAD_DESTRUCTOR_ITERATIONS = 568,
        _SC_GETGR_R_SIZE_MAX            = 569,
        _SC_GETPW_R_SIZE_MAX            = 570,
        _SC_LOGIN_NAME_MAX              = 571,
        _SC_THREAD_KEYS_MAX             = 572,
        _SC_THREAD_STACK_MIN            = 573,
        _SC_THREAD_THREADS_MAX          = 574,
        _SC_TTY_NAME_MAX                = 575,
        _SC_THREADS                     = 576,
        _SC_THREAD_ATTR_STACKADDR       = 577,
        _SC_THREAD_ATTR_STACKSIZE       = 578,
        _SC_THREAD_PRIORITY_SCHEDULING  = 579,
        _SC_THREAD_PRIO_INHERIT         = 580,
        _SC_THREAD_PRIO_PROTECT         = 581,
        _SC_THREAD_PROCESS_SHARED       = 582,
        _SC_THREAD_SAFE_FUNCTIONS       = 583,

        _SC_XOPEN_LEGACY                = 717,
        _SC_XOPEN_REALTIME              = 718,
        _SC_XOPEN_REALTIME_THREADS      = 719,
        _SC_XBS5_ILP32_OFF32            = 720,
        _SC_XBS5_ILP32_OFFBIG           = 721,
        _SC_XBS5_LP64_OFF64             = 722,
        _SC_XBS5_LPBIG_OFFBIG           = 723,

        _SC_2_PBS                       = 724,
        _SC_2_PBS_ACCOUNTING            = 725,
        _SC_2_PBS_CHECKPOINT            = 726,
        _SC_2_PBS_LOCATE                = 728,
        _SC_2_PBS_MESSAGE               = 729,
        _SC_2_PBS_TRACK                 = 730,
        _SC_ADVISORY_INFO               = 731,
        _SC_BARRIERS                    = 732,
        _SC_CLOCK_SELECTION             = 733,
        _SC_CPUTIME                     = 734,
        _SC_HOST_NAME_MAX         -  -  -  -  -  -  -                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            = 735,
        _SC_MONOTONIC_CLOCK             = 736,
        _SC_READER_WRITER_LOCKS         = 737,
        _SC_REGEXP                      = 738,
        _SC_SHELL                       = 739,
        _SC_SPAWN                       = 740,
        _SC_SPIN_LOCKS                  = 741,
        _SC_SPORADIC_SERVER             = 742,
        _SC_SS_REPL_MAX                 = 743,
        _SC_SYMLOOP_MAX                 = 744,
        _SC_THREAD_CPUTIME              = 745,
        _SC_THREAD_SPORADIC_SERVER      = 746,
        _SC_TIMEOUTS                    = 747,
        _SC_TRACE                       = 748,
        _SC_TRACE_EVENT_FILTER          = 749,
        _SC_TRACE_EVENT_NAME_MAX        = 750,
        _SC_TRACE_INHERIT               = 751,
        _SC_TRACE_LOG                   = 752,
        _SC_TRACE_NAME_MAX              = 753,
        _SC_TRACE_SYS_MAX               = 754,
        _SC_TRACE_USER_EVENT_MAX        = 755,
        _SC_TYPED_MEMORY_OBJECTS        = 756,
        _SC_V6_ILP32_OFF32              = 757,
        _SC_V6_ILP32_OFFBIG             = 758,
        _SC_V6_LP64_OFF64               = 759,
        _SC_V6_LPBIG_OFFBIG             = 760,
        _SC_XOPEN_STREAMS               = 761,
        _SC_IPV6                        = 762,
        _SC_RAW_SOCKETS                 = 763,
    }
    enum _SC_PAGE_SIZE = _SC_PAGESIZE;

    enum {
        _PC_LINK_MAX            = 1,
        _PC_MAX_CANON           = 2,
        _PC_MAX_INPUT           = 3,
        _PC_NAME_MAX            = 4,
        _PC_PATH_MAX            = 5,
        _PC_PIPE_BUF            = 6,
        _PC_NO_TRUNC            = 7,
        _PC_VDISABLE            = 8,
        _PC_CHOWN_RESTRICTED    = 9,

        _PC_ASYNC_IO            = 10,
        _PC_PRIO_IO             = 11,
        _PC_SYNC_IO             = 12,

        _PC_ALLOC_SIZE_MIN      = 13,
        _PC_REC_INCR_XFER_SIZE  = 14,
        _PC_REC_MAX_XFER_SIZE   = 15,
        _PC_REC_MIN_XFER_SIZE   = 16,
        _PC_REC_XFER_ALIGN      = 17,
        _PC_SYMLINK_MAX         = 18,
        _PC_2_SYMLINKS          = 19,
        _PC_ACL_ENABLED         = 20,
        _PC_MIN_HOLE_SIZE       = 21,
        _PC_CASE_BEHAVIOR       = 22,
        _PC_SATTR_ENABLED       = 23,
        _PC_SATTR_EXISTS        = 24,
        _PC_ACCESS_FILTERING    = 25,

        _PC_TIMESTAMP_RESOLUTION = 26,

        _PC_FILESIZEBITS        = 67,

        _PC_XATTR_ENABLED       = 100,
        _PC_XATTR_EXISTS        = 101
    }

    enum _PC_LAST = 101;
}
else version (CRuntime_Musl)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _CS_PATH,
        _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS,
        _CS_GNU_LIBC_VERSION,
        _CS_GNU_LIBPTHREAD_VERSION,
        _CS_POSIX_V5_WIDTH_RESTRICTED_ENVS,
        _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS,

        _CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFF32_LIBS,
        _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
        _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LIBS,
        _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,
        _CS_POSIX_V7_ILP32_OFF32_CFLAGS,
        _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,
        _CS_POSIX_V7_ILP32_OFF32_LIBS,
        _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,
        _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,
        _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,
        _CS_POSIX_V7_ILP32_OFFBIG_LIBS,
        _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,
        _CS_POSIX_V7_LP64_OFF64_CFLAGS,
        _CS_POSIX_V7_LP64_OFF64_LDFLAGS,
        _CS_POSIX_V7_LP64_OFF64_LIBS,
        _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,
        _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,
        _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,
        _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,
        _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,
        _CS_V6_ENV,
        _CS_V7_ENV
    }

    enum
    {
        _PC_LINK_MAX,
        _PC_MAX_CANON,
        _PC_MAX_INPUT,
        _PC_NAME_MAX,
        _PC_PATH_MAX,
        _PC_PIPE_BUF,
        _PC_CHOWN_RESTRICTED,
        _PC_NO_TRUNC,
        _PC_VDISABLE,
        _PC_SYNC_IO,
        _PC_ASYNC_IO,
        _PC_PRIO_IO,
        _PC_SOCK_MAXBUF,
        _PC_FILESIZEBITS,
        _PC_REC_INCR_XFER_SIZE,
        _PC_REC_MAX_XFER_SIZE,
        _PC_REC_MIN_XFER_SIZE,
        _PC_REC_XFER_ALIGN,
        _PC_ALLOC_SIZE_MIN,
        _PC_SYMLINK_MAX,
        _PC_2_SYMLINKS
    }

    enum
    {
        _SC_ARG_MAX,
        _SC_CHILD_MAX,
        _SC_CLK_TCK,
        _SC_NGROUPS_MAX,
        _SC_OPEN_MAX,
        _SC_STREAM_MAX,
        _SC_TZNAME_MAX,
        _SC_JOB_CONTROL,
        _SC_SAVED_IDS,
        _SC_REALTIME_SIGNALS,
        _SC_PRIORITY_SCHEDULING,
        _SC_TIMERS,
        _SC_ASYNCHRONOUS_IO,
        _SC_PRIORITIZED_IO,
        _SC_SYNCHRONIZED_IO,
        _SC_FSYNC,
        _SC_MAPPED_FILES,
        _SC_MEMLOCK,
        _SC_MEMLOCK_RANGE,
        _SC_MEMORY_PROTECTION,
        _SC_MESSAGE_PASSING,
        _SC_SEMAPHORES,
        _SC_SHARED_MEMORY_OBJECTS,
        _SC_AIO_LISTIO_MAX,
        _SC_AIO_MAX,
        _SC_AIO_PRIO_DELTA_MAX,
        _SC_DELAYTIMER_MAX,
        _SC_MQ_OPEN_MAX,
        _SC_MQ_PRIO_MAX,
        _SC_VERSION,
        _SC_PAGE_SIZE,
        _SC_PAGESIZE = _SC_PAGE_SIZE,
        _SC_RTSIG_MAX,
        _SC_SEM_NSEMS_MAX,
        _SC_SEM_VALUE_MAX,
        _SC_SIGQUEUE_MAX,
        _SC_TIMER_MAX,
        _SC_BC_BASE_MAX,
        _SC_BC_DIM_MAX,
        _SC_BC_SCALE_MAX,
        _SC_BC_STRING_MAX,
        _SC_COLL_WEIGHTS_MAX,

        _SC_EXPR_NEST_MAX = 42,
        _SC_LINE_MAX,
        _SC_RE_DUP_MAX,

        _SC_2_VERSION = 46,
        _SC_2_C_BIND,
        _SC_2_C_DEV,
        _SC_2_FORT_DEV,
        _SC_2_FORT_RUN,
        _SC_2_SW_DEV,
        _SC_2_LOCALEDEF,

        _SC_UIO_MAXIOV = 60,
        _SC_IOV_MAX = _SC_UIO_MAXIOV,

        _SC_THREADS = 67,
        _SC_THREAD_SAFE_FUNCTIONS,
        _SC_GETGR_R_SIZE_MAX,
        _SC_GETPW_R_SIZE_MAX,
        _SC_LOGIN_NAME_MAX,
        _SC_TTY_NAME_MAX,
        _SC_THREAD_DESTRUCTOR_ITERATIONS,
        _SC_THREAD_KEYS_MAX,
        _SC_THREAD_STACK_MIN,
        _SC_THREAD_THREADS_MAX,
        _SC_THREAD_ATTR_STACKADDR,
        _SC_THREAD_ATTR_STACKSIZE,
        _SC_THREAD_PRIORITY_SCHEDULING,
        _SC_THREAD_PRIO_INHERIT,
        _SC_THREAD_PRIO_PROTECT,
        _SC_THREAD_PROCESS_SHARED,

        _SC_NPROCESSORS_CONF,
        _SC_NPROCESSORS_ONLN,
        _SC_PHYS_PAGES,
        _SC_AVPHYS_PAGES,
        _SC_ATEXIT_MAX,
        _SC_PASS_MAX,

        _SC_XOPEN_VERSION,
        _SC_XOPEN_XCU_VERSION,
        _SC_XOPEN_UNIX,
        _SC_XOPEN_CRYPT,
        _SC_XOPEN_ENH_I18N,
        _SC_XOPEN_SHM,

        _SC_2_CHAR_TERM,
        _SC_2_UPE = 97,

        _SC_XOPEN_XPG2,
        _SC_XOPEN_XPG3,
        _SC_XOPEN_XPG4,

        _SC_NZERO = 109,

        _SC_XBS5_ILP32_OFF32 = 125,
        _SC_XBS5_ILP32_OFFBIG,
        _SC_XBS5_LP64_OFF64,
        _SC_XBS5_LPBIG_OFFBIG,

        _SC_XOPEN_LEGACY,
        _SC_XOPEN_REALTIME,
        _SC_XOPEN_REALTIME_THREADS,

        _SC_ADVISORY_INFO,
        _SC_BARRIERS,
        _SC_CLOCK_SELECTION = 137,
        _SC_CPUTIME,
        _SC_THREAD_CPUTIME,
        _SC_MONOTONIC_CLOCK = 149,
        _SC_READER_WRITER_LOCKS = 153,
        _SC_SPIN_LOCKS,
        _SC_REGEXP,
        _SC_SHELL = 157,
        _SC_SPAWN = 159,
        _SC_SPORADIC_SERVER,
        _SC_THREAD_SPORADIC_SERVER,
        _SC_TIMEOUTS = 164,
        _SC_TYPED_MEMORY_OBJECTS,
        _SC_2_PBS = 168,
        _SC_2_PBS_ACCOUNTING,
        _SC_2_PBS_LOCATE,
        _SC_2_PBS_MESSAGE,
        _SC_2_PBS_TRACK,
        _SC_SYMLOOP_MAX,
        _SC_STREAMS,
        _SC_2_PBS_CHECKPOINT,

        _SC_V6_ILP32_OFF32,
        _SC_V6_ILP32_OFFBIG,
        _SC_V6_LP64_OFF64,
        _SC_V6_LPBIG_OFFBIG,

        _SC_HOST_NAME_MAX,
        _SC_TRACE,
        _SC_TRACE_EVENT_FILTER,
        _SC_TRACE_INHERIT,
        _SC_TRACE_LOG,

        _SC_IPV6 = 235,
        _SC_RAW_SOCKETS,
        _SC_V7_ILP32_OFF32,
        _SC_V7_ILP32_OFFBIG,
        _SC_V7_LP64_OFF64,
        _SC_V7_LPBIG_OFFBIG,
        _SC_SS_REPL_MAX,
        _SC_TRACE_EVENT_NAME_MAX,
        _SC_TRACE_NAME_MAX,
        _SC_TRACE_SYS_MAX,
        _SC_TRACE_USER_EVENT_MAX,
        _SC_XOPEN_STREAMS,
        _SC_THREAD_ROBUST_PRIO_INHERIT,
        _SC_THREAD_ROBUST_PRIO_PROTECT
    }
}
else version (CRuntime_UClibc)
{
    enum F_OK       = 0;
    enum R_OK       = 4;
    enum W_OK       = 2;
    enum X_OK       = 1;

    enum F_ULOCK    = 0;
    enum F_LOCK     = 1;
    enum F_TLOCK    = 2;
    enum F_TEST     = 3;

    enum
    {
        _CS_PATH,

        _CS_V6_WIDTH_RESTRICTED_ENVS,

        _CS_GNU_LIBC_VERSION,
        _CS_GNU_LIBPTHREAD_VERSION,

        _CS_LFS_CFLAGS = 1000,
        _CS_LFS_LDFLAGS,
        _CS_LFS_LIBS,
        _CS_LFS_LINTFLAGS,
        _CS_LFS64_CFLAGS,
        _CS_LFS64_LDFLAGS,
        _CS_LFS64_LIBS,
        _CS_LFS64_LINTFLAGS,

        _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,
        _CS_XBS5_ILP32_OFF32_LDFLAGS,
        _CS_XBS5_ILP32_OFF32_LIBS,
        _CS_XBS5_ILP32_OFF32_LINTFLAGS,
        _CS_XBS5_ILP32_OFFBIG_CFLAGS,
        _CS_XBS5_ILP32_OFFBIG_LDFLAGS,
        _CS_XBS5_ILP32_OFFBIG_LIBS,
        _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,
        _CS_XBS5_LP64_OFF64_CFLAGS,
        _CS_XBS5_LP64_OFF64_LDFLAGS,
        _CS_XBS5_LP64_OFF64_LIBS,
        _CS_XBS5_LP64_OFF64_LINTFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_CFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,
        _CS_XBS5_LPBIG_OFFBIG_LIBS,
        _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,

        _CS_POSIX_V6_ILP32_OFF32_CFLAGS,
        _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFF32_LIBS,
        _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_ILP32_OFFBIG_LIBS,
        _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,
        _CS_POSIX_V6_LP64_OFF64_CFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LDFLAGS,
        _CS_POSIX_V6_LP64_OFF64_LIBS,
        _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,
        _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS
    }

    enum
    {
        _PC_LINK_MAX,
        _PC_MAX_CANON,
        _PC_MAX_INPUT,
        _PC_NAME_MAX,
        _PC_PATH_MAX,
        _PC_PIPE_BUF,
        _PC_CHOWN_RESTRICTED,
        _PC_NO_TRUNC,
        _PC_VDISABLE,
        _PC_SYNC_IO,
        _PC_ASYNC_IO,
        _PC_PRIO_IO,
        _PC_SOCK_MAXBUF,
        _PC_FILESIZEBITS,
        _PC_REC_INCR_XFER_SIZE,
        _PC_REC_MAX_XFER_SIZE,
        _PC_REC_MIN_XFER_SIZE,
        _PC_REC_XFER_ALIGN,
        _PC_ALLOC_SIZE_MIN,
        _PC_SYMLINK_MAX,
        _PC_2_SYMLINKS
    }

    enum
    {
        _SC_ARG_MAX,
        _SC_CHILD_MAX,
        _SC_CLK_TCK,
        _SC_NGROUPS_MAX,
        _SC_OPEN_MAX,
        _SC_STREAM_MAX,
        _SC_TZNAME_MAX,
        _SC_JOB_CONTROL,
        _SC_SAVED_IDS,
        _SC_REALTIME_SIGNALS,
        _SC_PRIORITY_SCHEDULING,
        _SC_TIMERS,
        _SC_ASYNCHRONOUS_IO,
        _SC_PRIORITIZED_IO,
        _SC_SYNCHRONIZED_IO,
        _SC_FSYNC,
        _SC_MAPPED_FILES,
        _SC_MEMLOCK,
        _SC_MEMLOCK_RANGE,
        _SC_MEMORY_PROTECTION,
        _SC_MESSAGE_PASSING,
        _SC_SEMAPHORES,
        _SC_SHARED_MEMORY_OBJECTS,
        _SC_AIO_LISTIO_MAX,
        _SC_AIO_MAX,
        _SC_AIO_PRIO_DELTA_MAX,
        _SC_DELAYTIMER_MAX,
        _SC_MQ_OPEN_MAX,
        _SC_MQ_PRIO_MAX,
        _SC_VERSION,
        _SC_PAGESIZE,
        _SC_PAGE_SIZE = _SC_PAGESIZE,
        _SC_RTSIG_MAX,
        _SC_SEM_NSEMS_MAX,
        _SC_SEM_VALUE_MAX,
        _SC_SIGQUEUE_MAX,
        _SC_TIMER_MAX,

        _SC_BC_BASE_MAX,
        _SC_BC_DIM_MAX,
        _SC_BC_SCALE_MAX,
        _SC_BC_STRING_MAX,
        _SC_COLL_WEIGHTS_MAX,
        _SC_EQUIV_CLASS_MAX,
        _SC_EXPR_NEST_MAX,
        _SC_LINE_MAX,
        _SC_RE_DUP_MAX,
        _SC_CHARCLASS_NAME_MAX,

        _SC_2_VERSION,
        _SC_2_C_BIND,
        _SC_2_C_DEV,
        _SC_2_FORT_DEV,
        _SC_2_FORT_RUN,
        _SC_2_SW_DEV,
        _SC_2_LOCALEDEF,

        _SC_PII,
        _SC_PII_XTI,
        _SC_PII_SOCKET,
        _SC_PII_INTERNET,
        _SC_PII_OSI,
        _SC_POLL,
        _SC_SELECT,
        _SC_UIO_MAXIOV,
        _SC_IOV_MAX = _SC_UIO_MAXIOV,
        _SC_PII_INTERNET_STREAM,
        _SC_PII_INTERNET_DGRAM,
        _SC_PII_OSI_COTS,
        _SC_PII_OSI_CLTS,
        _SC_PII_OSI_M,
        _SC_T_IOV_MAX,

        _SC_THREADS,
        _SC_THREAD_SAFE_FUNCTIONS,
        _SC_GETGR_R_SIZE_MAX,
        _SC_GETPW_R_SIZE_MAX,
        _SC_LOGIN_NAME_MAX,
        _SC_TTY_NAME_MAX,
        _SC_THREAD_DESTRUCTOR_ITERATIONS,
        _SC_THREAD_KEYS_MAX,
        _SC_THREAD_STACK_MIN,
        _SC_THREAD_THREADS_MAX,
        _SC_THREAD_ATTR_STACKADDR,
        _SC_THREAD_ATTR_STACKSIZE,
        _SC_THREAD_PRIORITY_SCHEDULING,
        _SC_THREAD_PRIO_INHERIT,
        _SC_THREAD_PRIO_PROTECT,
        _SC_THREAD_PROCESS_SHARED,

        _SC_NPROCESSORS_CONF,
        _SC_NPROCESSORS_ONLN,
        _SC_PHYS_PAGES,
        _SC_AVPHYS_PAGES,
        _SC_ATEXIT_MAX,
        _SC_PASS_MAX,

        _SC_XOPEN_VERSION,
        _SC_XOPEN_XCU_VERSION,
        _SC_XOPEN_UNIX,
        _SC_XOPEN_CRYPT,
        _SC_XOPEN_ENH_I18N,
        _SC_XOPEN_SHM,

        _SC_2_CHAR_TERM,
        _SC_2_C_VERSION,
        _SC_2_UPE,

        _SC_XOPEN_XPG2,
        _SC_XOPEN_XPG3,
        _SC_XOPEN_XPG4,

        _SC_CHAR_BIT,
        _SC_CHAR_MAX,
        _SC_CHAR_MIN,
        _SC_INT_MAX,
        _SC_INT_MIN,
        _SC_LONG_BIT,
        _SC_WORD_BIT,
        _SC_MB_LEN_MAX,
        _SC_NZERO,
        _SC_SSIZE_MAX,
        _SC_SCHAR_MAX,
        _SC_SCHAR_MIN,
        _SC_SHRT_MAX,
        _SC_SHRT_MIN,
        _SC_UCHAR_MAX,
        _SC_UINT_MAX,
        _SC_ULONG_MAX,
        _SC_USHRT_MAX,

        _SC_NL_ARGMAX,
        _SC_NL_LANGMAX,
        _SC_NL_MSGMAX,
        _SC_NL_NMAX,
        _SC_NL_SETMAX,
        _SC_NL_TEXTMAX,

        _SC_XBS5_ILP32_OFF32,
        _SC_XBS5_ILP32_OFFBIG,
        _SC_XBS5_LP64_OFF64,
        _SC_XBS5_LPBIG_OFFBIG,

        _SC_XOPEN_LEGACY,
        _SC_XOPEN_REALTIME,
        _SC_XOPEN_REALTIME_THREADS,

        _SC_ADVISORY_INFO,
        _SC_BARRIERS,
        _SC_BASE,
        _SC_C_LANG_SUPPORT,
        _SC_C_LANG_SUPPORT_R,
        _SC_CLOCK_SELECTION,
        _SC_CPUTIME,
        _SC_THREAD_CPUTIME,
        _SC_DEVICE_IO,
        _SC_DEVICE_SPECIFIC,
        _SC_DEVICE_SPECIFIC_R,
        _SC_FD_MGMT,
        _SC_FIFO,
        _SC_PIPE,
        _SC_FILE_ATTRIBUTES,
        _SC_FILE_LOCKING,
        _SC_FILE_SYSTEM,
        _SC_MONOTONIC_CLOCK,
        _SC_MULTI_PROCESS,
        _SC_SINGLE_PROCESS,
        _SC_NETWORKING,
        _SC_READER_WRITER_LOCKS,
        _SC_SPIN_LOCKS,
        _SC_REGEXP,
        _SC_REGEX_VERSION,
        _SC_SHELL,
        _SC_SIGNALS,
        _SC_SPAWN,
        _SC_SPORADIC_SERVER,
        _SC_THREAD_SPORADIC_SERVER,
        _SC_SYSTEM_DATABASE,
        _SC_SYSTEM_DATABASE_R,
        _SC_TIMEOUTS,
        _SC_TYPED_MEMORY_OBJECTS,
        _SC_USER_GROUPS,
        _SC_USER_GROUPS_R,
        _SC_2_PBS,
        _SC_2_PBS_ACCOUNTING,
        _SC_2_PBS_LOCATE,
        _SC_2_PBS_MESSAGE,
        _SC_2_PBS_TRACK,
        _SC_SYMLOOP_MAX,
        _SC_STREAMS,
        _SC_2_PBS_CHECKPOINT,

        _SC_V6_ILP32_OFF32,
        _SC_V6_ILP32_OFFBIG,
        _SC_V6_LP64_OFF64,
        _SC_V6_LPBIG_OFFBIG,

        _SC_HOST_NAME_MAX,
        _SC_TRACE,
        _SC_TRACE_EVENT_FILTER,
        _SC_TRACE_INHERIT,
        _SC_TRACE_LOG,

        _SC_LEVEL1_ICACHE_SIZE,
        _SC_LEVEL1_ICACHE_ASSOC,
        _SC_LEVEL1_ICACHE_LINESIZE,
        _SC_LEVEL1_DCACHE_SIZE,
        _SC_LEVEL1_DCACHE_ASSOC,
        _SC_LEVEL1_DCACHE_LINESIZE,
        _SC_LEVEL2_CACHE_SIZE,
        _SC_LEVEL2_CACHE_ASSOC,
        _SC_LEVEL2_CACHE_LINESIZE,
        _SC_LEVEL3_CACHE_SIZE,
        _SC_LEVEL3_CACHE_ASSOC,
        _SC_LEVEL3_CACHE_LINESIZE,
        _SC_LEVEL4_CACHE_SIZE,
        _SC_LEVEL4_CACHE_ASSOC,
        _SC_LEVEL4_CACHE_LINESIZE,

        _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,
        _SC_RAW_SOCKETS
    }
}

//
// File Synchronization (FSC)
//
/*
int fsync(int);
*/

version (CRuntime_Glibc)
{
    int fsync(int) @trusted;
}
else version (Darwin)
{
    int fsync(int) @trusted;
}
else version (FreeBSD)
{
    int fsync(int) @trusted;
}
else version (NetBSD)
{
    int fsync(int) @trusted;
}
else version (DragonFlyBSD)
{
    int fsync(int) @trusted;
}
else version (CRuntime_Bionic)
{
    int fsync(int) @trusted;
}
else version (CRuntime_Musl)
{
    int fsync(int) @trusted;
}
else version (Solaris)
{
    int fsync(int) @trusted;
}
else version (CRuntime_UClibc)
{
    int fsync(int) @trusted;
}

//
// Synchronized I/O (SIO)
//
/*
int fdatasync(int);
*/

version (CRuntime_Glibc)
{
    int fdatasync(int) @trusted;
}
else version (Solaris)
{
    int fdatasync(int) @trusted;
}
else version (CRuntime_Bionic)
{
    int fdatasync(int) @trusted;
}
else version (CRuntime_UClibc)
{
    int fdatasync(int) @trusted;
}

//
// XOpen (XSI)
//
/*
char*      crypt(in char*, in char*);
char*      ctermid(char*);
void       encrypt(ref char[64], int);
int        fchdir(int);
c_long     gethostid();
pid_t      getpgid(pid_t);
pid_t      getsid(pid_t);
char*      getwd(char*); // LEGACY
int        lchown(in char*, uid_t, gid_t);
int        lockf(int, int, off_t);
int        nice(int);
ssize_t    pread(int, void*, size_t, off_t);
ssize_t    pwrite(int, in void*, size_t, off_t);
pid_t      setpgrp();
int        setregid(gid_t, gid_t);
int        setreuid(uid_t, uid_t);
void       swab(in void*, void*, ssize_t);
void       sync();
int        truncate(in char*, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int        usleep(useconds_t);
pid_t      vfork();
*/

version (CRuntime_Glibc)
{
    char*      crypt(in char*, in char*);
    char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    pid_t      getpgid(pid_t) @trusted;
    pid_t      getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    //int        lockf(int, int, off_t);
    int        nice(int) @trusted;
    //ssize_t    pread(int, void*, size_t, off_t);
    //ssize_t    pwrite(int, in void*, size_t, off_t);
    pid_t      setpgrp() @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    //int        truncate(in char*, off_t);
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();

  static if ( __USE_FILE_OFFSET64 )
  {
    int        lockf64(int, int, off_t) @trusted;
    alias      lockf64 lockf;

    ssize_t    pread64(int, void*, size_t, off_t);
    alias      pread64 pread;

    ssize_t    pwrite64(int, in void*, size_t, off_t);
    alias      pwrite64 pwrite;

    int        truncate64(in char*, off_t);
    alias      truncate64 truncate;
  }
  else
  {
    int        lockf(int, int, off_t) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        truncate(in char*, off_t);
  }
}
else version (CRuntime_Musl)
{
    int fchdir(int) @trusted;
    int lockf(int, int, off_t);
    alias lockf lockf64;
}
else version (Darwin)
{
    char*      crypt(in char*, in char*);
    char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    pid_t      getpgid(pid_t) @trusted;
    pid_t      getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        lockf(int, int, off_t) @trusted;
    int        nice(int) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    pid_t      setpgrp() @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    int        truncate(in char*, off_t);
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();
}
else version (FreeBSD)
{
    char*      crypt(in char*, in char*);
    //char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    int        getpgid(pid_t) @trusted;
    int        getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        lockf(int, int, off_t) @trusted;
    int        nice(int) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        setpgrp(pid_t, pid_t) @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    int        truncate(in char*, off_t);
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();
}
else version (NetBSD)
{
    char*      crypt(in char*, in char*);
    //char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    int        getpgid(pid_t) @trusted;
    int        getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        lockf(int, int, off_t) @trusted;
    int        nice(int) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        setpgrp(pid_t, pid_t) @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    int        truncate(in char*, off_t);
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();
}
else version (DragonFlyBSD)
{
    char*      crypt(in char*, in char*);
    //char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    int        getpgid(pid_t) @trusted;
    int        getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        lockf(int, int, off_t) @trusted;
    int        nice(int) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        setpgrp(pid_t, pid_t) @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    int        truncate(in char*, off_t);
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();
}
else version (CRuntime_Bionic)
{
    int        fchdir(int) @trusted;
    pid_t      getpgid(pid_t) @trusted;
    int        lchown(in char*, uid_t, gid_t);
    int        nice(int) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        setpgrp() @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    int        sync() @trusted;
    int        truncate(in char*, off_t);
    int        usleep(c_ulong) @trusted;
    pid_t      vfork();
}
else version (Solaris)
{
    char*      crypt(in char*, in char*);
    char*      ctermid(char*);
    void       encrypt(ref char[64], int);
    int        fchdir(int);
    c_long     gethostid();
    pid_t      getpgid(pid_t);
    pid_t      getsid(pid_t);
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        nice(int);
    pid_t      setpgrp();
    int        setregid(gid_t, gid_t);
    int        setreuid(uid_t, uid_t);
    void       swab(in void*, void*, ssize_t);
    void       sync();
    useconds_t ualarm(useconds_t, useconds_t);
    int        usleep(useconds_t);
    pid_t      vfork();

    version (D_LP64)
    {
        int         lockf(int, int, off_t);
        alias       lockf lockf64;

        ssize_t     pread(int, void*, size_t, off_t);
        alias       pread pread64;

        ssize_t     pwrite(int, in void*, size_t, off_t);
        alias       pwrite pwrite64;

        int         truncate(in char*, off_t);
        alias       truncate truncate64;
    }
    else
    {
        static if ( __USE_FILE_OFFSET64 )
        {
            int        lockf64(int, int, off64_t);
            alias      lockf64 lockf;

            ssize_t    pread64(int, void*, size_t, off64_t);
            alias      pread64 pread;

            ssize_t    pwrite64(int, in void*, size_t, off_t);
            alias      pwrite64 pwrite;

            int        truncate64(in char*, off_t);
            alias      truncate64 truncate;
        }
        else
        {
            int        lockf(int, int, off_t);
            ssize_t    pread(int, void*, size_t, off_t);
            ssize_t    pwrite(int, in void*, size_t, off_t);
            int        truncate(in char*, off_t);
        }
    }
}
else version (CRuntime_UClibc)
{
    char*      crypt(in char*, in char*);
    char*      ctermid(char*);
    void       encrypt(ref char[64], int) @trusted;
    int        fchdir(int) @trusted;
    c_long     gethostid() @trusted;
    pid_t      getpgid(pid_t) @trusted;
    pid_t      getsid(pid_t) @trusted;
    char*      getwd(char*); // LEGACY
    int        lchown(in char*, uid_t, gid_t);
    int        nice(int) @trusted;
    pid_t      setpgrp() @trusted;
    int        setregid(gid_t, gid_t) @trusted;
    int        setreuid(uid_t, uid_t) @trusted;
    void       swab(in void*, void*, ssize_t);
    void       sync() @trusted;
    useconds_t ualarm(useconds_t, useconds_t) @trusted;
    int        usleep(useconds_t) @trusted;
    pid_t      vfork();

  static if ( __USE_FILE_OFFSET64 )
  {
    int        lockf64(int, int, off_t) @trusted;
    alias      lockf64 lockf;

    ssize_t    pread64(int, void*, size_t, off_t);
    alias      pread64 pread;

    ssize_t    pwrite64(int, in void*, size_t, off_t);
    alias      pwrite64 pwrite;

    int        truncate64(in char*, off_t);
    alias      truncate64 truncate;
  }
  else
  {
    int        lockf(int, int, off_t) @trusted;
    ssize_t    pread(int, void*, size_t, off_t);
    ssize_t    pwrite(int, in void*, size_t, off_t);
    int        truncate(in char*, off_t);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.utime;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for time_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C):
nothrow:
@nogc:

//
// Required
//
/*
struct utimbuf
{
    time_t  actime;
    time_t  modtime;
}

int utime(in char*, in utimbuf*);
*/

version (CRuntime_Glibc)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (CRuntime_Musl)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (Darwin)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (FreeBSD)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (NetBSD)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (DragonFlyBSD)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (Solaris)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (CRuntime_Bionic)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
else version (CRuntime_UClibc)
{
    struct utimbuf
    {
        time_t  actime;
        time_t  modtime;
    }

    int utime(in char*, in utimbuf*);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          k   .      ..  l   dlfcn.d m   elf.d   n   
execinfo.d  o   libelf.dp   link.d  q   sys |  time.d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * D header file for Solaris
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/head/dlfcn.h, illumos dlfcn.h)
 */

module core.sys.solaris.dlfcn;

version (Solaris):
extern (C):
nothrow:
@nogc:

public import core.sys.posix.dlfcn;
import core.stdc.config;

// enum RTLD_LAZY = 0x00001; // POSIX
// enum RTLD_NOW = 0x00002; // POSIX
enum RTLD_NOLOAD = 0x00004;
enum RTLD_DEEPBIND = 0x00008;

// enum RTLD_GLOBAL = 0x00100; // POSIX
// enum RTLD_LOCAL = 0; // POSIX
enum RTLD_PARENT   = 0x00200;
enum RTLD_GROUP    = 0x00400;
enum RTLD_WORLD    = 0x00800;
enum RTLD_NODELETE = 0x01000;
enum RTLD_FIRST    = 0x02000;
enum RTLD_CONFGEN  = 0x10000;


enum
{
    RTLD_NEXT    = cast(void *)-1,
    RTLD_DEFAULT = cast(void *)-2,
    RTLD_SELF    = cast(void *)-3,
    RTLD_PROBE   = cast(void *)-4,
}

alias c_ulong Lmid_t;

void* dlmopen(Lmid_t, in char*, int);

enum
{
    RTLD_REL_RELATIVE = 0x00001,
    RTLD_REL_EXEC     = 0x00002,
    RTLD_REL_DEPENDS  = 0x00004,
    RTLD_REL_PRELOAD  = 0x00008,
    RTLD_REL_SELF     = 0x00010,
    RTLD_REL_WEAK     = 0x00020,
    RTLD_REL_ALL      = 0x00fff,
    RTLD_MEMORY       = 0x01000,
    RTLD_STRIP        = 0x02000,
    RTLD_NOHEAP       = 0x04000,
    RTLD_CONFSET      = 0x10000,
}

int dldump(in char*, in char*, int);

struct Dl_info
{
    const(char)* dli_fname;
    void*        dli_fbase;
    const(char)* dli_sname;
    void*        dli_saddr;
}

enum
{
    RTLD_DL_SYMENT = 1,
    RTLD_DL_LINKMAP = 2,
}

int dladdr(const(void)*, Dl_info*);
int dladdr1(void*, Dl_info*, void**, int);

enum
{
    RTLD_DI_LMID         = 1,
    RTLD_DI_LINKMAP      = 2,
    RTLD_DI_CONFIGADDR   = 3,
    RTLD_DI_SERINFO      = 4,
    RTLD_DI_SERINFOSIZE  = 5,
    RTLD_DI_ORIGIN       = 6,
    RTLD_DI_PROFILENAME  = 7,
    RTLD_DI_PROFILEOUT   = 8,
    RTLD_DI_GETSIGNAL    = 9,
    RTLD_DI_SETSIGNAL    = 10,
    RTLD_DI_ARGSINFO     = 11,
    RTLD_DI_MMAPS        = 12,
    RTLD_DI_MMAPCNT      = 13,
    RTLD_DI_DEFERRED     = 14,
    RTLD_DI_DEFERRED_SYM = 15,
    RTLD_DI_MAX          = 15,
}

int dlinfo(void*, int, void*);

struct Dl_serpath
{
    char*  dls_name;
    uint   dls_flags;
}

struct Dl_serinfo
{
    size_t         dls_size;
    uint           dls_cnt;
    Dl_serpath[1]  dls_serpath;
}

// FIXME: Dl_argsinfo, Dl_mapinfo, Dl_amd64_unwindinfo are missing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/head/elf.h, illumos elf.h)
 */
module core.sys.solaris.elf;

version (Solaris):
extern (C):
nothrow:

public import core.sys.solaris.sys.elf;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * D header file for Solaris.
 *
 * Copyright: Copyright Martin Nowak 2012.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Authors:   Martin Nowak
 */
module core.sys.solaris.execinfo;

// The interface is exactly the same as linux, so copied from linux's execinfo.d

version (Solaris):
extern (C):
nothrow:

int backtrace(void** buffer, int size);
char** backtrace_symbols(const(void*)* buffer, int size);
void backtrace_symbols_fd(const(void*)* buffer, int size, int fd);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/head/libelf.h, illumos libelf.h)
 */
module core.sys.solaris.libelf;

version (Solaris):
extern (C):
nothrow:

import core.stdc.config;
import core.sys.posix.sys.types;
import core.sys.solaris.sys.elf;

enum Elf_Cmd
{
    ELF_C_NULL = 0,
    ELF_C_READ,
    ELF_C_WRITE,
    ELF_C_CLR,
    ELF_C_SET,
    ELF_C_FDDONE,
    ELF_C_FDREAD,
    ELF_C_RDWR,
    ELF_C_WRIMAGE,
    ELF_C_IMAGE,
    ELF_C_NUM
}

enum ELF_F_DIRTY  = 0x1;
enum ELF_F_LAYOUT = 0x4;

enum Elf_Kind
{
    ELF_K_NONE = 0,
    ELF_K_AR,
    ELF_K_COFF,
    ELF_K_ELF,
    ELF_K_NUM
}

enum Elf_Type
{
    ELF_T_BYTE = 0,
    ELF_T_ADDR,
    ELF_T_DYN,
    ELF_T_EHDR,
    ELF_T_HALF,
    ELF_T_OFF,
    ELF_T_PHDR,
    ELF_T_RELA,
    ELF_T_REL,
    ELF_T_SHDR,
    ELF_T_SWORD,
    ELF_T_SYM,
    ELF_T_WORD,
    ELF_T_VDEF,
    ELF_T_VNEED,
    ELF_T_SXWORD,
    ELF_T_XWORD,
    ELF_T_SYMINFO,
    ELF_T_NOTE,
    ELF_T_MOVE,
    ELF_T_MOVEP,
    ELF_T_CAP,
    ELF_T_NUM
}

struct Elf
{
}

struct Elf_Scn
{
}

struct Elf_Arhdr
{
    char*   ar_name;
    time_t  ar_date;
    uid_t   ar_uid;
    gid_t   ar_gid;
    mode_t  ar_mode;
    off_t   ar_size;
    char*   ar_rawname;
}

struct Elf_Arsym
{
    char*    as_name;
    size_t   as_off;
    c_ulong  as_hash;
}

struct Elf_Data
{
  void*     d_buf;
  Elf_Type  d_type;
  size_t    d_size;
  off_t     d_off;
  size_t    d_align;
  uint      d_version;
}

Elf* elf_begin(int, Elf_Cmd, Elf*);
int elf_cntl(Elf*, Elf_Cmd);
int elf_end(Elf*);
const(char)* elf_errmsg(int);
int elf_errno();
void elf_fill(int);
uint elf_flagdata(Elf_Data*, Elf_Cmd, uint);
uint elf_flagehdr(Elf*, Elf_Cmd,  uint);
uint elf_flagelf(Elf*, Elf_Cmd, uint);
uint elf_flagphdr(Elf*, Elf_Cmd, uint);
uint elf_flagscn(Elf_Scn*, Elf_Cmd, uint);
uint elf_flagshdr(Elf_Scn*, Elf_Cmd, uint);
size_t elf32_fsize(Elf_Type, size_t, uint);
Elf_Arhdr* elf_getarhdr(Elf*);
Elf_Arsym* elf_getarsym(Elf*, size_t*);
off_t elf_getbase(Elf*);
Elf_Data* elf_getdata(Elf_Scn*, Elf_Data*);
Elf32_Ehdr* elf32_getehdr(Elf*);
char* elf_getident(Elf*, size_t*);
Elf32_Phdr* elf32_getphdr(Elf*);
Elf_Scn* elf_getscn(Elf*, size_t);
Elf32_Shdr* elf32_getshdr(Elf_Scn*);
int elf_getphnum(Elf*, size_t*);
int elf_getphdrnum(Elf*, size_t*);
int elf_getshnum(Elf*, size_t*);
int elf_getshdrnum(Elf*, size_t*);
int elf_getshstrndx(Elf*, size_t*);
int elf_getshdrstrndx(Elf*, size_t*);
c_ulong elf_hash(in char*);
uint elf_sys_encoding();
long elf32_checksum(Elf*);
Elf_Kind elf_kind(Elf*);
Elf* elf_memory(char*, size_t);
size_t elf_ndxscn(Elf_Scn*);
Elf_Data* elf_newdata(Elf_Scn*);
Elf32_Ehdr* elf32_newehdr(Elf*);
Elf32_Phdr* elf32_newphdr(Elf*, size_t);
Elf_Scn* elf_newscn(Elf*);
Elf_Scn* elf_nextscn(Elf*, Elf_Scn*);
Elf_Cmd elf_next(Elf*);
size_t elf_rand(Elf*, size_t);
Elf_Data* elf_rawdata(Elf_Scn*, Elf_Data*);
char* elf_rawfile(Elf*, size_t*);
char* elf_strptr(Elf*, size_t, size_t);
off_t elf_update(Elf*, Elf_Cmd);
uint elf_version(uint);
Elf_Data* elf32_xlatetof(Elf_Data*, in Elf_Data*, uint);
Elf_Data* elf32_xlatetom(Elf_Data*, in Elf_Data*, uint);

version (D_LP64)
{
size_t elf64_fsize(Elf_Type, size_t, uint);
Elf64_Ehdr* elf64_getehdr(Elf*);
Elf64_Phdr* elf64_getphdr(Elf*);
Elf64_Shdr* elf64_getshdr(Elf_Scn*);
long elf64_checksum(Elf*);
Elf64_Ehdr* elf64_newehdr(Elf*);
Elf64_Phdr* elf64_newphdr(Elf*, size_t);
Elf_Data* elf64_xlatetof(Elf_Data*, in Elf_Data*, uint);
Elf_Data* elf64_xlatetom(Elf_Data*, in Elf_Data*, uint);
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ﻿/**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/head/link.h, illumos link.h)
 */
module core.sys.solaris.link;

version (Solaris):
extern (C):
nothrow:

import core.stdc.stdint;
import core.sys.solaris.dlfcn;
import core.sys.solaris.libelf;
import core.sys.solaris.sys.elf;
import core.sys.solaris.sys.link;

uint ld_version(uint);
void ld_input_done(uint*);

void ld_start(in char*, in Elf32_Half, in char*);
void ld_atexit(int);
void ld_open(in char**, in char**, int*, int, Elf**, Elf*, size_t, in Elf_Kind);
void ld_file(in char*, in Elf_Kind, int, Elf*);
void ld_input_section(in char*, Elf32_Shdr**, Elf32_Word, Elf_Data*, Elf*, uint*);
void ld_section(in char*, Elf32_Shdr*, Elf32_Word, Elf_Data*, Elf*);

version (D_LP64)
{
    void ld_start64(in char*, in Elf64_Half, in char*);
    void ld_atexit64(int);
    void ld_open64(in char**, in char**, int*, int, Elf**, Elf*, size_t, in Elf_Kind);
    void ld_file64(in char*, in Elf_Kind, int, Elf*);
    void ld_input_section64(in char*, Elf64_Shdr**, Elf64_Word, Elf_Data*, Elf*, uint*);
    void ld_section64(in char*, Elf64_Shdr*, Elf64_Word, Elf_Data*, Elf*);
}

enum LD_SUP_VNONE    = 0;
enum LD_SUP_VERSION1 = 1;
enum LD_SUP_VERSION2 = 2;
enum LD_SUP_VERSION3 = 3;
enum LD_SUP_VCURRENT = LD_SUP_VERSION3;

enum LD_SUP_DERIVED   = 0x1;
enum LD_SUP_INHERITED = 0x2;
enum LD_SUP_EXTRACTED = 0x4;

enum LM_ID_BASE = 0x00;
enum LM_ID_LDSO = 0x01;
enum LM_ID_NUM  = 2;

enum LM_ID_BRAND = 0xfd;
enum LM_ID_NONE  = 0xfe;
enum LM_ID_NEWLM = 0xff;

enum LAV_NONE     = 0;
enum LAV_VERSION1 = 1;
enum LAV_VERSION2 = 2;
enum LAV_VERSION3 = 3;
enum LAV_VERSION4 = 4;
enum LAV_VERSION5 = 5;
enum LAV_CURRENT  = LAV_VERSION5;
enum LAV_NUM      = 6;

enum LA_FLG_BINDTO   = 0x0001;
enum LA_FLG_BINDFROM = 0x0002;

enum LA_SYMB_NOPLTENTER = 0x0001;
enum LA_SYMB_NOPLTEXIT  = 0x0002;
enum LA_SYMB_STRUCTCALL = 0x0004;
enum LA_SYMB_DLSYM      = 0x0008;
enum LA_SYMB_ALTVALUE   = 0x0010;

enum LA_SER_ORIG    = 0x001;
enum LA_SER_LIBPATH = 0x002;
enum LA_SER_RUNPATH = 0x004;
enum LA_SER_CONFIG  = 0x008;
enum LA_SER_DEFAULT = 0x040;
enum LA_SER_SECURE  = 0x080;

enum LA_SER_MASK    = 0xfff;

enum LA_ACT_CONSISTENT = 0x00;
enum LA_ACT_ADD        = 0x01;
enum LA_ACT_DELETE     = 0x02;
enum LA_ACT_MAX        = 3;

version (D_LP64)
    alias long lagreg_t;
else
    alias int lagreg_t;

struct _la_sparc_regs
{
    lagreg_t  lr_rego0;
    lagreg_t  lr_rego1;
    lagreg_t  lr_rego2;
    lagreg_t  lr_rego3;
    lagreg_t  lr_rego4;
    lagreg_t  lr_rego5;
    lagreg_t  lr_rego6;
    lagreg_t  lr_rego7;
}

version (D_LP64)
{
    alias _la_sparc_regs La_sparcv9_regs;
    struct La_amd64_regs
    {
        lagreg_t  lr_rsp;
        lagreg_t  lr_rbp;
        lagreg_t  lr_rdi;
        lagreg_t  lr_rsi;
        lagreg_t  lr_rdx;
        lagreg_t  lr_rcx;
        lagreg_t  lr_r8;
        lagreg_t  lr_r9;
    }
}
else
{
    alias _la_sparc_regs La_sparcv8_regs;
    struct La_i86_regs
    {
        lagreg_t  lr_esp;
        lagreg_t  lr_ebp;
    }
}

uint la_version(uint);
void la_activity(uintptr_t*, uint);
void la_preinit(uintptr_t*);
char* la_objsearch(in char*, uintptr_t*, uint);
uint la_objopen(Link_map*, Lmid_t, uintptr_t*);
uint la_objclose(uintptr_t*);
int la_objfilter(uintptr_t*, in char*, uintptr_t*, uint);

version (D_LP64)
{
    uintptr_t la_amd64_pltenter(Elf64_Sym*, uint, uintptr_t*, uintptr_t*,
                                La_amd64_regs*, uint*, in char*);
    uintptr_t la_symbind64(Elf64_Sym*, uint, uintptr_t*, uintptr_t*, uint*, in char*);
    uintptr_t la_sparcv9_pltenter(Elf64_Sym*, uint, uintptr_t*, uintptr_t*,
                                  La_sparcv9_regs*, uint*, in char*);
    uintptr_t la_pltexit64(Elf64_Sym*, uint, uintptr_t*, uintptr_t*, uintptr_t, in char*);
}
else
{
    uintptr_t la_symbind32(Elf32_Sym*, uint, uintptr_t*, uintptr_t*, uint*);
    uintptr_t la_sparcv8_pltenter(Elf32_Sym*, uint, uintptr_t*, uintptr_t*,
                                  La_sparcv8_regs*, uint*);
    uintptr_t la_i86_pltenter(Elf32_Sym*, uint, uintptr_t*, uintptr_t*,
                              La_i86_regs*, uint*);
    uintptr_t la_pltexit(Elf32_Sym*, uint, uintptr_t*, uintptr_t*, uintptr_t);
}

template ElfW(string type)
{
    version (D_LP64)
        mixin("alias Elf64_"~type~" ElfW;");
    else
        mixin("alias Elf32_"~type~" ElfW;");
}

struct dl_phdr_info
{
    ElfW!"Addr"        dlpi_addr;
    char*              dlpi_name;
    ElfW!"Phdr"*       dlpi_phdr;
    ElfW!"Half"        dlpi_phnum;
    uint64_t           dlpi_adds;
    uint64_t           dlpi_subs;
    size_t             dlpi_tls_modid;  // since Solaris 11.5
    void*              dlpi_tls_data;   // since Solaris 11.5
};

private alias extern(C) int function(dl_phdr_info*, size_t, void *) dl_iterate_phdr_cb;
private alias extern(C) int function(dl_phdr_info*, size_t, void *) @nogc dl_iterate_phdr_cb_ngc;
extern int dl_iterate_phdr(dl_iterate_phdr_cb __callback, void*__data);
extern int dl_iterate_phdr(dl_iterate_phdr_cb_ngc __callback, void*__data) @nogc;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   q   .   k   ..  r   elf.d   s   	elf_386.d   t   elf_SPARC.d u   elf_amd64.d v   elf_notes.d w   
elftypes.d  x   link.d  y   
priocntl.d  z   	procset.d   {  <types.d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elf_386.h, illumos sys/elf_386.h)
 */
module core.sys.solaris.sys.elf;

version (Solaris):
extern (C):
nothrow:

public import core.sys.solaris.sys.elftypes;

enum ELF32_FSZ_ADDR  = 4;
enum ELF32_FSZ_HALF  = 2;
enum ELF32_FSZ_OFF   = 4;
enum ELF32_FSZ_SWORD = 4;
enum ELF32_FSZ_WORD  = 4;

enum ELF64_FSZ_ADDR   = 8;
enum ELF64_FSZ_HALF   = 2;
enum ELF64_FSZ_OFF    = 8;
enum ELF64_FSZ_SWORD  = 4;
enum ELF64_FSZ_WORD   = 4;
enum ELF64_FSZ_SXWORD = 8;
enum ELF64_FSZ_XWORD  = 8;

enum EI_NIDENT = 16;

struct Elf32_Ehdr
{
    char[EI_NIDENT] e_ident = 0;
    Elf32_Half    e_type;
    Elf32_Half    e_machine;
    Elf32_Word    e_version;
    Elf32_Addr    e_entry;
    Elf32_Off     e_phoff;
    Elf32_Off     e_shoff;
    Elf32_Word    e_flags;
    Elf32_Half    e_ehsize;
    Elf32_Half    e_phentsize;
    Elf32_Half    e_phnum;
    Elf32_Half    e_shentsize;
    Elf32_Half    e_shnum;
    Elf32_Half    e_shstrndx;
}

struct Elf64_Ehdr
{
    char[EI_NIDENT] e_ident = 0;
    Elf64_Half    e_type;
    Elf64_Half    e_machine;
    Elf64_Word    e_version;
    Elf64_Addr    e_entry;
    Elf64_Off     e_phoff;
    Elf64_Off     e_shoff;
    Elf64_Word    e_flags;
    Elf64_Half    e_ehsize;
    Elf64_Half    e_phentsize;
    Elf64_Half    e_phnum;
    Elf64_Half    e_shentsize;
    Elf64_Half    e_shnum;
    Elf64_Half    e_shstrndx;
}

enum EI_MAG0       = 0;
enum EI_MAG1       = 1;
enum EI_MAG2       = 2;
enum EI_MAG3       = 3;
enum EI_CLASS      = 4;
enum EI_DATA       = 5;
enum EI_VERSION    = 6;
enum EI_OSABI      = 7;
enum EI_ABIVERSION = 8;
enum EI_PAD        = 9;

enum ELFMAG0 = 0x7f;
enum ELFMAG1 = 'E';
enum ELFMAG2 = 'L';
enum ELFMAG3 = 'F';
enum ELFMAG  = "\177ELF";
enum SELFMAG = 4;

enum ELFCLASSNONE = 0;
enum ELFCLASS32   = 1;
enum ELFCLASS64   = 2;
enum ELFCLASSNUM  = 3;

enum ELFDATANONE = 0;
enum ELFDATA2LSB = 1;
enum ELFDATA2MSB = 2;
enum ELFDATANUM  = 3;

enum ET_NONE       = 0;
enum ET_REL        = 1;
enum ET_EXEC       = 2;
enum ET_DYN        = 3;
enum ET_CORE       = 4;
enum ET_NUM        = 5;
enum ET_LOOS       = 0xfe00;
enum ET_LOSUNW     = 0xfeff;
enum ET_SUNWPSEUDO = 0xfeff;
enum ET_HISUNW     = 0xfeff;
enum ET_HIOS       = 0xfeff;
enum ET_LOPROC     = 0xff00;
enum ET_HIPROC     = 0xffff;

enum EM_NONE        = 0;
enum EM_M32         = 1;
enum EM_SPARC       = 2;
enum EM_386         = 3;
enum EM_68K         = 4;
enum EM_88K         = 5;
enum EM_486         = 6;
enum EM_860         = 7;
enum EM_MIPS        = 8;
enum EM_S370        = 9;
enum EM_MIPS_RS3_LE = 10;
enum EM_RS6000      = 11;
enum EM_UNKNOWN12   = 12;
enum EM_UNKNOWN13   = 13;
enum EM_UNKNOWN14   = 14;
enum EM_PA_RISC     = 15;
enum EM_PARISC      = EM_PA_RISC;
enum EM_nCUBE       = 16;
enum EM_VPP500      = 17;
enum EM_SPARC32PLUS = 18;
enum EM_960         = 19;
enum EM_PPC         = 20;
enum EM_PPC64       = 21;
enum EM_S390        = 22;
enum EM_UNKNOWN22   = EM_S390;
enum EM_UNKNOWN23   = 23;
enum EM_UNKNOWN24   = 24;
enum EM_UNKNOWN25   = 25;
enum EM_UNKNOWN26   = 26;
enum EM_UNKNOWN27   = 27;
enum EM_UNKNOWN28   = 28;
enum EM_UNKNOWN29   = 29;
enum EM_UNKNOWN30   = 30;
enum EM_UNKNOWN31   = 31;
enum EM_UNKNOWN32   = 32;
enum EM_UNKNOWN33   = 33;
enum EM_UNKNOWN34   = 34;
enum EM_UNKNOWN35   = 35;
enum EM_V800        = 36;
enum EM_FR20        = 37;
enum EM_RH32        = 38;
enum EM_RCE         = 39;
enum EM_ARM         = 40;
enum EM_ALPHA       = 41;
enum EM_SH          = 42;
enum EM_SPARCV9     = 43;
enum EM_TRICORE     = 44;
enum EM_ARC         = 45;
enum EM_H8_300      = 46;
enum EM_H8_300H     = 47;
enum EM_H8S         = 48;
enum EM_H8_500      = 49;
enum EM_IA_64       = 50;
enum EM_MIPS_X      = 51;
enum EM_COLDFIRE    = 52;
enum EM_68HC12      = 53;
enum EM_MMA         = 54;
enum EM_PCP         = 55;
enum EM_NCPU        = 56;
enum EM_NDR1        = 57;
enum EM_STARCORE    = 58;
enum EM_ME16        = 59;
enum EM_ST100       = 60;
enum EM_TINYJ       = 61;
enum EM_AMD64       = 62;
enum EM_X86_64      = EM_AMD64;
enum EM_PDSP        = 63;
enum EM_UNKNOWN64   = 64;
enum EM_UNKNOWN65   = 65;
enum EM_FX66        = 66;
enum EM_ST9PLUS     = 67;
enum EM_ST7         = 68;
enum EM_68HC16      = 69;
enum EM_68HC11      = 70;
enum EM_68HC08      = 71;
enum EM_68HC05      = 72;
enum EM_SVX         = 73;
enum EM_ST19        = 74;
enum EM_VAX         = 75;
enum EM_CRIS        = 76;
enum EM_JAVELIN     = 77;
enum EM_FIREPATH    = 78;
enum EM_ZSP         = 79;
enum EM_MMIX        = 80;
enum EM_HUANY       = 81;
enum EM_PRISM       = 82;
enum EM_AVR         = 83;
enum EM_FR30        = 84;
enum EM_D10V        = 85;
enum EM_D30V        = 86;
enum EM_V850        = 87;
enum EM_M32R        = 88;
enum EM_MN10300     = 89;
enum EM_MN10200     = 90;
enum EM_PJ          = 91;
enum EM_OPENRISC    = 92;
enum EM_ARC_A5      = 93;
enum EM_XTENSA      = 94;
enum EM_NUM         = 95;

enum EV_NONE    = 0;
enum EV_CURRENT = 1;
enum EV_NUM     = 2;


enum ELFOSABI_NONE        = 0;
enum ELFOSABI_SYSV        = ELFOSABI_NONE;
enum ELFOSABI_HPUX        = 1;
enum ELFOSABI_NETBSD      = 2;
enum ELFOSABI_LINUX       = 3;
enum ELFOSABI_UNKNOWN4    = 4;
enum ELFOSABI_UNKNOWN5    = 5;
enum ELFOSABI_SOLARIS     = 6;
enum ELFOSABI_AIX         = 7;
enum ELFOSABI_IRIX        = 8;
enum ELFOSABI_FREEBSD     = 9;
enum ELFOSABI_TRU64       = 10;
enum ELFOSABI_MODESTO     = 11;
enum ELFOSABI_OPENBSD     = 12;
enum ELFOSABI_OPENVMS     = 13;
enum ELFOSABI_NSK         = 14;
enum ELFOSABI_AROS        = 15;
enum ELFOSABI_ARM         = 97;
enum ELFOSABI_STANDALONE  = 255;
enum ELFOSABI_DRAGONFLYBSD= ELFOSABI_NONE;

enum EAV_SUNW_NONE    = 0;
enum EAV_SUNW_CURRENT = 1;
enum EAV_SUNW_NUM     = 2;

struct Elf32_Phdr
{
    Elf32_Word    p_type;
    Elf32_Off     p_offset;
    Elf32_Addr    p_vaddr;
    Elf32_Addr    p_paddr;
    Elf32_Word    p_filesz;
    Elf32_Word    p_memsz;
    Elf32_Word    p_flags;
    Elf32_Word    p_align;
}

struct Elf64_Phdr
{
    Elf64_Word    p_type;
    Elf64_Word    p_flags;
    Elf64_Off     p_offset;
    Elf64_Addr    p_vaddr;
    Elf64_Addr    p_paddr;
    Elf64_Xword   p_filesz;
    Elf64_Xword   p_memsz;
    Elf64_Xword   p_align;
}

enum PT_NULL    = 0;
enum PT_LOAD    = 1;
enum PT_DYNAMIC = 2;
enum PT_INTERP  = 3;
enum PT_NOTE    = 4;
enum PT_SHLIB   = 5;
enum PT_PHDR    = 6;
enum PT_TLS     = 7;
enum PT_NUM     = 8;

enum PT_LOOS    = 0x60000000;

enum PT_SUNW_UNWIND   = 0x6464e550;
enum PT_SUNW_EH_FRAME = 0x6474e550;
enum PT_GNU_EH_FRAME  = PT_SUNW_EH_FRAME;

enum PT_GNU_STACK = 0x6474e551;
enum PT_GNU_RELRO = 0x6474e552;

enum PT_LOSUNW     = 0x6ffffffa;
enum PT_SUNWBSS    = 0x6ffffffa;
enum PT_SUNWSTACK  = 0x6ffffffb;
enum PT_SUNWDTRACE = 0x6ffffffc;
enum PT_SUNWCAP    = 0x6ffffffd;
enum PT_HISUNW     = 0x6fffffff;
enum PT_HIOS       = 0x6fffffff;
enum PT_LOPROC     = 0x70000000;
enum PT_HIPROC     = 0x7fffffff;

enum PF_R = 0x4;
enum PF_W = 0x2;
enum PF_X = 0x1;

enum PF_MASKOS   = 0x0ff00000;
enum PF_MASKPROC = 0xf0000000;

enum PF_SUNW_FAILURE = 0x00100000;
enum PF_SUNW_KILLED  = 0x00200000;
enum PF_SUNW_SIGINFO = 0x00400000;

enum PN_XNUM = 0xffff;

struct Elf32_Shdr
{
    Elf32_Word    sh_name;
    Elf32_Word    sh_type;
    Elf32_Word    sh_flags;
    Elf32_Addr    sh_addr;
    Elf32_Off     sh_offset;
    Elf32_Word    sh_size;
    Elf32_Word    sh_link;
    Elf32_Word    sh_info;
    Elf32_Word    sh_addralign;
    Elf32_Word    sh_entsize;
}

struct Elf64_Shdr
{
    Elf64_Word    sh_name;
    Elf64_Word    sh_type;
    Elf64_Xword   sh_flags;
    Elf64_Addr    sh_addr;
    Elf64_Off     sh_offset;
    Elf64_Xword   sh_size;
    Elf64_Word    sh_link;
    Elf64_Word    sh_info;
    Elf64_Xword   sh_addralign;
    Elf64_Xword   sh_entsize;
}

enum SHT_NULL          = 0;
enum SHT_PROGBITS      = 1;
enum SHT_SYMTAB        = 2;
enum SHT_STRTAB        = 3;
enum SHT_RELA          = 4;
enum SHT_HASH          = 5;
enum SHT_DYNAMIC       = 6;
enum SHT_NOTE          = 7;
enum SHT_NOBITS        = 8;
enum SHT_REL           = 9;
enum SHT_SHLIB         = 10;
enum SHT_DYNSYM        = 11;
enum SHT_UNKNOWN12     = 12;
enum SHT_UNKNOWN13     = 13;
enum SHT_INIT_ARRAY    = 14;
enum SHT_FINI_ARRAY    = 15;
enum SHT_PREINIT_ARRAY = 16;
enum SHT_GROUP         = 17;
enum SHT_SYMTAB_SHNDX  = 18;
enum SHT_NUM           = 19;

enum SHT_LOOS           = 0x60000000;
enum SHT_LOSUNW         = 0x6fffffef;
enum SHT_SUNW_capchain  = 0x6fffffef;
enum SHT_SUNW_capinfo   = 0x6ffffff0;
enum SHT_SUNW_symsort   = 0x6ffffff1;
enum SHT_SUNW_tlssort   = 0x6ffffff2;
enum SHT_SUNW_LDYNSYM   = 0x6ffffff3;
enum SHT_SUNW_dof       = 0x6ffffff4;
enum SHT_SUNW_cap       = 0x6ffffff5;
enum SHT_SUNW_SIGNATURE = 0x6ffffff6;
enum SHT_SUNW_ANNOTATE  = 0x6ffffff7;
enum SHT_SUNW_DEBUGSTR  = 0x6ffffff8;
enum SHT_SUNW_DEBUG     = 0x6ffffff9;
enum SHT_SUNW_move      = 0x6ffffffa;
enum SHT_SUNW_COMDAT    = 0x6ffffffb;
enum SHT_SUNW_syminfo   = 0x6ffffffc;
enum SHT_SUNW_verdef    = 0x6ffffffd;
enum SHT_GNU_verdef     = SHT_SUNW_verdef;
enum SHT_SUNW_verneed   = 0x6ffffffe;
enum SHT_GNU_verneed    = SHT_SUNW_verneed;
enum SHT_SUNW_versym    = 0x6fffffff;
enum SHT_GNU_versym     = SHT_SUNW_versym;
enum SHT_HISUNW         = 0x6fffffff;
enum SHT_HIOS           = 0x6fffffff;
enum SHT_GNU_ATTRIBUTES = 0x6ffffff5;
enum SHT_GNU_HASH       = 0x6ffffff6;
enum SHT_GNU_LIBLIST    = 0x6ffffff7;
enum SHT_CHECKSUM       = 0x6ffffff8;
enum SHT_LOPROC         = 0x70000000;
enum SHT_HIPROC         = 0x7fffffff;
enum SHT_LOUSER         = 0x80000000;
enum SHT_HIUSER         = 0xffffffff;

enum SHF_WRITE            = 0x01;
enum SHF_ALLOC            = 0x02;
enum SHF_EXECINSTR        = 0x04;
enum SHF_MERGE            = 0x10;
enum SHF_STRINGS          = 0x20;
enum SHF_INFO_LINK        = 0x40;
enum SHF_LINK_ORDER       = 0x80;
enum SHF_OS_NONCONFORMING = 0x100;
enum SHF_GROUP            = 0x200;
enum SHF_TLS              = 0x400;

enum SHF_MASKOS = 0x0ff00000;

enum SHF_MASKPROC = 0xf0000000;

enum SHN_UNDEF       = 0;
enum SHN_LORESERVE   = 0xff00;
enum SHN_LOPROC      = 0xff00;
enum SHN_HIPROC      = 0xff1f;
enum SHN_LOOS        = 0xff20;
enum SHN_LOSUNW      = 0xff3f;
enum SHN_SUNW_IGNORE = 0xff3f;
enum SHN_HISUNW      = 0xff3f;
enum SHN_HIOS        = 0xff3f;
enum SHN_ABS         = 0xfff1;
enum SHN_COMMON      = 0xfff2;
enum SHN_XINDEX      = 0xffff;
enum SHN_HIRESERVE   = 0xffff;

struct Elf32_Sym
{
    Elf32_Word    st_name;
    Elf32_Addr    st_value;
    Elf32_Word    st_size;
    ubyte         st_info;
    ubyte         st_other;
    Elf32_Half    st_shndx;
}

struct Elf64_Sym
{
    Elf64_Word    st_name;
    ubyte         st_info;
    ubyte         st_other;
    Elf64_Half    st_shndx;
    Elf64_Addr    st_value;
    Elf64_Xword   st_size;
}

enum STN_UNDEF  = 0;

extern (D)
{
    auto ELF32_ST_BIND(T)(T val) { return cast(ubyte)val >> 4; }
    auto ELF32_ST_TYPE(T)(T val) { return val & 0xf; }
    auto ELF32_ST_INFO(B, T)(B bind, T type) { return (bind << 4) + (type & 0xf); }
    alias ELF32_ST_BIND ELF64_ST_BIND;
    alias ELF32_ST_TYPE ELF64_ST_TYPE;
    alias ELF32_ST_INFO ELF64_ST_INFO;
}

enum STB_LOCAL  = 0;
enum STB_GLOBAL = 1;
enum STB_WEAK   = 2;
enum STB_NUM    = 3;
enum STB_LOPROC = 13;
enum STB_HIPROC = 15;

enum STT_NOTYPE  = 0;
enum STT_OBJECT  = 1;
enum STT_FUNC    = 2;
enum STT_SECTION = 3;
enum STT_FILE    = 4;
enum STT_COMMON  = 5;
enum STT_TLS     = 6;
enum STT_NUM     = 7;
enum STT_LOOS    = 10;
enum STT_HIOS    = 12;
enum STT_LOPROC  = 13;
enum STT_HIPROC  = 15;

extern (D)
{
    auto ELF32_ST_VISIBILITY(O)(O o) { return o & 0x07; }
    alias ELF32_ST_VISIBILITY ELF64_ST_VISIBILITY;
}

enum STV_DEFAULT   = 0;
enum STV_INTERNAL  = 1;
enum STV_HIDDEN    = 2;
enum STV_PROTECTED = 3;
enum STV_EXPORTED  = 4;
enum STV_SINGLETON = 5;
enum STV_ELIMINATE = 6;
enum STV_NUM       = 7;

struct Elf32_Rel
{
    Elf32_Addr    r_offset;
    Elf32_Word    r_info;
}

struct Elf32_Rela
{
    Elf32_Addr    r_offset;
    Elf32_Word    r_info;
    Elf32_Sword   r_addend;
}

struct Elf64_Rel
{
    Elf64_Addr    r_offset;
    Elf64_Xword   r_info;
}

struct Elf64_Rela
{
    Elf64_Addr    r_offset;
    Elf64_Xword   r_info;
    Elf64_Sxword  r_addend;
}

extern (D)
{
    auto ELF32_R_SYM(V)(V val) { return val >> 8; }
    auto ELF32_R_TYPE(V)(V val) { return val & 0xff; }
    auto ELF32_R_INFO(S, T)(S sym, T type) { return (sym << 8) + (type & 0xff); }

    auto ELF64_R_SYM(I)(I i) { return i >> 32; }
    auto ELF64_R_TYPE(I)(I i) { return i & 0xffffffff; }
    auto ELF64_R_INFO(S, T)(S sym, T type) { return (sym << 32) + (type); }

    auto ELF64_R_TYPE_DATA(I)(I i) { return (i << 32) >> 40; }
    auto ELF64_R_TYPE_ID(I)(I i) { return (i << 56) >> 56; }
    auto ELF64_R_TYPE_INFO(S, T)(S sym, T type) { return (sym <<8) + (type); }
}

enum GRP_COMDAT = 0x01;

struct Elf32_Nhdr
{
    Elf32_Word n_namesz;
    Elf32_Word n_descsz;
    Elf32_Word n_type;
}

struct Elf64_Nhdr
{
    Elf64_Word n_namesz;
    Elf64_Word n_descsz;
    Elf64_Word n_type;
}

struct Elf32_Move
{
    Elf32_Lword m_value;
    Elf32_Word  m_info;
    Elf32_Word  m_poffset;
    Elf32_Half  m_repeat;
    Elf32_Half  m_stride;
}

extern (D)
{
    auto ELF32_M_SYM(I)(I info) { return info >> 8; }
    auto ELF32_M_SIZE(I)(I info) { return cast(ubyte)info; }
    auto ELF32_M_INFO(S, SZ)(S sym, SZ size) { return (sym << 8) + cast(ubyte)size; }
}

struct Elf64_Move
{
    Elf64_Lword m_value;
    Elf64_Xword m_info;
    Elf64_Xword m_poffset;
    Elf64_Half  m_repeat;
    Elf64_Half  m_stride;
}

alias ELF32_M_SYM ELF64_M_SYM;
alias ELF32_M_SIZE ELF64_M_SIZE;
alias ELF32_M_INFO ELF64_M_INFO;

struct Elf32_Cap
{
    Elf32_Word  c_tag;
    union c_un
    {
        Elf32_Word  c_val;
        Elf32_Addr  c_ptr;
    }
}

alias Elf32_Word Elf32_Capinfo;
alias Elf32_Word Elf32_Capchain;


alias ELF32_M_SYM ELF32_C_SYM;
alias ELF32_M_SIZE ELF32_C_GROUP;
alias ELF32_M_INFO ELF32_C_INFO;

struct Elf64_Cap
{
    Elf64_Xword c_tag;
    union c_un
    {
        Elf64_Xword c_val;
        Elf64_Addr  c_ptr;
    }
}

alias Elf64_Xword Elf64_Capinfo;
alias Elf64_Word  Elf64_Capchain;

/*
 *  Macros to compose and decompose values for capabilities info.
 *
 *  sym = ELF64_C_SYM(info)
 *  grp = ELF64_C_GROUP(info)
 *  info = ELF64_C_INFO(sym, grp)
 */
extern (D)
{
    auto ELF64_C_SYM(I)(I info) { return info >> 32; }
    auto ELF64_C_GROUP(I)(I info) { return cast(Elf64_Word)info; }
    auto ELF64_C_INFO(S, G)(S sym, G grp) { return (sym << 32) + grp; }
}

enum CAPINFO_NONE    = 0;
enum CAPINFO_CURRENT = 1;
enum CAPINFO_NUM     = 2;

enum CAPCHAIN_NONE    = 0;
enum CAPCHAIN_CURRENT = 1;
enum CAPCHAIN_NUM     = 2;

enum CAPINFO_SUNW_GLOB = 0xff;

enum CA_SUNW_NULL = 0;
enum CA_SUNW_HW_1 = 1;
enum CA_SUNW_SF_1 = 2;
enum CA_SUNW_HW_2 = 3;
enum CA_SUNW_PLAT = 4;
enum CA_SUNW_MACH = 5;
enum CA_SUNW_ID   = 6;
enum CA_SUNW_NUM  = 7;

enum SF1_SUNW_FPKNWN = 0x001;
enum SF1_SUNW_FPUSED = 0x002;
enum SF1_SUNW_ADDR32 = 0x004;
enum SF1_SUNW_MASK   = 0x007;

enum NT_PRSTATUS   = 1;
enum NT_PRFPREG    = 2;
enum NT_PRPSINFO   = 3;
enum NT_PRXREG     = 4;
enum NT_PLATFORM   = 5;
enum NT_AUXV       = 6;
enum NT_GWINDOWS   = 7;
enum NT_ASRS       = 8;
enum NT_LDT        = 9;
enum NT_PSTATUS    = 10;
enum NT_PSINFO     = 13;
enum NT_PRCRED     = 14;
enum NT_UTSNAME    = 15;
enum NT_LWPSTATUS  = 16;
enum NT_LWPSINFO   = 17;
enum NT_PRPRIV     = 18;
enum NT_PRPRIVINFO = 19;
enum NT_CONTENT    = 20;
enum NT_ZONENAME   = 21;
enum NT_FDINFO     = 22;
enum NT_SPYMASTER  = 23;
enum NT_NUM        = 23;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elf_386.h, illumos sys/elf_386.h)
 */
module core.sys.solaris.sys.elf_386;

version (Solaris):
extern (C):
nothrow:

enum R_386_NONE         = 0;
enum R_386_32           = 1;
enum R_386_PC32         = 2;
enum R_386_GOT32        = 3;
enum R_386_PLT32        = 4;
enum R_386_COPY         = 5;
enum R_386_GLOB_DAT     = 6;
enum R_386_JMP_SLOT     = 7;
enum R_386_RELATIVE     = 8;
enum R_386_GOTOFF       = 9;
enum R_386_GOTPC        = 10;
enum R_386_32PLT        = 11;
enum R_386_TLS_GD_PLT   = 12;
enum R_386_TLS_LDM_PLT  = 13;
enum R_386_TLS_TPOFF    = 14;
enum R_386_TLS_IE       = 15;
enum R_386_TLS_GOTIE    = 16;
enum R_386_TLS_LE       = 17;
enum R_386_TLS_GD       = 18;
enum R_386_TLS_LDM      = 19;
enum R_386_16           = 20;
enum R_386_PC16         = 21;
enum R_386_8            = 22;
enum R_386_PC8          = 23;
enum R_386_UNKNOWN24    = 24;
enum R_386_UNKNOWN25    = 25;
enum R_386_UNKNOWN26    = 26;
enum R_386_UNKNOWN27    = 27;
enum R_386_UNKNOWN28    = 28;
enum R_386_UNKNOWN29    = 29;
enum R_386_UNKNOWN30    = 30;
enum R_386_UNKNOWN31    = 31;
enum R_386_TLS_LDO_32   = 32;
enum R_386_UNKNOWN33    = 33;
enum R_386_UNKNOWN34    = 34;
enum R_386_TLS_DTPMOD32 = 35;
enum R_386_TLS_DTPOFF32 = 36;
enum R_386_UNKNOWN37    = 37;
enum R_386_SIZE32       = 38;
enum R_386_NUM          = 39;

enum ELF_386_MAXPGSZ = 0x10000;

enum SHF_ORDERED = 0x40000000;
enum SHF_EXCLUDE = 0x80000000;

enum SHN_BEFORE = 0xff00;
enum SHN_AFTER  = 0xff01;

enum M_PLT_INSSIZE  = 6;
enum M_PLT_XNumber  = 1;
enum M_GOT_XDYNAMIC = 0;
enum M_GOT_XLINKMAP = 1;
enum M_GOT_XRTLD    = 2;
enum M_GOT_XNumber  = 3;

enum M32_WORD_ALIGN   = 4;
enum M32_PLT_ENTSIZE  = 16;
enum M32_PLT_ALIGN    = M32_WORD_ALIGN;
enum M32_GOT_ENTSIZE  = 4;
enum M32_PLT_RESERVSZ = (M_PLT_XNumber * M32_PLT_ENTSIZE);

version (_ELF64) {}
else
{
    enum M_WORD_ALIGN   = M32_WORD_ALIGN;
    enum M_PLT_ENTSIZE  = M32_PLT_ENTSIZE;
    enum M_PLT_ALIGN    = M32_PLT_ALIGN;
    enum M_PLT_RESERVSZ = M32_PLT_RESERVSZ;
    enum M_GOT_ENTSIZE  = M32_GOT_ENTSIZE;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elf_SPARC.h, illumos sys/elf_SPARC.h)
 */
module core.sys.solaris.sys.elf_SPARC;

version (Solaris):
extern (C):
nothrow:

enum EF_SPARC_32PLUS_MASK = 0xffff00;
enum EF_SPARC_32PLUS      = 0x000100;
enum EF_SPARC_EXT_MASK    = 0xffff00;
enum EF_SPARC_SUN_US1     = 0x000200;
enum EF_SPARC_HAL_R1      = 0x000400;
enum EF_SPARC_SUN_US3     = 0x000800;

enum EF_SPARCV9_MM  = 0x3;
enum EF_SPARCV9_TSO = 0x0;
enum EF_SPARCV9_PSO = 0x1;
enum EF_SPARCV9_RMO = 0x2;

enum R_SPARC_NONE             = 0;
enum R_SPARC_8                = 1;
enum R_SPARC_16               = 2;
enum R_SPARC_32               = 3;
enum R_SPARC_DISP8            = 4;
enum R_SPARC_DISP16           = 5;
enum R_SPARC_DISP32           = 6;
enum R_SPARC_WDISP30          = 7;
enum R_SPARC_WDISP22          = 8;
enum R_SPARC_HI22             = 9;
enum R_SPARC_22               = 10;
enum R_SPARC_13               = 11;
enum R_SPARC_LO10             = 12;
enum R_SPARC_GOT10            = 13;
enum R_SPARC_GOT13            = 14;
enum R_SPARC_GOT22            = 15;
enum R_SPARC_PC10             = 16;
enum R_SPARC_PC22             = 17;
enum R_SPARC_WPLT30           = 18;
enum R_SPARC_COPY             = 19;
enum R_SPARC_GLOB_DAT         = 20;
enum R_SPARC_JMP_SLOT         = 21;
enum R_SPARC_RELATIVE         = 22;
enum R_SPARC_UA32             = 23;
enum R_SPARC_PLT32            = 24;
enum R_SPARC_HIPLT22          = 25;
enum R_SPARC_LOPLT10          = 26;
enum R_SPARC_PCPLT32          = 27;
enum R_SPARC_PCPLT22          = 28;
enum R_SPARC_PCPLT10          = 29;
enum R_SPARC_10               = 30;
enum R_SPARC_11               = 31;
enum R_SPARC_64               = 32;
enum R_SPARC_OLO10            = 33;
enum R_SPARC_HH22             = 34;
enum R_SPARC_HM10             = 35;
enum R_SPARC_LM22             = 36;
enum R_SPARC_PC_HH22          = 37;
enum R_SPARC_PC_HM10          = 38;
enum R_SPARC_PC_LM22          = 39;
enum R_SPARC_WDISP16          = 40;
enum R_SPARC_WDISP19          = 41;
enum R_SPARC_GLOB_JMP         = 42;
enum R_SPARC_7                = 43;
enum R_SPARC_5                = 44;
enum R_SPARC_6                = 45;
enum R_SPARC_DISP64           = 46;
enum R_SPARC_PLT64            = 47;
enum R_SPARC_HIX22            = 48;
enum R_SPARC_LOX10            = 49;
enum R_SPARC_H44              = 50;
enum R_SPARC_M44              = 51;
enum R_SPARC_L44              = 52;
enum R_SPARC_REGISTER         = 53;
enum R_SPARC_UA64             = 54;
enum R_SPARC_UA16             = 55;
enum R_SPARC_TLS_GD_HI22      = 56;
enum R_SPARC_TLS_GD_LO10      = 57;
enum R_SPARC_TLS_GD_ADD       = 58;
enum R_SPARC_TLS_GD_CALL      = 59;
enum R_SPARC_TLS_LDM_HI22     = 60;
enum R_SPARC_TLS_LDM_LO10     = 61;
enum R_SPARC_TLS_LDM_ADD      = 62;
enum R_SPARC_TLS_LDM_CALL     = 63;
enum R_SPARC_TLS_LDO_HIX22    = 64;
enum R_SPARC_TLS_LDO_LOX10    = 65;
enum R_SPARC_TLS_LDO_ADD      = 66;
enum R_SPARC_TLS_IE_HI22      = 67;
enum R_SPARC_TLS_IE_LO10      = 68;
enum R_SPARC_TLS_IE_LD        = 69;
enum R_SPARC_TLS_IE_LDX       = 70;
enum R_SPARC_TLS_IE_ADD       = 71;
enum R_SPARC_TLS_LE_HIX22     = 72;
enum R_SPARC_TLS_LE_LOX10     = 73;
enum R_SPARC_TLS_DTPMOD32     = 74;
enum R_SPARC_TLS_DTPMOD64     = 75;
enum R_SPARC_TLS_DTPOFF32     = 76;
enum R_SPARC_TLS_DTPOFF64     = 77;
enum R_SPARC_TLS_TPOFF32      = 78;
enum R_SPARC_TLS_TPOFF64      = 79;
enum R_SPARC_GOTDATA_HIX22    = 80;
enum R_SPARC_GOTDATA_LOX10    = 81;
enum R_SPARC_GOTDATA_OP_HIX22 = 82;
enum R_SPARC_GOTDATA_OP_LOX10 = 83;
enum R_SPARC_GOTDATA_OP       = 84;
enum R_SPARC_H34              = 85;
enum R_SPARC_SIZE32           = 86;
enum R_SPARC_SIZE64           = 87;
enum R_SPARC_NUM              = 88;

enum R_SPARC_L34 = R_SPARC_L44;

enum ELF_SPARC_MAXPGSZ   = 0x10000;
enum ELF_SPARCV9_MAXPGSZ = 0x100000;

enum SHT_SPARC_GOTDATA = 0x70000000;

enum SHF_ORDERED = 0x40000000;
enum SHF_EXCLUDE = 0x80000000;

enum SHN_BEFORE = 0xff00;
enum SHN_AFTER  =  0xff01;

enum STT_SPARC_REGISTER = 13;

enum DT_SPARC_REGISTER = 0x70000001;

enum STO_SPARC_REGISTER_G1 = 0x1;
enum STO_SPARC_REGISTER_G2 = 0x2;
enum STO_SPARC_REGISTER_G3 = 0x3;
enum STO_SPARC_REGISTER_G4 = 0x4;
enum STO_SPARC_REGISTER_G5 = 0x5;
enum STO_SPARC_REGISTER_G6 = 0x6;
enum STO_SPARC_REGISTER_G7 = 0x7;

enum M_PLT_INSSIZE  = 4;
enum M_PLT_XNumber  = 4;
enum M_GOT_XDYNAMIC = 0;
enum M_GOT_XNumber  = 1;

enum M32_WORD_ALIGN   = 4;
enum M32_PLT_ENTSIZE  = 12;
enum M32_PLT_ALIGN    = M_WORD_ALIGN;
enum M32_GOT_ENTSIZE  = 4;
enum M32_GOT_MAXSMALL = 2048;
enum M32_PLT_RESERVSZ = (M_PLT_XNumber * M32_PLT_ENTSIZE);

enum M64_WORD_ALIGN   = 8;
enum M64_PLT_ENTSIZE  = 32;
enum M64_PLT_ALIGN    = 256;
enum M64_GOT_ENTSIZE  = 8;
enum M64_GOT_MAXSMALL = 1024;
enum M64_PLT_RESERVSZ = (M_PLT_XNumber * M64_PLT_ENTSIZE);

enum M64_PLT_NEARPLTS = 0x8000;
enum M64_PLT_FENTSIZE = 24;
enum M64_PLT_PSIZE    = 8;
enum M64_PLT_FBLKCNTS = 160;
enum M64_PLT_FBLOCKSZ = (M64_PLT_FBLKCNTS * M64_PLT_ENTSIZE);

version (_ELF64)
{
    enum M_WORD_ALIGN   = M64_WORD_ALIGN;
    enum M_PLT_ENTSIZE  = M64_PLT_ENTSIZE;
    enum M_PLT_ALIGN    = M64_PLT_ALIGN;
    enum M_PLT_RESERVSZ = M64_PLT_RESERVSZ;
    enum M_GOT_ENTSIZE  = M64_GOT_ENTSIZE;
    enum M_GOT_MAXSMALL = M64_GOT_MAXSMALL;
}
else
{
    enum M_WORD_ALIGN   = M32_WORD_ALIGN;
    enum M_PLT_ENTSIZE  = M32_PLT_ENTSIZE;
    enum M_PLT_ALIGN    = M32_PLT_ALIGN;
    enum M_PLT_RESERVSZ = M32_PLT_RESERVSZ;
    enum M_GOT_ENTSIZE  = M32_GOT_ENTSIZE;
    enum M_GOT_MAXSMALL = M32_GOT_MAXSMALL;
}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elf_amd64.h, illumos sys/elf_amd64.h)
 */
module core.sys.solaris.sys.elf_amd64;

version (Solaris):
extern (C):
nothrow:

public import core.sys.solaris.sys.elf_386;

enum R_AMD64_NONE       = 0;
enum R_AMD64_64         = 1;
enum R_AMD64_PC32       = 2;
enum R_AMD64_GOT32      = 3;
enum R_AMD64_PLT32      = 4;
enum R_AMD64_COPY       = 5;
enum R_AMD64_GLOB_DAT   = 6;
enum R_AMD64_JUMP_SLOT  = 7;
enum R_AMD64_RELATIVE   = 8;
enum R_AMD64_GOTPCREL   = 9;
enum R_AMD64_32         = 10;
enum R_AMD64_32S        = 11;
enum R_AMD64_16         = 12;
enum R_AMD64_PC16       = 13;
enum R_AMD64_8          = 14;
enum R_AMD64_PC8        = 15;
enum R_AMD64_DTPMOD64   = 16;
enum R_AMD64_DTPOFF64   = 17;
enum R_AMD64_TPOFF64    = 18;
enum R_AMD64_TLSGD      = 19;
enum R_AMD64_TLSLD      = 20;
enum R_AMD64_DTPOFF32   = 21;
enum R_AMD64_GOTTPOFF   = 22;
enum R_AMD64_TPOFF32    = 23;
enum R_AMD64_PC64       = 24;
enum R_AMD64_GOTOFF64   = 25;
enum R_AMD64_GOTPC32    = 26;
enum R_AMD64_GOT64      = 27;
enum R_AMD64_GOTPCREL64 = 28;
enum R_AMD64_GOTPC64    = 29;
enum R_AMD64_GOTPLT64   = 30;
enum R_AMD64_PLTOFF64   = 31;
enum R_AMD64_SIZE32     = 32;
enum R_AMD64_SIZE64     = 33;
enum R_AMD64_NUM        = 34;


enum R_X86_64_NONE       = R_AMD64_NONE;
enum R_X86_64_64         = R_AMD64_64;
enum R_X86_64_PC32       = R_AMD64_PC32;
enum R_X86_64_GOT32      = R_AMD64_GOT32;
enum R_X86_64_PLT32      = R_AMD64_PLT32;
enum R_X86_64_COPY       = R_AMD64_COPY;
enum R_X86_64_GLOB_DAT   = R_AMD64_GLOB_DAT;
enum R_X86_64_JUMP_SLOT  = R_AMD64_JUMP_SLOT;
enum R_X86_64_RELATIVE   = R_AMD64_RELATIVE;
enum R_X86_64_GOTPCREL   = R_AMD64_GOTPCREL;
enum R_X86_64_32         = R_AMD64_32;
enum R_X86_64_32S        = R_AMD64_32S;
enum R_X86_64_16         = R_AMD64_16;
enum R_X86_64_PC16       = R_AMD64_PC16;
enum R_X86_64_8          = R_AMD64_8;
enum R_X86_64_PC8        = R_AMD64_PC8;
enum R_X86_64_DTPMOD64   = R_AMD64_DTPMOD64;
enum R_X86_64_DTPOFF64   = R_AMD64_DTPOFF64;
enum R_X86_64_TPOFF64    = R_AMD64_TPOFF64;
enum R_X86_64_TLSGD      = R_AMD64_TLSGD;
enum R_X86_64_TLSLD      = R_AMD64_TLSLD;
enum R_X86_64_DTPOFF32   = R_AMD64_DTPOFF32;
enum R_X86_64_GOTTPOFF   = R_AMD64_GOTTPOFF;
enum R_X86_64_TPOFF32    = R_AMD64_TPOFF32;
enum R_X86_64_PC64       = R_AMD64_PC64;
enum R_X86_64_GOTPC32    = R_AMD64_GOTPC32;
enum R_X86_64_GOTOFF64   = R_AMD64_GOTOFF64;
enum R_X86_64_GOT64      = R_AMD64_GOT64;
enum R_X86_64_GOTPCREL64 = R_AMD64_GOTPCREL64;
enum R_X86_64_GOTPC64    = R_AMD64_GOTPC64;
enum R_X86_64_GOTPLT64   = R_AMD64_GOTPLT64;
enum R_X86_64_PLTOFF64   = R_AMD64_PLTOFF64;
enum R_X86_64_SIZE32     = R_AMD64_SIZE32;
enum R_X86_64_SIZE64     = R_AMD64_SIZE64;
enum R_X86_64_NUM        = R_AMD64_NUM;

enum ELF_AMD64_MAXPGSZ = 0x100000;

enum SHT_AMD64_UNWIND   = 0x70000001;
enum SHT_X86_64_UNWIND  = SHT_AMD64_UNWIND;

enum SHF_AMD64_LARGE  = 0x10000000;
enum SHF_X86_64_LARGE = SHF_AMD64_LARGE;

enum SHN_AMD64_LCOMMON  = 0xff02;
enum SHN_X86_64_LCOMMON = SHN_AMD64_LCOMMON;

enum M64_WORD_ALIGN   = 8;
enum M64_PLT_ENTSIZE  = M32_PLT_ENTSIZE;
enum M64_PLT_ALIGN    = M64_WORD_ALIGN;
enum M64_GOT_ENTSIZE  = 8;
enum M64_PLT_RESERVSZ = M32_PLT_RESERVSZ;

version (_ELF64)
{
    enum M_WORD_ALIGN   = M64_WORD_ALIGN;
    enum M_PLT_ENTSIZE  = M64_PLT_ENTSIZE;
    enum M_PLT_ALIGN    = M64_PLT_ALIGN;
    enum M_PLT_RESERVSZ = M64_PLT_RESERVSZ;
    enum M_GOT_ENTSIZE  = M64_GOT_ENTSIZE;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elf_notes.h, illumos sys/elf_notes.h)
 */
module core.sys.solaris.sys.elf_notes;

version (Solaris):
extern (C):
nothrow:

enum ELF_NOTE_SOLARIS = "SUNW Solaris";

enum ELF_NOTE_PAGESIZE_HINT = 1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/elftypes.h, illumos sys/elftypes.h)
 */
module core.sys.solaris.sys.elftypes;

version (Solaris):
extern (C):
nothrow:

import core.stdc.stdint;

alias uint32_t Elf32_Addr;
alias uint16_t Elf32_Half;
alias uint32_t Elf32_Off;
alias int32_t  Elf32_Sword;
alias uint32_t Elf32_Word;

alias uint64_t Elf64_Addr;
alias uint16_t Elf64_Half;
alias uint64_t Elf64_Off;
alias int32_t  Elf64_Sword;
alias int64_t  Elf64_Sxword;
alias uint32_t Elf64_Word;
alias uint64_t Elf64_Xword;
alias uint64_t Elf64_Lword;
alias uint64_t Elf32_Lword;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * D header file for Solaris.
 *
 * $(LINK2 http://src.illumos.org/source/xref/illumos-gate/usr/src/uts/common/sys/link.h, illumos sys/link.h)
 */
module core.sys.solaris.sys.link;

version (Solaris):
extern (C):
nothrow:

public import core.sys.solaris.sys.elftypes;
import core.stdc.config;

struct Elf32_Dyn
{
    Elf32_Sword d_tag;
    union _d_un
    {
        Elf32_Word d_val;
        Elf32_Addr d_ptr;
        Elf32_Off  d_off;
    } _d_un d_un;
}

struct Elf64_Dyn
{
    Elf64_Xword d_tag;
    union _d_un
    {
        Elf64_Xword d_val;
        Elf64_Addr  d_ptr;
    } _d_un d_un;
}

enum DT_NULL         = 0;
enum DT_NEEDED       = 1;
enum DT_PLTRELSZ     = 2;
enum DT_PLTGOT       = 3;
enum DT_HASH         = 4;
enum DT_STRTAB       = 5;
enum DT_SYMTAB       = 6;
enum DT_RELA         = 7;
enum DT_RELASZ       = 8;
enum DT_RELAENT      = 9;
enum DT_STRSZ        = 10;
enum DT_SYMENT       = 11;
enum DT_INIT         = 12;
enum DT_FINI         = 13;
enum DT_SONAME       = 14;
enum DT_RPATH        = 15;
enum DT_SYMBOLIC     = 16;
enum DT_REL          = 17;
enum DT_RELSZ        = 18;
enum DT_RELENT       = 19;
enum DT_PLTREL       = 20;
enum DT_DEBUG        = 21;
enum DT_TEXTREL      = 22;
enum DT_JMPREL       = 23;
enum DT_BIND_NOW     = 24;
enum DT_INIT_ARRAY   = 25;
enum DT_FINI_ARRAY   = 26;
enum DT_INIT_ARRAYSZ = 27;
enum DT_FINI_ARRAYSZ = 28;
enum DT_RUNPATH      = 29;
enum DT_FLAGS        = 30;

enum DT_ENCODING        = 32;
enum DT_PREINIT_ARRAY   = 32;
enum DT_PREINIT_ARRAYSZ = 33;

enum DT_MAXPOSTAGS = 34;

enum DT_LOOS           = 0x6000000d;
enum DT_SUNW_AUXILIARY = 0x6000000d;
enum DT_SUNW_RTLDINF   = 0x6000000e;
enum DT_SUNW_FILTER    = 0x6000000f;
enum DT_SUNW_CAP       = 0x60000010;
enum DT_SUNW_SYMTAB    = 0x60000011;
enum DT_SUNW_SYMSZ     = 0x60000012;

enum DT_SUNW_ENCODING    = 0x60000013;
enum DT_SUNW_SORTENT     = 0x60000013;
enum DT_SUNW_SYMSORT     = 0x60000014;
enum DT_SUNW_SYMSORTSZ   = 0x60000015;
enum DT_SUNW_TLSSORT     = 0x60000016;
enum DT_SUNW_TLSSORTSZ   = 0x60000017;
enum DT_SUNW_CAPINFO     = 0x60000018;
enum DT_SUNW_STRPAD      = 0x60000019;
enum DT_SUNW_CAPCHAIN    = 0x6000001a;
enum DT_SUNW_LDMACH      = 0x6000001b;
enum DT_SUNW_CAPCHAINENT = 0x6000001d;
enum DT_SUNW_CAPCHAINSZ  = 0x6000001f;

enum DT_HIOS = 0x6ffff000;

enum DT_DEPRECATED_SPARC_REGISTER = 0x7000001;

enum DT_VALRNGLO = 0x6ffffd00;

enum DT_GNU_PRELINKED  = 0x6ffffdf5;
enum DT_GNU_CONFLICTSZ = 0x6ffffdf6;
enum DT_GNU_LIBLISTSZ  = 0x6ffffdf7;
enum DT_CHECKSUM       = 0x6ffffdf8;
enum DT_PLTPADSZ       = 0x6ffffdf9;
enum DT_MOVEENT        = 0x6ffffdfa;
enum DT_MOVESZ         = 0x6ffffdfb;
enum DT_FEATURE_1      = 0x6ffffdfc;
enum DT_POSFLAG_1      = 0x6ffffdfd;
enum DT_SYMINSZ        = 0x6ffffdfe;
enum DT_SYMINENT       = 0x6ffffdff;
enum DT_VALRNGHI       = 0x6ffffdff;

enum DT_ADDRRNGLO = 0x6ffffe00;

enum DT_GNU_HASH     = 0x6ffffef5;
enum DT_TLSDESC_PLT  = 0x6ffffef6;
enum DT_TLSDESC_GOT  = 0x6ffffef7;
enum DT_GNU_CONFLICT = 0x6ffffef8;
enum DT_GNU_LIBLIST  = 0x6ffffef9;

enum DT_CONFIG    = 0x6ffffefa;
enum DT_DEPAUDIT  = 0x6ffffefb;
enum DT_AUDIT     = 0x6ffffefc;
enum DT_PLTPAD    = 0x6ffffefd;
enum DT_MOVETAB   = 0x6ffffefe;
enum DT_SYMINFO   = 0x6ffffeff;
enum DT_ADDRRNGHI = 0x6ffffeff;

enum DT_VERSYM = 0x6ffffff0;

enum DT_RELACOUNT  = 0x6ffffff9;
enum DT_RELCOUNT   = 0x6ffffffa;
enum DT_FLAGS_1    = 0x6ffffffb;
enum DT_VERDEF     = 0x6ffffffc;
enum DT_VERDEFNUM  = 0x6ffffffd;
enum DT_VERNEED    = 0x6ffffffe;
enum DT_VERNEEDNUM = 0x6fffffff;

enum DT_LOPROC    = 0x70000000;
enum DT_AUXILIARY = 0x7ffffffd;
enum DT_USED      = 0x7ffffffe;
enum DT_FILTER    = 0x7fffffff;
enum DT_HIPROC    = 0x7fffffff;

enum DF_ORIGIN     = 0x00000001;
enum DF_SYMBOLIC   = 0x00000002;
enum DF_TEXTREL    = 0x00000004;
enum DF_BIND_NOW   = 0x00000008;
enum DF_STATIC_TLS = 0x00000010;

enum DF_P1_LAZYLOAD  = 0x00000001;
enum DF_P1_GROUPPERM = 0x00000002;
enum DF_P1_DEFERRED  = 0x00000004;

enum DF_1_NOW        = 0x00000001;
enum DF_1_GLOBAL     = 0x00000002;
enum DF_1_GROUP      = 0x00000004;
enum DF_1_NODELETE   = 0x00000008;
