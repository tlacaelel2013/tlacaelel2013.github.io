= -1,
    CD_LBSELCHANGE,
    CD_LBSELSUB,
    CD_LBSELADD
}

enum WORD DN_DEFAULTPRN = 1;

/+
// Both MinGW and the windows docs indicate that there are macros for the send messages
// the controls. These seem to be totally unnecessary -- and at least one of MinGW or
// Windows Docs is buggy!

int CommDlg_OpenSave_GetSpec(HWND hWndControl, LPARAM lparam, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_GETSPEC, wParam, lParam);
}

int CommDlg_OpenSave_GetFilePath(HWND hWndControl, LPARAM lparam, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_GETFILEPATH, wParam, lParam);
}

int CommDlg_OpenSave_GetFolderPath(HWND hWndControl, LPARAM lparam, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_GETFOLDERPATH, wParam, lParam);
}

int CommDlg_OpenSave_GetFolderIDList(HWND hWndControl, LPARAM lparam, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_GETFOLDERIDLIST, wParam, lParam);
}

void CommDlg_OpenSave_SetControlText(HWND hWndControl, LPARAM lparam, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_SETCONTROLTEXT, wParam, lParam);
}

void CommDlg_OpenSave_HideControl(HWND hWndControl, WPARAM wParam) {
    return SendMessage(hWndControl, CDM_HIDECONTROL, wParam, 0);
}

void CommDlg_OpenSave_SetDefExt(HWND hWndControl, TCHAR* lparam) {
    return SendMessage(hWndControl, CDM_SETCONTROLTEXT, 0, cast(LPARAM)lParam);
}

// These aliases seem even more unnecessary
alias CommDlg_OpenSave_GetSpec
    CommDlg_OpenSave_GetSpecA, CommDlg_OpenSave_GetSpecW;
alias CommDlg_OpenSave_GetFilePath
    CommDlg_OpenSave_GetFilePathA, CommDlg_OpenSave_GetFilePathW;
alias CommDlg_OpenSave_GetFolderPath
    CommDlg_OpenSave_GetFolderPathA, CommDlg_OpenSave_GetFolderPathW;
+/

// Callbacks.
extern(Windows) {
alias UINT_PTR function (HWND, UINT, WPARAM, LPARAM) nothrow
    LPCCHOOKPROC, LPCFHOOKPROC, LPFRHOOKPROC, LPOFNHOOKPROC,
    LPPAGEPAINTHOOK, LPPAGESETUPHOOK, LPSETUPHOOKPROC, LPPRINTHOOKPROC;
}

//align (1): // 1 in Win32, default in Win64

struct CHOOSECOLORA {
    DWORD        lStructSize = CHOOSECOLORA.sizeof;
    HWND         hwndOwner;
    HWND         hInstance;
    COLORREF     rgbResult;
    COLORREF*    lpCustColors;
    DWORD        Flags;
    LPARAM       lCustData;
    LPCCHOOKPROC lpfnHook;
    LPCSTR       lpTemplateName;
}
alias CHOOSECOLORA* LPCHOOSECOLORA;

struct CHOOSECOLORW {
    DWORD        lStructSize = CHOOSECOLORW.sizeof;
    HWND         hwndOwner;
    HWND         hInstance;
    COLORREF     rgbResult;
    COLORREF*    lpCustColors;
    DWORD        Flags;
    LPARAM       lCustData;
    LPCCHOOKPROC lpfnHook;
    LPCWSTR      lpTemplateName;
}
alias CHOOSECOLORW* LPCHOOSECOLORW;

struct CHOOSEFONTA {
    DWORD        lStructSize = CHOOSEFONTA.sizeof;
    HWND         hwndOwner;
    HDC          hDC;
    LPLOGFONTA   lpLogFont;
    INT          iPointSize;
    DWORD        Flags;
    DWORD        rgbColors;
    LPARAM       lCustData;
    LPCFHOOKPROC lpfnHook;
    LPCSTR       lpTemplateName;
    HINSTANCE    hInstance;
    LPSTR        lpszStyle;
    WORD         nFontType;
    WORD         ___MISSING_ALIGNMENT__;
    INT          nSizeMin;
    INT          nSizeMax;
}
alias CHOOSEFONTA* LPCHOOSEFONTA;

struct CHOOSEFONTW {
    DWORD        lStructSize = CHOOSEFONTW.sizeof;
    HWND         hwndOwner;
    HDC          hDC;
    LPLOGFONTW   lpLogFont;
    INT          iPointSize;
    DWORD        Flags;
    DWORD        rgbColors;
    LPARAM       lCustData;
    LPCFHOOKPROC lpfnHook;
    LPCWSTR      lpTemplateName;
    HINSTANCE    hInstance;
    LPWSTR       lpszStyle;
    WORD         nFontType;
    WORD         ___MISSING_ALIGNMENT__;
    INT          nSizeMin;
    INT          nSizeMax;
}
alias CHOOSEFONTW* LPCHOOSEFONTW;

struct DEVNAMES {
    WORD wDriverOffset;
    WORD wDeviceOffset;
    WORD wOutputOffset;
    WORD wDefault;
}
alias DEVNAMES* LPDEVNAMES;

struct FINDREPLACEA {
    DWORD        lStructSize = FINDREPLACEA.sizeof;
    HWND         hwndOwner;
    HINSTANCE    hInstance;
    DWORD        Flags;
    LPSTR        lpstrFindWhat;
    LPSTR        lpstrReplaceWith;
    WORD         wFindWhatLen;
    WORD         wReplaceWithLen;
    LPARAM       lCustData;
    LPFRHOOKPROC lpfnHook;
    LPCSTR       lpTemplateName;
}
alias FINDREPLACEA* LPFINDREPLACEA;

struct FINDREPLACEW {
    DWORD        lStructSize = FINDREPLACEW.sizeof;
    HWND         hwndOwner;
    HINSTANCE    hInstance;
    DWORD        Flags;
    LPWSTR       lpstrFindWhat;
    LPWSTR       lpstrReplaceWith;
    WORD         wFindWhatLen;
    WORD         wReplaceWithLen;
    LPARAM       lCustData;
    LPFRHOOKPROC lpfnHook;
    LPCWSTR      lpTemplateName;
}
alias FINDREPLACEW* LPFINDREPLACEW;

struct OPENFILENAMEA {
    DWORD         lStructSize = OPENFILENAMEA.sizeof;
    HWND          hwndOwner;
    HINSTANCE     hInstance;
    LPCSTR        lpstrFilter;
    LPSTR         lpstrCustomFilter;
    DWORD         nMaxCustFilter;
    DWORD         nFilterIndex;
    LPSTR         lpstrFile;
    DWORD         nMaxFile;
    LPSTR         lpstrFileTitle;
    DWORD         nMaxFileTitle;
    LPCSTR        lpstrInitialDir;
    LPCSTR        lpstrTitle;
    DWORD         Flags;
    WORD          nFileOffset;
    WORD          nFileExtension;
    LPCSTR        lpstrDefExt;
    LPARAM        lCustData;
    LPOFNHOOKPROC lpfnHook;
    LPCSTR        lpTemplateName;

    //static if (_WIN32_WINNT >= 0x500) {
        void          *pvReserved;
        DWORD         dwReserved;
        DWORD         FlagsEx;
    //}
}
alias OPENFILENAMEA* LPOPENFILENAMEA;

struct OPENFILENAMEW {
    DWORD         lStructSize = OPENFILENAMEW.sizeof;
    HWND          hwndOwner;
    HINSTANCE     hInstance;
    LPCWSTR       lpstrFilter;
    LPWSTR        lpstrCustomFilter;
    DWORD         nMaxCustFilter;
    DWORD         nFilterIndex;
    LPWSTR        lpstrFile;
    DWORD         nMaxFile;
    LPWSTR        lpstrFileTitle;
    DWORD         nMaxFileTitle;
    LPCWSTR       lpstrInitialDir;
    LPCWSTR       lpstrTitle;
    DWORD         Flags;
    WORD          nFileOffset;
    WORD          nFileExtension;
    LPCWSTR       lpstrDefExt;
    LPARAM        lCustData;
    LPOFNHOOKPROC lpfnHook;
    LPCWSTR       lpTemplateName;

    //static if (_WIN32_WINNT >= 0x500) {
        void          *pvReserved;
        DWORD         dwReserved;
        DWORD         FlagsEx;
    //}
}
alias OPENFILENAMEW* LPOPENFILENAMEW;

enum size_t OPENFILENAME_SIZE_VERSION_400 = 76;

struct OFNOTIFYA {
    NMHDR           hdr;
    LPOPENFILENAMEA lpOFN;
    LPSTR           pszFile;
}
alias OFNOTIFYA* LPOFNOTIFYA;

struct OFNOTIFYW {
    NMHDR           hdr;
    LPOPENFILENAMEW lpOFN;
    LPWSTR          pszFile;
}
alias OFNOTIFYW* LPOFNOTIFYW;

struct PAGESETUPDLGA {
    DWORD           lStructSize = PAGESETUPDLGA.sizeof;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCSTR          lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
}
alias PAGESETUPDLGA* LPPAGESETUPDLGA;

struct PAGESETUPDLGW {
    DWORD           lStructSize = PAGESETUPDLGW.sizeof;
    HWND            hwndOwner;
    HGLOBAL         hDevMode;
    HGLOBAL         hDevNames;
    DWORD           Flags;
    POINT           ptPaperSize;
    RECT            rtMinMargin;
    RECT            rtMargin;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPAGESETUPHOOK lpfnPageSetupHook;
    LPPAGEPAINTHOOK lpfnPagePaintHook;
    LPCWSTR         lpPageSetupTemplateName;
    HGLOBAL         hPageSetupTemplate;
}
alias PAGESETUPDLGW* LPPAGESETUPDLGW;

align (1) struct PRINTDLGA {
align(1):
    DWORD           lStructSize = PRINTDLGA.sizeof;
    version (Win64)
        DWORD       padding1;
    HWND            hwndOwner;
    HANDLE          hDevMode;
    HANDLE          hDevNames;
    HDC             hDC;
    DWORD           Flags;
    WORD            nFromPage;
    WORD            nToPage;
    WORD            nMinPage;
    WORD            nMaxPage;
    WORD            nCopies;
    version (Win64)
        WORD        padding2;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPRINTHOOKPROC lpfnPrintHook;
    LPSETUPHOOKPROC lpfnSetupHook;
    LPCSTR          lpPrintTemplateName;
    LPCSTR          lpSetupTemplateName;
    HANDLE          hPrintTemplate;
    HANDLE          hSetupTemplate;
}
alias PRINTDLGA* LPPRINTDLGA;

align (1) struct PRINTDLGW {
align(1):
    DWORD           lStructSize = PRINTDLGW.sizeof;
    version (Win64)
        DWORD       padding1;
    HWND            hwndOwner;
    HANDLE          hDevMode;
    HANDLE          hDevNames;
    HDC             hDC;
    DWORD           Flags;
    WORD            nFromPage;
    WORD            nToPage;
    WORD            nMinPage;
    WORD            nMaxPage;
    WORD            nCopies;
    version (Win64)
        WORD        padding2;
    HINSTANCE       hInstance;
    LPARAM          lCustData;
    LPPRINTHOOKPROC lpfnPrintHook;
    LPSETUPHOOKPROC lpfnSetupHook;
    LPCWSTR         lpPrintTemplateName;
    LPCWSTR         lpSetupTemplateName;
    HANDLE          hPrintTemplate;
    HANDLE          hSetupTemplate;
}
alias PRINTDLGW* LPPRINTDLGW;

//static if (_WIN32_WINNT >= 0x500) {
    import core.sys.windows.unknwn; // for LPUNKNOWN
    import core.sys.windows.prsht;  // for HPROPSHEETPAGE

    struct PRINTPAGERANGE {
        DWORD  nFromPage;
        DWORD  nToPage;
    }
    alias PRINTPAGERANGE* LPPRINTPAGERANGE;

    struct PRINTDLGEXA {
        DWORD            lStructSize = PRINTDLGEXA.sizeof;
        HWND             hwndOwner;
        HGLOBAL          hDevMode;
        HGLOBAL          hDevNames;
        HDC              hDC;
        DWORD            Flags;
        DWORD            Flags2;
        DWORD            ExclusionFlags;
        DWORD            nPageRanges;
        DWORD            nMaxPageRanges;
        LPPRINTPAGERANGE lpPageRanges;
        DWORD            nMinPage;
        DWORD            nMaxPage;
        DWORD            nCopies;
        HINSTANCE        hInstance;
        LPCSTR           lpPrintTemplateName;
        LPUNKNOWN        lpCallback;
        DWORD            nPropertyPages;
        HPROPSHEETPAGE*  lphPropertyPages;
        DWORD            nStartPage;
        DWORD            dwResultAction;
    }
    alias PRINTDLGEXA* LPPRINTDLGEXA;

    struct PRINTDLGEXW {
        DWORD            lStructSize = PRINTDLGEXW.sizeof;
        HWND             hwndOwner;
        HGLOBAL          hDevMode;
        HGLOBAL          hDevNames;
        HDC              hDC;
        DWORD            Flags;
        DWORD            Flags2;
        DWORD            ExclusionFlags;
        DWORD            nPageRanges;
        DWORD            nMaxPageRanges;
        LPPRINTPAGERANGE lpPageRanges;
        DWORD            nMinPage;
        DWORD            nMaxPage;
        DWORD            nCopies;
        HINSTANCE        hInstance;
        LPCWSTR          lpPrintTemplateName;
        LPUNKNOWN        lpCallback;
        DWORD            nPropertyPages;
        HPROPSHEETPAGE*  lphPropertyPages;
        DWORD            nStartPage;
        DWORD            dwResultAction;
    }
    alias PRINTDLGEXW* LPPRINTDLGEXW;

//} // _WIN32_WINNT >= 0x500

extern (Windows) nothrow @nogc {
    BOOL ChooseColorA(LPCHOOSECOLORA);
    BOOL ChooseColorW(LPCHOOSECOLORW);
    BOOL ChooseFontA(LPCHOOSEFONTA);
    BOOL ChooseFontW(LPCHOOSEFONTW);
    DWORD CommDlgExtendedError();
    HWND FindTextA(LPFINDREPLACEA);
    HWND FindTextW(LPFINDREPLACEW);
    short GetFileTitleA(LPCSTR, LPSTR, WORD);
    short GetFileTitleW(LPCWSTR, LPWSTR, WORD);
    BOOL GetOpenFileNameA(LPOPENFILENAMEA);
    BOOL GetOpenFileNameW(LPOPENFILENAMEW);
    BOOL GetSaveFileNameA(LPOPENFILENAMEA);
    BOOL GetSaveFileNameW(LPOPENFILENAMEW);
    BOOL PageSetupDlgA(LPPAGESETUPDLGA);
    BOOL PageSetupDlgW(LPPAGESETUPDLGW);
    BOOL PrintDlgA(LPPRINTDLGA);
    BOOL PrintDlgW(LPPRINTDLGW);
    HWND ReplaceTextA(LPFINDREPLACEA);
    HWND ReplaceTextW(LPFINDREPLACEW);

    //static if (_WIN32_WINNT >= 0x500) {
        HRESULT PrintDlgExA(LPPRINTDLGEXA);
        HRESULT PrintDlgExW(LPPRINTDLGEXW);
    //}
}

version (Unicode) {
    alias CHOOSECOLORW CHOOSECOLOR;
    alias CHOOSEFONTW CHOOSEFONT;
    alias FINDREPLACEW FINDREPLACE;
    alias OPENFILENAMEW OPENFILENAME;
    alias OFNOTIFYW OFNOTIFY;
    alias PAGESETUPDLGW PAGESETUPDLG;
    alias PRINTDLGW PRINTDLG;

    alias ChooseColorW ChooseColor;
    alias ChooseFontW ChooseFont;
    alias FindTextW FindText;
    alias GetFileTitleW GetFileTitle;
    alias GetOpenFileNameW GetOpenFileName;
    alias GetSaveFileNameW GetSaveFileName;
    alias PageSetupDlgW PageSetupDlg;
    alias PrintDlgW PrintDlg;
    alias ReplaceTextW ReplaceText;

    //static if (_WIN32_WINNT >= 0x500) {
        alias PRINTDLGEXW PRINTDLGEX;
        alias PrintDlgExW PrintDlgEx;
    //}

} else { // UNICODE

    alias CHOOSECOLORA CHOOSECOLOR;
    alias CHOOSEFONTA CHOOSEFONT;
    alias FINDREPLACEA FINDREPLACE;
    alias OPENFILENAMEA OPENFILENAME;
    alias OFNOTIFYA OFNOTIFY;
    alias PAGESETUPDLGA PAGESETUPDLG;
    alias PRINTDLGA PRINTDLG;

    alias ChooseColorA ChooseColor;
    alias ChooseFontA ChooseFont;
    alias FindTextA FindText;
    alias GetFileTitleA GetFileTitle;
    alias GetOpenFileNameA GetOpenFileName;
    alias GetSaveFileNameA GetSaveFileName;
    alias PageSetupDlgA PageSetupDlg;
    alias PrintDlgA PrintDlg;
    alias ReplaceTextA ReplaceText;

    //static if (_WIN32_WINNT >= 0x500) {
        alias PRINTDLGEXA PRINTDLGEX;
        alias PrintDlgExA PrintDlgEx;
    //}

} // UNICODE

alias CHOOSECOLOR* LPCHOOSECOLOR;
alias CHOOSEFONT* LPCHOOSEFONT;
alias FINDREPLACE* LPFINDREPLACE;
alias OPENFILENAME* LPOPENFILENAME;
alias OFNOTIFY* LPOFNOTIFY;
alias PAGESETUPDLG* LPPAGESETUPDLG;
alias PRINTDLG* LPPRINTDLG;
//static if (_WIN32_WINNT >= 0x500) {
    alias PRINTDLGEX* LPPRINTDLGEX;
//}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * Helper module for the Windows API
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_core.d)
 */
module core.sys.windows.core;
version (Windows):

/**
 The core Windows API functions.

 Importing this file is equivalent to the C code:
 ---
 #define WIN32_LEAN_AND_MEAN
 #include "windows.h"
 ---

*/

public import core.sys.windows.windef;
public import core.sys.windows.winnt;
public import core.sys.windows.wincon;
public import core.sys.windows.winbase;
public import core.sys.windows.wingdi;
public import core.sys.windows.winuser;
public import core.sys.windows.winnls;
public import core.sys.windows.winver;
public import core.sys.windows.winnetwk;
public import core.sys.windows.winsvc;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_cpl.d)
 */
module core.sys.windows.cpl;
version (Windows):

version (ANSI) {} else version = Unicode;

private import core.sys.windows.windef, core.sys.windows.winuser;

enum : uint {
    WM_CPL_LAUNCH = WM_USER + 1000,
    WM_CPL_LAUNCHED
}

enum : uint {
    CPL_DYNAMIC_RES,
    CPL_INIT,
    CPL_GETCOUNT,
    CPL_INQUIRE,
    CPL_SELECT,
    CPL_DBLCLK,
    CPL_STOP,
    CPL_EXIT,
    CPL_NEWINQUIRE,
    CPL_STARTWPARMSA,
    CPL_STARTWPARMSW, // = 10
    CPL_SETUP = 200
}

extern (Windows) alias LONG function(HWND, UINT, LONG, LONG) APPLET_PROC;

align(1)
struct CPLINFO {
align(1):
    int  idIcon;
    int  idName;
    int  idInfo;
    LONG_PTR  lData;
}
alias CPLINFO* LPCPLINFO;

align(1)
struct NEWCPLINFOA {
align(1):
    DWORD     dwSize = NEWCPLINFOA.sizeof;
    DWORD     dwFlags;
    DWORD     dwHelpContext;
    LONG_PTR  lData;
    HICON     hIcon;
    CHAR[32]  szName = 0;
    CHAR[64]  szInfo = 0;
    CHAR[128] szHelpFile = 0;
}
alias NEWCPLINFOA* LPNEWCPLINFOA;

align(1)
struct NEWCPLINFOW {
align(1):
    DWORD      dwSize = NEWCPLINFOW.sizeof;
    DWORD      dwFlags;
    DWORD      dwHelpContext;
    LONG_PTR   lData;
    HICON      hIcon;
    WCHAR[32]  szName = 0;
    WCHAR[64]  szInfo = 0;
    WCHAR[128] szHelpFile = 0;
}
alias NEWCPLINFOW* LPNEWCPLINFOW;

version (Unicode) {
    alias CPL_STARTWPARMSW CPL_STARTWPARMS;
    alias NEWCPLINFOW NEWCPLINFO;
} else {
    alias CPL_STARTWPARMSA CPL_STARTWPARMS;
    alias NEWCPLINFOA NEWCPLINFO;
}

alias NEWCPLINFO* LPNEWCPLINFO;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
 * Windows API header module
 *
 * Translated from MinGW API for MS-Windows 3.10
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_cplext.d)
 */
module core.sys.windows.cplext;
version (Windows):

enum : uint {
    CPLPAGE_MOUSE_BUTTONS      = 1,
    CPLPAGE_MOUSE_PTRMOTION    = 2,
    CPLPAGE_MOUSE_WHEEL        = 3,
    CPLPAGE_KEYBOARD_SPEED     = 1,
    CPLPAGE_DISPLAY_BACKGROUND = 1
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_custcntl.d)
 */
module core.sys.windows.custcntl;
version (Windows):

version (ANSI) {} else version = Unicode;

private import core.sys.windows.windef;

// FIXME: check type
enum CCF_NOTEXT = 1;

enum size_t
    CCHCCCLASS =  32,
    CCHCCDESC  =  32,
    CCHCCTEXT  = 256;

struct CCSTYLEA {
    DWORD           flStyle;
    DWORD           flExtStyle;
    CHAR[CCHCCTEXT] szText = 0;
    LANGID          lgid;
    WORD            wReserved1;
}
alias CCSTYLEA* LPCCSTYLEA;

struct CCSTYLEW {
    DWORD            flStyle;
    DWORD            flExtStyle;
    WCHAR[CCHCCTEXT] szText = 0;
    LANGID           lgid;
    WORD             wReserved1;
}
alias CCSTYLEW* LPCCSTYLEW;

struct CCSTYLEFLAGA {
    DWORD flStyle;
    DWORD flStyleMask;
    LPSTR pszStyle;
}
alias CCSTYLEFLAGA* LPCCSTYLEFLAGA;

struct CCSTYLEFLAGW {
    DWORD  flStyle;
    DWORD  flStyleMask;
    LPWSTR pszStyle;
}
alias CCSTYLEFLAGW* LPCCSTYLEFLAGW;

struct CCINFOA {
    CHAR[CCHCCCLASS]  szClass = 0;
    DWORD             flOptions;
    CHAR[CCHCCDESC]   szDesc = 0;
    UINT              cxDefault;
    UINT              cyDefault;
    DWORD             flStyleDefault;
    DWORD             flExtStyleDefault;
    DWORD             flCtrlTypeMask;
    CHAR[CCHCCTEXT]   szTextDefault = 0;
    INT               cStyleFlags;
    LPCCSTYLEFLAGA    aStyleFlags;
    LPFNCCSTYLEA      lpfnStyle;
    LPFNCCSIZETOTEXTA lpfnSizeToText;
    DWORD             dwReserved1;
    DWORD             dwReserved2;
}
alias CCINFOA* LPCCINFOA;

struct CCINFOW {
    WCHAR[CCHCCCLASS] szClass = 0;
    DWORD             flOptions;
    WCHAR[CCHCCDESC]  szDesc = 0;
    UINT              cxDefault;
    UINT              cyDefault;
    DWORD             flStyleDefault;
    DWORD             flExtStyleDefault;
    DWORD             flCtrlTypeMask;
    WCHAR[CCHCCTEXT]  szTextDefault = 0;
    INT               cStyleFlags;
    LPCCSTYLEFLAGW    aStyleFlags;
    LPFNCCSTYLEW      lpfnStyle;
    LPFNCCSIZETOTEXTW lpfnSizeToText;
    DWORD             dwReserved1;
    DWORD             dwReserved2;
}
alias CCINFOW* LPCCINFOW;

extern (Windows) {
    alias BOOL function(HWND, LPCCSTYLEA) LPFNCCSTYLEA;
    alias BOOL function(HWND, LPCCSTYLEW) LPFNCCSTYLEW;
    alias INT function(DWORD, DWORD, HFONT, LPSTR) LPFNCCSIZETOTEXTA;
    alias INT function(DWORD, DWORD, HFONT, LPWSTR) LPFNCCSIZETOTEXTW;
    alias UINT function(LPCCINFOA) LPFNCCINFOA;
    alias UINT function(LPCCINFOW) LPFNCCINFOW;
    UINT CustomControlInfoA(LPCCINFOA acci);
    UINT CustomControlInfoW(LPCCINFOW acci);
}

version (Unicode) {
    alias CCSTYLEW CCSTYLE;
    alias CCSTYLEFLAGW CCSTYLEFLAG;
    alias CCINFOW CCINFO;
    alias LPFNCCSTYLEW LPFNCCSTYLE;
    alias LPFNCCSIZETOTEXTW LPFNCCSIZETOTEXT;
    alias LPFNCCINFOW LPFNCCINFO;
} else {
    alias CCSTYLEA CCSTYLE;
    alias CCSTYLEFLAGA CCSTYLEFLAG;
    alias CCINFOA CCINFO;
    alias LPFNCCSTYLEA LPFNCCSTYLE;
    alias LPFNCCSIZETOTEXTA LPFNCCSIZETOTEXT;
    alias LPFNCCINFOA LPFNCCINFO;
}

alias CCSTYLE* LPCCSTYLE;
alias CCSTYLEFLAG* LPCCSTYLEFLAG;
alias CCINFO* LPCCINFO;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * ...
 *
 * Copyright: Copyright Benjamin Thaut 2010 - 2011.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Benjamin Thaut, Sean Kelly
 * Source:    $(DRUNTIMESRC core/sys/windows/_stacktrace.d)
 */

module core.sys.windows.dbghelp;
version (Windows):

import core.sys.windows.winbase /+: FreeLibrary, GetProcAddress, LoadLibraryA+/;
import core.sys.windows.windef;

public import core.sys.windows.dbghelp_types;

extern(System)
{
    alias BOOL         function(HANDLE hProcess, DWORD64 lpBaseAddress, PVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead) ReadProcessMemoryProc64;
    alias PVOID        function(HANDLE hProcess, DWORD64 AddrBase) FunctionTableAccessProc64;
    alias DWORD64      function(HANDLE hProcess, DWORD64 Address) GetModuleBaseProc64;
    alias DWORD64      function(HANDLE hProcess, HANDLE hThread, ADDRESS64 *lpaddr) TranslateAddressProc64;

    alias BOOL         function(HANDLE hProcess, PCSTR UserSearchPath, bool fInvadeProcess) SymInitializeFunc;
    alias BOOL         function(HANDLE hProcess) SymCleanupFunc;
    alias DWORD        function(DWORD SymOptions) SymSetOptionsFunc;
    alias DWORD        function() SymGetOptionsFunc;
    alias PVOID        function(HANDLE hProcess, DWORD64 AddrBase) SymFunctionTableAccess64Func;
    alias BOOL         function(DWORD MachineType, HANDLE hProcess, HANDLE hThread, STACKFRAME64 *StackFrame, PVOID ContextRecord,
                                ReadProcessMemoryProc64 ReadMemoryRoutine, FunctionTableAccessProc64 FunctoinTableAccess,
                                GetModuleBaseProc64 GetModuleBaseRoutine, TranslateAddressProc64 TranslateAddress) StackWalk64Func;
    alias BOOL         function(HANDLE hProcess, DWORD64 dwAddr, PDWORD pdwDisplacement, IMAGEHLP_LINEA64 *line) SymGetLineFromAddr64Func;
    alias DWORD64      function(HANDLE hProcess, DWORD64 dwAddr) SymGetModuleBase64Func;
    alias BOOL         function(HANDLE hProcess, DWORD64 dwAddr, IMAGEHLP_MODULEA64 *ModuleInfo) SymGetModuleInfo64Func;
    alias BOOL         function(HANDLE hProcess, DWORD64 Address, DWORD64 *Displacement, IMAGEHLP_SYMBOLA64 *Symbol) SymGetSymFromAddr64Func;
    alias DWORD        function(PCTSTR DecoratedName, PTSTR UnDecoratedName, DWORD UndecoratedLength, DWORD Flags) UnDecorateSymbolNameFunc;
    alias DWORD64      function(HANDLE hProcess, HANDLE hFile, PCSTR ImageName, PCSTR ModuleName, DWORD64 BaseOfDll, DWORD SizeOfDll) SymLoadModule64Func;
    alias BOOL         function(HANDLE HProcess, PTSTR SearchPath, DWORD SearchPathLength) SymGetSearchPathFunc;
    alias BOOL         function(HANDLE hProcess, DWORD64 Address) SymUnloadModule64Func;
    alias BOOL         function(HANDLE hProcess, ULONG ActionCode, ulong CallbackContext, ulong UserContext) PSYMBOL_REGISTERED_CALLBACK64;
    alias BOOL         function(HANDLE hProcess, PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction, ulong UserContext) SymRegisterCallback64Func;
    alias API_VERSION* function() ImagehlpApiVersionFunc;
}

struct DbgHelp
{
    SymInitializeFunc        SymInitialize;
    SymCleanupFunc           SymCleanup;
    StackWalk64Func          StackWalk64;
    SymGetOptionsFunc        SymGetOptions;
    SymSetOptionsFunc        SymSetOptions;
    SymFunctionTableAccess64Func SymFunctionTableAccess64;
    SymGetLineFromAddr64Func SymGetLineFromAddr64;
    SymGetModuleBase64Func   SymGetModuleBase64;
    SymGetModuleInfo64Func   SymGetModuleInfo64;
    SymGetSymFromAddr64Func  SymGetSymFromAddr64;
    UnDecorateSymbolNameFunc UnDecorateSymbolName;
    SymLoadModule64Func      SymLoadModule64;
    SymGetSearchPathFunc     SymGetSearchPath;
    SymUnloadModule64Func    SymUnloadModule64;
    SymRegisterCallback64Func SymRegisterCallback64;
    ImagehlpApiVersionFunc   ImagehlpApiVersion;

    static DbgHelp* get()
    {
        if ( sm_hndl != sm_hndl.init )
            return &sm_inst;
        if ( (sm_hndl = LoadLibraryA( "dbghelp.dll" )) != sm_hndl.init )
        {
            sm_inst.SymInitialize            = cast(SymInitializeFunc) GetProcAddress(sm_hndl,"SymInitialize");
            sm_inst.SymCleanup               = cast(SymCleanupFunc) GetProcAddress(sm_hndl,"SymCleanup");
            sm_inst.StackWalk64              = cast(StackWalk64Func) GetProcAddress(sm_hndl,"StackWalk64");
            sm_inst.SymGetOptions            = cast(SymGetOptionsFunc) GetProcAddress(sm_hndl,"SymGetOptions");
            sm_inst.SymSetOptions            = cast(SymSetOptionsFunc) GetProcAddress(sm_hndl,"SymSetOptions");
            sm_inst.SymFunctionTableAccess64 = cast(SymFunctionTableAccess64Func) GetProcAddress(sm_hndl,"SymFunctionTableAccess64");
            sm_inst.SymGetLineFromAddr64     = cast(SymGetLineFromAddr64Func) GetProcAddress(sm_hndl,"SymGetLineFromAddr64");
            sm_inst.SymGetModuleBase64       = cast(SymGetModuleBase64Func) GetProcAddress(sm_hndl,"SymGetModuleBase64");
            sm_inst.SymGetModuleInfo64       = cast(SymGetModuleInfo64Func) GetProcAddress(sm_hndl,"SymGetModuleInfo64");
            sm_inst.SymGetSymFromAddr64      = cast(SymGetSymFromAddr64Func) GetProcAddress(sm_hndl,"SymGetSymFromAddr64");
            sm_inst.SymLoadModule64          = cast(SymLoadModule64Func) GetProcAddress(sm_hndl,"SymLoadModule64");
            sm_inst.SymGetSearchPath         = cast(SymGetSearchPathFunc) GetProcAddress(sm_hndl,"SymGetSearchPath");
            sm_inst.SymUnloadModule64        = cast(SymUnloadModule64Func) GetProcAddress(sm_hndl,"SymUnloadModule64");
            sm_inst.SymRegisterCallback64    = cast(SymRegisterCallback64Func) GetProcAddress(sm_hndl, "SymRegisterCallback64");
            sm_inst.ImagehlpApiVersion       = cast(ImagehlpApiVersionFunc) GetProcAddress(sm_hndl, "ImagehlpApiVersion");
            assert( sm_inst.SymInitialize && sm_inst.SymCleanup && sm_inst.StackWalk64 && sm_inst.SymGetOptions &&
                    sm_inst.SymSetOptions && sm_inst.SymFunctionTableAccess64 && sm_inst.SymGetLineFromAddr64 &&
                    sm_inst.SymGetModuleBase64 && sm_inst.SymGetModuleInfo64 && sm_inst.SymGetSymFromAddr64 &&
                    sm_inst.SymLoadModule64 && sm_inst.SymGetSearchPath && sm_inst.SymUnloadModule64 &&
                    sm_inst.SymRegisterCallback64 && sm_inst.ImagehlpApiVersion);

            return &sm_inst;
        }
        return null;
    }

    shared static ~this()
    {
        if ( sm_hndl != sm_hndl.init )
            FreeLibrary( sm_hndl );
    }

private:
    __gshared DbgHelp sm_inst;
    __gshared HANDLE  sm_hndl;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * ...
 *
 * Copyright: Copyright Benjamin Thaut 2010 - 2011.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Benjamin Thaut, Sean Kelly
 * Source:    $(DRUNTIMESRC core/sys/windows/_dbghelp_types.d)
 */

module core.sys.windows.dbghelp_types;
version (Windows):

version (ANSI) {} else version = Unicode;

import core.sys.windows.windef;
import core.sys.windows.imagehlp /+: ADDRESS_MODE+/;

public import core.sys.windows.winnt : TCHAR;

/*
enum ADDRESS_MODE : DWORD
{
    AddrMode1616 = 0,
    AddrMode1632 = 1,
    AddrModeReal = 2,
    AddrModeFlat = 3,
}
*/
enum : DWORD
{
    SYMOPT_DEFERRED_LOAD        = 0x00000004,
    SYMOPT_FAIL_CRITICAL_ERRORS = 0x00000200,
    SYMOPT_LOAD_LINES           = 0x00000010,
    SYMOPT_DEBUG                = 0x80000000,
}

enum : ULONG
{
    CBA_READ_MEMORY             = 0x00000006,
    CBA_DEBUG_INFO              = 0x10000000,
}

public import core.sys.windows.basetyps : GUID;

struct ADDRESS64
{
    DWORD64      Offset;
    WORD         Segment;
    ADDRESS_MODE Mode;
}

struct KDHELP64
{
    DWORD64 Thread;
    DWORD   ThCallbackStack;
    DWORD   ThCallbackBStore;
    DWORD   NextCallback;
    DWORD   FramePointer;
    DWORD64 KiCallUserMode;
    DWORD64 KeUserCallbackDispatcher;
    DWORD64 SystemRangeStart;
    DWORD64 KiUserExceptionDispatcher;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64[5] Reserved;
}

struct STACKFRAME64
{
    ADDRESS64  AddrPC;
    ADDRESS64  AddrReturn;
    ADDRESS64  AddrFrame;
    ADDRESS64  AddrStack;
    ADDRESS64  AddrBStore;
    PVOID      FuncTableEntry;
    DWORD64[4] Params;
    BOOL       Far;
    BOOL       Virtual;
    DWORD64[3] Reserved;
    KDHELP64   KdHelp;
}

public import core.sys.windows.winnt : IMAGE_FILE_MACHINE_I386, IMAGE_FILE_MACHINE_IA64, IMAGE_FILE_MACHINE_AMD64;

struct IMAGEHLP_LINEA64
{
    DWORD   SizeOfStruct;
    PVOID   Key;
    DWORD   LineNumber;
    PCSTR   FileName;
    DWORD64 Address;
}
struct IMAGEHLP_LINEW64
{
    DWORD   SizeOfStruct;
    PVOID   Key;
    DWORD   LineNumber;
    PWSTR FileName;
    DWORD64 Address;
}

enum SYM_TYPE : int
{
    SymNone = 0,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym,
    SymDia,
    SymVirtual,
    NumSymTypes,
}

struct IMAGEHLP_MODULEA64
{
    DWORD      SizeOfStruct;
    DWORD64    BaseOfImage;
    DWORD      ImageSize;
    DWORD      TimeDateStamp;
    DWORD      CheckSum;
    DWORD      NumSyms;
    SYM_TYPE   SymType;
    CHAR[32]   ModuleName = 0;
    CHAR[256]  ImageName = 0;
    CHAR[256]  LoadedImageName = 0;
    // new elements: 07-Jun-2002
    version (none)
    {
        CHAR[256]  LoadedPdbName = 0;
        DWORD      CVSig;
        CHAR[MAX_PATH*3] CVData = 0;
        DWORD      PdbSig;
        GUID       PdbSig70;
        DWORD      PdbAge;
        BOOL       PdbUnmatched;
        BOOL       DbgUnmachted;
        BOOL       LineNumbers;
        BOOL       GlobalSymbols;
        BOOL       TypeInfo;
    }
    // new elements: 17-Dec-2003
    version (none)
    {
        BOOL       SourceIndexed;
        BOOL       Publics;
    }
}
struct IMAGEHLP_MODULEW64
{
    DWORD      SizeOfStruct;
    DWORD64    BaseOfImage;
    DWORD      ImageSize;
    DWORD      TimeDateStamp;
    DWORD      CheckSum;
    DWORD      NumSyms;
    SYM_TYPE   SymType;
    WCHAR[32]  ModuleName = 0;
    WCHAR[256] ImageName = 0;
    WCHAR[256] LoadedImageName = 0;
    // new elements: 07-Jun-2002
    version (none)
    {
        WCHAR[256] LoadedPdbName = 0;
        DWORD      CVSig;
        WCHAR[MAX_PATH*3] CVData = 0;
        DWORD      PdbSig;
        GUID       PdbSig70;
        DWORD      PdbAge;
        BOOL       PdbUnmatched;
        BOOL       DbgUnmachted;
        BOOL       LineNumbers;
        BOOL       GlobalSymbols;
        BOOL       TypeInfo;
    }
    // new elements: 17-Dec-2003
    version (none)
    {
        BOOL       SourceIndexed;
        BOOL       Publics;
    }
}

struct IMAGEHLP_SYMBOLA64
{
    DWORD    SizeOfStruct;
    DWORD64  Address;
    DWORD    Size;
    DWORD    Flags;
    DWORD    MaxNameLength;
    CHAR[1] Name = 0;
}
struct IMAGEHLP_SYMBOLW64
{
    DWORD    SizeOfStruct;
    DWORD64  Address;
    DWORD    Size;
    DWORD    Flags;
    DWORD    MaxNameLength;
    WCHAR[1] Name = 0;
}


struct IMAGEHLP_CBA_READ_MEMORY
{
    DWORD64 addr;
    PVOID   buf;
    DWORD   bytes;
    DWORD   *bytesread;
}

struct API_VERSION
{
    USHORT MajorVersion;
    USHORT MinorVersion;
    USHORT Revision;
    USHORT Reserved;
}

version (Unicode)
{
    alias IMAGEHLP_LINEW64 IMAGEHLP_LINE64;
    alias IMAGEHLP_MODULEW64 IMAGEHLP_MODULE64;
    alias IMAGEHLP_SYMBOLW64 IMAGEHLP_SYMBOL64;
}
else
{
    alias IMAGEHLP_LINEA64 IMAGEHLP_LINE64;
    alias IMAGEHLP_MODULEA64 IMAGEHLP_MODULE64;
    alias IMAGEHLP_SYMBOLA64 IMAGEHLP_SYMBOL64;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Vladimir Vlasov
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_dbt.d)
 */
module core.sys.windows.dbt;
version (Windows):

version (ANSI) {} else version = Unicode;

import core.sys.windows.w32api, core.sys.windows.windef;
import core.sys.windows.basetyps; // for GUID

// FIXME: clean up Windows version support

enum : DWORD {
    DBT_NO_DISK_SPACE           = 0x47,
    DBT_CONFIGMGPRIVATE         = 0x7FFF,
    DBT_DEVICEARRIVAL           = 0x8000,
    DBT_DEVICEQUERYREMOVE       = 0x8001,
    DBT_DEVICEQUERYREMOVEFAILED = 0x8002,
    DBT_DEVICEREMOVEPENDING     = 0x8003,
    DBT_DEVICEREMOVECOMPLETE    = 0x8004,
    DBT_DEVICETYPESPECIFIC      = 0x8005,
    DBT_DEVTYP_OEM              = 0,
    DBT_DEVTYP_DEVNODE,
    DBT_DEVTYP_VOLUME,
    DBT_DEVTYP_PORT,
    DBT_DEVTYP_NET,
    DBT_DEVTYP_DEVICEINTERFACE,
    DBT_DEVTYP_HANDLE        // = 6
}

enum : DWORD {
    DBT_APPYBEGIN,
    DBT_APPYEND,
    DBT_DEVNODES_CHANGED     = 7,
    DBT_QUERYCHANGECONFIG    = 0x17,
    DBT_CONFIGCHANGED        = 0x18,
    DBT_CONFIGCHANGECANCELED = 0x19,
    DBT_MONITORCHANGE        = 0x1B,
    DBT_SHELLLOGGEDON        = 32,
    DBT_CONFIGMGAPI32        = 34,
    DBT_VXDINITCOMPLETE      = 35,
    DBT_VOLLOCKQUERYLOCK     = 0x8041,
    DBT_VOLLOCKLOCKTAKEN     = 0x8042,
    DBT_VOLLOCKLOCKFAILED    = 0x8043,
    DBT_VOLLOCKQUERYUNLOCK   = 0x8044,
    DBT_VOLLOCKLOCKRELEASED  = 0x8045,
    DBT_VOLLOCKUNLOCKFAILED  = 0x8046,
    DBT_USERDEFINED          = 0xFFFF
}

enum : WORD {
    DBTF_MEDIA = 1,
    DBTF_NET   = 2
}

enum : DWORD {
    BSM_ALLCOMPONENTS      = 0,
    BSM_APPLICATIONS       = 8,
    BSM_ALLDESKTOPS        = 16,
    BSM_INSTALLABLEDRIVERS = 4,
    BSM_NETDRIVER          = 2,
    BSM_VXDS               = 1,
    BSF_FLUSHDISK          = 0x00000004,
    BSF_FORCEIFHUNG        = 0x00000020,
    BSF_IGNORECURRENTTASK  = 0x00000002,
    BSF_NOHANG             = 0x00000008,
    BSF_NOTIMEOUTIFNOTHUNG = 0x00000040,
    BSF_POSTMESSAGE        = 0x00000010,
    BSF_QUERY              = 0x00000001,
    BSF_MSGSRV32ISOK_BIT   = 31,
    BSF_MSGSRV32ISOK       = 0x80000000
}

//static if (_WIN32_WINNT >= 0x500) {
    enum : DWORD {
        BSF_ALLOWSFW          = 0x00000080,
        BSF_SENDNOTIFYMESSAGE = 0x00000100
    }
//}

static if (_WIN32_WINNT >= 0x501) {
    enum : DWORD {
        BSF_LUID        = 0x00000400,
        BSF_RETURNHDESK = 0x00000200
    }
}

struct DEV_BROADCAST_HDR {
    DWORD dbch_size = DEV_BROADCAST_HDR.sizeof;
    DWORD dbch_devicetype;
    DWORD dbch_reserved;
}
alias DEV_BROADCAST_HDR* PDEV_BROADCAST_HDR;

struct DEV_BROADCAST_OEM {
    DWORD dbco_size = DEV_BROADCAST_OEM.sizeof;
    DWORD dbco_devicetype;
    DWORD dbco_reserved;
    DWORD dbco_identifier;
    DWORD dbco_suppfunc;
}
alias DEV_BROADCAST_OEM* PDEV_BROADCAST_OEM;

struct DEV_BROADCAST_PORT_A {
    DWORD dbcp_size = DEV_BROADCAST_PORT_A.sizeof;
    DWORD dbcp_devicetype;
    DWORD dbcp_reserved;
    char  _dbcp_name = 0;
    char* dbcp_name() return { return &_dbcp_name; }
}
alias DEV_BROADCAST_PORT_A* PDEV_BROADCAST_PORT_A;

struct DEV_BROADCAST_PORT_W {
    DWORD  dbcp_size = DEV_BROADCAST_PORT_W.sizeof;
    DWORD  dbcp_devicetype;
    DWORD  dbcp_reserved;
    WCHAR  _dbcp_name = 0;
    WCHAR* dbcp_name() return { return &_dbcp_name; }
}
alias DEV_BROADCAST_PORT_W* PDEV_BROADCAST_PORT_W;

struct DEV_BROADCAST_USERDEFINED {
    DEV_BROADCAST_HDR dbud_dbh;
    char  _dbud_szName = 0;
    char* dbud_szName() return { return &_dbud_szName; }
}

struct DEV_BROADCAST_VOLUME {
    DWORD dbcv_size = DEV_BROADCAST_VOLUME.sizeof;
    DWORD dbcv_devicetype;
    DWORD dbcv_reserved;
    DWORD dbcv_unitmask;
    WORD  dbcv_flags;
}
alias DEV_BROADCAST_VOLUME* PDEV_BROADCAST_VOLUME;

version (Unicode) {
    alias DEV_BROADCAST_PORT_W DEV_BROADCAST_PORT;
} else {
    alias DEV_BROADCAST_PORT_A DEV_BROADCAST_PORT;
}
alias DEV_BROADCAST_PORT* PDEV_BROADCAST_PORT;

//static if (_WIN32_WINNT >= 0x500) {
    struct DEV_BROADCAST_DEVICEINTERFACE_A {
        DWORD dbcc_size = DEV_BROADCAST_DEVICEINTERFACE_A.sizeof;
        DWORD dbcc_devicetype;
        DWORD dbcc_reserved;
        GUID  dbcc_classguid;
        char  _dbcc_name;
        char* dbcc_name() return { return &_dbcc_name; }
    }
    alias DEV_BROADCAST_DEVICEINTERFACE_A* PDEV_BROADCAST_DEVICEINTERFACE_A;

    struct DEV_BROADCAST_DEVICEINTERFACE_W {
        DWORD  dbcc_size = DEV_BROADCAST_DEVICEINTERFACE_W.sizeof;
        DWORD  dbcc_devicetype;
        DWORD  dbcc_reserved;
        GUID   dbcc_classguid;
        WCHAR  _dbcc_name = 0;
        WCHAR* dbcc_name() return { return &_dbcc_name; }
    }
    alias DEV_BROADCAST_DEVICEINTERFACE_W* PDEV_BROADCAST_DEVICEINTERFACE_W;

    version (Unicode) {
        alias DEV_BROADCAST_DEVICEINTERFACE_W DEV_BROADCAST_DEVICEINTERFACE;
    } else {
        alias DEV_BROADCAST_DEVICEINTERFACE_A DEV_BROADCAST_DEVICEINTERFACE;
    }
    alias DEV_BROADCAST_DEVICEINTERFACE* PDEV_BROADCAST_DEVICEINTERFACE;

    struct DEV_BROADCAST_HANDLE {
        DWORD  dbch_size = DEV_BROADCAST_HANDLE.sizeof;
        DWORD  dbch_devicetype;
        DWORD  dbch_reserved;
        HANDLE dbch_handle;
        DWORD  dbch_hdevnotify;
        GUID   dbch_eventguid;
        LONG   dbch_nameoffset;
        BYTE   _dbch_data;
        BYTE*  dbch_data() return { return &_dbch_data; }
    }
    alias DEV_BROADCAST_HANDLE* PDEV_BROADCAST_HANDLE;
//}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_dde.d)
 */
module core.sys.windows.dde;
version (Windows):
pragma(lib, "user32");

private import core.sys.windows.windef;

enum : uint {
    WM_DDE_FIRST     = 0x03E0,
    WM_DDE_INITIATE  = WM_DDE_FIRST,
    WM_DDE_TERMINATE,
    WM_DDE_ADVISE,
    WM_DDE_UNADVISE,
    WM_DDE_ACK,
    WM_DDE_DATA,
    WM_DDE_REQUEST,
    WM_DDE_POKE,
    WM_DDE_EXECUTE,
    WM_DDE_LAST      = WM_DDE_EXECUTE
}

struct DDEACK {
    ubyte bAppReturnCode;
    ubyte _bf;

    @property ubyte reserved() { return cast(ubyte) (_bf & 0x3F); }
    @property bool  fBusy()    { return cast(bool)  (_bf & 0x40); }
    @property bool  fAck()     { return cast(bool)  (_bf & 0x80); }

    @property ubyte reserved(ubyte r) {
        _bf = cast(ubyte) ((_bf & ~0x3F) | (r & 0x3F));
        return cast(ubyte)(r & 0x3F);
    }

    @property bool fBusy(bool f) { _bf = cast(ubyte) ((_bf & ~0x40) | (f << 6)); return f; }
    @property bool fAck(bool f)  { _bf = cast(ubyte) ((_bf & ~0x80) | (f << 7)); return f; }
}

struct DDEADVISE {
    ushort _bf;
    short  cfFormat;

    @property ushort reserved()  { return cast(ushort) (_bf & 0x3FFF); }
    @property bool   fDeferUpd() { return cast(bool)   (_bf & 0x4000); }
    @property bool   fAckReq()   { return cast(bool)   (_bf & 0x8000); }

    @property ushort reserved(ushort r) {
        _bf = cast(ushort) ((_bf & ~0x3FFF) | (r & 0x3FFF));
        return cast(ushort)(r & 0x3FFF);
    }

    @property bool   fDeferUpd(bool f) { _bf = cast(ushort) ((_bf & ~0x4000) | (f << 14)); return f; }
    @property bool   fAckReq(bool f)   { _bf = cast(ushort) ((_bf & ~0x8000) | (f << 15)); return f; }
}

struct DDEDATA {
    ushort _bf;
    short  cfFormat;
    byte   _Value;

    @property ushort unused()    { return cast(ushort) (_bf & 0x0FFF); }
    @property bool   fResponse() { return cast(bool)   (_bf & 0x1000); }
    @property bool   fRelease()  { return cast(bool)   (_bf & 0x2000); }
    @property bool   reserved()  { return cast(bool)   (_bf & 0x4000); }
    @property bool   fAckReq()   { return cast(bool)   (_bf & 0x8000); }

    @property byte*  Value() return { return &_Value; }

    @property ushort unused(ushort r) {
        _bf = cast(ushort) ((_bf & ~0x0FFF) | (r & 0x0FFF));
        return cast(ushort)(r & 0x0FFF);
    }

    @property bool   fResponse(bool f) { _bf = cast(ushort) ((_bf & ~0x1000) | (f << 12)); return f; }
    @property bool   fRelease(bool f)  { _bf = cast(ushort) ((_bf & ~0x2000) | (f << 13)); return f; }
    @property bool   reserved(bool f)  { _bf = cast(ushort) ((_bf & ~0x4000) | (f << 14)); return f; }
    @property bool   fAckReq(bool f)   { _bf = cast(ushort) ((_bf & ~0x8000) | (f << 15)); return f; }
}

struct DDEPOKE {
    ushort _bf;
    short  cfFormat;
    byte   _Value;

    @property ushort unused()    { return cast(ushort) (_bf & 0x1FFF); }
    @property bool   fRelease()  { return cast(bool)   (_bf & 0x2000); }
    @property ubyte  fReserved() { return cast(ubyte)  ((_bf & 0xC000) >>> 14); }

    @property byte*  Value() return { return &_Value; }

    @property ushort unused(ushort u) {
        _bf = cast(ushort) ((_bf & ~0x1FFF) | (u & 0x1FFF));
        return cast(ushort)(u & 0x1FFF);
    }

    @property bool   fRelease(bool f)   { _bf = cast(ushort) ((_bf & ~0x2000) | (f << 13)); return f; }
    @property ubyte  fReserved(ubyte r) { _bf = cast(ushort) ((_bf & ~0xC000) | (r << 14)); return r; }
}

deprecated struct DDELN {
    ushort _bf;
    short  cfFormat;

    @property ushort unused()    { return cast(ushort) (_bf & 0x1FFF); }
    @property bool   fRelease()  { return cast(bool)   (_bf & 0x2000); }
    @property bool   fDeferUpd() { return cast(bool)   (_bf & 0x4000); }
    @property bool   fAckReq()   { return cast(bool)   (_bf & 0x8000); }

    @property ushort unused(ushort u) {
        _bf = cast(ushort)((_bf & ~0x1FFF) | (u & 0x1FFF));
        return cast(ushort)(u & 0x1FFF);
    }

    @property bool   fRelease(bool f)  { _bf = cast(ushort) ((_bf & ~0x2000) | (f << 13)); return f; }
    @property bool   fDeferUpd(bool f) { _bf = cast(ushort) ((_bf & ~0x4000) | (f << 14)); return f; }
    @property bool   fAckReq(bool f)   { _bf = cast(ushort) ((_bf & ~0x8000) | (f << 15)); return f; }
}

deprecated struct DDEUP {
    ushort _bf;
    short  cfFormat;
    byte   _rgb;

    @property ushort unused()    { return cast(ushort) (_bf & 0x0FFF); }
    @property bool   fAck()      { return cast(bool)   (_bf & 0x1000); }
    @property bool   fRelease()  { return cast(bool)   (_bf & 0x2000); }
    @property bool   fReserved() { return cast(bool)   (_bf & 0x4000); }
    @property bool   fAckReq()   { return cast(bool)   (_bf & 0x8000); }

    @property byte*  rgb() return { return &_rgb; }

    @property ushort unused(ushort r) {
        _bf = cast(ushort) ((_bf & ~0x0FFF) | (r & 0x0FFF));
        return cast(ushort)(r & 0x0FFF);
    }

    @property bool   fAck(bool f)      { _bf = cast(ushort) ((_bf & ~0x1000) | (f << 12)); return f; }
    @property bool   fRelease(bool f)  { _bf = cast(ushort) ((_bf & ~0x2000) | (f << 13)); return f; }
    @property bool   fReserved(bool f) { _bf = cast(ushort) ((_bf & ~0x4000) | (f << 14)); return f; }
    @property bool   fAckReq(bool f)   { _bf = cast(ushort) ((_bf & ~0x8000) | (f << 15)); return f; }
}

extern (Windows) {
    BOOL DdeSetQualityOfService(HWND, const(SECURITY_QUALITY_OF_SERVICE)*,
      PSECURITY_QUALITY_OF_SERVICE);
    BOOL ImpersonateDdeClientWindow(HWND, HWND);
    LPARAM PackDDElParam(UINT, UINT_PTR, UINT_PTR);
    BOOL UnpackDDElParam(UINT, LPARAM, PUINT_PTR, PUINT_PTR);
    BOOL FreeDDElParam(UINT, LPARAM);
    LPARAM ReuseDDElParam(LPARAM, UINT, UINT, UINT_PTR, UINT_PTR);
}

debug (WindowsUnitTest) {
    unittest {
        DDEACK ddeack;

        with (ddeack) {
            reserved = 10;
            assert (_bf == 0x0A);
            fBusy = true;
            assert (_bf == 0x4A);
            fAck = true;
            assert (_bf == 0xCA);

            assert (reserved == 10);
            assert (fBusy == true);
            assert (fAck == true);

            reserved = 43;
            assert (_bf == 0xEB);
            fBusy = false;
            assert (_bf == 0xAB);
            fAck = false;
            assert (_bf == 0x2B);

            assert (reserved == 43);
            assert (fBusy == false);
            assert (fAck == false);
        }

        DDEPOKE ddepoke;

        with (ddepoke) {
            unused = 3456;
            assert (_bf == 0x0D80);
            fRelease = true;
            assert (_bf == 0x2D80);
            fReserved = 2;
            assert (_bf == 0xAD80);

            assert (unused == 3456);
            assert (fRelease == true);
            assert (fReserved == 2);

            unused = 2109;
            assert (_bf == 0xa83d);
            fRelease = false;
            assert (_bf == 0x883d);
            fReserved = 1;
            assert (_bf == 0x483d);

            assert (unused == 2109);
            assert (fRelease == false);
            assert (fReserved == 1);
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_ddeml.d)
 */
module core.sys.windows.ddeml;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "user32");

private import core.sys.windows.basetsd, core.sys.windows.windef, core.sys.windows.winnt;

enum : int {
    CP_WINANSI    = 1004,
    CP_WINUNICODE = 1200
}

enum : UINT {
    XTYPF_NOBLOCK = 2,
    XTYPF_NODATA  = 4,
    XTYPF_ACKREQ  = 8
}

enum : UINT {
    XCLASS_MASK         = 0xFC00,
    XCLASS_BOOL         = 0x1000,
    XCLASS_DATA         = 0x2000,
    XCLASS_FLAGS        = 0x4000,
    XCLASS_NOTIFICATION = 0x8000
}

enum : UINT {
    XST_NULL,
    XST_INCOMPLETE,
    XST_CONNECTED,
    XST_INIT1,
    XST_INIT2,
    XST_REQSENT,
    XST_DATARCVD,
    XST_POKESENT,
    XST_POKEACKRCVD,
    XST_EXECSENT,
    XST_EXECACKRCVD,
    XST_ADVSENT,
    XST_UNADVSENT,
    XST_ADVACKRCVD,
    XST_UNADVACKRCVD,
    XST_ADVDATASENT,
    XST_ADVDATAACKRCVD // = 16
}

enum : UINT {
    XTYP_ERROR           = XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_ADVDATA         = 0x0010 | XCLASS_FLAGS,
    XTYP_ADVREQ          = 0x0020 | XCLASS_DATA | XTYPF_NOBLOCK,
    XTYP_ADVSTART        = 0x0030 | XCLASS_BOOL,
    XTYP_ADVSTOP         = 0x0040 | XCLASS_NOTIFICATION,
    XTYP_EXECUTE         = 0x0050 | XCLASS_FLAGS,
    XTYP_CONNECT         = 0x0060 | XCLASS_BOOL | XTYPF_NOBLOCK,
    XTYP_CONNECT_CONFIRM = 0x0070 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_XACT_COMPLETE   = 0x0080 | XCLASS_NOTIFICATION,
    XTYP_POKE            = 0x0090 | XCLASS_FLAGS,
    XTYP_REGISTER        = 0x00A0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_REQUEST         = 0x00B0 | XCLASS_DATA,
    XTYP_DISCONNECT      = 0x00C0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_UNREGISTER      = 0x00D0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_WILDCONNECT     = 0x00E0 | XCLASS_DATA | XTYPF_NOBLOCK,
    XTYP_MONITOR         = 0X00F0 | XCLASS_NOTIFICATION | XTYPF_NOBLOCK,
    XTYP_MASK            = 0x00F0,
    XTYP_SHIFT           = 4
}

/+
#define TIMEOUT_ASYNC  0xFFFFFFFF
#define QID_SYNC       0xFFFFFFFF
+/

enum : UINT {
    ST_CONNECTED  =   1,
    ST_ADVISE     =   2,
    ST_ISLOCAL    =   4,
    ST_BLOCKED    =   8,
    ST_CLIENT     =  16,
    ST_TERMINATED =  32,
    ST_INLIST     =  64,
    ST_BLOCKNEXT  = 128,
    ST_ISSELF     = 256
}

/+
#define CADV_LATEACK 0xFFFF
+/

enum : UINT {
    DMLERR_NO_ERROR      = 0,
    DMLERR_FIRST         = 0x4000,
    DMLERR_ADVACKTIMEOUT = DMLERR_FIRST,
    DMLERR_BUSY,
    DMLERR_DATAACKTIMEOUT,
    DMLERR_DLL_NOT_INITIALIZED,
    DMLERR_DLL_USAGE,
    DMLERR_EXECACKTIMEOUT,
    DMLERR_INVALIDPARAMETER,
    DMLERR_LOW_MEMORY,
    DMLERR_MEMORY_ERROR,
    DMLERR_NOTPROCESSED,
    DMLERR_NO_CONV_ESTABLISHED,
    DMLERR_POKEACKTIMEOUT,
    DMLERR_POSTMSG_FAILED,
    DMLERR_REENTRANCY,
    DMLERR_SERVER_DIED,
    DMLERR_SYS_ERROR,
    DMLERR_UNADVACKTIMEOUT,
    DMLERR_UNFOUND_QUEUE_ID, // = 0x4011
    DMLERR_LAST          = DMLERR_UNFOUND_QUEUE_ID
}

/+
#define DDE_FACK    0x8000
#define DDE_FBUSY   0x4000
#define DDE_FDEFERUPD   0x4000
#define DDE_FACKREQ 0x8000
#define DDE_FRELEASE    0x2000
#define DDE_FREQUESTED  0x1000
#define DDE_FAPPSTATUS  0x00ff
#define DDE_FNOTPROCESSED   0
#define DDE_FACKRESERVED    (~(DDE_FACK|DDE_FBUSY|DDE_FAPPSTATUS))
#define DDE_FADVRESERVED    (~(DDE_FACKREQ|DDE_FDEFERUPD))
#define DDE_FDATRESERVED    (~(DDE_FACKREQ|DDE_FRELEASE|DDE_FREQUESTED))
#define DDE_FPOKRESERVED    (~DDE_FRELEASE)
#define MSGF_DDEMGR 0x8001
#define CBR_BLOCK   ((HDDEDATA)0xffffffff)
+/

enum DWORD
    APPCLASS_STANDARD         = 0,
    APPCLASS_MONITOR          = 0x00000001,
    APPCLASS_MASK             = 0x0000000F,
    APPCMD_CLIENTONLY         = 0x00000010,
    APPCMD_FILTERINITS        = 0x00000020,
    APPCMD_MASK               = 0x00000FF0,
    CBF_FAIL_SELFCONNECTIONS  = 0x00001000,
    CBF_FAIL_CONNECTIONS      = 0x00002000,
    CBF_FAIL_ADVISES          = 0x00004000,
    CBF_FAIL_EXECUTES         = 0x00008000,
    CBF_FAIL_POKES            = 0x00010000,
    CBF_FAIL_REQUESTS         = 0x00020000,
    CBF_FAIL_ALLSVRXACTIONS   = 0x0003f000,
    CBF_SKIP_CONNECT_CONFIRMS = 0x00040000,
    CBF_SKIP_REGISTRATIONS    = 0x00080000,
    CBF_SKIP_UNREGISTRATIONS  = 0x00100000,
    CBF_SKIP_DISCONNECTS      = 0x00200000,
    CBF_SKIP_ALLNOTIFICATIONS = 0x003c0000,
    MF_HSZ_INFO               = 0x01000000,
    MF_SENDMSGS               = 0x02000000,
    MF_POSTMSGS               = 0x04000000,
    MF_CALLBACKS              = 0x08000000,
    MF_ERRORS                 = 0x10000000,
    MF_LINKS                  = 0x20000000,
    MF_CONV                   = 0x40000000,
    MF_MASK                   = 0xFF000000;

enum : UINT {
    EC_ENABLEALL    = 0,
    EC_ENABLEONE    = ST_BLOCKNEXT,
    EC_DISABLE      = ST_BLOCKED,
    EC_QUERYWAITING = 2
}

enum : UINT {
    DNS_REGISTER   = 1,
    DNS_UNREGISTER = 2,
    DNS_FILTERON   = 4,
    DNS_FILTEROFF  = 8
}

/+
#define HDATA_APPOWNED  1
#define MAX_MONITORS    4
+/

enum : int {
    MH_CREATE  = 1,
    MH_KEEP    = 2,
    MH_DELETE  = 3,
    MH_CLEANUP = 4
}

mixin DECLARE_HANDLE!("HCONVLIST");
mixin DECLARE_HANDLE!("HCONV");
mixin DECLARE_HANDLE!("HSZ");
mixin DECLARE_HANDLE!("HDDEDATA");

extern (Windows) alias HDDEDATA
  function(UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, ULONG_PTR, ULONG_PTR) PFNCALLBACK;

struct HSZPAIR {
    HSZ hszSvc;
    HSZ hszTopic;
}
alias HSZPAIR* PHSZPAIR;

struct CONVCONTEXT {
    UINT                        cb = CONVCONTEXT.sizeof;
    UINT                        wFlags;
    UINT                        wCountryID;
    int                         iCodePage;
    DWORD                       dwLangID;
    DWORD                       dwSecurity;
    SECURITY_QUALITY_OF_SERVICE qos;
}
alias CONVCONTEXT* PCONVCONTEXT;

struct CONVINFO {
    DWORD       cb = CONVINFO.sizeof;
    DWORD_PTR   hUser;
    HCONV       hConvPartner;
    HSZ         hszSvcPartner;
    HSZ         hszServiceReq;
    HSZ         hszTopic;
    HSZ         hszItem;
    UINT        wFmt;
    UINT        wType;
    UINT        wStatus;
    UINT        wConvst;
    UINT        wLastError;
    HCONVLIST   hConvList;
    CONVCONTEXT ConvCtxt;
    HWND        hwnd;
    HWND        hwndPartner;
}
alias CONVINFO* PCONVINFO;

struct DDEML_MSG_HOOK_DATA {
    UINT_PTR uiLo;
    UINT_PTR uiHi;
    DWORD    cbData;
    DWORD[8] Data;
}

struct MONHSZSTRUCT {
    UINT     cb = MONHSZSTRUCT.sizeof;
    int      fsAction;
    DWORD    dwTime;
    HSZ      hsz;
    HANDLE   hTask;
    TCHAR[1] _str = 0;

    TCHAR* str() return { return _str.ptr; }
}
alias MONHSZSTRUCT* PMONHSZSTRUCT;

struct MONLINKSTRUCT {
    UINT   cb = MONLINKSTRUCT.sizeof;
    DWORD  dwTime;
    HANDLE hTask;
    BOOL   fEstablished;
    BOOL   fNoData;
    HSZ    hszSvc;
    HSZ    hszTopic;
    HSZ    hszItem;
    UINT   wFmt;
    BOOL   fServer;
    HCONV  hConvServer;
    HCONV  hConvClient;
}
alias MONLINKSTRUCT* PMONLINKSTRUCT;

struct MONCONVSTRUCT {
    UINT   cb = MONCONVSTRUCT.sizeof;
    BOOL   fConnect;
    DWORD  dwTime;
    HANDLE hTask;
    HSZ    hszSvc;
    HSZ    hszTopic;
    HCONV  hConvClient;
    HCONV  hConvServer;
}
alias MONCONVSTRUCT* PMONCONVSTRUCT;

struct MONCBSTRUCT {
    UINT        cb = MONCBSTRUCT.sizeof;
    DWORD       dwTime;
    HANDLE      hTask;
    DWORD       dwRet;
    UINT        wType;
    UINT        wFmt;
    HCONV       hConv;
    HSZ         hsz1;
    HSZ         hsz2;
    HDDEDATA    hData;
    ULONG_PTR   dwData1;
    ULONG_PTR   dwData2;
    CONVCONTEXT cc;
    DWORD       cbData;
    DWORD[8]    Data;
}
alias MONCBSTRUCT* PMONCBSTRUCT;

struct MONERRSTRUCT {
    UINT   cb = MONERRSTRUCT.sizeof;
    UINT   wLastError;
    DWORD  dwTime;
    HANDLE hTask;
}
alias MONERRSTRUCT* PMONERRSTRUCT;

struct MONMSGSTRUCT {
    UINT   cb = MONMSGSTRUCT.sizeof;
    HWND   hwndTo;
    DWORD  dwTime;
    HANDLE hTask;
    UINT   wMsg;
    WPARAM wParam;
    LPARAM lParam;
    DDEML_MSG_HOOK_DATA dmhd;
}
alias MONMSGSTRUCT* PMONMSGSTRUCT;

extern (Windows) {
    BOOL DdeAbandonTransaction(DWORD, HCONV, DWORD);
    PBYTE DdeAccessData(HDDEDATA, PDWORD);
    HDDEDATA DdeAddData(HDDEDATA, PBYTE, DWORD, DWORD);
    HDDEDATA DdeClientTransaction(PBYTE, DWORD, HCONV, HSZ, UINT, UINT,
      DWORD, PDWORD);
    int DdeCmpStringHandles(HSZ, HSZ);
    HCONV DdeConnect(DWORD, HSZ, HSZ, PCONVCONTEXT);
    HCONVLIST DdeConnectList(DWORD, HSZ, HSZ, HCONVLIST, PCONVCONTEXT);
    HDDEDATA DdeCreateDataHandle(DWORD, PBYTE, DWORD, DWORD, HSZ, UINT,
      UINT);
    HSZ DdeCreateStringHandleA(DWORD, LPSTR, int);
    HSZ DdeCreateStringHandleW(DWORD, LPWSTR, int);
    BOOL DdeDisconnect(HCONV);
    BOOL DdeDisconnectList(HCONVLIST);
    BOOL DdeEnableCallback(DWORD, HCONV, UINT);
    BOOL DdeFreeDataHandle(HDDEDATA);
    BOOL DdeFreeStringHandle(DWORD, HSZ);
    DWORD DdeGetData(HDDEDATA, PBYTE, DWORD, DWORD);
    UINT DdeGetLastError(DWORD);
    BOOL DdeImpersonateClient(HCONV);
    UINT DdeInitializeA(PDWORD, PFNCALLBACK, DWORD, DWORD);
    UINT DdeInitializeW(PDWORD, PFNCALLBACK, DWORD, DWORD);
    BOOL DdeKeepStringHandle(DWORD, HSZ);
    HDDEDATA DdeNameService(DWORD, HSZ, HSZ, UINT);
    BOOL DdePostAdvise(DWORD, HSZ, HSZ);
    UINT DdeQueryConvInfo(HCONV, DWORD, PCONVINFO);
    HCONV DdeQueryNextServer(HCONVLIST, HCONV);
    DWORD DdeQueryStringA(DWORD, HSZ, LPSTR, DWORD, int);
    DWORD DdeQueryStringW(DWORD, HSZ, LPWSTR, DWORD, int);
    HCONV DdeReconnect(HCONV);
    BOOL DdeSetUserHandle(HCONV, DWORD, DWORD_PTR);
    BOOL DdeUnaccessData(HDDEDATA);
    BOOL DdeUninitialize(DWORD);
}

const TCHAR[]
    SZDDESYS_TOPIC         = "System",
    SZDDESYS_ITEM_TOPICS   = "Topics",
    SZDDESYS_ITEM_SYSITEMS = "SysItems",
    SZDDESYS_ITEM_RTNMSG   = "ReturnMessage",
    SZDDESYS_ITEM_STATUS   = "Status",
    SZDDESYS_ITEM_FORMATS  = "Formats",
    SZDDESYS_ITEM_HELP     = "Help",
    SZDDE_ITEM_ITEMLIST    = "TopicItemList";

version (Unicode) {
    alias DdeCreateStringHandleW DdeCreateStringHandle;
    alias DdeInitializeW DdeInitialize;
    alias DdeQueryStringW DdeQueryString;
} else {
    alias DdeCreateStringHandleA DdeCreateStringHandle;
    alias DdeInitializeA DdeInitialize;
    alias DdeQueryStringA DdeQueryString;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_dhcpcsdk.d)
 */
module core.sys.windows.dhcpcsdk;
version (Windows):

private import core.sys.windows.w32api, core.sys.windows.windef;

/*static assert (_WIN32_WINNT >= 0x500,
"core.sys.windows.dhcpcsdk is available only if version Windows2000, WindowsXP, Windows2003
or WindowsVista is set");*/

//#if (_WIN32_WINNT >= 0x500)

// FIXME: check type
enum DHCPCAPI_REGISTER_HANDLE_EVENT = 1;
enum DHCPCAPI_REQUEST_PERSISTENT    = 1;
enum DHCPCAPI_REQUEST_SYNCHRONOUS   = 2;

struct DHCPCAPI_CLASSID {
    ULONG  Flags;
    LPBYTE Data;
    ULONG  nBytesData;
}
alias DHCPCAPI_CLASSID* PDHCPCAPI_CLASSID, LPDHCPCAPI_CLASSID;

struct DHCPAPI_PARAMS {
    ULONG  Flags;
    ULONG  OptionId;
    BOOL   IsVendor;
    LPBYTE Data;
    DWORD  nBytesData;
}
alias DHCPAPI_PARAMS* PDHCPAPI_PARAMS, LPDHCPAPI_PARAMS;

struct DHCPCAPI_PARAMS_ARRAY {
    ULONG            nParams;
    LPDHCPAPI_PARAMS Params;
}
alias DHCPCAPI_PARAMS_ARRAY* PDHCPCAPI_PARAMS_ARRAY, LPDHCPCAPI_PARAMS_ARRAY;

extern (Windows) {
    void DhcpCApiCleanup();
    DWORD DhcpCApiInitialize(LPDWORD);
    DWORD DhcpDeRegisterParamChange(DWORD, LPVOID, LPVOID);
    DWORD DhcpRegisterParamChange(DWORD, LPVOID, PWSTR, LPDHCPCAPI_CLASSID,
      DHCPCAPI_PARAMS_ARRAY, LPVOID);
    DWORD DhcpRemoveDNSRegistrations();
    DWORD DhcpUndoRequestParams(DWORD, LPVOID, LPWSTR, LPWSTR);
}

//#endif // (_WIN32_WINNT >= 0x500)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_dlgs.d)
 */
module core.sys.windows.dlgs;
version (Windows):

private import core.sys.windows.windef;

enum : ushort {
    FILEOPENORD      = 1536,
    MULTIFILEOPENORD = 1537,
    PRINTDLGORD      = 1538,
    PRNSETUPDLGORD   = 1539,
    FINDDLGORD       = 1540,
    REPLACEDLGORD    = 1541,
    FONTDLGORD       = 1542,
    FORMATDLGORD31   = 1543,
    FORMATDLGORD30   = 1544,
    PAGESETUPDLGORD  = 1546
}

enum : int {
    ctlFirst = 0x400,
    ctlLast  = 0x4ff,
    chx1     = 0x410,
    chx2     = 0x411,
    chx3     = 0x412,
    chx4     = 0x413,
    chx5     = 0x414,
    chx6     = 0x415,
    chx7     = 0x416,
    chx8     = 0x417,
    chx9     = 0x418,
    chx10    = 0x419,
    chx11    = 0x41a,
    chx12    = 0x41b,
    chx13    = 0x41c,
    chx14    = 0x41d,
    chx15    = 0x41e,
    chx16    = 0x41f,
    cmb1     = 0x470,
    cmb2     = 0x471,
    cmb3     = 0x472,
    cmb4     = 0x473,
    cmb5     = 0x474,
    cmb6     = 0x475,
    cmb7     = 0x476,
    cmb8     = 0x477,
    cmb9     = 0x478,
    cmb10    = 0x479,
    cmb11    = 0x47a,
    cmb12    = 0x47b,
    cmb13    = 0x47c,
    cmb14    = 0x47d,
    cmb15    = 0x47e,
    cmb16    = 0x47f,
    edt1     = 0x480,
    edt2     = 0x481,
    edt3     = 0x482,
    edt4     = 0x483,
    edt5     = 0x484,
    edt6     = 0x485,
    edt7     = 0x486,
    edt8     = 0x487,
    edt9     = 0x488,
    edt10    = 0x489,
    edt11    = 0x48a,
    edt12    = 0x48b,
    edt13    = 0x48c,
    edt14    = 0x48d,
    edt15    = 0x48e,
    edt16    = 0x48f,
    frm1     = 0x434,
    frm2     = 0x435,
    frm3     = 0x436,
    frm4     = 0x437,
    grp1     = 0x430,
    grp2     = 0x431,
    grp3     = 0x432,
    grp4     = 0x433,
    ico1     = 0x43c,
    ico2     = 0x43d,
    ico3     = 0x43e,
    ico4     = 0x43f,
    lst1     = 0x460,
    lst2     = 0x461,
    lst3     = 0x462,
    lst4     = 0x463,
    lst5     = 0x464,
    lst6     = 0x465,
    lst7     = 0x466,
    lst8     = 0x467,
    lst9     = 0x468,
    lst10    = 0x469,
    lst11    = 0x46a,
    lst12    = 0x46b,
    lst13    = 0x46c,
    lst14    = 0x46d,
    lst15    = 0x46e,
    lst16    = 0x46f,
    psh1     = 0x400,
    psh2     = 0x401,
    psh3     = 0x402,
    psh4     = 0x403,
    psh5     = 0x404,
    psh6     = 0x405,
    psh7     = 0x406,
    psh8     = 0x407,
    psh9     = 0x408,
    psh10    = 0x409,
    psh11    = 0x40a,
    psh12    = 0x40b,
    psh13    = 0x40c,
    psh14    = 0x40d,
    psh15    = 0x40e,
    pshHelp  = 0x40e,
    psh16    = 0x40f,
    rad1     = 0x420,
    rad2     = 0x421,
    rad3     = 0x422,
    rad4     = 0x423,
    rad5     = 0x424,
    rad6     = 0x425,
    rad7     = 0x426,
    rad8     = 0x427,
    rad9     = 0x428,
    rad10    = 0x429,
    rad11    = 0x42a,
    rad12    = 0x42b,
    rad13    = 0x42c,
    rad14    = 0x42d,
    rad15    = 0x42e,
    rad16    = 0x42f,
    rct1     = 0x438,
    rct2     = 0x439,
    rct3     = 0x43a,
    rct4     = 0x43b,
    scr1     = 0x490,
    scr2     = 0x491,
    scr3     = 0x492,
    scr4     = 0x493,
    scr5     = 0x494,
    scr6     = 0x495,
    scr7     = 0x496,
    scr8     = 0x497,
    stc1     = 0x440,
    stc2     = 0x441,
    stc3     = 0x442,
    stc4     = 0x443,
    stc5     = 0x444,
    stc6     = 0x445,
    stc7     = 0x446,
    stc8     = 0x447,
    stc9     = 0x448,
    stc10    = 0x449,
    stc11    = 0x44a,
    stc12    = 0x44b,
    stc13    = 0x44c,
    stc14    = 0x44d,
    stc15    = 0x44e,
    stc16    = 0x44f,
    stc17    = 0x450,
    stc18    = 0x451,
    stc19    = 0x452,
    stc20    = 0x453,
    stc21    = 0x454,
    stc22    = 0x455,
    stc23    = 0x456,
    stc24    = 0x457,
    stc25    = 0x458,
    stc26    = 0x459,
    stc27    = 0x45a,
    stc28    = 0x45b,
    stc29    = 0x45c,
    stc30    = 0x45d,
    stc31    = 0x45e,
    stc32    = 0x45f
}

struct CRGB {
    ubyte bRed;
    ubyte bGreen;
    ubyte bBlue;
    ubyte bExtra;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * This module provides OS specific helper function for DLL support
 *
 * Copyright: Copyright Digital Mars 2010 - 2012.
 * License: Distributed under the
 *      $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0).
 *    (See accompanying file LICENSE)
 * Authors:   Rainer Schuetze
 * Source: $(DRUNTIMESRC src/core/sys/windows/_dll.d)
 */

/* NOTE: This file has been patched from the original DMD distribution to
 * work with the GDC compiler.
 */
module core.sys.windows.dll;
version (Windows):

import core.sys.windows.winbase;
import core.sys.windows.winnt;
import core.stdc.string;
import core.runtime;

public import core.sys.windows.threadaux;

///////////////////////////////////////////////////////////////////
// support fixing implicit TLS for dynamically loaded DLLs on Windows XP

// in this special case, we have to treat _tlsstart and _tlsend as non-TLS variables
//  as they are used to simulate TLS when it is not set up under XP. In this case we must
//  not access tls_array[tls_index] as needed for thread local _tlsstart and _tlsend
extern (C)
{
        version (MinGW)
        {
            extern __gshared void* _tls_start;
            extern __gshared void* _tls_end;
            extern __gshared void* __xl_a;

            alias _tls_start _tlsstart;
            alias _tls_end   _tlsend;
            alias __xl_a     _tls_callbacks_a;
        }
        else version (Win32)
    {
        version (CRuntime_DigitalMars)
        {
            extern __gshared byte  _tlsstart;
            extern __gshared byte  _tlsend;
            extern __gshared void* _tls_callbacks_a;
        }
        else version (CRuntime_Microsoft)
        {
            extern __gshared byte  _tls_start;
            extern __gshared byte  _tls_end;
            extern __gshared void*  __xl_a;
            alias _tls_start _tlsstart;
            alias _tls_end   _tlsend;
            alias __xl_a     _tls_callbacks_a;
        }
        extern __gshared int   _tls_index;
    }
}

extern (C) // rt.minfo
{
    void rt_moduleTlsCtor();
    void rt_moduleTlsDtor();
}

private:
version (Win32)
{
struct dll_aux
{
    // don't let symbols leak into other modules
    struct LdrpTlsListEntry
    {
        LdrpTlsListEntry* next;
        LdrpTlsListEntry* prev;
        void* tlsstart;
        void* tlsend;
        void* ptr_tlsindex;
        void* callbacks;
        void* zerofill;
        int   tlsindex;
    }

    alias fnRtlAllocateHeap = extern(Windows)
    void* function(void* HeapHandle, uint Flags, size_t Size) nothrow;

    // find a code sequence and return the address after the sequence
    static void* findCodeSequence( void* adr, int len, ref ubyte[] pattern ) nothrow
    {
        if ( !adr )
            return null;

        ubyte* code = cast(ubyte*) adr;
        for ( int p = 0; p < len; p++ )
        {
            if ( code[ p .. p + pattern.length ] == pattern[ 0 .. $ ] )
            {
                ubyte* padr = code + p + pattern.length;
                return padr;
            }
        }
        return null;
    }

    // find a code sequence and return the (relative) address that follows
    static void* findCodeReference( void* adr, int len, ref ubyte[] pattern, bool relative ) nothrow
    {
        if ( !adr )
            return null;

        ubyte* padr = cast(ubyte*) findCodeSequence( adr, len, pattern );
        if ( padr )
        {
            if ( relative )
                return padr + 4 + *cast(int*) padr;
            return *cast(void**) padr;
        }
        return null;
    }

    // crawl through ntdll to find function _LdrpAllocateTls@0 and references
    //  to _LdrpNumberOfTlsEntries, _NtdllBaseTag and _LdrpTlsList
    // LdrInitializeThunk
    // -> _LdrpInitialize@12
    // -> _LdrpInitializeThread@4
    // -> _LdrpAllocateTls@0
    // -> je chunk
    //     _LdrpNumberOfTlsEntries - number of entries in TlsList
    //     _NtdllBaseTag           - tag used for RtlAllocateHeap
    //     _LdrpTlsList            - root of the double linked list with TlsList entries

    static __gshared int* pNtdllBaseTag; // remembered for reusage in addTlsData

    static __gshared ubyte[] jmp_LdrpInitialize = [ 0x33, 0xED, 0xE9 ]; // xor ebp,ebp; jmp _LdrpInitialize
    static __gshared ubyte[] jmp__LdrpInitialize = [ 0x5D, 0xE9 ]; // pop ebp; jmp __LdrpInitialize
    static __gshared ubyte[] jmp__LdrpInitialize_xp64 = [ 0x5D, 0x90, 0x90, 0x90, 0x90, 0x90 ]; // pop ebp; nop; nop; nop; nop; nop;
    static __gshared ubyte[] call_LdrpInitializeThread = [ 0xFF, 0x75, 0x08, 0xE8 ]; // push [ebp+8]; call _LdrpInitializeThread
    static __gshared ubyte[] call_LdrpAllocateTls = [ 0x00, 0x00, 0xE8 ]; // jne 0xc3; call _LdrpAllocateTls
    static __gshared ubyte[] call_LdrpAllocateTls_svr03 = [ 0x65, 0xfc, 0x00, 0xE8 ]; // and [ebp+fc], 0; call _LdrpAllocateTls
    static __gshared ubyte[] jne_LdrpAllocateTls = [ 0x0f, 0x85 ]; // jne body_LdrpAllocateTls
    static __gshared ubyte[] mov_LdrpNumberOfTlsEntries = [ 0x8B, 0x0D ]; // mov ecx, _LdrpNumberOfTlsEntries
    static __gshared ubyte[] mov_NtdllBaseTag = [ 0x51, 0x8B, 0x0D ]; // push ecx; mov ecx, _NtdllBaseTag
    static __gshared ubyte[] mov_NtdllBaseTag_srv03 = [ 0x50, 0xA1 ]; // push eax; mov eax, _NtdllBaseTag
    static __gshared ubyte[] mov_LdrpTlsList = [ 0x8B, 0x3D ]; // mov edi, _LdrpTlsList

    static LdrpTlsListEntry* addTlsListEntry( void** peb, void* tlsstart, void* tlsend, void* tls_callbacks_a, int* tlsindex ) nothrow
    {
        HANDLE hnd = GetModuleHandleA( "NTDLL" );
        assert( hnd, "cannot get module handle for ntdll" );
        ubyte* fn = cast(ubyte*) GetProcAddress( hnd, "LdrInitializeThunk" );
        assert( fn, "cannot find LdrInitializeThunk in ntdll" );

        void* pLdrpInitialize = findCodeReference( fn, 20, jmp_LdrpInitialize, true );
        void* p_LdrpInitialize = findCodeReference( pLdrpInitialize, 40, jmp__LdrpInitialize, true );
        if ( !p_LdrpInitialize )
            p_LdrpInitialize = findCodeSequence( pLdrpInitialize, 40, jmp__LdrpInitialize_xp64 );
        void* pLdrpInitializeThread = findCodeReference( p_LdrpInitialize, 200, call_LdrpInitializeThread, true );
        void* pLdrpAllocateTls = findCodeReference( pLdrpInitializeThread, 40, call_LdrpAllocateTls, true );
        if (!pLdrpAllocateTls)
            pLdrpAllocateTls = findCodeReference( pLdrpInitializeThread, 100, call_LdrpAllocateTls_svr03, true );
        void* pBodyAllocateTls = findCodeReference( pLdrpAllocateTls, 40, jne_LdrpAllocateTls, true );

        int* pLdrpNumberOfTlsEntries = cast(int*) findCodeReference( pBodyAllocateTls, 60, mov_LdrpNumberOfTlsEntries, false );
        pNtdllBaseTag = cast(int*) findCodeReference( pBodyAllocateTls, 30, mov_NtdllBaseTag, false );
        if (!pNtdllBaseTag)
            pNtdllBaseTag = cast(int*) findCodeReference( pBodyAllocateTls, 30, mov_NtdllBaseTag_srv03, false );
        LdrpTlsListEntry* pLdrpTlsList = cast(LdrpTlsListEntry*)findCodeReference( pBodyAllocateTls, 80, mov_LdrpTlsList, false );

        if ( !pLdrpNumberOfTlsEntries || !pNtdllBaseTag || !pLdrpTlsList )
            return null;

        fnRtlAllocateHeap fnAlloc = cast(fnRtlAllocateHeap) GetProcAddress( hnd, "RtlAllocateHeap" );
        if ( !fnAlloc )
            return null;

        // allocate new TlsList entry (adding 0xC0000 to the tag is obviously a flag also usesd by
        //  the nt-loader, could be the result of HEAP_MAKE_TAG_FLAGS(0,HEAP_NO_SERIALIZE|HEAP_GROWABLE)
        //  but this is not documented in the msdn entry for RtlAlloateHeap
        void* heap = peb[6];
        LdrpTlsListEntry* entry = cast(LdrpTlsListEntry*) (*fnAlloc)( heap, *pNtdllBaseTag | 0xc0000, LdrpTlsListEntry.sizeof );
        if ( !entry )
            return null;

        // fill entry
        entry.tlsstart = tlsstart;
        entry.tlsend = tlsend;
        entry.ptr_tlsindex = tlsindex;
        entry.callbacks = tls_callbacks_a;
        entry.zerofill = null;
        entry.tlsindex = *pLdrpNumberOfTlsEntries;

        // and add it to the end of TlsList
        *tlsindex = *pLdrpNumberOfTlsEntries;
        entry.next = pLdrpTlsList;
        entry.prev = pLdrpTlsList.prev;
        pLdrpTlsList.prev.next = entry;
        pLdrpTlsList.prev = entry;
        (*pLdrpNumberOfTlsEntries)++;

        return entry;
    }

    // reallocate TLS array and create a copy of the TLS data section
    static bool addTlsData( void** teb, void* tlsstart, void* tlsend, int tlsindex ) nothrow
    {
        HANDLE hnd = GetModuleHandleA( "NTDLL" );
        assert( hnd, "cannot get module handle for ntdll" );

        fnRtlAllocateHeap fnAlloc = cast(fnRtlAllocateHeap) GetProcAddress( hnd, "RtlAllocateHeap" );
        if ( !fnAlloc || !pNtdllBaseTag )
            return false;

        void** peb = cast(void**) teb[12];
        void* heap = peb[6];

        auto sz = tlsend - tlsstart;
        void* tlsdata = cast(void*) (*fnAlloc)( heap, *pNtdllBaseTag | 0xc0000, sz );
        if ( !tlsdata )
            return false;

        // no relocations! not even self-relocations. Windows does not do them.
        core.stdc.string.memcpy( tlsdata, tlsstart, sz );

        // create copy of tls pointer array
        void** array = cast(void**) (*fnAlloc)( heap, *pNtdllBaseTag | 0xc0000, (tlsindex + 1) * (void*).sizeof );
        if ( !array )
            return false;

        if ( tlsindex > 0 && teb[11] )
            core.stdc.string.memcpy( array, teb[11], tlsindex * (void*).sizeof);
        array[tlsindex] = tlsdata;
        teb[11] = cast(void*) array;

        // let the old array leak, in case a oncurrent thread is still relying on it
        return true;
    }

    alias bool BOOLEAN;

    struct UNICODE_STRING
    {
        short Length;
        short MaximumLength;
        wchar* Buffer;
    }

    struct LIST_ENTRY
    {
        LIST_ENTRY* next;
        LIST_ENTRY* prev;
    }

    // the following structures can be found here: http://undocumented.ntinternals.net/
    // perhaps this should be same as LDR_DATA_TABLE_ENTRY, which is introduced with PEB_LDR_DATA
    struct LDR_MODULE
    {
        LIST_ENTRY      InLoadOrderModuleList;
        LIST_ENTRY      InMemoryOrderModuleList;
        LIST_ENTRY      InInitializationOrderModuleList;
        PVOID           BaseAddress;
        PVOID           EntryPoint;
        SIZE_T          SizeOfImage;
        UNICODE_STRING  FullDllName;
        UNICODE_STRING  BaseDllName;
        ULONG           Flags;
        SHORT           LoadCount;
        SHORT           TlsIndex;
        LIST_ENTRY      HashTableEntry;
        ULONG           TimeDateStamp;
    }

    struct PEB_LDR_DATA
    {
        ULONG           Length;
        BOOLEAN         Initialized;
        PVOID           SsHandle;
        LIST_ENTRY      InLoadOrderModuleList;
        LIST_ENTRY      InMemoryOrderModuleList;
        LIST_ENTRY      InInitializationOrderModuleList;
    }

    static LDR_MODULE* findLdrModule( HINSTANCE hInstance, void** peb ) nothrow
    {
        PEB_LDR_DATA* ldrData = cast(PEB_LDR_DATA*) peb[3];
        LIST_ENTRY* root = &ldrData.InLoadOrderModuleList;
        for (LIST_ENTRY* entry = root.next; entry != root; entry = entry.next)
        {
            LDR_MODULE *ldrMod = cast(LDR_MODULE*) entry;
            if (ldrMod.BaseAddress == hInstance)
                return ldrMod;
        }
        return null;
    }

    static bool setDllTlsUsage( HINSTANCE hInstance, void** peb ) nothrow
    {
        LDR_MODULE *thisMod = findLdrModule( hInstance, peb );
        if ( !thisMod )
            return false;

        thisMod.TlsIndex = -1;  // uses TLS (not the index itself)
        thisMod.LoadCount = -1; // never unload
        return true;
    }
}
}

public:
/* *****************************************************
 * Fix implicit thread local storage for the case when a DLL is loaded
 * dynamically after process initialization.
 * The link time variables are passed to allow placing this function into
 * an RTL DLL itself.
 * The problem is described in Bugzilla 3342 and
 * http://www.nynaeve.net/?p=187, to quote from the latter:
 *
 * "When a DLL using implicit TLS is loaded, because the loader doesn't process the TLS
 *  directory, the _tls_index value is not initialized by the loader, nor is there space
 *  allocated for module's TLS data in the ThreadLocalStoragePointer arrays of running
 *  threads. The DLL continues to load, however, and things will appear to work... until the
 *  first access to a __declspec(thread) variable occurs, that is."
 *
 * _tls_index is initialized by the compiler to 0, so we can use this as a test.
 */
bool dll_fixTLS( HINSTANCE hInstance, void* tlsstart, void* tlsend, void* tls_callbacks_a, int* tlsindex ) nothrow
{
    version (Win64)
        return true;                // fixed
    else version (Win32)
    {
    /* If the OS has allocated a TLS slot for us, we don't have to do anything
     * tls_index 0 means: the OS has not done anything, or it has allocated slot 0
     * Vista and later Windows systems should do this correctly and not need
     * this function.
     */
    if ( *tlsindex != 0 )
        return true;

    void** peb;
    asm pure nothrow @nogc
    {
        mov EAX,FS:[0x30];
        mov peb, EAX;
    }
    dll_aux.LDR_MODULE *ldrMod = dll_aux.findLdrModule( hInstance, peb );
    if ( !ldrMod )
        return false; // not in module list, bail out
    if ( ldrMod.TlsIndex != 0 )
        return true;  // the OS has already setup TLS

    dll_aux.LdrpTlsListEntry* entry = dll_aux.addTlsListEntry( peb, tlsstart, tlsend, tls_callbacks_a, tlsindex );
    if ( !entry )
        return false;

    scope (failure) assert(0); // enforce nothrow, Bugzilla 13561

    if ( !enumProcessThreads(
        function (uint id, void* context) nothrow {
            dll_aux.LdrpTlsListEntry* entry = cast(dll_aux.LdrpTlsListEntry*) context;
            return dll_aux.addTlsData( getTEB( id ), entry.tlsstart, entry.tlsend, entry.tlsindex );
        }, entry ) )
        return false;

    ldrMod.TlsIndex = -1;  // flag TLS usage (not the index itself)
    ldrMod.LoadCount = -1; // prevent unloading of the DLL,
                           // since XP does not keep track of used TLS entries
    return true;
    }
}

// fixup TLS storage, initialize runtime and attach to threads
// to be called from DllMain with reason DLL_PROCESS_ATTACH
bool dll_process_attach( HINSTANCE hInstance, bool attach_threads,
                         void* tlsstart, void* tlsend, void* tls_callbacks_a, int* tlsindex )
{
    version (Win32)
    {
        if ( !dll_fixTLS( hInstance, tlsstart, tlsend, tls_callbacks_a, tlsindex ) )
            return false;
    }

    Runtime.initialize();

    if ( !attach_threads )
        return true;

    // attach to all other threads
    return enumProcessThreads(
        function (uint id, void* context) {
            if ( !thread_findByAddr( id ) )
            {
                // if the OS has not prepared TLS for us, don't attach to the thread
                if ( GetTlsDataAddress( id ) )
                {
                    thread_attachByAddr( id );
                    thread_moduleTlsCtor( id );
                }
            }
            return true;
        }, null );
}

// same as above, but only usable if druntime is linked statically
bool dll_process_attach( HINSTANCE hInstance, bool attach_threads = true )
{
    version (Win64)
    {
        return dll_process_attach( hInstance, attach_threads,
                                   null, null, null, null );
    }
    else version (Win32)
    {
        return dll_process_attach( hInstance, attach_threads,
                                   &_tlsstart, &_tlsend, &_tls_callbacks_a, &_tls_index );
    }
}

// to be called from DllMain with reason DLL_PROCESS_DETACH
void dll_process_detach( HINSTANCE hInstance, bool detach_threads = true )
{
    // detach from all other threads
    if ( detach_threads )
        enumProcessThreads(
            function (uint id, void* context) {
                if ( id != GetCurrentThreadId() && thread_findByAddr( id ) )
                {
                    thread_moduleTlsDtor( id );
                    thread_detachByAddr( id );
                }
                return true;
            }, null );

    Runtime.terminate();
}

/* Make sure that tlsCtorRun is itself a tls variable
 */
static bool tlsCtorRun;
static this() { tlsCtorRun = true; }
static ~this() { tlsCtorRun = false; }

// to be called from DllMain with reason DLL_THREAD_ATTACH
bool dll_thread_attach( bool attach_thread = true, bool initTls = true )
{
    // if the OS has not prepared TLS for us, don't attach to the thread
    //  (happened when running under x64 OS)
    if ( !GetTlsDataAddress( GetCurrentThreadId() ) )
        return false;
    if ( !thread_findByAddr( GetCurrentThreadId() ) )
    {
        // only attach to thread and initalize it if it is not in the thread list (so it's not created by "new Thread")
        if ( attach_thread )
            thread_attachThis();
        if ( initTls && !tlsCtorRun ) // avoid duplicate calls
            rt_moduleTlsCtor();
    }
    return true;
}

// to be called from DllMain with reason DLL_THREAD_DETACH
bool dll_thread_detach( bool detach_thread = true, bool exitTls = true )
{
    // if the OS has not prepared TLS for us, we did not attach to the thread
    if ( !GetTlsDataAddress( GetCurrentThreadId() ) )
         return false;
    if ( thread_findByAddr( GetCurrentThreadId() ) )
    {
        if ( exitTls && tlsCtorRun ) // avoid dtors to be run twice
            rt_moduleTlsDtor();
        if ( detach_thread )
            thread_detachThis();
    }
    return true;
}

/// A simple mixin to provide a $(D DllMain) which calls the necessary
/// runtime initialization and termination functions automatically.
///
/// Instead of writing a custom $(D DllMain), simply write:
///
/// ---
/// mixin SimpleDllMain;
/// ---
mixin template SimpleDllMain()
{
    import core.sys.windows.windef : HINSTANCE;

    extern(Windows)
    bool DllMain(HINSTANCE hInstance, uint ulReason, void* reserved)
    {
        import core.sys.windows.winnt;
        import core.sys.windows.dll :
            dll_process_attach, dll_process_detach,
            dll_thread_attach, dll_thread_detach;
        switch (ulReason)
        {
            default: assert(0);
            case DLL_PROCESS_ATTACH:
                return dll_process_attach( hInstance, true );

            case DLL_PROCESS_DETACH:
                dll_process_detach( hInstance, true );
                return true;

            case DLL_THREAD_ATTACH:
                return dll_thread_attach( true, true );

            case DLL_THREAD_DETACH:
                return dll_thread_detach( true, true );
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_docobj.d)
 */
module core.sys.windows.docobj;
version (Windows):

private import core.sys.windows.basetyps, core.sys.windows.oaidl, core.sys.windows.objidl, core.sys.windows.oleidl,
  core.sys.windows.unknwn, core.sys.windows.windef, core.sys.windows.wtypes;

// FIXME: remove inherited methods from interface definitions

enum {
    OLECMDERR_E_UNKNOWNGROUP = -2147221244,
    OLECMDERR_E_CANCELED     = -2147221245,
    OLECMDERR_E_NOHELP       = -2147221246,
    OLECMDERR_E_DISABLED     = -2147221247,
    OLECMDERR_E_NOTSUPPORTED = -2147221248
}

enum OLECMDID {
    OLECMDID_OPEN = 1,
    OLECMDID_NEW = 2,
    OLECMDID_SAVE = 3,
    OLECMDID_SAVEAS = 4,
    OLECMDID_SAVECOPYAS = 5,
    OLECMDID_PRINT = 6,
    OLECMDID_PRINTPREVIEW = 7,
    OLECMDID_PAGESETUP = 8,
    OLECMDID_SPELL = 9,
    OLECMDID_PROPERTIES = 10,
    OLECMDID_CUT = 11,
    OLECMDID_COPY = 12,
    OLECMDID_PASTE = 13,
    OLECMDID_PASTESPECIAL = 14,
    OLECMDID_UNDO = 15,
    OLECMDID_REDO = 16,
    OLECMDID_SELECTALL = 17,
    OLECMDID_CLEARSELECTION = 18,
    OLECMDID_ZOOM = 19,
    OLECMDID_GETZOOMRANGE = 20,
    OLECMDID_UPDATECOMMANDS = 21,
    OLECMDID_REFRESH = 22,
    OLECMDID_STOP = 23,
    OLECMDID_HIDETOOLBARS = 24,
    OLECMDID_SETPROGRESSMAX = 25,
    OLECMDID_SETPROGRESSPOS = 26,
    OLECMDID_SETPROGRESSTEXT = 27,
    OLECMDID_SETTITLE = 28,
    OLECMDID_SETDOWNLOADSTATE = 29,
    OLECMDID_STOPDOWNLOAD = 30
}

enum OLECMDF {
    OLECMDF_SUPPORTED = 1,
    OLECMDF_ENABLED = 2,
    OLECMDF_LATCHED = 4,
    OLECMDF_NINCHED = 8
}

enum OLECMDEXECOPT {
    OLECMDEXECOPT_DODEFAULT = 0,
    OLECMDEXECOPT_PROMPTUSER = 1,
    OLECMDEXECOPT_DONTPROMPTUSER = 2,
    OLECMDEXECOPT_SHOWHELP = 3
}

struct OLECMDTEXT {
    DWORD cmdtextf;
    ULONG cwActual;
    ULONG cwBuf;
    wchar[1] rgwz = 0;
}

struct OLECMD {
    ULONG cmdID;
    DWORD cmdf;
}

alias IOleInPlaceSite LPOLEINPLACESITE;
alias IEnumOleDocumentViews LPENUMOLEDOCUMENTVIEWS;

extern (C) extern const IID
    IID_IContinueCallback,
    IID_IEnumOleDocumentViews,
    IID_IPrint,
    IID_IOleDocumentView,
    IID_IOleDocument,
    IID_IOleCommandTarget,
    IID_IOleDocumentSite;


interface IOleDocumentView : IUnknown {
    HRESULT SetInPlaceSite(LPOLEINPLACESITE);
    HRESULT GetInPlaceSite(LPOLEINPLACESITE*);
    HRESULT GetDocument(IUnknown*);
    HRESULT SetRect(LPRECT);
    HRESULT GetRect(LPRECT);
    HRESULT SetRectComplex(LPRECT, LPRECT, LPRECT, LPRECT);
    HRESULT Show(BOOL);
    HRESULT UIActivate(BOOL);
    HRESULT Open();
    HRESULT Close(DWORD);
    HRESULT SaveViewState(IStream);
    HRESULT ApplyViewState(IStream);
    HRESULT Clone(LPOLEINPLACESITE, IOleDocumentView*);
}

interface IEnumOleDocumentViews : IUnknown {
      HRESULT Next(ULONG, IOleDocumentView, ULONG*);
      HRESULT Skip(ULONG);
      HRESULT Reset();
      HRESULT Clone(IEnumOleDocumentViews*);
}

interface IOleDocument : IUnknown {
    HRESULT CreateView(LPOLEINPLACESITE, IStream, DWORD, IOleDocumentView*);
    HRESULT GetDocMiscStatus(DWORD*);
    HRESULT EnumViews(LPENUMOLEDOCUMENTVIEWS*, IOleDocumentView*);
}

interface IOleCommandTarget : IUnknown {
    HRESULT QueryStatus(const(GUID)*, ULONG, OLECMD*, OLECMDTEXT*);
    HRESULT Exec(const(GUID)*, DWORD, DWORD, VARIANTARG*, VARIANTARG*);
}

interface IOleDocumentSite : IUnknown {
    HRESULT ActivateMe(IOleDocumentView);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_errorrep.d)
 */
module core.sys.windows.errorrep;
version (Windows):

version (ANSI) {} else version = Unicode;

private import core.sys.windows.w32api, core.sys.windows.windef;

static assert (_WIN32_WINNT >= 0x501,
    "core.sys.windows.errorrep is available only if version WindowsXP, Windows2003 "
    ~ "or WindowsVista is set");

enum EFaultRepRetVal {
    frrvOk,
    frrvOkManifest,
    frrvOkQueued,
    frrvErr,
    frrvErrNoDW,
    frrvErrTimeout,
    frrvLaunchDebugger,
    frrvOkHeadless // = 7
}

extern (Windows) {
    BOOL AddERExcludedApplicationA(LPCSTR);
    BOOL AddERExcludedApplicationW(LPCWSTR);
    EFaultRepRetVal ReportFault(LPEXCEPTION_POINTERS, DWORD);
}

version (Unicode) {
    alias AddERExcludedApplicationW AddERExcludedApplication;
} else {
    alias AddERExcludedApplicationA AddERExcludedApplication;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_exdisp.d)
 */
module core.sys.windows.exdisp;
version (Windows):

import core.sys.windows.docobj, core.sys.windows.oaidl, core.sys.windows.ocidl;
private import core.sys.windows.basetyps, core.sys.windows.windef, core.sys.windows.wtypes;


enum BrowserNavConstants {
    navOpenInNewWindow = 0x01,
    navNoHistory       = 0x02,
    navNoReadFromCache = 0x04,
    navNoWriteTocache  = 0x08,
    navAllowAutosearch = 0x10,
    navBrowserBar      = 0x20,
    navHyperLink       = 0x40
}

interface IWebBrowser : IDispatch {
    HRESULT GoBack();
    HRESULT GoForward();
    HRESULT GoHome();
    HRESULT GoSearch();
    HRESULT Navigate(BSTR, VARIANT*, VARIANT*, VARIANT*, VARIANT*);
    HRESULT Refresh();
    HRESULT Refresh2(VARIANT*);
    HRESULT Stop();
    HRESULT get_Application(IDispatch* ppDisp);
    HRESULT get_Parent(IDispatch* ppDisp);
    HRESULT get_Container(IDispatch* ppDisp);
    HRESULT get_Document(IDispatch* ppDisp);
    HRESULT get_TopLevelContainer(VARIANT_BOOL*);
    HRESULT get_Type(BSTR*);
    HRESULT get_Left(LONG*);
    HRESULT put_Left(LONG);
    HRESULT get_Top(LONG*);
    HRESULT put_Top(LONG);
    HRESULT get_Width(LONG*);
    HRESULT put_Width(LONG);
    HRESULT get_Height(LONG*);
    HRESULT put_Height(LONG);
    HRESULT get_LocationName(BSTR*);
    HRESULT get_LocationURL(BSTR*);
    HRESULT get_Busy(VARIANT_BOOL*);
}

interface IWebBrowserApp : IWebBrowser {
    HRESULT Quit();
    HRESULT ClientToWindow(int*, int*);
    HRESULT PutProperty(BSTR, VARIANT);
    HRESULT GetProperty(BSTR, VARIANT*);
    HRESULT get_Name(BSTR*);
    HRESULT get_HWND(LONG*);
    HRESULT get_FullName(BSTR*);
    HRESULT get_Path(BSTR*);
    HRESULT get_Visible(VARIANT_BOOL*);
    HRESULT put_Visible(VARIANT_BOOL);
    HRESULT get_StatusBar(VARIANT_BOOL*);
    HRESULT put_StatusBar(VARIANT_BOOL);
    HRESULT get_StatusText(BSTR*);
    HRESULT put_StatusText(BSTR);
    HRESULT get_ToolBar(int*);
    HRESULT put_ToolBar(int);
    HRESULT get_MenuBar(VARIANT_BOOL*);
    HRESULT put_MenuBar(VARIANT_BOOL);
    HRESULT get_FullScreen(VARIANT_BOOL*);
    HRESULT put_FullScreen(VARIANT_BOOL);
}

interface IWebBrowser2 : IWebBrowserApp {
    HRESULT Navigate2(VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT*);
    HRESULT QueryStatusWB(OLECMDID, OLECMDF*);
    HRESULT ExecWB(OLECMDID, OLECMDEXECOPT, VARIANT*, VARIANT*);
    HRESULT ShowBrowserBar(VARIANT*, VARIANT*, VARIANT*);
    HRESULT get_ReadyState(READYSTATE*);
    HRESULT get_Offline(VARIANT_BOOL*);
    HRESULT put_Offline(VARIANT_BOOL);
    HRESULT get_Silent(VARIANT_BOOL*);
    HRESULT put_Silent(VARIANT_BOOL);
    HRESULT get_RegistaerAsBrowser(VARIANT_BOOL*);
    HRESULT put_RegisterAsBrowser(VARIANT_BOOL);
    HRESULT get_RegistaerAsDropTarget(VARIANT_BOOL*);
    HRESULT put_RegisterAsDropTarget(VARIANT_BOOL);
    HRESULT get_TheaterMode(VARIANT_BOOL*);
    HRESULT put_TheaterMode(VARIANT_BOOL);
    HRESULT get_AddressBar(VARIANT_BOOL*);
    HRESULT put_AddressBar(VARIANT_BOOL);
    HRESULT get_Resizable(VARIANT_BOOL*);
    HRESULT put_Resizable(VARIANT_BOOL);
}

interface DWebBrowserEvents2 : IDispatch {
    void StatusTextChange(BSTR);
    void ProgressChange(LONG, LONG);
    void CommandStateChange(LONG, VARIANT_BOOL);
    void DownloadBegin();
    void DownloadComplete();
    void TitleChange(BSTR);
    void PropertyChange(BSTR);
    void BeforeNavigate2(IDispatch pDisp, VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT_BOOL*);
    void NewWindow2(IDispatch* ppDisp, VARIANT_BOOL*);
    void NavigateComplete(IDispatch pDisp, VARIANT*);
    void DocumentComplete(IDispatch pDisp, VARIANT*);
    void OnQuit();
    void OnVisible(VARIANT_BOOL);
    void OnToolBar(VARIANT_BOOL);
    void OnMenuBar(VARIANT_BOOL);
    void OnStatusBar(VARIANT_BOOL);
    void OnFullScreen(VARIANT_BOOL);
    void OnTheaterMode(VARIANT_BOOL);
    void WindowSetResizable(VARIANT_BOOL);
    void WindowSetLeft(LONG);
    void WindowSetTop(LONG);
    void WindowSetWidth(LONG);
    void WindowSetHeight(LONG);
    void WindowClosing(VARIANT_BOOL, VARIANT_BOOL*);
    void ClientToHostWindow(LONG*, LONG*);
    void SetSecureLockIcon(LONG);
    void FileDownload(VARIANT_BOOL*);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * Windows API header module
 *
 * Translated from MinGW API for MS-Windows 3.10
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_exdispid.d)
 */
module core.sys.windows.exdispid;
version (Windows):

enum : int {
    DISPID_STATUSTEXTCHANGE = 102,
    DISPID_PROGRESSCHANGE   = 108,
    DISPID_TITLECHANGE      = 113,
    DISPID_BEFORENAVIGATE2  = 250,
    DISPID_NEWWINDOW2       = 251,
    DISPID_DOCUMENTCOMPLETE = 259
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_httpext.d)
 */
module core.sys.windows.httpext;
version (Windows):

/* Comment from MinGW
       httpext.h - Header for ISAPI extensions.

       This file is part of a free library for the Win32 API.

       This library is distributed in the hope that it will be useful,
       but WITHOUT ANY WARRANTY; without even the implied warranty of
       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
*/

private import core.sys.windows.basetsd /+: DECLARE_HANDLE, HANDLE+/;
private import core.sys.windows.windef /+: BOOL, CHAR, DWORD, LPBYTE, LPDWORD+/;
private import core.sys.windows.winnt /+: LPCSTR, LPSTR, LPVOID, PVOID, VOID+/;

enum {
    HSE_VERSION_MAJOR               = 2,
    HSE_VERSION_MINOR               = 0,
    HSE_LOG_BUFFER_LEN              = 80,
    HSE_MAX_EXT_DLL_NAME_LEN        = 256,
    HSE_STATUS_SUCCESS              = 1,
    HSE_STATUS_SUCCESS_AND_KEEP_CONN,
    HSE_STATUS_PENDING,
    HSE_STATUS_ERROR,
    HSE_REQ_BASE                    = 0,
    HSE_REQ_SEND_URL_REDIRECT_RESP,
    HSE_REQ_SEND_URL,
    HSE_REQ_SEND_RESPONSE_HEADER,
    HSE_REQ_DONE_WITH_SESSION,
    HSE_REQ_SEND_RESPONSE_HEADER_EX = 1016,
    HSE_REQ_END_RESERVED            = 1000,
    HSE_TERM_ADVISORY_UNLOAD        = 0x00000001,
    HSE_TERM_MUST_UNLOAD,
    HSE_IO_SYNC                     = 0x00000001,
    HSE_IO_ASYNC,
    HSE_IO_DISCONNECT_AFTER_SEND    = 0x00000004,
    HSE_IO_SEND_HEADERS             = 0x00000008
}

mixin DECLARE_HANDLE!("HCONN");

struct HSE_VERSION_INFO {
    DWORD dwExtensionVersion;
    CHAR[HSE_MAX_EXT_DLL_NAME_LEN] lpszExtensionDesc = 0;
}
alias HSE_VERSION_INFO* LPHSE_VERSION_INFO;

struct EXTENSION_CONTROL_BLOCK {
    DWORD  cbSize = EXTENSION_CONTROL_BLOCK.sizeof;
    DWORD  dwVersion;
    HCONN  ConnID;
    DWORD  dwHttpStatusCode;
    CHAR[HSE_LOG_BUFFER_LEN] lpszLogData = 0;
    LPSTR  lpszMethod;
    LPSTR  lpszQueryString;
    LPSTR  lpszPathInfo;
    LPSTR  lpszPathTranslated;
    DWORD  cbTotalBytes;
    DWORD  cbAvailable;
    LPBYTE lpbData;
    LPSTR  lpszContentType;
    extern (Windows) {
        BOOL function(HCONN, LPSTR, LPVOID, LPDWORD) GetServerVariable;
        BOOL function(HCONN, LPVOID, LPDWORD, DWORD) WriteClient;
        BOOL function(HCONN, LPVOID, LPDWORD) ReadClient;
        BOOL function(HCONN, DWORD, LPVOID, LPDWORD, LPDWORD) ServerSupportFunction;
    }
}
alias EXTENSION_CONTROL_BLOCK* LPEXTENSION_CONTROL_BLOCK;

extern (Windows) {
    alias BOOL function(HSE_VERSION_INFO*) PFN_GETEXTENSIONVERSION;
    alias DWORD function(EXTENSION_CONTROL_BLOCK*) PFN_HTTPEXTENSIONPROC;
    alias BOOL function(DWORD) PFN_TERMINATEEXTENSION;
    alias VOID function(EXTENSION_CONTROL_BLOCK*, PVOID, DWORD, DWORD) PFN_HSE_IO_COMPLETION;
}

struct HSE_TF_INFO {
    PFN_HSE_IO_COMPLETION pfnHseIO;
    PVOID  pContext;
    HANDLE hFile;
    LPCSTR pszStatusCode;
    DWORD  BytesToWrite;
    DWORD  Offset;
    PVOID  pHead;
    DWORD  HeadLength;
    PVOID  pTail;
    DWORD  TailLength;
    DWORD  dwFlags;
}
alias HSE_TF_INFO* LPHSE_TF_INFO;

struct HSE_SEND_HEADER_EX_INFO {
    LPCSTR pszStatus;
    LPCSTR pszHeader;
    DWORD  cchStatus;
    DWORD  cchHeader;
    BOOL   fKeepConn;
}
alias HSE_SEND_HEADER_EX_INFO* LPHSE_SEND_HEADER_EX_INF;

extern (Windows) {
    BOOL GetExtensionVersion(HSE_VERSION_INFO*);
    DWORD HttpExtensionProc(EXTENSION_CONTROL_BLOCK*);
    BOOL TerminateExtension(DWORD);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * Windows API header module
 *
 * Translated from MinGW API for MS-Windows 3.10
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_idispids.d)
 */
module core.sys.windows.idispids;
version (Windows):

enum : int {
    DISPID_AMBIENT_OFFLINEIFNOTCONNECTED = -5501,
    DISPID_AMBIENT_SILENT                = -5502
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_imagehlp.d)
 */
module core.sys.windows.imagehlp;
version (Windows):

version (ANSI) {} else version = Unicode;

/* Comment from MinGW
    NOTE: This strictly does not belong in the Win32 API since it's
    really part of Platform SDK. However, GDB needs it and we might
    as well provide it here.
*/

private import core.sys.windows.winbase, core.sys.windows.windef;

// FIXME: check types of constants

enum API_VERSION_NUMBER = 7;

enum BIND_NO_BOUND_IMPORTS  = 1;
enum BIND_NO_UPDATE         = 2;
enum BIND_ALL_IMAGES        = 4;
enum BIND_CACHE_IMPORT_DLLS = 8;

enum {
    CBA_DEFERRED_SYMBOL_LOAD_START = 1,
    CBA_DEFERRED_SYMBOL_LOAD_COMPLETE,
    CBA_DEFERRED_SYMBOL_LOAD_FAILURE,
    CBA_SYMBOLS_UNLOADED,
    CBA_DUPLICATE_SYMBOL
}

enum CERT_PE_IMAGE_DIGEST_DEBUG_INFO      = 1;
enum CERT_PE_IMAGE_DIGEST_RESOURCES       = 2;
enum CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO = 4;
enum CERT_PE_IMAGE_DIGEST_NON_PE_INFO     = 8;

enum CERT_SECTION_TYPE_ANY = 255;

enum {
    CHECKSUM_SUCCESS = 0,
    CHECKSUM_OPEN_FAILURE,
    CHECKSUM_MAP_FAILURE,
    CHECKSUM_MAPVIEW_FAILURE,
    CHECKSUM_UNICODE_FAILURE
}

enum IMAGE_SEPARATION = 65536;

enum SPLITSYM_REMOVE_PRIVATE    = 1;
enum SPLITSYM_EXTRACT_ALL       = 2;
enum SPLITSYM_SYMBOLPATH_IS_SRC = 4;

enum SYMF_OMAP_GENERATED = 1;
enum SYMF_OMAP_MODIFIED  = 2;

enum SYMOPT_CASE_INSENSITIVE  =  1;
enum SYMOPT_UNDNAME           =  2;
enum SYMOPT_DEFERRED_LOADS    =  4;
enum SYMOPT_NO_CPP            =  8;
//const SYMOPT_LOAD_LINES        = 16;
//const SYMOPT_OMAP_FIND_NEAREST = 32;
public import core.sys.windows.dbghelp_types :
    SYMOPT_DEFERRED_LOAD,
    SYMOPT_FAIL_CRITICAL_ERRORS,
    SYMOPT_LOAD_LINES,
    SYMOPT_DEBUG;

enum UNDNAME_COMPLETE               =     0;
enum UNDNAME_NO_LEADING_UNDERSCORES =     1;
enum UNDNAME_NO_MS_KEYWORDS         =     2;
enum UNDNAME_NO_FUNCTION_RETURNS    =     4;
enum UNDNAME_NO_ALLOCATION_MODEL    =     8;
enum UNDNAME_NO_ALLOCATION_LANGUAGE =    16;
enum UNDNAME_NO_MS_THISTYPE         =    32;
enum UNDNAME_NO_CV_THISTYPE         =    64;
enum UNDNAME_NO_THISTYPE            =    96;
enum UNDNAME_NO_ACCESS_SPECIFIERS   =   128;
enum UNDNAME_NO_THROW_SIGNATURES    =   256;
enum UNDNAME_NO_MEMBER_TYPE         =   512;
enum UNDNAME_NO_RETURN_UDT_MODEL    =  1024;
enum UNDNAME_32_BIT_DECODE          =  2048;
enum UNDNAME_NAME_ONLY              =  4096;
enum UNDNAME_NO_ARGUMENTS           =  8192;
enum UNDNAME_NO_SPECIAL_SYMS        = 16384;

enum IMAGEHLP_STATUS_REASON {
    BindOutOfMemory,
    BindRvaToVaFailed,
    BindNoRoomInImage,
    BindImportModuleFailed,
    BindImportProcedureFailed,
    BindImportModule,
    BindImportProcedure,
    BindForwarder,
    BindForwarderNOT,
    BindImageModified,
    BindExpandFileHeaders,
    BindImageComplete,
    BindMismatchedSymbols,
    BindSymbolsNotUpdated
}

struct LOADED_IMAGE {
    LPSTR                 ModuleName;
    HANDLE                hFile;
    PUCHAR                MappedAddress;
    PIMAGE_NT_HEADERS     FileHeader;
    PIMAGE_SECTION_HEADER LastRvaSection;
    ULONG                 NumberOfSections;
    PIMAGE_SECTION_HEADER Sections;
    ULONG                 Characteristics;
    BOOLEAN               fSystemImage;
    BOOLEAN               fDOSImage;
    LIST_ENTRY            Links;
    ULONG                 SizeOfImage;
}
alias LOADED_IMAGE* PLOADED_IMAGE;

struct IMAGE_DEBUG_INFORMATION {
    LIST_ENTRY                 List;
    DWORD                      Size;
    PVOID                      MappedBase;
    USHORT                     Machine;
    USHORT                     Characteristics;
    DWORD                      CheckSum;
    DWORD                      ImageBase;
    DWORD                      SizeOfImage;
    DWORD                      NumberOfSections;
    PIMAGE_SECTION_HEADER      Sections;
    DWORD                      ExportedNamesSize;
    LPSTR                      ExportedNames;
    DWORD                      NumberOfFunctionTableEntries;
    PIMAGE_FUNCTION_ENTRY      FunctionTableEntries;
    DWORD                      LowestFunctionStartingAddress;
    DWORD                      HighestFunctionEndingAddress;
    DWORD                      NumberOfFpoTableEntries;
    PFPO_DATA                  FpoTableEntries;
    DWORD                      SizeOfCoffSymbols;
    PIMAGE_COFF_SYMBOLS_HEADER CoffSymbols;
    DWORD                      SizeOfCodeViewSymbols;
    PVOID                      CodeViewSymbols;
    LPSTR                      ImageFilePath;
    LPSTR                      ImageFileName;
    LPSTR                      DebugFilePath;
    DWORD                      TimeDateStamp;
    BOOL                       RomImage;
    PIMAGE_DEBUG_DIRECTORY     DebugDirectory;
    DWORD                      NumberOfDebugDirectories;
    DWORD[3]                   Reserved;
}
alias IMAGE_DEBUG_INFORMATION* PIMAGE_DEBUG_INFORMATION;

enum ADDRESS_MODE {
    AddrMode1616,
    AddrMode1632,
    AddrModeReal,
    AddrModeFlat
}

struct ADDRESS {
    DWORD        Offset;
    WORD         Segment;
    ADDRESS_MODE Mode;
}
alias ADDRESS* LPADDRESS;

struct KDHELP {
    DWORD Thread;
    DWORD ThCallbackStack;
    DWORD NextCallback;
    DWORD FramePointer;
    DWORD KiCallUserMode;
    DWORD KeUserCallbackDispatcher;
    DWORD SystemRangeStart;
    DWORD ThCallbackBStore;
    DWORD KiUserExceptionDispatcher;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD[5] Reserved;
}
alias KDHELP* PKDHELP;

struct STACKFRAME {
    ADDRESS  AddrPC;
    ADDRESS  AddrReturn;
    ADDRESS  AddrFrame;
    ADDRESS  AddrStack;
    LPVOID   FuncTableEntry;
    DWORD[4] Params;
    BOOL     Far;
    BOOL     Virtual;
    DWORD[3] Reserved;
    KDHELP   KdHelp;
    ADDRESS  AddrBStore;
}
alias STACKFRAME* LPSTACKFRAME;

/*
struct API_VERSION {
    USHORT MajorVersion;
    USHORT MinorVersion;
    USHORT Revision;
    USHORT Reserved;
}
*/
public import core.sys.windows.dbghelp_types : API_VERSION;
alias API_VERSION* LPAPI_VERSION;

enum SYM_TYPE {
    SymNone,
    SymCoff,
    SymCv,
    SymPdb,
    SymExport,
    SymDeferred,
    SymSym
}

struct IMAGEHLP_SYMBOL {
    DWORD   SizeOfStruct;
    DWORD   Address;
    DWORD   Size;
    DWORD   Flags;
    DWORD   MaxNameLength;
    CHAR[1] Name = 0;
}
alias IMAGEHLP_SYMBOL* PIMAGEHLP_SYMBOL;

struct IMAGEHLP_MODULE {
    DWORD     SizeOfStruct;
    DWORD     BaseOfImage;
    DWORD     ImageSize;
    DWORD     TimeDateStamp;
    DWORD     CheckSum;
    DWORD     NumSyms;
    SYM_TYPE  SymType;
    CHAR[32]  ModuleName = 0;
    CHAR[256] ImageName = 0;
    CHAR[256] LoadedImageName = 0;
}
alias IMAGEHLP_MODULE* PIMAGEHLP_MODULE;

struct IMAGEHLP_LINE {
    DWORD SizeOfStruct;
    DWORD Key;
    DWORD LineNumber;
    PCHAR FileName;
    DWORD Address;
}
alias IMAGEHLP_LINE* PIMAGEHLP_LINE;

struct IMAGEHLP_DEFERRED_SYMBOL_LOAD {
    DWORD          SizeOfStruct;
    DWORD          BaseOfImage;
    DWORD          CheckSum;
    DWORD          TimeDateStamp;
    CHAR[MAX_PATH] FileName = 0;
    BOOLEAN        Reparse;
}
alias IMAGEHLP_DEFERRED_SYMBOL_LOAD* PIMAGEHLP_DEFERRED_SYMBOL_LOAD;

struct IMAGEHLP_DUPLICATE_SYMBOL {
    DWORD            SizeOfStruct;
    DWORD            NumberOfDups;
    PIMAGEHLP_SYMBOL Symbol;
    ULONG            SelectedSymbol;
}
alias IMAGEHLP_DUPLICATE_SYMBOL* PIMAGEHLP_DUPLICATE_SYMBOL;

mixin DECLARE_HANDLE!("DIGEST_HANDLE");

extern (Windows) {
    alias BOOL function(IMAGEHLP_STATUS_REASON, LPSTR, LPSTR, ULONG_PTR, ULONG_PTR)
      PIMAGEHLP_STATUS_ROUTINE;
    alias BOOL function(HANDLE , LPCVOID, LPVOID, DWORD, LPDWORD)
      PREAD_PROCESS_MEMORY_ROUTINE;
    alias LPVOID function(HANDLE, DWORD) PFUNCTION_TABLE_ACCESS_ROUTINE;
    alias DWORD function(HANDLE, DWORD) PGET_MODULE_BASE_ROUTINE;
    alias DWORD function(HANDLE, HANDLE, LPADDRESS)
      PTRANSLATE_ADDRESS_ROUTINE;
    alias BOOL function(LPSTR, ULONG, PVOID) PSYM_ENUMMODULES_CALLBACK;
    alias BOOL function(LPSTR, ULONG, ULONG, PVOID) PSYM_ENUMSYMBOLS_CALLBACK;
    alias BOOL function(LPSTR, ULONG, ULONG, PVOID)
      PENUMLOADED_MODULES_CALLBACK;
    alias BOOL function(HANDLE, ULONG, PVOID, PVOID)
      PSYMBOL_REGISTERED_CALLBACK;
    alias BOOL function(DIGEST_HANDLE refdata, PBYTE pData, DWORD dwLength)
      DIGEST_FUNCTION;

    PIMAGE_NT_HEADERS CheckSumMappedFile(LPVOID, DWORD, LPDWORD, LPDWORD);
    DWORD MapFileAndCheckSumA(LPSTR, LPDWORD, LPDWORD);
    DWORD MapFileAndCheckSumW(PWSTR, LPDWORD, LPDWORD);
    BOOL TouchFileTimes(HANDLE, LPSYSTEMTIME);
    BOOL SplitSymbols(LPSTR, LPSTR, LPSTR, DWORD);
    HANDLE FindDebugInfoFile(LPSTR, LPSTR, LPSTR);
    HANDLE FindExecutableImage(LPSTR, LPSTR, LPSTR);
    BOOL UpdateDebugInfoFile(LPSTR, LPSTR, LPSTR, PIMAGE_NT_HEADERS);
    BOOL UpdateDebugInfoFileEx(LPSTR, LPSTR, LPSTR, PIMAGE_NT_HEADERS, DWORD);
    BOOL BindImage(LPSTR, LPSTR, LPSTR);
    BOOL BindImageEx(DWORD, LPSTR, LPSTR, LPSTR, PIMAGEHLP_STATUS_ROUTINE);
    BOOL ReBaseImage(LPSTR, LPSTR, BOOL, BOOL, BOOL, ULONG, ULONG*, ULONG_PTR*,
      ULONG*, ULONG_PTR*, ULONG);
    PLOADED_IMAGE ImageLoad(LPSTR, LPSTR);
    BOOL ImageUnload(PLOADED_IMAGE);
    PIMAGE_NT_HEADERS ImageNtHeader(PVOID);
    PVOID ImageDirectoryEntryToData(PVOID, BOOLEAN, USHORT, PULONG);
    PIMAGE_SECTION_HEADER ImageRvaToSection(PIMAGE_NT_HEADERS, PVOID, ULONG);
    PVOID ImageRvaToVa(PIMAGE_NT_HEADERS, PVOID, ULONG,
      PIMAGE_SECTION_HEADER*);
    BOOL MapAndLoad(LPSTR, LPSTR, PLOADED_IMAGE, BOOL, BOOL);
    BOOL GetImageConfigInformation(PLOADED_IMAGE,
      PIMAGE_LOAD_CONFIG_DIRECTORY);
    DWORD GetImageUnusedHeaderBytes(PLOADED_IMAGE, LPDWORD);
    BOOL SetImageConfigInformation(PLOADED_IMAGE,
      PIMAGE_LOAD_CONFIG_DIRECTORY);
    BOOL UnMapAndLoad(PLOADED_IMAGE);
    PIMAGE_DEBUG_INFORMATION MapDebugInformation(HANDLE, LPSTR, LPSTR, DWORD);
    BOOL UnmapDebugInformation(PIMAGE_DEBUG_INFORMATION);
    HANDLE FindExecutableImage(LPSTR, LPSTR, LPSTR);
    BOOL SearchTreeForFile(LPSTR, LPSTR, LPSTR);
    BOOL MakeSureDirectoryPathExists(LPCSTR);
    DWORD UnDecorateSymbolName(LPCSTR, LPSTR, DWORD, DWORD);
    BOOL StackWalk(DWORD, HANDLE, HANDLE, LPSTACKFRAME, LPVOID,
      PREAD_PROCESS_MEMORY_ROUTINE, PFUNCTION_TABLE_ACCESS_ROUTINE,
      PGET_MODULE_BASE_ROUTINE, PTRANSLATE_ADDRESS_ROUTINE);
    LPAPI_VERSION ImagehlpApiVersion();
    LPAPI_VERSION ImagehlpApiVersionEx(LPAPI_VERSION);
    DWORD GetTimestampForLoadedLibrary(HMODULE);
    BOOL RemovePrivateCvSymbolic(PCHAR, PCHAR*, ULONG*);
    VOID RemoveRelocations(PCHAR);
    DWORD SymSetOptions(DWORD);
    DWORD SymGetOptions();
    BOOL SymCleanup(HANDLE);
    BOOL SymEnumerateModules(HANDLE, PSYM_ENUMMODULES_CALLBACK, PVOID);
    BOOL SymEnumerateSymbols(HANDLE, DWORD, PSYM_ENUMSYMBOLS_CALLBACK, PVOID);
    BOOL EnumerateLoadedModules(HANDLE, PENUMLOADED_MODULES_CALLBACK, PVOID);
    LPVOID SymFunctionTableAccess(HANDLE, DWORD);
    BOOL SymGetModuleInfo(HANDLE, DWORD, PIMAGEHLP_MODULE);
    DWORD SymGetModuleBase(HANDLE, DWORD);
    BOOL SymGetSymFromAddr(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
    BOOL SymGetSymFromName(HANDLE, LPSTR, PIMAGEHLP_SYMBOL);
    BOOL SymGetSymNext(HANDLE, PIMAGEHLP_SYMBOL);
    BOOL SymGetSymPrev(HANDLE, PIMAGEHLP_SYMBOL);
    BOOL SymGetLineFromAddr(HANDLE, DWORD, PDWORD, PIMAGEHLP_LINE);
    BOOL SymGetLineFromName(HANDLE, LPSTR, LPSTR, DWORD, PLONG,
      PIMAGEHLP_LINE);
    BOOL SymGetLineNext(HANDLE, PIMAGEHLP_LINE);
    BOOL SymGetLinePrev(HANDLE, PIMAGEHLP_LINE);
    BOOL SymMatchFileName(LPSTR, LPSTR, LPSTR*, LPSTR*);
    BOOL SymInitialize(HANDLE, LPSTR, BOOL);
    BOOL SymGetSearchPath(HANDLE, LPSTR, DWORD);
    BOOL SymSetSearchPath(HANDLE, LPSTR);
    BOOL SymLoadModule(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
    BOOL SymUnloadModule(HANDLE, DWORD);
    BOOL SymUnDName(PIMAGEHLP_SYMBOL, LPSTR, DWORD);
    BOOL SymRegisterCallback(HANDLE, PSYMBOL_REGISTERED_CALLBACK, PVOID);
    BOOL ImageGetDigestStream(HANDLE, DWORD, DIGEST_FUNCTION, DIGEST_HANDLE);
    BOOL ImageAddCertificate(HANDLE, LPWIN_CERTIFICATE, PDWORD);
    BOOL ImageRemoveCertificate(HANDLE, DWORD);
    BOOL ImageEnumerateCertificates(HANDLE, WORD, PDWORD, PDWORD, DWORD);
    BOOL ImageGetCertificateData(HANDLE, DWORD, LPWIN_CERTIFICATE, PDWORD);
    BOOL ImageGetCertificateHeader(HANDLE, DWORD, LPWIN_CERTIFICATE);
    BOOL CopyPdb(CHAR*, CHAR*, BOOL);
    BOOL RemovePrivateCvSymbolicEx(PCHAR, ULONG, PCHAR*, ULONG*);
}

version (Unicode) {
    alias MapFileAndCheckSumW MapFileAndCheckSum;
} else {
    alias MapFileAndCheckSumA MapFileAndCheckSum;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_imm.d)
 */
module core.sys.windows.imm;
version (Windows):

version (ANSI) {} else version = Unicode;
pragma(lib, "imm32");

import core.sys.windows.windef, core.sys.windows.wingdi;
import core.sys.windows.winuser; // for the MFS_xxx enums.
private import core.sys.windows.w32api;

enum WM_CONVERTREQUESTEX     = 0x108;
enum WM_IME_STARTCOMPOSITION = 0x10D;
enum WM_IME_ENDCOMPOSITION   = 0x10E;
enum WM_IME_COMPOSITION      = 0x10F;
enum WM_IME_KEYLAST          = 0x10F;
enum WM_IME_SETCONTEXT       = 0x281;
enum WM_IME_NOTIFY           = 0x282;
enum WM_IME_CONTROL          = 0x283;
enum WM_IME_COMPOSITIONFULL  = 0x284;
enum WM_IME_SELECT           = 0x285;
enum WM_IME_CHAR             = 0x286;
//static if (_WIN32_WINNT >= 0x500) {
enum WM_IME_REQUEST      = 0x288;
//}
enum WM_IME_KEYDOWN          = 0x290;
enum WM_IME_KEYUP            = 0x291;


enum IMC_GETCANDIDATEPOS=7;
enum IMC_SETCANDIDATEPOS=8;
enum IMC_GETCOMPOSITIONFONT=9;
enum IMC_SETCOMPOSITIONFONT=10;
enum IMC_GETCOMPOSITIONWINDOW=11;
enum IMC_SETCOMPOSITIONWINDOW=12;
enum IMC_GETSTATUSWINDOWPOS=15;
enum IMC_SETSTATUSWINDOWPOS=16;
enum IMC_CLOSESTATUSWINDOW=0x21;
enum IMC_OPENSTATUSWINDOW=0x22;
enum IMN_CLOSESTATUSWINDOW=1;
enum IMN_OPENSTATUSWINDOW=2;
enum IMN_CHANGECANDIDATE=3;
enum IMN_CLOSECANDIDATE=4;
enum IMN_OPENCANDIDATE=5;
enum IMN_SETCONVERSIONMODE=6;
enum IMN_SETSENTENCEMODE=7;
enum IMN_SETOPENSTATUS=8;
enum IMN_SETCANDIDATEPOS=9;
enum IMN_SETCOMPOSITIONFONT=10;
enum IMN_SETCOMPOSITIONWINDOW=11;
enum IMN_SETSTATUSWINDOWPOS=12;
enum IMN_GUIDELINE=13;
enum IMN_PRIVATE=14;

enum NI_OPENCANDIDATE=16;
enum NI_CLOSECANDIDATE=17;
enum NI_SELECTCANDIDATESTR=18;
enum NI_CHANGECANDIDATELIST=19;
enum NI_FINALIZECONVERSIONRESULT=20;
enum NI_COMPOSITIONSTR=21;
enum NI_SETCANDIDATE_PAGESTART=22;
enum NI_SETCANDIDATE_PAGESIZE=23;
enum NI_IMEMENUSELECTED=24;

enum ISC_SHOWUICANDIDATEWINDOW=1;
enum ISC_SHOWUICOMPOSITIONWINDOW=0x80000000;
enum ISC_SHOWUIGUIDELINE=0x40000000;
enum ISC_SHOWUIALLCANDIDATEWINDOW=15;
enum ISC_SHOWUIALL=0xC000000F;

enum CPS_COMPLETE=1;
enum CPS_CONVERT=2;
enum CPS_REVERT=3;
enum CPS_CANCEL=4;

enum IME_CHOTKEY_IME_NONIME_TOGGLE=16;
enum IME_CHOTKEY_SHAPE_TOGGLE=17;
enum IME_CHOTKEY_SYMBOL_TOGGLE=18;
enum IME_JHOTKEY_CLOSE_OPEN=0x30;
enum IME_KHOTKEY_SHAPE_TOGGLE=0x50;
enum IME_KHOTKEY_HANJACONVERT=0x51;
enum IME_KHOTKEY_ENGLISH=0x52;
enum IME_THOTKEY_IME_NONIME_TOGGLE=0x70;
enum IME_THOTKEY_SHAPE_TOGGLE=0x71;
enum IME_THOTKEY_SYMBOL_TOGGLE=0x72;
enum IME_HOTKEY_DSWITCH_FIRST=256;
enum IME_HOTKEY_DSWITCH_LAST=0x11F;
enum IME_ITHOTKEY_RESEND_RESULTSTR=512;
enum IME_ITHOTKEY_PREVIOUS_COMPOSITION=513;
enum IME_ITHOTKEY_UISTYLE_TOGGLE=514;

enum GCS_COMPREADSTR=1;
enum GCS_COMPREADATTR=2;
enum GCS_COMPREADCLAUSE=4;
enum GCS_COMPSTR=8;
enum GCS_COMPATTR=16;
enum GCS_COMPCLAUSE=32;
enum GCS_CURSORPOS=128;
enum GCS_DELTASTART=256;
enum GCS_RESULTREADSTR=512;
enum GCS_RESULTREADCLAUSE=1024;
enum GCS_RESULTSTR=2048;
enum GCS_RESULTCLAUSE=4096;

enum CS_INSERTCHAR=0x2000;
enum CS_NOMOVECARET=0x4000;

enum IMEVER_0310=0x3000A;
enum IMEVER_0400=0x40000;

enum IME_PROP_AT_CARET=0x10000;
enum IME_PROP_SPECIAL_UI=0x20000;
enum IME_PROP_CANDLIST_START_FROM_1=0x40000;
enum IME_PROP_UNICODE=0x80000;

enum UI_CAP_2700=1;
enum UI_CAP_ROT90=2;
enum UI_CAP_ROTANY=4;

enum SCS_CAP_COMPSTR=1;
enum SCS_CAP_MAKEREAD=2;
enum SELECT_CAP_CONVERSION=1;
enum SELECT_CAP_SENTENCE=2;
enum GGL_LEVEL=1;
enum GGL_INDEX=2;
enum GGL_STRING=3;
enum GGL_PRIVATE=4;
enum GL_LEVEL_NOGUIDELINE=0;
enum GL_LEVEL_FATAL=1;
enum GL_LEVEL_ERROR=2;
enum GL_LEVEL_WARNING=3;
enum GL_LEVEL_INFORMATION=4;
enum GL_ID_UNKNOWN=0;
enum GL_ID_NOMODULE=1;
enum GL_ID_NODICTIONARY=16;
enum GL_ID_CANNOTSAVE=17;
enum GL_ID_NOCONVERT=32;
enum GL_ID_TYPINGERROR=33;
enum GL_ID_TOOMANYSTROKE=34;
enum GL_ID_READINGCONFLICT=35;
enum GL_ID_INPUTREADING=36;
enum GL_ID_INPUTRADICAL=37;
enum GL_ID_INPUTCODE=38;
enum GL_ID_INPUTSYMBOL=39;
enum GL_ID_CHOOSECANDIDATE=40;
enum GL_ID_REVERSECONVERSION=41;
enum GL_ID_PRIVATE_FIRST=0x8000;
enum GL_ID_PRIVATE_LAST=0xFFFF;

enum DWORD IGP_GETIMEVERSION = -4;
enum IGP_PROPERTY=4;
enum IGP_CONVERSION=8;
enum IGP_SENTENCE=12;
enum IGP_UI=16;
enum IGP_SETCOMPSTR=0x14;
enum IGP_SELECT=0x18;

enum SCS_SETSTR       = GCS_COMPREADSTR|GCS_COMPSTR;
enum SCS_CHANGEATTR   = GCS_COMPREADATTR|GCS_COMPATTR;
enum SCS_CHANGECLAUSE = GCS_COMPREADCLAUSE|GCS_COMPCLAUSE;

enum ATTR_INPUT=0;
enum ATTR_TARGET_CONVERTED=1;
enum ATTR_CONVERTED=2;
enum ATTR_TARGET_NOTCONVERTED=3;
enum ATTR_INPUT_ERROR=4;
enum ATTR_FIXEDCONVERTED=5;
enum CFS_DEFAULT=0;
enum CFS_RECT=1;
enum CFS_POINT=2;
enum CFS_SCREEN=4;
enum CFS_FORCE_POSITION=32;
enum CFS_CANDIDATEPOS=64;
enum CFS_EXCLUDE=128;
enum GCL_CONVERSION=1;
enum GCL_REVERSECONVERSION=2;
enum GCL_REVERSE_LENGTH=3;

enum IME_CMODE_ALPHANUMERIC=0;
enum IME_CMODE_NATIVE=1;
enum IME_CMODE_CHINESE=IME_CMODE_NATIVE;
enum IME_CMODE_HANGEUL=IME_CMODE_NATIVE;
enum IME_CMODE_HANGUL=IME_CMODE_NATIVE;
enum IME_CMODE_JAPANESE=IME_CMODE_NATIVE;
enum IME_CMODE_KATAKANA=2;
enum IME_CMODE_LANGUAGE=3;
enum IME_CMODE_FULLSHAPE=8;
enum IME_CMODE_ROMAN=16;
enum IME_CMODE_CHARCODE=32;
enum IME_CMODE_HANJACONVERT=64;
enum IME_CMODE_SOFTKBD=128;
enum IME_CMODE_NOCONVERSION=256;
enum IME_CMODE_EUDC=512;
enum IME_CMODE_SYMBOL=1024;
enum IME_CMODE_FIXED=2048;
enum IME_SMODE_NONE=0;
enum IME_SMODE_PLAURALCLAUSE=1;
enum IME_SMODE_SINGLECONVERT=2;
enum IME_SMODE_AUTOMATIC=4;
enum IME_SMODE_PHRASEPREDICT=8;
enum IME_CAND_UNKNOWN=0;
enum IME_CAND_READ=1;
enum IME_CAND_CODE=2;
enum IME_CAND_MEANING=3;
enum IME_CAND_RADICAL=4;
enum IME_CAND_STROKE=5;
enum IMM_ERROR_NODATA=(-1);
enum IMM_ERROR_GENERAL=(-2);
enum IME_CONFIG_GENERAL=1;
enum IME_CONFIG_REGISTERWORD=2;
enum IME_CONFIG_SELECTDICTIONARY=3;
enum IME_ESC_QUERY_SUPPORT=3;
enum IME_ESC_RESERVED_FIRST=4;
enum IME_ESC_RESERVED_LAST=0x7FF;
enum IME_ESC_PRIVATE_FIRST=0x800;
enum IME_ESC_PRIVATE_LAST=0xFFF;
enum IME_ESC_SEQUENCE_TO_INTERNAL=0x1001;
enum IME_ESC_GET_EUDC_DICTIONARY=0x1003;
enum IME_ESC_SET_EUDC_DICTIONARY=0x1004;
enum IME_ESC_MAX_KEY=0x1005;
enum IME_ESC_IME_NAME=0x1006;
enum IME_ESC_SYNC_HOTKEY=0x1007;
enum IME_ESC_HANJA_MODE=0x1008;
enum IME_ESC_AUTOMATA=0x1009;
enum IME_REGWORD_STYLE_EUDC=1;
enum IME_REGWORD_STYLE_USER_FIRST=0x80000000;
enum IME_REGWORD_STYLE_USER_LAST=0xFFFFFFFF;

enum SOFTKEYBOARD_TYPE_T1=1;
enum SOFTKEYBOARD_TYPE_C1=2;

enum IMEMENUITEM_STRING_SIZE=80;

enum MOD_ALT=1;
enum MOD_CONTROL=2;
enum MOD_SHIFT=4;
enum MOD_WIN=8;
enum MOD_IGNORE_ALL_MODIFIER=1024;
enum MOD_ON_KEYUP=2048;
enum MOD_RIGHT=16384;
enum MOD_LEFT=32768;

enum IACE_CHILDREN=1;
enum IACE_DEFAULT=16;
enum IACE_IGNORENOCONTEXT=32;

enum IGIMIF_RIGHTMENU=1;

enum IGIMII_CMODE=1;
enum IGIMII_SMODE=2;
enum IGIMII_CONFIGURE=4;
enum IGIMII_TOOLS=8;
enum IGIMII_HELP=16;
enum IGIMII_OTHER=32;
enum IGIMII_INPUTTOOLS=64;

enum IMFT_RADIOCHECK=1;
enum IMFT_SEPARATOR=2;
enum IMFT_SUBMENU=4;

enum IMFS_GRAYED=MFS_GRAYED;
enum IMFS_DISABLED=MFS_DISABLED;
enum IMFS_CHECKED=MFS_CHECKED;
enum IMFS_HILITE=MFS_HILITE;
enum IMFS_ENABLED=MFS_ENABLED;
enum IMFS_UNCHECKED=MFS_UNCHECKED;
enum IMFS_UNHILITE=MFS_UNHILITE;
enum IMFS_DEFAULT=MFS_DEFAULT;

enum STYLE_DESCRIPTION_SIZE=32;

alias DWORD HIMC;
alias DWORD HIMCC;
alias HKL* LPHKL;

struct COMPOSITIONFORM{
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
}
alias COMPOSITIONFORM* PCOMPOSITIONFORM, LPCOMPOSITIONFORM;

struct CANDIDATEFORM{
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
}
alias CANDIDATEFORM* PCANDIDATEFORM, LPCANDIDATEFORM;

struct CANDIDATELIST{
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD[1] dwOffset;
}
alias CANDIDATELIST* PCANDIDATELIST, LPCANDIDATELIST;

struct REGISTERWORDA{
    LPSTR lpReading;
    LPSTR lpWord;
}
alias REGISTERWORDA* PREGISTERWORDA, LPREGISTERWORDA;

struct REGISTERWORDW{
    LPWSTR lpReading;
    LPWSTR lpWord;
}
alias REGISTERWORDW* PREGISTERWORDW, LPREGISTERWORDW;

struct STYLEBUFA{
    DWORD dwStyle;
    CHAR[STYLE_DESCRIPTION_SIZE] szDescription = 0;
}
alias STYLEBUFA* PSTYLEBUFA, LPSTYLEBUFA;

struct STYLEBUFW{
    DWORD dwStyle;
    WCHAR[STYLE_DESCRIPTION_SIZE] szDescription = 0;
}
alias STYLEBUFW* PSTYLEBUFW, LPSTYLEBUFW;

struct IMEMENUITEMINFOA{
    UINT cbSize = this.sizeof;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR[IMEMENUITEM_STRING_SIZE] szString = 0;
    HBITMAP hbmpItem;
}
alias IMEMENUITEMINFOA* PIMEMENUITEMINFOA, LPIMEMENUITEMINFOA;

struct IMEMENUITEMINFOW{
    UINT cbSize = this.sizeof;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR[IMEMENUITEM_STRING_SIZE] szString = 0;
    HBITMAP hbmpItem;
}
alias IMEMENUITEMINFOW* PIMEMENUITEMINFOW, LPIMEMENUITEMINFOW;

extern (Windows) {
alias int function (LPCSTR, DWORD, LPCSTR, LPVOID)  REGISTERWORDENUMPROCA;
alias int function (LPCWSTR, DWORD, LPCWSTR, LPVOID) REGISTERWORDENUMPROCW;
}

version (Unicode) {
    alias REGISTERWORDENUMPROCW REGISTERWORDENUMPROC;
    alias REGISTERWORDW REGISTERWORD;
    alias IMEMENUITEMINFOW IMEMENUITEMINFO;
    alias STYLEBUFW STYLEBUF;
} else {
    alias REGISTERWORDENUMPROCA REGISTERWORDENUMPROC;
    alias REGISTERWORDA REGISTERWORD;
    alias IMEMENUITEMINFOA IMEMENUITEMINFO;
    alias STYLEBUFA STYLEBUF;
}

alias STYLEBUF* PSTYLEBUF, LPSTYLEBUF;
alias REGISTERWORD* PREGISTERWORD, LPREGISTERWORD;
alias IMEMENUITEMINFO* PIMEMENUITEMINFO, LPIMEMENUITEMINFO;


extern (Windows):
HKL ImmInstallIMEA(LPCSTR, LPCSTR);
HKL ImmInstallIMEW(LPCWSTR, LPCWSTR);
HWND ImmGetDefaultIMEWnd(HWND);
UINT ImmGetDescriptionA(HKL, LPSTR, UINT);
UINT ImmGetDescriptionW(HKL, LPWSTR, UINT);
UINT ImmGetIMEFileNameA(HKL, LPSTR, UINT);
UINT ImmGetIMEFileNameW(HKL, LPWSTR, UINT);
DWORD ImmGetProperty(HKL, DWORD);
BOOL ImmIsIME(HKL);
BOOL ImmSimulateHotKey(HWND, DWORD);
HIMC ImmCreateContext();
BOOL ImmDestroyContext(HIMC);
HIMC ImmGetContext(HWND);
BOOL ImmReleaseContext(HWND, HIMC);
HIMC ImmAssociateContext(HWND, HIMC);
LONG ImmGetCompositionStringA(HIMC, DWORD, PVOID, DWORD);
LONG ImmGetCompositionStringW(HIMC, DWORD, PVOID, DWORD);
BOOL ImmSetCompositionStringA(HIMC, DWORD, PCVOID, DWORD, PCVOID, DWORD);
BOOL ImmSetCompositionStringW(HIMC, DWORD, PCVOID, DWORD, PCVOID, DWORD);
DWORD ImmGetCandidateListCountA(HIMC, PDWORD);
DWORD ImmGetCandidateListCountW(HIMC, PDWORD);
DWORD ImmGetCandidateListA(HIMC, DWORD, PCANDIDATELIST, DWORD);
DWORD ImmGetCandidateListW(HIMC, DWORD, PCANDIDATELIST, DWORD);
DWORD ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD);
DWORD ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD);
BOOL ImmGetConversionStatus(HIMC, LPDWORD, PDWORD);
BOOL ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL ImmGetOpenStatus(HIMC);
BOOL ImmSetOpenStatus(HIMC, BOOL);

BOOL ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL ImmGetCompositionFontW(HIMC, LPLOGFONTW);
BOOL ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL ImmSetCompositionFontW(HIMC, LPLOGFONTW);

BOOL ImmConfigureIMEA(HKL, HWND, DWORD, PVOID);
BOOL ImmConfigureIMEW(HKL, HWND, DWORD, PVOID);
LRESULT ImmEscapeA(HKL, HIMC, UINT, PVOID);
LRESULT ImmEscapeW(HKL, HIMC, UINT, PVOID);
DWORD ImmGetConversionListA(HKL, HIMC, LPCSTR, PCANDIDATELIST, DWORD, UINT);
DWORD ImmGetConversionListW(HKL, HIMC, LPCWSTR, PCANDIDATELIST, DWORD, UINT);
BOOL ImmNotifyIME(HIMC, DWORD, DWORD, DWORD);
BOOL ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL ImmGetCompositionWindow(HIMC, PCOMPOSITIONFORM);
BOOL ImmSetCompositionWindow(HIMC, PCOMPOSITIONFORM);
BOOL ImmGetCandidateWindow(HIMC, DWORD, PCANDIDATEFORM);
BOOL ImmSetCandidateWindow(HIMC, PCANDIDATEFORM);
BOOL ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
UINT ImmGetVirtualKey(HWND);
BOOL ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
BOOL ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
UINT ImmGetRegisterWordStyleA(HKL, UINT, PSTYLEBUFA);
UINT ImmGetRegisterWordStyleW(HKL, UINT, PSTYLEBUFW);
UINT ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, PVOID);
UINT ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, PVOID);
BOOL EnableEUDC(BOOL);
BOOL ImmDisableIME(DWORD);
DWORD ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);

version (Unicode) {
    alias ImmEnumRegisterWordW ImmEnumRegisterWord;
    alias ImmGetRegisterWordStyleW ImmGetRegisterWordStyle;
    alias ImmUnregisterWordW ImmUnregisterWord;
    alias ImmRegisterWordW ImmRegisterWord;
    alias ImmInstallIMEW ImmInstallIME;
    alias ImmIsUIMessageW ImmIsUIMessage;
    alias ImmGetConversionListW ImmGetConversionList;
    alias ImmEscapeW ImmEscape;
    alias ImmConfigureIMEW ImmConfigureIME;
    alias ImmSetCompositionFontW ImmSetCompositionFont;
    alias ImmGetCompositionFontW ImmGetCompositionFont;
    alias ImmGetGuideLineW ImmGetGuideLine;
    alias ImmGetCandidateListW ImmGetCandidateList;
    alias ImmGetCandidateListCountW ImmGetCandidateListCount;
    alias ImmSetCompositionStringW ImmSetCompositionString;
    alias ImmGetCompositionStringW ImmGetCompositionString;
    alias ImmGetDescriptionW ImmGetDescription;
    alias ImmGetIMEFileNameW ImmGetIMEFileName;
    alias ImmGetImeMenuItemsW ImmGetImeMenuItems;
} else {
    alias ImmEnumRegisterWordA ImmEnumRegisterWord;
    alias ImmGetRegisterWordStyleA ImmGetRegisterWordStyle;
    alias ImmUnregisterWordA ImmUnregisterWord;
    alias ImmRegisterWordA ImmRegisterWord;
    alias ImmInstallIMEA ImmInstallIME;
    alias ImmIsUIMessageA ImmIsUIMessage;
    alias ImmGetConversionListA ImmGetConversionList;
    alias ImmEscapeA ImmEscape;
    alias ImmConfigureIMEA ImmConfigureIME;
    alias ImmSetCompositionFontA ImmSetCompositionFont;
    alias ImmGetCompositionFontA ImmGetCompositionFont;
    alias ImmGetGuideLineA ImmGetGuideLine;
    alias ImmGetCandidateListA ImmGetCandidateList;
    alias ImmGetCandidateListCountA ImmGetCandidateListCount;
    alias ImmSetCompositionStringA ImmSetCompositionString;
    alias ImmGetCompositionStringA ImmGetCompositionString;
    alias ImmGetDescriptionA ImmGetDescription;
    alias ImmGetIMEFileNameA ImmGetIMEFileName;
    alias ImmGetImeMenuItemsW ImmGetImeMenuItems;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_intshcut.d)
 */
module core.sys.windows.intshcut;
version (Windows):

version (ANSI) {} else version = Unicode;

private import core.sys.windows.unknwn, core.sys.windows.windef;

enum : SCODE {
    E_FLAGS                     = 0x80041000,
      // = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1000)
    URL_E_INVALID_SYNTAX        = 0x80041001,
      // = MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1001)
    URL_E_UNREGISTERED_PROTOCOL = 0x80041002, // etc.
    IS_E_EXEC_FAILED            = 0x80042002
}

enum IURL_SETURL_FLAGS {
    IURL_SETURL_FL_GUESS_PROTOCOL = 1,
    IURL_SETURL_FL_USE_DEFAULT_PROTOCOL,
    ALL_IURL_SETURL_FLAGS
}

enum IURL_INVOKECOMMAND_FLAGS {
    IURL_INVOKECOMMAND_FL_ALLOW_UI = 1,
    IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB,
    ALL_IURL_INVOKECOMMAND_FLAGS
}

enum TRANSLATEURL_IN_FLAGS {
    TRANSLATEURL_FL_GUESS_PROTOCOL = 1,
    TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL,
    ALL_TRANSLATEURL_FLAGS
}

enum URLASSOCIATIONDIALOG_IN_FLAGS {
    URLASSOCDLG_FL_USE_DEFAULT_NAME = 1,
    URLASSOCDLG_FL_REGISTER_ASSOC,
    ALL_URLASSOCDLG_FLAGS
}

enum MIMEASSOCIATIONDIALOG_IN_FLAGS {
    MIMEASSOCDLG_FL_REGISTER_ASSOC = 1,
    ALL_MIMEASSOCDLG_FLAGS         = MIMEASSOCDLG_FL_REGISTER_ASSOC
}

struct URLINVOKECOMMANDINFO {
    DWORD dwcbSize = URLINVOKECOMMANDINFO.sizeof;
    DWORD dwFlags;
    HWND  hwndParent;
    PCSTR pcszVerb;
}
alias URLINVOKECOMMANDINFO CURLINVOKECOMMANDINFO;
alias URLINVOKECOMMANDINFO* PURLINVOKECOMMANDINFO, PCURLINVOKECOMMANDINFO;

interface IUniformResourceLocator : IUnknown {
    HRESULT SetURL(PCSTR, DWORD);
    HRESULT GetURL(PSTR*);
    HRESULT InvokeCommand(PURLINVOKECOMMANDINFO);
}
//alias typeof(*(IUniformResourceLocator.init)) CIUniformResourceLocator; // value-type of interface not representable in D
alias IUniformResourceLocator PIUniformResourceLocator,
  PCIUniformResourceLocator;

extern (Windows) {
    BOOL InetIsOffline(DWORD);
    HRESULT MIMEAssociationDialogA(HWND, DWORD, PCSTR, PCSTR, PSTR, UINT);
    HRESULT MIMEAssociationDialogW(HWND, DWORD, PCWSTR, PCWSTR, PWSTR, UINT);
    HRESULT TranslateURLA(PCSTR, DWORD, PSTR*);
    HRESULT TranslateURLW(PCWSTR, DWORD, PWSTR*);
    HRESULT URLAssociationDialogA(HWND, DWORD, PCSTR, PCSTR, PSTR, UINT);
    HRESULT URLAssociationDialogW(HWND, DWORD, PCWSTR, PCWSTR, PWSTR, UINT);
}

version (Unicode) {
    alias TranslateURLW TranslateURL;
    alias MIMEAssociationDialogW MIMEAssociationDialog;
    alias URLAssociationDialogW URLAssociationDialog;
} else {
    alias TranslateURLA TranslateURL;
    alias MIMEAssociationDialogA MIMEAssociationDialog;
    alias URLAssociationDialogA URLAssociationDialog;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_ipexport.d)
 */
module core.sys.windows.ipexport;
version (Windows):

private import core.sys.windows.windef;

enum size_t MAX_ADAPTER_NAME = 128;

// IP STATUS flags
enum : IP_STATUS {
    IP_SUCCESS         =     0,
    IP_STATUS_BASE     = 11000,
    IP_BUF_TOO_SMALL,
    IP_DEST_NET_UNREACHABLE,
    IP_DEST_HOST_UNREACHABLE,
    IP_DEST_PROT_UNREACHABLE,
    IP_DEST_PORT_UNREACHABLE,
    IP_NO_RESOURCES,
    IP_BAD_OPTION,
    IP_HW_ERROR,
    IP_PACKET_TOO_BIG,
    IP_REQ_TIMED_OUT,
    IP_BAD_REQ,
    IP_BAD_ROUTE,
    IP_TTL_EXPIRED_TRANSIT,
    IP_TTL_EXPIRED_REASSEM,
    IP_PARAM_PROBLEM,
    IP_SOURCE_QUENCH,
    IP_OPTION_TOO_BIG,
    IP_BAD_DESTINATION,
    IP_ADDR_DELETED,
    IP_SPEC_MTU_CHANGE,
    IP_MTU_CHANGE,
    IP_UNLOAD,      // = IP_STATUS_BASE + 22
    IP_GENERAL_FAILURE = IP_STATUS_BASE + 50,
    MAX_IP_STATUS      = IP_GENERAL_FAILURE,
    IP_PENDING         = IP_STATUS_BASE + 255
}

// IP header Flags values
enum byte IP_FLAG_DF = 2;

// IP Option types
enum : ubyte {
    IP_OPT_EOL          = 0,
    IP_OPT_NOP          = 0x01,
    IP_OPT_RR           = 0x07,
    IP_OPT_SECURITY     = 0x82,
    IP_OPT_LSRR         = 0x83,
    IP_OPT_SSRR         = 0x89,
    IP_OPT_TS           = 0x44,
    IP_OPT_SID          = 0x88,
    IP_OPT_ROUTER_ALERT = 0x94
}

enum ubyte MAX_OPT_SIZE = 40;

alias uint IPAddr, IPMask, IP_STATUS;

struct IP_OPTION_INFORMATION {
    ubyte  Ttl;
    ubyte  Tos;
    ubyte  Flags;
    ubyte  OptionsSize;
    ubyte* OptionsData;
}
alias IP_OPTION_INFORMATION* PIP_OPTION_INFORMATION;

struct ICMP_ECHO_REPLY {
  IPAddr Address;
  uint   Status;
  uint   RoundTripTime;
  ushort DataSize;
  ushort Reserved;
  void*  Data;
  IP_OPTION_INFORMATION Options;
}
alias ICMP_ECHO_REPLY* PICMP_ECHO_REPLY;

struct IP_ADAPTER_INDEX_MAP {
    ULONG                   Index;
    WCHAR[MAX_ADAPTER_NAME] Name = 0;
}
alias IP_ADAPTER_INDEX_MAP* PIP_ADAPTER_INDEX_MAP;

struct IP_INTERFACE_INFO {
    LONG                    NumAdapters;
    IP_ADAPTER_INDEX_MAP[1] _Adapter;

    IP_ADAPTER_INDEX_MAP* Adapter() return { return _Adapter.ptr; }
}
alias IP_INTERFACE_INFO* PIP_INTERFACE_INFO;

struct IP_UNIDIRECTIONAL_ADAPTER_ADDRESS {
    ULONG     NumAdapters;
    IPAddr[1] _Address;

    IPAddr* Address() return { return _Address.ptr; }
}
alias IP_UNIDIRECTIONAL_ADAPTER_ADDRESS* PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_iphlpapi.d)
 */
module core.sys.windows.iphlpapi;
version (Windows):

import core.sys.windows.ipexport, core.sys.windows.iprtrmib, core.sys.windows.iptypes;
private import core.sys.windows.winbase, core.sys.windows.windef;

extern (Windows) {
    DWORD AddIPAddress(IPAddr, IPMask, DWORD, PULONG, PULONG);
    DWORD CreateIpForwardEntry(PMIB_IPFORWARDROW);
    DWORD CreateIpNetEntry(PMIB_IPNETROW);
    DWORD CreateProxyArpEntry(DWORD, DWORD, DWORD);
    DWORD DeleteIPAddress(ULONG);
    DWORD DeleteIpForwardEntry(PMIB_IPFORWARDROW);
    DWORD DeleteIpNetEntry(PMIB_IPNETROW);
    DWORD DeleteProxyArpEntry(DWORD, DWORD, DWORD);
    DWORD EnableRouter(HANDLE*, OVERLAPPED*);
    DWORD FlushIpNetTable(DWORD);
    DWORD GetAdapterIndex(LPWSTR, PULONG);
    DWORD GetAdaptersInfo(PIP_ADAPTER_INFO, PULONG);
    DWORD GetBestInterface(IPAddr, PDWORD);
    DWORD GetBestRoute(DWORD, DWORD, PMIB_IPFORWARDROW);
    DWORD GetFriendlyIfIndex(DWORD);
    DWORD GetIcmpStatistics(PMIB_ICMP);
    DWORD GetIfEntry(PMIB_IFROW);
    DWORD GetIfTable(PMIB_IFTABLE, PULONG, BOOL);
    DWORD GetInterfaceInfo(PIP_INTERFACE_INFO, PULONG);
    DWORD GetIpAddrTable(PMIB_IPADDRTABLE, PULONG, BOOL);
    DWORD GetIpForwardTable(PMIB_IPFORWARDTABLE, PULONG, BOOL);
    DWORD GetIpNetTable(PMIB_IPNETTABLE, PULONG, BOOL);
    DWORD GetIpStatistics(PMIB_IPSTATS);
    DWORD GetNetworkParams(PFIXED_INFO, PULONG);
    DWORD GetNumberOfInterfaces(PDWORD);
    DWORD GetPerAdapterInfo(ULONG, PIP_PER_ADAPTER_INFO, PULONG);
    BOOL GetRTTAndHopCount(IPAddr, PULONG, ULONG, PULONG);
    DWORD GetTcpStatistics(PMIB_TCPSTATS);
    DWORD GetTcpTable(PMIB_TCPTABLE, PDWORD, BOOL);
    DWORD GetUniDirectionalAdapterInfo(PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS,
      PULONG);
    DWORD GetUdpStatistics(PMIB_UDPSTATS);
    DWORD GetUdpTable(PMIB_UDPTABLE, PDWORD, BOOL);
    DWORD IpReleaseAddress(PIP_ADAPTER_INDEX_MAP);
    DWORD IpRenewAddress(PIP_ADAPTER_INDEX_MAP);
    DWORD NotifyAddrChange(PHANDLE, LPOVERLAPPED);
    DWORD NotifyRouteChange(PHANDLE, LPOVERLAPPED);
    DWORD SendARP(IPAddr, IPAddr, PULONG, PULONG);
    DWORD SetIfEntry(PMIB_IFROW);
    DWORD SetIpForwardEntry(PMIB_IPFORWARDROW);
    DWORD SetIpNetEntry(PMIB_IPNETROW);
    DWORD SetIpStatistics(PMIB_IPSTATS);
    DWORD SetIpTTL(UINT);
    DWORD SetTcpEntry(PMIB_TCPROW);
    DWORD UnenableRouter(OVERLAPPED*, LPDWORD);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_ipifcons.d)
 */
module core.sys.windows.ipifcons;
version (Windows):

// FIXME: check types of constants

enum {
    MIB_IF_ADMIN_STATUS_UP = 1,
    MIB_IF_ADMIN_STATUS_DOWN,
    MIB_IF_ADMIN_STATUS_TESTING,
}

enum {
    MIB_IF_OPER_STATUS_NON_OPERATIONAL,
    MIB_IF_OPER_STATUS_UNREACHABLE,
    MIB_IF_OPER_STATUS_DISCONNECTED,
    MIB_IF_OPER_STATUS_CONNECTING,
    MIB_IF_OPER_STATUS_CONNECTED,
    MIB_IF_OPER_STATUS_OPERATIONAL // = 5
}

enum {
    MIB_IF_TYPE_OTHER     =  1,
    MIB_IF_TYPE_ETHERNET  =  6,
    MIB_IF_TYPE_TOKENRING =  9,
    MIB_IF_TYPE_FDDI      = 15,
    MIB_IF_TYPE_PPP       = 23,
    MIB_IF_TYPE_LOOPBACK  = 24,
    MIB_IF_TYPE_SLIP      = 28
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_iprtrmib.d)
 */
module core.sys.windows.iprtrmib;
version (Windows):

import core.sys.windows.ipifcons;
private import core.sys.windows.windef;

// FIXME: check types of constants

enum size_t
    MAXLEN_PHYSADDR        =   8,
    MAXLEN_IFDESCR         = 256,
    MAX_INTERFACE_NAME_LEN = 256;

enum {
    MIB_IPNET_TYPE_OTHER = 1,
    MIB_IPNET_TYPE_INVALID,
    MIB_IPNET_TYPE_DYNAMIC,
    MIB_IPNET_TYPE_STATIC
}

enum {
    MIB_TCP_RTO_OTHER = 1,
    MIB_TCP_RTO_CONSTANT,
    MIB_TCP_RTO_RSRE,
    MIB_TCP_RTO_VANJ
}

enum {
    MIB_TCP_STATE_CLOSED = 1,
    MIB_TCP_STATE_LISTEN,
    MIB_TCP_STATE_SYN_SENT,
    MIB_TCP_STATE_SYN_RCVD,
    MIB_TCP_STATE_ESTAB,
    MIB_TCP_STATE_FIN_WAIT1,
    MIB_TCP_STATE_FIN_WAIT2,
    MIB_TCP_STATE_CLOSE_WAIT,
    MIB_TCP_STATE_CLOSING,
    MIB_TCP_STATE_LAST_ACK,
    MIB_TCP_STATE_TIME_WAIT,
    MIB_TCP_STATE_DELETE_TCB // = 12
}

enum DWORD
    MIB_USE_CURRENT_TTL        = -1,
    MIB_USE_CURRENT_FORWARDING = -1,
    MIB_TCP_MAXCONN_DYNAMIC    = -1;

struct MIB_IPADDRROW {
    DWORD  dwAddr;
    DWORD  dwIndex;
    DWORD  dwMask;
    DWORD  dwBCastAddr;
    DWORD  dwReasmSize;
    ushort unused1;
    ushort unused2;
}
alias MIB_IPADDRROW* PMIB_IPADDRROW;

struct MIB_IPADDRTABLE {
    DWORD            dwNumEntries;
    MIB_IPADDRROW[1] _table;

    MIB_IPADDRROW* table() return { return _table.ptr; }
}
alias MIB_IPADDRTABLE* PMIB_IPADDRTABLE;

struct MIB_IPFORWARDROW {
    DWORD dwForwardDest;
    DWORD dwForwardMask;
    DWORD dwForwardPolicy;
    DWORD dwForwardNextHop;
    DWORD dwForwardIfIndex;
    DWORD dwForwardType;
    DWORD dwForwardProto;
    DWORD dwForwardAge;
    DWORD dwForwardNextHopAS;
    DWORD dwForwardMetric1;
    DWORD dwForwardMetric2;
    DWORD dwForwardMetric3;
    DWORD dwForwardMetric4;
    DWORD dwForwardMetric5;
}
alias MIB_IPFORWARDROW* PMIB_IPFORWARDROW;

struct MIB_IPFORWARDTABLE {
    DWORD               dwNumEntries;
    MIB_IPFORWARDROW[1] _table;

    MIB_IPFORWARDROW* table() return { return _table.ptr; }
}
alias MIB_IPFORWARDTABLE* PMIB_IPFORWARDTABLE;

struct MIB_IPNETROW {
    DWORD dwIndex;
    DWORD dwPhysAddrLen;
    BYTE[MAXLEN_PHYSADDR] bPhysAddr;
    DWORD dwAddr;
    DWORD dwType;
}
alias MIB_IPNETROW* PMIB_IPNETROW;

struct MIB_IPNETTABLE {
    DWORD           dwNumEntries;
    MIB_IPNETROW[1] _table;

    MIB_IPNETROW* table() return { return _table.ptr; }
}
alias MIB_IPNETTABLE* PMIB_IPNETTABLE;

struct MIBICMPSTATS {
    DWORD dwMsgs;
    DWORD dwErrors;
    DWORD dwDestUnreachs;
    DWORD dwTimeExcds;
    DWORD dwParmProbs;
    DWORD dwSrcQuenchs;
    DWORD dwRedirects;
    DWORD dwEchos;
    DWORD dwEchoReps;
    DWORD dwTimestamps;
    DWORD dwTimestampReps;
    DWORD dwAddrMasks;
    DWORD dwAddrMaskReps;
}
alias MIBICMPSTATS* PMIBICMPSTATS;

struct MIBICMPINFO {
    MIBICMPSTATS icmpInStats;
    MIBICMPSTATS icmpOutStats;
}
alias MIBICMPINFO* PMIBICMPINFO;

struct MIB_ICMP {
    MIBICMPINFO stats;
}
alias MIB_ICMP* PMIB_ICMP;

struct MIB_IFROW {
    WCHAR[MAX_INTERFACE_NAME_LEN] wszName = 0;
    DWORD dwIndex;
    DWORD dwType;
    DWORD dwMtu;
    DWORD dwSpeed;
    DWORD dwPhysAddrLen;
    BYTE[MAXLEN_PHYSADDR] bPhysAddr;
    DWORD dwAdminStatus;
    DWORD dwOperStatus;
    DWORD dwLastChange;
    DWORD dwInOctets;
    DWORD dwInUcastPkts;
    DWORD dwInNUcastPkts;
    DWORD dwInDiscards;
    DWORD dwInErrors;
    DWORD dwInUnknownProtos;
    DWORD dwOutOctets;
    DWORD dwOutUcastPkts;
    DWORD dwOutNUcastPkts;
    DWORD dwOutDiscards;
    DWORD dwOutErrors;
    DWORD dwOutQLen;
    DWORD dwDescrLen;
    BYTE[MAXLEN_IFDESCR] bDescr;
}
alias MIB_IFROW* PMIB_IFROW;

struct MIB_IFTABLE {
    DWORD        dwNumEntries;
    MIB_IFROW[1] _table;

    MIB_IFROW* table() return { return _table.ptr; }
}
alias MIB_IFTABLE* PMIB_IFTABLE;

struct MIB_IPSTATS {
    DWORD dwForwarding;
    DWORD dwDefaultTTL;
    DWORD dwInReceives;
    DWORD dwInHdrErrors;
    DWORD dwInAddrErrors;
    DWORD dwForwDatagrams;
    DWORD dwInUnknownProtos;
    DWORD dwInDiscards;
    DWORD dwInDelivers;
    DWORD dwOutRequests;
    DWORD dwRoutingDiscards;
    DWORD dwOutDiscards;
    DWORD dwOutNoRoutes;
    DWORD dwReasmTimeout;
    DWORD dwReasmReqds;
    DWORD dwReasmOks;
    DWORD dwReasmFails;
    DWORD dwFragOks;
    DWORD dwFragFails;
    DWORD dwFragCreates;
    DWORD dwNumIf;
    DWORD dwNumAddr;
    DWORD dwNumRoutes;
}
alias MIB_IPSTATS* PMIB_IPSTATS;

struct MIB_TCPSTATS {
    DWORD dwRtoAlgorithm;
    DWORD dwRtoMin;
    DWORD dwRtoMax;
    DWORD dwMaxConn;
    DWORD dwActiveOpens;
    DWORD dwPassiveOpens;
    DWORD dwAttemptFails;
    DWORD dwEstabResets;
    DWORD dwCurrEstab;
    DWORD dwInSegs;
    DWORD dwOutSegs;
    DWORD dwRetransSegs;
    DWORD dwInErrs;
    DWORD dwOutRsts;
    DWORD dwNumConns;
}
alias MIB_TCPSTATS* PMIB_TCPSTATS;

struct MIB_TCPROW {
    DWORD dwState;
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
    DWORD dwRemoteAddr;
    DWORD dwRemotePort;
}
alias MIB_TCPROW* PMIB_TCPROW;

struct MIB_TCPTABLE {
    DWORD         dwNumEntries;
    MIB_TCPROW[1] _table;

    MIB_TCPROW* table() return { return _table.ptr; }
}
alias MIB_TCPTABLE* PMIB_TCPTABLE;

struct MIB_UDPSTATS {
    DWORD dwInDatagrams;
    DWORD dwNoPorts;
    DWORD dwInErrors;
    DWORD dwOutDatagrams;
    DWORD dwNumAddrs;
}
alias MIB_UDPSTATS* PMIB_UDPSTATS;

struct MIB_UDPROW {
    DWORD dwLocalAddr;
    DWORD dwLocalPort;
}
alias MIB_UDPROW* PMIB_UDPROW;

struct MIB_UDPTABLE {
    DWORD         dwNumEntries;
    MIB_UDPROW[1] _table;

    MIB_UDPROW* table() return { return _table.ptr; }
}
alias MIB_UDPTABLE* PMIB_UDPTABLE;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_iptypes.d)
 */
module core.sys.windows.iptypes;
version (Windows):

import core.sys.windows.windef;
import core.stdc.time;
//#include <sys/types.h>

enum size_t
    DEFAULT_MINIMUM_ENTITIES       =  32,
    MAX_ADAPTER_ADDRESS_LENGTH     =   8,
    MAX_ADAPTER_DESCRIPTION_LENGTH = 128,
    MAX_ADAPTER_NAME_LENGTH        = 256,
    MAX_DOMAIN_NAME_LEN            = 128,
    MAX_HOSTNAME_LEN               = 128,
    MAX_SCOPE_ID_LEN               = 256;

enum UINT
    BROADCAST_NODETYPE    = 1,
    PEER_TO_PEER_NODETYPE = 2,
    MIXED_NODETYPE        = 4,
    HYBRID_NODETYPE       = 8;

enum : UINT {
    IF_OTHER_ADAPTERTYPE,
    IF_ETHERNET_ADAPTERTYPE,
    IF_TOKEN_RING_ADAPTERTYPE,
    IF_FDDI_ADAPTERTYPE,
    IF_PPP_ADAPTERTYPE,
    IF_LOOPBACK_ADAPTERTYPE // = 5
}

struct IP_ADDRESS_STRING {
    char[16] String = 0;
}
alias IP_ADDRESS_STRING IP_MASK_STRING;
alias IP_ADDRESS_STRING* PIP_ADDRESS_STRING, PIP_MASK_STRING;

struct IP_ADDR_STRING {
    IP_ADDR_STRING*   Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING    IpMask;
    DWORD             Context;
}
alias IP_ADDR_STRING* PIP_ADDR_STRING;

struct IP_ADAPTER_INFO {
    IP_ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char[MAX_ADAPTER_NAME_LENGTH+4]        AdapterName = 0;
    char[MAX_ADAPTER_DESCRIPTION_LENGTH+4] Description = 0;
    UINT             AddressLength;
    BYTE[MAX_ADAPTER_ADDRESS_LENGTH]       Address = 0;
    DWORD            Index;
    UINT             Type;
    UINT             DhcpEnabled;
    PIP_ADDR_STRING  CurrentIpAddress;
    IP_ADDR_STRING   IpAddressList;
    IP_ADDR_STRING   GatewayList;
    IP_ADDR_STRING   DhcpServer;
    BOOL             HaveWins;
    IP_ADDR_STRING   PrimaryWinsServer;
    IP_ADDR_STRING   SecondaryWinsServer;
    time_t           LeaseObtained;
    time_t           LeaseExpires;
}
alias IP_ADAPTER_INFO* PIP_ADAPTER_INFO;

struct IP_PER_ADAPTER_INFO {
    UINT AutoconfigEnabled;
    UINT AutoconfigActive;
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
}
alias IP_PER_ADAPTER_INFO* PIP_PER_ADAPTER_INFO;

struct FIXED_INFO {
    char[MAX_HOSTNAME_LEN+4]    HostName = 0;
    char[MAX_DOMAIN_NAME_LEN+4] DomainName = 0;
    PIP_ADDR_STRING             CurrentDnsServer;
    IP_ADDR_STRING              DnsServerList;
    UINT                        NodeType;
    char[MAX_SCOPE_ID_LEN+4]    ScopeId = 0;
    UINT                        EnableRouting;
    UINT                        EnableProxy;
    UINT                        EnableDns;
}
alias FIXED_INFO* PFIXED_INFO;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * Windows API header module
 *
 * Translated from MinGW API for MS-Windows 3.10
 *
 * Authors: Stewart Gordon
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_isguids.d)
 */
module core.sys.windows.isguids;
version (Windows):

private import core.sys.windows.basetyps;

extern (C) extern const GUID
    CLSID_InternetShortcut,
    IID_IUniformResourceLocator;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lm.d)
 */
module core.sys.windows.lm;
version (Windows):
/* removed - now supporting only Win2k up
version (WindowsVista) {
    version = WIN32_WINNT_ONLY;
} else version (Windows2003) {
    version = WIN32_WINNT_ONLY;
} else version (WindowsXP) {
    version = WIN32_WINNT_ONLY;
} else version (WindowsNTonly) {
    version = WIN32_WINNT_ONLY;
}
*/
public import core.sys.windows.lmcons;
public import core.sys.windows.lmaccess;
public import core.sys.windows.lmalert;
public import core.sys.windows.lmat;
public import core.sys.windows.lmerr;
public import core.sys.windows.lmshare;
public import core.sys.windows.lmapibuf;
public import core.sys.windows.lmremutl;
public import core.sys.windows.lmrepl;
public import core.sys.windows.lmuse;
public import core.sys.windows.lmstats;
public import core.sys.windows.lmwksta;
public import core.sys.windows.lmserver;

version (Windows2000) {
} else {
    public import core.sys.windows.lmmsg;
}

// FIXME: Everything in these next files seems to be deprecated!
import core.sys.windows.lmaudit;
import core.sys.windows.lmchdev; // can't find many docs for functions from this file.
import core.sys.windows.lmconfig;
import core.sys.windows.lmerrlog;
import core.sys.windows.lmsvc;
import core.sys.windows.lmsname; // in MinGW, this was publicly included by lm.lmsvc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmaccess.d)
 */
module core.sys.windows.lmaccess;
version (Windows):
pragma(lib, "netapi32");

/**
 Changes relative to MinGW:
    USER_POSIX_ID_PARMNUM and GROUP_POSIX_ID_PARMNUM aren't in MinGW or in
    the Platform SDK docs, so they have been dropped from this file.
*/

private import core.sys.windows.lmcons, core.sys.windows.windef;

const wchar[]
    GROUP_SPECIALGRP_USERS  = "USERS",
    GROUP_SPECIALGRP_ADMINS = "ADMINS",
    GROUP_SPECIALGRP_GUESTS = "GUESTS",
    GROUP_SPECIALGRP_LOCAL  = "LOCAL";

enum ACCESS_LETTERS = "RWCXDAP ";

enum NETLOGON_CONTROL_QUERY=1;
enum NETLOGON_CONTROL_REPLICATE=2;
enum NETLOGON_CONTROL_SYNCHRONIZE=3;
enum NETLOGON_CONTROL_PDC_REPLICATE=4;
enum NETLOGON_CONTROL_REDISCOVER=5;
enum NETLOGON_CONTROL_TC_QUERY=6;
enum NETLOGON_CONTROL_BACKUP_CHANGE_LOG=65532;
enum NETLOGON_CONTROL_TRUNCATE_LOG=65533;
enum NETLOGON_CONTROL_SET_DBFLAG=65534;
enum NETLOGON_CONTROL_BREAKPOINT=65535;

enum UF_SCRIPT=1;
enum UF_ACCOUNTDISABLE=2;
enum UF_HOMEDIR_REQUIRED=8;
enum UF_LOCKOUT=16;
enum UF_PASSWD_NOTREQD=32;
enum UF_PASSWD_CANT_CHANGE=64;
enum UF_TEMP_DUPLICATE_ACCOUNT=256;
enum UF_NORMAL_ACCOUNT=512;
enum UF_INTERDOMAIN_TRUST_ACCOUNT=2048;
enum UF_WORKSTATION_TRUST_ACCOUNT=4096;
enum UF_SERVER_TRUST_ACCOUNT=8192;
enum UF_MNS_LOGON_ACCOUNT=131072;
enum UF_MACHINE_ACCOUNT_MASK=UF_INTERDOMAIN_TRUST_ACCOUNT|UF_WORKSTATION_TRUST_ACCOUNT|UF_SERVER_TRUST_ACCOUNT;
enum UF_ACCOUNT_TYPE_MASK=UF_TEMP_DUPLICATE_ACCOUNT|UF_NORMAL_ACCOUNT|UF_INTERDOMAIN_TRUST_ACCOUNT|UF_WORKSTATION_TRUST_ACCOUNT|UF_SERVER_TRUST_ACCOUNT;
enum UF_DONT_EXPIRE_PASSWD=65536;
enum UF_SETTABLE_BITS=UF_SCRIPT|UF_ACCOUNTDISABLE|UF_LOCKOUT|UF_HOMEDIR_REQUIRED|UF_PASSWD_NOTREQD|UF_PASSWD_CANT_CHANGE|UF_ACCOUNT_TYPE_MASK|UF_DONT_EXPIRE_PASSWD;

enum FILTER_TEMP_DUPLICATE_ACCOUNT=1;
enum FILTER_NORMAL_ACCOUNT=2;
enum FILTER_INTERDOMAIN_TRUST_ACCOUNT=8;
enum FILTER_WORKSTATION_TRUST_ACCOUNT=16;
enum FILTER_SERVER_TRUST_ACCOUNT=32;

enum LG_INCLUDE_INDIRECT=1;

enum AF_OP_PRINT=1;
enum AF_OP_COMM=2;
enum AF_OP_SERVER=4;
enum AF_OP_ACCOUNTS=8;
enum AF_SETTABLE_BITS=(AF_OP_PRINT|AF_OP_COMM|AF_OP_SERVER|AF_OP_ACCOUNTS);

enum UAS_ROLE_STANDALONE=0;
enum UAS_ROLE_MEMBER=1;
enum UAS_ROLE_BACKUP=2;
enum UAS_ROLE_PRIMARY=3;

enum USER_NAME_PARMNUM=1;
enum USER_PASSWORD_PARMNUM=3;
enum USER_PASSWORD_AGE_PARMNUM=4;
enum USER_PRIV_PARMNUM=5;
enum USER_HOME_DIR_PARMNUM=6;
enum USER_COMMENT_PARMNUM=7;
enum USER_FLAGS_PARMNUM=8;
enum USER_SCRIPT_PATH_PARMNUM=9;
enum USER_AUTH_FLAGS_PARMNUM=10;
enum USER_FULL_NAME_PARMNUM=11;
enum USER_USR_COMMENT_PARMNUM=12;
enum USER_PARMS_PARMNUM=13;
enum USER_WORKSTATIONS_PARMNUM=14;
enum USER_LAST_LOGON_PARMNUM=15;
enum USER_LAST_LOGOFF_PARMNUM=16;
enum USER_ACCT_EXPIRES_PARMNUM=17;
enum USER_MAX_STORAGE_PARMNUM=18;
enum USER_UNITS_PER_WEEK_PARMNUM=19;
enum USER_LOGON_HOURS_PARMNUM=20;
enum USER_PAD_PW_COUNT_PARMNUM=21;
enum USER_NUM_LOGONS_PARMNUM=22;
enum USER_LOGON_SERVER_PARMNUM=23;
enum USER_COUNTRY_CODE_PARMNUM=24;
enum USER_CODE_PAGE_PARMNUM=25;
enum USER_PRIMARY_GROUP_PARMNUM=51;
enum USER_PROFILE=52;
enum USER_PROFILE_PARMNUM=52;
enum USER_HOME_DIR_DRIVE_PARMNUM=53;

enum USER_NAME_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_NAME_PARMNUM;
enum USER_PASSWORD_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PASSWORD_PARMNUM;
enum USER_PASSWORD_AGE_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PASSWORD_AGE_PARMNUM;
enum USER_PRIV_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PRIV_PARMNUM;
enum USER_HOME_DIR_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_HOME_DIR_PARMNUM;
enum USER_COMMENT_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_COMMENT_PARMNUM;
enum USER_FLAGS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_FLAGS_PARMNUM;
enum USER_SCRIPT_PATH_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_SCRIPT_PATH_PARMNUM;
enum USER_AUTH_FLAGS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_AUTH_FLAGS_PARMNUM;
enum USER_FULL_NAME_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_FULL_NAME_PARMNUM;
enum USER_USR_COMMENT_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_USR_COMMENT_PARMNUM;
enum USER_PARMS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PARMS_PARMNUM;
enum USER_WORKSTATIONS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_WORKSTATIONS_PARMNUM;
enum USER_LAST_LOGON_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_LAST_LOGON_PARMNUM;
enum USER_LAST_LOGOFF_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_LAST_LOGOFF_PARMNUM;
enum USER_ACCT_EXPIRES_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_ACCT_EXPIRES_PARMNUM;
enum USER_MAX_STORAGE_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_MAX_STORAGE_PARMNUM;
enum USER_UNITS_PER_WEEK_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_UNITS_PER_WEEK_PARMNUM;
enum USER_LOGON_HOURS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_LOGON_HOURS_PARMNUM;
enum USER_PAD_PW_COUNT_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PAD_PW_COUNT_PARMNUM;
enum USER_NUM_LOGONS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_NUM_LOGONS_PARMNUM;
enum USER_LOGON_SERVER_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_LOGON_SERVER_PARMNUM;
enum USER_COUNTRY_CODE_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_COUNTRY_CODE_PARMNUM;
enum USER_CODE_PAGE_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_CODE_PAGE_PARMNUM;
enum USER_PRIMARY_GROUP_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_PRIMARY_GROUP_PARMNUM;
// USER_POSIX_ID_PARMNUM isn't in MinGW or in the Platform SDK docs.
//const USER_POSIX_ID_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_POSIX_ID_PARMNUM;
enum USER_HOME_DIR_DRIVE_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+USER_HOME_DIR_DRIVE_PARMNUM;

enum NULL_USERSETINFO_PASSWD=" ";
enum ULONG TIMEQ_FOREVER=-1;
enum ULONG USER_MAXSTORAGE_UNLIMITED=-1;
enum ULONG USER_NO_LOGOFF=-1;
enum UNITS_PER_DAY=24;
enum UNITS_PER_WEEK=168;
enum USER_PRIV_MASK=3;
enum USER_PRIV_GUEST=0;
enum USER_PRIV_USER=1;
enum USER_PRIV_ADMIN=2;
enum MAX_PASSWD_LEN=PWLEN;
enum DEF_MIN_PWLEN=6;
enum DEF_PWUNIQUENESS=5;
enum DEF_MAX_PWHIST=8;
enum DEF_MAX_PWAGE=TIMEQ_FOREVER;
enum DEF_MIN_PWAGE=0;
enum ULONG DEF_FORCE_LOGOFF=0xffffffff;
enum DEF_MAX_BADPW=0;
enum ONE_DAY=86400;
enum VALIDATED_LOGON=0;
enum PASSWORD_EXPIRED=2;
enum NON_VALIDATED_LOGON=3;
enum VALID_LOGOFF=1;

enum MODALS_MIN_PASSWD_LEN_PARMNUM=1;
enum MODALS_MAX_PASSWD_AGE_PARMNUM=2;
enum MODALS_MIN_PASSWD_AGE_PARMNUM=3;
enum MODALS_FORCE_LOGOFF_PARMNUM=4;
enum MODALS_PASSWD_HIST_LEN_PARMNUM=5;
enum MODALS_ROLE_PARMNUM=6;
enum MODALS_PRIMARY_PARMNUM=7;
enum MODALS_DOMAIN_NAME_PARMNUM=8;
enum MODALS_DOMAIN_ID_PARMNUM=9;
enum MODALS_LOCKOUT_DURATION_PARMNUM=10;
enum MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM=11;
enum MODALS_LOCKOUT_THRESHOLD_PARMNUM=12;

enum MODALS_MIN_PASSWD_LEN_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_MIN_PASSWD_LEN_PARMNUM);
enum MODALS_MAX_PASSWD_AGE_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_MAX_PASSWD_AGE_PARMNUM);
enum MODALS_MIN_PASSWD_AGE_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_MIN_PASSWD_AGE_PARMNUM);
enum MODALS_FORCE_LOGOFF_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_FORCE_LOGOFF_PARMNUM);
enum MODALS_PASSWD_HIST_LEN_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_PASSWD_HIST_LEN_PARMNUM);
enum MODALS_ROLE_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_ROLE_PARMNUM);
enum MODALS_PRIMARY_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_PRIMARY_PARMNUM);
enum MODALS_DOMAIN_NAME_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_DOMAIN_NAME_PARMNUM);
enum MODALS_DOMAIN_ID_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+MODALS_DOMAIN_ID_PARMNUM);

enum GROUPIDMASK=0x8000;
enum GROUP_ALL_PARMNUM=0;
enum GROUP_NAME_PARMNUM=1;
enum GROUP_COMMENT_PARMNUM=2;
enum GROUP_ATTRIBUTES_PARMNUM=3;

enum GROUP_ALL_INFOLEVEL = PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM;
enum GROUP_NAME_INFOLEVEL = PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM;
enum GROUP_COMMENT_INFOLEVEL = PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM;
enum GROUP_ATTRIBUTES_INFOLEVEL = PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM;
// GROUP_POSIX_ID_PARMNUM isn't in MinGW or in the Platform SDK docs.
//const GROUP_POSIX_ID_INFOLEVEL = PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM;

enum LOCALGROUP_NAME_PARMNUM=1;
enum LOCALGROUP_COMMENT_PARMNUM=2;
enum MAXPERMENTRIES=64;
enum ACCESS_NONE=0;
enum ACCESS_READ=1;
enum ACCESS_WRITE=2;
enum ACCESS_CREATE=4;
enum ACCESS_EXEC=8;
enum ACCESS_DELETE=16;
enum ACCESS_ATRIB=32;
enum ACCESS_PERM=64;
enum ACCESS_ALL = ACCESS_READ|ACCESS_WRITE|ACCESS_CREATE|ACCESS_EXEC|ACCESS_DELETE|ACCESS_ATRIB|ACCESS_PERM;
enum ACCESS_GROUP=0x8000;
enum ACCESS_AUDIT=1;
enum ACCESS_SUCCESS_OPEN=16;
enum ACCESS_SUCCESS_WRITE=32;
enum ACCESS_SUCCESS_DELETE=64;
enum ACCESS_SUCCESS_ACL=128;
enum ACCESS_SUCCESS_MASK=240;
enum ACCESS_FAIL_OPEN=256;
enum ACCESS_FAIL_WRITE=512;
enum ACCESS_FAIL_DELETE=1024;
enum ACCESS_FAIL_ACL=2048;
enum ACCESS_FAIL_MASK=3840;
enum ACCESS_FAIL_SHIFT=4;
enum ACCESS_RESOURCE_NAME_PARMNUM=1;
enum ACCESS_ATTR_PARMNUM=2;
enum ACCESS_COUNT_PARMNUM=3;
enum ACCESS_ACCESS_LIST_PARMNUM=4;

enum ACCESS_RESOURCE_NAME_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+ACCESS_RESOURCE_NAME_PARMNUM);
enum ACCESS_ATTR_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+ACCESS_ATTR_PARMNUM);
enum ACCESS_COUNT_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+ACCESS_COUNT_PARMNUM);
enum ACCESS_ACCESS_LIST_INFOLEVEL=(PARMNUM_BASE_INFOLEVEL+ACCESS_ACCESS_LIST_PARMNUM);

enum NETLOGON_REPLICATION_NEEDED=1;
enum NETLOGON_REPLICATION_IN_PROGRESS=2;
enum NETLOGON_FULL_SYNC_REPLICATION=4;
enum NETLOGON_REDO_NEEDED=8;

struct USER_INFO_0 {
    LPWSTR usri0_name;
}
alias USER_INFO_0* PUSER_INFO_0, LPUSER_INFO_0;

struct USER_INFO_1{
    LPWSTR usri1_name;
    LPWSTR usri1_password;
    DWORD usri1_password_age;
    DWORD usri1_priv;
    LPWSTR usri1_home_dir;
    LPWSTR usri1_comment;
    DWORD usri1_flags;
    LPWSTR usri1_script_path;
}
alias USER_INFO_1* PUSER_INFO_1, LPUSER_INFO_1;

struct USER_INFO_2{
    LPWSTR usri2_name;
    LPWSTR usri2_password;
    DWORD usri2_password_age;
    DWORD usri2_priv;
    LPWSTR usri2_home_dir;
    LPWSTR usri2_comment;
    DWORD usri2_flags;
    LPWSTR usri2_script_path;
    DWORD usri2_auth_flags;
    LPWSTR usri2_full_name;
    LPWSTR usri2_usr_comment;
    LPWSTR usri2_parms;
    LPWSTR usri2_workstations;
    DWORD usri2_last_logon;
    DWORD usri2_last_logoff;
    DWORD usri2_acct_expires;
    DWORD usri2_max_storage;
    DWORD usri2_units_per_week;
    PBYTE usri2_logon_hours;
    DWORD usri2_bad_pw_count;
    DWORD usri2_num_logons;
    LPWSTR usri2_logon_server;
    DWORD usri2_country_code;
    DWORD usri2_code_page;
}
alias USER_INFO_2* PUSER_INFO_2, LPUSER_INFO_2;

struct USER_INFO_3{
    LPWSTR usri3_name;
    LPWSTR usri3_password;
    DWORD usri3_password_age;
    DWORD usri3_priv;
    LPWSTR usri3_home_dir;
    LPWSTR usri3_comment;
    DWORD usri3_flags;
    LPWSTR usri3_script_path;
    DWORD usri3_auth_flags;
    LPWSTR usri3_full_name;
    LPWSTR usri3_usr_comment;
    LPWSTR usri3_parms;
    LPWSTR usri3_workstations;
    DWORD usri3_last_logon;
    DWORD usri3_last_logoff;
    DWORD usri3_acct_expires;
    DWORD usri3_max_storage;
    DWORD usri3_units_per_week;
    PBYTE usri3_logon_hours;
    DWORD usri3_bad_pw_count;
    DWORD usri3_num_logons;
    LPWSTR usri3_logon_server;
    DWORD usri3_country_code;
    DWORD usri3_code_page;
    DWORD usri3_user_id;
    DWORD usri3_primary_group_id;
    LPWSTR usri3_profile;
    LPWSTR usri3_home_dir_drive;
    DWORD usri3_password_expired;
}
alias USER_INFO_3* PUSER_INFO_3, LPUSER_INFO_3;

struct USER_INFO_10{
    LPWSTR usri10_name;
    LPWSTR usri10_comment;
    LPWSTR usri10_usr_comment;
    LPWSTR usri10_full_name;
}
alias USER_INFO_10* PUSER_INFO_10, LPUSER_INFO_10;

struct USER_INFO_11{
    LPWSTR usri11_name;
    LPWSTR usri11_comment;
    LPWSTR usri11_usr_comment;
    LPWSTR usri11_full_name;
    DWORD usri11_priv;
    DWORD usri11_auth_flags;
    DWORD usri11_password_age;
    LPWSTR usri11_home_dir;
    LPWSTR usri11_parms;
    DWORD usri11_last_logon;
    DWORD usri11_last_logoff;
    DWORD usri11_bad_pw_count;
    DWORD usri11_num_logons;
    LPWSTR usri11_logon_server;
    DWORD usri11_country_code;
    LPWSTR usri11_workstations;
    DWORD usri11_max_storage;
    DWORD usri11_units_per_week;
    PBYTE usri11_logon_hours;
    DWORD usri11_code_page;
}
alias USER_INFO_11* PUSER_INFO_11, LPUSER_INFO_11;

struct USER_INFO_20 {
    LPWSTR usri20_name;
    LPWSTR usri20_full_name;
    LPWSTR usri20_comment;
    DWORD usri20_flags;
    DWORD usri20_user_id;
}
alias USER_INFO_20* PUSER_INFO_20, LPUSER_INFO_20;

struct USER_INFO_21 {
    BYTE[ENCRYPTED_PWLEN] usri21_password;
}
alias USER_INFO_21* PUSER_INFO_21, LPUSER_INFO_21;

struct USER_INFO_22{
    LPWSTR usri22_name;
    BYTE[ENCRYPTED_PWLEN] usri22_password;
    DWORD usri22_password_age;
    DWORD usri22_priv;
    LPWSTR usri22_home_dir;
    LPWSTR usri22_comment;
    DWORD usri22_flags;
    LPWSTR usri22_script_path;
    DWORD usri22_auth_flags;
    LPWSTR usri22_full_name;
    LPWSTR usri22_usr_comment;
    LPWSTR usri22_parms;
    LPWSTR usri22_workstations;
    DWORD usri22_last_logon;
    DWORD usri22_last_logoff;
    DWORD usri22_acct_expires;
    DWORD usri22_max_storage;
    DWORD usri22_units_per_week;
    PBYTE usri22_logon_hours;
    DWORD usri22_bad_pw_count;
    DWORD usri22_num_logons;
    LPWSTR usri22_logon_server;
    DWORD usri22_country_code;
    DWORD usri22_code_page;
}
alias USER_INFO_22* PUSER_INFO_22, LPUSER_INFO_22;

struct USER_INFO_1003{
    LPWSTR usri1003_password;
}
alias USER_INFO_1003* PUSER_INFO_1003, LPUSER_INFO_1003;

struct USER_INFO_1005{
    DWORD usri1005_priv;
}
alias USER_INFO_1005* PUSER_INFO_1005, LPUSER_INFO_1005;

struct USER_INFO_1006{
    LPWSTR usri1006_home_dir;
}
alias USER_INFO_1006* PUSER_INFO_1006, LPUSER_INFO_1006;

struct USER_INFO_1007{
    LPWSTR usri1007_comment;
}
alias USER_INFO_1007* PUSER_INFO_1007, LPUSER_INFO_1007;

struct USER_INFO_1008{
    DWORD usri1008_flags;
}
alias USER_INFO_1008* PUSER_INFO_1008, LPUSER_INFO_1008;

struct USER_INFO_1009{
    LPWSTR usri1009_script_path;
}
alias USER_INFO_1009* PUSER_INFO_1009, LPUSER_INFO_1009;

struct USER_INFO_1010{
    DWORD usri1010_auth_flags;
}
alias USER_INFO_1010* PUSER_INFO_1010, LPUSER_INFO_1010;

struct USER_INFO_1011{
    LPWSTR usri1011_full_name;
}
alias USER_INFO_1011* PUSER_INFO_1011, LPUSER_INFO_1011;

struct USER_INFO_1012{
    LPWSTR usri1012_usr_comment;
}
alias USER_INFO_1012* PUSER_INFO_1012, LPUSER_INFO_1012;

struct USER_INFO_1013{
    LPWSTR usri1013_parms;
}
alias USER_INFO_1013* PUSER_INFO_1013, LPUSER_INFO_1013;

struct USER_INFO_1014{
    LPWSTR usri1014_workstations;
}
alias USER_INFO_1014* PUSER_INFO_1014, LPUSER_INFO_1014;

struct USER_INFO_1017{
    DWORD usri1017_acct_expires;
}
alias USER_INFO_1017* PUSER_INFO_1017, LPUSER_INFO_1017;

struct USER_INFO_1018{
    DWORD usri1018_max_storage;
}
alias USER_INFO_1018* PUSER_INFO_1018, LPUSER_INFO_1018;

struct USER_INFO_1020{
    DWORD usri1020_units_per_week;
    PBYTE usri1020_logon_hours;
}
alias USER_INFO_1020* PUSER_INFO_1020, LPUSER_INFO_1020;

struct USER_INFO_1023{
    LPWSTR usri1023_logon_server;
}
alias USER_INFO_1023* PUSER_INFO_1023, LPUSER_INFO_1023;

struct USER_INFO_1024{
    DWORD usri1024_country_code;
}
alias USER_INFO_1024* PUSER_INFO_1024, LPUSER_INFO_1024;

struct USER_INFO_1025{
    DWORD usri1025_code_page;
}
alias USER_INFO_1025* PUSER_INFO_1025, LPUSER_INFO_1025;

struct USER_INFO_1051{
    DWORD usri1051_primary_group_id;
}
alias USER_INFO_1051* PUSER_INFO_1051, LPUSER_INFO_1051;

struct USER_INFO_1052{
    LPWSTR usri1052_profile;
}
alias USER_INFO_1052* PUSER_INFO_1052, LPUSER_INFO_1052;

struct USER_INFO_1053{
    LPWSTR usri1053_home_dir_drive;
}
alias USER_INFO_1053* PUSER_INFO_1053, LPUSER_INFO_1053;

struct USER_MODALS_INFO_0{
    DWORD usrmod0_min_passwd_len;
    DWORD usrmod0_max_passwd_age;
    DWORD usrmod0_min_passwd_age;
    DWORD usrmod0_force_logoff;
    DWORD usrmod0_password_hist_len;
}
alias USER_MODALS_INFO_0* PUSER_MODALS_INFO_0, LPUSER_MODALS_INFO_0;

struct USER_MODALS_INFO_1{
    DWORD usrmod1_role;
    LPWSTR usrmod1_primary;
}
alias USER_MODALS_INFO_1* PUSER_MODALS_INFO_1, LPUSER_MODALS_INFO_1;

struct USER_MODALS_INFO_2{
    LPWSTR usrmod2_domain_name;
    PSID usrmod2_domain_id;
}
alias USER_MODALS_INFO_2* PUSER_MODALS_INFO_2, LPUSER_MODALS_INFO_2;

struct USER_MODALS_INFO_3{
    DWORD usrmod3_lockout_duration;
    DWORD usrmod3_lockout_observation_window;
    DWORD usrmod3_lockout_threshold;
}
alias USER_MODALS_INFO_3* PUSER_MODALS_INFO_3, LPUSER_MODALS_INFO_3;

struct USER_MODALS_INFO_1001{
    DWORD usrmod1001_min_passwd_len;
}
alias USER_MODALS_INFO_1001* PUSER_MODALS_INFO_1001, LPUSER_MODALS_INFO_1001;

struct USER_MODALS_INFO_1002{
    DWORD usrmod1002_max_passwd_age;
}
alias USER_MODALS_INFO_1002* PUSER_MODALS_INFO_1002, LPUSER_MODALS_INFO_1002;

struct USER_MODALS_INFO_1003{
    DWORD usrmod1003_min_passwd_age;
}
alias USER_MODALS_INFO_1003* PUSER_MODALS_INFO_1003, LPUSER_MODALS_INFO_1003;

struct USER_MODALS_INFO_1004{
    DWORD usrmod1004_force_logoff;
}
alias USER_MODALS_INFO_1004* PUSER_MODALS_INFO_1004, LPUSER_MODALS_INFO_1004;

struct USER_MODALS_INFO_1005{
    DWORD usrmod1005_password_hist_len;
}
alias USER_MODALS_INFO_1005* PUSER_MODALS_INFO_1005, LPUSER_MODALS_INFO_1005;

struct USER_MODALS_INFO_1006{
    DWORD usrmod1006_role;
}
alias USER_MODALS_INFO_1006* PUSER_MODALS_INFO_1006, LPUSER_MODALS_INFO_1006;

struct USER_MODALS_INFO_1007{
    LPWSTR usrmod1007_primary;
}
alias USER_MODALS_INFO_1007* PUSER_MODALS_INFO_1007, LPUSER_MODALS_INFO_1007;

struct GROUP_INFO_0{
    LPWSTR grpi0_name;
}
alias GROUP_INFO_0* PGROUP_INFO_0, LPGROUP_INFO_0;

struct GROUP_INFO_1{
    LPWSTR grpi1_name;
    LPWSTR grpi1_comment;
}
alias GROUP_INFO_1* PGROUP_INFO_1, LPGROUP_INFO_1;

struct GROUP_INFO_2{
    LPWSTR grpi2_name;
    LPWSTR grpi2_comment;
    DWORD grpi2_group_id;
    DWORD grpi2_attributes;
}
alias GROUP_INFO_2* PGROUP_INFO_2;

struct GROUP_INFO_1002{
    LPWSTR grpi1002_comment;
}
alias GROUP_INFO_1002* PGROUP_INFO_1002, LPGROUP_INFO_1002;

struct GROUP_INFO_1005{
    DWORD grpi1005_attributes;
}
alias GROUP_INFO_1005* PGROUP_INFO_1005, LPGROUP_INFO_1005;

struct GROUP_USERS_INFO_0{
    LPWSTR grui0_name;
}
alias GROUP_USERS_INFO_0* PGROUP_USERS_INFO_0, LPGROUP_USERS_INFO_0;

struct GROUP_USERS_INFO_1{
    LPWSTR grui1_name;
    DWORD grui1_attributes;
}
alias GROUP_USERS_INFO_1* PGROUP_USERS_INFO_1, LPGROUP_USERS_INFO_1;

struct LOCALGROUP_INFO_0{
    LPWSTR lgrpi0_name;
}
alias LOCALGROUP_INFO_0* PLOCALGROUP_INFO_0, LPLOCALGROUP_INFO_0;

struct LOCALGROUP_INFO_1{
    LPWSTR lgrpi1_name;
    LPWSTR lgrpi1_comment;
}
alias LOCALGROUP_INFO_1* PLOCALGROUP_INFO_1, LPLOCALGROUP_INFO_1;

struct LOCALGROUP_INFO_1002{
    LPWSTR lgrpi1002_comment;
}
alias LOCALGROUP_INFO_1002* PLOCALGROUP_INFO_1002, LPLOCALGROUP_INFO_1002;

struct LOCALGROUP_MEMBERS_INFO_0{
    PSID lgrmi0_sid;
}
alias LOCALGROUP_MEMBERS_INFO_0* PLOCALGROUP_MEMBERS_INFO_0, LPLOCALGROUP_MEMBERS_INFO_0;

struct LOCALGROUP_MEMBERS_INFO_1{
    PSID lgrmi1_sid;
    SID_NAME_USE lgrmi1_sidusage;
    LPWSTR lgrmi1_name;
}
alias LOCALGROUP_MEMBERS_INFO_1* PLOCALGROUP_MEMBERS_INFO_1, LPLOCALGROUP_MEMBERS_INFO_1;

struct LOCALGROUP_MEMBERS_INFO_2{
    PSID lgrmi2_sid;
    SID_NAME_USE lgrmi2_sidusage;
    LPWSTR lgrmi2_domainandname;
}
alias LOCALGROUP_MEMBERS_INFO_2* PLOCALGROUP_MEMBERS_INFO_2, LPLOCALGROUP_MEMBERS_INFO_2;

struct LOCALGROUP_MEMBERS_INFO_3{
    LPWSTR lgrmi3_domainandname;
}
alias LOCALGROUP_MEMBERS_INFO_3* PLOCALGROUP_MEMBERS_INFO_3, LPLOCALGROUP_MEMBERS_INFO_3;

struct LOCALGROUP_USERS_INFO_0{
    LPWSTR lgrui0_name;
}
alias LOCALGROUP_USERS_INFO_0* PLOCALGROUP_USERS_INFO_0, LPLOCALGROUP_USERS_INFO_0;

struct NET_DISPLAY_USER{
    LPWSTR usri1_name;
    LPWSTR usri1_comment;
    DWORD usri1_flags;
    LPWSTR usri1_full_name;
    DWORD usri1_user_id;
    DWORD usri1_next_index;
}
alias NET_DISPLAY_USER* PNET_DISPLAY_USER;

struct NET_DISPLAY_MACHINE{
    LPWSTR usri2_name;
    LPWSTR usri2_comment;
    DWORD usri2_flags;
    DWORD usri2_user_id;
    DWORD usri2_next_index;
}
alias NET_DISPLAY_MACHINE* PNET_DISPLAY_MACHINE;

struct NET_DISPLAY_GROUP{
    LPWSTR grpi3_name;
    LPWSTR grpi3_comment;
    DWORD grpi3_group_id;
    DWORD grpi3_attributes;
    DWORD grpi3_next_index;
}
alias NET_DISPLAY_GROUP* PNET_DISPLAY_GROUP;

struct ACCESS_INFO_0{
    LPTSTR acc0_resource_name;
}
alias ACCESS_INFO_0* PACCESS_INFO_0, LPACCESS_INFO_0;

struct ACCESS_INFO_1{
    LPTSTR acc1_resource_name;
    DWORD acc1_attr;
    DWORD acc1_count;
}
alias ACCESS_INFO_1* PACCESS_INFO_1, LPACCESS_INFO_1;

struct ACCESS_INFO_1002{
    DWORD acc1002_attr;
}
alias ACCESS_INFO_1002* PACCESS_INFO_1002, LPACCESS_INFO_1002;

struct ACCESS_LIST{
    LPTSTR acl_ugname;
    DWORD acl_access;
}
alias ACCESS_LIST* PACCESS_LIST, LPACCESS_LIST;

struct NETLOGON_INFO_1{
    DWORD netlog1_flags;
    NET_API_STATUS netlog1_pdc_connection_status;
}
alias NETLOGON_INFO_1* PNETLOGON_INFO_1;

struct NETLOGON_INFO_2{
    DWORD netlog2_flags;
    NET_API_STATUS netlog2_pdc_connection_status;
    LPWSTR netlog2_trusted_dc_name;
    NET_API_STATUS netlog2_tc_connection_status;
}
alias NETLOGON_INFO_2* PNETLOGON_INFO_2;

struct NETLOGON_INFO_3{
    DWORD netlog3_flags;
    DWORD netlog3_logon_attempts;
    DWORD netlog3_reserved1;
    DWORD netlog3_reserved2;
    DWORD netlog3_reserved3;
    DWORD netlog3_reserved4;
    DWORD netlog3_reserved5;
}
alias NETLOGON_INFO_3* PNETLOGON_INFO_3;

extern (Windows) {
deprecated {
    /* These are obsolete */
    NET_API_STATUS NetAccessAdd(LPCWSTR,DWORD,PBYTE,PDWORD);
    NET_API_STATUS NetAccessEnum(LPCWSTR,LPCWSTR,DWORD,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
    NET_API_STATUS NetAccessGetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE*);
    NET_API_STATUS NetAccessSetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE,PDWORD);
    NET_API_STATUS NetAccessDel(LPCWSTR,LPCWSTR);
    NET_API_STATUS NetAccessGetUserPerms(LPCWSTR,LPCWSTR,LPCWSTR,PDWORD);
}
NET_API_STATUS NetUserAdd(LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetUserEnum(LPCWSTR,DWORD,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS NetUserGetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE*);
NET_API_STATUS NetUserSetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetUserDel(LPCWSTR,LPCWSTR);
NET_API_STATUS NetUserGetGroups(LPCWSTR,LPCWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD);
NET_API_STATUS NetUserSetGroups(LPCWSTR,LPCWSTR,DWORD,PBYTE,DWORD);
NET_API_STATUS NetUserGetLocalGroups(LPCWSTR,LPCWSTR,DWORD,DWORD,PBYTE*,DWORD,PDWORD,PDWORD);
NET_API_STATUS NetUserModalsGet(LPCWSTR,DWORD,PBYTE*);
NET_API_STATUS NetUserModalsSet(LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetUserChangePassword(LPCWSTR,LPCWSTR,LPCWSTR,LPCWSTR);
NET_API_STATUS NetGroupAdd(LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetGroupAddUser(LPCWSTR,LPCWSTR,LPCWSTR);
NET_API_STATUS NetGroupEnum(LPCWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS NetGroupGetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE*);
NET_API_STATUS NetGroupSetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetGroupDel(LPCWSTR,LPCWSTR);
NET_API_STATUS NetGroupDelUser(LPCWSTR,LPCWSTR,LPCWSTR);
NET_API_STATUS NetGroupGetUsers(LPCWSTR,LPCWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS NetGroupSetUsers(LPCWSTR,LPCWSTR,DWORD,PBYTE,DWORD);
NET_API_STATUS NetLocalGroupAdd(LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetLocalGroupAddMember(LPCWSTR,LPCWSTR,PSID);
NET_API_STATUS NetLocalGroupEnum(LPCWSTR,DWORD,PBYTE*,DWORD,PDWORD,PDWORD,PDWORD);
NET_API_STATUS NetLocalGroupGetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE*);
NET_API_STATUS NetLocalGroupSetInfo(LPCWSTR,LPCWSTR,DWORD,PBYTE,PDWORD);
NET_API_STATUS NetLocalGroupDel(LPCWSTR,LPCWSTR);
NET_API_STATUS NetLocalGroupDelMember(LPCWSTR,LPCWSTR,PSID);
NET_API_STATUS NetLocalGroupGetMembers(LPCWSTR,LPCWSTR,DWORD,PBYTE*,DWORD,
PDWORD,PDWORD,PDWORD);
NET_API_STATUS NetLocalGroupSetMembers(LPCWSTR,LPCWSTR,DWORD,PBYTE,DWORD);
NET_API_STATUS NetLocalGroupAddMembers(LPCWSTR,LPCWSTR,DWORD,PBYTE,DWORD);
NET_API_STATUS NetLocalGroupDelMembers(LPCWSTR,LPCWSTR,DWORD,PBYTE,DWORD);
NET_API_STATUS NetQueryDisplayInformation(LPCWSTR,DWORD,DWORD,DWORD,DWORD,PDWORD,PVOID*);
NET_API_STATUS NetGetDisplayInformationIndex(LPCWSTR,DWORD,LPCWSTR,PDWORD);
NET_API_STATUS NetGetDCName(LPCWSTR,LPCWSTR,PBYTE*);
NET_API_STATUS NetGetAnyDCName(LPCWSTR,LPCWSTR,PBYTE*);
NET_API_STATUS I_NetLogonControl(LPCWSTR,DWORD,DWORD,PBYTE*);
NET_API_STATUS I_NetLogonControl2(LPCWSTR,DWORD,DWORD,PBYTE,PBYTE*);
}
                                                                                                                                                                  /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmalert.d)
 */
module core.sys.windows.lmalert;
version (Windows):
pragma(lib, "netapi32");

private import core.sys.windows.lmcons, core.sys.windows.windef;

const TCHAR[]
    ALERTER_MAILSLOT     = `\\.\MAILSLOT\Alerter`,
    ALERT_PRINT_EVENT    = "PRINTING",
    ALERT_MESSAGE_EVENT  = "MESSAGE",
    ALERT_ERRORLOG_EVENT = "ERRORLOG",
    ALERT_ADMIN_EVENT    = "ADMIN",
    ALERT_USER_EVENT     = "USER";
//MACRO #define ALERT_OTHER_INFO(x) ((PBYTE)(x)+sizeof(STD_ALERT))

//MACRO #define ALERT_VAR_DATA(p) ((PBYTE)(p)+sizeof(*p))

enum PRJOB_QSTATUS     = 3;
enum PRJOB_DEVSTATUS   = 508;
enum PRJOB_COMPLETE    = 4;
enum PRJOB_INTERV      = 8;
enum PRJOB_            = 16;
enum PRJOB_DESTOFFLINE = 32;
enum PRJOB_DESTPAUSED  = 64;
enum PRJOB_NOTIFY      = 128;
enum PRJOB_DESTNOPAPER = 256;
enum PRJOB_DELETED     = 32768;
enum PRJOB_QS_QUEUED   = 0;
enum PRJOB_QS_PAUSED   = 1;
enum PRJOB_QS_SPOOLING = 2;
enum PRJOB_QS_PRINTING = 3;

struct ADMIN_OTHER_INFO{
    DWORD alrtad_errcode;
    DWORD alrtad_numstrings;
}
alias ADMIN_OTHER_INFO* PADMIN_OTHER_INFO, LPADMIN_OTHER_INFO;

struct STD_ALERT{
    DWORD alrt_timestamp;
    TCHAR[EVLEN+1] alrt_eventname = 0;
    TCHAR[SNLEN+1] alrt_servicename = 0;
}
alias STD_ALERT* PSTD_ALERT, LPSTD_ALERT;

struct ERRLOG_OTHER_INFO{
    DWORD alrter_errcode;
    DWORD alrter_offset;
}
alias ERRLOG_OTHER_INFO* PERRLOG_OTHER_INFO, LPERRLOG_OTHER_INFO;

struct PRINT_OTHER_INFO{
    DWORD alrtpr_jobid;
    DWORD alrtpr_status;
    DWORD alrtpr_submitted;
    DWORD alrtpr_size;
}
alias PRINT_OTHER_INFO* PPRINT_OTHER_INFO, LPPRINT_OTHER_INFO;

struct USER_OTHER_INFO{
    DWORD alrtus_errcode;
    DWORD alrtus_numstrings;
}
alias USER_OTHER_INFO* PUSER_OTHER_INFO, LPUSER_OTHER_INFO;

extern (Windows) {
NET_API_STATUS NetAlertRaise(LPCWSTR,PVOID,DWORD);
NET_API_STATUS NetAlertRaiseEx(LPCWSTR,PVOID,DWORD,LPCWSTR);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmapibuf.d)
 */
module core.sys.windows.lmapibuf;
version (Windows):
pragma(lib, "netapi32");

private import core.sys.windows.lmcons, core.sys.windows.windef;

extern (Windows) {
    NET_API_STATUS NetApiBufferAllocate(DWORD, PVOID*);
    NET_API_STATUS NetApiBufferFree(PVOID);
    NET_API_STATUS NetApiBufferReallocate(PVOID, DWORD, PVOID*);
    NET_API_STATUS NetApiBufferSize(PVOID, PDWORD);
    NET_API_STATUS NetapipBufferAllocate(DWORD, PVOID*);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmat.d)
 */
module core.sys.windows.lmat;
version (Windows):
pragma(lib, "netapi32");

private import core.sys.windows.lmcons, core.sys.windows.windef;

enum JOB_RUN_PERIODICALLY = 1;
enum JOB_EXEC_ERROR       = 2;
enum JOB_RUNS_TODAY       = 4;
enum JOB_ADD_CURRENT_DATE = 8;
enum JOB_NONINTERACTIVE   = 16;
enum JOB_INPUT_FLAGS      = JOB_RUN_PERIODICALLY | JOB_ADD_CURRENT_DATE
                             | JOB_NONINTERACTIVE;
enum JOB_OUTPUT_FLAGS     = JOB_RUN_PERIODICALLY | JOB_EXEC_ERROR
                             | JOB_RUNS_TODAY | JOB_NONINTERACTIVE;

struct AT_ENUM {
    DWORD JobId;
    DWORD_PTR JobTime;
    DWORD DaysOfMonth;
    UCHAR DaysOfWeek;
    UCHAR Flags;
    LPWSTR Command;
}
alias AT_ENUM* PAT_ENUM, LPAT_ENUM;

struct AT_INFO {
    DWORD_PTR JobTime;
    DWORD DaysOfMonth;
    UCHAR DaysOfWeek;
    UCHAR Flags;
    LPWSTR Command;
}
alias AT_INFO* PAT_INFO, LPAT_INFO;

extern (Windows) {
    NET_API_STATUS NetScheduleJobAdd(LPWSTR, PBYTE, LPDWORD);
    NET_API_STATUS NetScheduleJobDel(LPWSTR, DWORD, DWORD);
    NET_API_STATUS NetScheduleJobEnum(LPWSTR, PBYTE*, DWORD, PDWORD, PDWORD,
      PDWORD);
    NET_API_STATUS NetScheduleJobGetInfo(LPWSTR, DWORD, PBYTE*);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmaudit.d)
 */
// COMMENT: This file may be deprecated.
module core.sys.windows.lmaudit;
version (Windows):

private import core.sys.windows.lmcons, core.sys.windows.windef;

enum LOGFLAGS_FORWARD  = 0;
enum LOGFLAGS_BACKWARD = 1;
enum LOGFLAGS_SEEK     = 2;

enum ACTION_LOCKOUT     = 0;
enum ACTION_ADMINUNLOCK = 1;

enum AE_GUEST=0;
enum AE_USER=1;
enum AE_ADMIN=2;
enum AE_NORMAL=0;
enum AE_USERLIMIT=0;
enum AE_GENERAL=0;
enum AE_ERROR=1;
enum AE_SESSDIS=1;
enum AE_BADPW=1;
enum AE_AUTODIS=2;
enum AE_UNSHARE=2;
enum AE_ADMINPRIVREQD=2;
enum AE_ADMINDIS=3;
enum AE_NOACCESSPERM=3;
enum AE_ACCRESTRICT=4;
enum AE_NORMAL_CLOSE=0;
enum AE_SES_CLOSE=1;
enum AE_ADMIN_CLOSE=2;
enum AE_LIM_UNKNOWN=0;
enum AE_LIM_LOGONHOURS=1;
enum AE_LIM_EXPIRED=2;
enum AE_LIM_INVAL_WKSTA=3;
enum AE_LIM_DISABLED=4;
enum AE_LIM_DELETED=5;
enum AE_MOD=0;
enum AE_DELETE=1;
enum AE_ADD=2;

enum AE_UAS_USER   = 0;
enum AE_UAS_GROUP  = 1;
enum AE_UAS_MODALS = 2;

enum SVAUD_SERVICE       = 1;
enum SVAUD_GOODSESSLOGON = 6;
enum SVAUD_BADSESSLOGON  = 24;
enum SVAUD_SESSLOGON     = SVAUD_GOODSESSLOGON|SVAUD_BADSESSLOGON;
enum SVAUD_GOODNETLOGON  = 96;
enum SVAUD_BADNETLOGON   = 384;
enum SVAUD_NETLOGON      = SVAUD_GOODNETLOGON|SVAUD_BADNETLOGON;
enum SVAUD_LOGON         = SVAUD_NETLOGON|SVAUD_SESSLOGON;
enum SVAUD_GOODUSE       = 0x600;
enum SVAUD_BADUSE        = 0x1800;
enum SVAUD_USE           = SVAUD_GOODUSE|SVAUD_BADUSE;
enum SVAUD_USERLIST      = 8192;
enum SVAUD_PERMISSIONS   = 16384;
enum SVAUD_RESOURCE      = 32768;
enum SVAUD_LOGONLIM      = 65536;

enum AA_AUDIT_ALL=1;
enum AA_A_OWNER=4;
enum AA_CLOSE=8;
enum AA_S_OPEN=16;
enum AA_S_WRITE=32;
enum AA_S_CREATE=32;
enum AA_S_DELETE=64;
enum AA_S_ACL=128;
enum AA_S_ALL=253;
enum AA_F_OPEN=256;
enum AA_F_WRITE=512;
enum AA_F_CREATE=512;
enum AA_F_DELETE=1024;
enum AA_F_ACL=2048;
enum AA_F_ALL = AA_F_OPEN|AA_F_WRITE|AA_F_DELETE|AA_F_ACL;
enum AA_A_OPEN=2048;
enum AA_A_WRITE=4096;
enum AA_A_CREATE=8192;
enum AA_A_DELETE=16384;
enum AA_A_ACL=32768;
enum AA_A_ALL = AA_F_OPEN|AA_F_WRITE|AA_F_DELETE|AA_F_ACL;

struct AUDIT_ENTRY{
    DWORD ae_len;
    DWORD ae_reserved;
    DWORD ae_time;
    DWORD ae_type;
    DWORD ae_data_offset;
    DWORD ae_data_size;
}
alias AUDIT_ENTRY* PAUDIT_ENTRY, LPAUDIT_ENTRY;

struct HLOG{
    DWORD time;
    DWORD last_flags;
    DWORD offset;
    DWORD rec_offset;
}
alias HLOG* PHLOG, LPHLOG;

struct AE_SRVSTATUS{
    DWORD ae_sv_status;
}
alias AE_SRVSTATUS* PAE_SRVSTATUS, LPAE_SRVSTATUS;

struct AE_SESSLOGON{
    DWORD ae_so_compname;
    DWORD ae_so_username;
    DWORD ae_so_privilege;
}
alias AE_SESSLOGON* PAE_SESSLOGON, LPAE_SESSLOGON;

struct AE_SESSLOGOFF{
    DWORD ae_sf_compname;
    DWORD ae_sf_username;
    DWORD ae_sf_reason;
}
alias AE_SESSLOGOFF* PAE_SESSLOGOFF, LPAE_SESSLOGOFF;

struct AE_SESSPWERR{
    DWORD ae_sp_compname;
    DWORD ae_sp_username;
}
alias AE_SESSPWERR* PAE_SESSPWERR, LPAE_SESSPWERR;

struct AE_CONNSTART{
    DWORD ae_ct_compname;
    DWORD ae_ct_username;
    DWORD ae_ct_netname;
    DWORD ae_ct_connid;
}
alias AE_CONNSTART* PAE_CONNSTART, LPAE_CONNSTART;

struct AE_CONNSTOP{
    DWORD ae_cp_compname;
    DWORD ae_cp_username;
    DWORD ae_cp_netname;
    DWORD ae_cp_connid;
    DWORD ae_cp_reason;
}
alias AE_CONNSTOP* PAE_CONNSTOP, LPAE_CONNSTOP;

struct AE_CONNREJ{
    DWORD ae_cr_compname;
    DWORD ae_cr_username;
    DWORD ae_cr_netname;
    DWORD ae_cr_reason;
}
alias AE_CONNREJ* PAE_CONNREJ, LPAE_CONNREJ;

struct AE_RESACCESS{
    DWORD ae_ra_compname;
    DWORD ae_ra_username;
    DWORD ae_ra_resname;
    DWORD ae_ra_operation;
    DWORD ae_ra_returncode;
    DWORD ae_ra_restype;
    DWORD ae_ra_fileid;
}
alias AE_RESACCESS* PAE_RESACCESS, LPAE_RESACCESS;

struct AE_RESACCESSREJ{
    DWORD ae_rr_compname;
    DWORD ae_rr_username;
    DWORD ae_rr_resname;
    DWORD ae_rr_operation;
}
alias AE_RESACCESSREJ* PAE_RESACCESSREJ, LPAE_RESACCESSREJ;

struct AE_CLOSEFILE{
    DWORD ae_cf_compname;
    DWORD ae_cf_username;
    DWORD ae_cf_resname;
    DWORD ae_cf_fileid;
    DWORD ae_cf_duration;
    DWORD ae_cf_reason;
}
alias AE_CLOSEFILE* PAE_CLOSEFILE, LPAE_CLOSEFILE;

struct AE_SERVICESTAT{
    DWORD ae_ss_compname;
    DWORD ae_ss_username;
    DWORD ae_ss_svcname;
    DWORD ae_ss_status;
    DWORD ae_ss_code;
    DWORD ae_ss_text;
    DWORD ae_ss_returnval;
}
alias AE_SERVICESTAT* PAE_SERVICESTAT, LPAE_SERVICESTAT;

struct AE_ACLMOD{
    DWORD ae_am_compname;
    DWORD ae_am_username;
    DWORD ae_am_resname;
    DWORD ae_am_action;
    DWORD ae_am_datalen;
}
alias AE_ACLMOD* PAE_ACLMOD, LPAE_ACLMOD;

struct AE_UASMOD{
    DWORD ae_um_compname;
    DWORD ae_um_username;
    DWORD ae_um_resname;
    DWORD ae_um_rectype;
    DWORD ae_um_action;
    DWORD ae_um_datalen;
}
alias AE_UASMOD* PAE_UASMOD, LPAE_UASMOD;

struct AE_NETLOGON{
    DWORD ae_no_compname;
    DWORD ae_no_username;
    DWORD ae_no_privilege;
    DWORD ae_no_authflags;
}
alias AE_NETLOGON* PAE_NETLOGON, LPAE_NETLOGON;

struct AE_NETLOGOFF{
    DWORD ae_nf_compname;
    DWORD ae_nf_username;
    DWORD ae_nf_reserved1;
    DWORD ae_nf_reserved2;
}
alias AE_NETLOGOFF* PAE_NETLOGOFF, LPAE_NETLOGOFF;

struct AE_ACCLIM{
    DWORD ae_al_compname;
    DWORD ae_al_username;
    DWORD ae_al_resname;
    DWORD ae_al_limit;
}
alias AE_ACCLIM* PAE_ACCLIM, LPAE_ACCLIM;

struct AE_LOCKOUT{
    DWORD ae_lk_compname;
    DWORD ae_lk_username;
    DWORD ae_lk_action;
    DWORD ae_lk_bad_pw_count;
}
alias AE_LOCKOUT* PAE_LOCKOUT, LPAE_LOCKOUT;

struct AE_GENERIC{
    DWORD ae_ge_msgfile;
    DWORD ae_ge_msgnum;
    DWORD ae_ge_params;
    DWORD ae_ge_param1;
    DWORD ae_ge_param2;
    DWORD ae_ge_param3;
    DWORD ae_ge_param4;
    DWORD ae_ge_param5;
    DWORD ae_ge_param6;
    DWORD ae_ge_param7;
    DWORD ae_ge_param8;
    DWORD ae_ge_param9;
}
alias AE_GENERIC* PAE_GENERIC, LPAE_GENERIC;

extern (Windows) {
deprecated {
NET_API_STATUS NetAuditClear(LPCWSTR,LPCWSTR,LPCWSTR);
NET_API_STATUS NetAuditRead(LPTSTR,LPTSTR,LPHLOG,DWORD,PDWORD,DWORD,DWORD,PBYTE*,DWORD,PDWORD,PDWORD);
NET_API_STATUS NetAuditWrite(DWORD,PBYTE,DWORD,LPTSTR,PBYTE);
}
}

/+
/* MinGW: These conflict with struct typedefs, why? */
enum AE_SRVSTATUS=0;
enum AE_SESSLOGON=1;
enum AE_SESSLOGOFF=2;
enum AE_SESSPWERR=3;
enum AE_CONNSTART=4;
enum AE_CONNSTOP=5;
enum AE_CONNREJ=6;
enum AE_RESACCESS=7;
enum AE_RESACCESSREJ=8;
enum AE_CLOSEFILE=9;
enum AE_SERVICESTAT=11;
enum AE_ACLMOD=12;
enum AE_UASMOD=13;
enum AE_NETLOGON=14;
enum AE_NETLOGOFF=15;
enum AE_NETLOGDENIED=16;
enum AE_ACCLIMITEXCD=17;
enum AE_RESACCESS2=18;
enum AE_ACLMODFAIL=19;
enum AE_LOCKOUT=20;
enum AE_GENERIC_TYPE=21;
enum AE_SRVSTART=0;
enum AE_SRVPAUSED=1;
enum AE_SRVCONT=2;
enum AE_SRVSTOP=3;
+/
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmbrowsr.d)
 */
module core.sys.windows.lmbrowsr;
version (Windows):

private import core.sys.windows.lmcons, core.sys.windows.windef;

enum BROWSER_ROLE_PDC = 1;
enum BROWSER_ROLE_BDC = 2;

struct BROWSER_STATISTICS {
    LARGE_INTEGER StatisticsStartTime;
    LARGE_INTEGER NumberOfServerAnnouncements;
    LARGE_INTEGER NumberOfDomainAnnouncements;
    ULONG NumberOfElectionPackets;
    ULONG NumberOfMailslotWrites;
    ULONG NumberOfGetBrowserServerListRequests;
    ULONG NumberOfServerEnumerations;
    ULONG NumberOfDomainEnumerations;
    ULONG NumberOfOtherEnumerations;
    ULONG NumberOfMissedServerAnnouncements;
    ULONG NumberOfMissedMailslotDatagrams;
    ULONG NumberOfMissedGetBrowserServerListRequests;
    ULONG NumberOfFailedServerAnnounceAllocations;
    ULONG NumberOfFailedMailslotAllocations;
    ULONG NumberOfFailedMailslotReceives;
    ULONG NumberOfFailedMailslotWrites;
    ULONG NumberOfFailedMailslotOpens;
    ULONG NumberOfDuplicateMasterAnnouncements;
    LARGE_INTEGER NumberOfIllegalDatagrams;
}
alias BROWSER_STATISTICS* PBROWSER_STATISTICS, LPBROWSER_STATISTICS;

struct BROWSER_STATISTICS_100 {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER NumberOfServerAnnouncements;
    LARGE_INTEGER NumberOfDomainAnnouncements;
    ULONG NumberOfElectionPackets;
    ULONG NumberOfMailslotWrites;
    ULONG NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER NumberOfIllegalDatagrams;
}
alias BROWSER_STATISTICS_100* PBROWSER_STATISTICS_100;

struct BROWSER_STATISTICS_101 {
    LARGE_INTEGER StartTime;
    LARGE_INTEGER NumberOfServerAnnouncements;
    LARGE_INTEGER NumberOfDomainAnnouncements;
    ULONG NumberOfElectionPackets;
    ULONG NumberOfMailslotWrites;
    ULONG NumberOfGetBrowserServerListRequests;
    LARGE_INTEGER NumberOfIllegalDatagrams;
    ULONG NumberOfMissedServerAnnouncements;
    ULONG NumberOfMissedMailslotDatagrams;
    ULONG NumberOfMissedGetBrowserServerListRequests;
    ULONG NumberOfFailedServerAnnounceAllocations;
    ULONG NumberOfFailedMailslotAllocations;
    ULONG NumberOfFailedMailslotReceives;
    ULONG NumberOfFailedMailslotWrites;
    ULONG NumberOfFailedMailslotOpens;
    ULONG NumberOfDuplicateMasterAnnouncements;
}
alias BROWSER_STATISTICS_101* PBROWSER_STATISTICS_101;

extern (Windows) {
    NET_API_STATUS I_BrowserServerEnum(LPCWSTR, LPCWSTR, LPCWSTR, DWORD,
      PBYTE*, DWORD, PDWORD, PDWORD, DWORD, LPCWSTR, PDWORD);
    NET_API_STATUS I_BrowserServerEnumEx(LPCWSTR, LPCWSTR, LPCWSTR, DWORD,
      PBYTE*, DWORD, PDWORD, PDWORD, DWORD, LPCWSTR, LPCWSTR);
    NET_API_STATUS I_BrowserQueryEmulatedDomains(LPWSTR, PBYTE*, PDWORD);
    NET_API_STATUS I_BrowserQueryOtherDomains(LPCWSTR, PBYTE*, PDWORD, PDWORD);
    NET_API_STATUS I_BrowserResetNetlogonState(LPCWSTR);
    NET_API_STATUS I_BrowserSetNetlogonState(LPWSTR, LPWSTR, LPWSTR, DWORD);
    NET_API_STATUS I_BrowserQueryStatistics(LPCWSTR, LPBROWSER_STATISTICS*);
    NET_API_STATUS I_BrowserResetStatistics(LPCWSTR);
    WORD I_BrowserServerEnumForXactsrv(LPCWSTR, LPCWSTR, ULONG, USHORT, PVOID,
      WORD, DWORD, PDWORD, PDWORD, DWORD, LPCWSTR, LPCWSTR, PWORD);
    NET_API_STATUS I_BrowserDebugTrace(PWCHAR, PCHAR);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * Windows API header module
 *
 * Translated from MinGW Windows headers
 *
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0)
 * Source: $(DRUNTIMESRC src/core/sys/windows/_lmchdev.d)
 */
module core.sys.windows.lmchdev;
version (Windows):

// COMMENT: This file might be deprecated.

private import core.sys.windows.lmcons, core.sys.windows.windef;

enum CHARDEVQ_NO_REQUESTS  = -1;
enum CHARDEV_CLOSE         = 0;
enum CHARDEVQ_MAX_PRIORITY = 1;
enum CHARDEVQ_DEV_PARMNUM  = 1;

enum HANDLE_INFO_LEVEL_1 = 1;
enum HANDLE_CHARTIME_PARMNUM = 1;
enum HANDLE_CHARCOUNT_PARMNUM = 2;

enum CHARDEV_STAT_OPENED = 2;
enum CHARDEVQ_PRIORITY_PARMNUM = 2;
enum CHARDEVQ_DEVS_PARMNUM = 3;
enum CHARDEV_STAT_ERROR = 4;
enum CHARDEVQ_NUMUSERS_PARMNUM = 4;
enum CHARDEVQ_NUMAHEAD_PARMNUM = 5;
enum CHARDEVQ_DEF_PRIORITY = 5;
enum CHARDEVQ_PRIORITY_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+CHARDEVQ_PRIORITY_PARMNUM;
enum CHARDEVQ_DEVS_INFOLEVEL = PARMNUM_BASE_INFOLEVEL+CHARDEVQ_DEVS_PARMNUM;
enum CHARDEVQ_MIN_PRIORITY = 9;

struct CHARDEV_INFO_0 {
 LPWSTR ch0_dev;
}
alias CHARDEV_INFO_0* PCHARDEV_INFO_0, LPCHARDEV_INFO_0;

struct CHARDEV_INFO_1{
    LPWSTR ch1_dev;
    DWORD ch1_status;
    LPWSTR ch1_username;
    DWORD ch1_time;
}
alias CHARDEV_INFO_1* PCHARDEV_INFO_1, LPCHARDEV_INFO_1;

struct CHARDEVQ_INFO_0 {
 LPWSTR cq0_dev;
}
alias CHARDEVQ_INFO_0* PCHARDEVQ_INFO_0, LPCHARDEVQ_INFO_0;

struct CHARDEVQ_INFO_1{
    LPWSTR cq1_dev;
    DWORD cq1_priority;
    LPWSTR cq1_devs;
    DWORD cq1_numusers;
    DWORD cq1_numahead;
}
alias CHARDEVQ_INFO_1* PCHARDEVQ_INFO_1, LPCHARDEVQ_INFO_1;

struct CHARDEVQ_INFO_1002 {
    DWORD cq1002_priority;
}
alias CHARDEVQ_INFO_1002* PCHARDEVQ_INFO_1002, LPCHARDEVQ_INFO_1002;

struct CHARDEVQ_INFO_1003 {
    LPWSTR cq1003_devs;
}
alias CHARDEVQ_INFO_1003* PCHARDEVQ_INFO_1003, LPCHARDEVQ_INFO_1003;

struct HANDLE_INFO_1{
    DWORD hdli1_chartime;
    DWORD hdli1_charcount;
}
alias HANDLE_INFO_1* PHANDLE_INFO_1, LPHANDLE_INFO_1;

extern (Windows) {
    NET_API_STATUS NetCharDevEnum(LPCWSTR, DWORD, PBYTE*, DWORD, PDWORD, PDWORD, PDWORD);
    NET_API_STATUS NetCharDevGetInfo(LPCWSTR, LPCWSTR, DWORD, PBYTE*);
    NET_API_STATUS NetCharDevControl(LPCWSTR, LPCWSTR, DWORD);
    NET_API_STATUS NetCharDevQEnum(LPCWSTR, LPCWSTR, DWORD, PBYTE*, DWORD, PDWORD, PDWORD, PDWORD);
    NET_API_STATUS NetCharDevQGetInfo(LPCWSTR, LPCWSTR, LPCWSTR, DWORD, PBYTE*);
    NET_API_STATUS NetCharDevQSetInfo(LPCWSTR, LPCWSTR, DWORD, PBYTE, PDWORD);
    NET_API_STATUS NetCharDevQPurge(LPCWSTR, LPCWSTR);
    NET_API_STATUS NetCharDevQPurgeSelf(LPCWSTR, LPCWSTR, LPCWSTR);
    NET_API_STATUS NetHandleGetInfo(HANDLE, DWORD, PBYTE*);
    NET_API_STATUS NetHandleSetInfo(HANDLE, DWORD, PBYTE, DWORD, PDWORD);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         