r, possibly trivial.
  template<bool __trivially_destructible, typename... _Types>
    struct _Variant_storage;

  template <typename... _Types>
    using __select_index =
      typename __select_int::_Select_int_base<sizeof...(_Types),
					      unsigned char,
					      unsigned short>::type::value_type;

  template<typename... _Types>
    struct _Variant_storage<false, _Types...>
    {
      constexpr
      _Variant_storage()
      : _M_index(static_cast<__index_type>(variant_npos))
      { }

      template<size_t _Np, typename... _Args>
	constexpr
	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
	_M_index{_Np}
	{ }

      constexpr void _M_reset_impl()
      {
	__do_visit([](auto&& __this_mem) mutable
		   -> __detail::__variant::__variant_cookie
	  {
	    if constexpr (!is_same_v<remove_reference_t<decltype(__this_mem)>,
			  __variant_cookie>)
	      std::_Destroy(std::__addressof(__this_mem));
	    return {};
	  }, __variant_cast<_Types...>(*this));
      }

      void _M_reset()
      {
	_M_reset_impl();
	_M_index = static_cast<__index_type>(variant_npos);
      }

      ~_Variant_storage()
      { _M_reset(); }

      void*
      _M_storage() const
      {
	return const_cast<void*>(static_cast<const void*>(
	    std::addressof(_M_u)));
      }

      constexpr bool
      _M_valid() const noexcept
      {
	if constexpr (__never_valueless<_Types...>())
	  return true;
	return this->_M_index != __index_type(variant_npos);
      }

      _Variadic_union<_Types...> _M_u;
      using __index_type = __select_index<_Types...>;
      __index_type _M_index;
    };

  template<typename... _Types>
    struct _Variant_storage<true, _Types...>
    {
      constexpr
      _Variant_storage()
      : _M_index(static_cast<__index_type>(variant_npos))
      { }

      template<size_t _Np, typename... _Args>
	constexpr
	_Variant_storage(in_place_index_t<_Np>, _Args&&... __args)
	: _M_u(in_place_index<_Np>, std::forward<_Args>(__args)...),
	_M_index{_Np}
	{ }

      void _M_reset()
      { _M_index = static_cast<__index_type>(variant_npos); }

      void*
      _M_storage() const
      {
	return const_cast<void*>(static_cast<const void*>(
	    std::addressof(_M_u)));
      }

      constexpr bool
      _M_valid() const noexcept
      {
	if constexpr (__never_valueless<_Types...>())
	  return true;
	return this->_M_index != static_cast<__index_type>(variant_npos);
      }

      _Variadic_union<_Types...> _M_u;
      using __index_type = __select_index<_Types...>;
      __index_type _M_index;
    };

  template<typename... _Types>
    using _Variant_storage_alias =
	_Variant_storage<_Traits<_Types...>::_S_trivial_dtor, _Types...>;

  template<typename _Tp, typename _Up>
    void __variant_construct_single(_Tp&& __lhs, _Up&& __rhs_mem)
    {
      void* __storage = std::addressof(__lhs._M_u);
      using _Type = remove_reference_t<decltype(__rhs_mem)>;
      if constexpr (!is_same_v<_Type, __variant_cookie>)
        ::new (__storage)
	  _Type(std::forward<decltype(__rhs_mem)>(__rhs_mem));
    }

  template<typename... _Types, typename _Tp, typename _Up>
    void __variant_construct(_Tp&& __lhs, _Up&& __rhs)
    {
      __lhs._M_index = __rhs._M_index;
      __do_visit([&__lhs](auto&& __rhs_mem) mutable
		 -> __detail::__variant::__variant_cookie
        {
	  __variant_construct_single(std::forward<_Tp>(__lhs),
	      std::forward<decltype(__rhs_mem)>(__rhs_mem));
	  return {};
	}, __variant_cast<_Types...>(std::forward<_Up>(__rhs)));
    }

  // The following are (Copy|Move) (ctor|assign) layers for forwarding
  // triviality and handling non-trivial SMF behaviors.

  template<bool, typename... _Types>
    struct _Copy_ctor_base : _Variant_storage_alias<_Types...>
    {
      using _Base = _Variant_storage_alias<_Types...>;
      using _Base::_Base;

      _Copy_ctor_base(const _Copy_ctor_base& __rhs)
	  noexcept(_Traits<_Types...>::_S_nothrow_copy_ctor)
      {
	__variant_construct<_Types...>(*this, __rhs);
      }

      _Copy_ctor_base(_Copy_ctor_base&&) = default;
      _Copy_ctor_base& operator=(const _Copy_ctor_base&) = default;
      _Copy_ctor_base& operator=(_Copy_ctor_base&&) = default;
    };

  template<typename... _Types>
    struct _Copy_ctor_base<true, _Types...> : _Variant_storage_alias<_Types...>
    {
      using _Base = _Variant_storage_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Copy_ctor_alias =
	_Copy_ctor_base<_Traits<_Types...>::_S_trivial_copy_ctor, _Types...>;

  template<bool, typename... _Types>
    struct _Move_ctor_base : _Copy_ctor_alias<_Types...>
    {
      using _Base = _Copy_ctor_alias<_Types...>;
      using _Base::_Base;

      _Move_ctor_base(_Move_ctor_base&& __rhs)
	  noexcept(_Traits<_Types...>::_S_nothrow_move_ctor)
      {
	__variant_construct<_Types...>(*this, std::move(__rhs));
      }

      template<typename _Up>
        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
        {
	  this->_M_reset();
	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
	  this->_M_index = __rhs_index;
	}

      template<typename _Up>
        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
        {
	  this->_M_reset();
	  __variant_construct_single(*this, __rhs);
	  this->_M_index = __rhs_index;
	}

      _Move_ctor_base(const _Move_ctor_base&) = default;
      _Move_ctor_base& operator=(const _Move_ctor_base&) = default;
      _Move_ctor_base& operator=(_Move_ctor_base&&) = default;
    };

  template<typename... _Types>
    struct _Move_ctor_base<true, _Types...> : _Copy_ctor_alias<_Types...>
    {
      using _Base = _Copy_ctor_alias<_Types...>;
      using _Base::_Base;

      template<typename _Up>
        void _M_destructive_move(unsigned short __rhs_index, _Up&& __rhs)
        {
	  this->_M_reset();
	  __variant_construct_single(*this, std::forward<_Up>(__rhs));
	  this->_M_index = __rhs_index;
	}

      template<typename _Up>
        void _M_destructive_copy(unsigned short __rhs_index, const _Up& __rhs)
        {
	  this->_M_reset();
	  __variant_construct_single(*this, __rhs);
	  this->_M_index = __rhs_index;
	}
    };

  template<typename... _Types>
    using _Move_ctor_alias =
	_Move_ctor_base<_Traits<_Types...>::_S_trivial_move_ctor, _Types...>;

  template<bool, typename... _Types>
    struct _Copy_assign_base : _Move_ctor_alias<_Types...>
    {
      using _Base = _Move_ctor_alias<_Types...>;
      using _Base::_Base;

      _Copy_assign_base&
      operator=(const _Copy_assign_base& __rhs)
	  noexcept(_Traits<_Types...>::_S_nothrow_copy_assign)
      {
	__do_visit<__visit_with_index>([this](auto&& __rhs_mem,
					      auto __rhs_index) mutable
	    -> __detail::__variant::__variant_idx_cookie
	  {
	    if constexpr (__rhs_index != variant_npos)
	      {
		if (this->_M_index == __rhs_index)
		  __variant::__get<__rhs_index>(*this) = __rhs_mem;
		else
		  {
		    using __rhs_type = __remove_cvref_t<decltype(__rhs_mem)>;
		    if constexpr (is_nothrow_copy_constructible_v<__rhs_type>
			|| !is_nothrow_move_constructible_v<__rhs_type>)
		      // The standard says this->emplace<__rhs_type>(__rhs_mem)
		      // should be used here, but _M_destructive_copy is
		      // equivalent in this case. Either copy construction
		      // doesn't throw, so _M_destructive_copy gives strong
		      // exception safety guarantee, or both copy construction
		      // and move construction can throw, so emplace only gives
		      // basic exception safety anyway.
		      this->_M_destructive_copy(__rhs_index, __rhs_mem);
		    else
		      __variant_cast<_Types...>(*this)
			= variant<_Types...>(std::in_place_index<__rhs_index>,
					     __rhs_mem);
		  }
	      }
	    else
	      this->_M_reset();
	    return {};
	  }, __variant_cast<_Types...>(__rhs));
	return *this;
      }

      _Copy_assign_base(const _Copy_assign_base&) = default;
      _Copy_assign_base(_Copy_assign_base&&) = default;
      _Copy_assign_base& operator=(_Copy_assign_base&&) = default;
    };

  template<typename... _Types>
    struct _Copy_assign_base<true, _Types...> : _Move_ctor_alias<_Types...>
    {
      using _Base = _Move_ctor_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Copy_assign_alias =
      _Copy_assign_base<_Traits<_Types...>::_S_trivial_copy_assign, _Types...>;

  template<bool, typename... _Types>
    struct _Move_assign_base : _Copy_assign_alias<_Types...>
    {
      using _Base = _Copy_assign_alias<_Types...>;
      using _Base::_Base;

      _Move_assign_base&
      operator=(_Move_assign_base&& __rhs)
	  noexcept(_Traits<_Types...>::_S_nothrow_move_assign)
      {
	__do_visit<__visit_with_index>([this](auto&& __rhs_mem,
					      auto __rhs_index) mutable
	    -> __detail::__variant::__variant_idx_cookie
	  {
	    if constexpr (__rhs_index != variant_npos)
	      {
		if (this->_M_index == __rhs_index)
		  __variant::__get<__rhs_index>(*this) = std::move(__rhs_mem);
		else
		  __variant_cast<_Types...>(*this)
		    .template emplace<__rhs_index>(std::move(__rhs_mem));
	      }
	    else
	      this->_M_reset();
	    return {};
	  }, __variant_cast<_Types...>(__rhs));
	return *this;
      }

      _Move_assign_base(const _Move_assign_base&) = default;
      _Move_assign_base(_Move_assign_base&&) = default;
      _Move_assign_base& operator=(const _Move_assign_base&) = default;
    };

  template<typename... _Types>
    struct _Move_assign_base<true, _Types...> : _Copy_assign_alias<_Types...>
    {
      using _Base = _Copy_assign_alias<_Types...>;
      using _Base::_Base;
    };

  template<typename... _Types>
    using _Move_assign_alias =
      _Move_assign_base<_Traits<_Types...>::_S_trivial_move_assign, _Types...>;

  template<typename... _Types>
    struct _Variant_base : _Move_assign_alias<_Types...>
    {
      using _Base = _Move_assign_alias<_Types...>;

      constexpr
      _Variant_base()
	  noexcept(_Traits<_Types...>::_S_nothrow_default_ctor)
      : _Variant_base(in_place_index<0>) { }

      template<size_t _Np, typename... _Args>
	constexpr explicit
	_Variant_base(in_place_index_t<_Np> __i, _Args&&... __args)
	: _Base(__i, std::forward<_Args>(__args)...)
	{ }

      _Variant_base(const _Variant_base&) = default;
      _Variant_base(_Variant_base&&) = default;
      _Variant_base& operator=(const _Variant_base&) = default;
      _Variant_base& operator=(_Variant_base&&) = default;
    };

  // For how many times does _Tp appear in _Tuple?
  template<typename _Tp, typename _Tuple>
    struct __tuple_count;

  template<typename _Tp, typename _Tuple>
    inline constexpr size_t __tuple_count_v =
      __tuple_count<_Tp, _Tuple>::value;

  template<typename _Tp, typename... _Types>
    struct __tuple_count<_Tp, tuple<_Types...>>
    : integral_constant<size_t, 0> { };

  template<typename _Tp, typename _First, typename... _Rest>
    struct __tuple_count<_Tp, tuple<_First, _Rest...>>
    : integral_constant<
	size_t,
	__tuple_count_v<_Tp, tuple<_Rest...>> + is_same_v<_Tp, _First>> { };

  // TODO: Reuse this in <tuple> ?
  template<typename _Tp, typename... _Types>
    inline constexpr bool __exactly_once =
      __tuple_count_v<_Tp, tuple<_Types...>> == 1;

  // Takes _Types and create an overloaded _S_fun for each type.
  // If a type appears more than once in _Types, create only one overload.
  template<typename... _Types>
    struct __overload_set
    { static void _S_fun(); };

  template<typename _First, typename... _Rest>
    struct __overload_set<_First, _Rest...> : __overload_set<_Rest...>
    {
      using __overload_set<_Rest...>::_S_fun;
      static integral_constant<size_t, sizeof...(_Rest)> _S_fun(_First);
    };

  template<typename... _Rest>
    struct __overload_set<void, _Rest...> : __overload_set<_Rest...>
    {
      using __overload_set<_Rest...>::_S_fun;
    };

  // Helper for variant(_Tp&&) and variant::operator=(_Tp&&).
  // __accepted_index maps an arbitrary _Tp to an alternative type in _Variant
  // (or to variant_npos).
  template<typename _Tp, typename _Variant, typename = void>
    struct __accepted_index
    { static constexpr size_t value = variant_npos; };

  template<typename _Tp, typename... _Types>
    struct __accepted_index<
      _Tp, variant<_Types...>,
      void_t<decltype(__overload_set<_Types...>::_S_fun(std::declval<_Tp>()))>>
    {
      static constexpr size_t value = sizeof...(_Types) - 1
	- decltype(__overload_set<_Types...>::
		   _S_fun(std::declval<_Tp>()))::value;
    };

  // Returns the raw storage for __v.
  template<typename _Variant>
    void* __get_storage(_Variant&& __v)
    { return __v._M_storage(); }

  template <typename _Maybe_variant_cookie, typename _Variant>
    struct _Extra_visit_slot_needed
    {
      template <typename> struct _Variant_never_valueless;

      template <typename... _Types>
	struct _Variant_never_valueless<variant<_Types...>>
	: bool_constant<__never_valueless<_Types...>()> {};

      static constexpr bool value =
	(is_same_v<_Maybe_variant_cookie, __variant_cookie>
	 || is_same_v<_Maybe_variant_cookie, __variant_idx_cookie>)
	&& !_Variant_never_valueless<__remove_cvref_t<_Variant>>::value;
    };

  // Used for storing a multi-dimensional vtable.
  template<typename _Tp, size_t... _Dimensions>
    struct _Multi_array;

  // Partial specialization with rank zero, stores a single _Tp element.
  template<typename _Tp>
    struct _Multi_array<_Tp>
    {
      constexpr const _Tp&
      _M_access() const
      { return _M_data; }

      _Tp _M_data;
    };

  // Partial specialization with rank >= 1.
  template<typename _Ret,
	   typename _Visitor,
	   typename... _Variants,
	   size_t __first, size_t... __rest>
    struct _Multi_array<_Ret(*)(_Visitor, _Variants...), __first, __rest...>
    {
      static constexpr size_t __index =
	sizeof...(_Variants) - sizeof...(__rest) - 1;

      using _Variant = typename _Nth_type<__index, _Variants...>::type;

      static constexpr int __do_cookie =
	_Extra_visit_slot_needed<_Ret, _Variant>::value ? 1 : 0;

      using _Tp = _Ret(*)(_Visitor, _Variants...);

      template<typename... _Args>
	constexpr const _Tp&
	_M_access(size_t __first_index, _Args... __rest_indices) const
        {
	  return _M_arr[__first_index + __do_cookie]
	    ._M_access(__rest_indices...);
	}

      _Multi_array<_Tp, __rest...> _M_arr[__first + __do_cookie];
    };

  // Creates a multi-dimensional vtable recursively.
  //
  // The __same_return_types non-type template parameter specifies whether
  // to enforce that all visitor invocations return the same type. This is
  // required by std::visit but not std::visit<R>.
  //
  // For example,
  // visit([](auto, auto){},
  //       variant<int, char>(),  // typedef'ed as V1
  //       variant<float, double, long double>())  // typedef'ed as V2
  // will trigger instantiations of:
  // __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 2, 3>,
  //                   tuple<V1&&, V2&&>, std::index_sequence<>>
  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,
  //                     tuple<V1&&, V2&&>, std::index_sequence<0>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 0>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 1>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<0, 2>>
  //   __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&), 3>,
  //                     tuple<V1&&, V2&&>, std::index_sequence<1>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 0>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 1>>
  //     __gen_vtable_impl<true, _Multi_array<void(*)(V1&&, V2&&)>,
  //                       tuple<V1&&, V2&&>, std::index_sequence<1, 2>>
  // The returned multi-dimensional vtable can be fast accessed by the visitor
  // using index calculation.
  template<bool __same_return_types,
	   typename _Array_type, typename _Variant_tuple, typename _Index_seq>
    struct __gen_vtable_impl;

  // Defines the _S_apply() member that returns a _Multi_array populated
  // with function pointers that perform the visitation expressions e(m)
  // for each valid pack of indexes into the variant types _Variants.
  //
  // This partial specialization builds up the index sequences by recursively
  // calling _S_apply() on the next specialization of __gen_vtable_impl.
  // The base case of the recursion defines the actual function pointers.
  template<bool __same_return_types,
	   typename _Result_type, typename _Visitor, size_t... __dimensions,
	   typename... _Variants, size_t... __indices>
    struct __gen_vtable_impl<
        __same_return_types,
	_Multi_array<_Result_type (*)(_Visitor, _Variants...), __dimensions...>,
	tuple<_Variants...>, std::index_sequence<__indices...>>
    {
      using _Next =
	  remove_reference_t<typename _Nth_type<sizeof...(__indices),
			     _Variants...>::type>;
      using _Array_type =
	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
		       __dimensions...>;

      static constexpr _Array_type
      _S_apply()
      {
	_Array_type __vtable{};
	_S_apply_all_alts(
	  __vtable, make_index_sequence<variant_size_v<_Next>>());
	return __vtable;
      }

      template<size_t... __var_indices>
	static constexpr void
	_S_apply_all_alts(_Array_type& __vtable,
			  std::index_sequence<__var_indices...>)
	{
	  if constexpr (_Extra_visit_slot_needed<_Result_type, _Next>::value)
	    (_S_apply_single_alt<true, __var_indices>(
	      __vtable._M_arr[__var_indices + 1],
	      &(__vtable._M_arr[0])), ...);
	  else
	    (_S_apply_single_alt<false, __var_indices>(
	      __vtable._M_arr[__var_indices]), ...);
	}

      template<bool __do_cookie, size_t __index, typename _Tp>
	static constexpr void
	_S_apply_single_alt(_Tp& __element, _Tp* __cookie_element = nullptr)
	{
	  using _Alternative = variant_alternative_t<__index, _Next>;
	  if constexpr (__do_cookie)
	    {
	      __element = __gen_vtable_impl<
		__same_return_types,
		_Tp,
		tuple<_Variants...>,
		std::index_sequence<__indices..., __index>>::_S_apply();
	      *__cookie_element = __gen_vtable_impl<
		__same_return_types,
		_Tp,
		tuple<_Variants...>,
		std::index_sequence<__indices..., variant_npos>>::_S_apply();
	    }
	  else
	    {
	      __element = __gen_vtable_impl<
		__same_return_types,
		remove_reference_t<decltype(__element)>, tuple<_Variants...>,
		std::index_sequence<__indices..., __index>>::_S_apply();
	    }
	}
    };

  // This partial specialization is the base case for the recursion.
  // It populates a _Multi_array element with the address of a function
  // that invokes the visitor with the alternatives specified by __indices.
  template<bool __same_return_types,
	   typename _Result_type, typename _Visitor, typename... _Variants,
	   size_t... __indices>
    struct __gen_vtable_impl<
      __same_return_types,
      _Multi_array<_Result_type (*)(_Visitor, _Variants...)>,
		   tuple<_Variants...>, std::index_sequence<__indices...>>
    {
      using _Array_type =
	  _Multi_array<_Result_type (*)(_Visitor, _Variants...)>;

      template<size_t __index, typename _Variant>
	static constexpr decltype(auto)
	__element_by_index_or_cookie(_Variant&& __var) noexcept
        {
	  if constexpr (__index != variant_npos)
	    return __variant::__get<__index>(std::forward<_Variant>(__var));
	  else
	    return __variant_cookie{};
	}

      static constexpr decltype(auto)
      __visit_invoke_impl(_Visitor&& __visitor, _Variants... __vars)
      {
	// For raw visitation using indices, pass the indices to the visitor:
	if constexpr (is_same_v<_Result_type, __variant_idx_cookie>)
	  return std::__invoke(std::forward<_Visitor>(__visitor),
	      __element_by_index_or_cookie<__indices>(
		std::forward<_Variants>(__vars))...,
	      integral_constant<size_t, __indices>()...);
	// For std::visit<cv void>, cast the result to void:
	else if constexpr (!__same_return_types &&
			   std::is_void_v<_Result_type>)
	  return (void)std::__invoke(std::forward<_Visitor>(__visitor),
	      __element_by_index_or_cookie<__indices>(
		std::forward<_Variants>(__vars))...);
	else
	  return std::__invoke(std::forward<_Visitor>(__visitor),
	      __element_by_index_or_cookie<__indices>(
		std::forward<_Variants>(__vars))...);
      }

      static constexpr decltype(auto)
      __do_visit_invoke(_Visitor&& __visitor, _Variants... __vars)
      {
	return __visit_invoke_impl(std::forward<_Visitor>(__visitor),
				   std::forward<_Variants>(__vars)...);
      }

      // Perform the implicit conversion to _Result_type for std::visit<R>.
      static constexpr _Result_type
      __do_visit_invoke_r(_Visitor&& __visitor, _Variants... __vars)
      {
	return __visit_invoke_impl(std::forward<_Visitor>(__visitor),
				   std::forward<_Variants>(__vars)...);
      }

      static constexpr decltype(auto)
      __visit_invoke(_Visitor&& __visitor, _Variants... __vars)
      {
	if constexpr (__same_return_types)
	  return __do_visit_invoke(std::forward<_Visitor>(__visitor),
				   std::forward<_Variants>(__vars)...);
	else
	  return __do_visit_invoke_r(std::forward<_Visitor>(__visitor),
				     std::forward<_Variants>(__vars)...);
      }

      static constexpr auto
      _S_apply()
      { return _Array_type{&__visit_invoke}; }
    };

  template<bool __same_return_types,
	   typename _Result_type, typename _Visitor, typename... _Variants>
    struct __gen_vtable
    {
      using _Array_type =
	  _Multi_array<_Result_type (*)(_Visitor, _Variants...),
		       variant_size_v<remove_reference_t<_Variants>>...>;

      static constexpr _Array_type _S_vtable
	= __gen_vtable_impl<__same_return_types,
			    _Array_type, tuple<_Variants...>,
			    std::index_sequence<>>::_S_apply();
    };

  template<size_t _Np, typename _Tp>
    struct _Base_dedup : public _Tp { };

  template<typename _Variant, typename __indices>
    struct _Variant_hash_base;

  template<typename... _Types, size_t... __indices>
    struct _Variant_hash_base<variant<_Types...>,
			      std::index_sequence<__indices...>>
    : _Base_dedup<__indices, __poison_hash<remove_const_t<_Types>>>... { };

  template<size_t _Np, typename _Variant>
    using __get_t = decltype(std::get<_Np>(std::declval<_Variant>()));

  // Return type of std::visit.
  template<typename _Visitor, typename... _Variants>
    using __visit_result_t
      = invoke_result_t<_Visitor, __get_t<0, _Variants>...>;

} // namespace __variant
} // namespace __detail

  template<size_t _Np, typename _Variant, typename... _Args>
    void __variant_construct_by_index(_Variant& __v, _Args&&... __args)
    {
      __v._M_index = _Np;
      auto&& __storage = __detail::__variant::__get<_Np>(__v);
      ::new ((void*)std::addressof(__storage))
        remove_reference_t<decltype(__storage)>
	  (std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename... _Types>
    constexpr bool
    holds_alternative(const variant<_Types...>& __v) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      return __v.index() == __detail::__variant::__index_of_v<_Tp, _Types...>;
    }

  template<typename _Tp, typename... _Types>
    constexpr _Tp& get(variant<_Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
    }

  template<typename _Tp, typename... _Types>
    constexpr _Tp&& get(variant<_Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
	std::move(__v));
    }

  template<typename _Tp, typename... _Types>
    constexpr const _Tp& get(const variant<_Types...>& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
    }

  template<typename _Tp, typename... _Types>
    constexpr const _Tp&& get(const variant<_Types...>&& __v)
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
	std::move(__v));
    }

  template<size_t _Np, typename... _Types>
    constexpr add_pointer_t<variant_alternative_t<_Np, variant<_Types...>>>
    get_if(variant<_Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp should not be void");
      if (__ptr && __ptr->index() == _Np)
	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
      return nullptr;
    }

  template<size_t _Np, typename... _Types>
    constexpr
    add_pointer_t<const variant_alternative_t<_Np, variant<_Types...>>>
    get_if(const variant<_Types...>* __ptr) noexcept
    {
      using _Alternative_type = variant_alternative_t<_Np, variant<_Types...>>;
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      static_assert(!is_void_v<_Alternative_type>, "_Tp should not be void");
      if (__ptr && __ptr->index() == _Np)
	return std::addressof(__detail::__variant::__get<_Np>(*__ptr));
      return nullptr;
    }

  template<typename _Tp, typename... _Types>
    constexpr add_pointer_t<_Tp>
    get_if(variant<_Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
	  __ptr);
    }

  template<typename _Tp, typename... _Types>
    constexpr add_pointer_t<const _Tp>
    get_if(const variant<_Types...>* __ptr) noexcept
    {
      static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
		    "T should occur for exactly once in alternatives");
      static_assert(!is_void_v<_Tp>, "_Tp should not be void");
      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
	  __ptr);
    }

  struct monostate { };

#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP, __NAME) \
  template<typename... _Types> \
    constexpr bool operator __OP(const variant<_Types...>& __lhs, \
				 const variant<_Types...>& __rhs) \
    { \
      bool __ret = true; \
      __do_visit<__detail::__variant::__visit_with_index>( \
        [&__ret, &__lhs] \
		 (auto&& __rhs_mem, auto __rhs_index) mutable \
		   -> __detail::__variant::__variant_idx_cookie \
        { \
	  if constexpr (__rhs_index != variant_npos) \
	    { \
	      if (__lhs.index() == __rhs_index) \
	        { \
		  auto& __this_mem = std::get<__rhs_index>(__lhs);	\
                  __ret = __this_mem __OP __rhs_mem; \
                } \
	      else \
		__ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
            } \
          else \
            __ret = (__lhs.index() + 1) __OP (__rhs_index + 1); \
	  return {}; \
	}, __rhs); \
      return __ret; \
    } \
\
  constexpr bool operator __OP(monostate, monostate) noexcept \
  { return 0 __OP 0; }

  _VARIANT_RELATION_FUNCTION_TEMPLATE(<, less)
  _VARIANT_RELATION_FUNCTION_TEMPLATE(<=, less_equal)
  _VARIANT_RELATION_FUNCTION_TEMPLATE(==, equal)
  _VARIANT_RELATION_FUNCTION_TEMPLATE(!=, not_equal)
  _VARIANT_RELATION_FUNCTION_TEMPLATE(>=, greater_equal)
  _VARIANT_RELATION_FUNCTION_TEMPLATE(>, greater)

#undef _VARIANT_RELATION_FUNCTION_TEMPLATE

  template<typename _Visitor, typename... _Variants>
    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
    visit(_Visitor&&, _Variants&&...);

  template<typename... _Types>
    inline enable_if_t<(is_move_constructible_v<_Types> && ...)
			&& (is_swappable_v<_Types> && ...)>
    swap(variant<_Types...>& __lhs, variant<_Types...>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }

  template<typename... _Types>
    enable_if_t<!((is_move_constructible_v<_Types> && ...)
		   && (is_swappable_v<_Types> && ...))>
    swap(variant<_Types...>&, variant<_Types...>&) = delete;

  class bad_variant_access : public exception
  {
  public:
    bad_variant_access() noexcept : _M_reason("Unknown reason") { }
    const char* what() const noexcept override
    { return _M_reason; }

  private:
    bad_variant_access(const char* __reason) : _M_reason(__reason) { }

    const char* _M_reason;

    friend void __throw_bad_variant_access(const char* __what);
  };

  inline void
  __throw_bad_variant_access(const char* __what)
  { _GLIBCXX_THROW_OR_ABORT(bad_variant_access(__what)); }

  template<typename... _Types>
    class variant
    : private __detail::__variant::_Variant_base<_Types...>,
      private _Enable_default_constructor<
	__detail::__variant::_Traits<_Types...>::_S_default_ctor,
	  variant<_Types...>>,
      private _Enable_copy_move<
	__detail::__variant::_Traits<_Types...>::_S_copy_ctor,
	__detail::__variant::_Traits<_Types...>::_S_copy_assign,
	__detail::__variant::_Traits<_Types...>::_S_move_ctor,
	__detail::__variant::_Traits<_Types...>::_S_move_assign,
	variant<_Types...>>
    {
    private:
      template <typename... _UTypes, typename _Tp>
	friend decltype(auto) __variant_cast(_Tp&&);
      template<size_t _Np, typename _Variant, typename... _Args>
	friend void __variant_construct_by_index(_Variant& __v,
						 _Args&&... __args);

      static_assert(sizeof...(_Types) > 0,
		    "variant must have at least one alternative");
      static_assert(!(std::is_reference_v<_Types> || ...),
		    "variant must have no reference alternative");
      static_assert(!(std::is_void_v<_Types> || ...),
		    "variant must have no void alternative");

      using _Base = __detail::__variant::_Variant_base<_Types...>;
      using _Default_ctor_enabler =
	_Enable_default_constructor<
	  __detail::__variant::_Traits<_Types...>::_S_default_ctor,
	    variant<_Types...>>;

      template<typename _Tp>
	static constexpr bool __not_self
	  = !is_same_v<__remove_cvref_t<_Tp>, variant>;

      template<typename _Tp>
	static constexpr bool
	__exactly_once = __detail::__variant::__exactly_once<_Tp, _Types...>;

      template<typename _Tp>
	static constexpr size_t __accepted_index =
	  __detail::__variant::__accepted_index<_Tp&&, variant>::value;

      template<size_t _Np, typename = enable_if_t<(_Np < sizeof...(_Types))>>
	using __to_type = variant_alternative_t<_Np, variant>;

      template<typename _Tp, typename = enable_if_t<__not_self<_Tp>>>
	using __accepted_type = __to_type<__accepted_index<_Tp>>;

      template<typename _Tp>
	static constexpr size_t __index_of =
	  __detail::__variant::__index_of_v<_Tp, _Types...>;

      using _Traits = __detail::__variant::_Traits<_Types...>;

      template<typename _Tp>
	struct __is_in_place_tag : false_type { };
      template<typename _Tp>
	struct __is_in_place_tag<in_place_type_t<_Tp>> : true_type { };
      template<size_t _Np>
	struct __is_in_place_tag<in_place_index_t<_Np>> : true_type { };

      template<typename _Tp>
	static constexpr bool __not_in_place_tag
	  = !__is_in_place_tag<__remove_cvref_t<_Tp>>::value;

    public:
      variant() = default;
      variant(const variant& __rhs) = default;
      variant(variant&&) = default;
      variant& operator=(const variant&) = default;
      variant& operator=(variant&&) = default;
      ~variant() = default;

      template<typename _Tp,
	       typename = enable_if_t<sizeof...(_Types) != 0>,
	       typename = enable_if_t<__not_in_place_tag<_Tp>>,
	       typename _Tj = __accepted_type<_Tp&&>,
	       typename = enable_if_t<__exactly_once<_Tj>
				      && is_constructible_v<_Tj, _Tp>>>
	constexpr
	variant(_Tp&& __t)
	noexcept(is_nothrow_constructible_v<_Tj, _Tp>)
	: variant(in_place_index<__accepted_index<_Tp&&>>,
		  std::forward<_Tp>(__t))
	{ }

      template<typename _Tp, typename... _Args,
	       typename = enable_if_t<__exactly_once<_Tp>
				      && is_constructible_v<_Tp, _Args...>>>
	constexpr explicit
	variant(in_place_type_t<_Tp>, _Args&&... __args)
	: variant(in_place_index<__index_of<_Tp>>,
		  std::forward<_Args>(__args)...)
	{ }

      template<typename _Tp, typename _Up, typename... _Args,
	       typename = enable_if_t<__exactly_once<_Tp>
				      && is_constructible_v<_Tp,
					   initializer_list<_Up>&, _Args...>>>
	constexpr explicit
	variant(in_place_type_t<_Tp>, initializer_list<_Up> __il,
		_Args&&... __args)
	: variant(in_place_index<__index_of<_Tp>>, __il,
		  std::forward<_Args>(__args)...)
	{ }

      template<size_t _Np, typename... _Args,
	       typename _Tp = __to_type<_Np>,
	       typename = enable_if_t<is_constructible_v<_Tp, _Args...>>>
	constexpr explicit
	variant(in_place_index_t<_Np>, _Args&&... __args)
	: _Base(in_place_index<_Np>, std::forward<_Args>(__args)...),
	_Default_ctor_enabler(_Enable_default_constructor_tag{})
	{ }

      template<size_t _Np, typename _Up, typename... _Args,
	       typename _Tp = __to_type<_Np>,
	       typename = enable_if_t<is_constructible_v<_Tp,
							 initializer_list<_Up>&,
							 _Args...>>>
	constexpr explicit
	variant(in_place_index_t<_Np>, initializer_list<_Up> __il,
		_Args&&... __args)
	: _Base(in_place_index<_Np>, __il, std::forward<_Args>(__args)...),
	_Default_ctor_enabler(_Enable_default_constructor_tag{})
	{ }

      template<typename _Tp>
	enable_if_t<__exactly_once<__accepted_type<_Tp&&>>
		    && is_constructible_v<__accepted_type<_Tp&&>, _Tp>
		    && is_assignable_v<__accepted_type<_Tp&&>&, _Tp>,
		    variant&>
	operator=(_Tp&& __rhs)
	noexcept(is_nothrow_assignable_v<__accepted_type<_Tp&&>&, _Tp>
		 && is_nothrow_constructible_v<__accepted_type<_Tp&&>, _Tp>)
	{
	  constexpr auto __index = __accepted_index<_Tp&&>;
	  if (index() == __index)
	    std::get<__index>(*this) = std::forward<_Tp>(__rhs);
	  else
	    {
	      using _Tj = __accepted_type<_Tp&&>;
	      if constexpr (is_nothrow_constructible_v<_Tj, _Tp>
			    || !is_nothrow_move_constructible_v<_Tj>)
		this->emplace<__index>(std::forward<_Tp>(__rhs));
	      else
		operator=(variant(std::forward<_Tp>(__rhs)));
	    }
	  return *this;
	}

      template<typename _Tp, typename... _Args>
	enable_if_t<is_constructible_v<_Tp, _Args...> && __exactly_once<_Tp>,
		    _Tp&>
	emplace(_Args&&... __args)
	{
	  constexpr size_t __index = __index_of<_Tp>;
	  return this->emplace<__index>(std::forward<_Args>(__args)...);
	}

      template<typename _Tp, typename _Up, typename... _Args>
	enable_if_t<is_constructible_v<_Tp, initializer_list<_Up>&, _Args...>
		    && __exactly_once<_Tp>,
		    _Tp&>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{
	  constexpr size_t __index = __index_of<_Tp>;
	  return this->emplace<__index>(__il, std::forward<_Args>(__args)...);
	}

      template<size_t _Np, typename... _Args>
	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
				       _Args...>,
		    variant_alternative_t<_Np, variant>&>
	emplace(_Args&&... __args)
	{
	  static_assert(_Np < sizeof...(_Types),
			"The index should be in [0, number of alternatives)");
	  using type = variant_alternative_t<_Np, variant>;
	  // Provide the strong exception-safety guarantee when possible,
	  // to avoid becoming valueless.
	  if constexpr (is_nothrow_constructible_v<type, _Args...>)
	    {
	      this->_M_reset();
	      __variant_construct_by_index<_Np>(*this,
		  std::forward<_Args>(__args)...);
	    }
	  else if constexpr (is_scalar_v<type>)
	    {
	      // This might invoke a potentially-throwing conversion operator:
	      const type __tmp(std::forward<_Args>(__args)...);
	      // But these steps won't throw:
	      this->_M_reset();
	      __variant_construct_by_index<_Np>(*this, __ŠÊ  ‹Ê  ŒÊ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      tmp);
	    }
	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
	      && _Traits::_S_move_assign)
	    {
	      // This construction might throw:
	      variant __tmp(in_place_index<_Np>,
			    std::forward<_Args>(__args)...);
	      // But _Never_valueless_alt<type> means this won't:
	      *this = std::move(__tmp);
	    }
	  else
	    {
	      // This case only provides the basic exception-safety guarantee,
	      // i.e. the variant can become valueless.
	      this->_M_reset();
	      __try
		{
		  __variant_construct_by_index<_Np>(*this,
		    std::forward<_Args>(__args)...);
		}
	      __catch (...)
		{
		  this->_M_index = variant_npos;
		  __throw_exception_again;
		}
	    }
	  return std::get<_Np>(*this);
	}

      template<size_t _Np, typename _Up, typename... _Args>
	enable_if_t<is_constructible_v<variant_alternative_t<_Np, variant>,
				       initializer_list<_Up>&, _Args...>,
		    variant_alternative_t<_Np, variant>&>
	emplace(initializer_list<_Up> __il, _Args&&... __args)
	{
	  static_assert(_Np < sizeof...(_Types),
			"The index should be in [0, number of alternatives)");
	  using type = variant_alternative_t<_Np, variant>;
	  // Provide the strong exception-safety guarantee when possible,
	  // to avoid becoming valueless.
	  if constexpr (is_nothrow_constructible_v<type,
						   initializer_list<_Up>&,
						   _Args...>)
	    {
	      this->_M_reset();
	      __variant_construct_by_index<_Np>(*this, __il,
		  std::forward<_Args>(__args)...);
	    }
	  else if constexpr (__detail::__variant::_Never_valueless_alt<type>()
	      && _Traits::_S_move_assign)
	    {
	      // This construction might throw:
	      variant __tmp(in_place_index<_Np>, __il,
			    std::forward<_Args>(__args)...);
	      // But _Never_valueless_alt<type> means this won't:
	      *this = std::move(__tmp);
	    }
	  else
	    {
	      // This case only provides the basic exception-safety guarantee,
	      // i.e. the variant can become valueless.
	      this->_M_reset();
	      __try
		{
		  __variant_construct_by_index<_Np>(*this, __il,
		    std::forward<_Args>(__args)...);
		}
	      __catch (...)
		{
		  this->_M_index = variant_npos;
		  __throw_exception_again;
		}
	    }
	  return std::get<_Np>(*this);
	}

      constexpr bool valueless_by_exception() const noexcept
      { return !this->_M_valid(); }

      constexpr size_t index() const noexcept
      {
	if (this->_M_index ==
	    typename _Base::__index_type(variant_npos))
	  return variant_npos;
	return this->_M_index;
      }

      void
      swap(variant& __rhs)
      noexcept((__is_nothrow_swappable<_Types>::value && ...)
	       && is_nothrow_move_constructible_v<variant>)
      {
	__do_visit<__detail::__variant::__visit_with_index>(
	  [this, &__rhs](auto&& __rhs_mem,
			 auto __rhs_index) mutable
	    -> __detail::__variant::__variant_idx_cookie
	  {
	    if constexpr (__rhs_index != variant_npos)
	      {
		if (this->index() == __rhs_index)
		  {
		    auto& __this_mem =
		      std::get<__rhs_index>(*this);
		    using std::swap;
		    swap(__this_mem, __rhs_mem);
		  }
		else
		  {
		    if (this->index() != variant_npos)
		      {
			auto __tmp(std::move(__rhs_mem));
			__rhs = std::move(*this);
			this->_M_destructive_move(__rhs_index,
						  std::move(__tmp));
		      }
		    else
		      {
			this->_M_destructive_move(__rhs_index,
						  std::move(__rhs_mem));
			__rhs._M_reset();
		      }
		  }
	      }
	    else
	      {
		if (this->index() != variant_npos)
		  {
		    __rhs = std::move(*this);
		    this->_M_reset();
		  }
	      }
	    return {};
	  }, __rhs);
      }

    private:

#if defined(__clang__) && __clang_major__ <= 7
    public:
      using _Base::_M_u; // See https://bugs.llvm.org/show_bug.cgi?id=31852
    private:
#endif

      template<size_t _Np, typename _Vp>
	friend constexpr decltype(auto)
	__detail::__variant::__get(_Vp&& __v) noexcept;

      template<typename _Vp>
	friend void* __detail::__variant::__get_storage(_Vp&& __v);

#define _VARIANT_RELATION_FUNCTION_TEMPLATE(__OP) \
      template<typename... _Tp> \
	friend constexpr bool \
	operator __OP(const variant<_Tp...>& __lhs, \
		      const variant<_Tp...>& __rhs);

      _VARIANT_RELATION_FUNCTION_TEMPLATE(<)
      _VARIANT_RELATION_FUNCTION_TEMPLATE(<=)
      _VARIANT_RELATION_FUNCTION_TEMPLATE(==)
      _VARIANT_RELATION_FUNCTION_TEMPLATE(!=)
      _VARIANT_RELATION_FUNCTION_TEMPLATE(>=)
      _VARIANT_RELATION_FUNCTION_TEMPLATE(>)

#undef _VARIANT_RELATION_FUNCTION_TEMPLATE
    };

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&
    get(variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      if (__v.index() != _Np)
	__throw_bad_variant_access("Unexpected index");
      return __detail::__variant::__get<_Np>(__v);
    }

  template<size_t _Np, typename... _Types>
    constexpr variant_alternative_t<_Np, variant<_Types...>>&&
    get(variant<_Types...>&& __v)
    {
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      if (__v.index() != _Np)
	__throw_bad_variant_access("Unexpected index");
      return __detail::__variant::__get<_Np>(std::move(__v));
    }

  template<size_t _Np, typename... _Types>
    constexpr const variant_alternative_t<_Np, variant<_Types...>>&
    get(const variant<_Types...>& __v)
    {
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      if (__v.index() != _Np)
	__throw_bad_variant_access("Unexpected index");
      return __detail::__variant::__get<_Np>(__v);
    }

  template<size_t _Np, typename... _Types>
    constexpr const variant_alternative_t<_Np, variant<_Types...>>&&
    get(const variant<_Types...>&& __v)
    {
      static_assert(_Np < sizeof...(_Types),
		    "The index should be in [0, number of alternatives)");
      if (__v.index() != _Np)
	__throw_bad_variant_access("Unexpected index");
      return __detail::__variant::__get<_Np>(std::move(__v));
    }

  template<bool __use_index,
	   bool __same_return_types,
	   typename _Visitor, typename... _Variants>
    constexpr decltype(auto)
    __do_visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      using _Deduced_type = std::invoke_result<_Visitor,
	__detail::__variant::__get_t<0, _Variants>...>;

      using _Result_type = typename std::conditional_t<__use_index,
	__detail::__variant::__variant_idx_cookie,
	_Deduced_type>::type;

      constexpr auto& __vtable = __detail::__variant::__gen_vtable<
	__same_return_types,
	_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;

      auto __func_ptr = __vtable._M_access(__variants.index()...);
      return (*__func_ptr)(std::forward<_Visitor>(__visitor),
			   std::forward<_Variants>(__variants)...);
    }

  template<typename _Visitor, typename... _Variants>
    constexpr __detail::__variant::__visit_result_t<_Visitor, _Variants...>
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      if ((__variants.valueless_by_exception() || ...))
	__throw_bad_variant_access("Unexpected index");

      return std::__do_visit(std::forward<_Visitor>(__visitor),
			     std::forward<_Variants>(__variants)...);
    }

#if __cplusplus > 201703L
  template<typename _Res, typename _Visitor, typename... _Variants>
    constexpr _Res
    visit(_Visitor&& __visitor, _Variants&&... __variants)
    {
      if ((__variants.valueless_by_exception() || ...))
	__throw_bad_variant_access("Unexpected index");

      if constexpr (std::is_void_v<_Res>)
        (void) __do_visit<false, false>(std::forward<_Visitor>(__visitor),
					std::forward<_Variants>(__variants)...);
      else
	return __do_visit<false, false>(std::forward<_Visitor>(__visitor),
					std::forward<_Variants>(__variants)...);
    }
#endif

  template<bool, typename... _Types>
    struct __variant_hash_call_base_impl
    {
      size_t
      operator()(const variant<_Types...>& __t) const
      noexcept((is_nothrow_invocable_v<hash<decay_t<_Types>>, _Types> && ...))
      {
	size_t __ret;
	__do_visit([&__t, &__ret](auto&& __t_mem) mutable
		   -> __detail::__variant::__variant_cookie
	  {
	    using _Type = __remove_cvref_t<decltype(__t_mem)>;
	    if constexpr (!is_same_v<_Type,
			             __detail::__variant::__variant_cookie>)
	      __ret = std::hash<size_t>{}(__t.index())
		      + std::hash<_Type>{}(__t_mem);
	    else
	      __ret = std::hash<size_t>{}(__t.index());
	    return {};
	  }, __t);
	return __ret;
      }
    };

  template<typename... _Types>
    struct __variant_hash_call_base_impl<false, _Types...> {};

  template<typename... _Types>
    using __variant_hash_call_base =
    __variant_hash_call_base_impl<(__poison_hash<remove_const_t<_Types>>::
				   __enable_hash_call &&...), _Types...>;

  template<typename... _Types>
    struct hash<variant<_Types...>>
    : private __detail::__variant::_Variant_hash_base<
	variant<_Types...>, std::index_sequence_for<_Types...>>,
      public __variant_hash_call_base<_Types...>
    {
      using result_type [[__deprecated__]] = size_t;
      using argument_type [[__deprecated__]] = variant<_Types...>;
    };

  template<>
    struct hash<monostate>
    {
      using result_type [[__deprecated__]] = size_t;
      using argument_type [[__deprecated__]] = monostate;

      size_t
      operator()(const monostate& __t) const noexcept
      {
	constexpr size_t __magic_monostate_hash = -7777;
	return __magic_monostate_hash;
      }
    };

  template<typename... _Types>
    struct __is_fast_hash<hash<variant<_Types...>>>
    : bool_constant<(__is_fast_hash<_Types>::value && ...)>
    { };

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std

#endif // C++17

#endif // _GLIBCXX_VARIANT
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // <vector> -*- C++ -*-

// Copyright (C) 2001-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/*
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Hewlett-Packard Company makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 *
 * Copyright (c) 1996
 * Silicon Graphics Computer Systems, Inc.
 *
 * Permission to use, copy, modify, distribute and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appear in all copies and
 * that both that copyright notice and this permission notice appear
 * in supporting documentation.  Silicon Graphics makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 */

/** @file include/vector
 *  This is a Standard C++ Library header.
 */

#ifndef _GLIBCXX_VECTOR
#define _GLIBCXX_VECTOR 1

#pragma GCC system_header

#include <bits/stl_algobase.h>
#if __cplusplus > 201703L
#  include <bits/stl_algo.h> // For remove and remove_if
#endif // C++20
#include <bits/allocator.h>
#include <bits/stl_construct.h>
#include <bits/stl_uninitialized.h>
#include <bits/stl_vector.h>
#include <bits/stl_bvector.h>
#include <bits/range_access.h>

#ifndef _GLIBCXX_EXPORT_TEMPLATE
# include <bits/vector.tcc>
#endif

#ifdef _GLIBCXX_DEBUG
# include <debug/vector>
#endif

#ifdef _GLIBCXX_PROFILE
# include <profile/vector>
#endif

#if __cplusplus >= 201703L
namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION
  namespace pmr {
    template<typename _Tp> class polymorphic_allocator;
    template<typename _Tp>
      using vector = std::vector<_Tp, polymorphic_allocator<_Tp>>;
  } // namespace pmr
# ifdef _GLIBCXX_DEBUG
  namespace _GLIBCXX_STD_C::pmr {
    template<typename _Tp>
      using vector
	= _GLIBCXX_STD_C::vector<_Tp, std::pmr::polymorphic_allocator<_Tp>>;
  } // namespace _GLIBCXX_STD_C::pmr
# endif
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std
#endif // C++17

#if __cplusplus > 201703L
namespace std _GLIBCXX_VISIBILITY(default)
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

#define __cpp_lib_erase_if 202002L

  template<typename _Tp, typename _Alloc, typename _Predicate>
    inline typename vector<_Tp, _Alloc>::size_type
    erase_if(vector<_Tp, _Alloc>& __cont, _Predicate __pred)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove_if(__cont.begin(), __cont.end(), __pred),
		   __cont.end());
      return __osz - __cont.size();
    }

  template<typename _Tp, typename _Alloc, typename _Up>
    inline typename vector<_Tp, _Alloc>::size_type
    erase(vector<_Tp, _Alloc>& __cont, const _Up& __value)
    {
      const auto __osz = __cont.size();
      __cont.erase(std::remove(__cont.begin(), __cont.end(), __value),
		   __cont.end());
      return __osz - __cont.size();
    }
_GLIBCXX_END_NAMESPACE_VERSION
} // namespace std
#endif // C++20

#endif /* _GLIBCXX_VECTOR */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  // -*- C++ -*- Libstdc++ version details header.

// Copyright (C) 2018-2019 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file version
 *  This is a Standard C++ Library file.  You should @c \#include this file
 *  in your programs, rather than any of the @a *.h implementation files.
 */

#ifndef _GLIBCXX_VERSION_INCLUDED
#define _GLIBCXX_VERSION_INCLUDED

#pragma GCC system_header

#include <bits/c++config.h>

// c++03
#if _GLIBCXX_HOSTED
# define __cpp_lib_incomplete_container_elements 201505
#endif

#if !defined(__STRICT_ANSI__)
// gnu++03
# define __cpp_lib_uncaught_exceptions 201411L
#endif

#if __cplusplus >= 201103L
// c++11
#define __cpp_lib_is_null_pointer 201309
#define __cpp_lib_result_of_sfinae 201210

#if _GLIBCXX_HOSTED
# define __cpp_lib_allocator_is_always_equal 201411
# define __cpp_lib_allocator_traits_is_always_equal 201411
# define __cpp_lib_shared_ptr_arrays 201611L
#endif

#if !defined(__STRICT_ANSI__)
// gnu++11
# define __cpp_lib_is_swappable 201603
# define __cpp_lib_void_t 201411
# if _GLIBCXX_HOSTED
#  define __cpp_lib_enable_shared_from_this 201603
# endif
#endif

// For C++11 and later we support ISO/IEC 29124 Mathematical Special Functions
#define __STDCPP_MATH_SPEC_FUNCS__ 201003L

#if __cplusplus >= 201402L
// c++14
#define __cpp_lib_integral_constant_callable 201304
#define __cpp_lib_is_final 201402L
#define __cpp_lib_transformation_trait_aliases 201304

#if _GLIBCXX_HOSTED
# define __cpp_lib_chrono_udls 201304
# define __cpp_lib_complex_udls 201309
# define __cpp_lib_exchange_function 201304
# define __cpp_lib_generic_associative_lookup 201304
# define __cpp_lib_integer_sequence 201304
# define __cpp_lib_make_reverse_iterator 201402
# define __cpp_lib_make_unique 201304
# ifndef _GLIBCXX_DEBUG // PR libstdc++/70303
#  define __cpp_lib_null_iterators 201304L
# endif
# define __cpp_lib_quoted_string_io 201304
# define __cpp_lib_robust_nonmodifying_seq_ops 201304
# ifdef _GLIBCXX_HAS_GTHREADS
#  define __cpp_lib_shared_timed_mutex 201402
# endif
# define __cpp_lib_string_udls 201304
# define __cpp_lib_transparent_operators 201510
# define __cpp_lib_tuple_element_t 201402L
# define __cpp_lib_tuples_by_type 201304
#endif

#if __cplusplus >= 201703L
// c++17
#define __cpp_lib_addressof_constexpr 201603
#define __cpp_lib_atomic_is_always_lock_free 201603
#define __cpp_lib_bool_constant 201505
#define __cpp_lib_byte 201603
#ifdef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
# define __cpp_lib_has_unique_object_representations 201606
#endif
#ifdef _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE
# define __cpp_lib_is_aggregate 201703
#endif
#define __cpp_lib_is_invocable 201703
#define __cpp_lib_is_swappable 201603
#ifdef _GLIBCXX_HAVE_BUILTIN_LAUNDER
# define __cpp_lib_launder 201606
#endif
#define __cpp_lib_logical_traits 201510
#define __cpp_lib_type_trait_variable_templates 201510L
#define __cpp_lib_uncaught_exceptions 201411L
#define __cpp_lib_void_t 201411

#if _GLIBCXX_HOSTED
#define __cpp_lib_any 201606L
#define __cpp_lib_apply 201603
#define __cpp_lib_array_constexpr 201803L
#define __cpp_lib_as_const 201510
#define __cpp_lib_boyer_moore_searcher 201603
#define __cpp_lib_chrono 201611
#define __cpp_lib_clamp 201603
#define __cpp_lib_constexpr_char_traits 201611
#define __cpp_lib_constexpr_string 201611L
#define __cpp_lib_enable_shared_from_this 201603
#define __cpp_lib_execution 201902L // FIXME: should be 201603L
#define __cpp_lib_filesystem 201703
#define __cpp_lib_gcd 201606
#define __cpp_lib_gcd_lcm 201606
#define __cpp_lib_hypot 201603
#define __cpp_lib_invoke 201411
#define __cpp_lib_lcm 201606
#define __cpp_lib_make_from_tuple 201606
#define __cpp_lib_map_insertion 201411  // non-standard macro
#define __cpp_lib_map_try_emplace 201411
#define __cpp_lib_math_special_functions 201603L
#ifdef _GLIBCXX_HAS_GTHREADS
# define __cpp_lib_memory_resource 201603
#else
# define __cpp_lib_memory_resource 1
#endif
#define __cpp_lib_node_extract 201606
#define __cpp_lib_nonmember_container_access 201411
#define __cpp_lib_not_fn 201603
#define __cpp_lib_optional 201606L
#define __cpp_lib_raw_memory_algorithms 201606L
#define __cpp_lib_sample 201603
#ifdef _GLIBCXX_HAS_GTHREADS
# define __cpp_lib_scoped_lock 201703
# define __cpp_lib_shared_mutex 201505
#endif
#define __cpp_lib_shared_ptr_weak_type 201606
#define __cpp_lib_string_view 201803
// #define __cpp_lib_to_chars 201611L
#define __cpp_lib_unordered_map_insertion 201411  // non-standard macro
#define __cpp_lib_unordered_map_try_emplace 201411
#define __cpp_lib_variant 201606L
#define __cpp_lib_parallel_algorithm 201603L
#endif

#if __cplusplus > 201703L
// c++2a
#define __cpp_lib_bitops 201907L
#define __cpp_lib_bounded_array_traits 201902L
// __cpp_lib_char8_t is defined in <bits/c++config.h>
#if __cpp_impl_destroying_delete
# define __cpp_lib_destroying_delete 201806L
#endif
#define __cpp_lib_endian 201907L
#define __cpp_lib_int_pow2 201806L
#ifdef _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED
# define __cpp_lib_is_constant_evaluated 201811L
#endif
#define __cpp_lib_is_nothrow_convertible 201806L
#define __cpp_lib_remove_cvref 201711L
#define __cpp_lib_type_identity 201806L
#define __cpp_lib_unwrap_ref 201811L

#if _GLIBCXX_HOSTED
#define __cpp_lib_assume_aligned 201811L
#define __cpp_lib_bind_front 201907L
// FIXME: #define __cpp_lib_execution 201902L
#define __cpp_lib_constexpr_complex 201711L
#define __cpp_lib_constexpr_memory 201811L
#define __cpp_lib_erase_if 202002L
#define __cpp_lib_interpolate 201902L
#define __cpp_lib_list_remove_return_type 201806L
#define __cpp_lib_polymorphic_allocator 201902L
#define __cpp_lib_starts_ends_with 201711L
#define __cpp_lib_to_address 201711L
#endif
#endif // C++2a
#endif // C++17
#endif // C++14
#endif // C++11

#endif // _GLIBCXX_VERSION_INCLUDED
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   ¾   .   r   ..  ¿   go  n   	ldscripts   ‰   libatomic.a Š   libatomic.so‹   libatomic.so.1  Œ   libatomic.so.1.2.0     libgcc_s.so Ž   libgcc_s.so.1      libgdruntime.a     libgdruntime.so ‘   libgdruntime.so.76  ’    libgdruntime.so.76.0.3  “   libgfortran.a   ”   libgfortran.so  •   libgfortran.so.5–   libgfortran.so.5.0.0—   libgfortran.spec˜   libgo.a ™   libgo.soš   libgo.so.14 ›   libgo.so.14.0.0 œ   libgobegin.a   libgolibbegin.a ž   libgphobos.aŸ   libgphobos.so       libgphobos.so.76¡   libgphobos.so.76.0.3¢   libgphobos.spec £   	libobjc.a   ¤   
libobjc.la  ¥   
libobjc.so  ¦   libobjc.so.4§   libobjc.so.4.0.0¨   libstdc++.a ©   libstdc++.soª   libstdc++.so.6  «   libstdc++.so.6.0.28 ¬  $ libstdc++.so.6.0.28-gdb.py  ­   libstdc++fs.a   ®  hlibsupc++.a                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     ¿   .   ¾   ..  À  è9.5.0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           À   .   ¿   ..  Á  èriscv64-c07-linux-gnu                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Á   .   À   ..  Â   archive Å   	bufio.gox   Æ   	bytes.gox   Ç   compressÍ   	container   Ñ   context.gox Ò   crypto  æ   
crypto.gox  ç   databaseë   debug   ò   encodingþ   encoding.goxÿ   
errors.gox      
expvar.gox     flag.gox   fmt.gox    go     hash   hash.gox   html   html.gox   image       	image.gox   !   index   #   io  %   io.gox  &   log (   log.gox )   math.   math.gox/   mime2   mime.gox3   net D   net.gox E   os  I   os.gox  J   pathL   path.goxM   reflect.gox N   regexp  P   
regexp.gox  Q   runtime U   runtime.gox V   sort.goxW   strconv.gox X   strings.gox Y   sync[   sync.gox\   syscall.gox ]   testing b   testing.gox c   texti   time.goxj   unicode m  xunicode.gox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     Â   .   Á   ..  Ã   tar.gox Ä  Øzip.gox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         ELF          ó                    È>         @     @   v3;
package tar
pkgpath archive/tar
import bytes bytes "bytes"
import errors errors "errors"
import fmt fmt "fmt"
import io io "io"
import ioutil io/ioutil "io/ioutil"
import math math "math"
import os os "os"
import user os/user "os/user"
import path path "path"
import reflect reflect "reflect"
import runtime runtime "runtime"
import sort sort "sort"
import strconv strconv "strconv"
import strings strings "strings"
import sync sync "sync"
import syscall syscall "syscall"
import time time "time"
init tar archive..z2ftar..import bytes bytes..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import ioutil io..z2fioutil..import os os..import user os..z2fuser..import path path..import filepath path..z2ffilepath..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 1 3 1 6 1 13 1 14 1 16 1 19 2 3 2 4 2 5 2 6 2 8 2 12 2 13 2 14 2 15 2 16 2 17 2 18 2 19 4 3 4 6 4 13 4 14 4 16 4 17 4 18 6 3 6 13 6 14 6 16 7 1 7 3 7 4 7 5 7 6 7 8 7 11 7 12 7 13 7 14 7 15 7 16 7 17 7 18 7 19 8 3 8 4 8 5 8 6 8 13 8 14 8 16 8 17 8 18 9 2 9 3 9 4 9 5 9 6 9 8 9 12 9 13 9 14 9 15 9 16 9 17 9 18 9 19 10 3 10 6 10 13 10 14 10 16 10 19 11 3 11 4 11 5 11 6 11 8 11 12 11 13 11 14 11 15 11 16 11 17 11 18 11 19 12 3 12 13 12 14 12 15 12 16 12 19 13 3 13 14 15 3 15 13 15 14 16 3 16 13 16 14 17 3 17 13 17 14 17 16 18 3 18 13 18 14 18 16 18 17
types 65 5 869 181 888 1065 30 139 3246 344 21 18 19 525 165 21 31 91 21 36 112 19 73 75 83 195 22 18 18 335 36 30 72 18 30 73 18 159 44 99 43 85 521 19 19 485 26 19 610 215 143 19 609 19 451 45 21 101 55 186 44 100 49 35 49 34
type 1 "Format" <type -11>
 func (f <type 1>) .archive/tar.has (f2 <type 1>) <type -15>
 func (f <esc:0x1> <type 27>) .archive/tar.mayBe (f2 <type 1>) <inl:171>
  // /home/arreguin/utils/00-ccLab2-fedora35/opt/.build/HOST-riscv64-c06-linux-gnu/riscv64-c07-linux-gnu/src/gcc/libgo/go/archive/tar/format.go:109
  *f = (*f | f2) //109
 func (f <esc:0x1> <type 27>) .archive/tar.mayOnlyBe (f2 <type 1>) <inl:171>
  // /home/arreguin/utils/00-ccLab2-fedora35/opt/.build/HOST-riscv64-c06-linux-gnu/riscv64-c07-linux-gnu/src/gcc/libgo/go/archive/tar/format.go:110
  *f = (*f & f2) //110
 func (f <esc:0x1> <type 27>) .archive/tar.mustNotBe (f2 <type 1>) <inl:172>
  // /home/arreguin/utils/00-ccLab2-fedora35/opt/.build/HOST-riscv64-c06-linux-gnu/riscv64-c07-linux-gnu/src/gcc/libgo/go/archive/tar/format.go:111
  *f = (*f &^ f2) //111
 func (f <type 1>) String () <type -16>
type 2 "Header" <type 28>
 func (h <type 2>) .archive/tar.allowedFormats () (format <type 1>, paxHdrs <type 29>, err <type -19>)
 func (h <esc:0x12> <type 26>) FileInfo () <type 5>
type 3 "Reader" <type 36>
 func (tr <type 32>) Next () (? <type 26>, ? <type -19>)
 func (tr <type 32>) .archive/tar.next () (? <type 26>, ? <type -19>)
 func (tr <esc:0x9> <type 32>) .archive/tar.handleRegularFile (hdr <esc:0x1> <type 26>) <type -19>
 func (tr <esc:0x9> <type 32>) .archive/tar.handleSparseFile (hdr <esc:0x1> <type 26>, rawHdr <type 42>) <type -19>
 func (tr <esc:0x9> <type 32>) .archive/tar.readGNUSparsePAXHeaders (hdr <esc:0x1> <type 26>) (? <type 54>, ? <type -19>)
 func (tr <type 32>) .archive/tar.readHeader () (? <type 26>, ? <type 42>, ? <type -19>)
 func (tr <esc:0x9> <type 32>) .archive/tar.readOldGNUSparseMap (hdr <esc:0x1> <type 26>, blk <type 42>) (? <type 54>, ? <type -19>)
 func (tr <esc:0x10a> <type 32>) Read (b <type 9>) (? <type -11>, ? <type -19>)
 func (tr <esc:0x10a> <type 32>) .archive/tar.writeTo (w <type 33>) (? <type -4>, ? <type -19>)
type 4 "Writer" <type 58>
 func (tw <esc:0x2a> <type 35>) Flush () <type -19>
 func (tw <type 35>) WriteHeader (hdr <esc:0x9> <type 26>) <type -19>
 func (tw <type 35>) .archive/tar.writeUSTARHeader (hdr <esc:0x9> <type 26>) <type -19>
 func (tw <type 35>) .archive/tar.writePAXHeader (hdr <esc:0x9> <type 26>, paxHdrs <esc:0x1> <type 29>) <type -19>
 func (tw <type 35>) .archive/tar.writeGNUHeader (hdr <esc:0x9> <type 26>) <type -19>
 func (tw <type 35>) .archive/tar.templateV7Plus (hdr <esc:0x9> <type 26>, fmtStr <esc:0x1> <type 61>, fmtNum <esc:0x1> <type 63>) <type 42>
 func (tw <type 35>) .archive/tar.writeRawFile (name <esc:0x1> <type -16>, data <type -16>, flag <type -20>, format <type 1>) <type -19>
 func (tw <esc:0x2a> <type 35>) .archive/tar.writeRawHeader (blk <type 42>, size <type -4>, flag <type -20>) <type -19>
 func (tw <esc:0x10a> <type 35>) Write (b <type 9>) (? <type -11>, ? <type -19>)
 func (tw <esc:0x10a> <type 35>) .archive/tar.readFrom (r <type 30>) (? <type -4>, ? <type -19>)
 func (tw <esc:0x2a> <type 35>) Close () <type -19>
type 5 "os.FileInfo" <type 6>
type 6 interface { IsDir () <type -15>; ModTime () <type 7>; Mode () <type 24>; Name () <type -16>; Size () <type -4>; Sys () <type 25>; }
type 7 "time.Time" <type 23>
 func (t <esc:0x1> <type 7>) String () <type -16>
 func (t <esc:0x1> <type 7>) Format (layout <esc:0x1> <type -16>) <type -16>
 func (t <esc:0x12> <type 7>) Add (d <type 8>) <type 7>
 func (t <esc:0x1> <type 7>) AppendFormat (b <esc:0x12> <type 9>, layout <esc:0x1> <type -16>) <type 9>
 func (t <esc:0x1> <type 7>) Minute () <type -11>
 func (t <esc:0x1> <type 10>) .time.setMono (m <type -4>)
 func (t <esc:0x1> <type 7>) Clock () (hour <type -11>, min <type -11>, sec <type -11>)
 func (t <esc:0x1> <type 7>) MarshalBinary () (? <type 9>, ? <type -19>)
 func (t <esc:0x1> <type 7>) After (u <esc:0x1> <type 7>) <type -15>
 func (t <esc:0x1> <type 7>) UnixNano () <type -4>
 func (t <esc:0x1> <type 10>) GobDecode (data <esc:0x1> <type 9>) <type -19>
 func (t <esc:0x1> <type 7>) Day () <type -11>
 func (t <esc:0x1> <type 10>) .time.unixSec () <type -4>
 func (t <esc:0x12> <type 7>) Round (d <type 8>) <type 7>
 func (t <esc:0x1> <type 10>) .time.nsec () <type -3>
 func (t <esc:0x1> <type 7>) Before (u <esc:0x1> <type 7>) <type -15>
 func (t <esc:0x32> <type 7>) Zone () (name <type -16>, offset <type -11>)
 func (t <esc:0x1> <type 10>) .time.setLoc (loc <type 11>)
 func (t <esc:0x12> <type 7>) Truncate (d <type 8>) <type 7>
 func (t <esc:0x1> <type 10>) UnmarshalText (data <esc:0x1> <type 9>) <type -19>
 func (t <esc:0x1> <type 10>) UnmarshalBinary (data <esc:0x1> <type 9>) <type -19>
 func (t <esc:0x1> <type 7>) Hour () <type -11>
 func (t <esc:0x1> <type 7>) .time.abs () <type -8>
 func (t <esc:0x1> <type 7>) ISOWeek () (year <type -11>, week <type -11>)
 func (t <esc:0x12> <type 7>) Location () <type 11>
 func (t <esc:0x1> <type 7>) Month () <type 21>
 func (t <esc:0x1> <type 7>) GobEncode () (? <type 9>, ? <type -19>)
 func (t <esc:0x1> <type 7>) Second () <type -11>
 func (t <esc:0x1> <type 10>) UnmarshalJSON (data <esc:0x1> <type 9>) <type -19>
 func (t <esc:0x1> <type 10>) .time.addSec (d <type -4>)
 func (t <esc:0x1> <type 7>) Year () <type -11>
 func (t <esc:0x1> <type 7>) Date () (year <type -11>, month <type 21>, day <type -11>)
 func (t <esc:0x1> <type 7>) Weekday () <type 22>
 func (t <esc:0x1> <type 7>) Unix () <type -4>
 func (t <esc:0x1> <type 7>) YearDay () <type -11>
 func (t <esc:0x12> <type 7>) Local () <type 7>
 func (t <esc:0x1> <type 7>) IsZero () <type -15>
 func (t <esc:0x1> <type 7>) Equal (u <esc:0x1> <type 7>) <type -15>
 func (t <esc:0x12> <type 7>) In (loc <type 11>) <type 7>
 func (t <esc:0x1> <type 7>) Nanosecond () <type -11>
 func (t <esc:0x12> <type 7>) UTC () <type 7>
 func (t <esc:0x32> <type 7>) .time.locabs () (name <type -16>, offset <type -11>, abs <type -8>)
 func (t <esc:0x1> <type 7>) Sub (u <esc:0x1> <type 7>) <type 8>
 func (t <esc:0x1> <type 10>) .time.mono () <type -4>
 func (t <esc:0x1> <type 7>) MarshalText () (? <type 9>, ? <type -19>)
 func (t <esc:0x1> <type 10>) .time.stripMono ()
 func (t <esc:0x1> <type 7>) MarshalJSON () (? <type 9>, ? <type -19>)
 func (t <esc:0x1> <type 7>) .time.date (full <type -15>) (year <type -11>, month <type 21>, day <type -11>, yday <type -11>)
 func (t <type 7>) AddDate (years <type -11>, months <type -11>, days <type -11>) <type 7>
 func (t <esc:0x1> <type 10>) .time.sec () <type -4>
type 8 "time.Duration" <type -4>
 func (d <type 8>) Round (m <type 8>) <type 8>
 func (d <type 8>) Truncate (m <type 8>) <type 8>
 func (d <type 8>) Hours () <type -10>
 func (d <type 8>) Minutes () <type -10>
 func (d <type 8>) Seconds () <type -10>
 func (d <type 8>) Nanoseconds () ($ret65 <type -4>)
 func (d <type 8>) String () <type -16>
type 9 [] <type -20>
type 10 *<type 7>
type 11 *<type 12>
type 12 "time.Location" <type 13>
 func (l <esc:0x1> <type 11>) .time.lookupName (name <esc:0x1> <type -16>, unix <type -4>) (offset <type -11>, ok <type -15>)
 func (l <esc:0x1> <type 11>) .time.firstZoneUsed () <type -15>
 func (l <esc:0x1> <type 11>) .time.lookupFirstZone () <type -11>
 func (l <esc:0x32> <type 11>) .time.lookup (sec <type -4>) (name <type -16>, offset <type -11>, start <type -4>, end <type -4>)
 func (l <esc:0x22> <type 11>) String () <type -16>
 func (l <esc:0x12> <type 11>) .time.get () <type 11>
type 13 struct { .time.name <type -16>; .time.zone <type 14>; .time.tx <type 17>; .time.cacheStart <type -4>; .time.cacheEnd <type -4>; .time.cacheZone <type 20>; }
type 14 [] <type 15>
type 15 ".time.zone" <type 16>
type 16 struct { .time.name <type -16>; .time.offset <type -11>; .time.isDST <type -15>; }
type 17 [] <type 18>
type 18 ".time.zoneTrans" <type 19>
type 19 struct { .time.when <type -4>; .time.index <type -5>; .time.isstd <type -15>; .time.isutc <type -15>; }
type 20 *<type 15>
type 21 "time.Month" <type -11>
 func (m <type 21>) String () <type -16>
type 22 "time.Weekday" <type -11>
 func (d <type 22>) String () <type -16>
type 23 struct { .time.wall <type -8>; .time.ext <type -4>; .time.loc <type 11>; }
type 24 "os.FileMode" <type -7>
 func (m <type 24>) Perm () <type 24>
 func (m <type 24>) IsDir () <type -15>
 func (m <type 24>) IsRegular () <type -15>
 func (m <type 24>) String () <type -16>
type 25 interface { }
type 26 *<type 2>
type 27 *<type 1>
type 28 struct { Typeflag <type -20>; Name <type -16>; Linkname <type -16>; Size <type -4>; Mode <type -4>; Uid <type -11>; Gid <type -11>; Uname <type -16>; Gname <type -16>; ModTime <type 7>; AccessTime <type 7>; ChangeTime <type 7>; Devmajor <type -4>; Devminor <type -4>; Xattrs <type 29>; PAXRecords <type 29>; Format <type 1>; }
type 29 map [<type -16>] <type -16>
type 30 "io.Reader" <type 31>
type 31 interface { Read (p <type 9>) (n <type -11>, err <type -19>); }
type 32 *<type 3>
type 33 "io.Writer" <type 34>
type 34 interface { Write (p <type 9>) (n <type -11>, err <type -19>); }
type 35 *<type 4>
type 36 struct { .archive/tar.r <type 30>; .archive/tar.pad <type -4>; .archive/tar.curr <type 37>; .archive/tar.blk <type 41>; .archive/tar.err <type -19>; }
type 37 ".archive/tar.fileReader" <type 38>
type 38 interface { ? <type 30>; ? <type 39>; WriteTo (? <type 33>) (? <type -4>, ? <type -19>); }
type 39 ".archive/tar.fileState" <type 40>
type 40 interface { LogicalRemaining () <type -4>; PhysicalRemaining () <type -4>; }
type 41 ".archive/tar.block" <type 45>
 func (b <esc:0x12> <type 42>) V7 () <type 43>
 func (b <esc:0x12> <type 42>) GNU () <type 46>
 func (b <esc:0x12> <type 42>) STAR () <type 50>
 func (b <esc:0x12> <type 42>) USTAR () <type 52>
 func (b <esc:0x12> <type 42>) Sparse () <type 48>
 func (b <esc:0x1> <type 42>) GetFormat () <type 1>
 func (b <esc:0x1> <type 42>) SetFormat (format <type 1>)
 func (b <esc:0x1> <type 42>) ComputeChecksum () (unsigned <type -4>, signed <type -4>)
 func (b <esc:0x1> <type 42>) Reset ()
type 42 *<type 41>
type 43 *<type 44>
type 44 ".archive/tar.headerV7" <type 45>
 func (h <esc:0x12> <type 43>) Name () <type 9>
 func (h <esc:0x12> <type 43>) Mode () <type 9>
 func (h <esc:0x12> <type 43>) UID () <type 9>
 func (h <esc:0x12> <type 43>) GID () <type 9>
 func (h <esc:0x12> <type 43>) Size () <type 9>
 func (h <esc:0x12> <type 43>) ModTime () <type 9>
 func (h <esc:0x12> <type 43>) Chksum () <type 9>
 func (h <esc:0x12> <type 43>) TypeFlag () <type 9>
 func (h <esc:0x12> <type 43>) LinkName () <type 9>
type 45 [512 ] <type -20>
type 46 *<type 47>
type 47 ".archive/tar.headerGNU" <type 45>
 func (h <esc:0x12> <type 46>) V7 () <type 43>
 func (h <esc:0x12> <type 46>) Magic () <type 9>
 func (h <esc:0x12> <type 46>) Version () <type 9>
 func (h <esc:0x12> <type 46>) UserName () <type 9>
 func (h <esc:0x12> <type 46>) GroupName () <type 9>
 func (h <esc:0x12> <type 46>) DevMajor () <type 9>
 func (h <esc:0x12> <type 46>) DevMinor () <type 9>
 func (h <esc:0x12> <type 46>) AccessTime () <type 9>
 func (h <esc:0x12> <type 46>) ChangeTime () <type 9>
 func (h <esc:0x12> <type 46>) Sparse () <type 48>
 func (h <esc:0x12> <type 46>) RealSize () <type 9>
type 48 ".archive/tar.sparseArray" <type 9>
 func (s <esc:0x12> <type 48>) Entry (i <type -11>) <type 49>
 func (s <esc:0x12> <type 48>) IsExtended () <type 9>
 func (s <esc:0x1> <type 48>) MaxEntries () <type -11>
type 49 ".archive/tar.sparseElem" <type 9>
 func (s <esc:0x12> <type 49>) Offset () <type 9>
 func (s <esc:0x12> <type 49>) Length () <type 9>
type 50 *<type 51>
type 51 ".archive/tar.headerSTAR" <type 45>
 func (h <esc:0x12> <type 50>) V7 () <type 43>
 func (h <esc:0x12> <type 50>) Magic () <type 9>
 func (h <esc:0x12> <type 50>) Version () <type 9>
 func (h <esc:0x12> <type 50>) UserName () <type 9>
 func (h <esc:0x12> <type 50>) GroupName () <type 9>
 func (h <esc:0x12> <type 50>) DevMajor () <type 9>
 func (h <esc:0x12> <type 50>) DevMinor () <type 9>
 func (h <esc:0x12> <type 50>) Prefix () <type 9>
 func (h <esc:0x12> <type 50>) AccessTime () <type 9>
 func (h <esc:0x12> <type 50>) ChangeTime () <type 9>
 func (h <esc:0x12> <type 50>) Trailer () <type 9>
type 52 *<type 53>
type 53 ".archive/tar.headerUSTAR" <type 45>
 func (h <esc:0x12> <type 52>) V7 () <type 43>
 func (h <esc:0x12> <type 52>) Magic () <type 9>
 func (h <esc:0x12> <type 52>) Version () <type 9>
 func (h <esc:0x12> <type 52>) UserName () <type 9>
 func (h <esc:0x12> <type 52>) GroupName () <type 9>
 func (h <esc:0x12> <type 52>) DevMajor () <type 9>
 func (h <esc:0x12> <type 52>) DevMinor () <type 9>
 func (h <esc:0x12> <type 52>) Prefix () <type 9>
type 54 ".archive/tar.sparseDatas" <type 55>
type 55 [] <type 56>
type 56 ".archive/tar.sparseEntry" <type 57>
 func (s <type 56>) .archive/tar.endOffset () <type -4>
type 57 struct { Offset <type -4>; Length <type -4>; }
type 58 struct { .archive/tar.w <type 33>; .archive/tar.pad <type -4>; .archive/tar.curr <type 59>; .archive/tar.hdr <type 2>; .archive/tar.blk <type 41>; .archive/tar.err <type -19>; }
type 59 ".archive/tar.fileWriter" <type 60>
type 60 interface { ? <type 33>; ? <type 39>; ReadFrom (? <type 30>) (? <type -4>, ? <type -19>); }
type 61 ".archive/tar.stringFormatter" <type 62>
type 62 (? <type 9>, ? <type -16>)
type 63 ".archive/tar.numberFormatter" <type 64>
type 64 (? <type 9>, ? <type -4>)
var ErrFieldTooLong <type -19>
var ErrHeader <type -19>
var ErrWriteAfterClose <type -19>
var ErrWriteTooLong <type -19>
func FileInfoHeader (fi <type 5>, link <type -16>) (? <type 26>, ? <type -19>)
const FormatGNU <type 1> = 8 
const FormatPAX <type 1> = 4 
const FormatUSTAR <type 1> = 2 
const FormatUnknown <type 1> = 0 
func NewReader (r <type 30>) <type 32>
func NewWriter (w <type 33>) <type 35>
const TypeBlock = 52' 
const TypeChar = 51' 
const TypeCont = 55' 
const TypeDir = 53' 
const TypeFifo = 54' 
const TypeGNULongLink = 75' 
const TypeGNULongName = 76' 
const TypeGNUSparse = 83' 
const TypeLink = 49' 
const TypeReg = 48' 
const TypeRegA = 0' 
const TypeSymlink = 50' 
const TypeXGlobalHeader = 103' 
const TypeXHeader = 120' 
checksum A1DA1069CA3B8EA94AA84ADE66950DD8E9CC2343
                                                      .symtab .strtab .shstrtab .go_export                                                                                        @       *>                                                   p>      0                           	                       >                                                          ¡>      &                      ELF          ó                    0^         @     @   v3;
package zip
pkgpath archive/zip
import bufio bufio "bufio"
import flate compress/flate "compress/flate"
import binary encoding/binary "encoding/binary"
import errors errors "errors"
import fmt fmt "fmt"
import hash hash "hash"
import crc32 hash/crc32 "hash/crc32"
import io io "io"
import ioutil io/ioutil "io/ioutil"
import os os "os"
import path path "path"
import strings strings "strings"
import sync sync "sync"
import time time "time"
import utf8 unicode/utf8 "unicode/utf8"
indirectimport poll internal/poll
indirectimport syscall syscall
init zip archive..z2fzip..import bufio bufio..import bytes bytes..import flate compress..z2fflate..import binary encoding..z2fbinary..import fmt fmt..import crc32 hash..z2fcrc32..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import ioutil io..z2fioutil..import os os..import path path..import filepath path..z2ffilepath..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 0 20 0 21 0 22 1 2 1 7 1 10 1 16 1 17 1 19 1 22 2 7 2 10 2 16 2 17 2 19 2 22 3 1 3 2 3 5 3 7 3 8 3 9 3 10 3 12 3 15 3 16 3 17 3 18 3 19 3 20 3 21 3 22 4 7 4 10 4 15 4 16 4 17 4 18 4 19 4 22 5 7 5 8 5 9 5 10 5 12 5 15 5 16 5 17 5 18 5 19 5 20 5 21 5 22 6 7 6 10 6 16 6 17 6 19 8 7 8 10 8 16 8 17 8 19 8 20 8 21 10 7 10 16 10 17 10 19 11 2 11 7 11 8 11 9 11 10 11 12 11 14 11 15 11 16 11 17 11 18 11 19 11 20 11 21 11 22 12 7 12 8 12 9 12 10 12 16 12 17 12 19 12 20 12 21 13 7 13 10 13 16 13 17 13 19 13 22 14 7 14 8 14 9 14 10 14 12 14 15 14 16 14 17 14 18 14 19 14 20 14 21 14 22 15 7 15 16 15 17 15 18 15 19 15 22 16 7 16 17 18 7 18 16 18 17 19 7 19 16 19 17 20 7 20 16 20 17 20 19 21 7 21 16 21 17 21 19 21 20
types 142 8 29 32 323 364 81 276 568 48 29 74 22 35 47 30 43 32 30 73 34 48 157 18 32 90 18 401 3310 356 19 19 525 165 21 31 91 21 36 112 19 73 75 83 18 32 141 195 22 18 18 57 19 2808 21 36 119 23 34 22 32 19 76 136 3616 19 37 91 19 43 50 40 53 24 24 38 40 19 35 61 24 19 21 19 36 78 19 35 54 19 37 61 25 19 35 321 157 19 50 43 44 24 284 375 21 116 953 21 58 21 23 96 21 53 21 41 21 34 59 21 34 36 20 122 22 34 258 21 127 75 23 21 42 64 21 190 223 34 57 32 119 34 44
type 1 "Compressor" <type 8>
type 2 "Decompressor" <type 16>
type 3 "File" <type 21>
 func (f <esc:0x1> <type 25>) .archive/zip.hasDataDescriptor () <type -15>
 func (f <esc:0x9> <type 25>) DataOffset () (offset <type -4>, err <type -19>)
 func (f <type 25>) Open () (? <type 19>, ? <type -19>)
 func (f <esc:0x9> <type 25>) .archive/zip.findBodyOffset () (? <type -4>, ? <type -19>)
type 4 "FileHeader" <type 26>
 func (h <esc:0x12> <type 43>) FileInfo () <type 44>
 func (h <esc:0x1> <type 43>) ModTime () <type 27>
 func (h <esc:0x1> <type 43>) SetModTime (t <type 27>)
 func (h <esc:0x1> <type 43>) Mode () (mode <type 46>)
 func (h <esc:0x1> <type 43>) SetMode (mode <type 46>)
 func (h <esc:0x1> <type 43>) .archive/zip.isZip64 () <type -15>
type 5 "ReadCloser" <type 50>
 func (rc <esc:0x9> <type 49>) Close () <type -19>
type 6 "Reader" <type 122>
 func (z <type 22>) .archive/zip.init (r <type 23>, size <type -4>) <type -19>
 func (z <esc:0x1> <type 22>) RegisterDecompressor (method <type -6>, dcomp <type 2>)
 func (z <esc:0x1> <type 22>) .archive/zip.decompressor (method <type -6>) <type 2>
type 7 "Writer" <type 125>
 func (w <esc:0x1> <type 48>) SetOffset (n <type -4>)
 func (w <esc:0x4a> <type 48>) Flush () <type -19>
 func (w <esc:0x1> <type 48>) SetComment (comment <type -16>) <type -19>
 func (w <esc:0x4a> <type 48>) Close () <type -19>
 func (w <type 48>) Create (name <type -16>) (? <type 9>, ? <type -19>)
 func (w <type 48>) CreateHeader (fh <type 43>) (? <type 9>, ? <type -19>)
 func (w <esc:0x1> <type 48>) RegisterCompressor (method <type -6>, comp <type 1>)
 func (w <esc:0x1> <type 48>) .archive/zip.compressor (method <type -6>) <type 1>
type 8 (w <type 9>) (? <type 12>, ? <type -19>)
type 9 "io.Writer" <type 10>
type 10 interface { Write (p <type 11>) (n <type -11>, err <type -19>); }
type 11 [] <type -20>
type 12 "io.WriteCloser" <type 13>
type 13 interface { ? <type 9>; ? <type 14>; }
type 14 "io.Closer" <type 15>
type 15 interface { Close () <type -19>; }
type 16 (r <type 17>) <type 19>
type 17 "io.Reader" <type 18>
type 18 interface { Read (p <type 11>) (n <type -11>, err <type -19>); }
type 19 "io.ReadCloser" <type 20>
type 20 interface { ? <type 17>; ? <type 14>; }
type 21 struct { ? <type 4>; .archive/zip.zip <type 22>; .archive/zip.zipr <type 23>; .archive/zip.zipsize <type -4>; .archive/zip.headerOffset <type -4>; }
type 22 *<type 6>
type 23 "io.ReaderAt" <type 24>
type 24 interface { ReadAt (p <type 11>, off <type -4>) (n <type -11>, err <type -19>); }
type 25 *<type 3>
type 26 struct { Name <type -16>; Comment <type -16>; NonUTF8 <type -15>; CreatorVersion <type -6>; ReaderVersion <type -6>; Flags <type -6>; Method <type -6>; Modified <type 27>; ModifiedTime <type -6>; ModifiedDate <type -6>; CRC32 <type -7>; CompressedSize <type -7>; UncompressedSize <type -7>; CompressedSize64 <type -8>; UncompressedSize64 <type -8>; Extra <type 11>; ExternalAttrs <type -7>; }
type 27 "time.Time" <type 42>
 func (t <esc:0x1> <type 27>) String () <type -16>
 func (t <esc:0x1> <type 27>) Format (layout <esc:0x1> <type -16>) <type -16>
 func (t <esc:0x12> <type 27>) Add (d <type 28>) <type 27>
 func (t <esc:0x1> <type 27>) AppendFormat (b <esc:0x12> <type 11>, layout <esc:0x1> <type -16>) <type 11>
 func (t <esc:0x1> <type 27>) Minute () <type -11>
 func (t <esc:0x1> <type 29>) .time.setMono (m <type -4>)
 func (t <esc:0x1> <type 27>) Clock () (hour <type -11>, min <type -11>, sec <type -11>)
 func (t <esc:0x1> <type 27>) MarshalBinary () (? <type 11>, ? <type -19>)
 func (t <esc:0x1> <type 27>) After (u <esc:0x1> <type 27>) <type -15>
 func (t <esc:0x1> <type 27>) UnixNano () <type -4>
 func (t <esc:0x1> <type 29>) GobDecode (data <esc:0x1> <type 11>) <type -19>
 func (t <esc:0x1> <type 27>) Day () <type -11>
 func (t <esc:0x1> <type 29>) .time.unixSec () <type -4>
 func (t <esc:0x12> <type 27>) Round (d <type 28>) <type 27>
 func (t <esc:0x1> <type 29>) .time.nsec () <type -3>
 func (t <esc:0x1> <type 27>) Before (u <esc:0x1> <type 27>) <type -15>
 func (t <esc:0x32> <type 27>) Zone () (name <type -16>, offset <type -11>)
 func (t <esc:0x1> <type 29>) .time.setLoc (loc <type 30>)
 func (t <esc:0x12> <type 27>) Truncate (d <type 28>) <type 27>
 func (t <esc:0x1> <type 29>) UnmarshalText (data <esc:0x1> <type 11>) <type -19>
 func (t <esc:0x1> <type 29>) UnmarshalBinary (data <esc:0x1> <type 11>) <type -19>
 func (t <esc:0x1> <type 27>) Hour () <type -11>
 func (t <esc:0x1> <type 27>) .time.abs () <type -8>
 func (t <esc:0x1> <type 27>) ISOWeek () (year <type -11>, week <type -11>)
 func (t <esc:0x12> <type 27>) Location () <type 30>
 func (t <esc:0x1> <type 27>) Month () <type 40>
 func (t <esc:0x1> <type 27>) GobEncode () (? <type 11>, ? <type -19>)
 func (t <esc:0x1> <type 27>) Second () <type -11>
 func (t <esc:0x1> <type 29>) UnmarshalJSON (data <esc:0x1> <type 11>) <type -19>
 func (t <esc:0x1> <type 29>) .time.addSec (d <type -4>)
 func (t <esc:0x1> <type 27>) Year () <type -11>
 func (t <esc:0x1> <type 27>) Date () (year <type -11>, month <type 40>, day <type -11>)
 func (t <esc:0x1> <type 27>) Weekday () <type 41>
 func (t <esc:0x1> <type 27>) Unix () <type -4>
 func (t <esc:0x1> <type 27>) YearDay () <type -11>
 func (t <esc:0x12> <type 27>) Local () <type 27>
 func (t <esc:0x1> <type 27>) IsZero () <type -15>
 func (t <esc:0x1> <type 27>) Equal (u <esc:0x1> <type 27>) <type -15>
 func (t <esc:0x12> <type 27>) In (loc <type 30>) <type 27>
 func (t <esc:0x1> <type 27>) Nanosecond () <type -11>
 func (t <esc:0x12> <type 27>) UTC () <type 27>
 func (t <esc:0x32> <type 27>) .time.locabs () (name <type -16>, offset <type -11>, abs <type -8>)
 func (t <esc:0x1> <type 27>) Sub (u <esc:0x1> <type 27>) <type 28>
 func (t <esc:0x1> <type 29>) .time.mono () <type -4>
 func (t <esc:0x1> <type 27>) MarshalText () (? <type 11>, ? <type -19>)
 func (t <esc:0x1> <type 29>) .time.stripMono ()
 func (t <esc:0x1> <type 27>) MarshalJSON () (? <type 11>, ? <type -19>)
 func (t <esc:0x1> <type 27>) .time.date (full <type -15>) (year <type -11>, month <type 40>, day <type -11>, yday <type -11>)
 func (t <type 27>) AddDate (years <type -11>, months <type -11>, days <type -11>) <type 27>
 func (t <esc:0x1> <type 29>) .time.sec () <type -4>
type 28 "time.Duration" <type -4>
 func (d <type 28>) Round (m <type 28>) <type 28>
 func (d <type 28>) Truncate (m <type 28>) <type 28>
 func (d <type 28>) Hours () <type -10>
 func (d <type 28>) Minutes () <type -10>
 func (d <type 28>) Seconds () <type -10>
 func (d <type 28>) Nanoseconds () ($ret65 <type -4>)
 func (d <type 28>) String () <type -16>
type 29 *<type 27>
type 30 *<type 31>
type 31 "time.Location" <type 32>
 func (l <esc:0x1> <type 30>) .time.lookupName (name <esc:0x1> <type -16>, unix <type -4>) (offset <type -11>, ok <type -15>)
 func (l <esc:0x1> <type 30>) .time.firstZoneUsed () <type -15>
 func (l <esc:0x1> <type 30>) .time.lookupFirstZone () <type -11>
 func (l <esc:0x32> <type 30>) .time.lookup (sec <type -4>) (name <type -16>, offset <type -11>, start <type -4>, end <type -4>)
 func (l <esc:0x22> <type 30>) String () <type -16>
 func (l <esc:0x12> <type 30>) .time.get () <type 30>
type 32 struct { .time.name <type -16>; .time.zone <type 33>; .time.tx <type 36>; .time.cacheStart <type -4>; .time.cacheEnd <type -4>; .time.cacheZone <type 39>; }
type 33 [] <type 34>
type 34 ".time.zone" <type 35>
type 35 struct { .time.name <type -16>; .time.offset <type -11>; .time.isDST <type -15>; }
type 36 [] <type 37>
type 37 ".time.zoneTrans" <type 38>
type 38 struct { .time.when <type -4>; .time.index <type -5>; .time.isstd <type -15>; .time.isutc <type -15>; }
type 39 *<type 34>
type 40 "time.Month" <type -11>
 func (m <type 40>) String () <type -16>
type 41 "time.Weekday" <type -11>
 func (d <type 41>) String () <type -16>
type 42 struct { .time.wall <type -8>; .time.ext <type -4>; .time.loc <type 30>; }
type 43 *<type 4>
type 44 "os.FileInfo" <type 45>
type 45 interface { IsDir () <type -15>; ModTime () <type 27>; Mode () <type 46>; Name () <type -16>; Size () <type -4>; Sys () <type 47>; }
type 46 "os.FileMode" <type -7>
 func (m <type 46>) Perm () <type 46>
 func (m <type 46>) IsDir () <type -15>
 func (m <type 46>) IsRegular () <type -15>
 func (m <type 46>) String () <type -16>
type 47 interface { }
type 48 *<type 7>
type 49 *<type 5>
type 50 struct { .archive/zip.f <type 51>; ? <type 6>; }
type 51 *<type 52>
type 52 "os.File" <type 59>
 func (f <esc:0x10a> <type 51>) Stat () (? <type 44>, ? <type -19>)
 func (f <esc:0x10a> <type 51>) .os.readdir (n <type -11>) (fi <type 53>, err <type -19>)
 func (f <esc:0x9> <type 51>) .os.seek (offset <type -4>, whence <type -11>) (ret <type -4>, err <type -19>)
 func (f <esc:0x9> <type 51>) .os.pwrite (b <esc:0x1> <type 11>, off <type -4>) (n <type -11>, err <type -19>)
 func (f <esc:0x9> <type 51>) .os.write (b <type 11>) (n <type -11>, err <type -19>)
 func (f <esc:0x9> <type 51>) SetDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x10a> <type 51>) WriteString (s <esc:0x1> <type -16>) (n <type -11>, err <type -19>)
 func (f <esc:0x10a> <type 51>) ReadAt (b <esc:0x1> <type 11>, off <type -4>) (n <type -11>, err <type -19>)
 func (f <esc:0x9> <type 51>) SetWriteDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x10a> <type 51>) Read (b <type 11>) (n <type -11>, err <type -19>)
 func (f <esc:0x9> <type 51>) .os.pread (b <esc:0x1> <type 11>, off <type -4>) (n <type -11>, err <type -19>)
 func (f <esc:0x10a> <type 51>) Seek (offset <type -4>, whence <type -11>) (ret <type -4>, err <type -19>)
 func (f <esc:0x10a> <type 51>) Write (b <type 11>) (n <type -11>, err <type -19>)
 func (f <esc:0x9> <type 51>) SetReadDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x9> <type 51>) .os.setReadDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x22> <type 51>) .os.wrapErr (op <type -16>, err <type -19>) <type -19>
 func (f <type 51>) SyscallConn () (? <type 54>, ? <type -19>)
 func (f <esc:0x10a> <type 51>) WriteAt (b <esc:0x1> <type 11>, off <type -4>) (n <type -11>, err <type -19>)
 func (file <esc:0x10a> <type 51>) .os.readdirnames (n <type -11>) (names <type 58>, err <type -19>)
 func (f <esc:0x2a> <type 51>) Chmod (mode <type 46>) <type -19>
 func (f <esc:0x10a> <type 51>) Readdirnames (n <type -11>) (names <type 58>, err <type -19>)
 func (f <esc:0x2a> <type 51>) .os.chmod (mode <type 46>) <type -19>
 func (f <esc:0x9> <type 51>) Close () <type -19>
 func (f <esc:0x10a> <type 51>) Readdir (n <type -11>) (? <type 53>, ? <type -19>)
 func (f <esc:0x2a> <type 51>) Chown (uid <type -11>, gid <type -11>) <type -19>
 func (f <esc:0x2a> <type 51>) Truncate (size <type -4>) <type -19>
 func (f <esc:0x32> <type 51>) Name () <type -16>
 func (f <esc:0x2a> <type 51>) Sync () <type -19>
 func (f <esc:0x9> <type 51>) .os.setDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x2a> <type 51>) Chdir () <type -19>
 func (f <esc:0x9> <type 51>) .os.setWriteDeadline (t <esc:0x1> <type 27>) <type -19>
 func (f <esc:0x1> <type 51>) .os.checkValid (op <esc:0x1> <type -16>) <type -19>
 func (f <esc:0x9> <type 51>) Fd () <type -13>
 func (f <esc:0x9> <type 51>) .os.read (b <type 11>) (n <type -11>, err <type -19>)
type 53 [] <type 44>
type 54 "syscall.RawConn" <type 55>
type 55 interface { Control (f <type 56>) <type -19>; Read (f <type 57>) <type -19>; Write (f <type 57>) <type -19>; }
type 56 (? <type -13>)
type 57 (? <type -13>) <type -15>
type 58 [] <type -16>
type 59 struct { ? <type 60>; }
type 60 *<type 61>
type 61 ".os.file" <type 62>
 func (file <type 60>) .os.close () <type -19>
type 62 struct { .os.pfd <type 63>; .os.name <type -16>; .os.dirinfo <type 115>; .os.nonblock <type -15>; .os.stdoutOrErr <type -15>; }
type 63 "internal/poll.FD" <type 101>
 func (fd <type 64>) Accept () (? <type -11>, ? <type 65>, ? <type -16>, ? <type -19>)
 func (fd <type 64>) Pwrite (p <esc:0x1> <type 11>, off <type -4>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) .internal/poll.writeUnlock ()
 func (fd <type 64>) Write (p <type 11>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) ReadFrom (p <esc:0x1> <type 11>) (? <type -11>, ? <type 65>, ? <type -19>)
 func (fd <type 64>) .internal/poll.readLock () <type -19>
 func (fd <type 64>) Pread (p <esc:0x1> <type 11>, off <type -4>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) Read (p <type 11>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) Shutdown (how <type -11>) <type -19>
 func (fd <type 64>) Close () <type -19>
 func (fd <type 64>) .internal/poll.destroy () <type -19>
 func (fd <type 64>) Ftruncate (size <type -4>) <type -19>
 func (fd <type 64>) Seek (offset <type -4>, whence <type -11>) (? <type -4>, ? <type -19>)
 func (fd <esc:0x1> <type 64>) Init (net <esc:0x1> <type -16>, pollable <type -15>) <type -19>
 func (fd <type 64>) Fsync () <type -19>
 func (fd <type 64>) .internal/poll.readUnlock ()
 func (fd <type 64>) Dup () (? <type -11>, ? <type -16>, ? <type -19>)
 func (fd <type 64>) Fchmod (mode <type -7>) <type -19>
 func (fd <type 64>) Fchdir () <type -19>
 func (fd <type 64>) SetsockoptInt (level <type -11>, name <type -11>, arg <type -11>) <type -19>
 func (fd <type 64>) WriteOnce (p <type 11>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) SetsockoptIPMreq (level <type -11>, name <type -11>, mreq <esc:0x1> <type 76>) <type -19>
 func (fd <type 64>) Writev (v <esc:0x9> <type 80>) (? <type -4>, ? <type -19>)
 func (fd <type 64>) RawControl (f <esc:0x1> <type 56>) <type -19>
 func (fd <esc:0x1> <type 64>) WaitWrite () <type -19>
 func (fd <type 64>) SetsockoptIPMreqn (level <type -11>, name <type -11>, mreq <esc:0x1> <type 82>) <type -19>
 func (fd <type 64>) RawWrite (f <esc:0x1> <type 57>) <type -19>
 func (fd <type 64>) Fchown (uid <type -11>, gid <type -11>) <type -19>
 func (fd <type 64>) SetReadDeadline (t <esc:0x1> <type 27>) <type -19>
 func (fd <type 64>) SetsockoptLinger (level <type -11>, name <type -11>, l <esc:0x1> <type 85>) <type -19>
 func (fd <type 64>) SetsockoptIPv6Mreq (level <type -11>, name <type -11>, mreq <esc:0x1> <type 88>) <type -19>
 func (fd <type 64>) SetsockoptByte (level <type -11>, name <type -11>, arg <type -20>) <type -19>
 func (fd <type 64>) SetBlocking () <type -19>
 func (fd <type 64>) ReadDirent (buf <esc:0x1> <type 11>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) .internal/poll.decref () <type -19>
 func (fd <type 64>) RawRead (f <esc:0x1> <type 57>) <type -19>
 func (fd <type 64>) SetDeadline (t <esc:0x1> <type 27>) <type -19>
 func (fd <type 64>) Fstat (s <esc:0x1> <type 92>) <type -19>
 func (fd <type 64>) ReadMsg (p <esc:0x1> <type 11>, oob <esc:0x1> <type 11>) (? <type -11>, ? <type -11>, ? <type -11>, ? <type 65>, ? <type -19>)
 func (fd <type 64>) .internal/poll.writeLock () <type -19>
 func (fd <type 64>) SetsockoptInet4Addr (level <type -11>, name <type -11>, arg <type 79>) <type -19>
 func (fd <esc:0x1> <type 64>) .internal/poll.eofError (n <type -11>, err <esc:0x12> <type -19>) <type -19>
 func (fd <type 64>) WriteTo (p <esc:0x1> <type 11>, sa <type 65>) (? <type -11>, ? <type -19>)
 func (fd <type 64>) SetWriteDeadline (t <esc:0x1> <type 27>) <type -19>
 func (fd <type 64>) .internal/poll.incref () <type -19>
 func (fd <type 64>) WriteMsg (p <esc:0x1> <type 11>, oob <esc:0x1> <type 11>, sa <type 65>) (? <type -11>, ? <type -11>, ? <type -19>)
type 64 *<type 63>
type 65 "syscall.Sockaddr" <type 66>
type 66 interface { .syscall.sockaddr () (ptr <type 67>, len <type 74>, err <type -19>); }
type 67 *<type 68>
type 68 "syscall.RawSockaddrAny" <type 69>
type 69 struct { Addr <type 70>; Pad <type 73>; }
type 70 "syscall.RawSockaddr" <type 71>
type 71 struct { Family <type -6>; Data <type 72>; }
type 72 [14 ] <type -1>
type 73 [96 ] <type -1>
type 74 "syscall.Socklen_t" <type 75>
type 75 ".syscall._socklen_t" <type -7>
type 76 *<type 77>
type 77 "syscall.IPMreq" <type 78>
type 78 struct { Multiaddr <type 79>; Interface <type 79>; }
type 79 [4 ] <type -20>
type 80 *<type 81>
type 81 [] <type 11>
type 82 *<type 83>
type 83 "syscall.IPMreqn" <type 84>
type 84 struct { Multiaddr <type 79>; Address <type 79>; Ifindex <type -3>; }
type 85 *<type 86>
type 86 "syscall.Linger" <type 87>
type 87 struct { Onoff <type -3>; Linger <type -3>; }
type 88 *<type 89>
type 89 "syscall.IPv6Mreq" <type 90>
type 90 struct { Multiaddr <type 91>; Interface <type -7>; }
type 91 [16 ] <type -20>
type 92 *<type 93>
type 93 "syscall.Stat_t" <type 94>
type 94 struct { Dev <type -8>; Ino <type -8>; Mode <type -7>; Nlink <type -7>; Uid <type -7>; Gid <type -7>; Rdev <type -8>; .syscall.__pad1 <type -8>; Size <type -4>; Blksize <type -3>; .syscall.__pad2 <type -3>; Blocks <type -4>; Atim <type 95>; Mtim <type 95>; Ctim <type 95>; .syscall.__glibc_reserved <type 100>; }
type 95 "syscall.Timespec" <type 97>
 func (ts <esc:0x1> <type 96>) Unix () (sec <type -4>, nsec <type -4>)
 func (ts <esc:0x1> <type 96>) Nano () <type -4>
type 96 *<type 95>
type 97 struct { Sec <type 98>; Nsec <type 99>; }
type 98 "syscall.Timespec_sec_t" <type -4>
type 99 "syscall.Timespec_nsec_t" <type -4>
type 100 [2 ] <type -3>
type 101 struct { .internal/poll.fdmu <type 102>; Sysfd <type -11>; .internal/poll.pd <type 105>; .internal/poll.iovecs <type 108>; .internal/poll.csema <type -7>; .internal/poll.isBlocking <type -7>; IsStream <type -15>; ZeroReadIsEOF <type -15>; .internal/poll.isFile <type -15>; }
type 102 ".internal/poll.fdMutex" <type 104>
 func (mu <type 103>) .internal/poll.incref () <type -15>
 func (mu <type 103>) .internal/poll.increfAndClose () <type -15>
 func (mu <type 103>) .internal/poll.decref () <type -15>
 func (mu <type 103>) .internal/poll.rwlock (read <type -15>) <type -15>
 func (mu <type 103>) .internal/poll.rwunlock (read <type -15>) <type -15>
type 103 *<type 102>
type 104 struct { .internal/poll.state <type -8>; .internal/poll.rsema <type -7>; .internal/poll.wsema <type -7>; }
type 105 ".internal/poll.pollDesc" <type 107>
 func (pd <esc:0x1> <type 106>) .internal/poll.init (fd <esc:0x1> <type 64>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.evict ()
 func (pd <esc:0x1> <type 106>) .internal/poll.close ()
 func (pd <esc:0x1> <type 106>) .internal/poll.wait (mode <type -11>, isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.prepare (mode <type -11>, isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.pollable () <type -15>
 func (pd <esc:0x1> <type 106>) .internal/poll.prepareRead (isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.waitWrite (isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.prepareWrite (isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.waitRead (isFile <type -15>) <type -19>
 func (pd <esc:0x1> <type 106>) .internal/poll.waitCanceled (mode <type -11>)
type 106 *<type 105>
type 107 struct { .internal/poll.runtimeCtx <type -13>; }
type 108 *<type 109>
type 109 [] <type 110>
type 110 "syscall.Iovec" <type 112>
 func (iov <esc:0x1> <type 111>) SetLen (length <type -11>)
type 111 *<type 110>
type 112 struct { Base <type 113>; Len <type 114>; }
type 113 *<type -20>
type 114 "syscall.Iovec_len_t" <type -8>
type 115 *<type 116>
type 116 ".os.dirInfo" <type 117>
type 117 struct { .os.buf <type 11>; .os.dir <type 118>; }
type 118 *<type 119>
type 119 "syscall.DIR" <type 120>
type 120 ".syscall._DIR" <type 121>
type 121 struct { }
type 122 struct { .archive/zip.r <type 23>; File <type 123>; Comment <type -16>; .archive/zip.decompressors <type 124>; }
type 123 [] <type 25>
type 124 map [<type -6>] <type 2>
type 125 struct { .archive/zip.cw <type 126>; .archive/zip.dir <type 129>; .archive/zip.last <type 133>; .archive/zip.closed <type -15>; .archive/zip.compressors <type 140>; .archive/zip.comment <type -16>; .archive/zip.testHookCloseSizeOffset <type 141>; }
type 126 *<type 127>
type 127 ".archive/zip.countWriter" <type 128>
 func (w <esc:0x9> <type 126>) Write (p <type 11>) (? <type -11>, ? <type -19>)
type 128 struct { .archive/zip.w <type 9>; .archive/zip.count <type -4>; }
type 129 [] <type 130>
type 130 *<type 131>
type 131 ".archive/zip.header" <type 132>
type 132 struct { ? <type 43>; .archive/zip.offset <type -8>; }
type 133 *<type 134>
type 134 ".archive/zip.fileWriter" <type 135>
 func (w <esc:0x9> <type 133>) Write (p <type 11>) (? <type -11>, ? <type -19>)
 func (w <esc:0x9> <type 133>) .archive/zip.close () <type -19>
type 135 struct { ? <type 130>; .archive/zip.zipw <type 9>; .archive/zip.rawCount <type 126>; .archive/zip.comp <type 12>; .archive/zip.compCount <type 126>; .archive/zip.crc32 <type 136>; .archive/zip.closed <type -15>; }
type 136 "hash.Hash32" <type 137>
type 137 interface { ? <type 138>; Sum32 () <type -7>; }
type 138 "hash.Hash" <type 139>
type 139 interface { ? <type 9>; BlockSize () <type -11>; Reset (); Size () <type -11>; Sum (b <type 11>) <type 11>; }
type 140 map [<type -6>] <type 1>
type 141 (size <type -8>, offset <type -8>)
const Deflate <type -6> = 8 
var ErrAlgorithm <type -19>
var ErrChecksum <type -19>
var ErrFormat <type -19>
func FileInfoHeader (fi <type 44>) (? <type 43>, ? <type -19>)
func NewReader (r <type 23>, size <type -4>) (? <type 22>, ? <type -19>)
func NewWriter (w <type 9>) <type 48>
func OpenReader (name <type -16>) (? <type 49>, ? <type -19>)
func RegisterCompressor (method <type -6>, comp <type 1>)
func RegisterDecompressor (method <type -6>, dcomp <type 2>)
const Store <type -6> = 0 
checksum 8F33593AA35D3C3ED1D1D16ED99D0E2084FCD72B
                                                       .symtab .strtab .shstrtab .go_export                                                                                        @       ‘]                                                   Ø]      0                           	                      ^                                                          	^      &                                                                                                                                                                              ELF          ó                    (         @     @   v3;
package bufio
pkgpath bufio
import bytes bytes "bytes"
import errors errors "errors"
import io io "io"
import utf8 unicode/utf8 "unicode/utf8"
init bufio bufio..import bytes bytes..import cpu internal..z2fcpu..import io io..import runtime runtime..import sys runtime..z2finternal..z2fsys..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 1 2 1 3 1 4 1 5 1 6 1 7 3 2 3 4 3 5 3 6 4 2 4 5 6 2 6 4 6 5
types 20 6 30 1409 478 29 697 17 17 17 29 73 22 18 30 74 43 186 291 97 106
type 1 "ReadWriter" <type 15>
type 2 "Reader" <type 16>
 func (b <esc:0x1> <type 6>) Size () <type -11>
 func (b <esc:0x9> <type 6>) Reset (r <type 9>)
 func (b <esc:0x1> <type 6>) .bufio.reset (buf <type 11>, r <type 9>)
 func (b <esc:0x9> <type 6>) .bufio.fill ()
 func (b <esc:0x22> <type 6>) .bufio.readErr () <type -19>
 func (b <esc:0x12a> <type 6>) Peek (n <type -11>) (? <type 11>, ? <type -19>)
 func (b <esc:0x10a> <type 6>) Discard (n <type -11>) (discarded <type -11>, err <type -19>)
 func (b <esc:0x10a> <type 6>) Read (p <type 11>) (n <type -11>, err <type -19>)
 func (b <esc:0x10a> <type 6>) ReadByte () (? <type -20>, ? <type -19>)
 func (b <esc:0x1> <type 6>) UnreadByte () <type -19>
 func (b <esc:0x80a> <type 6>) ReadRune () (r <type -21>, size <type -11>, err <type -19>)
 func (b <esc:0x1> <type 6>) UnreadRune () <type -19>
 func (b <esc:0x1> <type 6>) Buffered () <type -11>
 func (b <esc:0x12a> <type 6>) ReadSlice (delim <type -20>) (line <type 11>, err <type -19>)
 func (b <esc:0x82a> <type 6>) ReadLine () (line <type 11>, isPrefix <type -15>, err <type -19>)
 func (b <esc:0x10a> <type 6>) ReadBytes (delim <type -20>) (? <type 11>, ? <type -19>)
 func (b <esc:0x10a> <type 6>) ReadString (delim <type -20>) (? <type -16>, ? <type -19>)
 func (b <esc:0x10a> <type 6>) WriteTo (w <type 13>) (n <type -4>, err <type -19>)
 func (b <esc:0x9> <type 6>) .bufio.writeBuf (w <type 13>) (? <type -4>, ? <type -19>)
type 3 "Scanner" <type 17>
 func (s <esc:0x22> <type 12>) Err () <type -19>
 func (s <esc:0x22> <type 12>) Bytes () <type 11>
 func (s <esc:0x1> <type 12>) Text () <type -16>
 func (s <esc:0x9> <type 12>) Scan () <type -15>
 func (s <esc:0x1> <type 12>) .bufio.advance (n <type -11>) <type -15>
 func (s <esc:0x1> <type 12>) .bufio.setErr (err <type -19>)
 func (s <esc:0x1> <type 12>) Buffer (buf <type 11>, max <type -11>)
 func (s <esc:0x1> <type 12>) Split (split <type 4>)
type 4 "SplitFunc" <type 18>
type 5 "Writer" <type 19>
 func (b <esc:0x1> <type 7>) Size () <type -11>
 func (b <esc:0x1> <type 7>) Reset (w <type 13>)
 func (b <esc:0x2a> <type 7>) Flush () <type -19>
 func (b <esc:0x1> <type 7>) Available () <type -11>
 func (b <esc:0x1> <type 7>) Buffered () <type -11>
 func (b <esc:0x10a> <type 7>) Write (p <type 11>) (nn <type -11>, err <type -19>)
 func (b <esc:0x2a> <type 7>) WriteByte (c <type -20>) <type -19>
 func (b <esc:0x10a> <type 7>) WriteRune (r <type -21>) (size <type -11>, err <type -19>)
 func (b <esc:0x10a> <type 7>) WriteString (s <esc:0x1> <type -16>) (? <type -11>, ? <type -19>)
 func (b <esc:0x10a> <type 7>) ReadFrom (r <type 9>) (n <type -4>, err <type -19>)
type 6 *<type 2>
type 7 *<type 5>
type 8 *<type 1>
type 9 "io.Reader" <type 10>
type 10 interface { Read (p <type 11>) (n <type -11>, err <type -19>); }
type 11 [] <type -20>
type 12 *<type 3>
type 13 "io.Writer" <type 14>
type 14 interface { Write (p <type 11>) (n <type -11>, err <type -19>); }
type 15 struct { ? <type 6>; ? <type 7>; }
type 16 struct { .bufio.buf <type 11>; .bufio.rd <type 9>; .bufio.r <type -11>; .bufio.w <type -11>; .bufio.err <type -19>; .bufio.lastByte <type -11>; .bufio.lastRuneSize <type -11>; }
type 17 struct { .bufio.r <type 9>; .bufio.split <type 4>; .bufio.maxTokenSize <type -11>; .bufio.token <type 11>; .bufio.buf <type 11>; .bufio.start <type -11>; .bufio.end <type -11>; .bufio.err <type -19>; .bufio.empties <type -11>; .bufio.scanCalled <type -15>; .bufio.done <type -15>; }
type 18 (data <type 11>, atEOF <type -15>) (advance <type -11>, token <type 11>, err <type -19>)
type 19 struct { .bufio.err <type -19>; .bufio.buf <type 11>; .bufio.n <type -11>; .bufio.wr <type 13>; }
var ErrAdvanceTooFar <type -19>
var ErrBufferFull <type -19>
var ErrFinalToken <type -19>
var ErrInvalidUnreadByte <type -19>
var ErrInvalidUnreadRune <type -19>
var ErrNegativeAdvance <type -19>
var ErrNegativeCount <type -19>
var ErrTooLong <type -19>
const MaxScanTokenSize = 65536 
func NewReadWriter (r <type 6>, w <type 7>) <type 8>
func NewReader (rd <type 9>) <type 6>
func NewReaderSize (rd <type 9>, size <type -11>) <type 6>
func NewScanner (r <type 9>) <type 12>
func NewWriter (w <type 13>) <type 7>
func NewWriterSize (w <type 13>, size <type -11>) <type 7>
func ScanBytes (data <esc:0x82> <type 11>, atEOF <type -15>) (advance <type -11>, token <type 11>, err <type -19>)
func ScanLines (data <esc:0x82> <type 11>, atEOF <type -15>) (advance <type -11>, token <type 11>, err <type -19>)
func ScanRunes (data <esc:0x82> <type 11>, atEOF <type -15>) (advance <type -11>, token <type 11>, err <type -19>)
func ScanWords (data <esc:0x82> <type 11>, atEOF <type -15>) (advance <type -11>, token <type 11>, err <type -19>)
checksum 578F7D5ADF82C85BCA188CDED68ED6640201E35C
                                                   .symtab .strtab .shstrtab .go_export                                                                                        @                                                          Ð      0                           	                                                                                       &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ó                    °         @     @   v3;
package bytes
pkgpath bytes
import errors errors "errors"
import bytealg internal/bytealg "internal/bytealg"
import io io "io"
import unicode unicode "unicode"
import utf8 unicode/utf8 "unicode/utf8"
init bytes bytes..import cpu internal..z2fcpu..import io io..import runtime runtime..import sys runtime..z2finternal..z2fsys..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 2 1 2 3 2 4 2 5 3 1 3 4 5 1 5 3 5 4
types 23 3 1769 820 88 21 33 17 28 71 29 73 20 34 34 18 86 22 250 21 38 64 31 24
type 1 "Buffer" <type 3>
 func (b <esc:0x22> <type 6>) Bytes () <type 4>
 func (b <esc:0x1> <type 6>) String () <type -16>
 func (b <esc:0x1> <type 6>) .bytes.empty () <type -15>
 func (b <esc:0x1> <type 6>) Len () <type -11>
 func (b <esc:0x1> <type 6>) Cap () <type -11>
 func (b <esc:0x1> <type 6>) Truncate (n <type -11>)
 func (b <esc:0x1> <type 6>) Reset ()
 func (b <esc:0x1> <type 6>) .bytes.tryGrowByReslice (n <type -11>) (? <type -11>, ? <type -15>)
 func (b <esc:0x1> <type 6>) .bytes.grow (n <type -11>) <type -11>
 func (b <esc:0x1> <type 6>) Grow (n <type -11>)
 func (b <esc:0x1> <type 6>) Write (p <esc:0x1> <type 4>) (n <type -11>, err <type -19>)
 func (b <esc:0x1> <type 6>) WriteString (s <esc:0x1> <type -16>) (n <type -11>, err <type -19>)
 func (b <esc:0x9> <type 6>) ReadFrom (r <type 7>) (n <type -4>, err <type -19>)
 func (b <esc:0x9> <type 6>) WriteTo (w <type 9>) (n <type -4>, err <type -19>)
 func (b <esc:0x1> <type 6>) WriteByte (c <type -20>) <type -19>
 func (b <esc:0x1> <type 6>) WriteRune (r <type -21>) (n <type -11>, err <type -19>)
 func (b <esc:0x1> <type 6>) Read (p <esc:0x1> <type 4>) (n <type -11>, err <type -19>)
 func (b <esc:0x22> <type 6>) Next (n <type -11>) <type 4>
 func (b <esc:0x1> <type 6>) ReadByte () (? <type -20>, ? <type -19>)
 func (b <esc:0x1> <type 6>) ReadRune () (r <type -21>, size <type -11>, err <type -19>)
 func (b <esc:0x1> <type 6>) UnreadRune () <type -19>
 func (b <esc:0x1> <type 6>) UnreadByte () <type -19>
 func (b <esc:0x1> <type 6>) ReadBytes (delim <type -20>) (line <type 4>, err <type -19>)
 func (b <esc:0x22> <type 6>) .bytes.readSlice (delim <type -20>) (line <type 4>, err <type -19>)
 func (b <esc:0x1> <type 6>) ReadString (delim <type -20>) (line <type -16>, err <type -19>)
type 2 "Reader" <type 15>
 func (r <esc:0x1> <type 14>) Len () <type -11>
 func (r <esc:0x1> <type 14>) Size () <type -4>
 func (r <esc:0x1> <type 14>) Read (b <esc:0x1> <type 4>) (n <type -11>, err <type -19>)
 func (r <esc:0x1> <type 14>) ReadAt (b <esc:0x1> <type 4>, off <type -4>) (n <type -11>, err <type -19>)
 func (r <esc:0x1> <type 14>) ReadByte () (? <type -20>, ? <type -19>)
 func (r <esc:0x1> <type 14>) UnreadByte () <type -19>
 func (r <esc:0x1> <type 14>) ReadRune () (ch <type -21>, size <type -11>, err <type -19>)
 func (r <esc:0x1> <type 14>) UnreadRune () <type -19>
 func (r <esc:0x1> <type 14>) Seek (offset <type -4>, whence <type -11>) (? <type -4>, ? <type -19>)
 func (r <esc:0x9> <type 14>) WriteTo (w <type 9>) (n <type -4>, err <type -19>)
 func (r <esc:0x1> <type 14>) Reset (b <type 4>)
type 3 struct { .bytes.buf <type 4>; .bytes.off <type -11>; .bytes.lastRead <type 5>; }
type 4 [] <type -20>
type 5 ".bytes.readOp" <type -1>
type 6 *<type 1>
type 7 "io.Reader" <type 8>
type 8 interface { Read (p <type 4>) (n <type -11>, err <type -19>); }
type 9 "io.Writer" <type 10>
type 10 interface { Write (p <type 4>) (n <type -11>, err <type -19>); }
type 11 [] <type 4>
type 12 (? <type -21>) <type -15>
type 13 (r <type -21>) <type -21>
type 14 *<type 2>
type 15 struct { .bytes.s <type 4>; .bytes.i <type -4>; .bytes.prevRune <type -11>; }
type 16 [] <type -21>
type 17 "unicode.SpecialCase" <type 18>
 func (special <esc:0x1> <type 17>) ToLower (r <type -21>) <type -21>
 func (special <esc:0x1> <type 17>) ToTitle (r <type -21>) <type -21>
 func (special <esc:0x1> <type 17>) ToUpper (r <type -21>) <type -21>
type 18 [] <type 19>
type 19 "unicode.CaseRange" <type 20>
type 20 struct { Lo <type -7>; Hi <type -7>; Delta <type 21>; }
type 21 ".unicode.d" <type 22>
type 22 [3 ] <type -21>
func Compare (a <esc:0x1> <type 4>, b <esc:0x1> <type 4>) <type -11>
func Contains (b <esc:0x1> <type 4>, subslice <esc:0x1> <type 4>) <type -15>
func ContainsAny (b <esc:0x1> <type 4>, chars <esc:0x1> <type -16>) <type -15>
func ContainsRune (b <esc:0x1> <type 4>, r <type -21>) <type -15>
func Count (s <esc:0x1> <type 4>, sep <esc:0x1> <type 4>) <type -11>
func Equal (a <esc:0x1> <type 4>, b <esc:0x1> <type 4>) <type -15>
func EqualFold (s <esc:0x1> <type 4>, t <esc:0x1> <type 4>) <type -15>
var ErrTooLarge <type -19>
func Fields (s <type 4>) <type 11>
func FieldsFunc (s <type 4>, f <esc:0x1> <type 12>) <type 11>
func HasPrefix (s <esc:0x1> <type 4>, prefix <esc:0x1> <type 4>) <type -15>
func HasSuffix (s <esc:0x1> <type 4>, suffix <esc:0x1> <type 4>) <type -15>
func Index (s <esc:0x1> <type 4>, sep <esc:0x1> <type 4>) <type -11>
func IndexAny (s <esc:0x1> <type 4>, chars <esc:0x1> <type -16>) <type -11>
func IndexByte (b <esc:0x1> <type 4>, c <type -20>) <type -11>
func IndexFunc (s <esc:0x1> <type 4>, f <esc:0x1> <type 12>) <type -11>
func IndexRune (s <esc:0x1> <type 4>, r <type -21>) <type -11>
func Join (s <esc:0x1> <type 11>, sep <esc:0x1> <type 4>) <type 4>
func LastIndex (s <esc:0x1> <type 4>, sep <esc:0x1> <type 4>) <type -11>
func LastIndexAny (s <esc:0x1> <type 4>, chars <esc:0x1> <type -16>) <type -11>
func LastIndexByte (s <esc:0x1> <type 4>, c <type -20>) <type -11>
func LastIndexFunc (s <esc:0x1> <type 4>, f <esc:0x1> <type 12>) <type -11>
func Map (mapping <esc:0x1> <type 13>, s <esc:0x1> <type 4>) <type 4>
const MinRead = 512 
func NewBuffer (buf <type 4>) <type 6>
func NewBufferString (s <esc:0x1> <type -16>) <type 6>
func NewReader (b <type 4>) <type 14>
func Repeat (b <esc:0x1> <type 4>, count <type -11>) <type 4>
func Replace (s <esc:0x1> <type 4>, old <esc:0x1> <type 4>, new <esc:0x1> <type 4>, n <type -11>) <type 4>
func ReplaceAll (s <esc:0x1> <type 4>, old <esc:0x1> <type 4>, new <esc:0x1> <type 4>) <type 4>
func Runes (s <esc:0x1> <type 4>) <type 16>
func Split (s <type 4>, sep <esc:0x1> <type 4>) <type 11>
func SplitAfter (s <type 4>, sep <esc:0x1> <type 4>) <type 11>
func SplitAfterN (s <type 4>, sep <esc:0x1> <type 4>, n <type -11>) <type 11>
func SplitN (s <type 4>, sep <esc:0x1> <type 4>, n <type -11>) <type 11>
func Title (s <esc:0x1> <type 4>) <type 4>
func ToLower (s <esc:0x1> <type 4>) <type 4>
func ToLowerSpecial (c <type 17>, s <esc:0x1> <type 4>) <type 4>
func ToTitle (s <esc:0x1> <type 4>) <type 4>
func ToTitleSpecial (c <type 17>, s <esc:0x1> <type 4>) <type 4>
func ToUpper (s <esc:0x1> <type 4>) <type 4>
func ToUpperSpecial (c <type 17>, s <esc:0x1> <type 4>) <type 4>
func Trim (s <esc:0x12> <type 4>, cutset <type -16>) <type 4>
func TrimFunc (s <esc:0x12> <type 4>, f <esc:0x1> <type 12>) <type 4>
func TrimLeft (s <esc:0x12> <type 4>, cutset <type -16>) <type 4>
func TrimLeftFunc (s <esc:0x12> <type 4>, f <esc:0x1> <type 12>) <type 4>
func TrimPrefix (s <esc:0x12> <type 4>, prefix <esc:0x1> <type 4>) <type 4>
func TrimRight (s <esc:0x12> <type 4>, cutset <type -16>) <type 4>
func TrimRightFunc (s <esc:0x12> <type 4>, f <esc:0x1> <type 12>) <type 4>
func TrimSpace (s <esc:0x12> <type 4>) <type 4>
func TrimSuffix (s <esc:0x12> <type 4>, suffix <esc:0x1> <type 4>) <type 4>
checksum BA49E2F8F1AE3B4BB8ED00E66CD1F59E00D945F3
                                                     .symtab .strtab .shstrtab .go_export                                                                                        @                                                          X      0                           	                      ˆ                                                          ‰      &                                                                                                                                                                                                                                                                                                              Ç   .   Á   ..  È   	bzip2.gox   É   	flate.gox   Ê   gzip.goxË   lzw.gox Ì   zlib.gox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ELF          ó                             @     @   v3;
package bzip2
pkgpath compress/bzip2
import bufio bufio "bufio"
import io io "io"
import sort sort "sort"
init bzip2 compress..z2fbzip2..import bufio bufio..import bytes bytes..import cpu internal..z2fcpu..import io io..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 1 2 1 3 1 4 1 6 1 7 1 9 1 10 2 3 2 4 2 6 2 7 2 9 2 10 4 3 4 6 4 7 4 9 5 3 5 6 5 7 5 8 5 9 5 10 6 3 6 7 8 3 8 6 8 7 9 3 9 6 9 7
types 5 2 85 28 71 21
type 1 "StructuralError" <type -16>
 func (s <esc:0x1> <type 1>) Error () <type -16>
type 2 "io.Reader" <type 3>
type 3 interface { Read (p <type 4>) (n <type -11>, err <type -19>); }
type 4 [] <type -20>
func NewReader (r <type 2>) <type 2>
checksum FFBF8F23B9BE450C02DA954F3C793610CE3BF0BE
                                                 .symtab .strtab .shstrtab .go_export                                                                                        @       o                                                   °      0                           	                      à                                                          á      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ó                    H+         @     @   v3;
package flate
pkgpath compress/flate
import bufio bufio "bufio"
import fmt fmt "fmt"
import io io "io"
import math math "math"
import bits math/bits "math/bits"
import sort sort "sort"
import strconv strconv "strconv"
import sync sync "sync"
init flate compress..z2fflate..import bufio bufio..import bytes bytes..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 1 2 1 4 1 7 1 10 1 11 1 13 1 16 2 4 2 7 2 10 2 11 2 13 2 16 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 5 4 5 7 5 10 5 11 5 13 5 14 5 15 7 4 7 10 7 11 7 13 8 4 8 5 8 6 8 7 8 10 8 11 8 13 8 14 8 15 9 4 9 10 9 11 9 12 9 13 9 16 10 4 10 11 12 4 12 10 12 11 13 4 13 10 13 11 14 4 14 10 14 11 14 13 15 4 15 10 15 11 15 13 15 14
types 68 8 76 83 79 26 28 80 222 28 72 22 34 47 30 43 30 74 18 53 18 47 34 64 69 18 80 1361 19 21 211 817 53 230 19 1870 19 454 21 21 48 86 187 21 127 19 82 24 288 19 285 19 498 26 24 21 35 21 46 22 19 393 115 27 47 84 28 27 25
type 1 "CorruptInputError" <type -4>
 func (e <type 1>) Error () <type -16>
type 2 "InternalError" <type -16>
 func (e <esc:0x1> <type 2>) Error () <type -16>
type 3 "ReadError" <type 18>
 func (e <esc:0x9> <type 19>) Error () <type -16>
type 4 "Reader" <type 20>
type 5 "Resetter" <type 23>
type 6 "WriteError" <type 18>
 func (e <esc:0x9> <type 24>) Error () <type -16>
type 7 "Writer" <type 25>
 func (w <type 17>) Write (data <type 10>) (n <type -11>, err <type -19>)
 func (w <type 17>) Flush () <type -19>
 func (w <type 17>) Close () <type -19>
 func (w <type 17>) Reset (dst <type 15>)
type 8 "io.Reader" <type 9>
type 9 interface { Read (p <type 10>) (n <type -11>, err <type -19>); }
type 10 [] <type -20>
type 11 "io.ReadCloser" <type 12>
type 12 interface { ? <type 8>; ? <type 13>; }
type 13 "io.Closer" <type 14>
type 14 interface { Close () <type -19>; }
type 15 "io.Writer" <type 16>
type 16 interface { Write (p <type 10>) (n <type -11>, err <type -19>); }
type 17 *<type 7>
type 18 struct { Offset <type -4>; Err <type -19>; }
type 19 *<type 3>
type 20 interface { ? <type 8>; ? <type 21>; }
type 21 "io.ByteReader" <type 22>
type 22 interface { ReadByte () (? <type -20>, ? <type -19>); }
type 23 interface { Reset (r <type 8>, dict <type 10>) <type -19>; }
type 24 *<type 6>
type 25 struct { .compress/flate.d <type 26>; .compress/flate.dict <type 10>; }
type 26 ".compress/flate.compressor" <type 30>
 func (d <esc:0x1> <type 27>) .compress/flate.fillDeflate (b <esc:0x1> <type 10>) <type -11>
 func (d <esc:0x3a> <type 27>) .compress/flate.writeBlock (tokens <esc:0x1> <type 28>, index <type -11>) <type -19>
 func (d <type 27>) .compress/flate.fillWindow (b <esc:0x1> <type 10>)
 func (d <esc:0x1> <type 27>) .compress/flate.findMatch (pos <type -11>, prevHead <type -11>, prevLength <type -11>, lookahead <type -11>) (length <type -11>, offset <type -11>, ok <type -15>)
 func (d <esc:0x3a> <type 27>) .compress/flate.writeStoredBlock (buf <type 10>) <type -19>
 func (d <esc:0x9> <type 27>) .compress/flate.encSpeed ()
 func (d <esc:0x1> <type 27>) .compress/flate.initDeflate ()
 func (d <esc:0x9> <type 27>) .compress/flate.deflate ()
 func (d <esc:0x1> <type 27>) .compress/flate.fillStore (b <esc:0x1> <type 10>) <type -11>
 func (d <esc:0x9> <type 27>) .compress/flate.store ()
 func (d <esc:0x9> <type 27>) .compress/flate.storeHuff ()
 func (d <type 27>) .compress/flate.write (b <type 10>) (n <type -11>, err <type -19>)
 func (d <type 27>) .compress/flate.syncFlush () <type -19>
 func (d <esc:0x1> <type 27>) .compress/flate.init (w <type 15>, level <type -11>) (err <type -19>)
 func (d <esc:0x1> <type 27>) .compress/flate.reset (w <type 15>)
 func (d <type 27>) .compress/flate.close () <type -19>
type 27 *<type 26>
type 28 [] <type 29>
type 29 ".compress/flate.token" <type -7>
 func (t <type 29>) .compress/flate.literal () <type -7>
 func (t <type 29>) .compress/flate.offset () <type -7>
 func (t <type 29>) .compress/flate.length () <type -7>
type 30 struct { ? <type 31>; .compress/flate.w <type 33>; .compress/flate.bulkHasher <type 55>; .compress/flate.fill <type 57>; .compress/flate.step <type 58>; .compress/flate.sync <type -15>; .compress/flate.bestSpeed <type 59>; .compress/flate.chainHead <type -11>; .compress/flate.hashHead <type 65>; .compress/flate.hashPrev <type 66>; .compress/flate.hashOffset <type -11>; .compress/flate.index <type -11>; .compress/flate.window <type 10>; .compress/flate.windowEnd <type -11>; .compress/flate.blockStart <type -11>; .compress/flate.byteAvailable <type -15>; .compress/flate.tokens <type 28>; .compress/flate.length <type -11>; .compress/flate.offset <type -11>; .compress/flate.hash <type -7>; .compress/flate.maxInsertIndex <type -11>; .compress/flate.err <type -19>; .compress/flate.hashMatch <type 67>; }
type 31 ".compress/flate.compressionLevel" <type 32>
type 32 struct { .compress/flate.level <type -11>; .compress/flate.good <type -11>; .compress/flate.lazy <type -11>; .compress/flate.nice <type -11>; .compress/flate.chain <type -11>; .compress/flate.fastSkipHashing <type -11>; }
type 33 *<type 34>
type 34 ".compress/flate.huffmanBitWriter" <type 51>
 func (w <esc:0x1> <type 33>) .compress/flate.reset (writer <type 15>)
 func (w <type 33>) .compress/flate.flush ()
 func (w <esc:0x9> <type 33>) .compress/flate.write (b <type 10>)
 func (w <type 33>) .compress/flate.writeBits (b <type -3>, nb <type -12>)
 func (w <type 33>) .compress/flate.writeBytes (bytes <type 10>)
 func (w <esc:0x1> <type 33>) .compress/flate.generateCodegen (numLiterals <type -11>, numOffsets <type -11>, litEnc <esc:0x1> <type 35>, offEnc <esc:0x1> <type 35>)
 func (w <esc:0x1> <type 33>) .compress/flate.dynamicSize (litEnc <esc:0x1> <type 35>, offEnc <esc:0x1> <type 35>, extraBits <type -11>) (size <type -11>, numCodegens <type -11>)
 func (w <esc:0x1> <type 33>) .compress/flate.fixedSize (extraBits <type -11>) <type -11>
 func (w <esc:0x1> <type 33>) .compress/flate.storedSize (in <esc:0x1> <type 10>) (? <type -11>, ? <type -15>)
 func (w <type 33>) .compress/flate.writeCode (c <type 43>)
 func (w <type 33>) .compress/flate.writeDynamicHeader (numLiterals <type -11>, numOffsets <type -11>, numCodegens <type -11>, isEof <type -15>)
 func (w <type 33>) .compress/flate.writeStoredHeader (length <type -11>, isEof <type -15>)
 func (w <type 33>) .compress/flate.writeFixedHeader (isEof <type -15>)
 func (w <type 33>) .compress/flate.writeBlock (tokens <esc:0x1> <type 28>, eof <type -15>, input <type 10>)
 func (w <type 33>) .compress/flate.writeBlockDynamic (tokens <esc:0x1> <type 28>, eof <type -15>, input <type 10>)
 func (w <esc:0x9> <type 33>) .compress/flate.indexTokens (tokens <esc:0x1> <type 28>) (numLiterals <type -11>, numOffsets <type -11>)
 func (w <type 33>) .compress/flate.writeTokens (tokens <esc:0x1> <type 28>, leCodes <esc:0x1> <type 42>, oeCodes <esc:0x1> <type 42>)
 func (w <type 33>) .compress/flate.writeBlockHuff (eof <type -15>, input <type 10>)
type 35 *<type 36>
type 36 ".compress/flate.huffmanEncoder" <type 41>
 func (h <esc:0x1> <type 35>) .compress/flate.bitLength (freq <esc:0x1> <type 37>) <type -11>
 func (h <esc:0x12> <type 35>) .compress/flate.bitCounts (list <esc:0x1> <type 38>, maxBits <type -3>) <type 37>
 func (h <type 35>) .compress/flate.assignEncodingAndSize (bitCount <esc:0x1> <type 37>, list <type 38>)
 func (h <type 35>) .compress/flate.generate (freq <esc:0x1> <type 37>, maxBits <type -3>)
type 37 [] <type -3>
type 38 [] <type 39>
type 39 ".compress/flate.literalNode" <type 40>
type 40 struct { .compress/flate.literal <type -6>; .compress/flate.freq <type -3>; }
type 41 struct { .compress/flate.codes <type 42>; .compress/flate.freqcache <type 38>; .compress/flate.bitCount <type 46>; .compress/flate.lns <type 47>; .compress/flate.lfs <type 49>; }
type 42 [] <type 43>
type 43 ".compress/flate.hcode" <type 45>
 func (h <esc:0x1> <type 44>) .compress/flate.set (code <type -6>, length <type -6>)
type 44 *<type 43>
type 45 struct { .compress/flate.code <type -6>; .compress/flate.len <type -6>; }
type 46 [17 ] <type -3>
type 47 ".compress/flate.byLiteral" <type 38>
 func (s <type 48>) .compress/flate.sort (a <type 38>)
 func (s <esc:0x1> <type 47>) Len () <type -11>
 func (s <esc:0x1> <type 47>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 47>) Swap (i <type -11>, j <type -11>)
type 48 *<type 47>
type 49 ".compress/flate.byFreq" <type 38>
 func (s <type 50>) .compress/flate.sort (a <type 38>)
 func (s <esc:0x1> <type 49>) Len () <type -11>
 func (s <esc:0x1> <type 49>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 49>) Swap (i <type -11>, j <type -11>)
type 50 *<type 49>
type 51 struct { .compress/flate.writer <type 15>; .compress/flate.bits <type -8>; .compress/flate.nbits <type -12>; .compress/flate.bytes <type 52>; .compress/flate.codegenFreq <type 53>; .compress/flate.nbytes <type -11>; .compress/flate.literalFreq <type 37>; .compress/flate.offsetFreq <type 37>; .compress/flate.codegen <type 54>; .compress/flate.literalEncoding <type 35>; .compress/flate.offsetEncoding <type 35>; .compress/flate.codegenEncoding <type 35>; .compress/flate.err <type -19>; }
type 52 [248 ] <type -20>
type 53 [19 ] <type -3>
type 54 [] <type -5>
type 55 (? <type 10>, ? <type 56>)
type 56 [] <type -7>
type 57 (? <type 27>, ? <type 10>) <type -11>
type 58 (? <type 27>)
type 59 *<type 60>
type 60 ".compress/flate.deflateFast" <type 61>
 func (e <esc:0x1> <type 59>) .compress/flate.encode (dst <esc:0x12> <type 28>, src <esc:0x1> <type 10>) <type 28>
 func (e <esc:0x1> <type 59>) .compress/flate.matchLen (s <type -3>, t <type -3>, src <esc:0x1> <type 10>) <type -3>
 func (e <esc:0x1> <type 59>) .compress/flate.reset ()
 func (e <esc:0x1> <type 59>) .compress/flate.resetAll ()
type 61 struct { .compress/flate.table <type 62>; .compress/flate.prev <type 10>; .compress/flate.cur <type -3>; }
type 62 [16384 ] <type 63>
type 63 ".compress/flate.tableEntry" <type 64>
type 64 struct { .compress/flate.val <type -7>; .compress/flate.offset <type -3>; }
type 65 [131072 ] <type -7>
type 66 [32768 ] <type -7>
type 67 [257 ] <type -7>
const BestCompression = 9 
const BestSpeed = 1 
const DefaultCompression = -1 
const HuffmanOnly = -2 
func NewReader (r <type 8>) <type 11>
func NewReaderDict (r <type 8>, dict <esc:0x1> <type 10>) <type 11>
func NewWriter (w <type 15>, level <type -11>) (? <type 17>, ? <type -19>)
func NewWriterDict (w <type 15>, level <type -11>, dict <esc:0x1> <type 10>) (? <type 17>, ? <type -19>)
const NoCompression = 0 
checksum A01E9A10B02BBB678B9023CF9E4B98D9F73CF342
                                                .symtab .strtab .shstrtab .go_export                                                                                        @       °*                                                   ð*      0                           	                       +                                                          !+      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ó                    (D         @     @   v3;
package gzip
pkgpath compress/gzip
import bufio bufio "bufio"
import flate compress/flate "compress/flate"
import binary encoding/binary "encoding/binary"
import errors errors "errors"
import fmt fmt "fmt"
import crc32 hash/crc32 "hash/crc32"
import io io "io"
import time time "time"
init gzip compress..z2fgzip..import bufio bufio..import bytes bytes..import flate compress..z2fflate..import binary encoding..z2fbinary..import fmt fmt..import crc32 hash..z2fcrc32..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 1 2 1 7 1 10 1 13 1 14 1 16 1 19 2 7 2 10 2 13 2 14 2 16 2 19 3 1 3 2 3 5 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 3 19 4 7 4 10 4 12 4 13 4 14 4 15 4 16 4 19 5 7 5 8 5 9 5 10 5 11 5 12 5 13 5 14 5 15 5 16 5 17 5 18 5 19 6 7 6 10 6 13 6 14 6 16 8 7 8 10 8 13 8 14 8 16 8 17 8 18 10 7 10 13 10 14 10 16 11 7 11 8 11 9 11 10 11 13 11 14 11 16 11 17 11 18 12 7 12 13 12 14 12 15 12 16 12 19 13 7 13 14 15 7 15 13 15 14 16 7 16 13 16 14 17 7 17 13 17 14 17 16 18 7 18 13 18 14 18 16 18 17
types 85 4 25 412 455 104 21 3231 344 17 71 19 525 165 21 31 91 21 36 112 19 75 83 30 72 18 30 73 18 262 42 48 34 64 34 48 30 43 26 327 19 237 79 1356 19 21 211 816 53 230 19 1864 21 127 19 82 19 454 21 21 48 86 187 24 288 19 285 19 498 26 24 21 34 21 45 22 19 391 114 27 47 84 28 27 25 25
type 1 "Header" <type 4>
type 2 "Reader" <type 28>
 func (z <type 24>) Reset (r <type 22>) <type -19>
 func (z <esc:0x1> <type 24>) Multistream (ok <type -15>)
 func (z <type 24>) .compress/gzip.readString () (? <type -16>, ? <type -19>)
 func (z <type 24>) .compress/gzip.readHeader () (hdr <type 1>, err <type -19>)
 func (z <type 24>) Read (p <type 5>) (n <type -11>, err <type -19>)
 func (z <esc:0x9> <type 24>) Close () <type -19>
type 3 "Writer" <type 38>
 func (z <esc:0x9> <type 27>) .compress/gzip.init (w <type 25>, level <type -11>)
 func (z <esc:0x9> <type 27>) Reset (w <type 25>)
 func (z <type 27>) .compress/gzip.writeBytes (b <type 5>) <type -19>
 func (z <type 27>) .compress/gzip.writeString (s <type -16>) (err <type -19>)
 func (z <type 27>) Write (p <type 5>) (? <type -11>, ? <type -19>)
 func (z <type 27>) Flush () <type -19>
 func (z <type 27>) Close () <type -19>
type 4 struct { Comment <type -16>; Extra <type 5>; ModTime <type 6>; Name <type -16>; OS <type -20>; }
type 5 [] <type -20>
type 6 "time.Time" <type 21>
 func (t <esc:0x12> <type 6>) Round (d <type 7>) <type 6>
 func (t <esc:0x12> <type 6>) Truncate (d <type 7>) <type 6>
 func (t <esc:0x1> <type 8>) UnmarshalText (data <esc:0x1> <type 5>) <type -19>
 func (t <esc:0x1> <type 8>) UnmarshalBinary (data <esc:0x1> <type 5>) <type -19>
 func (t <esc:0x12> <type 6>) Local () <type 6>
 func (t <esc:0x1> <type 6>) MarshalJSON () (? <type 5>, ? <type -19>)
 func (t <esc:0x1> <type 6>) .time.date (full <type -15>) (year <type -11>, month <type 9>, day <type -11>, yday <type -11>)
 func (t <type 6>) AddDate (years <type -11>, months <type -11>, days <type -11>) <type 6>
 func (t <esc:0x1> <type 8>) .time.mono () <type -4>
 func (t <esc:0x1> <type 6>) MarshalText () (? <type 5>, ? <type -19>)
 func (t <esc:0x1> <type 8>) .time.stripMono ()
 func (t <esc:0x32> <type 6>) Zone () (name <type -16>, offset <type -11>)
 func (t <esc:0x1> <type 8>) .time.setLoc (loc <type 10>)
 func (t <esc:0x1> <type 8>) .time.unixSec () <type -4>
 func (t <esc:0x1> <type 8>) GobDecode (data <esc:0x1> <type 5>) <type -19>
 func (t <esc:0x1> <type 6>) UnixNano () <type -4>
 func (t <esc:0x1> <type 6>) After (u <esc:0x1> <type 6>) <type -15>
 func (t <esc:0x1> <type 6>) MarshalBinary () (? <type 5>, ? <type -19>)
 func (t <esc:0x1> <type 6>) Clock () (hour <type -11>, min <type -11>, sec <type -11>)
 func (t <esc:0x1> <type 8>) .time.sec () <type -4>
 func (t <esc:0x1> <type 6>) Before (u <esc:0x1> <type 6>) <type -15>
 func (t <esc:0x1> <type 8>) .time.nsec () <type -3>
 func (t <esc:0x1> <type 8>) .time.setMono (m <type -4>)
 func (t <esc:0x1> <type 6>) Minute () <type -11>
 func (t <esc:0x1> <type 6>) AppendFormat (b <esc:0x12> <type 5>, layout <esc:0x1> <type -16>) <type 5>
 func (t <esc:0x1> <type 6>) Day () <type -11>
 func (t <esc:0x12> <type 6>) Add (d <type 7>) <type 6>
 func (t <esc:0x1> <type 6>) Format (layout <esc:0x1> <type -16>) <type -16>
 func (t <esc:0x1> <type 6>) String () <type -16>
 func (t <esc:0x1> <type 6>) Equal (u <esc:0x1> <type 6>) <type -15>
 func (t <esc:0x1> <type 6>) Sub (u <esc:0x1> <type 6>) <type 7>
 func (t <esc:0x32> <type 6>) .time.locabs () (name <type -16>, offset <type -11>, abs <type -8>)
 func (t <esc:0x12> <type 6>) In (loc <type 10>) <type 6>
 func (t <esc:0x12> <type 6>) UTC () <type 6>
 func (t <esc:0x1> <type 6>) Nanosecond () <type -11>
 func (t <esc:0x1> <type 6>) IsZero () <type -15>
 func (t <esc:0x1> <type 6>) .time.abs () <type -8>
 func (t <esc:0x1> <type 6>) Hour () <type -11>
 func (t <esc:0x1> <type 6>) Date () (year <type -11>, month <type 9>, day <type -11>)
 func (t <esc:0x1> <type 6>) GobEncode () (? <type 5>, ? <type -19>)
 func (t <esc:0x12> <type 6>) Location () <type 10>
 func (t <esc:0x1> <type 6>) Month () <type 9>
 func (t <esc:0x1> <type 6>) ISOWeek () (year <type -11>, week <type -11>)
 func (t <esc:0x1> <type 8>) UnmarshalJSON (data <esc:0x1> <type 5>) <type -19>
 func (t <esc:0x1> <type 8>) .time.addSec (d <type -4>)
 func (t <esc:0x1> <type 6>) Year () <type -11>
 func (t <esc:0x1> <type 6>) Second () <type -11>
 func (t <esc:0x1> <type 6>) Weekday () <type 20>
 func (t <esc:0x1> <type 6>) Unix () <type -4>
 func (t <esc:0x1> <type 6>) YearDay () <type -11>
type 7 "time.Duration" <type -4>
 func (d <type 7>) Round (m <type 7>) <type 7>
 func (d <type 7>) Truncate (m <type 7>) <type 7>
 func (d <type 7>) Hours () <type -10>
 func (d <type 7>) Minutes () <type -10>
 func (d <type 7>) Seconds () <type -10>
 func (d <type 7>) Nanoseconds () ($ret65 <type -4>)
 func (d <type 7>) String () <type -16>
type 8 *<type 6>
type 9 "time.Month" <type -11>
 func (m <type 9>) String () <type -16>
type 10 *<type 11>
type 11 "time.Location" <type 12>
 func (l <esc:0x1> <type 10>) .time.lookupName (name <esc:0x1> <type -16>, unix <type -4>) (offset <type -11>, ok <type -15>)
 func (l <esc:0x1> <type 10>) .time.firstZoneUsed () <type -15>
 func (l <esc:0x1> <type 10>) .time.lookupFirstZone () <type -11>
 func (l <esc:0x32> <type 10>) .time.lookup (sec <type -4>) (name <type -16>, offset <type -11>, start <type -4>, end <type -4>)
 func (l <esc:0x22> <type 10>) String () <type -16>
 func (l <esc:0x12> <type 10>) .time.get () <type 10>
type 12 struct { .time.name <type -16>; .time.zone <type 13>; .time.tx <type 16>; .time.cacheStart <type -4>; .time.cacheEnd <type -4>; .time.cacheZone <type 19>; }
type 13 [] <type 14>
type 14 ".time.zone" <type 15>
type 15 struct { .time.name <type -16>; .time.offset <type -11>; .time.isDST <type -15>; }
type 16 [] <type 17>
type 17 ".time.zoneTrans" <type 18>
type 18 struct { .time.when <type -4>; .time.index <type -5>; .time.isstd <type -15>; .time.isutc <type -15>; }
type 19 *<type 14>
type 20 "time.Weekday" <type -11>
 func (d <type 20>) String () <type -16>
type 21 struct { .time.wall <type -8>; .time.ext <type -4>; .time.loc <type 10>; }
type 22 "io.Reader" <type 23>
type 23 interface { Read (p <type 5>) (n <type -11>, err <type -19>); }
type 24 *<type 2>
type 25 "io.Writer" <type 26>
type 26 interface { Write (p <type 5>) (n <type -11>, err <type -19>); }
type 27 *<type 3>
type 28 struct { ? <type 1>; .compress/gzip.r <type 29>; .compress/gzip.decompressor <type 33>; .compress/gzip.digest <type -7>; .compress/gzip.size <type -7>; .compress/gzip.buf <type 37>; .compress/gzip.err <type -19>; .compress/gzip.multistream <type -15>; }
type 29 "compress/flate.Reader" <type 30>
type 30 interface { ? <type 22>; ? <type 31>; }
type 31 "io.ByteReader" <type 32>
type 32 interface { ReadByte () (? <type -20>, ? <type -19>); }
type 33 "io.ReadCloser" <type 34>
type 34 interface { ? <type 22>; ? <type 35>; }
type 35 "io.Closer" <type 36>
type 36 interface { Close () <type -19>; }
type 37 [512 ] <type -20>
type 38 struct { ? <type 1>; .compress/gzip.w <type 25>; .compress/gzip.level <type -11>; .compress/gzip.wroteHeader <type -15>; .compress/gzip.compressor <type 39>; .compress/gzip.digest <type -7>; .compress/gzip.size <type -7>; .compress/gzip.closed <type -15>; .compress/gzip.buf <type 84>; .compress/gzip.err <type -19>; }
type 39 *<type 40>
type 40 "compress/flate.Writer" <type 41>
 func (w <type 39>) Reset (dst <type 25>)
 func (w <type 39>) Close () <type -19>
 func (w <type 39>) Flush () <type -19>
 func (w <type 39>) Write (data <type 5>) (n <type -11>, err <type -19>)
type 41 struct { .compress/flate.d <type 42>; .compress/flate.dict <type 5>; }
type 42 ".compress/flate.compressor" <type 46>
 func (d <esc:0x1> <type 43>) .compress/flate.init (w <type 25>, level <type -11>) (err <type -19>)
 func (d <esc:0x1> <type 43>) .compress/flate.initDeflate ()
 func (d <esc:0x1> <type 43>) .compress/flate.fillStore (b <esc:0x1> <type 5>) <type -11>
 func (d <esc:0x1> <type 43>) .compress/flate.fillDeflate (b <esc:0x1> <type 5>) <type -11>
 func (d <esc:0x3a> <type 43>) .compress/flate.writeBlock (tokens <esc:0x1> <type 44>, index <type -11>) <type -19>
 func (d <esc:0x1> <type 43>) .compress/flate.reset (w <type 25>)
 func (d <esc:0x1> <type 43>) .compress/flate.findMatch (pos <type -11>, prevHead <type -11>, prevLength <type -11>, lookahead <type -11>) (length <type -11>, offset <type -11>, ok <type -15>)
 func (d <esc:0x9> <type 43>) .compress/flate.deflate ()
 func (d <esc:0x9> <type 43>) .compress/flate.store ()
 func (d <esc:0x3a> <type 43>) .compress/flate.writeStoredBlock (buf <type 5>) <type -19>
 func (d <type 43>) .compress/flate.close () <type -19>
 func (d <type 43>) .compress/flate.fillWindow (b <esc:0x1> <type 5>)
 func (d <esc:0x9> <type 43>) .compress/flate.storeHuff ()
 func (d <type 43>) .compress/flate.syncFlush () <type -19>
 func (d <esc:0x9> <type 43>) .compress/flate.encSpeed ()
 func (d <type 43>) .compress/flate.write (b <type 5>) (n <type -11>, err <type -19>)
type 43 *<type 42>
type 44 [] <type 45>
type 45 ".compress/flate.token" <type -7>
 func (t <type 45>) .compress/flate.length () <type -7>
 func (t <type 45>) .compress/flate.offset () <type -7>
 func (t <type 45>) .compress/flate.literal () <type -7>
type 46 struct { ? <type 47>; .compress/flate.w <type 49>; .compress/flate.bulkHasher <type 71>; .compress/flate.fill <type 73>; .compress/flate.step <type 74>; .compress/flate.sync <type -15>; .compress/flate.bestSpeed <type 75>; .compress/flate.chainHead <type -11>; .compress/flate.hashHead <type 81>; .compress/flate.hashPrev <type 82>; .compress/flate.hashOffset <type -11>; .compress/flate.index <type -11>; .compress/flate.window <type 5>; .compress/flate.windowEnd <type -11>; .compress/flate.blockStart <type -11>; .compress/flate.byteAvailable <type -15>; .compress/flate.tokens <type 44>; .compress/flate.length <type -11>; .compress/flate.offset <type -11>; .compress/flate.hash <type -7>; .compress/flate.maxInsertIndex <type -11>; .compress/flate.err <type -19>; .compress/flate.hashMatch <type 83>; }
type 47 ".compress/flate.compressionLevel" <type 48>
type 48 struct { .compress/flate.level <type -11>; .compress/flate.good <type -11>; .compress/flate.lazy <type -11>; .compress/flate.nice <type -11>; .compress/flate.chain <type -11>; .compress/flate.fastSkipHashing <type -11>; }
type 49 *<type 50>
type 50 ".compress/flate.huffmanBitWriter" <type 67>
 func (w <type 49>) .compress/flate.writeTokens (tokens <esc:0x1> <type 44>, leCodes <esc:0x1> <type 51>, oeCodes <esc:0x1> <type 51>)
 func (w <esc:0x9> <type 49>) .compress/flate.indexTokens (tokens <esc:0x1> <type 44>) (numLiterals <type -11>, numOffsets <type -11>)
 func (w <type 49>) .compress/flate.writeBlockDynamic (tokens <esc:0x1> <type 44>, eof <type -15>, input <type 5>)
 func (w <type 49>) .compress/flate.writeBlock (tokens <esc:0x1> <type 44>, eof <type -15>, input <type 5>)
 func (w <type 49>) .compress/flate.flush ()
 func (w <esc:0x1> <type 49>) .compress/flate.dynamicSize (litEnc <esc:0x1> <type 55>, offEnc <esc:0x1> <type 55>, extraBits <type -11>) (size <type -11>, numCodegens <type -11>)
 func (w <esc:0x9> <type 49>) .compress/flate.write (b <type 5>)
 func (w <type 49>) .compress/flate.writeBits (b <type -3>, nb <type -12>)
 func (w <type 49>) .compress/flate.writeStoredHeader (length <type -11>, isEof <type -15>)
 func (w <type 49>) .compress/flate.writeBytes (bytes <type 5>)
 func (w <esc:0x1> <type 49>) .compress/flate.reset (writer <type 25>)
 func (w <esc:0x1> <type 49>) .compress/flate.storedSize (in <esc:0x1> <type 5>) (? <type -11>, ? <type -15>)
 func (w <type 49>) .compress/flate.writeBlockHuff (eof <type -15>, input <type 5>)
 func (w <esc:0x1> <type 49>) .compress/flate.generateCodegen (numLiterals <type -11>, numOffsets <type -11>, litEnc <esc:0x1> <type 55>, offEnc <esc:0x1> <type 55>)
 func (w <esc:0x1> <type 49>) .compress/flate.fixedSize (extraBits <type -11>) <type -11>
 func (w <type 49>) .compress/flate.writeCode (c <type 52>)
 func (w <type 49>) .compress/flate.writeFixedHeader (isEof <type -15>)
 func (w <type 49>) .compress/flate.writeDynamicHeader (numLiterals <type -11>, numOffsets <type -11>, numCodegens <type -11>, isEof <type -15>)
type 51 [] <type 52>
type 52 ".compress/flate.hcode" <type 54>
 func (h <esc:0x1> <type 53>) .compress/flate.set (code <type -6>, length <type -6>)
type 53 *<type 52>
type 54 struct { .compress/flate.code <type -6>; .compress/flate.len <type -6>; }
type 55 *<type 56>
type 56 ".compress/flate.huffmanEncoder" <type 61>
 func (h <type 55>) .compress/flate.generate (freq <esc:0x1> <type 57>, maxBits <type -3>)
 func (h <type 55>) .compress/flate.assignEncodingAndSize (bitCount <esc:0x1> <type 57>, list <type 58>)
 func (h <esc:0x12> <type 55>) .compress/flate.bitCounts (list <esc:0x1> <type 58>, maxBits <type -3>) <type 57>
 func (h <esc:0x1> <type 55>) .compress/flate.bitLength (freq <esc:0x1> <type 57>) <type -11>
type 57 [] <type -3>
type 58 [] <type 59>
type 59 ".compress/flate.literalNode" <type 60>
type 60 struct { .compress/flate.literal <type -6>; .compress/flate.freq <type -3>; }
type 61 struct { .compress/flate.codes <type 51>; .compress/flate.freqcache <type 58>; .compress/flate.bitCount <type 62>; .compress/flate.lns <type 63>; .compress/flate.lfs <type 65>; }
type 62 [17 ] <type -3>
type 63 ".compress/flate.byLiteral" <type 58>
 func (s <esc:0x1> <type 63>) Swap (i <type -11>, j <type -11>)
 func (s <esc:0x1> <type 63>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 63>) Len () <type -11>
 func (s <type 64>) .compress/flate.sort (a <type 58>)
type 64 *<type 63>
type 65 ".compress/flate.byFreq" <type 58>
 func (s <esc:0x1> <type 65>) Swap (i <type -11>, j <type -11>)
 func (s <esc:0x1> <type 65>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 65>) Len () <type -11>
 func (s <type 66>) .compress/flate.sort (a <type 58>)
type 66 *<type 65>
type 67 struct { .compress/flate.writer <type 25>; .compress/flate.bits <type -8>; .compress/flate.nbits <type -12>; .compress/flate.bytes <type 68>; .compress/flate.codegenFreq <type 69>; .compress/flate.nbytes <type -11>; .compress/flate.literalFreq <type 57>; .compress/flate.offsetFreq <type 57>; .compress/flate.codegen <type 70>; .compress/flate.literalEncoding <type 55>; .compress/flate.offsetEncoding <type 55>; .compress/flate.codegenEncoding <type 55>; .compress/flate.err <type -19>; }
type 68 [248 ] <type -20>
type 69 [19 ] <type -3>
type 70 [] <type -5>
type 71 (? <type 5>, ? <type 72>)
type 72 [] <type -7>
type 73 (? <type 43>, ? <type 5>) <type -11>
type 74 (? <type 43>)
type 75 *<type 76>
type 76 ".compress/flate.deflateFast" <type 77>
 func (e <esc:0x1> <type 75>) .compress/flate.resetAll ()
 func (e <esc:0x1> <type 75>) .compress/flate.reset ()
 func (e <esc:0x1> <type 75>) .compress/flate.matchLen (s <type -3>, t <type -3>, src <esc:0x1> <type 5>) <type -3>
 func (e <esc:0x1> <type 75>) .compress/flate.encode (dst <esc:0x12> <type 44>, src <esc:0x1> <type 5>) <type 44>
type 77 struct { .compress/flate.table <type 78>; .compress/flate.prev <type 5>; .compress/flate.cur <type -3>; }
type 78 [16384 ] <type 79>
type 79 ".compress/flate.tableEntry" <type 80>
type 80 struct { .compress/flate.val <type -7>; .compress/flate.offset <type -3>; }
type 81 [131072 ] <type -7>
type 82 [32768 ] <type -7>
type 83 [257 ] <type -7>
type 84 [10 ] <type -20>
const BestCompression = 9 
const BestSpeed = 1 
const DefaultCompression = -1 
var ErrChecksum <type -19>
var ErrHeader <type -19>
const HuffmanOnly = -2 
func NewReader (r <type 22>) (? <type 24>, ? <type -19>)
func NewWriter (w <type 25>) <type 27>
func NewWriterLevel (w <type 25>, level <type -11>) (? <type 27>, ? <type -19>)
const NoCompression = 0 
checksum 2F52C4DFD880607B39F123F5B8274C7D1D64FCC6
                                                   .symtab .strtab .shstrtab .go_export                                                                                        @       C                                                   ÐC      0                           	                       D                                                          D      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ó                    `         @     @   v3;
package lzw
pkgpath compress/lzw
import bufio bufio "bufio"
import errors errors "errors"
import fmt fmt "fmt"
import io io "io"
init lzw compress..z2flzw..import bufio bufio..import bytes bytes..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 1 2 1 4 1 7 1 10 1 11 1 13 1 16 2 4 2 7 2 10 2 11 2 13 2 16 3 4 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 5 4 5 7 5 10 5 11 5 13 5 14 5 15 7 4 7 10 7 11 7 13 8 4 8 5 8 6 8 7 8 10 8 11 8 13 8 14 8 15 9 4 9 10 9 11 9 12 9 13 9 16 10 4 10 11 12 4 12 10 12 11 13 4 13 10 13 11 14 4 14 10 14 11 14 13 15 4 15 10 15 11 15 13 15 14
types 13 2 26 28 71 21 32 45 28 42 29 73 35 46
type 1 "Order" <type -11>
type 2 "io.Reader" <type 3>
type 3 interface { Read (p <type 4>) (n <type -11>, err <type -19>); }
type 4 [] <type -20>
type 5 "io.ReadCloser" <type 6>
type 6 interface { ? <type 2>; ? <type 7>; }
type 7 "io.Closer" <type 8>
type 8 interface { Close () <type -19>; }
type 9 "io.Writer" <type 10>
type 10 interface { Write (p <type 4>) (n <type -11>, err <type -19>); }
type 11 "io.WriteCloser" <type 12>
type 12 interface { ? <type 9>; ? <type 7>; }
const LSB <type 1> = 0 
const MSB <type 1> = 1 
func NewReader (r <type 2>, order <type 1>, litWidth <type -11>) <type 5>
func NewWriter (w <type 9>, order <type 1>, litWidth <type -11>) <type 11>
checksum 1256E74F6A92D35305B9F5C1F4AE9F8986ABDE9B
                                                 .symtab .strtab .shstrtab .go_export                                                                                        @       Ç                                                         0                           	                      8                                                          9      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                    Ø-         @     @   v3;
package zlib
pkgpath compress/zlib
import bufio bufio "bufio"
import flate compress/flate "compress/flate"
import binary encoding/binary "encoding/binary"
import errors errors "errors"
import fmt fmt "fmt"
import hash hash "hash"
import adler32 hash/adler32 "hash/adler32"
import io io "io"
init zlib compress..z2fzlib..import bufio bufio..import bytes bytes..import flate compress..z2fflate..import binary encoding..z2fbinary..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 1 2 1 6 1 9 1 12 1 13 1 15 1 18 2 6 2 9 2 12 2 13 2 15 2 18 3 1 3 2 3 5 3 6 3 7 3 8 3 9 3 10 3 11 3 12 3 13 3 14 3 15 3 16 3 17 3 18 4 6 4 9 4 11 4 12 4 13 4 14 4 15 4 18 5 6 5 7 5 8 5 9 5 10 5 11 5 12 5 13 5 14 5 15 5 16 5 17 5 18 7 6 7 9 7 12 7 13 7 15 7 16 7 17 9 6 9 12 9 13 9 15 10 6 10 7 10 8 10 9 10 12 10 13 10 15 10 16 10 17 11 6 11 12 11 13 11 14 11 15 11 18 12 6 12 13 14 6 14 12 14 13 15 6 15 12 15 13 16 6 16 12 16 13 16 15 17 6 17 12 17 13 17 15 17 16
types 65 3 28 293 28 71 21 32 45 28 42 30 73 18 68 284 19 237 79 1356 19 21 211 816 53 230 19 1864 21 127 19 82 19 454 21 21 48 86 187 24 288 19 285 19 498 26 24 21 34 21 45 22 19 391 114 27 47 84 28 27 25 32 55 30 117 24
type 1 "Resetter" <type 13>
type 2 "Writer" <type 14>
 func (z <esc:0x9> <type 12>) Reset (w <type 10>)
 func (z <type 12>) .compress/zlib.writeHeader () (err <type -19>)
 func (z <type 12>) Write (p <type 5>) (n <type -11>, err <type -19>)
 func (z <type 12>) Flush () <type -19>
 func (z <type 12>) Close () <type -19>
type 3 "io.Reader" <type 4>
type 4 interface { Read (p <type 5>) (n <type -11>, err <type -19>); }
type 5 [] <type -20>
type 6 "io.ReadCloser" <type 7>
type 7 interface { ? <type 3>; ? <type 8>; }
type 8 "io.Closer" <type 9>
type 9 interface { Close () <type -19>; }
type 10 "io.Writer" <type 11>
type 11 interface { Write (p <type 5>) (n <type -11>, err <type -19>); }
type 12 *<type 2>
type 13 interface { Reset (r <type 3>, dict <type 5>) <type -19>; }
type 14 struct { .compress/zlib.w <type 10>; .compress/zlib.level <type -11>; .compress/zlib.dict <type 5>; .compress/zlib.compressor <type 15>; .compress/zlib.digest <type 60>; .compress/zlib.err <type -19>; .compress/zlib.scratch <type 64>; .compress/zlib.wroteHeader <type -15>; }
type 15 *<type 16>
type 16 "compress/flate.Writer" <type 17>
 func (w <type 15>) Reset (dst <type 10>)
 func (w <type 15>) Close () <type -19>
 func (w <type 15>) Flush () <type -19>
 func (w <type 15>) Write (data <type 5>) (n <type -11>, err <type -19>)
type 17 struct { .compress/flate.d <type 18>; .compress/flate.dict <type 5>; }
type 18 ".compress/flate.compressor" <type 22>
 func (d <esc:0x1> <type 19>) .compress/flate.init (w <type 10>, level <type -11>) (err <type -19>)
 func (d <esc:0x1> <type 19>) .compress/flate.initDeflate ()
 func (d <esc:0x1> <type 19>) .compress/flate.fillStore (b <esc:0x1> <type 5>) <type -11>
 func (d <esc:0x1> <type 19>) .compress/flate.fillDeflate (b <esc:0x1> <type 5>) <type -11>
 func (d <esc:0x3a> <type 19>) .compress/flate.writeBlock (tokens <esc:0x1> <type 20>, index <type -11>) <type -19>
 func (d <esc:0x1> <type 19>) .compress/flate.reset (w <type 10>)
 func (d <esc:0x1> <type 19>) .compress/flate.findMatch (pos <type -11>, prevHead <type -11>, prevLength <type -11>, lookahead <type -11>) (length <type -11>, offset <type -11>, ok <type -15>)
 func (d <esc:0x9> <type 19>) .compress/flate.deflate ()
 func (d <esc:0x9> <type 19>) .compress/flate.store ()
 func (d <esc:0x3a> <type 19>) .compress/flate.writeStoredBlock (buf <type 5>) <type -19>
 func (d <type 19>) .compress/flate.close () <type -19>
 func (d <type 19>) .compress/flate.fillWindow (b <esc:0x1> <type 5>)
 func (d <esc:0x9> <type 19>) .compress/flate.storeHuff ()
 func (d <type 19>) .compress/flate.syncFlush () <type -19>
 func (d <esc:0x9> <type 19>) .compress/flate.encSpeed ()
 func (d <type 19>) .compress/flate.write (b <type 5>) (n <type -11>, err <type -19>)
type 19 *<type 18>
type 20 [] <type 21>
type 21 ".compress/flate.token" <type -7>
 func (t <type 21>) .compress/flate.length () <type -7>
 func (t <type 21>) .compress/flate.offset () <type -7>
 func (t <type 21>) .compress/flate.literal () <type -7>
type 22 struct { ? <type 23>; .compress/flate.w <type 25>; .compress/flate.bulkHasher <type 47>; .compress/flate.fill <type 49>; .compress/flate.step <type 50>; .compress/flate.sync <type -15>; .compress/flate.bestSpeed <type 51>; .compress/flate.chainHead <type -11>; .compress/flate.hashHead <type 57>; .compress/flate.hashPrev <type 58>; .compress/flate.hashOffset <type -11>; .compress/flate.index <type -11>; .compress/flate.window <type 5>; .compress/flate.windowEnd <type -11>; .compress/flate.blockStart <type -11>; .compress/flate.byteAvailable <type -15>; .compress/flate.tokens <type 20>; .compress/flate.length <type -11>; .compress/flate.offset <type -11>; .compress/flate.hash <type -7>; .compress/flate.maxInsertIndex <type -11>; .compress/flate.err <type -19>; .compress/flate.hashMatch <type 59>; }
type 23 ".compress/flate.compressionLevel" <type 24>
type 24 struct { .compress/flate.level <type -11>; .compress/flate.good <type -11>; .compress/flate.lazy <type -11>; .compress/flate.nice <type -11>; .compress/flate.chain <type -11>; .compress/flate.fastSkipHashing <type -11>; }
type 25 *<type 26>
type 26 ".compress/flate.huffmanBitWriter" <type 43>
 func (w <type 25>) .compress/flate.writeTokens (tokens <esc:0x1> <type 20>, leCodes <esc:0x1> <type 27>, oeCodes <esc:0x1> <type 27>)
 func (w <esc:0x9> <type 25>) .compress/flate.indexTokens (tokens <esc:0x1> <type 20>) (numLiterals <type -11>, numOffsets <type -11>)
 func (w <type 25>) .compress/flate.writeBlockDynamic (tokens <esc:0x1> <type 20>, eof <type -15>, input <type 5>)
 func (w <type 25>) .compress/flate.writeBlock (tokens <esc:0x1> <type 20>, eof <type -15>, input <type 5>)
 func (w <type 25>) .compress/flate.flush ()
 func (w <esc:0x1> <type 25>) .compress/flate.dynamicSize (litEnc <esc:0x1> <type 31>, offEnc <esc:0x1> <type 31>, extraBits <type -11>) (size <type -11>, numCodegens <type -11>)
 func (w <esc:0x9> <type 25>) .compress/flate.write (b <type 5>)
 func (w <type 25>) .compress/flate.writeBits (b <type -3>, nb <type -12>)
 func (w <type 25>) .compress/flate.writeStoredHeader (length <type -11>, isEof <type -15>)
 func (w <type 25>) .compress/flate.writeBytes (bytes <type 5>)
 func (w <esc:0x1> <type 25>) .compress/flate.reset (writer <type 10>)
 func (w <esc:0x1> <type 25>) .compress/flate.storedSize (in <esc:0x1> <type 5>) (? <type -11>, ? <type -15>)
 func (w <type 25>) .compress/flate.writeBlockHuff (eof <type -15>, input <type 5>)
 func (w <esc:0x1> <type 25>) .compress/flate.generateCodegen (numLiterals <type -11>, numOffsets <type -11>, litEnc <esc:0x1> <type 31>, offEnc <esc:0x1> <type 31>)
 func (w <esc:0x1> <type 25>) .compress/flate.fixedSize (extraBits <type -11>) <type -11>
 func (w <type 25>) .compress/flate.writeCode (c <type 28>)
 func (w <type 25>) .compress/flate.writeFixedHeader (isEof <type -15>)
 func (w <type 25>) .compress/flate.writeDynamicHeader (numLiterals <type -11>, numOffsets <type -11>, numCodegens <type -11>, isEof <type -15>)
type 27 [] <type 28>
type 28 ".compress/flate.hcode" <type 30>
 func (h <esc:0x1> <type 29>) .compress/flate.set (code <type -6>, length <type -6>)
type 29 *<type 28>
type 30 struct { .compress/flate.code <type -6>; .compress/flate.len <type -6>; }
type 31 *<type 32>
type 32 ".compress/flate.huffmanEncoder" <type 37>
 func (h <type 31>) .compress/flate.generate (freq <esc:0x1> <type 33>, maxBits <type -3>)
 func (h <type 31>) .compress/flate.assignEncodingAndSize (bitCount <esc:0x1> <type 33>, list <type 34>)
 func (h <esc:0x12> <type 31>) .compress/flate.bitCounts (list <esc:0x1> <type 34>, maxBits <type -3>) <type 33>
 func (h <esc:0x1> <type 31>) .compress/flate.bitLength (freq <esc:0x1> <type 33>) <type -11>
type 33 [] <type -3>
type 34 [] <type 35>
type 35 ".compress/flate.literalNode" <type 36>
type 36 struct { .compress/flate.literal <type -6>; .compress/flate.freq <type -3>; }
type 37 struct { .compress/flate.codes <type 27>; .compress/flate.freqcache <type 34>; .compress/flate.bitCount <type 38>; .compress/flate.lns <type 39>; .compress/flate.lfs <type 41>; }
type 38 [17 ] <type -3>
type 39 ".compress/flate.byLiteral" <type 34>
 func (s <esc:0x1> <type 39>) Swap (i <type -11>, j <type -11>)
 func (s <esc:0x1> <type 39>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 39>) Len () <type -11>
 func (s <type 40>) .compress/flate.sort (a <type 34>)
type 40 *<type 39>
type 41 ".compress/flate.byFreq" <type 34>
 func (s <esc:0x1> <type 41>) Swap (i <type -11>, j <type -11>)
 func (s <esc:0x1> <type 41>) Less (i <type -11>, j <type -11>) <type -15>
 func (s <esc:0x1> <type 41>) Len () <type -11>
 func (s <type 42>) .compress/flate.sort (a <type 34>)
type 42 *<type 41>
type 43 struct { .compress/flate.writer <type 10>; .compress/flate.bits <type -8>; .compress/flate.nbits <type -12>; .compress/flate.bytes <type 44>; .compress/flate.codegenFreq <type 45>; .compress/flate.nbytes <type -11>; .compress/flate.literalFreq <type 33>; .compress/flate.offsetFreq <type 33>; .compress/flate.codegen <type 46>; .compress/flate.literalEncoding <type 31>; .compress/flate.offsetEncoding <type 31>; .compress/flate.codegenEncoding <type 31>; .compress/flate.err <type -19>; }
type 44 [248 ] <type -20>
type 45 [19 ] <type -3>
type 46 [] <type -5>
type 47 (? <type 5>, ? <type 48>)
type 48 [] <type -7>
type 49 (? <type 19>, ? <type 5>) <type -11>
type 50 (? <type 19>)
type 51 *<type 52>
type 52 ".compress/flate.deflateFast" <type 53>
 func (e <esc:0x1> <type 51>) .compress/flate.resetAll ()
 func (e <esc:0x1> <type 51>) .compress/flate.reset ()
 func (e <esc:0x1> <type 51>) .compress/flate.matchLen (s <type -3>, t <type -3>, src <esc:0x1> <type 5>) <type -3>
 func (e <esc:0x1> <type 51>) .compress/flate.encode (dst <esc:0x12> <type 20>, src <esc:0x1> <type 5>) <type 20>
type 53 struct { .compress/flate.table <type 54>; .compress/flate.prev <type 5>; .compress/flate.cur <type -3>; }
type 54 [16384 ] <type 55>
type 55 ".compress/flate.tableEntry" <type 56>
type 56 struct { .compress/flate.val <type -7>; .compress/flate.offset <type -3>; }
type 57 [131072 ] <type -7>
type 58 [32768 ] <type -7>
type 59 [257 ] <type -7>
type 60 "hash.Hash32" <type 61>
type 61 interface { ? <type 62>; Sum32 () <type -7>; }
type 62 "hash.Hash" <type 63>
type 63 interface { ? <type 10>; BlockSize () <type -11>; Reset (); Size () <type -11>; Sum (b <type 5>) <type 5>; }
type 64 [4 ] <type -20>
const BestCompression = 9 
const BestSpeed = 1 
const DefaultCompression = -1 
var ErrChecksum <type -19>
var ErrDictionary <type -19>
var ErrHeader <type -19>
const HuffmanOnly = -2 
func NewReader (r <type 3>) (? <type 6>, ? <type -19>)
func NewReaderDict (r <type 3>, dict <type 5>) (? <type 6>, ? <type -19>)
func NewWriter (w <type 10>) <type 12>
func NewWriterLevel (w <type 10>, level <type -11>) (? <type 12>, ? <type -19>)
func NewWriterLevelDict (w <type 10>, level <type -11>, dict <type 5>) (? <type 12>, ? <type -19>)
const NoCompression = 0 
checksum 6292E6902F3563112E8643BDA9638E61F14D256D
                                                     .symtab .strtab .shstrtab .go_export                                                                                        @       ;-                                                   €-      0                           	                      °-                                                          ±-      &                                                                                                                                                                                                                                                                      Í   .   Á   ..  Î   heap.goxÏ   list.goxÐ  Èring.gox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ELF          ó                    è         @     @   v3;
package heap
pkgpath container/heap
import sort sort "sort"
init cpu internal..z2fcpu..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import unicode unicode..import
init_graph 1 0 1 2 1 3 1 4 1 5 1 6 2 0 2 3 4 0 4 2 4 3 5 0 5 2 5 3
types 6 2 28 69 33 121 21
type 1 "Interface" <type 2>
type 2 interface { ? <type 3>; Pop () <type 5>; Push (x <type 5>); }
type 3 "sort.Interface" <type 4>
type 4 interface { Len () <type -11>; Less (i <type -11>, j <type -11>) <type -15>; Swap (i <type -11>, j <type -11>); }
type 5 interface { }
func Fix (h <type 1>, i <type -11>)
func Init (h <type 1>)
func Pop (h <type 1>) <type 5>
func Push (h <type 1>, x <type 5>)
func Remove (h <type 1>, i <type -11>) <type 5>
checksum D5DB6CC68B7F2E9EAB2E098C53D5531D41CA3FDB
                                                       .symtab .strtab .shstrtab .go_export                                                                                        @       I                                                         0                           	                      À                                                          Á      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      ELF          ó                             @     @   v3;
package list
pkgpath container/list
types 8 3 120 1255 127 17 17 21 81
type 1 "Element" <type 3>
 func (e <esc:0x22> <type 4>) Next () <type 4>
 func (e <esc:0x22> <type 4>) Prev () <type 4>
type 2 "List" <type 7>
 func (l <type 5>) Init () <type 5>
 func (l <esc:0x1> <type 5>) Len () <type -11>
 func (l <esc:0x22> <type 5>) Front () <type 4>
 func (l <esc:0x22> <type 5>) Back () <type 4>
 func (l <type 5>) .container/list.lazyInit ()
 func (l <type 5>) .container/list.insert (e <type 4>, at <type 4>) <type 4>
 func (l <type 5>) .container/list.insertValue (v <type 6>, at <type 4>) <type 4>
 func (l <esc:0x1> <type 5>) .container/list.remove (e <esc:0x1a> <type 4>) <type 4>
 func (l <esc:0x1> <type 5>) .container/list.move (e <type 4>, at <type 4>) <type 4>
 func (l <esc:0x1> <type 5>) Remove (e <esc:0x2a> <type 4>) <type 6>
 func (l <type 5>) PushFront (v <type 6>) <type 4>
 func (l <type 5>) PushBack (v <type 6>) <type 4>
 func (l <type 5>) InsertBefore (v <type 6>, mark <esc:0x9> <type 4>) <type 4>
 func (l <type 5>) InsertAfter (v <type 6>, mark <type 4>) <type 4>
 func (l <type 5>) MoveToFront (e <type 4>)
 func (l <esc:0x9> <type 5>) MoveToBack (e <type 4>)
 func (l <esc:0x1> <type 5>) MoveBefore (e <type 4>, mark <esc:0x9> <type 4>)
 func (l <esc:0x1> <type 5>) MoveAfter (e <type 4>, mark <type 4>)
 func (l <type 5>) PushBackList (other <esc:0x9> <type 5>)
 func (l <type 5>) PushFrontList (other <esc:0x9> <type 5>)
type 3 struct { .container/list.next <type 4>; .container/list.prev <type 4>; .container/list.list <type 5>; Value <type 6>; }
type 4 *<type 1>
type 5 *<type 2>
type 6 interface { }
type 7 struct { .container/list.root <type 1>; .container/list.len <type -11>; }
func New () <type 5>
checksum D56CF52B87EB500C77BB8361B8882306499CE474
                                                .symtab .strtab .shstrtab .go_export                                                                                        @       ø                                                   8      0                           	                      h                                                          i      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                    @         @     @   v3;
package ring
pkgpath container/ring
types 6 2 373 17 96 21 20
type 1 "Ring" <type 3>
 func (r <type 2>) .container/ring.init () <type 2>
 func (r <type 2>) Next () <type 2>
 func (r <type 2>) Prev () <type 2>
 func (r <type 2>) Move (n <type -11>) <type 2>
 func (r <type 2>) Link (s <type 2>) <type 2>
 func (r <type 2>) Unlink (n <type -11>) <type 2>
 func (r <type 2>) Len () <type -11>
 func (r <type 2>) Do (f <esc:0x1> <type 5>)
type 2 *<type 1>
type 3 struct { .container/ring.next <type 2>; .container/ring.prev <type 2>; Value <type 4>; }
type 4 interface { }
type 5 (? <type 4>)
func New (n <type -11>) <type 2>
checksum 8A35E037E91C77C6986726C312EF5035421A9EB7
                                                    .symtab .strtab .shstrtab .go_export                                                                                        @       ¤                                                   è      0                           	                                                                                      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                    8         @     @   v3;
package context
pkgpath context
import errors errors "errors"
import fmt fmt "fmt"
import reflect reflect "reflect"
import sync sync "sync"
import time time "time"
init context context..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 1 11 1 12 1 13 1 14 3 2 3 5 3 8 3 9 3 11 3 12 3 13 5 2 5 8 5 9 5 11 6 2 6 3 6 4 6 5 6 8 6 9 6 11 6 12 6 13 7 2 7 8 7 9 7 10 7 11 7 14 8 2 8 9 10 2 10 8 10 9 11 2 11 8 11 9 12 2 12 8 12 9 12 11 13 2 13 8 13 9 13 11 13 12
types 25 3 29 26 10 140 3231 344 17 21 71 19 525 165 21 31 91 21 36 112 19 75 83 26 19 22
type 1 "CancelFunc" <type 3>
type 2 "Context" <type 4>
type 3 ()
type 4 interface { Deadline () (deadline <type 5>, ok <type -15>); Done () <type 22>; Err () <type -19>; Value (key <type 24>) <type 24>; }
type 5 "time.Time" <type 21>
 func (t <esc:0x12> <type 5>) Round (d <type 6>) <type 5>
 func (t <esc:0x12> <type 5>) Truncate (d <type 6>) <type 5>
 func (t <esc:0x1> <type 7>) UnmarshalText (data <esc:0x1> <type 8>) <type -19>
 func (t <esc:0x1> <type 7>) UnmarshalBinary (data <esc:0x1> <type 8>) <type -19>
 func (t <esc:0x12> <type 5>) Local () <type 5>
 func (t <esc:0x1> <type 5>) MarshalJSON () (? <type 8>, ? <type -19>)
 func (t <esc:0x1> <type 5>) .time.date (full <type -15>) (year <type -11>, month <type 9>, day <type -11>, yday <type -11>)
 func (t <type 5>) AddDate (years <type -11>, months <type -11>, days <type -11>) <type 5>
 func (t <esc:0x1> <type 7>) .time.mono () <type -4>
 func (t <esc:0x1> <type 5>) MarshalText () (? <type 8>, ? <type -19>)
 func (t <esc:0x1> <type 7>) .time.stripMono ()
 func (t <esc:0x32> <type 5>) Zone () (name <type -16>, offset <type -11>)
 func (t <esc:0x1> <type 7>) .time.setLoc (loc <type 10>)
 func (t <esc:0x1> <type 7>) .time.unixSec () <type -4>
 func (t <esc:0x1> <type 7>) GobDecode (data <esc:0x1> <type 8>) <type -19>
 func (t <esc:0x1> <type 5>) UnixNano () <type -4>
 func (t <esc:0x1> <type 5>) After (u <esc:0x1> <type 5>) <type -15>
 func (t <esc:0x1> <type 5>) MarshalBinary () (? <type 8>, ? <type -19>)
 func (t <esc:0x1> <type 5>) Clock () (hour <type -11>, min <type -11>, sec <type -11>)
 func (t <esc:0x1> <type 7>) .time.sec () <type -4>
 func (t <esc:0x1> <type 5>) Before (u <esc:0x1> <type 5>) <type -15>
 func (t <esc:0x1> <type 7>) .time.nsec () <type -3>
 func (t <esc:0x1> <type 7>) .time.setMono (m <type -4>)
 func (t <esc:0x1> <type 5>) Minute () <type -11>
 func (t <esc:0x1> <type 5>) AppendFormat (b <esc:0x12> <type 8>, layout <esc:0x1> <type -16>) <type 8>
 func (t <esc:0x1> <type 5>) Day () <type -11>
 func (t <esc:0x12> <type 5>) Add (d <type 6>) <type 5>
 func (t <esc:0x1> <type 5>) Format (layout <esc:0x1> <type -16>) <type -16>
 func (t <esc:0x1> <type 5>) String () <type -16>
 func (t <esc:0x1> <type 5>) Equal (u <esc:0x1> <type 5>) <type -15>
 func (t <esc:0x1> <type 5>) Sub (u <esc:0x1> <type 5>) <type 6>
 func (t <esc:0x32> <type 5>) .time.locabs () (name <type -16>, offset <type -11>, abs <type -8>)
 func (t <esc:0x12> <type 5>) In (loc <type 10>) <type 5>
 func (t <esc:0x12> <type 5>) UTC () <type 5>
 func (t <esc:0x1> <type 5>) Nanosecond () <type -11>
 func (t <esc:0x1> <type 5>) IsZero () <type -15>
 func (t <esc:0x1> <type 5>) .time.abs () <type -8>
 func (t <esc:0x1> <type 5>) Hour () <type -11>
 func (t <esc:0x1> <type 5>) Date () (year <type -11>, month <type 9>, day <type -11>)
 func (t <esc:0x1> <type 5>) GobEncode () (? <type 8>, ? <type -19>)
 func (t <esc:0x12> <type 5>) Location () <type 10>
 func (t <esc:0x1> <type 5>) Month () <type 9>
 func (t <esc:0x1> <type 5>) ISOWeek () (year <type -11>, week <type -11>)
 func (t <esc:0x1> <type 7>) UnmarshalJSON (data <esc:0x1> <type 8>) <type -19>
 func (t <esc:0x1> <type 7>) .time.addSec (d <type -4>)
 func (t <esc:0x1> <type 5>) Year () <type -11>
 func (t <esc:0x1> <type 5>) Second () <type -11>
 func (t <esc:0x1> <type 5>) Weekday () <type 20>
 func (t <esc:0x1> <type 5>) Unix () <type -4>
 func (t <esc:0x1> <type 5>) YearDay () <type -11>
type 6 "time.Duration" <type -4>
 func (d <type 6>) Round (m <type 6>) <type 6>
 func (d <type 6>) Truncate (m <type 6>) <type 6>
 func (d <type 6>) Hours () <type -10>
 func (d <type 6>) Minutes () <type -10>
 func (d <type 6>) Seconds () <type -10>
 func (d <type 6>) Nanoseconds () ($ret65 <type -4>)
 func (d <type 6>) String () <type -16>
type 7 *<type 5>
type 8 [] <type -20>
type 9 "time.Month" <type -11>
 func (m <type 9>) String () <type -16>
type 10 *<type 11>
type 11 "time.Location" <type 12>
 func (l <esc:0x1> <type 10>) .time.lookupName (name <esc:0x1> <type -16>, unix <type -4>) (offset <type -11>, ok <type -15>)
 func (l <esc:0x1> <type 10>) .time.firstZoneUsed () <type -15>
 func (l <esc:0x1> <type 10>) .time.lookupFirstZone () <type -11>
 func (l <esc:0x32> <type 10>) .time.lookup (sec <type -4>) (name <type -16>, offset <type -11>, start <type -4>, end <type -4>)
 func (l <esc:0x22> <type 10>) String () <type -16>
 func (l <esc:0x12> <type 10>) .time.get () <type 10>
type 12 struct { .time.name <type -16>; .time.zone <type 13>; .time.tx <type 16>; .time.cacheStart <type -4>; .time.cacheEnd <type -4>; .time.cacheZone <type 19>; }
type 13 [] <type 14>
type 14 ".time.zone" <type 15>
type 15 struct { .time.name <type -16>; .time.offset <type -11>; .time.isDST <type -15>; }
type 16 [] <type 17>
type 17 ".time.zoneTrans" <type 18>
type 18 struct { .time.when <type -4>; .time.index <type -5>; .time.isstd <type -15>; .time.isutc <type -15>; }
type 19 *<type 14>
type 20 "time.Weekday" <type -11>
 func (d <type 20>) String () <type -16>
type 21 struct { .time.wall <type -8>; .time.ext <type -4>; .time.loc <type 10>; }
type 22 chan <- <type 23>
type 23 struct { }
type 24 interface { }
func Background () <type 2>
var Canceled <type -19>
var DeadlineExceeded <type -19>
func TODO () <type 2>
func WithCancel (parent <type 2>) (ctx <type 2>, cancel <type 1>)
func WithDeadline (parent <type 2>, d <type 5>) (? <type 2>, ? <type 1>)
func WithTimeout (parent <type 2>, timeout <type 6>) (? <type 2>, ? <type 1>)
func WithValue (parent <type 2>, key <type 24>, val <type 24>) <type 2>
checksum 794497BE0834E42D0AD19EFBF0E42F7384D945FD
                                                       .symtab .strtab .shstrtab .go_export                                                                                        @       ™                                                   à      0                           	                                                                                      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Ò   .   Á   ..  Ó   aes.gox Ô   
cipher.gox  Õ   des.gox Ö   dsa.gox ×   	ecdsa.gox   Ø   elliptic.goxÙ   hmac.goxÚ   md5.gox Û   rand.goxÜ   rc4.gox Ý   rsa.gox Þ   sha1.goxß   
sha256.gox  à   
sha512.gox  á   
subtle.gox  â   tls.gox ã   x509å  Äx509.gox                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ELF          ó                    À         @     @   v3;
package aes
pkgpath crypto/aes
import cipher crypto/cipher "crypto/cipher"
import subtle crypto/internal/subtle "crypto/internal/subtle"
import binary encoding/binary "encoding/binary"
import strconv strconv "strconv"
init cipher crypto..z2fcipher..import binary encoding..z2fbinary..import cpu internal..z2fcpu..import io io..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 3 2 3 5 3 6 3 8 4 2 4 5 4 6 4 7 4 8 4 9 5 2 5 6 7 2 7 5 7 6 8 2 8 5 8 6
types 5 2 72 21 38 122
type 1 "KeySizeError" <type -11>
 func (k <type 1>) Error () <type -16>
type 2 [] <type -20>
type 3 "crypto/cipher.Block" <type 4>
type 4 interface { BlockSize () <type -11>; Decrypt (dst <type 2>, src <type 2>); Encrypt (dst <type 2>, src <type 2>); }
const BlockSize = 16 
func NewCipher (key <esc:0x1> <type 2>) (? <type 3>, ? <type -19>)
checksum F3B766B6DAA785D95F4F35B248961AC9B92BAB09
                                                     .symtab .strtab .shstrtab .go_export                                                                                        @       #                                                   h      0                           	                      ˜                                                          ™      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                              @     @   v3;
package cipher
pkgpath crypto/cipher
import subtle crypto/internal/subtle "crypto/internal/subtle"
import subtle crypto/subtle "crypto/subtle"
import binary encoding/binary "encoding/binary"
import errors errors "errors"
import io io "io"
import runtime runtime "runtime"
import unsafe unsafe "unsafe"
init cipher crypto..z2fcipher..import binary encoding..z2fbinary..import cpu internal..z2fcpu..import io io..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 3 2 3 5 3 6 3 8 4 2 4 5 4 6 4 7 4 8 4 9 5 2 5 6 7 2 7 5 7 6 8 2 8 5 8 6
types 18 7 23 24 29 26 102 142 271 21 122 89 65 44 30 72 60 30 73
type 1 "AEAD" <type 7>
type 2 "Block" <type 9>
type 3 "BlockMode" <type 10>
type 4 "Stream" <type 11>
type 5 "StreamReader" <type 12>
 func (r <type 5>) Read (dst <type 8>) (n <type -11>, err <type -19>)
type 6 "StreamWriter" <type 15>
 func (w <type 6>) Write (src <type 8>) (n <type -11>, err <type -19>)
 func (w <type 6>) Close () <type -19>
type 7 interface { NonceSize () <type -11>; Open (dst <type 8>, nonce <type 8>, ciphertext <type 8>, additionalData <type 8>) (? <type 8>, ? <type -19>); Overhead () <type -11>; Seal (dst <type 8>, nonce <type 8>, plaintext <type 8>, additionalData <type 8>) <type 8>; }
type 8 [] <type -20>
type 9 interface { BlockSize () <type -11>; Decrypt (dst <type 8>, src <type 8>); Encrypt (dst <type 8>, src <type 8>); }
type 10 interface { BlockSize () <type -11>; CryptBlocks (dst <type 8>, src <type 8>); }
type 11 interface { XORKeyStream (dst <type 8>, src <type 8>); }
type 12 struct { S <type 4>; R <type 13>; }
type 13 "io.Reader" <type 14>
type 14 interface { Read (p <type 8>) (n <type -11>, err <type -19>); }
type 15 struct { S <type 4>; W <type 16>; Err <type -19>; }
type 16 "io.Writer" <type 17>
type 17 interface { Write (p <type 8>) (n <type -11>, err <type -19>); }
func NewCBCDecrypter (b <type 2>, iv <type 8>) <type 3>
func NewCBCEncrypter (b <type 2>, iv <type 8>) <type 3>
func NewCFBDecrypter (block <type 2>, iv <esc:0x1> <type 8>) <type 4>
func NewCFBEncrypter (block <type 2>, iv <esc:0x1> <type 8>) <type 4>
func NewCTR (block <type 2>, iv <type 8>) <type 4>
func NewGCM (cipher <type 2>) (? <type 1>, ? <type -19>)
func NewGCMWithNonceSize (cipher <type 2>, size <type -11>) (? <type 1>, ? <type -19>)
func NewGCMWithTagSize (cipher <type 2>, tagSize <type -11>) (? <type 1>, ? <type -19>)
func NewOFB (b <type 2>, iv <esc:0x1> <type 8>) <type 4>
checksum 77532DA1FECC7CDCB290F9C02C61E1EE0D7C8293
                                                     .symtab .strtab .shstrtab .go_export                                                                                        @       c
                                                   ¨
      0                           	                      Ø
                                                          Ù
      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                    P         @     @   v3;
package des
pkgpath crypto/des
import cipher crypto/cipher "crypto/cipher"
import subtle crypto/internal/subtle "crypto/internal/subtle"
import binary encoding/binary "encoding/binary"
import strconv strconv "strconv"
init des crypto..z2fdes..import cipher crypto..z2fcipher..import binary encoding..z2fbinary..import cpu internal..z2fcpu..import io io..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 1 2 1 3 1 4 1 5 1 6 1 7 1 8 1 9 1 10 2 3 2 4 2 5 2 6 2 7 2 8 2 9 2 10 4 3 4 6 4 7 4 9 5 3 5 6 5 7 5 8 5 9 5 10 6 3 6 7 8 3 8 6 8 7 9 3 9 6 9 7
types 5 2 72 21 38 122
type 1 "KeySizeError" <type -11>
 func (k <type 1>) Error () <type -16>
type 2 [] <type -20>
type 3 "crypto/cipher.Block" <type 4>
type 4 interface { BlockSize () <type -11>; Decrypt (dst <type 2>, src <type 2>); Encrypt (dst <type 2>, src <type 2>); }
const BlockSize = 8 
func NewCipher (key <esc:0x1> <type 2>) (? <type 3>, ? <type -19>)
func NewTripleDESCipher (key <esc:0x1> <type 2>) (? <type 3>, ? <type -19>)
checksum 286210C76BF81707F3711304F5E00C377FB2E9E5
                                                   .symtab .strtab .shstrtab .go_export                                                                                        @       µ                                                   ø      0                           	                      (                                                          )      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ELF          ó                     8         @     @   v3;
package dsa
pkgpath crypto/dsa
import randutil crypto/internal/randutil "crypto/internal/randutil"
import errors errors "errors"
import io io "io"
import big math/big "math/big"
indirectimport fmt fmt
indirectimport rand math/rand
init dsa crypto..z2fdsa..import bytes bytes..import randutil crypto..z2finternal..z2frandutil..import binary encoding..z2fbinary..import fmt fmt..import cpu internal..z2fcpu..import poll internal..z2fpoll..import testlog internal..z2ftestlog..import io io..import big math..z2fbig..import rand math..z2frand..import os os..import reflect reflect..import runtime runtime..import sys runtime..z2finternal..z2fsys..import strconv strconv..import sync sync..import syscall syscall..import time time..import unicode unicode..import
init_graph 0 1 0 2 0 3 0 4 0 5 0 6 0 7 0 8 0 9 0 10 0 11 0 12 0 13 0 14 0 15 0 16 0 17 0 18 0 19 1 5 1 8 1 13 1 14 1 16 1 19 2 5 2 8 2 13 2 14 2 16 3 5 3 8 3 12 3 13 3 14 3 15 3 16 3 19 4 5 4 6 4 7 4 8 4 11 4 12 4 13 4 14 4 15 4 16 4 17 4 18 4 19 6 5 6 8 6 13 6 14 6 16 6 17 6 18 8 5 8 13 8 14 8 16 9 1 9 3 9 4 9 5 9 6 9 7 9 8 9 10 9 11 9 12 9 13 9 14 9 15 9 16 9 17 9 18 9 19 10 5 10 13 10 14 10 16 11 5 11 6 11 7 11 8 11 13 11 14 11 16 11 17 11 18 12 5 12 13 12 14 12 15 12 16 12 19 13 5 13 14 15 5 15 13 15 14 16 5 16 13 16 14 17 5 17 13 17 14 17 16 18 5 18 13 18 14 18 16 18 17
types 41 5 35 30 30 29 17 28 71 21 17 58 19 5175 21 35 30 194 35 61 34 64 19 1020 37 22 131 37 65 39 56 34 293 34 70 4122 21 38 102 44 44 18
type 1 "ParameterSizes" <type -11>
type 2 "Parameters" <type 10>
type 3 "PrivateKey" <type 38>
type 4 "PublicKey" <type 39>
type 5 *<type 3>
type 6 "io.Reader" <type 7>
type 7 interface { Read (p <type 8>) (n <type -11>, err <type -19>); }
type 8 [] <type -20>
type 9 *<type 2>
type 10 struct { P <type 11>; Q <type 11>; G <type 11>; }
type 11 *<type 12>
type 12 "math/big.Int" <type 33>
 func (x <esc:0x9> <type 11>) ProbablyPrime (n <type -11>) <type -15>
 func (x <esc:0x1> <type 11>) MarshalJSON () (? <type 8>, ? <type -19>)
 func (z <esc:0x1a> <type 11>) Exp (x <esc:0x9> <type 11>, y <esc:0x1> <type 11>, m <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) Cmp (y <esc:0x1> <type 11>) (r <type -11>)
 func (z <esc:0x1a> <type 11>) Quo (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) IsInt64 () <type -15>
 func (z <esc:0x1a> <type 11>) ModSqrt (x <esc:0x9> <type 11>, p <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Rsh (x <esc:0x1> <type 11>, n <type -12>) <type 11>
 func (x <esc:0x1> <type 11>) Int64 () <type -4>
 func (z <esc:0x1a> <type 11>) SetBytes (buf <esc:0x1> <type 8>) <type 11>
 func (z <esc:0x1a> <type 11>) .math/big.modSqrtTonelliShanks (x <esc:0x9> <type 11>, p <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Mod (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) SetInt64 (x <type -4>) <type 11>
 func (z <esc:0x1a> <type 11>) SetUint64 (x <type -8>) <type 11>
 func (z <esc:0x1a> <type 11>) Set (x <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) ModInverse (g <esc:0x1> <type 11>, n <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x22> <type 11>) Bits () <type 13>
 func (z <esc:0x1a> <type 11>) Add (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) .math/big.modSqrt3Mod4Prime (x <esc:0x9> <type 11>, p <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) Format (s <type 15>, ch <type -21>)
 func (z <esc:0x1a> <type 11>) .math/big.scan (r <type 17>, base <type -11>) (? <type 11>, ? <type -11>, ? <type -19>)
 func (z <esc:0x1a> <type 11>) SetString (s <type -16>, base <type -11>) (? <type 11>, ? <type -15>)
 func (z <esc:0x1a> <type 11>) Mul (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x12> <type 11>) SetBits (abs <type 13>) <type 11>
 func (x <esc:0x1> <type 11>) Sign () <type -11>
 func (z <esc:0x1a> <type 11>) MulRange (a <type -4>, b <type -4>) <type 11>
 func (x <esc:0x1> <type 11>) MarshalText () (text <type 8>, err <type -19>)
 func (z <esc:0x1a> <type 11>) Abs (x <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Neg (x <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) .math/big.setFromScanner (r <type 17>, base <type -11>) (? <type 11>, ? <type -15>)
 func (z <esc:0x1a> <type 11>) And (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Sub (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) CmpAbs (y <esc:0x1> <type 11>) <type -11>
 func (z <esc:0x1a> <type 11>) Div (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Rem (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) IsUint64 () <type -15>
 func (z <esc:0x1a> <type 11>) DivMod (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>, m <esc:0x8a> <type 11>) (? <type 11>, ? <type 11>)
 func (z <esc:0x1a> <type 11>) Binomial (n <type -4>, k <type -4>) <type 11>
 func (x <esc:0x1> <type 11>) Uint64 () <type -8>
 func (x <esc:0x1> <type 11>) BitLen () <type -11>
 func (z <esc:0x1a> <type 11>) GCD (x <esc:0x9> <type 11>, y <esc:0x9> <type 11>, a <esc:0x1> <type 11>, b <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) Bit (i <type -11>) <type -12>
 func (z <esc:0x1a> <type 11>) Or (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x12> <type 11>) .math/big.lehmerGCD (x <esc:0x1> <type 11>, y <esc:0x9> <type 11>, a <esc:0x1> <type 11>, b <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Rand (rnd <esc:0x9> <type 21>, n <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Xor (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Sqrt (x <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) .math/big.modSqrt5Mod8Prime (x <esc:0x1> <type 11>, p <esc:0x1> <type 11>) <type 11>
 func (z <esc:0x1a> <type 11>) Lsh (x <esc:0x1> <type 11>, n <type -12>) <type 11>
 func (z <esc:0x1a> <type 11>) SetBit (x <esc:0x1> <type 11>, i <type -11>, b <type -12>) <type 11>
 func (z <esc:0x1a> <type 11>) AndNot (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) Bytes () <type 8>
 func (z <esc:0x1a> <type 11>) Not (x <esc:0x1> <type 11>) <type 11>
 func (x <esc:0x1> <type 11>) GobEncode () (? <type 8>, ? <type -19>)
 func (x <esc:0x1> <type 11>) Append (buf <esc:0x12> <type 8>, base <type -11>) <type 8>
 func (x <esc:0x1> <type 11>) String () <type -16>
 func (x <esc:0x1> <type 11>) Text (base <type -11>) <type -16>
 func (z <esc:0x9> <type 11>) Scan (s <type 30>, ch <type -21>) <type -19>
 func (z <esc:0x9> <type 11>) UnmarshalJSON (text <type 8>) <type -19>
 func (z <esc:0x1a> <type 11>) QuoRem (x <esc:0x1> <type 11>, y <esc:0x1> <type 11>, r <esc:0x8a> <type 11>) (? <type 11>, ? <type 11>)
 func (z <esc:0x9> <type 11>) GobDecode (buf <esc:0x1> <type 8>) <type -19>
 func (z <esc:0x9> <type 11>) UnmarshalText (text <type 8>) <type -19>
type 13 [] <type 14>
type 14 "math/big.Word" <type -12>
type 15 "fmt.State" <type 16>
type 16 interface { Flag (c <type -11>) <type -15>; Precision () (prec <type -11>, ok <type -15>); Width () (wid <type -11>, ok <type -15>); Write (b <type 8>) (n <type -11>, err <type -19>); }
type 17 "io.ByteScanner" <type 18>
type 18 interface { ? <type 19>; UnreadByte () <type -19>; }
type 19 "io.ByteReader" <type 20>
type 20 interface { ReadByte () (? <type -20>, ? <type -19>); }
type 21 *<type 22>
type 22 "math/rand.Rand" <type 25>
 func (r <esc:0x9> <type 21>) Intn (n <type -11>) <type -11>
 func (r <esc:0x9> <type 21>) Int31n (n <type -3>) <type -3>
 func (r <type 21>) Read (p <esc:0x1> <type 8>) (n <type -11>, err <type -19>)
 func (r <esc:0x9> <type 21>) Int31 () <type -3>
 func (r <esc:0x9> <type 21>) Shuffle (n <type -11>, swap <esc:0x1> <type 23>)
 func (r <esc:0x9> <type 21>) Uint32 () <type -7>
 func (r <esc:0x9> <type 21>) Float32 () <type -9>
 func (r <esc:0x9> <type 21>) .math/rand.int31n (n <type -3>) <type -3>
 func (r <esc:0x9> <type 21>) Uint64 () <type -8>
 func (r <esc:0x9> <type 21>) Perm (n <type -11>) <type 24>
 func (r <esc:0x9> <type 21>) ExpFloat64 () <type -10>
 func (r <esc:0x9> <type 21>) NormFloat64 () <type -10>
 func (r <esc:0x9> <type 21>) Seed (seed <type -4>)
 func (r <esc:0x9> <type 21>) Int63 () <type -4>
 func (r <esc:0x9> <type 21>) Float64 () <type -10>
 func (r <esc:0x9> <type 21>) Int63n (n <type -4>) <type -4>
 func (r <esc:0x9> <type 21>) Int () <type -11>
type 23 (i <type -11>, j <type -11>)
type 24 [] <type -11>
type 25 struct { .math/rand.src <type 26>; .math/rand.s64 <type 28>; .math/rand.readVal <type -4>; .math/rand.readPos <type -1>; }
type 26 "math/rand.Source" <type 27>
type 27 interface { Int63 () <type -4>; Seed (seed <type -4>); }
type 28 "math/rand.Source64" <type 29>
type 29 interface { ? <type 26>; Uint64 () <type -8>; }
type 30 "fmt.ScanState" <type 31>
type 31 interface { Read (buf <type 8>) (n <type -11>, err <type -19>); ReadRune () (r <type -21>, size <type -11>, err <type -19>); SkipSpace (); Token (skipSpace <type -15>, f <type 32>) (token <type 8>, err <type -19>); UnreadRune () <type -19>; Width () (wid <type -11>, ok <type -15>); }
type 32 (? <type -21>) <type -15>
type 33 struct { .math/big.neg <type -15>; .math/big.abs <type 34>; }
type 34 ".math/big.nat" <type 13>
 func (n <esc:0x1> <type 34>) .math/big.probablyPrimeMillerRabin (reps <type -11>, force2 <type -15>) <type -15>
 func (z <esc:0x12> <type 34>) .math/big.scan (r <type 17>, base <type -11>, fracOk <type -15>) (res <type 34>, b <type -11>, count <type -11>, err <type -19>)
 func (z <type 34>) .math/big.sqrt (x <esc:0x1> <type 34>) <type 34>
 func (z <esc:0x1> <type 34>) .math/big.bytes (buf <esc:0x1> <type 8>) (i <type -11>)
 func (z <esc:0x12> <type 34>) .math/big.expNNMontgomery (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>, m <esc:0x1> <type 34>) <type 34>
 func (z <type 34>) .math/big.expNNWindowed (x <type 34>, y <esc:0x1> <type 34>, m <esc:0x1> <type 34>) <type 34>
 func (z <type 34>) .math/big.expNN (x <type 34>, y <esc:0x1> <type 34>, m <esc:0x1> <type 34>) <type 34>
 func (z <type 34>) .math/big.expWW (x <type 14>, y <type 14>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.montgomery (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>, m <esc:0x1> <type 34>, k <type 14>, n <type -11>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.shr (x <esc:0x1> <type 34>, s <type -12>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.norm () <type 34>
 func (q <esc:0x1> <type 34>) .math/big.convertWords (s <esc:0x1> <type 8>, b <type 14>, ndigits <type -11>, bb <type 14>, table <esc:0x1> <type 35>)
 func (z <type 34>) .math/big.add (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.setBytes (buf <esc:0x1> <type 8>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.random (rand <esc:0x9> <type 21>, limit <esc:0x1> <type 34>, n <type -11>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.set (x <esc:0x1> <type 34>) <type 34>
 func (x <esc:0x1> <type 34>) .math/big.utoa (base <type -11>) <type 8>
 func (z <esc:0x12> <type 34>) .math/big.setBit (x <esc:0x1> <type 34>, i <type -12>, b <type -12>) <type 34>
 func (z <type 34>) .math/big.mulRange (a <type -8>, b <type -8>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.make (n <type -11>) <type 34>
 func (n <type 34>) .math/big.probablyPrimeLucas () <type -15>
 func (z <esc:0x12> <type 34>) .math/big.setWord (x <type 14>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.divW (x <esc:0x1> <type 34>, y <type 14>) (q <type 34>, r <type 14>)
 func (x <esc:0x1> <type 34>) .math/big.itoa (neg <type -15>, base <type -11>) <type 8>
 func (z <esc:0x1> <type 34>) .math/big.clear ()
 func (z <esc:0x12> <type 34>) .math/big.div (z2 <esc:0x82> <type 34>, u <esc:0x1> <type 34>, v <esc:0x1> <type 34>) (q <type 34>, r <type 34>)
 func (z <esc:0x12> <type 34>) .math/big.setUint64 (x <type -8>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.and (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (x <esc:0x1> <type 34>) .math/big.bitLen () <type -11>
 func (z <esc:0x12> <type 34>) .math/big.divLarge (u <esc:0x82> <type 34>, uIn <esc:0x1> <type 34>, vIn <esc:0x1> <type 34>) (q <type 34>, r <type 34>)
 func (z <esc:0x12> <type 34>) .math/big.sub (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (x <esc:0x1> <type 34>) .math/big.cmp (y <esc:0x1> <type 34>) (r <type -11>)
 func (z <esc:0x12> <type 34>) .math/big.shl (x <esc:0x1> <type 34>, s <type -12>) <type 34>
 func (z <type 34>) .math/big.sqr (x <esc:0x1> <type 34>) <type 34>
 func (x <esc:0x1> <type 34>) .math/big.trailingZeroBits () <type -12>
 func (x <esc:0x1> <type 34>) .math/big.bit (i <type -12>) <type -12>
 func (x <esc:0x1> <type 34>) .math/big.sticky (i <type -12>) <type -12>
 func (z <type 34>) .math/big.mul (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.mulAddWW (x <esc:0x1> <type 34>, y <type 14>, r <type 14>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.andNot (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.or (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (z <esc:0x12> <type 34>) .math/big.xor (x <esc:0x1> <type 34>, y <esc:0x1> <type 34>) <type 34>
 func (x <esc:0x1> <type 34>) .math/big.modW (d <type 14>) (r <type 14>)
type 35 [] <type 36>
type 36 ".math/big.divisor" <type 37>
type 37 struct { .math/big.bbb <type 34>; .math/big.nbits <type -11>; .math/big.ndigits <type -11>; }
type 38 struct { ? <type 4>; X <type 11>; }
type 39 struct { ? <type 2>; Y <type 11>; }
type 40 *<type 4>
var ErrInvalidPublicKey <type -19>
func GenerateKey (priv <esc:0x9> <type 5>, rand <type 6>) <type -19>
func GenerateParameters (params <esc:0x1> <type 9>, rand <type 6>, sizes <type 1>) <type -19>
const L1024N160 <type 1> = 0 
const L2048N224 <type 1> = 1 
const L2048N256 <type 1> = 2 
const L3072N256 <type 1> = 3 
func Sign (rand <type 6>, priv <esc:0x9> <type 5>, hash <esc:0x1> <type 8>) (r <type 11>, s <type 11>, err <type -19>)
func Verify (pub <esc:0x9> <type 40>, hash <esc:0x1> <type 8>, r <esc:0x1> <type 11>, s <esc:0x1> <type 11>) <type -15>
checksum D6AC31A252C552023ECD439664AE20A23AFEF4E1
                                                  .symtab .strtab .shstrtab .go_export                                                                                        @       8                                                   H8      0                           	                      x8                                                          y8      &                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              