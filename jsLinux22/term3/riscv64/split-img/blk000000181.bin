        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
        alias ru_nivcsw ru_last;
    }

    enum
    {
        RLIMIT_CORE   =  4,
        RLIMIT_CPU    =  0,
        RLIMIT_DATA   =  2,
        RLIMIT_FSIZE  =  1,
        RLIMIT_NOFILE =  8,
        RLIMIT_STACK  =  3,
        RLIMIT_AS     = 10,
    }
}
else version (NetBSD)
{
    enum
    {
        PRIO_PROCESS = 0,
        PRIO_PGRP    = 1,
        PRIO_USER    = 2,
    }

    alias long rlim_t;

    enum
    {
        RLIM_INFINITY   = (cast(rlim_t)((cast(ulong) 1 << 63) - 1)),
        // FreeBSD explicitly does not define the following:
        //RLIM_SAVED_MAX,
        //RLIM_SAVED_CUR,
    }

    enum
    {
        RUSAGE_SELF     =  0,
        RUSAGE_CHILDREN = -1,
    }

    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        alias ru_ixrss ru_first;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
        alias ru_nivcsw ru_last;
    }

    enum
    {
        RLIMIT_CORE   =  4,
        RLIMIT_CPU    =  0,
        RLIMIT_DATA   =  2,
        RLIMIT_FSIZE  =  1,
        RLIMIT_NOFILE =  8,
        RLIMIT_STACK  =  3,
        RLIMIT_AS     = 10,
    }
}
else version (DragonFlyBSD)
{
    enum
    {
        PRIO_PROCESS = 0,
        PRIO_PGRP    = 1,
        PRIO_USER    = 2,
    }

    alias long rlim_t;

    enum
    {
        RLIM_INFINITY   = (cast(rlim_t)((cast(ulong) 1 << 63) - 1)),
        // DragonFlyBSD explicitly does not define the following:
        //RLIM_SAVED_MAX,
        //RLIM_SAVED_CUR,
    }

    enum
    {
        RUSAGE_SELF     =  0,
        RUSAGE_CHILDREN = -1,
    }

    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        alias ru_ixrss ru_first;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
        alias ru_nivcsw ru_last;
    }

    enum
    {
        RLIMIT_CORE   =  4,
        RLIMIT_CPU    =  0,
        RLIMIT_DATA   =  2,
        RLIMIT_FSIZE  =  1,
        RLIMIT_NOFILE =  8,
        RLIMIT_STACK  =  3,
        RLIMIT_AS     = 10,
    }
}
else version (Solaris)
{
    enum
    {
        PRIO_PROCESS = 0,
        PRIO_PGRP    = 1,
        PRIO_USER    = 2,
    }

    alias c_ulong rlim_t;

    enum : c_long
    {
        RLIM_INFINITY   = -3,
        RLIM_SAVED_MAX  = -2,
        RLIM_SAVED_CUR  = -1,
    }

    enum
    {
        RUSAGE_SELF     =  0,
        RUSAGE_CHILDREN = -1,
    }

    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
    }

    enum
    {
        RLIMIT_CORE   = 4,
        RLIMIT_CPU    = 0,
        RLIMIT_DATA   = 2,
        RLIMIT_FSIZE  = 1,
        RLIMIT_NOFILE = 5,
        RLIMIT_STACK  = 3,
        RLIMIT_AS     = 6,
    }
}
else version (CRuntime_Bionic)
{
    enum
    {
        PRIO_PROCESS = 0,
        PRIO_PGRP    = 1,
        PRIO_USER    = 2,
    }

    alias c_ulong rlim_t;
    enum RLIM_INFINITY = cast(c_ulong)(~0UL);

    enum
    {
        RUSAGE_SELF     =  0,
        RUSAGE_CHILDREN = -1,
    }

    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
    }

    enum
    {
        RLIMIT_CORE   = 4,
        RLIMIT_CPU    = 0,
        RLIMIT_DATA   = 2,
        RLIMIT_FSIZE  = 1,
        RLIMIT_NOFILE = 7,
        RLIMIT_STACK  = 3,
        RLIMIT_AS     = 9,
    }
}
else version (CRuntime_Musl)
{
    alias ulong rlim_t;

    int getrlimit(int, rlimit*);
    int setrlimit(int, in rlimit*);
    alias getrlimit getrlimit64;
    alias setrlimit setrlimit64;
    enum
    {
        RUSAGE_SELF = 0,
        RUSAGE_CHILDREN = -1,
        RUSAGE_THREAD = 1
    }
    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
        c_long[16] __reserved;
    }

    enum
    {
        RLIMIT_CPU    = 0,
        RLIMIT_FSIZE  = 1,
        RLIMIT_DATA   = 2,
        RLIMIT_STACK  = 3,
        RLIMIT_CORE   = 4,
        RLIMIT_NOFILE = 7,
        RLIMIT_AS     = 9,
    }
}
else version (CRuntime_UClibc)
{
    enum
    {
        PRIO_PROCESS = 0,
        PRIO_PGRP    = 1,
        PRIO_USER    = 2,
    }

    static if (__USE_FILE_OFFSET64)
         alias ulong rlim_t;
    else
         alias c_ulong rlim_t;

    static if (__USE_FILE_OFFSET64)
        enum RLIM_INFINITY = 0xffffffffffffffffUL;
    else
        enum RLIM_INFINITY = cast(c_ulong)(~0UL);

    enum RLIM_SAVED_MAX = RLIM_INFINITY;
    enum RLIM_SAVED_CUR = RLIM_INFINITY;

    enum
    {
        RUSAGE_SELF     =  0,
        RUSAGE_CHILDREN = -1,
    }

    struct rusage
    {
        timeval ru_utime;
        timeval ru_stime;
        c_long ru_maxrss;
        c_long ru_ixrss;
        c_long ru_idrss;
        c_long ru_isrss;
        c_long ru_minflt;
        c_long ru_majflt;
        c_long ru_nswap;
        c_long ru_inblock;
        c_long ru_oublock;
        c_long ru_msgsnd;
        c_long ru_msgrcv;
        c_long ru_nsignals;
        c_long ru_nvcsw;
        c_long ru_nivcsw;
    }

    enum
    {
        RLIMIT_CORE   = 4,
        RLIMIT_CPU    = 0,
        RLIMIT_DATA   = 2,
        RLIMIT_FSIZE  = 1,
        RLIMIT_NOFILE = 7,
        RLIMIT_STACK  = 3,
        RLIMIT_AS     = 9,
    }
}
else static assert (false, "Unsupported platform");

struct rlimit
{
    rlim_t rlim_cur;
    rlim_t rlim_max;
}

version (CRuntime_Glibc)
{
    int getpriority(int, id_t);
    int setpriority(int, id_t, int);
}
else version (FreeBSD)
{
    int getpriority(int, int);
    int setpriority(int, int, int);
}
else version (DragonFlyBSD)
{
    int getpriority(int, int);
    int setpriority(int, int, int);
}
else version (CRuntime_Bionic)
{
    int getpriority(int, int);
    int setpriority(int, int, int);
}
else version (Solaris)
{
    int getpriority(int, id_t);
    int setpriority(int, id_t, int);
}
else version (Darwin)
{
    int getpriority(int, id_t);
    int setpriority(int, id_t, int);
}
else version (CRuntime_UClibc)
{
    int getpriority(int, id_t);
    int setpriority(int, id_t, int);
}

version (CRuntime_Glibc)
{
    static if (__USE_FILE_OFFSET64)
    {
        int getrlimit64(int, rlimit*);
        int setrlimit64(int, in rlimit*);
        alias getrlimit = getrlimit64;
        alias setrlimit = setrlimit64;
    }
    else
    {
        int getrlimit(int, rlimit*);
        int setrlimit(int, in rlimit*);
    }
    int getrusage(int, rusage*);
}
else version (CRuntime_Bionic)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (Darwin)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (FreeBSD)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (NetBSD)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (DragonFlyBSD)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (Solaris)
{
    int getrlimit(int, rlimit*);
    int getrusage(int, rusage*);
    int setrlimit(int, in rlimit*);
}
else version (CRuntime_UClibc)
{
    static if (__USE_FILE_OFFSET64)
    {
        int getrlimit64(int, rlimit*);
        int setrlimit64(int, in rlimit*);
        alias getrlimit = getrlimit64;
        alias setrlimit = setrlimit64;
    }
    else
    {
        int getrlimit(int, rlimit*);
        int setrlimit(int, in rlimit*);
    }
    int getrusage(int, rusage*);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2016.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */
module core.sys.posix.sys.select;

private import core.sys.posix.config;
public import core.stdc.time;           // for timespec
public import core.sys.posix.sys.time;  // for timeval
public import core.sys.posix.sys.types; // for time_t
public import core.sys.posix.signal;    // for sigset_t

//debug=select;  // uncomment to turn on debugging printf's
version (unittest) import core.stdc.stdio: printf;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C) nothrow @nogc:

//
// Required
//
/*
NOTE: This module requires timeval from core.sys.posix.sys.time, but timeval
      is supposedly an XOpen extension.  As a result, this header will not
      compile on platforms that are not XSI-compliant.  This must be resolved
      on a per-platform basis.

fd_set

void FD_CLR(int fd, fd_set* fdset);
int FD_ISSET(int fd, const(fd_set)* fdset);
void FD_SET(int fd, fd_set* fdset);
void FD_ZERO(fd_set* fdset);

FD_SETSIZE

int  pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
int  select(int, fd_set*, fd_set*, fd_set*, timeval*);
*/

version (CRuntime_Glibc)
{
    private
    {
        alias c_long __fd_mask;
        enum uint __NFDBITS = 8 * __fd_mask.sizeof;

        extern (D) auto __FDELT( int d ) pure
        {
            return d / __NFDBITS;
        }

        extern (D) auto __FDMASK( int d ) pure
        {
            return cast(__fd_mask) 1 << ( d % __NFDBITS );
        }
    }

    enum FD_SETSIZE = 1024;

    struct fd_set
    {
        __fd_mask[FD_SETSIZE / __NFDBITS] fds_bits;
    }

    extern (D) void FD_CLR( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] &= ~__FDMASK( fd );
    }

    extern (D) bool FD_ISSET( int fd, const(fd_set)* fdset ) pure
    {
        return (fdset.fds_bits[__FDELT( fd )] & __FDMASK( fd )) != 0;
    }

    extern (D) void FD_SET( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] |= __FDMASK( fd );
    }

    extern (D) void FD_ZERO( fd_set* fdset ) pure
    {
        fdset.fds_bits[0 .. $] = 0;
    }

    /+
     + GNU ASM Implementation
     +
    # define __FD_ZERO(fdsp)                                \
      do {                                                  \
        int __d0, __d1;                                     \
        __asm__ __volatile__ ("cld; rep; stosl"             \
                  : "=c" (__d0), "=D" (__d1)                \
                  : "a" (0), "0" (sizeof (fd_set)           \
                          / sizeof (__fd_mask)),            \
                    "1" (&__FDS_BITS (fdsp)[0])             \
                  : "memory");                              \
      } while (0)

    # define __FD_SET(fd, fdsp)                             \
      __asm__ __volatile__ ("btsl %1,%0"                    \
                : "=m" (__FDS_BITS (fdsp)[__FDELT (fd)])    \
                : "r" (((int) (fd)) % __NFDBITS)            \
                : "cc","memory")
    # define __FD_CLR(fd, fdsp)                             \
      __asm__ __volatile__ ("btrl %1,%0"                    \
                : "=m" (__FDS_BITS (fdsp)[__FDELT (fd)])    \
                : "r" (((int) (fd)) % __NFDBITS)            \
                : "cc","memory")
    # define __FD_ISSET(fd, fdsp)                           \
      (__extension__                                        \
       ({register char __result;                            \
         __asm__ __volatile__ ("btl %1,%2 ; setcb %b0"      \
                   : "=q" (__result)                        \
                   : "r" (((int) (fd)) % __NFDBITS),        \
                     "m" (__FDS_BITS (fdsp)[__FDELT (fd)])  \
                   : "cc");                                 \
         __result; }))
     +/

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (Darwin)
{
    private
    {
        enum uint __DARWIN_NBBY    = 8;                            /* bits in a byte */
        enum uint __DARWIN_NFDBITS = (int.sizeof * __DARWIN_NBBY); /* bits per mask */
    }

    enum FD_SETSIZE = 1024;

    struct fd_set
    {
        int[(FD_SETSIZE + (__DARWIN_NFDBITS - 1)) / __DARWIN_NFDBITS] fds_bits;
    }

    extern (D) void FD_CLR( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[fd / __DARWIN_NFDBITS] &= ~(1 << (fd % __DARWIN_NFDBITS));
    }

    extern (D) bool FD_ISSET( int fd, const(fd_set)* fdset ) pure
    {
        return (fdset.fds_bits[fd / __DARWIN_NFDBITS] & (1 << (fd % __DARWIN_NFDBITS))) != 0;
    }

    extern (D) void FD_SET( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[fd / __DARWIN_NFDBITS] |= 1 << (fd % __DARWIN_NFDBITS);
    }

    extern (D) void FD_ZERO( fd_set* fdset ) pure
    {
        fdset.fds_bits[0 .. $] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (FreeBSD)
{
    private
    {
        alias c_ulong __fd_mask;
        enum _NFDBITS = __fd_mask.sizeof * 8;
    }

    enum uint FD_SETSIZE = 1024;

    struct fd_set
    {
        __fd_mask[(FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS] __fds_bits;
    }

    extern (D) __fd_mask __fdset_mask(uint n) pure
    {
        return cast(__fd_mask) 1 << (n % _NFDBITS);
    }

    extern (D) void FD_CLR( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] &= ~__fdset_mask(n);
    }

    extern (D) bool FD_ISSET( int n, const(fd_set)* p ) pure
    {
        return (p.__fds_bits[n / _NFDBITS] & __fdset_mask(n)) != 0;
    }

    extern (D) void FD_SET( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] |= __fdset_mask(n);
    }

    extern (D) void FD_ZERO( fd_set* p ) pure
    {
        fd_set *_p;
        size_t _n;

        _p = p;
        _n = (FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS;
        while (_n > 0)
            _p.__fds_bits[--_n] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (NetBSD)
{
    private
    {
        alias c_ulong __fd_mask;
        enum _NFDBITS = __fd_mask.sizeof * 8;
    }

    enum uint FD_SETSIZE = 256;

    struct fd_set
    {
        __fd_mask[(FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS] __fds_bits;
    }

    extern (D) __fd_mask __fdset_mask(uint n) pure
    {
        return cast(__fd_mask) 1 << (n % _NFDBITS);
    }

    extern (D) void FD_CLR( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] &= ~__fdset_mask(n);
    }

    extern (D) bool FD_ISSET( int n, const(fd_set)* p ) pure
    {
        return (p.__fds_bits[n / _NFDBITS] & __fdset_mask(n)) != 0;
    }

    extern (D) void FD_SET( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] |= __fdset_mask(n);
    }

    extern (D) void FD_ZERO( fd_set* p ) pure
    {
        fd_set *_p;
        size_t _n;

        _p = p;
        _n = (FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS;
        while (_n > 0)
            _p.__fds_bits[--_n] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (DragonFlyBSD)
{
    private
    {
        alias c_ulong __fd_mask;
        enum _NFDBITS = __fd_mask.sizeof * 8;
    }

    enum uint FD_SETSIZE = 1024;

    struct fd_set
    {
        __fd_mask[(FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS] __fds_bits;
    }

    extern (D) __fd_mask __fdset_mask(uint n) pure
    {
        return cast(__fd_mask) 1 << (n % _NFDBITS);
    }

    extern (D) void FD_CLR( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] &= ~__fdset_mask(n);
    }

    extern (D) bool FD_ISSET( int n, const(fd_set)* p ) pure
    {
        return (p.__fds_bits[n / _NFDBITS] & __fdset_mask(n)) != 0;
    }

    extern (D) void FD_SET( int n, fd_set* p ) pure
    {
        p.__fds_bits[n / _NFDBITS] |= __fdset_mask(n);
    }

    extern (D) void FD_ZERO( fd_set* p ) pure
    {
        fd_set *_p;
        size_t _n;

        _p = p;
        _n = (FD_SETSIZE + (_NFDBITS - 1)) / _NFDBITS;
        while (_n > 0)
            _p.__fds_bits[--_n] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (Solaris)
{
    private
    {
        alias c_long fds_mask;

        enum _NBBY = 8;
        enum FD_NFDBITS = fds_mask.sizeof * _NBBY;
    }

    version (D_LP64)
        enum uint FD_SETSIZE = 65536;
    else
        enum uint FD_SETSIZE = 1024;

    struct fd_set
    {
        c_long[(FD_SETSIZE + (FD_NFDBITS - 1)) / FD_NFDBITS] fds_bits;
    }

    extern (D) void FD_SET(int __n, fd_set* __p) pure
    {
        __p.fds_bits[__n / FD_NFDBITS] |= 1UL << (__n % FD_NFDBITS);
    }

    extern (D) void FD_CLR(int __n, fd_set* __p) pure
    {
        __p.fds_bits[__n / FD_NFDBITS] &= ~(1UL << (__n % FD_NFDBITS));
    }

    extern (D) bool FD_ISSET(int __n, const(fd_set)* __p) pure
    {
        return (__p.fds_bits[__n / FD_NFDBITS] & (1UL << (__n % FD_NFDBITS))) != 0;
    }

    extern (D) void FD_ZERO(fd_set* __p) pure
    {
        __p.fds_bits[0 .. $] = 0;
    }

    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
}
else version (CRuntime_Bionic)
{
    private
    {
        alias c_ulong __fd_mask;
        enum uint __NFDBITS = 8 * __fd_mask.sizeof;

        extern (D) auto __FDELT( int d ) pure
        {
            return d / __NFDBITS;
        }

        extern (D) auto __FDMASK( int d ) pure
        {
            return cast(__fd_mask) 1 << ( d % __NFDBITS );
        }
    }

    enum FD_SETSIZE = 1024;

    struct fd_set
    {
        __fd_mask[FD_SETSIZE / __NFDBITS] fds_bits;
    }

    // These functions are generated in assembly in bionic.
    extern (D) void FD_CLR( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] &= ~__FDMASK( fd );
    }

    extern (D) bool FD_ISSET( int fd, const(fd_set)* fdset ) pure
    {
        return (fdset.fds_bits[__FDELT( fd )] & __FDMASK( fd )) != 0;
    }

    extern (D) void FD_SET( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] |= __FDMASK( fd );
    }

    extern (D) void FD_ZERO( fd_set* fdset ) pure
    {
        fdset.fds_bits[0 .. $] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (CRuntime_Musl)
{
    enum FD_SETSIZE = 1024;

    alias ulong fd_mask;

    private
    {
        enum uint __NFDBITS = 8 * fd_mask.sizeof;

        extern (D) auto __FDELT( int d ) pure
        {
            return d / __NFDBITS;
        }

        extern (D) auto __FDMASK( int d ) pure
        {
            return cast(fd_mask) 1 << ( d % __NFDBITS );
        }
    }

    struct fd_set {
        ulong[FD_SETSIZE / 8 / long.sizeof] fds_bits;
    }

    extern (D) void FD_CLR( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] &= ~__FDMASK( fd );
    }

    extern (D) bool FD_ISSET( int fd, const(fd_set)* fdset ) pure
    {
        return (fdset.fds_bits[__FDELT( fd )] & __FDMASK( fd )) != 0;
    }

    extern (D) void FD_SET( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] |= __FDMASK( fd );
    }

    extern (D) void FD_ZERO( fd_set* fdset ) pure
    {
        fdset.fds_bits[0 .. $] = 0;
    }
    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else version (CRuntime_UClibc)
{
    private
    {
        alias c_long __fd_mask;
        enum uint __NFDBITS = 8 * __fd_mask.sizeof;

        extern (D) auto __FDELT( int d ) pure
        {
            return d / __NFDBITS;
        }

        extern (D) auto __FDMASK( int d ) pure
        {
            return cast(__fd_mask) 1 << ( d % __NFDBITS );
        }
    }

    enum FD_SETSIZE = 1024;

    struct fd_set
    {
        __fd_mask[FD_SETSIZE / __NFDBITS] fds_bits;
    }

    extern (D) void FD_CLR( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] &= ~__FDMASK( fd );
    }

    extern (D) bool FD_ISSET( int fd, const(fd_set)* fdset ) pure
    {
        return (fdset.fds_bits[__FDELT( fd )] & __FDMASK( fd )) != 0;
    }

    extern (D) void FD_SET( int fd, fd_set* fdset ) pure
    {
        fdset.fds_bits[__FDELT( fd )] |= __FDMASK( fd );
    }

    extern (D) void FD_ZERO( fd_set* fdset ) pure
    {
        fdset.fds_bits[0 .. $] = 0;
    }

    int pselect(int, fd_set*, fd_set*, fd_set*, in timespec*, in sigset_t*);
    int select(int, fd_set*, fd_set*, fd_set*, timeval*);
}
else
{
    static assert(false, "Unsupported platform");
}

pure unittest
{
    debug(select) printf("core.sys.posix.sys.select unittest\n");

    fd_set fd;

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        assert(!FD_ISSET(i, &fd));
    }

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        if ((i & -i) == i)
            FD_SET(i, &fd);
    }

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        if ((i & -i) == i)
            assert(FD_ISSET(i, &fd));
        else
            assert(!FD_ISSET(i, &fd));
    }

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        if ((i & -i) == i)
            FD_CLR(i, &fd);
        else
            FD_SET(i, &fd);
    }

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        if ((i & -i) == i)
            assert(!FD_ISSET(i, &fd));
        else
            assert(FD_ISSET(i, &fd));
    }

    FD_ZERO(&fd);

    for (auto i = 0; i < FD_SETSIZE; i++)
    {
        assert(!FD_ISSET(i, &fd));
    }
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.shm;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for pid_t, time_t, key_t
public import core.sys.posix.sys.ipc;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C) nothrow @nogc:

//
// XOpen (XSI)
//
/*
SHM_RDONLY
SHM_RND

SHMLBA

shmatt_t

struct shmid_ds
{
    ipc_perm    shm_perm;
    size_t      shm_segsz;
    pid_t       shm_lpid;
    pid_t       shm_cpid;
    shmatt_t    shm_nattch;
    time_t      shm_atime;
    time_t      shm_dtime;
    time_t      shm_ctime;
}

void* shmat(int, in void*, int);
int   shmctl(int, int, shmid_ds*);
int   shmdt(in void*);
int   shmget(key_t, size_t, int);
*/

version (CRuntime_Glibc)
{
    enum SHM_RDONLY     = 0x01000; // 010000
    enum SHM_RND        = 0x02000; // 020000

    int   __getpagesize();
    alias __getpagesize SHMLBA;

    alias c_ulong   shmatt_t;

    /* For any changes, please check /usr/include/bits/shm.h */
    struct shmid_ds
    {
        ipc_perm    shm_perm;
        size_t      shm_segsz;
        time_t      shm_atime;
        version (X86_64) {} else c_ulong     __unused1;
        time_t      shm_dtime;
        version (X86_64) {} else c_ulong     __unused2;
        time_t      shm_ctime;
        version (X86_64) {} else c_ulong     __unused3;
        pid_t       shm_cpid;
        pid_t       shm_lpid;
        shmatt_t    shm_nattch;
        c_ulong     __unused4;
        c_ulong     __unused5;
    }

    void* shmat(int, in void*, int);
    int   shmctl(int, int, shmid_ds*);
    int   shmdt(in void*);
    int   shmget(key_t, size_t, int);
}
else version (FreeBSD)
{
    enum SHM_RDONLY     = 0x01000; // 010000
    enum SHM_RND        = 0x02000; // 020000
    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)

    alias c_ulong   shmatt_t;

    struct shmid_ds_old // <= FreeBSD7
    {
        ipc_perm_old    shm_perm;
        int             shm_segsz;
        pid_t           shm_lpid;
        pid_t           shm_cpid;
        short           shm_nattch;
        time_t          shm_atime;
        time_t          shm_dtime;
        time_t          shm_ctime;
        void*           shm_internal;
    }

    struct shmid_ds
    {
         ipc_perm    shm_perm;
         int         shm_segsz;
         pid_t       shm_lpid;
         pid_t       shm_cpid;
         short       shm_nattch;
         time_t      shm_atime;
         time_t      shm_dtime;
         time_t      shm_ctime;
    }

    void* shmat(int, in void*, int);
    int   shmctl(int, int, shmid_ds*);
    int   shmdt(in void*);
    int   shmget(key_t, size_t, int);
}
else version (NetBSD)
{
    enum SHM_RDONLY     = 0x01000; // 010000
    enum SHM_RND        = 0x02000; // 020000
    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)

    alias c_ulong   shmatt_t;

    struct shmid_ds
    {
        ipc_perm        shm_perm;
        size_t             shm_segsz;
        pid_t           shm_lpid;
        pid_t           shm_cpid;
        short           shm_nattch;
        time_t          shm_atime;
        time_t          shm_dtime;
        time_t          shm_ctime;
        void*           shm_internal;
    }

    void* shmat(int, in void*, int);
    int   shmctl(int, int, shmid_ds*);
    int   shmdt(in void*);
    int   shmget(key_t, size_t, int);
}
else version (DragonFlyBSD)
{
    enum SHM_RDONLY     = 0x01000; // 010000
    enum SHM_RND        = 0x02000; // 020000
    enum SHMLBA         = 1 << 12; // PAGE_SIZE = (1<<PAGE_SHIFT)

    alias c_ulong   shmatt_t;

    struct shmid_ds
    {
         ipc_perm       shm_perm;
         int            shm_segsz;
         pid_t          shm_lpid;
         pid_t          shm_cpid;
         short          shm_nattch;
         time_t         shm_atime;
         time_t         shm_dtime;
         time_t         shm_ctime;
         private void*  shm_internal;
    }

    void* shmat(int, in void*, int);
    int   shmctl(int, int, shmid_ds*);
    int   shmdt(in void*);
    int   shmget(key_t, size_t, int);
}
else version (Darwin)
{

}
else version (CRuntime_UClibc)
{
    enum SHM_RDONLY     = 0x1000; // 010000
    enum SHM_RND        = 0x2000; // 020000
    enum SHM_REMAP      = 0x4000; // 040000

    int   __getpagesize();
    alias __getpagesize SHMLBA;

    alias c_ulong   shmatt_t;

    version (X86_64)
        enum includeUnused  = false;
    else version (MIPS32)
        enum includeUnused  = false;
    else
        enum includeUnused  = true;

    struct shmid_ds
    {
        ipc_perm    shm_perm;
        size_t      shm_segsz;
        time_t      shm_atime;
        static if (includeUnused) c_ulong     __unused1;
        time_t      shm_dtime;
        static if (includeUnused) c_ulong     __unused2;
        time_t      shm_ctime;
        static if (includeUnused) c_ulong     __unused3;
        pid_t       shm_cpid;
        pid_t       shm_lpid;
        shmatt_t    shm_nattch;
        c_ulong     __unused4;
        c_ulong     __unused5;
    }

    struct shminfo
    {
        c_ulong shmmax;
        c_ulong shmmin;
        c_ulong shmmni;
        c_ulong shmseg;
        c_ulong shmall;
        c_ulong __unused1;
        c_ulong __unused2;
        c_ulong __unused3;
        c_ulong __unused4;
    }

    struct shm_info
    {
        int used_ids;
        c_ulong shm_tot;
        c_ulong shm_rss;
        c_ulong shm_swp;
        c_ulong swap_attempts;
        c_ulong swap_successes;
    }

    void* shmat(int, in void*, int);
    int   shmctl(int, int, shmid_ds*);
    int   shmdt(in void*);
    int   shmget(key_t, size_t, int);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.socket;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for ssize_t
public import core.sys.posix.sys.uio;   // for iovec

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (ARM)     version = ARM_Any;
version (AArch64) version = ARM_Any;
version (HPPA)    version = HPPA_Any;
version (MIPS32)  version = MIPS_Any;
version (MIPS64)  version = MIPS_Any;
version (PPC)     version = PPC_Any;
version (PPC64)   version = PPC_Any;
version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;
version (S390)    version = IBMZ_Any;
version (SPARC)   version = SPARC_Any;
version (SPARC64) version = SPARC_Any;
version (SystemZ) version = IBMZ_Any;
version (X86)     version = X86_Any;
version (X86_64)  version = X86_Any;

version (Posix):
extern (C) nothrow @nogc:

//
// Required
//
/*
socklen_t
sa_family_t

struct sockaddr
{
    sa_family_t sa_family;
    char        sa_data[];
}

struct sockaddr_storage
{
    sa_family_t ss_family;
}

struct msghdr
{
    void*         msg_name;
    socklen_t     msg_namelen;
    struct iovec* msg_iov;
    int           msg_iovlen;
    void*         msg_control;
    socklen_t     msg_controllen;
    int           msg_flags;
}

struct iovec {} // from core.sys.posix.sys.uio

struct cmsghdr
{
    socklen_t cmsg_len;
    int       cmsg_level;
    int       cmsg_type;
}

SCM_RIGHTS

CMSG_DATA(cmsg)
CMSG_NXTHDR(mhdr,cmsg)
CMSG_FIRSTHDR(mhdr)

struct linger
{
    int l_onoff;
    int l_linger;
}

SOCK_DGRAM
SOCK_SEQPACKET
SOCK_STREAM

SOL_SOCKET

SO_ACCEPTCONN
SO_BROADCAST
SO_DEBUG
SO_DONTROUTE
SO_ERROR
SO_KEEPALIVE
SO_LINGER
SO_OOBINLINE
SO_RCVBUF
SO_RCVLOWAT
SO_RCVTIMEO
SO_REUSEADDR
SO_SNDBUF
SO_SNDLOWAT
SO_SNDTIMEO
SO_TYPE

SOMAXCONN

MSG_CTRUNC
MSG_DONTROUTE
MSG_EOR
MSG_OOB
MSG_PEEK
MSG_TRUNC
MSG_WAITALL

AF_INET
AF_UNIX
AF_UNSPEC

SHUT_RD
SHUT_RDWR
SHUT_WR

int     accept(int, sockaddr*, socklen_t*);
int     bind(int, in sockaddr*, socklen_t);
int     connect(int, in sockaddr*, socklen_t);
int     getpeername(int, sockaddr*, socklen_t*);
int     getsockname(int, sockaddr*, socklen_t*);
int     getsockopt(int, int, int, void*, socklen_t*);
int     listen(int, int);
ssize_t recv(int, void*, size_t, int);
ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);
ssize_t recvmsg(int, msghdr*, int);
ssize_t send(int, in void*, size_t, int);
ssize_t sendmsg(int, in msghdr*, int);
ssize_t sendto(int, in void*, size_t, int, in sockaddr*, socklen_t);
int     setsockopt(int, int, int, in void*, socklen_t);
int     shutdown(int, int);
int     socket(int, int, int);
int     sockatmark(int);
int     socketpair(int, int, int, ref int[2]);
*/

version (CRuntime_Glibc)
{
    // Some of the constants below and from the Bionic section are really from
    // the linux kernel headers.
    alias uint   socklen_t;
    alias ushort sa_family_t;

    struct sockaddr
    {
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private enum : size_t
    {
        _SS_SIZE    = 128,
        _SS_PADSIZE = _SS_SIZE - (c_ulong.sizeof * 2)
    }

    struct sockaddr_storage
    {
        sa_family_t ss_family;
        c_ulong     __ss_align;
        byte[_SS_PADSIZE] __ss_padding;
    }

    struct msghdr
    {
        void*     msg_name;
        socklen_t msg_namelen;
        iovec*    msg_iov;
        size_t    msg_iovlen;
        void*     msg_control;
        size_t    msg_controllen;
        int       msg_flags;
    }

    struct cmsghdr
    {
        size_t cmsg_len;
        int    cmsg_level;
        int    cmsg_type;
        static if ( false /* (!is( __STRICT_ANSI__ ) && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L */ )
        {
            ubyte[1] __cmsg_data;
        }
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    static if ( false /* (!is( __STRICT_ANSI__ ) && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L */ )
    {
        extern (D) ubyte[1] CMSG_DATA( cmsghdr* cmsg ) pure nothrow @nogc { return cmsg.__cmsg_data; }
    }
    else
    {
        extern (D) inout(ubyte)*   CMSG_DATA( inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }
    }

    private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;
    extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc
    {
        return __cmsg_nxthdr(msg, cmsg);
    }

    extern (D) inout(cmsghdr)* CMSG_FIRSTHDR( inout(msghdr)* mhdr ) pure nothrow @nogc
    {
        return ( cast(size_t)mhdr.msg_controllen >= cmsghdr.sizeof
                             ? cast(inout(cmsghdr)*) mhdr.msg_control
                             : cast(inout(cmsghdr)*) null );
    }

    extern (D)
    {
        size_t CMSG_ALIGN( size_t len ) pure nothrow @nogc
        {
            return (len + size_t.sizeof - 1) & cast(size_t) (~(size_t.sizeof - 1));
        }

        size_t CMSG_LEN( size_t len ) pure nothrow @nogc
        {
            return CMSG_ALIGN(cmsghdr.sizeof) + len;
        }
    }

    extern (D) size_t CMSG_SPACE(size_t len) pure nothrow @nogc
    {
        return CMSG_ALIGN(len) + CMSG_ALIGN(cmsghdr.sizeof);
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    version (X86_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 18,
            SO_RCVTIMEO     = 20,
            SO_REUSEADDR    = 2,
            SO_REUSEPORT    = 15,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 19,
            SO_SNDTIMEO     = 21,
            SO_TYPE         = 3
        }
    }
    else version (HPPA_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1,
        }

        enum
        {
            SOL_SOCKET      = 0xffff
        }

        enum
        {
            SO_ACCEPTCONN   = 0x401c,
            SO_BROADCAST    = 0x0020,
            SO_DEBUG        = 0x0001,
            SO_DONTROUTE    = 0x0010,
            SO_ERROR        = 0x1007,
            SO_KEEPALIVE    = 0x0008,
            SO_LINGER       = 0x0080,
            SO_OOBINLINE    = 0x0100,
            SO_RCVBUF       = 0x1002,
            SO_RCVLOWAT     = 0x1004,
            SO_RCVTIMEO     = 0x1006,
            SO_REUSEADDR    = 0x0004,
            SO_SNDBUF       = 0x1001,
            SO_SNDLOWAT     = 0x1003,
            SO_SNDTIMEO     = 0x1005,
            SO_TYPE         = 0x1008,
        }
    }
    else version (MIPS_Any)
    {
        enum
        {
            SOCK_DGRAM      = 1,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 2,
        }

        enum
        {
            SOL_SOCKET      = 0xffff
        }

        enum
        {
            SO_ACCEPTCONN   = 0x1009,
            SO_BROADCAST    = 0x0020,
            SO_DEBUG        = 0x0001,
            SO_DONTROUTE    = 0x0010,
            SO_ERROR        = 0x1007,
            SO_KEEPALIVE    = 0x0008,
            SO_LINGER       = 0x0080,
            SO_OOBINLINE    = 0x0100,
            SO_RCVBUF       = 0x1002,
            SO_RCVLOWAT     = 0x1004,
            SO_RCVTIMEO     = 0x1006,
            SO_REUSEADDR    = 0x0004,
            SO_SNDBUF       = 0x1001,
            SO_SNDLOWAT     = 0x1003,
            SO_SNDTIMEO     = 0x1005,
            SO_TYPE         = 0x1008,
        }
    }
    else version (PPC_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 16,
            SO_RCVTIMEO     = 18,
            SO_REUSEADDR    = 2,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 17,
            SO_SNDTIMEO     = 19,
            SO_TYPE         = 3
        }
    }
    else version (ARM_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 18,
            SO_RCVTIMEO     = 20,
            SO_REUSEADDR    = 2,
            SO_REUSEPORT    = 15,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 19,
            SO_SNDTIMEO     = 21,
            SO_TYPE         = 3
        }
    }
    else version (RISCV_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 18,
            SO_RCVTIMEO     = 20,
            SO_REUSEADDR    = 2,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 19,
            SO_SNDTIMEO     = 21,
            SO_TYPE         = 3
        }
    }
    else version (SPARC_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 18,
            SO_RCVTIMEO     = 20,
            SO_REUSEADDR    = 2,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 19,
            SO_SNDTIMEO     = 21,
            SO_TYPE         = 3
        }
    }
    else version (IBMZ_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1
        }

        enum
        {
            SOL_SOCKET      = 1
        }

        enum
        {
            SO_ACCEPTCONN   = 30,
            SO_BROADCAST    = 6,
            SO_DEBUG        = 1,
            SO_DONTROUTE    = 5,
            SO_ERROR        = 4,
            SO_KEEPALIVE    = 9,
            SO_LINGER       = 13,
            SO_OOBINLINE    = 10,
            SO_RCVBUF       = 8,
            SO_RCVLOWAT     = 18,
            SO_RCVTIMEO     = 20,
            SO_REUSEADDR    = 2,
            SO_SNDBUF       = 7,
            SO_SNDLOWAT     = 19,
            SO_SNDTIMEO     = 21,
            SO_TYPE         = 3
        }
    }
    else
        static assert(0, "unimplemented");

    enum
    {
        SOMAXCONN       = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x08,
        MSG_DONTROUTE   = 0x04,
        MSG_EOR         = 0x80,
        MSG_OOB         = 0x01,
        MSG_PEEK        = 0x02,
        MSG_TRUNC       = 0x20,
        MSG_WAITALL     = 0x100,
        MSG_NOSIGNAL    = 0x4000
    }

    enum
    {
        AF_APPLETALK    = 5,
        AF_INET         = 2,
        AF_IPX          = 4,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0,
        PF_APPLETALK    = AF_APPLETALK,
        PF_IPX          = AF_IPX
    }

    enum int SOCK_RDM   = 4;

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    ssize_t recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    ssize_t sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (Darwin)
{
    alias uint   socklen_t;
    alias ubyte  sa_family_t;

    struct sockaddr
    {
        ubyte       sa_len;
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private enum : size_t
    {
        _SS_PAD1    = long.sizeof - ubyte.sizeof - sa_family_t.sizeof,
        _SS_PAD2    = 128 - ubyte.sizeof - sa_family_t.sizeof - _SS_PAD1 - long.sizeof
    }

    struct sockaddr_storage
    {
         ubyte          ss_len;
         sa_family_t    ss_family;
         byte[_SS_PAD1] __ss_pad1;
         long           __ss_align;
         byte[_SS_PAD2] __ss_pad2;
    }

    struct msghdr
    {
        void*     msg_name;
        socklen_t msg_namelen;
        iovec*    msg_iov;
        int       msg_iovlen;
        void*     msg_control;
        socklen_t msg_controllen;
        int       msg_flags;
    }

    struct cmsghdr
    {
         socklen_t cmsg_len;
         int       cmsg_level;
         int       cmsg_type;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    /+
    CMSG_DATA(cmsg)     ((unsigned char *)(cmsg) + \
                         ALIGN(sizeof(struct cmsghdr)))
    CMSG_NXTHDR(mhdr, cmsg) \
                        (((unsigned char *)(cmsg) + ALIGN((cmsg)->cmsg_len) + \
                         ALIGN(sizeof(struct cmsghdr)) > \
                         (unsigned char *)(mhdr)->msg_control +(mhdr)->msg_controllen) ? \
                         (struct cmsghdr *)0 /* NULL */ : \
                         (struct cmsghdr *)((unsigned char *)(cmsg) + ALIGN((cmsg)->cmsg_len)))
    CMSG_FIRSTHDR(mhdr) ((struct cmsghdr *)(mhdr)->msg_control)
    +/

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    enum
    {
        SOCK_DGRAM      = 2,
        SOCK_RDM        = 4,
        SOCK_SEQPACKET  = 5,
        SOCK_STREAM     = 1
    }

    enum : uint
    {
        SOL_SOCKET      = 0xffff
    }

    enum : uint
    {
        SO_ACCEPTCONN   = 0x0002,
        SO_BROADCAST    = 0x0020,
        SO_DEBUG        = 0x0001,
        SO_DONTROUTE    = 0x0010,
        SO_ERROR        = 0x1007,
        SO_KEEPALIVE    = 0x0008,
        SO_LINGER       = 0x1080,
        SO_NOSIGPIPE    = 0x1022, // non-standard
        SO_OOBINLINE    = 0x0100,
        SO_RCVBUF       = 0x1002,
        SO_RCVLOWAT     = 0x1004,
        SO_RCVTIMEO     = 0x1006,
        SO_REUSEADDR    = 0x0004,
        SO_REUSEPORT    = 0x0200,
        SO_SNDBUF       = 0x1001,
        SO_SNDLOWAT     = 0x1003,
        SO_SNDTIMEO     = 0x1005,
        SO_TYPE         = 0x1008
    }

    enum
    {
        SOMAXCONN       = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x20,
        MSG_DONTROUTE   = 0x4,
        MSG_EOR         = 0x8,
        MSG_OOB         = 0x1,
        MSG_PEEK        = 0x2,
        MSG_TRUNC       = 0x10,
        MSG_WAITALL     = 0x40
    }

    enum
    {
        AF_APPLETALK    = 16,
        AF_INET         = 2,
        AF_IPX          = 23,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0,
        PF_APPLETALK    = AF_APPLETALK,
        PF_IPX          = AF_IPX
    }

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    ssize_t recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    ssize_t sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (FreeBSD)
{
    alias uint   socklen_t;
    alias ubyte  sa_family_t;

    struct sockaddr
    {
        ubyte       sa_len;
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private
    {
        enum _SS_ALIGNSIZE  = long.sizeof;
        enum _SS_MAXSIZE    = 128;
        enum _SS_PAD1SIZE   = _SS_ALIGNSIZE - ubyte.sizeof - sa_family_t.sizeof;
        enum _SS_PAD2SIZE   = _SS_MAXSIZE - ubyte.sizeof - sa_family_t.sizeof - _SS_PAD1SIZE - _SS_ALIGNSIZE;
    }

    struct sockaddr_storage
    {
         ubyte              ss_len;
         sa_family_t        ss_family;
         byte[_SS_PAD1SIZE] __ss_pad1;
         long               __ss_align;
         byte[_SS_PAD2SIZE] __ss_pad2;
    }

    struct msghdr
    {
        void*     msg_name;
        socklen_t msg_namelen;
        iovec*    msg_iov;
        int       msg_iovlen;
        void*     msg_control;
        socklen_t msg_controllen;
        int       msg_flags;
    }

    struct cmsghdr
    {
         socklen_t cmsg_len;
         int       cmsg_level;
         int       cmsg_type;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    private // <machine/param.h>
    {
        enum _ALIGNBYTES = /+c_int+/ int.sizeof - 1;
        extern (D) size_t _ALIGN( size_t p ) { return (p + _ALIGNBYTES) & ~_ALIGNBYTES; }
    }

    extern (D) ubyte* CMSG_DATA( cmsghdr* cmsg )
    {
        return cast(ubyte*) cmsg + _ALIGN( cmsghdr.sizeof );
    }

    extern (D) cmsghdr* CMSG_NXTHDR( msghdr* mhdr, cmsghdr* cmsg )
    {
        if ( cmsg == null )
        {
           return CMSG_FIRSTHDR( mhdr );
        }
        else
        {
            if ( cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ) + _ALIGN( cmsghdr.sizeof ) >
                    cast(ubyte*) mhdr.msg_control + mhdr.msg_controllen )
                return null;
            else
                return cast(cmsghdr*) (cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ));
        }
    }

    extern (D) cmsghdr* CMSG_FIRSTHDR( msghdr* mhdr )
    {
        return mhdr.msg_controllen >= cmsghdr.sizeof ? cast(cmsghdr*) mhdr.msg_control : null;
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    enum
    {
        SOCK_DGRAM      = 2,
        SOCK_RDM        = 4,
        SOCK_SEQPACKET  = 5,
        SOCK_STREAM     = 1
    }

    enum : uint
    {
        SOL_SOCKET      = 0xffff
    }

    enum : uint
    {
        SO_ACCEPTCONN   = 0x0002,
        SO_BROADCAST    = 0x0020,
        SO_DEBUG        = 0x0001,
        SO_DONTROUTE    = 0x0010,
        SO_ERROR        = 0x1007,
        SO_KEEPALIVE    = 0x0008,
        SO_LINGER       = 0x0080,
        SO_NOSIGPIPE    = 0x0800, // non-standard
        SO_OOBINLINE    = 0x0100,
        SO_RCVBUF       = 0x1002,
        SO_RCVLOWAT     = 0x1004,
        SO_RCVTIMEO     = 0x1006,
        SO_REUSEADDR    = 0x0004,
        SO_REUSEPORT    = 0x0200,
        SO_SNDBUF       = 0x1001,
        SO_SNDLOWAT     = 0x1003,
        SO_SNDTIMEO     = 0x1005,
        SO_TYPE         = 0x1008
    }

    enum
    {
        SOMAXCONN       = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x20,
        MSG_DONTROUTE   = 0x4,
        MSG_EOR         = 0x8,
        MSG_OOB         = 0x1,
        MSG_PEEK        = 0x2,
        MSG_TRUNC       = 0x10,
        MSG_WAITALL     = 0x40,
        MSG_NOSIGNAL    = 0x20000
    }

    enum
    {
        AF_APPLETALK    = 16,
        AF_INET         = 2,
        AF_IPX          = 23,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0
    }

    enum
    {
        SHUT_RD = 0,
        SHUT_WR = 1,
        SHUT_RDWR = 2
    }

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    ssize_t recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    ssize_t sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (NetBSD)
{
    alias uint   socklen_t;
    alias ubyte  sa_family_t;

    struct sockaddr
    {
        ubyte       sa_len;
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private
    {
        enum _SS_ALIGNSIZE  = long.sizeof;
        enum _SS_MAXSIZE    = 128;
        enum _SS_PAD1SIZE   = _SS_ALIGNSIZE - ubyte.sizeof - sa_family_t.sizeof;
        enum _SS_PAD2SIZE   = _SS_MAXSIZE - ubyte.sizeof - sa_family_t.sizeof - _SS_PAD1SIZE - _SS_ALIGNSIZE;
    }

    struct sockaddr_storage
    {
         ubyte              ss_len;
         sa_family_t        ss_family;
         byte[_SS_PAD1SIZE] __ss_pad1;
         long               __ss_align;
         byte[_SS_PAD2SIZE] __ss_pad2;
    }

    struct msghdr
    {
        void*     msg_name;
        socklen_t msg_namelen;
        iovec*    msg_iov;
        int       msg_iovlen;
        void*     msg_control;
        socklen_t msg_controllen;
        int       msg_flags;
    }

    struct cmsghdr
    {
         socklen_t cmsg_len;
         int       cmsg_level;
         int       cmsg_type;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    private // <machine/param.h>
    {
        enum _ALIGNBYTES = /+c_int+/ int.sizeof - 1;
        extern (D) size_t _ALIGN( size_t p ) { return (p + _ALIGNBYTES) & ~_ALIGNBYTES; }
    }

    extern (D) ubyte* CMSG_DATA( cmsghdr* cmsg )
    {
        return cast(ubyte*) cmsg + _ALIGN( cmsghdr.sizeof );
    }

    extern (D) cmsghdr* CMSG_NXTHDR( msghdr* mhdr, cmsghdr* cmsg )
    {
        if ( cmsg == null )
        {
           return CMSG_FIRSTHDR( mhdr );
        }
        else
        {
            if ( cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ) + _ALIGN( cmsghdr.sizeof ) >
                    cast(ubyte*) mhdr.msg_control + mhdr.msg_controllen )
                return null;
            else
                return cast(cmsghdr*) (cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ));
        }
    }

    extern (D) cmsghdr* CMSG_FIRSTHDR( msghdr* mhdr )
    {
        return mhdr.msg_controllen >= cmsghdr.sizeof ? cast(cmsghdr*) mhdr.msg_control : null;
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    enum
    {
        SOCK_DGRAM      = 2,
        SOCK_RDM        = 4,
        SOCK_SEQPACKET  = 5,
        SOCK_STREAM     = 1
    }

    enum : uint
    {
        SOL_SOCKET      = 0xffff
    }

    enum : uint
    {
         SO_DEBUG        = 0x0001,          /* turn on debugging info recording */
         SO_ACCEPTCONN   = 0x0002,          /* socket has had listen() */
         SO_REUSEADDR    = 0x0004,          /* allow local address reuse */
         SO_KEEPALIVE    = 0x0008,          /* keep connections alive */
         SO_DONTROUTE    = 0x0010,          /* just use interface addresses */
         SO_BROADCAST    = 0x0020,          /* permit sending of broadcast msgs */
         SO_USELOOPBACK  = 0x0040,          /* bypass hardware when possible */
         SO_LINGER       = 0x0080,          /* linger on close if data present */
         SO_OOBINLINE    = 0x0100,          /* leave received OOB data in line */
         SO_REUSEPORT    = 0x0200,          /* allow local address & port reuse */
        /*      SO_OTIMESTAMP   0x0400          */
         SO_NOSIGPIPE    = 0x0800,          /* no SIGPIPE from EPIPE */
         SO_ACCEPTFILTER = 0x1000,          /* there is an accept filter */
         SO_TIMESTAMP    = 0x2000,          /* timestamp received dgram traffic */

        /*
         * Additional options, not kept in so_options.
         */
         SO_SNDBUF       = 0x1001,          /* send buffer size */
         SO_RCVBUF       = 0x1002,          /* receive buffer size */
         SO_SNDLOWAT     = 0x1003,          /* send low-water mark */
         SO_RCVLOWAT     = 0x1004,          /* receive low-water mark */
        /* SO_OSNDTIMEO         0x1005 */
        /* SO_ORCVTIMEO         0x1006 */
         SO_ERROR        = 0x1007,          /* get error status and clear */
         SO_TYPE         = 0x1008,          /* get socket type */
         SO_OVERFLOWED   = 0x1009,          /* datagrams: return packets dropped */

         SO_NOHEADER     = 0x100a,          /* user supplies no header to kernel;
                                                 * kernel removes header and supplies
                                                 * payload
                                                 */
         SO_SNDTIMEO     = 0x100b,          /* send timeout */
         SO_RCVTIMEO     = 0x100c          /* receive timeout */

    }

    enum
    {
        SOMAXCONN       = 128
    }

    enum : uint
    {
         MSG_OOB         = 0x0001,          /* process out-of-band data */
         MSG_PEEK        = 0x0002,          /* peek at incoming message */
         MSG_DONTROUTE   = 0x0004,          /* send without using routing tables */
         MSG_EOR         = 0x0008,          /* data completes record */
         MSG_TRUNC       = 0x0010,          /* data discarded before delivery */
         MSG_CTRUNC      = 0x0020,          /* control data lost before delivery */
         MSG_WAITALL     = 0x0040,          /* wait for full request or error */
         MSG_DONTWAIT    = 0x0080,          /* this message should be nonblocking */
         MSG_BCAST       = 0x0100,          /* this message was rcvd using link-level brdcst */
         MSG_MCAST       = 0x0200,          /* this message was rcvd using link-level mcast */
         MSG_NOSIGNAL    = 0x0400          /* do not generate SIGPIPE on EOF */
    }

    enum
    {
        AF_APPLETALK    = 16,
        AF_INET         = 2,
        AF_IPX          = 23,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0
    }

    enum
    {
        SHUT_RD = 0,
        SHUT_WR = 1,
        SHUT_RDWR = 2
    }

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    ssize_t recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    ssize_t sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (DragonFlyBSD)
{
    alias uint   socklen_t;
    alias ubyte  sa_family_t;

    enum
    {
        SOCK_STREAM         = 1,
        SOCK_DGRAM          = 2,
        //SOCK_RAW          = 3,      // defined below
        SOCK_RDM            = 4,
        SOCK_SEQPACKET      = 5,
    }

    enum SOCK_CLOEXEC       = 0x10000000;
    enum SOCK_NONBLOCK      = 0x20000000;

    enum : uint
    {
        SO_DEBUG            = 0x0001,
        SO_ACCEPTCONN       = 0x0002,
        SO_REUSEADDR        = 0x0004,
        SO_KEEPALIVE        = 0x0008,
        SO_DONTROUTE        = 0x0010,
        SO_BROADCAST        = 0x0020,
        SO_USELOOPBACK      = 0x0040,
        SO_LINGER           = 0x0080,
        SO_OOBINLINE        = 0x0100,
        SO_REUSEPORT        = 0x0200,
        SO_TIMESTAMP        = 0x0400,
        SO_NOSIGPIPE        = 0x0800, // non-standard
        SO_ACCEPTFILTER     = 0x1000,

        SO_SNDBUF           = 0x1001,
        SO_RCVBUF           = 0x1002,
        SO_SNDLOWAT         = 0x1003,
        SO_RCVLOWAT         = 0x1004,
        SO_SNDTIMEO         = 0x1005,
        SO_RCVTIMEO         = 0x1006,
        SO_ERROR            = 0x1007,
        SO_TYPE             = 0x1008,
        SO_SNDSPACE         = 0x100a, // get appr. send buffer free space
        SO_CPUHINT          = 0x1030, // get socket's owner cpuid hint
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    struct  accept_filter_arg {
        byte[16] af_name;
        byte[256-16] af_arg;
    }

    enum : uint
    {
        SOL_SOCKET          = 0xffff
    }

    enum
    {
        AF_UNSPEC           = 0,
        AF_LOCAL            = 1,
        AF_UNIX             = AF_LOCAL,
        AF_INET             = 2,
        AF_IMPLINK          = 3,
        AF_PUP              = 4,
        AF_CHAOS            = 5,
        AF_NETBIOS          = 6,
        AF_ISO              = 7,
        AF_OSI              = AF_ISO,
        AF_ECMA             = 8,
        AF_DATAKIT          = 9,
        AF_CCITT            = 10,
        AF_SNA              = 11,
        AF_DECnet           = 12,
        AF_DLI              = 13,
        AF_LAT              = 14,
        AF_HYLINK           = 15,
        AF_APPLETALK        = 16,
        AF_ROUTE            = 17,
        AF_LINK             = 18,
        pseudo_AF_XTP       = 19,
        AF_COIP             = 20,
        AF_CNT              = 21,
        pseudo_AF_RTIP      = 22,
        AF_IPX              = 23,
        AF_SIP              = 24,
        pseudo_AF_PIP       = 25,
        AF_ISDN             = 26,
        AF_E164             = AF_ISDN,
        pseudo_AF_KEY       = 27,
        //AF_INET6            = 28,   // defined below
        AF_NATM             = 29,
        AF_ATM              = 30,
        pseudo_AF_HDRCMPLT  = 31,
        AF_NETGRAPH         = 32,
        AF_BLUETOOTH        = 33,
        AF_MPLS             = 34,
        AF_IEEE80211        = 35,
    }

    struct sockaddr
    {
        ubyte               sa_len;
        sa_family_t         sa_family;
        byte[14]            sa_data;
    }

    enum SOCK_MAXADDRLEN = 255;

    struct sockproto {
        ushort              sp_family;
        ushort              sp_protocol;
    }

    private
    {
        enum _SS_ALIGNSIZE  = long.sizeof;
        enum _SS_MAXSIZE    = 128;
        enum _SS_PAD1SIZE   = _SS_ALIGNSIZE - ubyte.sizeof - sa_family_t.sizeof;
        enum _SS_PAD2SIZE   = _SS_MAXSIZE - ubyte.sizeof - sa_family_t.sizeof - _SS_PAD1SIZE - _SS_ALIGNSIZE;
    }

    struct sockaddr_storage
    {
        ubyte              ss_len;
        sa_family_t        ss_family;
        byte[_SS_PAD1SIZE] __ss_pad1;
        long               __ss_align;
        byte[_SS_PAD2SIZE] __ss_pad2;
    }

    /* protocol families */
    enum PF_UNSPEC          = AF_UNSPEC;
    enum PF_LOCAL           = AF_LOCAL;
    enum PF_UNIX            = PF_LOCAL;
    enum PF_INET            = AF_INET;
    enum PF_IMPLINK         = AF_IMPLINK;
    enum PF_PUP             = AF_PUP;
    enum PF_CHAOS           = AF_CHAOS;
    enum PF_NETBIOS         = AF_NETBIOS;
    enum PF_ISO             = AF_ISO;
    enum PF_OSI             = AF_ISO;
    enum PF_ECMA            = AF_ECMA;
    enum PF_DATAKIT         = AF_DATAKIT;
    enum PF_CCITT           = AF_CCITT;
    enum PF_SNA             = AF_SNA;
    enum PF_DECnet          = AF_DECnet;
    enum PF_DLI             = AF_DLI;
    enum PF_LAT             = AF_LAT;
    enum PF_HYLINK          = AF_HYLINK;
    enum PF_APPLETALK       = AF_APPLETALK;
    enum PF_ROUTE           = AF_ROUTE;
    enum PF_LINK            = AF_LINK;
    enum PF_XTP             = pseudo_AF_XTP;
    enum PF_COIP            = AF_COIP;
    enum PF_CNT             = AF_CNT;
    enum PF_SIP             = AF_SIP;
    enum PF_IPX             = AF_IPX;
    enum PF_RTIP            = pseudo_AF_RTIP;
    enum PF_PIP             = pseudo_AF_PIP;
    enum PF_ISDN            = AF_ISDN;
    enum PF_KEY             = pseudo_AF_KEY;
    enum PF_INET6           = AF_INET6;
    enum PF_NATM            = AF_NATM;
    enum PF_ATM             = AF_ATM;
    enum PF_NETGRAPH        = AF_NETGRAPH;
    enum PF_BLUETOOTH       = AF_BLUETOOTH;

    struct msghdr
    {
        void*               msg_name;
        socklen_t           msg_namelen;
        iovec*              msg_iov;
        int                 msg_iovlen;
        void*               msg_control;
        socklen_t           msg_controllen;
        int                 msg_flags;
    }

    enum SOMAXCONN          = 128;
    enum SOMAXOPT_SIZE      = 65536;
    enum SOMAXOPT_SIZE0     = (32 * 1024 * 1024);

    enum : uint
    {
        MSG_OOB             = 0x00000001,
        MSG_PEEK            = 0x00000002,
        MSG_DONTROUTE       = 0x00000004,
        MSG_EOR             = 0x00000008,
        MSG_TRUNC           = 0x00000010,
        MSG_CTRUNC          = 0x00000020,
        MSG_WAITALL         = 0x00000040,
        MSG_DONTWAIT        = 0x00000080,
        MSG_EOF             = 0x00000100,
        MSG_UNUSED09        = 0x00000200,
        MSG_NOSIGNAL        = 0x00000400,
        MSG_SYNC            = 0x00000800,
        MSG_CMSG_CLOEXEC    = 0x00001000,
        /* These override FIONBIO.  MSG_FNONBLOCKING is functionally equivalent to MSG_DONTWAIT.*/
        MSG_FBLOCKING       = 0x00010000,
        MSG_FNONBLOCKING    = 0x00020000,
        MSG_FMASK           = 0xFFFF0000,
    }

    struct cmsghdr
    {
         socklen_t          cmsg_len;
         int                cmsg_level;
         int                cmsg_type;
    }

    enum CMGROUP_MAX        = 16;

    struct cmsgcred {
            pid_t           cmcred_pid;
            uid_t           cmcred_uid;
            uid_t           cmcred_euid;
            gid_t           cmcred_gid;
            short           cmcred_ngroups;
            gid_t[CMGROUP_MAX] cmcred_groups;
    };

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    private // <machine/param.h>
    {
        enum _ALIGNBYTES = /+c_int+/ int.sizeof - 1;
        extern (D) size_t _ALIGN( size_t p ) { return (p + _ALIGNBYTES) & ~_ALIGNBYTES; }
    }

    extern (D) ubyte* CMSG_DATA( cmsghdr* cmsg )
    {
        return cast(ubyte*) cmsg + _ALIGN( cmsghdr.sizeof );
    }

    extern (D) cmsghdr* CMSG_NXTHDR( msghdr* mhdr, cmsghdr* cmsg )
    {
        if ( cmsg == null )
        {
           return CMSG_FIRSTHDR( mhdr );
        }
        else
        {
            if ( cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ) + _ALIGN( cmsghdr.sizeof ) >
                    cast(ubyte*) mhdr.msg_control + mhdr.msg_controllen )
                return null;
            else
                return cast(cmsghdr*) (cast(ubyte*) cmsg + _ALIGN( cmsg.cmsg_len ));
        }
    }

    extern (D) cmsghdr* CMSG_FIRSTHDR( msghdr* mhdr )
    {
        return mhdr.msg_controllen >= cmsghdr.sizeof ? cast(cmsghdr*) mhdr.msg_control : null;
    }

    enum
    {
        SHUT_RD             = 0,
        SHUT_WR             = 1,
        SHUT_RDWR           = 2
    }

/*
    /+ sendfile(2) header/trailer struct +/
    struct sf_hdtr {
        iovec *             headers;
        int                 hdr_cnt;
        iovec *             trailers;
        int                 trl_cnt;
    };
*/

    int     accept(int, sockaddr*, socklen_t*);
//    int     accept4(int, sockaddr*, socklen_t*, int);
    int     bind(int, in sockaddr*, socklen_t);
    int     connect(int, in sockaddr*, socklen_t);
//    int     extconnect(int, int, sockaddr*, socklen_t);
    int     getpeername(int, sockaddr*, socklen_t*);
    int     getsockname(int, sockaddr*, socklen_t*);
    int     getsockopt(int, int, int, void*, socklen_t*);
    int     listen(int, int);
    ssize_t recv(int, void*, size_t, int);
    ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);
    ssize_t recvmsg(int, msghdr*, int);
    ssize_t send(int, in void*, size_t, int);
    ssize_t sendto(int, in void*, size_t, int, in sockaddr*, socklen_t);
    ssize_t sendmsg(int, in msghdr*, int);
//    int     sendfile(int, int, off_t, size_t, sf_hdtr *, off_t *, int);
    int     setsockopt(int, int, int, in void*, socklen_t);
    int     shutdown(int, int);
    int     sockatmark(int);
    int     socket(int, int, int);
    int     socketpair(int, int, int, ref int[2]);
//  void    pfctlinput(int, struct sockaddr *);
}
else version (Solaris)
{
    alias uint socklen_t;
    alias ushort sa_family_t;

    struct sockaddr
    {
        sa_family_t sa_family;
        char[14] sa_data = 0;
    }

    alias double sockaddr_maxalign_t;

    private
    {
        enum _SS_ALIGNSIZE  = sockaddr_maxalign_t.sizeof;
        enum _SS_MAXSIZE    = 256;
        enum _SS_PAD1SIZE   = _SS_ALIGNSIZE - sa_family_t.sizeof;
        enum _SS_PAD2SIZE   = _SS_MAXSIZE - sa_family_t.sizeof + _SS_PAD1SIZE + _SS_ALIGNSIZE;
    }

    struct sockaddr_storage
    {
         sa_family_t ss_family;
         char[_SS_PAD1SIZE] _ss_pad1 = void;
         sockaddr_maxalign_t _ss_align;
         char[_SS_PAD2SIZE] _ss_pad2 = void;
    }

    struct msghdr
    {
        void* msg_name;
        socklen_t msg_namelen;
        iovec* msg_iov;
        int msg_iovlen;
        void* msg_control;
        socklen_t msg_controllen;
        int msg_flags;
    }

    struct cmsghdr
    {
         socklen_t cmsg_len;
         int cmsg_level;
         int cmsg_type;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x1010
    }

    // FIXME: CMSG_DATA, CMSG_NXTHDR, CMSG_FIRSTHDR missing

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    enum
    {
        SOCK_STREAM = 2,
        SOCK_DGRAM = 1,
        SOCK_RDM = 5,
        SOCK_SEQPACKET = 6,
    }

    enum : uint
    {
        SOL_SOCKET      = 0xffff
    }

    enum : uint
    {
        SO_ACCEPTCONN   = 0x0002,
        SO_BROADCAST    = 0x0020,
        SO_DEBUG        = 0x0001,
        SO_DONTROUTE    = 0x0010,
        SO_ERROR        = 0x1007,
        SO_KEEPALIVE    = 0x0008,
        SO_LINGER       = 0x0080,
        SO_OOBINLINE    = 0x0100,
        SO_RCVBUF       = 0x1002,
        SO_RCVLOWAT     = 0x1004,
        SO_RCVTIMEO     = 0x1006,
        SO_REUSEADDR    = 0x0004,
        SO_SNDBUF       = 0x1001,
        SO_SNDLOWAT     = 0x1003,
        SO_SNDTIMEO     = 0x1005,
        SO_TYPE         = 0x1008,

        SO_USELOOPBACK  = 0x0040, // non-standard
        SO_DGRAM_ERRIND = 0x0200, // non-standard
        SO_RECVUCRED    = 0x0400, // non-standard
    }

    enum
    {
        SOMAXCONN = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x10,
        MSG_DONTROUTE   = 0x4,
        MSG_EOR         = 0x8,
        MSG_OOB         = 0x1,
        MSG_PEEK        = 0x2,
        MSG_TRUNC       = 0x20,
        MSG_WAITALL     = 0x40
    }

    enum
    {
        AF_IPX          = 23,
        AF_APPLETALK    = 16,
        AF_INET         = 2,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0
    }

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    ssize_t recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    ssize_t sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (CRuntime_Bionic)
{
    alias int    socklen_t;
    alias ushort sa_family_t;

    struct sockaddr
    {
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private enum size_t _K_SS_MAXSIZE  = 128;

    struct sockaddr_storage
    {
        ushort ss_family;
        byte[_K_SS_MAXSIZE - ushort.sizeof] __data;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    private enum _ALIGNBYTES = c_long.sizeof - 1;

    extern (D)
    {
        size_t CMSG_ALIGN( size_t len )
        {
            return (len + _ALIGNBYTES) & ~_ALIGNBYTES;
        }

        void* CMSG_DATA( cmsghdr* cmsg )
        {
            return cast(void*) (cast(char*) cmsg + CMSG_ALIGN( cmsghdr.sizeof ));
        }

        cmsghdr* CMSG_NXTHDR( msghdr* mhdr, cmsghdr* cmsg )
        {
            cmsghdr* __ptr = cast(cmsghdr*) ((cast(ubyte*) cmsg) + CMSG_ALIGN(cmsg.cmsg_len));
            return cast(c_ulong)( cast(char*)(__ptr+1) - cast(char*) mhdr.msg_control) > mhdr.msg_controllen ? null : __ptr;
        }

        cmsghdr* CMSG_FIRSTHDR( msghdr* mhdr )
        {
            return mhdr.msg_controllen >= cmsghdr.sizeof ? cast(cmsghdr*) mhdr.msg_control : null;
        }
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    struct msghdr
    {
        void*           msg_name;
        int             msg_namelen;
        iovec*          msg_iov;
        __kernel_size_t msg_iovlen;
        void*           msg_control;
        __kernel_size_t msg_controllen;
        uint            msg_flags;
    }

    struct cmsghdr
    {
        __kernel_size_t cmsg_len;
        int             cmsg_level;
        int             cmsg_type;
    }

    alias size_t __kernel_size_t;

    enum
    {
        SOCK_DGRAM      = 2,
        SOCK_SEQPACKET  = 5,
        SOCK_STREAM     = 1
    }

    enum
    {
        SOL_SOCKET      = 1
    }

    enum
    {
        SO_ACCEPTCONN   = 30,
        SO_BROADCAST    = 6,
        SO_DEBUG        = 1,
        SO_DONTROUTE    = 5,
        SO_ERROR        = 4,
        SO_KEEPALIVE    = 9,
        SO_LINGER       = 13,
        SO_OOBINLINE    = 10,
        SO_RCVBUF       = 8,
        SO_RCVLOWAT     = 18,
        SO_RCVTIMEO     = 20,
        SO_REUSEADDR    = 2,
        SO_SNDBUF       = 7,
        SO_SNDLOWAT     = 19,
        SO_SNDTIMEO     = 21,
        SO_TYPE         = 3
    }

    enum
    {
        SOMAXCONN       = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x08,
        MSG_DONTROUTE   = 0x04,
        MSG_EOR         = 0x80,
        MSG_OOB         = 0x01,
        MSG_PEEK        = 0x02,
        MSG_TRUNC       = 0x20,
        MSG_WAITALL     = 0x100
    }

    enum
    {
        AF_APPLETALK    = 5,
        AF_INET         = 2,
        AF_IPX          = 4,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0
    }

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    enum SOCK_RDM = 4;

    int     accept(int, scope sockaddr*, scope socklen_t*);
    int     bind(int, const scope sockaddr*, socklen_t);
    int     connect(int, const scope sockaddr*, socklen_t);
    int     getpeername(int, scope sockaddr*, scope socklen_t*);
    int     getsockname(int, scope sockaddr*, scope socklen_t*);
    int     getsockopt(int, int, int, scope void*, scope socklen_t*);
    int     listen(int, int) @safe;
    ssize_t recv(int, scope void*, size_t, int);
    ssize_t recvfrom(int, scope void*, size_t, int, scope sockaddr*, scope socklen_t*);
    int     recvmsg(int, scope msghdr*, int);
    ssize_t send(int, const scope void*, size_t, int);
    int     sendmsg(int, const scope msghdr*, int);
    ssize_t sendto(int, const scope void*, size_t, int, const scope sockaddr*, socklen_t);
    int     setsockopt(int, int, int, const scope void*, socklen_t);
    int     shutdown(int, int) @safe;
    int     socket(int, int, int) @safe;
    int     sockatmark(int) @safe;
    int     socketpair(int, int, int, ref int[2]) @safe;
}
else version (CRuntime_Musl)
{
    alias uint socklen_t;
    alias ushort sa_family_t;

    struct sockaddr
    {
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private enum : size_t
    {
        _SS_SIZE    = 128,
        _SS_PADSIZE = _SS_SIZE - c_ulong.sizeof - sa_family_t.sizeof
    }

    struct sockaddr_storage
    {
        sa_family_t ss_family;
        byte[_SS_PADSIZE] __ss_padding;
        c_ulong     __ss_align;
    }

    enum {
        SOCK_STREAM = 1,
        SOCK_DGRAM = 2,
        SOCK_RAW = 3,
        SOCK_RDM = 4,
        SOCK_SEQPACKET = 5,
        SOCK_DCCP = 6,
        SOCK_PACKET = 10
    }
    enum
    {
        AF_UNSPEC       = 0,
        AF_LOCAL        = 1,
        AF_UNIX         = AF_LOCAL,
        AF_FILE         = AF_LOCAL,
        AF_INET         = 2,
        AF_AX25         = 3,
        AF_IPX          = 4,
        AF_APPLETALK    = 5,
        PF_APPLETALK    = AF_APPLETALK,
        PF_IPX          = AF_IPX
    }

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    enum
    {
        SOL_SOCKET      = 1
    }

    enum
    {
        SO_DEBUG        = 1,
        SO_REUSEADDR    = 2,
        SO_TYPE         = 3,
        SO_ERROR        = 4,
        SO_DONTROUTE    = 5,
        SO_BROADCAST    = 6,
        SO_SNDBUF       = 7,
        SO_RCVBUF       = 8,
        SO_KEEPALIVE    = 9,
        SO_OOBINLINE    = 10,
        SO_LINGER       = 13,
        SO_RCVLOWAT     = 18,
        SO_SNDLOWAT     = 19,
        SO_RCVTIMEO     = 20,
        SO_SNDTIMEO     = 21,
        SO_ACCEPTCONN   = 30
    }

    enum : uint
    {
        MSG_OOB         = 0x01,
        MSG_PEEK        = 0x02,
        MSG_DONTROUTE   = 0x04,
        MSG_CTRUNC      = 0x08,
        MSG_TRUNC       = 0x20,
        MSG_EOR         = 0x80,
        MSG_WAITALL     = 0x100,
        MSG_NOSIGNAL    = 0x4000
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }
    struct msghdr {
   V-  W-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               void *msg_name;
        socklen_t msg_namelen;
        iovec *msg_iov;
        int msg_iovlen, __pad1;
        void *msg_control;
        socklen_t msg_controllen, __pad2;
        int msg_flags;
    }
    int     accept(int, sockaddr*, socklen_t*);
    int     bind(int, in sockaddr*, socklen_t);
    int     connect(int, in sockaddr*, socklen_t);
    int     getpeername(int, sockaddr*, socklen_t*);
    int     getsockname(int, sockaddr*, socklen_t*);
    int     getsockopt(int, int, int, void*, socklen_t*);
    int     listen(int, int);
    ssize_t recv(int, void*, size_t, int);
    ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);
    ssize_t recvmsg(int, msghdr*, int);
    ssize_t send(int, in void*, size_t, int);
    ssize_t sendmsg(int, in msghdr*, int);
    ssize_t sendto(int, in void*, size_t, int, in sockaddr*, socklen_t);
    int     setsockopt(int, int, int, in void*, socklen_t);
    int     shutdown(int, int);
    int     socket(int, int, int);
    int     sockatmark(int);
    int     socketpair(int, int, int, ref int[2]);
}
else version (CRuntime_UClibc)
{
    alias uint   socklen_t;
    alias ushort sa_family_t;

    struct sockaddr
    {
        sa_family_t sa_family;
        byte[14]    sa_data;
    }

    private enum : size_t
    {
        _SS_SIZE    = 128,
        _SS_PADSIZE = _SS_SIZE - (c_ulong.sizeof * 2)
    }

    struct sockaddr_storage
    {
        sa_family_t ss_family;
        c_ulong     __ss_align;
        byte[_SS_PADSIZE] __ss_padding;
    }

    struct msghdr
    {
        void*     msg_name;
        socklen_t msg_namelen;
        iovec*    msg_iov;
        size_t    msg_iovlen;
        void*     msg_control;
        size_t    msg_controllen;
        int       msg_flags;
    }

    struct cmsghdr
    {
        size_t cmsg_len;
        int    cmsg_level;
        int    cmsg_type;
    }

    enum : uint
    {
        SCM_RIGHTS = 0x01
    }

    extern (D) inout(ubyte)*   CMSG_DATA( inout(cmsghdr)* cmsg ) pure nothrow @nogc { return cast(ubyte*)( cmsg + 1 ); }

    private inout(cmsghdr)* __cmsg_nxthdr(inout(msghdr)*, inout(cmsghdr)*) pure nothrow @nogc;
    extern (D)  inout(cmsghdr)* CMSG_NXTHDR(inout(msghdr)* msg, inout(cmsghdr)* cmsg) pure nothrow @nogc
    {
        return __cmsg_nxthdr(msg, cmsg);
    }

    extern (D) inout(cmsghdr)* CMSG_FIRSTHDR( inout(msghdr)* mhdr ) pure nothrow @nogc
    {
        return ( cast(size_t)mhdr.msg_controllen >= cmsghdr.sizeof
                             ? cast(inout(cmsghdr)*) mhdr.msg_control
                             : cast(inout(cmsghdr)*) null );
    }

    extern (D)
    {
        size_t CMSG_ALIGN( size_t len ) pure nothrow @nogc
        {
            return (len + size_t.sizeof - 1) & cast(size_t) (~(size_t.sizeof - 1));
        }

        size_t CMSG_LEN( size_t len ) pure nothrow @nogc
        {
            return CMSG_ALIGN(cmsghdr.sizeof) + len;
        }
    }

    extern (D) size_t CMSG_SPACE(size_t len) pure nothrow @nogc
    {
        return CMSG_ALIGN(len) + CMSG_ALIGN(cmsghdr.sizeof);
    }

    struct linger
    {
        int l_onoff;
        int l_linger;
    }

    version (X86_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1,
            SOCK_CLOEXEC    = 0x80000, // octal 02000000
            SOCK_NONBLOCK   = 0x800 // octal 00004000
        }
    }
    else version (MIPS_Any)
    {
        enum
        {
            SOCK_DGRAM      = 1,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 2,
            SOCK_CLOEXEC    = 0x80000, // octal 02000000
            SOCK_NONBLOCK   = 0x80 // octal 00000200
        }
    }
    else version (ARM_Any)
    {
        enum
        {
            SOCK_DGRAM      = 2,
            SOCK_SEQPACKET  = 5,
            SOCK_STREAM     = 1,
            SOCK_CLOEXEC    = 0x80000, // octal 02000000
            SOCK_NONBLOCK   = 0x800 // octal 00004000
        }
    }
    else
        static assert(0, "unimplemented");

    enum
    {
        SO_ACCEPTCONN   = 30,
        SO_BROADCAST    = 6,
        SO_DEBUG        = 1,
        SO_DONTROUTE    = 5,
        SO_ERROR        = 4,
        SO_KEEPALIVE    = 9,
        SO_LINGER       = 13,
        SO_OOBINLINE    = 10,
        SO_RCVBUF       = 8,
        SO_RCVLOWAT     = 18,
        SO_RCVTIMEO     = 20,
        SO_REUSEADDR    = 2,
        SO_SNDBUF       = 7,
        SO_SNDLOWAT     = 19,
        SO_SNDTIMEO     = 21,
        SO_TYPE         = 3,

        SOL_SOCKET      = 1,
        SOL_TCP         = 6,
        SOMAXCONN       = 128
    }

    enum : uint
    {
        MSG_CTRUNC      = 0x08,
        MSG_DONTROUTE   = 0x04,
        MSG_EOR         = 0x80,
        MSG_OOB         = 0x01,
        MSG_PEEK        = 0x02,
        MSG_TRUNC       = 0x20,
        MSG_WAITALL     = 0x100,
        MSG_NOSIGNAL    = 0x4000
    }

    enum
    {
        AF_APPLETALK    = 5,
        AF_INET         = 2,
        AF_IPX          = 4,
        AF_UNIX         = 1,
        AF_UNSPEC       = 0,
        PF_APPLETALK    = AF_APPLETALK,
        PF_IPX          = AF_IPX
    }

    enum int SOCK_RDM   = 4;

    enum
    {
        SHUT_RD,
        SHUT_WR,
        SHUT_RDWR
    }

    int     accept(int, sockaddr*, socklen_t*);
    int     bind(int, in sockaddr*, socklen_t);
    int     connect(int, in sockaddr*, socklen_t);
    int     getpeername(int, sockaddr*, socklen_t*);
    int     getsockname(int, sockaddr*, socklen_t*);
    int     getsockopt(int, int, int, void*, socklen_t*);
    int     listen(int, int);
    ssize_t recv(int, void*, size_t, int);
    ssize_t recvfrom(int, void*, size_t, int, sockaddr*, socklen_t*);
    ssize_t recvmsg(int, msghdr*, int);
    ssize_t send(int, in void*, size_t, int);
    ssize_t sendmsg(int, in msghdr*, int);
    ssize_t sendto(int, in void*, size_t, int, in sockaddr*, socklen_t);
    int     setsockopt(int, int, int, in void*, socklen_t);
    int     shutdown(int, int);
    int     socket(int, int, int);
    int     sockatmark(int);
    int     socketpair(int, int, int, ref int[2]);
}
else
{
    static assert(false, "Unsupported platform");
}

//
// IPV6 (IP6)
//
/*
AF_INET6
*/

version (CRuntime_Glibc)
{
    enum
    {
        AF_INET6    = 10
    }
}
else version (Darwin)
{
    enum
    {
        AF_INET6    = 30
    }
}
else version (FreeBSD)
{
    enum
    {
        AF_INET6    = 28
    }
}
else version (NetBSD)
{
    enum
    {
        AF_INET6    = 24
    }
}
else version (DragonFlyBSD)
{
    enum
    {
        AF_INET6    = 28
    }
}
else version (Solaris)
{
    enum
    {
        AF_INET6 = 26,
    }
}
else version (CRuntime_Bionic)
{
    enum
    {
        AF_INET6    = 10
    }
}
else version (CRuntime_Musl)
{
    enum AF_INET6 = 10;
}
else version (CRuntime_UClibc)
{
    enum
    {
        AF_INET6    = 10
    }
}
else
{
    static assert(false, "Unsupported platform");
}

//
// Raw Sockets (RS)
//
/*
SOCK_RAW
*/

version (CRuntime_Glibc)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (Darwin)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (FreeBSD)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (NetBSD)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (DragonFlyBSD)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (Solaris)
{
    enum
    {
        SOCK_RAW = 4,
    }
}
else version (CRuntime_Bionic)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else version (CRuntime_Musl)
{
}
else version (CRuntime_UClibc)
{
    enum
    {
        SOCK_RAW    = 3
    }
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.stat;

private import core.sys.posix.config;
private import core.stdc.stdint;
private import core.sys.posix.time;     // for timespec
public import core.sys.posix.sys.types; // for off_t, mode_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (RISCV32) version = RISCV_Any;
version (RISCV64) version = RISCV_Any;

version (Posix):
extern (C) nothrow @nogc:

//
// Required
//
/*
struct stat
{
    dev_t   st_dev;
    ino_t   st_ino;
    mode_t  st_mode;
    nlink_t st_nlink;
    uid_t   st_uid;
    gid_t   st_gid;
    off_t   st_size;
    time_t  st_atime;
    time_t  st_mtime;
    time_t  st_ctime;
}

S_IRWXU
    S_IRUSR
    S_IWUSR
    S_IXUSR
S_IRWXG
    S_IRGRP
    S_IWGRP
    S_IXGRP
S_IRWXO
    S_IROTH
    S_IWOTH
    S_IXOTH
S_ISUID
S_ISGID
S_ISVTX

S_ISBLK(m)
S_ISCHR(m)
S_ISDIR(m)
S_ISFIFO(m)
S_ISREG(m)
S_ISLNK(m)
S_ISSOCK(m)

S_TYPEISMQ(buf)
S_TYPEISSEM(buf)
S_TYPEISSHM(buf)

int    chmod(in char*, mode_t);
int    fchmod(int, mode_t);
int    fstat(int, stat*);
int    lstat(in char*, stat*);
int    mkdir(in char*, mode_t);
int    mkfifo(in char*, mode_t);
int    stat(in char*, stat*);
mode_t umask(mode_t);
 */

version (CRuntime_Glibc)
{
    version (X86)
    {
        struct stat_t
        {
            dev_t       st_dev;
            ushort      __pad1;
            static if (!__USE_FILE_OFFSET64)
            {
                ino_t       st_ino;
            }
            else
            {
                uint        __st_ino;
            }
            mode_t      st_mode;
            nlink_t     st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            dev_t       st_rdev;
            ushort      __pad2;
            off_t       st_size;
            blksize_t   st_blksize;
            blkcnt_t    st_blocks;
            static if (__USE_MISC || __USE_XOPEN2K8)
            {
                timespec    st_atim;
                timespec    st_mtim;
                timespec    st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                time_t      st_atime;
                ulong_t     st_atimensec;
                time_t      st_mtime;
                ulong_t     st_mtimensec;
                time_t      st_ctime;
                ulong_t     st_ctimensec;
            }
            static if (__USE_FILE_OFFSET64)
            {
                ino_t       st_ino;
            }
            else
            {
                c_ulong     __unused4;
                c_ulong     __unused5;
            }
        }
    }
    else version (X86_64)
    {
        struct stat_t
        {
            dev_t       st_dev;
            ino_t       st_ino;
            nlink_t     st_nlink;
            mode_t      st_mode;
            uid_t       st_uid;
            gid_t       st_gid;
            uint        __pad0;
            dev_t       st_rdev;
            off_t       st_size;
            blksize_t   st_blksize;
            blkcnt_t    st_blocks;
            static if (__USE_MISC || __USE_XOPEN2K8)
            {
                timespec    st_atim;
                timespec    st_mtim;
                timespec    st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                time_t      st_atime;
                ulong_t     st_atimensec;
                time_t      st_mtime;
                ulong_t     st_mtimensec;
                time_t      st_ctime;
                ulong_t     st_ctimensec;
            }
            slong_t[3]     __unused;
        }
    }
    else version (HPPA)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = size_t;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            ushort __pad1;

            static if (!__USE_FILE_OFFSET64)
            {
                __ino_t st_ino;
            }
            else
            {
                __ino_t __st_ino;
            }
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            ushort __pad2;

            static if (!__USE_FILE_OFFSET64)
            {
                __off_t st_size;
            }
            else
            {
                __off64_t st_size;
            }
            __blksize_t st_blksize;

            static if (!__USE_FILE_OFFSET64)
            {
                __blkcnt_t st_blocks;
            }
            else
            {
                __blkcnt64_t st_blocks;
            }

            static if ( __USE_MISC || __USE_XOPEN2K8)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }

            static if (!__USE_FILE_OFFSET64)
            {
                c_ulong __unused4;
                c_ulong __unused5;
            }
            else
            {
                __ino64_t st_ino;
            }
        }
        static if (__USE_FILE_OFFSET64)
            static assert(stat_t.sizeof == 104);
        else
            static assert(stat_t.sizeof == 88);
    }
    else version (MIPS_O32)
    {
        struct stat_t
        {
            c_ulong     st_dev;
            c_long[3]   st_pad1;
            ino_t       st_ino;
            mode_t      st_mode;
            nlink_t     st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            c_ulong     st_rdev;
            static if (!__USE_FILE_OFFSET64)
            {
                c_long[2]   st_pad2;
                off_t       st_size;
                c_long      st_pad3;
            }
            else
            {
                c_long[3]   st_pad2;
                off_t       st_size;
            }
            static if (__USE_MISC || __USE_XOPEN2K8)
            {
                timespec    st_atim;
                timespec    st_mtim;
                timespec    st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                time_t      st_atime;
                c_ulong     st_atimensec;
                time_t      st_mtime;
                c_ulong     st_mtimensec;
                time_t      st_ctime;
                c_ulong     st_ctimensec;
            }
            blksize_t   st_blksize;
            static if (!__USE_FILE_OFFSET64)
            {
                blkcnt_t    st_blocks;
            }
            else
            {
                c_long      st_pad4;
                blkcnt_t    st_blocks;
            }
            c_long[14]  st_pad5;
        }
        static if (!__USE_FILE_OFFSET64)
            static assert(stat_t.sizeof == 144);
        else
            static assert(stat_t.sizeof == 160);
    }
    else version (MIPS64)
    {
        struct stat_t
        {
            dev_t       st_dev;
            int[3]      st_pad1;
            ino_t       st_ino;
            mode_t      st_mode;
            nlink_t     st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            dev_t       st_rdev;
            static if (!__USE_FILE_OFFSET64)
            {
                uint[2]     st_pad2;
                off_t       st_size;
                int         st_pad3;
            }
            else
            {
                uint[3]     st_pad2;
                off_t       st_size;
            }
            static if (__USE_MISC || __USE_XOPEN2K8)
            {
                timespec    st_atim;
                timespec    st_mtim;
                timespec    st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                time_t      st_atime;
                c_ulong     st_atimensec;
                time_t      st_mtime;
                c_ulong     st_mtimensec;
                time_t      st_ctime;
                c_ulong     st_ctimensec;
            }
            blksize_t   st_blksize;
            uint        st_pad4;
            blkcnt_t    st_blocks;
            int[14]     st_pad5;
        }
        version (MIPS_N32)
        {
            static if (!__USE_FILE_OFFSET64)
                static assert(stat_t.sizeof == 160);
            else
                static assert(stat_t.sizeof == 176);
        }
        else version (MIPS_O64)
        {
            static if (!__USE_FILE_OFFSET64)
                static assert(stat_t.sizeof == 160);
            else
                static assert(stat_t.sizeof == 176);
        }
        else
        {
            static assert(stat_t.sizeof == 216);
        }
    }
    else version (PPC)
    {
        struct stat_t
        {
            c_ulong     st_dev;
            ino_t       st_ino;
            mode_t      st_mode;
            nlink_t     st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            c_ulong     st_rdev;
            off_t       st_size;
            c_ulong     st_blksize;
            c_ulong     st_blocks;
            c_ulong     st_atime;
            c_ulong     st_atime_nsec;
            c_ulong     st_mtime;
            c_ulong     st_mtime_nsec;
            c_ulong     st_ctime;
            c_ulong     st_ctime_nsec;
            c_ulong     __unused4;
            c_ulong     __unused5;
        }
    }
    else version (PPC64)
    {
        struct stat_t
        {
            c_ulong     st_dev;
            ino_t       st_ino;
            nlink_t     st_nlink;
            mode_t      st_mode;
            uid_t       st_uid;
            gid_t       st_gid;
            c_ulong     st_rdev;
            off_t       st_size;
            c_ulong     st_blksize;
            c_ulong     st_blocks;
            c_ulong     st_atime;
            c_ulong     st_atime_nsec;
            c_ulong     st_mtime;
            c_ulong     st_mtime_nsec;
            c_ulong     st_ctime;
            c_ulong     st_ctime_nsec;
            c_ulong     __unused4;
            c_ulong     __unused5;
            c_ulong     __unused6;
        }
    }
    else version (RISCV_Any)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = uint;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = int;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;

            static if (__USE_FILE_OFFSET64)
            {
                __ino64_t st_ino;
            }
            else
            {
                __ino_t st_ino;
            }
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            __dev_t __pad1;

            static if (__USE_FILE_OFFSET64)
            {
                __off64_t st_size;
            }
            else
            {
                __off_t st_size;
            }
            __blksize_t st_blksize;
            int __pad2;

            static if (__USE_FILE_OFFSET64)
            {
                __blkcnt64_t st_blocks;
            }
            else
            {
                __blkcnt_t st_blocks;
            }

            static if (__USE_MISC)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }
            int[2] __unused;
        }
    }
    else version (ARM)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = size_t;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            ushort __pad1;

            static if (!__USE_FILE_OFFSET64)
            {
                __ino_t st_ino;
            }
            else
            {
                __ino_t __st_ino;
            }
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            ushort __pad2;

            static if (!__USE_FILE_OFFSET64)
            {
                __off_t st_size;
            }
            else
            {
                __off64_t st_size;
            }
            __blksize_t st_blksize;

            static if (!__USE_FILE_OFFSET64)
            {
                __blkcnt_t st_blocks;
            }
            else
            {
                __blkcnt64_t st_blocks;
            }

            static if ( __USE_MISC || __USE_XOPEN2K8)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }

            static if (!__USE_FILE_OFFSET64)
            {
                c_ulong __unused4;
                c_ulong __unused5;
            }
            else
            {
                __ino64_t st_ino;
            }
        }
        static if (__USE_FILE_OFFSET64)
            static assert(stat_t.sizeof == 104);
        else
            static assert(stat_t.sizeof == 88);
    }
    else version (AArch64)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = uint;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = int;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;

            static if (!__USE_FILE_OFFSET64)
            {
                __ino_t st_ino;
            }
            else
            {
                __ino64_t st_ino;
            }
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            __dev_t __pad1;

            static if (!__USE_FILE_OFFSET64)
            {
                __off_t st_size;
            }
            else
            {
                __off64_t st_size;
            }
            __blksize_t st_blksize;
            int __pad2;

            static if (!__USE_FILE_OFFSET64)
            {
                __blkcnt_t st_blocks;
            }
            else
            {
                __blkcnt64_t st_blocks;
            }

            static if (__USE_MISC)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }
            int[2] __unused;
        }
        version (D_LP64)
            static assert(stat_t.sizeof == 128);
        else
            static assert(stat_t.sizeof == 104);
    }
    else version (SPARC64)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = uint;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            ushort __pad1;
            __ino_t st_ino;
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            ushort __pad2;

            static if (!__USE_FILE_OFFSET64)
            {
                __off_t st_size;
            }
            else
            {
                __off64_t st_size;
            }
            __blksize_t st_blksize;

            static if (!__USE_FILE_OFFSET64)
            {
                __blkcnt_t st_blocks;
            }
            else
            {
                __blkcnt64_t st_blocks;
            }

            static if (__USE_XOPEN2K8)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }

            c_ulong __unused4;
            c_ulong __unused5;
        }
        static assert(stat_t.sizeof == 144);
    }
    else version (S390)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = uint;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            uint __pad1;
            static if (!__USE_FILE_OFFSET64)
                __ino_t st_ino;
            else
                __ino_t __st_ino;
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            uint __pad2;
            static if (!__USE_FILE_OFFSET64)
                __off_t st_size;
            else
                __off64_t st_size;
            __blksize_t st_blksize;
            static if (!__USE_FILE_OFFSET64)
                __blkcnt_t st_blocks;
            else
                __blkcnt64_t st_blocks;
            static if (__USE_XOPEN2K8)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }
            static if (!__USE_FILE_OFFSET64)
            {
                c_ulong __glibc_reserved4;
                c_ulong __glibc_reserved5;
            }
            else
                __ino64_t st_ino;
        }
        static if (__USE_FILE_OFFSET64)
            static assert(stat_t.sizeof == 104);
        else
            static assert(stat_t.sizeof == 88);
    }
    else version (SystemZ)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = ulong;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            __ino_t st_ino;
            __nlink_t st_nlink;
            __mode_t st_mode;
            __uid_t st_uid;
            __gid_t st_gid;
            int __glibc_reserved0;
            __dev_t st_rdev;
            __off_t st_size;
            static if (__USE_XOPEN2K8)
            {
                __timespec st_atim;
                __timespec st_mtim;
                __timespec st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                __time_t st_atime;
                c_ulong st_atimensec;
                __time_t st_mtime;
                c_ulong st_mtimensec;
                __time_t st_ctime;
                c_ulong st_ctimensec;
            }
            __blksize_t st_blksize;
            __blkcnt_t st_blocks;
            c_long[3] __glibc_reserved;
        }
        static if (__USE_XOPEN2K8)
            static assert(stat_t.sizeof == 144);
        else
            static assert(stat_t.sizeof == 144);
    }
    else
        static assert(0, "unimplemented");

    enum S_IRUSR    = 0x100; // octal 0400
    enum S_IWUSR    = 0x080; // octal 0200
    enum S_IXUSR    = 0x040; // octal 0100
    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;

    enum S_IRGRP    = S_IRUSR >> 3;
    enum S_IWGRP    = S_IWUSR >> 3;
    enum S_IXGRP    = S_IXUSR >> 3;
    enum S_IRWXG    = S_IRWXU >> 3;

    enum S_IROTH    = S_IRGRP >> 3;
    enum S_IWOTH    = S_IWGRP >> 3;
    enum S_IXOTH    = S_IXGRP >> 3;
    enum S_IRWXO    = S_IRWXG >> 3;

    enum S_ISUID    = 0x800; // octal 04000
    enum S_ISGID    = 0x400; // octal 02000
    enum S_ISVTX    = 0x200; // octal 01000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }

    static if ( true /*__USE_POSIX199309*/ )
    {
        extern bool S_TYPEISMQ( stat_t* buf )  { return false; }
        extern bool S_TYPEISSEM( stat_t* buf ) { return false; }
        extern bool S_TYPEISSHM( stat_t* buf ) { return false; }
    }

    enum UTIME_NOW = 0x3fffffff;
    enum UTIME_OMIT = 0x3ffffffe;

    int utimensat(int dirfd, const char *pathname,
        ref const(timespec)[2] times, int flags);
    int futimens(int fd, ref const(timespec)[2] times);
}
else version (Darwin)
{
    // _DARWIN_FEATURE_64_BIT_INODE stat is default for Mac OSX >10.5 and is
    // only meaningful type for other OS X/Darwin variants (e.g. iOS).
    // man stat(2) gives details.
    struct stat_t
    {
        dev_t       st_dev;
        mode_t      st_mode;
        nlink_t     st_nlink;
        ino_t       st_ino;
        uid_t       st_uid;
        gid_t       st_gid;
        dev_t       st_rdev;
        union
        {
            struct
            {
                timespec  st_atimespec;
                timespec  st_mtimespec;
                timespec  st_ctimespec;
                timespec  st_birthtimespec;
            }
            struct
            {
                time_t      st_atime;
                c_long      st_atimensec;
                time_t      st_mtime;
                c_long      st_mtimensec;
                time_t      st_ctime;
                c_long      st_ctimensec;
                time_t      st_birthtime;
                c_long      st_birthtimensec;
            }
        }
        off_t       st_size;
        blkcnt_t    st_blocks;
        blksize_t   st_blksize;
        uint        st_flags;
        uint        st_gen;
        int         st_lspare;
        long[2]     st_qspare;
    }

    enum S_IRUSR    = 0x100;  // octal 0400
    enum S_IWUSR    = 0x080;  // octal 0200
    enum S_IXUSR    = 0x040;  // octal 0100
    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;

    enum S_IRGRP    = S_IRUSR >> 3;
    enum S_IWGRP    = S_IWUSR >> 3;
    enum S_IXGRP    = S_IXUSR >> 3;
    enum S_IRWXG    = S_IRWXU >> 3;

    enum S_IROTH    = S_IRGRP >> 3;
    enum S_IWOTH    = S_IWGRP >> 3;
    enum S_IXOTH    = S_IXGRP >> 3;
    enum S_IRWXO    = S_IRWXG >> 3;

    enum S_ISUID    = 0x800; // octal 04000
    enum S_ISGID    = 0x400; // octal 02000
    enum S_ISVTX    = 0x200; // octal 01000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }
}
else version (FreeBSD)
{
    // https://github.com/freebsd/freebsd/blob/master/sys/sys/stat.h

    struct stat_t
    {
        dev_t       st_dev;
        ino_t       st_ino;
        mode_t      st_mode;
        nlink_t     st_nlink;
        uid_t       st_uid;
        gid_t       st_gid;
        dev_t       st_rdev;

        time_t      st_atime;
        c_long      __st_atimensec;
        time_t      st_mtime;
        c_long      __st_mtimensec;
        time_t      st_ctime;
        c_long      __st_ctimensec;

        off_t       st_size;
        blkcnt_t    st_blocks;
        blksize_t   st_blksize;
        fflags_t    st_flags;
        uint        st_gen;
        int         st_lspare;

        time_t      st_birthtime;
        c_long      st_birthtimensec;

        ubyte[16 - timespec.sizeof] padding;
    }

    enum S_IRUSR    = 0x100; // octal 0000400
    enum S_IWUSR    = 0x080; // octal 0000200
    enum S_IXUSR    = 0x040; // octal 0000100
    enum S_IRWXU    = 0x1C0; // octal 0000700

    enum S_IRGRP    = 0x020;  // octal 0000040
    enum S_IWGRP    = 0x010;  // octal 0000020
    enum S_IXGRP    = 0x008;  // octal 0000010
    enum S_IRWXG    = 0x038;  // octal 0000070

    enum S_IROTH    = 0x4; // 0000004
    enum S_IWOTH    = 0x2; // 0000002
    enum S_IXOTH    = 0x1; // 0000001
    enum S_IRWXO    = 0x7; // 0000007

    enum S_ISUID    = 0x800; // octal 0004000
    enum S_ISGID    = 0x400; // octal 0002000
    enum S_ISVTX    = 0x200; // octal 0001000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }

    enum UTIME_NOW = -1;
    enum UTIME_OMIT = -2;

    // Since FreeBSD 11:
    version (none)
    {
        int utimensat(int dirfd, const char *pathname,
            ref const(timespec)[2] times, int flags);
        int futimens(int fd, ref const(timespec)[2] times);
    }
}
else version (NetBSD)
{
    struct stat_t
    {
        dev_t     st_dev;               /* inode's device */
        mode_t    st_mode;              /* inode protection mode */
        ino_t     st_ino;               /* inode's number */
        nlink_t   st_nlink;             /* number of hard links */
        uid_t     st_uid;               /* user ID of the file's owner */
        gid_t     st_gid;               /* group ID of the file's group */
        dev_t     st_rdev;              /* device type */
        time_t    st_atime;             /* time of last access */
        long      st_atimensec;         /* nsec of last access */
        time_t    st_mtime;             /* time of last data modification */
        long      st_mtimensec;         /* nsec of last data modification */
        time_t    st_ctime;             /* time of last file status change */
        long      st_ctimensec;         /* nsec of last file status change */
        time_t    st_birthtime;         /* time of creation */
        long      st_birthtimensec;     /* nsec of time of creation */
        off_t     st_size;              /* file size, in bytes */
        blkcnt_t  st_blocks;            /* blocks allocated for file */
        blksize_t st_blksize;           /* optimal blocksize for I/O */
        uint32_t  st_flags;             /* user defined flags for file */
        uint32_t  st_gen;               /* file generation number */
        uint32_t[2]  st_spare;
    }

    enum S_IRUSR    = 0x100; // octal 0000400
    enum S_IWUSR    = 0x080; // octal 0000200
    enum S_IXUSR    = 0x040; // octal 0000100
    enum S_IRWXU    = 0x1C0; // octal 0000700

    enum S_IRGRP    = 0x020;  // octal 0000040
    enum S_IWGRP    = 0x010;  // octal 0000020
    enum S_IXGRP    = 0x008;  // octal 0000010
    enum S_IRWXG    = 0x038;  // octal 0000070

    enum S_IROTH    = 0x4; // 0000004
    enum S_IWOTH    = 0x2; // 0000002
    enum S_IXOTH    = 0x1; // 0000001
    enum S_IRWXO    = 0x7; // 0000007

    enum S_ISUID    = 0x800; // octal 0004000
    enum S_ISGID    = 0x400; // octal 0002000
    enum S_ISVTX    = 0x200; // octal 0001000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }
}
else version (DragonFlyBSD)
{
    struct stat_t {
            ino_t     st_ino;               /* inode's number */
            nlink_t   st_nlink;             /* number of hard links */
            dev_t     st_dev;               /* inode's device */
            mode_t    st_mode;              /* inode protection mode */
            uint16_t  st_padding1;
            uid_t     st_uid;               /* user ID of the file's owner */
            gid_t     st_gid;               /* group ID of the file's group */
            dev_t     st_rdev;              /* device type */
            time_t      st_atime;
            c_long      __st_atimensec;
            time_t      st_mtime;
            c_long      __st_mtimensec;
            time_t      st_ctime;
            c_long      __st_ctimensec;
            off_t     st_size;              /* file size, in bytes */
            int64_t   st_blocks;            /* blocks allocated for file */
            uint32_t  st_blksize;           /* optimal blocksize for I/O */
            uint32_t  st_flags;             /* user defined flags for file */
            uint32_t  st_gen;               /* file generation number */
            int32_t   st_lspare;
            int64_t   st_qspare1;           /* was recursive change detect */
            int64_t   st_qspare2;
    };

    enum S_IRUSR    = 0x100; // octal 0000400
    enum S_IWUSR    = 0x080; // octal 0000200
    enum S_IXUSR    = 0x040; // octal 0000100
    enum S_IRWXU    = 0x1C0; // octal 0000700

    enum S_IRGRP    = 0x020;  // octal 0000040
    enum S_IWGRP    = 0x010;  // octal 0000020
    enum S_IXGRP    = 0x008;  // octal 0000010
    enum S_IRWXG    = 0x038;  // octal 0000070

    enum S_IROTH    = 0x4; // 0000004
    enum S_IWOTH    = 0x2; // 0000002
    enum S_IXOTH    = 0x1; // 0000001
    enum S_IRWXO    = 0x7; // 0000007

    enum S_ISUID    = 0x800; // octal 0004000
    enum S_ISGID    = 0x400; // octal 0002000
    enum S_ISVTX    = 0x200; // octal 0001000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }
}
else version (Solaris)
{
    private enum _ST_FSTYPSZ = 16;

    version (D_LP64)
    {
        struct stat_t
        {
            dev_t st_dev;
            ino_t st_ino;
            mode_t st_mode;
            nlink_t st_nlink;
            uid_t st_uid;
            gid_t st_gid;
            dev_t st_rdev;
            off_t st_size;
            union
            {
                timestruc_t st_atim;
                time_t      st_atime;
            }
            union
            {
                timestruc_t st_mtim;
                time_t      st_mtime;
            }
            union
            {
                timestruc_t st_ctim;
                time_t      st_ctime;
            }
            blksize_t st_blksize;
            blkcnt_t st_blocks;
            char[_ST_FSTYPSZ] st_fstype = 0;
        }

        static if (__USE_LARGEFILE64) alias stat_t stat64_t;
    }
    else
    {
        struct stat32_t
        {
            dev_t st_dev;
            c_long[3] st_pad1;
            ino_t st_ino;
            mode_t st_mode;
            nlink_t st_nlink;
            uid_t st_uid;
            gid_t st_gid;
            dev_t st_rdev;
            c_long[2] st_pad2;
            off_t st_size;
            c_long st_pad3;
            union
            {
                timestruc_t st_atim;
                time_t      st_atime;
            }
            union
            {
                timestruc_t st_mtim;
                time_t      st_mtime;
            }
            union
            {
                timestruc_t st_ctim;
                time_t      st_ctime;
            }
            blksize_t st_blksize;
            blkcnt_t st_blocks;
            char[_ST_FSTYPSZ] st_fstype = 0;
            c_long[8] st_pad4;
        }

        struct stat64_t
        {
            dev_t st_dev;
            c_long[3] st_pad1;
            ino64_t st_ino;
            mode_t st_mode;
            nlink_t st_nlink;
            uid_t st_uid;
            gid_t st_gid;
            dev_t st_rdev;
            c_long[2] st_pad2;
            off64_t st_size;
            union
            {
                timestruc_t st_atim;
                time_t      st_atime;
            }
            union
            {
                timestruc_t st_mtim;
                time_t      st_mtime;
            }
            union
            {
                timestruc_t st_ctim;
                time_t      st_ctime;
            }
            blksize_t st_blksize;
            blkcnt64_t st_blocks;
            char[_ST_FSTYPSZ] st_fstype = 0;
            c_long[8] st_pad4;
        }

        static if (__USE_FILE_OFFSET64)
            alias stat64_t stat_t;
        else
            alias stat32_t stat_t;

    }

    enum S_IRUSR = 0x100;
    enum S_IWUSR = 0x080;
    enum S_IXUSR = 0x040;
    enum S_IRWXU = 0x1C0;

    enum S_IRGRP = 0x020;
    enum S_IWGRP = 0x010;
    enum S_IXGRP = 0x008;
    enum S_IRWXG = 0x038;

    enum S_IROTH = 0x4; // 0000004
    enum S_IWOTH = 0x2; // 0000002
    enum S_IXOTH = 0x1; // 0000001
    enum S_IRWXO = 0x7; // 0000007

    enum S_ISUID = 0x800;
    enum S_ISGID = 0x400;
    enum S_ISVTX = 0x200;

    private
    {
        extern (D) bool S_ISTYPE(mode_t mode, uint mask)
        {
            return (mode & S_IFMT) == mask;
        }
    }

    extern (D) bool S_ISBLK(mode_t mode) { return S_ISTYPE(mode, S_IFBLK); }
    extern (D) bool S_ISCHR(mode_t mode) { return S_ISTYPE(mode, S_IFCHR); }
    extern (D) bool S_ISDIR(mode_t mode) { return S_ISTYPE(mode, S_IFDIR); }
    extern (D) bool S_ISFIFO(mode_t mode) { return S_ISTYPE(mode, S_IFIFO); }
    extern (D) bool S_ISREG(mode_t mode) { return S_ISTYPE(mode, S_IFREG); }
    extern (D) bool S_ISLNK(mode_t mode) { return S_ISTYPE(mode, S_IFLNK); }
    extern (D) bool S_ISSOCK(mode_t mode) { return S_ISTYPE(mode, S_IFSOCK); }
    extern (D) bool S_ISDOOR(mode_t mode) { return S_ISTYPE(mode, S_IFDOOR); }
    extern (D) bool S_ISPORT(mode_t mode) { return S_ISTYPE(mode, S_IFPORT); }
}
else version (CRuntime_Bionic)
{
    version (X86)
    {
        struct stat_t
        {
            ulong       st_dev;
            ubyte[4]    __pad0;
            c_ulong     __st_ino;
            uint        st_mode;
            uint        st_nlink;
            c_ulong     st_uid;
            c_ulong     st_gid;
            ulong       st_rdev;
            ubyte[4]    __pad3;

            long        st_size;
            c_ulong     st_blksize;
            ulong       st_blocks;
            c_ulong     st_atime;
            c_ulong     st_atime_nsec;
            c_ulong     st_mtime;
            c_ulong     st_mtime_nsec;
            c_ulong     st_ctime;
            c_ulong     st_ctime_nsec;
            ulong       st_ino;
        }
    }
    else version (ARM)
    {
        struct stat_t
        {
            ulong       st_dev;
            ubyte[4]    __pad0;
            c_ulong     __st_ino;
            uint        st_mode;
            uint        st_nlink;
            c_ulong     st_uid;
            c_ulong     st_gid;
            ulong       st_rdev;
            ubyte[4]    __pad3;

            long        st_size;
            c_ulong     st_blksize;
            ulong       st_blocks;
            c_ulong     st_atime;
            c_ulong     st_atime_nsec;
            c_ulong     st_mtime;
            c_ulong     st_mtime_nsec;
            c_ulong     st_ctime;
            c_ulong     st_ctime_nsec;
            ulong       st_ino;
        }
    }
    else version (AArch64)
    {
        struct stat_t
        {
            ulong       st_dev;
            ulong       st_ino;
            uint        st_mode;
            uint        st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            ulong       st_rdev;
            ulong       __pad1;

            long        st_size;
            int         st_blksize;
            int         __pad2;
            long        st_blocks;
            long        st_atime;
            ulong       st_atime_nsec;
            long        st_mtime;
            ulong       st_mtime_nsec;
            long        st_ctime;
            ulong       st_ctime_nsec;
            uint        __unused4;
            uint        __unused5;
        }
    }
    else version (X86_64)
    {
        struct stat_t
        {
            ulong       st_dev;
            ulong       st_ino;
            ulong       st_nlink;
            uint        st_mode;
            uid_t       st_uid;
            gid_t       st_gid;
            uint        __pad0;

            ulong       st_rdev;
            long        st_size;
            long        st_blksize;
            long        st_blocks;
            long        st_atime;
            ulong       st_atime_nsec;
            long        st_mtime;
            ulong       st_mtime_nsec;
            long        st_ctime;
            ulong       st_ctime_nsec;
            long[3]     __pad3;
        }
    }
    else
    {
        static assert(false, "Architecture not supported.");
    }

    enum S_IRUSR    = 0x100; // octal 0000400
    enum S_IWUSR    = 0x080; // octal 0000200
    enum S_IXUSR    = 0x040; // octal 0000100
    enum S_IRWXU    = 0x1C0; // octal 0000700

    enum S_IRGRP    = 0x020;  // octal 0000040
    enum S_IWGRP    = 0x010;  // octal 0000020
    enum S_IXGRP    = 0x008;  // octal 0000010
    enum S_IRWXG    = 0x038;  // octal 0000070

    enum S_IROTH    = 0x4; // 0000004
    enum S_IWOTH    = 0x2; // 0000002
    enum S_IXOTH    = 0x1; // 0000001
    enum S_IRWXO    = 0x7; // 0000007

    enum S_ISUID    = 0x800; // octal 0004000
    enum S_ISGID    = 0x400; // octal 0002000
    enum S_ISVTX    = 0x200; // octal 0001000

    private
    {
        extern (D) bool S_ISTYPE( uint mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( uint mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( uint mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( uint mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( uint mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( uint mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( uint mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( uint mode ) { return S_ISTYPE( mode, S_IFSOCK ); }

    // Added since Lollipop
    int utimensat(int dirfd, const char *pathname,
        ref const(timespec)[2] times, int flags);
}
else version (CRuntime_Musl)
{
    alias __mode_t = uint;
    enum {
        S_IRUSR    = 0x100, // octal 0400
        S_IWUSR    = 0x080, // octal 0200
        S_IXUSR    = 0x040, // octal 0100
        S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR,

        S_IRGRP    = S_IRUSR >> 3,
        S_IWGRP    = S_IWUSR >> 3,
        S_IXGRP    = S_IXUSR >> 3,
        S_IRWXG    = S_IRWXU >> 3,

        S_IROTH    = S_IRGRP >> 3,
        S_IWOTH    = S_IWGRP >> 3,
        S_IXOTH    = S_IXGRP >> 3,
        S_IRWXO    = S_IRWXG >> 3,

        S_ISUID    = 0x800, // octal 04000
        S_ISGID    = 0x400, // octal 02000
        S_ISVTX    = 0x200, // octal 01000
    }
    struct stat_t {
        dev_t st_dev;
        ino_t st_ino;
        nlink_t st_nlink;

        mode_t st_mode;
        uid_t st_uid;
        gid_t st_gid;
        uint    __pad0;
        dev_t st_rdev;
        off_t st_size;
        blksize_t st_blksize;
        blkcnt_t st_blocks;

        timespec st_atim;
        timespec st_mtim;
        timespec st_ctim;
        extern(D) @safe @property inout pure nothrow
        {
            ref inout(time_t) st_atime() return { return st_atim.tv_sec; }
            ref inout(time_t) st_mtime() return { return st_mtim.tv_sec; }
            ref inout(time_t) st_ctime() return { return st_ctim.tv_sec; }
        }
        long[3] __unused;
    }
    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { ree-  f-  g-  h-                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  turn S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }

    int utimensat(int dirfd, const char *pathname,
        ref const(timespec)[2] times, int flags);
}
else version (CRuntime_UClibc)
{
    version (X86_64)
    {
        struct stat_t
        {
            dev_t       st_dev;
            ino_t       st_ino;
            nlink_t     st_nlink;
            mode_t      st_mode;
            uid_t       st_uid;
            gid_t       st_gid;
            uint        __pad0;
            dev_t       st_rdev;
            off_t       st_size;
            blksize_t   st_blksize;
            blkcnt_t    st_blocks;
            time_t      st_atime;
            ulong_t     st_atimensec;
            time_t      st_mtime;
            ulong_t     st_mtimensec;
            time_t      st_ctime;
            ulong_t     st_ctimensec;
            slong_t[3]     __unused;
        }
    }
    else version (MIPS_O32)
    {
        struct stat_t
        {
            c_ulong     st_dev;
            c_long[3]   st_pad1;
            ino_t       st_ino;
            mode_t      st_mode;
            nlink_t     st_nlink;
            uid_t       st_uid;
            gid_t       st_gid;
            c_ulong     st_rdev;
            static if (!__USE_FILE_OFFSET64)
            {
                c_long[2]   st_pad2;
                off_t       st_size;
                c_long      st_pad3;
            }
            else
            {
                c_long[3]   st_pad2;
                off_t       st_size;
            }
            static if (__USE_MISC || __USE_XOPEN2K8)
            {
                timespec    st_atim;
                timespec    st_mtim;
                timespec    st_ctim;
                extern(D)
                {
                    @property ref time_t st_atime() { return st_atim.tv_sec; }
                    @property ref time_t st_mtime() { return st_mtim.tv_sec; }
                    @property ref time_t st_ctime() { return st_ctim.tv_sec; }
                }
            }
            else
            {
                time_t      st_atime;
                c_ulong     st_atimensec;
                time_t      st_mtime;
                c_ulong     st_mtimensec;
                time_t      st_ctime;
                c_ulong     st_ctimensec;
            }
            blksize_t   st_blksize;
            static if (!__USE_FILE_OFFSET64)
            {
                blkcnt_t    st_blocks;
            }
            else
            {
                c_long      st_pad4;
                blkcnt_t    st_blocks;
            }
            c_long[14]  st_pad5;
        }
    }
    else version (ARM)
    {
        private
        {
            alias __dev_t = ulong;
            alias __ino_t = c_ulong;
            alias __ino64_t = ulong;
            alias __mode_t = uint;
            alias __nlink_t = size_t;
            alias __uid_t = uint;
            alias __gid_t = uint;
            alias __off_t = c_long;
            alias __off64_t = long;
            alias __blksize_t = c_long;
            alias __blkcnt_t = c_long;
            alias __blkcnt64_t = long;
            alias __timespec = timespec;
            alias __time_t = time_t;
        }
        struct stat_t
        {
            __dev_t st_dev;
            ushort __pad1;

            static if (!__USE_FILE_OFFSET64)
            {
                __ino_t st_ino;
            }
            else
            {
                __ino_t __st_ino;
            }
            __mode_t st_mode;
            __nlink_t st_nlink;
            __uid_t st_uid;
            __gid_t st_gid;
            __dev_t st_rdev;
            ushort __pad2;

            static if (!__USE_FILE_OFFSET64)
            {
                __off_t st_size;
            }
            else
            {
                __off64_t st_size;
            }
            __blksize_t st_blksize;

            static if (!__USE_FILE_OFFSET64)
            {
                __blkcnt_t st_blocks;
            }
            else
            {
                __blkcnt64_t st_blocks;
            }

            __time_t st_atime;
            c_ulong st_atimensec;
            __time_t st_mtime;
            c_ulong st_mtimensec;
            __time_t st_ctime;
            c_ulong st_ctimensec;

            static if (!__USE_FILE_OFFSET64)
            {
                c_ulong __unused4;
                c_ulong __unused5;
            }
            else
            {
                __ino64_t st_ino;
            }
        }
        static if (__USE_FILE_OFFSET64)
            static assert(stat_t.sizeof == 104);
        else
            static assert(stat_t.sizeof == 88);
    }
    else
        static assert(0, "unimplemented");

    enum S_IRUSR    = 0x100; // octal 0400
    enum S_IWUSR    = 0x080; // octal 0200
    enum S_IXUSR    = 0x040; // octal 0100
    enum S_IRWXU    = S_IRUSR | S_IWUSR | S_IXUSR;

    enum S_IRGRP    = S_IRUSR >> 3;
    enum S_IWGRP    = S_IWUSR >> 3;
    enum S_IXGRP    = S_IXUSR >> 3;
    enum S_IRWXG    = S_IRWXU >> 3;

    enum S_IROTH    = S_IRGRP >> 3;
    enum S_IWOTH    = S_IWGRP >> 3;
    enum S_IXOTH    = S_IXGRP >> 3;
    enum S_IRWXO    = S_IRWXG >> 3;

    enum S_ISUID    = 0x800; // octal 04000
    enum S_ISGID    = 0x400; // octal 02000
    enum S_ISVTX    = 0x200; // octal 01000

    private
    {
        extern (D) bool S_ISTYPE( mode_t mode, uint mask )
        {
            return ( mode & S_IFMT ) == mask;
        }
    }

    extern (D) bool S_ISBLK( mode_t mode )  { return S_ISTYPE( mode, S_IFBLK );  }
    extern (D) bool S_ISCHR( mode_t mode )  { return S_ISTYPE( mode, S_IFCHR );  }
    extern (D) bool S_ISDIR( mode_t mode )  { return S_ISTYPE( mode, S_IFDIR );  }
    extern (D) bool S_ISFIFO( mode_t mode ) { return S_ISTYPE( mode, S_IFIFO );  }
    extern (D) bool S_ISREG( mode_t mode )  { return S_ISTYPE( mode, S_IFREG );  }
    extern (D) bool S_ISLNK( mode_t mode )  { return S_ISTYPE( mode, S_IFLNK );  }
    extern (D) bool S_ISSOCK( mode_t mode ) { return S_ISTYPE( mode, S_IFSOCK ); }

    static if ( true /*__USE_POSIX199309*/ )
    {
        extern bool S_TYPEISMQ( stat_t* buf )  { return false; }
        extern bool S_TYPEISSEM( stat_t* buf ) { return false; }
        extern bool S_TYPEISSHM( stat_t* buf ) { return false; }
    }

    enum UTIME_NOW = 0x3fffffff;
    enum UTIME_OMIT = 0x3ffffffe;

    int utimensat(int dirfd, const char *pathname,
    ref const(timespec)[2] times, int flags);
    int futimens(int fd, ref const(timespec)[2] times);
}
else
{
    static assert(false, "Unsupported platform");
}

int    chmod(in char*, mode_t);
int    fchmod(int, mode_t);
//int    fstat(int, stat_t*);
//int    lstat(in char*, stat_t*);
int    mkdir(in char*, mode_t);
int    mkfifo(in char*, mode_t);
//int    stat(in char*, stat_t*);
mode_t umask(mode_t);

version (CRuntime_Glibc)
{
  static if ( __USE_LARGEFILE64 )
  {
    int   fstat64(int, stat_t*) @trusted;
    alias fstat64 fstat;

    int   lstat64(in char*, stat_t*);
    alias lstat64 lstat;

    int   stat64(in char*, stat_t*);
    alias stat64 stat;
  }
  else
  {
    int   fstat(int, stat_t*) @trusted;
    int   lstat(in char*, stat_t*);
    int   stat(in char*, stat_t*);
  }
}
else version (Solaris)
{
    version (D_LP64)
    {
        int fstat(int, stat_t*) @trusted;
        int lstat(in char*, stat_t*);
        int stat(in char*, stat_t*);

        static if (__USE_LARGEFILE64)
        {
            alias fstat fstat64;
            alias lstat lstat64;
            alias stat stat64;
        }
    }
    else
    {
        static if (__USE_LARGEFILE64)
        {
            int   fstat64(int, stat_t*) @trusted;
            alias fstat64 fstat;

            int   lstat64(in char*, stat_t*);
            alias lstat64 lstat;

            int   stat64(in char*, stat_t*);
            alias stat64 stat;
        }
        else
        {
            int fstat(int, stat_t*) @trusted;
            int lstat(in char*, stat_t*);
            int stat(in char*, stat_t*);
        }
    }
}
else version (Darwin)
{
    // OS X maintains backwards compatibility with older binaries using 32-bit
    // inode functions by appending $INODE64 to newer 64-bit inode functions.
    version (OSX)
    {
        pragma(mangle, "fstat$INODE64") int fstat(int, stat_t*);
        pragma(mangle, "lstat$INODE64") int lstat(in char*, stat_t*);
        pragma(mangle, "stat$INODE64")  int stat(in char*, stat_t*);
    }
    else
    {
        int fstat(int, stat_t*);
        int lstat(in char*, stat_t*);
        int stat(in char*, stat_t*);
    }
}
else version (FreeBSD)
{
    int   fstat(int, stat_t*);
    int   lstat(in char*, stat_t*);
    int   stat(in char*, stat_t*);
}
else version (NetBSD)
{
    int   __fstat50(int, stat_t*);
    int   __lstat50(in char*, stat_t*);
    int   __stat50(in char*, stat_t*);
    alias __fstat50 fstat;
    alias __lstat50 lstat;
    alias __stat50 stat;
}
else version (DragonFlyBSD)
{
    int   fstat(int, stat_t*);
    int   lstat(in char*, stat_t*);
    int   stat(in char*, stat_t*);
}
else version (CRuntime_Bionic)
{
    int   fstat(int, stat_t*) @trusted;
    int   lstat(in char*, stat_t*);
    int   stat(in char*, stat_t*);
}
else version (CRuntime_Musl)
{
    int stat(in char*, stat_t*);
    int fstat(int, stat_t*);
    int lstat(in char*, stat_t*);

    alias fstat fstat64;
    alias lstat lstat64;
    alias stat stat64;
}
else version (CRuntime_UClibc)
{
  static if ( __USE_LARGEFILE64 )
  {
    int   fstat64(int, stat_t*) @trusted;
    alias fstat64 fstat;

    int   lstat64(in char*, stat_t*);
    alias lstat64 lstat;

    int   stat64(in char*, stat_t*);
    alias stat64 stat;
  }
  else
  {
    int   fstat(int, stat_t*) @trusted;
    int   lstat(in char*, stat_t*);
    int   stat(in char*, stat_t*);
  }
}

//
// Typed Memory Objects (TYM)
//
/*
S_TYPEISTMO(buf)
*/

//
// XOpen (XSI)
//
/*
S_IFMT
S_IFBLK
S_IFCHR
S_IFIFO
S_IFREG
S_IFDIR
S_IFLNK
S_IFSOCK

int mknod(in 3char*, mode_t, dev_t);
*/

version (CRuntime_Glibc)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (Darwin)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (FreeBSD)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (NetBSD)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (DragonFlyBSD)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (Solaris)
{
    enum S_IFMT = 0xF000;
    enum S_IFBLK = 0x6000;
    enum S_IFCHR = 0x2000;
    enum S_IFIFO = 0x1000;
    enum S_IFREG = 0x8000;
    enum S_IFDIR = 0x4000;
    enum S_IFLNK = 0xA000;
    enum S_IFSOCK = 0xC000;
    enum S_IFDOOR = 0xD000;
    enum S_IFPORT = 0xE000;

    int mknod(in char*, mode_t, dev_t);
}
else version (CRuntime_Bionic)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else version (CRuntime_Musl)
{
    enum {
        S_IFMT     = 0xF000, // octal 0170000
        S_IFBLK    = 0x6000, // octal 0060000
        S_IFCHR    = 0x2000, // octal 0020000
        S_IFIFO    = 0x1000, // octal 0010000
        S_IFREG    = 0x8000, // octal 0100000
        S_IFDIR    = 0x4000, // octal 0040000
        S_IFLNK    = 0xA000, // octal 0120000
        S_IFSOCK   = 0xC000, // octal 0140000
    }

    int mknod(in char*, mode_t, dev_t);
}
else version (CRuntime_UClibc)
{
    enum S_IFMT     = 0xF000; // octal 0170000
    enum S_IFBLK    = 0x6000; // octal 0060000
    enum S_IFCHR    = 0x2000; // octal 0020000
    enum S_IFIFO    = 0x1000; // octal 0010000
    enum S_IFREG    = 0x8000; // octal 0100000
    enum S_IFDIR    = 0x4000; // octal 0040000
    enum S_IFLNK    = 0xA000; // octal 0120000
    enum S_IFSOCK   = 0xC000; // octal 0140000

    int mknod(in char*, mode_t, dev_t);
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /++
    D header file correspoding to sys/statvfs.h.

    Copyright: Copyright 2012 -
    License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
    Authors:   Robert Klotzner and $(HTTP jmdavisprog.com, Jonathan M Davis)
    Standards: $(HTTP http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_statvfs.h.html,
                      The Open Group Base Specifications Issue 7 IEEE Std 1003.1, 2018 Edition)
 +/
module core.sys.posix.sys.statvfs;
private import core.stdc.config;
private import core.sys.posix.config;
public import core.sys.posix.sys.types;

version (Posix):
extern (C) :
nothrow:
@nogc:

version (CRuntime_Glibc) {
    static if (__WORDSIZE == 32)
    {
        version=_STATVFSBUF_F_UNUSED;
    }
    struct statvfs_t
    {
        c_ulong f_bsize;
        c_ulong f_frsize;
        fsblkcnt_t f_blocks;
        fsblkcnt_t f_bfree;
        fsblkcnt_t f_bavail;
        fsfilcnt_t f_files;
        fsfilcnt_t f_ffree;
        fsfilcnt_t f_favail;
        c_ulong f_fsid;
        version (_STATVFSBUF_F_UNUSED)
        {
            int __f_unused;
        }
        c_ulong f_flag;
        c_ulong f_namemax;
        int[6] __f_spare;
    }
    /* Definitions for the flag in `f_flag'.  These definitions should be
      kept in sync with the definitions in <sys/mount.h>.  */
    static if (__USE_GNU)
    {
        enum FFlag
        {
            ST_RDONLY = 1,        /* Mount read-only.  */
            ST_NOSUID = 2,
            ST_NODEV = 4,         /* Disallow access to device special files.  */
            ST_NOEXEC = 8,        /* Disallow program execution.  */
            ST_SYNCHRONOUS = 16,      /* Writes are synced at once.  */
            ST_MANDLOCK = 64,     /* Allow mandatory locks on an FS.  */
            ST_WRITE = 128,       /* Write on file/directory/symlink.  */
            ST_APPEND = 256,      /* Append-only file.  */
            ST_IMMUTABLE = 512,       /* Immutable file.  */
            ST_NOATIME = 1024,        /* Do not update access times.  */
            ST_NODIRATIME = 2048,     /* Do not update directory access times.  */
            ST_RELATIME = 4096        /* Update atime relative to mtime/ctime.  */

        }
    }  /* Use GNU.  */
    else
    { // Posix defined:
        enum FFlag
        {
            ST_RDONLY = 1,        /* Mount read-only.  */
            ST_NOSUID = 2
        }
    }

    static if ( __USE_FILE_OFFSET64 )
    {
        int statvfs64 (const char * file, statvfs_t* buf);
        alias statvfs64 statvfs;

        int fstatvfs64 (int fildes, statvfs_t *buf) @trusted;
        alias fstatvfs64 fstatvfs;
    }
    else
    {
        int statvfs (const char * file, statvfs_t* buf);
        int fstatvfs (int fildes, statvfs_t *buf);
    }

}
else version (NetBSD)
{
    enum  _VFS_MNAMELEN = 1024;
    enum  _VFS_NAMELEN = 32;

    struct fsid_t
    {
       int[2] __fsid_val;
    }

    struct statvfs_t
    {
        c_ulong f_flag;
        c_ulong f_bsize;
        c_ulong f_frsize;
        c_ulong f_iosize;
        fsblkcnt_t f_blocks;
        fsblkcnt_t f_bfree;
        fsblkcnt_t f_bavail;
        fsblkcnt_t f_bresvd;
        fsfilcnt_t f_files;
        fsfilcnt_t f_ffree;
        fsfilcnt_t f_favail;
        fsfilcnt_t f_fresvd;
        ulong f_syncreads;
        ulong f_syncwrites;
        ulong f_asyncreads;
        ulong f_asyncwrites;
        fsid_t f_fsidx;
        c_ulong f_fsid;
        c_ulong f_namemax;
        int f_owner;
        int[4] f_spare;
        char[_VFS_NAMELEN] f_fstypename = 0;
        char[_VFS_MNAMELEN] f_mntonname = 0;
        char[_VFS_MNAMELEN] f_mntfromname = 0;
    }

    enum FFlag
    {
        ST_RDONLY = 1,        /* Mount read-only.  */
        ST_NOSUID = 2
    }

    int statvfs (const char * file, statvfs_t* buf);
    int fstatvfs (int fildes, statvfs_t *buf) @trusted;
}
else version (FreeBSD)
{
    import core.sys.freebsd.sys.mount;

    // @@@DEPRECATED_2.091@@@
    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias MFSNAMELEN = core.sys.freebsd.sys.mount.MFSNAMELEN;

    // @@@DEPRECATED_2.091@@@
    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias MNAMELEN = core.sys.freebsd.sys.mount.MNAMELEN;

    // @@@DEPRECATED_2.091@@@
    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias fsid_t = core.sys.freebsd.sys.mount.fsid_t;

    // @@@DEPRECATED_2.091@@@
    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias statfs_t = core.sys.freebsd.sys.mount.statfs_t;

    // @@@DEPRECATED_2.091@@@
    deprecated("Values moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    enum FFlag
    {
        // @@@DEPRECATED_2.091@@@
        MNT_RDONLY = 1,          /* read only filesystem */

        // @@@DEPRECATED_2.091@@@
        MNT_SYNCHRONOUS = 2,     /* fs written synchronously */

        // @@@DEPRECATED_2.091@@@
        MNT_NOEXEC = 4,          /* can't exec from filesystem */

        // @@@DEPRECATED_2.091@@@
        MNT_NOSUID  = 8,         /* don't honor setuid fs bits */

        // @@@DEPRECATED_2.091@@@
        MNT_NFS4ACLS = 16,       /* enable NFS version 4 ACLs */

        // @@@DEPRECATED_2.091@@@
        MNT_UNION = 32,          /* union with underlying fs */

        // @@@DEPRECATED_2.091@@@
        MNT_ASYNC = 64,          /* fs written asynchronously */

        // @@@DEPRECATED_2.091@@@
        MNT_SUIDDIR = 128,       /* special SUID dir handling */

        // @@@DEPRECATED_2.091@@@
        MNT_SOFTDEP = 256,       /* using soft updates */

        // @@@DEPRECATED_2.091@@@
        MNT_NOSYMFOLLOW = 512,   /* do not follow symlinks */

        // @@@DEPRECATED_2.091@@@
        MNT_GJOURNAL = 1024,     /* GEOM journal support enabled */

        // @@@DEPRECATED_2.091@@@
        MNT_MULTILABEL = 2048,   /* MAC support for objects */

        // @@@DEPRECATED_2.091@@@
        MNT_ACLS = 4096,         /* ACL support enabled */

        // @@@DEPRECATED_2.091@@@
        MNT_NOATIME = 8192,      /* dont update file access time */

        // @@@DEPRECATED_2.091@@@
        MNT_NOCLUSTERR = 16384,  /* disable cluster read */

        // @@@DEPRECATED_2.091@@@
        MNT_NOCLUSTERW = 32768,  /* disable cluster write */

        // @@@DEPRECATED_2.091@@@
        MNT_SUJ = 65536,         /* using journaled soft updates */

        // @@@DEPRECATED_2.091@@@
        MNT_AUTOMOUNTED = 131072 /* mounted by automountd(8) */
    }

    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias statfs = core.sys.freebsd.sys.mount.statfs;

    deprecated("Moved to core.sys.freebsd.sys.mount to correspond to C header file sys/mount.h")
    alias fstatfs = core.sys.freebsd.sys.mount.fstatfs;

    struct statvfs_t
    {
        fsblkcnt_t f_bavail;
        fsblkcnt_t f_bfree;
        fsblkcnt_t f_blocks;
        fsfilcnt_t f_favail;
        fsfilcnt_t f_ffree;
        fsfilcnt_t f_files;
        ulong f_bsize;
        ulong f_flag;
        ulong f_frsize;
        ulong f_fsid;
        ulong f_namemax;
    }

    enum uint ST_RDONLY = 0x1;
    enum uint ST_NOSUID = 0x2;

    int fstatvfs(int, statvfs_t*);
    int statvfs(const char*, statvfs_t*);
}
else
{
    struct statvfs_t
    {
        c_ulong f_bsize;
        c_ulong f_frsize;
        fsblkcnt_t f_blocks;
        fsblkcnt_t f_bfree;
        fsblkcnt_t f_bavail;
        fsfilcnt_t f_files;
        fsfilcnt_t f_ffree;
        fsfilcnt_t f_favail;
        c_ulong f_fsid;
        c_ulong f_flag;
        c_ulong f_namemax;
    }

    enum FFlag
    {
        ST_RDONLY = 1,        /* Mount read-only.  */
        ST_NOSUID = 2
    }

    int statvfs (const char * file, statvfs_t* buf);
    int fstatvfs (int fildes, statvfs_t *buf) @trusted;
}
                                                                                                                                                                                                                                                                               /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.time;

private import core.sys.posix.config;
public import core.sys.posix.sys.types;  // for time_t, suseconds_t
public import core.sys.posix.sys.select; // for fd_set, FD_CLR() FD_ISSET() FD_SET() FD_ZERO() FD_SETSIZE, select()

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (linux) public import core.sys.linux.sys.time;

version (Posix):
extern (C) nothrow @nogc:

//
// XOpen (XSI)
//
/*
struct timeval
{
    time_t      tv_sec;
    suseconds_t tv_usec;
}

struct itimerval
{
    timeval it_interval;
    timeval it_value;
}

ITIMER_REAL
ITIMER_VIRTUAL
ITIMER_PROF

int getitimer(int, itimerval*);
int gettimeofday(timeval*, void*);
int select(int, fd_set*, fd_set*, fd_set*, timeval*); (defined in core.sys.posix.sys.signal)
int setitimer(int, in itimerval*, itimerval*);
int utimes(in char*, ref const(timeval)[2]); // LEGACY
*/

version (CRuntime_Glibc)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    enum ITIMER_REAL    = 0;
    enum ITIMER_VIRTUAL = 1;
    enum ITIMER_PROF    = 2;

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, void*);
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]); // LEGACY
}
else version (CRuntime_Musl)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }
    int gettimeofday(timeval*, void*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (Darwin)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    // non-standard
    struct timezone_t
    {
        int tz_minuteswest;
        int tz_dsttime;
    }

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, timezone_t*); // timezone_t* is normally void*
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (FreeBSD)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    // non-standard
    struct timezone_t
    {
        int tz_minuteswest;
        int tz_dsttime;
    }

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, timezone_t*); // timezone_t* is normally void*
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (NetBSD)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, void*); // timezone_t* is normally void*
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (DragonFlyBSD)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    // non-standard
    struct timezone_t
    {
        int tz_minuteswest;
        int tz_dsttime;
    }

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, timezone_t*); // timezone_t* is normally void*
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (Solaris)
{
    struct timeval
    {
        time_t tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, void*);
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (CRuntime_Bionic)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    struct timezone_t
    {
        int tz_minuteswest;
        int tz_dsttime;
    }

    enum ITIMER_REAL    = 0;
    enum ITIMER_VIRTUAL = 1;
    enum ITIMER_PROF    = 2;

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, timezone_t*);
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else version (CRuntime_UClibc)
{
    struct timeval
    {
        time_t      tv_sec;
        suseconds_t tv_usec;
    }

    struct itimerval
    {
        timeval it_interval;
        timeval it_value;
    }

    enum ITIMER_REAL    = 0;
    enum ITIMER_VIRTUAL = 1;
    enum ITIMER_PROF    = 2;

    int getitimer(int, itimerval*);
    int gettimeofday(timeval*, void*);
    int setitimer(int, in itimerval*, itimerval*);
    int utimes(in char*, ref const(timeval)[2]);
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /**
 * D header file for POSIX.
 *
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 */

module core.sys.posix.sys.ttycom;

import core.sys.posix.sys.ioccom;
import core.sys.posix.termios;
import core.sys.posix.sys.time;

version (Posix):

nothrow @nogc:

version (OSX)
{
    struct winsize {
        ushort  ws_row;     // rows, in characters
        ushort  ws_col;     // columns, in characters
        ushort  ws_xpixel;  // horizontal size, pixels
        ushort  ws_ypixel;  // vertical size, pixels
    }

    // Serial/TTY ioctl's
    enum uint TIOCMODG =  _IOR!(int)('t', 3);  // get modem control state
    enum uint TIOCMODS =  _IOW!(int)('t', 4);  // set modem control state
    enum uint       TIOCM_LE  = 0x001;          // line enable
    enum uint       TIOCM_DTR = 0x002;          // data terminal ready
    enum uint       TIOCM_RTS = 0x004;          // request to send
    enum uint       TIOCM_ST  = 0x008;          // secondary transmit
    enum uint       TIOCM_SR  = 0x010;          // secondary receive
    enum uint       TIOCM_CTS = 0x020;          // clear to send
    enum uint       TIOCM_CAR = 0x040;          // carrier detect
    enum uint       TIOCM_CD  = TIOCM_CAR;
    enum uint       TIOCM_RNG = 0x080;          // ring
    enum uint       TIOCM_RI  = TIOCM_RNG;
    enum uint       TIOCM_DSR = 0x100;          // data set ready
                            // 8-10 compat
    enum uint TIOCEXCL  = _IO('t', 13);        // set exclusive use of tty
    enum uint TIOCNXCL  = _IO('t', 14);        // reset exclusive use of tty
                            // 15 unused
    enum uint TIOCFLUSH = _IOW!(int)('t', 16); // flush buffers
                            // 17-18 compat
    enum uint TIOCGETA  = _IOR!(termios)('t', 19); // get termios struct
    enum uint TIOCSETA  = _IOW!(termios)('t', 20); // set termios struct
    enum uint TIOCSETAW = _IOW!(termios)('t', 21); // drain output, set
    enum uint TIOCSETAF = _IOW!(termios)('t', 22); // drn out, fls in, set
    enum uint TIOCGETD  = _IOR!(int)('t', 26); // get line discipline
    enum uint TIOCSETD  = _IOW!(int)('t', 27); // set line discipline
    enum uint TIOCIXON  = _IO('t', 129);       // internal input VSTART
    enum uint TIOCIXOFF = _IO('t', 128);       // internal input VSTOP
                            // 127-124 compat
    enum uint TIOCSBRK  = _IO('t', 123);       // set break bit
    enum uint TIOCCBRK  = _IO('t', 122);       // clear break bit
    enum uint TIOCSDTR  = _IO('t', 121);       // set data terminal ready
    enum uint TIOCCDTR  = _IO('t', 120);       // clear data terminal ready
    enum uint TIOCGPGRP = _IOR!(int)('t', 119); // get pgrp of tty
    enum uint TIOCSPGRP = _IOW!(int)('t', 118); // set pgrp of tty
                            // 117-116 compat
    enum uint TIOCOUTQ  = _IOR!(int)('t', 115); // output queue size
    enum uint TIOCSTI   = _IOW!(char)('t', 114);// simulate terminal input
    enum uint TIOCNOTTY = _IO('t', 113);        // void tty association
    enum uint TIOCPKT   = _IOW!(int)('t', 112); // pty: set/clear packet mode
    enum uint   TIOCPKT_DATA       = 0x00;     // data packet
    enum uint   TIOCPKT_FLUSHREAD  = 0x01;     // flush packet
    enum uint   TIOCPKT_FLUSHWRITE = 0x02;     // flush packet
    enum uint   TIOCPKT_STOP       = 0x04;     // stop output
    enum uint   TIOCPKT_START      = 0x08;     // start output
    enum uint   TIOCPKT_NOSTOP     = 0x10;     // no more ^S, ^Q
    enum uint   TIOCPKT_DOSTOP     = 0x20;     // now do ^S ^Q
    enum uint   TIOCPKT_IOCTL      = 0x40;     // state change of pty driver
    enum uint TIOCSTOP   = _IO('t', 111);      // stop output, like ^S
    enum uint TIOCSTART  = _IO('t', 110);      // start output, like ^Q
    enum uint TIOCMSET   = _IOW!(int)('t', 109); // set all modem bits
    enum uint TIOCMBIS   = _IOW!(int)('t', 108); // bis modem bits
    enum uint TIOCMBIC   = _IOW!(int)('t', 107); // bic modem bits
    enum uint TIOCMGET   = _IOR!(int)('t', 106); // get all modem bits
    enum uint TIOCREMOTE = _IOW!(int)('t', 105); // remote input editing
    enum uint TIOCGWINSZ = _IOR!(winsize)('t', 104);  // get window size
    enum uint TIOCSWINSZ = _IOW!(winsize)('t', 103);  // set window size
    enum uint TIOCUCNTL  = _IOW!(int)('t', 102); // pty: set/clr usr cntl mode
    enum uint TIOCSTAT   = _IO('t', 101);      // simulate ^T status message
    enum uint   UIOCCMD(n) = _IO('u', n);      // usr cntl op "n"
    enum uint TIOCSCONS = _IO('t', 99);        // 4.2 compatibility
    enum uint TIOCCONS  = _IOW!(int)('t', 98); // become virtual console
    enum uint TIOCSCTTY = _IO('t', 97);        // become controlling tty
    enum uint TIOCEXT   = _IOW!(int)('t', 96); // pty: external processing
    enum uint TIOCSIG   =   _IO('t', 95);      // pty: generate signal
    enum uint TIOCDRAIN =   _IO('t', 94);      // wait till output drained
    enum uint TIOCMSDTRWAIT =  _IOW!(int)('t', 91);  // modem: set wait on close
    enum uint TIOCMGDTRWAIT =  _IOR!(int)('t', 90);  // modem: get wait on close
    enum uint TIOCTIMESTAMP =  _IOR!(timeval)('t', 89);   // enable/get timestamp
                                                          // of last input event
    enum uint TIOCDCDTIMESTAMP = _IOR!(timeval)('t', 88); // enable/get timestamp
                                                          // of last DCd rise
    enum uint TIOCSDRAINWAIT   = _IOW!(int)('t', 87); // set ttywait timeout
    enum uint TIOCGDRAINWAIT   = _IOR!(int)('t', 86); // get ttywait timeout
    enum uint TIOCDSIMICROCODE = _IO('t', 85);        // download microcode to
                                                      // DSI Softmodem
    enum uint TIOCPTYGRANT  =  _IO('t', 84);   // grantpt(3)
    enum uint TIOCPTYGNAME  =  _IOC(IOC_OUT, 't', 83, 128); // ptsname(3)
    enum uint TIOCPTYUNLK   =  _IO('t', 82);   // unlockpt(3)

    enum uint TTYDISC  = 0;       // termios tty line discipline
    enum uint TABLDISC = 3;       // tablet discipline
    enum uint SLIPDISC = 4;       // serial IP discipline
    enum uint PPPDISC  = 5;       // PPP discipline
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly,
              Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.types;

private import core.sys.posix.config;
private import core.stdc.stdint;
public import core.stdc.stddef;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C):

//
// bits/typesizes.h -- underlying types for *_t.
//
/*
__syscall_slong_t
__syscall_ulong_t
*/
version (CRuntime_Glibc)
{
    version (X86_64)
    {
        version (D_X32)
        {
            // X32 kernel interface is 64-bit.
            alias long slong_t;
            alias ulong ulong_t;
        }
        else
        {
            alias c_long slong_t;
            alias c_ulong ulong_t;
        }
    }
    else
    {
        alias c_long slong_t;
        alias c_ulong ulong_t;
    }
}
else
{
    alias c_long slong_t;
    alias c_ulong ulong_t;
}

//
// Required
//
/*
blkcnt_t
blksize_t
dev_t
gid_t
ino_t
mode_t
nlink_t
off_t
pid_t
size_t
ssize_t
time_t
uid_t
*/

version (CRuntime_Glibc)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    alias long      blkcnt_t;
    alias ulong     ino_t;
    alias long      off_t;
  }
  else
  {
    alias slong_t   blkcnt_t;
    alias ulong_t   ino_t;
    alias slong_t   off_t;
  }
    alias slong_t   blksize_t;
    alias ulong     dev_t;
    alias uint      gid_t;
    alias uint      mode_t;
    alias ulong_t   nlink_t;
    alias int       pid_t;
    //size_t (defined in core.stdc.stddef)
    alias c_long    ssize_t;
    alias slong_t   time_t;
    alias uint      uid_t;
}
else version (CRuntime_Musl)
{
    alias long      blksize_t;
    alias ulong     nlink_t;
    alias long      dev_t;
    alias long      blkcnt_t;
    alias ulong     ino_t;
    alias long      off_t;
    alias long      _Addr;
    alias int       pid_t;
    alias uint      uid_t;
    alias uint      gid_t;
    alias long      time_t;
    alias long      clock_t;
    alias ulong     pthread_t;
    alias _Addr     ssize_t;
}
else version (Darwin)
{
    alias long      blkcnt_t;
    alias int       blksize_t;
    alias int       dev_t;
    alias uint      gid_t;
    alias ulong     ino_t;
    alias ushort    mode_t;
    alias ushort    nlink_t;
    alias long      off_t;
    alias int       pid_t;
    //size_t (defined in core.stdc.stddef)
    alias c_long    ssize_t;
    alias c_long    time_t;
    alias uint      uid_t;
}
else version (FreeBSD)
{
    // https://github.com/freebsd/freebsd/blob/master/sys/sys/_types.h
    alias long      blkcnt_t;
    alias uint      blksize_t;
    alias uint      dev_t;
    alias uint      gid_t;
    alias uint      ino_t;
    alias ushort    mode_t;
    alias ushort    nlink_t;
    alias long      off_t;
    alias int       pid_t;
    //size_t (defined in core.stdc.stddef)
    alias c_long    ssize_t;
    alias c_long    time_t;
    alias uint      uid_t;
    alias uint      fflags_t;
}
else version (NetBSD)
{
    alias long      blkcnt_t;
    alias int       blksize_t;
    alias ulong     dev_t;
    alias uint      gid_t;
    alias ulong     ino_t;
    alias uint      mode_t;
    alias uint      nlink_t;
    alias ulong     off_t;
    alias int       pid_t;
    //size_t (defined in core.stdc.stddef)
    alias c_long      ssize_t;
    alias c_long      time_t;
    alias uint        uid_t;
}
else version (DragonFlyBSD)
{
    alias long      blkcnt_t;
    alias long      blksize_t;
    alias uint      dev_t;
    alias uint      gid_t;
    alias long      ino_t;
    alias ushort    mode_t;
    alias uint      nlink_t;
    alias long      off_t;      //__off_t (defined in /usr/include/sys/stdint.h -> core.stdc.stddef)
    alias int       pid_t;      // size_t (defined in /usr/include/sys/stdint.h -> core.stdc.stddef)
    alias c_long    ssize_t;
    alias long      time_t;
    alias uint      uid_t;
}
else version (Solaris)
{
    alias char* caddr_t;
    alias c_long daddr_t;
    alias short cnt_t;

    static if (__USE_FILE_OFFSET64)
    {
        alias long blkcnt_t;
        alias ulong ino_t;
        alias long off_t;
    }
    else
    {
        alias c_long blkcnt_t;
        alias c_ulong ino_t;
        alias c_long off_t;
    }

    version (D_LP64)
    {
        alias blkcnt_t blkcnt64_t;
        alias ino_t ino64_t;
        alias off_t off64_t;
    }
    else
    {
        alias long blkcnt64_t;
        alias ulong ino64_t;
        alias long off64_t;
    }

    alias uint blksize_t;
    alias c_ulong dev_t;
    alias uid_t gid_t;
    alias uint mode_t;
    alias uint nlink_t;
    alias int pid_t;
    alias c_long ssize_t;
    alias c_long time_t;
    alias uint uid_t;
}
else version (CRuntime_Bionic)
{
    alias c_ulong   blkcnt_t;
    alias c_ulong   blksize_t;
    alias size_t    dev_t;
    alias uint      gid_t;
    alias c_ulong   ino_t;
    alias c_long    off_t;
    alias int       pid_t;
    alias c_long    ssize_t;
    alias c_long    time_t;
    alias uint      uid_t;

    version (D_LP64)
    {
        alias uint      mode_t;
        alias uint      nlink_t;
    }
    else
    {
        alias ushort    mode_t;
        alias ushort    nlink_t;
    }
}
else version (CRuntime_UClibc)
{
    static if ( __USE_FILE_OFFSET64 )
    {
        alias long      blkcnt_t;
        alias ulong     ino_t;
        alias long      off_t;
    }
    else
    {
        alias slong_t   blkcnt_t;
        alias ulong_t   ino_t;
        alias slong_t   off_t;
    }

    version (D_LP64)
    {
        alias ino_t ino64_t;
        alias off_t off64_t;
    }
    else
    {
        alias ulong ino64_t;
        alias long off64_t;
    }

    alias slong_t   blksize_t;
    alias c_ulong   dev_t;
    alias uint      gid_t;
    alias uint      mode_t;
    alias uint      nlink_t;
    alias int       pid_t;
    //size_t (defined in core.stdc.stddef)
    alias c_long    ssize_t;
    alias slong_t   time_t;
    alias uint      uid_t;
}
else
{
    static assert(false, "Unsupported platform");
}

//
// XOpen (XSI)
//
/*
clock_t
fsblkcnt_t
fsfilcnt_t
id_t
key_t
suseconds_t
useconds_t
*/

version (CRuntime_Glibc)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
  }
  else
  {
    alias ulong_t   fsblkcnt_t;
    alias ulong_t   fsfilcnt_t;
  }
    alias slong_t   clock_t;
    alias uint      id_t;
    alias int       key_t;
    alias slong_t   suseconds_t;
    alias uint      useconds_t;
}
else version (Darwin)
{
    alias uint   fsblkcnt_t;
    alias uint   fsfilcnt_t;
    alias c_long clock_t;
    alias uint   id_t;
    // key_t
    alias int    suseconds_t;
    alias uint   useconds_t;
}
else version (FreeBSD)
{
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
    alias c_long    clock_t;
    alias long      id_t;
    alias c_long    key_t;
    alias c_long    suseconds_t;
    alias uint      useconds_t;
}
else version (NetBSD)
{
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
    alias c_long    clock_t;
    alias long      id_t;
    alias c_long    key_t;
    alias c_long    suseconds_t;
    alias uint      useconds_t;
}
else version (DragonFlyBSD)
{
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
    alias c_long    clock_t;
    alias long      id_t;
    alias c_long    key_t;
    alias c_long    suseconds_t;
    alias uint      useconds_t;
}
else version (Solaris)
{
    static if (__USE_FILE_OFFSET64)
    {
        alias ulong fsblkcnt_t;
        alias ulong fsfilcnt_t;
    }
    else
    {
        alias c_ulong fsblkcnt_t;
        alias c_ulong fsfilcnt_t;
    }

    alias c_long clock_t;
    alias int id_t;
    alias int key_t;
    alias c_long suseconds_t;
    alias uint useconds_t;

    alias id_t taskid_t;
    alias id_t projid_t;
    alias id_t poolid_t;
    alias id_t zoneid_t;
    alias id_t ctid_t;
}
else version (CRuntime_Bionic)
{
    alias c_ulong  fsblkcnt_t;
    alias c_ulong  fsfilcnt_t;
    alias c_long   clock_t;
    alias uint     id_t;
    alias int      key_t;
    alias c_long   suseconds_t;
    alias uint     useconds_t; // Updated in Lollipop
}
else version (CRuntime_Musl)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
  }
  else
  {
    alias ulong_t   fsblkcnt_t;
    alias ulong_t   fsfilcnt_t;
  }
    alias uint mode_t;
    alias uint id_t;
    alias long suseconds_t;
}
else version (CRuntime_UClibc)
{
  static if ( __USE_FILE_OFFSET64 )
  {
    alias ulong     fsblkcnt_t;
    alias ulong     fsfilcnt_t;
  }
  else
  {
    alias ulong_t   fsblkcnt_t;
    alias ulong_t   fsfilcnt_t;
  }
    alias slong_t   clock_t;
    alias uint      id_t;
    alias int       key_t;
    alias slong_t   suseconds_t;
    alias uint      useconds_t;
}
else
{
    static assert(false, "Unsupported platform");
}

//
// Thread (THR)
//
/*
pthread_attr_t
pthread_cond_t
pthread_condattr_t
pthread_key_t
pthread_mutex_t
pthread_mutexattr_t
pthread_once_t
pthread_rwlock_t
pthread_rwlockattr_t
pthread_t
*/

version (CRuntime_Glibc)
{
    version (X86)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (X86_64)
    {
        static if (__WORDSIZE == 64)
        {
            enum __SIZEOF_PTHREAD_ATTR_T = 56;
            enum __SIZEOF_PTHREAD_MUTEX_T = 40;
            enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
            enum __SIZEOF_PTHREAD_COND_T = 48;
            enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
            enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
            enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
            enum __SIZEOF_PTHREAD_BARRIER_T = 32;
            enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
        }
        else
        {
            enum __SIZEOF_PTHREAD_ATTR_T = 32;
            enum __SIZEOF_PTHREAD_MUTEX_T = 32;
            enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
            enum __SIZEOF_PTHREAD_COND_T = 48;
            enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
            enum __SIZEOF_PTHREAD_RWLOCK_T = 44;
            enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
            enum __SIZEOF_PTHREAD_BARRIER_T = 20;
            enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
        }
    }
    else version (AArch64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 64;
        enum __SIZEOF_PTHREAD_MUTEX_T = 48;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 8;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 8;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 8;
    }
    else version (ARM)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (HPPA)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 48;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 64;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 48;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (IA64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (MIPS32)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (MIPS64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (PPC)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (PPC64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (RISCV32)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (RISCV64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (SPARC64)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (S390)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else version (SystemZ)
    {
        enum __SIZEOF_PTHREAD_ATTR_T = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
    }
    else
    {
        static assert (false, "Unsupported platform");
    }

    union pthread_attr_t
    {
        byte[__SIZEOF_PTHREAD_ATTR_T] __size;
        c_long __align;
    }

    private alias int __atomic_lock_t;

    private struct _pthread_fastlock
    {
        c_long          __status;
        __atomic_lock_t __spinlock;
    }

    private alias void* _pthread_descr;

    union pthread_cond_t
    {
        byte[__SIZEOF_PTHREAD_COND_T] __size;
        long  __align;
    }

    union pthread_condattr_t
    {
        byte[__SIZEOF_PTHREAD_CONDATTR_T] __size;
        int __align;
    }

    alias uint pthread_key_t;

    union pthread_mutex_t
    {
        byte[__SIZEOF_PTHREAD_MUTEX_T] __size;
        c_long __align;
    }

    union pthread_mutexattr_t
    {
        byte[__SIZEOF_PTHREAD_MUTEXATTR_T] __size;
        int __align;
    }

    alias int pthread_once_t;

    struct pthread_rwlock_t
    {
        byte[__SIZEOF_PTHREAD_RWLOCK_T] __size;
        c_long __align;
    }

    struct pthread_rwlockattr_t
    {
        byte[__SIZEOF_PTHREAD_RWLOCKATTR_T] __size;
        c_long __align;
    }

    alias c_ulong pthread_t;
}
else version (CRuntime_Musl)
{
    version (X86_64) {
        union pthread_attr_t
        {
            int[14] __i;
            ulong[7] __s;
        }
        union pthread_cond_t
        {
            int[12] __i;
            void*[6] __p;
        }
        union pthread_mutex_t
        {
            int[10] __i;
            void*[5] __p;
        }
        union pthread_rwlock_t
        {
            int[14] __i;
            void*[7] __p;
        }
        struct pthread_rwlockattr_t
        {
            uint[2] __attr;
        }
        alias uint pthread_key_t;
        alias uint pthread_condattr_t;
        alias uint pthread_mutexattr_t;
        alias int pthread_once_t;
    }
    else
    {
        static assert (false, "Architecture unsupported");
    }
}
else version (Darwin)
{
    version (D_LP64)
    {
        enum __PTHREAD_SIZE__               = 1168;
        enum __PTHREAD_ATTR_SIZE__          = 56;
        enum __PTHREAD_MUTEXATTR_SIZE__     = 8;
        enum __PTHREAD_MUTEX_SIZE__         = 56;
        enum __PTHREAD_CONDATTR_SIZE__      = 8;
        enum __PTHREAD_COND_SIZE__          = 40;
        enum __PTHREAD_ONCE_SIZE__          = 8;
        enum __PTHREAD_RWLOCK_SIZE__        = 192;
        enum __PTHREAD_RWLOCKATTR_SIZE__    = 16;
    }
    else
    {
        enum __PTHREAD_SIZE__               = 596;
        enum __PTHREAD_ATTR_SIZE__          = 36;
        enum __PTHREAD_MUTEXATTR_SIZE__     = 8;
        enum __PTHREAD_MUTEX_SIZE__         = 40;
        enum __PTHREAD_CONDATTR_SIZE__      = 4;
        enum __PTHREAD_COND_SIZE__          = 24;
        enum __PTHREAD_ONCE_SIZE__          = 4;
        enum __PTHREAD_RWLOCK_SIZE__        = 124;
        enum __PTHREAD_RWLOCKATTR_SIZE__    = 12;
    }

    struct pthread_handler_rec
    {
      void function(void*)  __routine;
      void*                 __arg;
      pthread_handler_rec*  __next;
    }

    struct pthread_attr_t
    {
        c_long                              __sig;
        byte[__PTHREAD_ATTR_SIZE__]         __opaque;
    }

    struct pthread_cond_t
    {
        c_long                              __sig;
        byte[__PTHREAD_COND_SIZE__]         __opaque;
    }

    struct pthread_condattr_t
    {
        c_long                              __sig;
        byte[__PTHREAD_CONDATTR_SIZE__]     __opaque;
    }

    alias c_ulong pthread_key_t;

    struct pthread_mutex_t
    {
        c_long                              __sig;
        byte[__PTHREAD_MUTEX_SIZE__]        __opaque;
    }

    struct pthread_mutexattr_t
    {
        c_long                              __sig;
        byte[__PTHREAD_MUTEXATTR_SIZE__]    __opaque;
    }

    struct pthread_once_t
    {
        c_long                              __sig;
        byte[__PTHREAD_ONCE_SIZE__]         __opaque;
    }

    struct pthread_rwlock_t
    {
        c_long                              __sig;
        byte[__PTHREAD_RWLOCK_SIZE__]       __opaque;
    }

    struct pthread_rwlockattr_t
    {
        c_long                              __sig;
        byte[__PTHREAD_RWLOCKATTR_SIZE__]   __opaque;
    }

    private struct _opaque_pthread_t
    {
        c_long                  __sig;
        pthread_handler_rec*    __cleanup_stack;
        byte[__PTHREAD_SIZE__]  __opaque;
    }

    alias _opaque_pthread_t* pthread_t;
}
else version (FreeBSD)
{
    alias int lwpid_t;

    alias void* pthread_attr_t;
    alias void* pthread_cond_t;
    alias void* pthread_condattr_t;
    alias void* pthread_key_t;
    alias void* pthread_mutex_t;
    alias void* pthread_mutexattr_t;
    alias void* pthread_once_t;
    alias void* pthread_rwlock_t;
    alias void* pthread_rwlockattr_t;
    alias void* pthread_t;
}
else version (NetBSD)
{
   struct pthread_queue_t {
         void*  ptqh_first;
         void** ptqh_last;
   }

    alias lwpid_t = int;
    alias pthread_spin_t = ubyte;
    struct pthread_attr_t {
        uint    pta_magic;
        int     pta_flags;
        void*   pta_private;
    }
    struct  pthread_spinlock_t {
        uint    pts_magic;
        pthread_spin_t  pts_spin;
        int             pts_flags;
    }
    struct pthread_cond_t {
        uint    ptc_magic;
        pthread_spin_t  ptc_lock;
        pthread_queue_t ptc_waiters;
        pthread_mutex_t *ptc_mutex;
        void*   ptc_private;
    }
    struct pthread_condattr_t {
        uint    ptca_magic;
        void    *ptca_private;
    }
    struct pthread_mutex_t {
        uint ptm_magic;
        pthread_spin_t  ptm_errorcheck;
        ubyte[3]         ptm_pad1;
        pthread_spin_t  ptm_interlock;
        ubyte[3] ptm_pad2;
        pthread_t ptm_owner;
        void* ptm_waiters;
        uint  ptm_recursed;
        void* ptm_spare2;
    }
    struct pthread_mutexattr_t{
        uint    ptma_magic;
        void*   ptma_private;
    }
    struct pthread_once_t{
        pthread_mutex_t pto_mutex;
        int     pto_done;
    }
    struct pthread_rwlock_t{
        uint    ptr_magic;

        pthread_spin_t  ptr_interlock;

        pthread_queue_t ptr_rblocked;
        pthread_queue_t ptr_wblocked;
        uint    ptr_nreaders;
        pthread_t ptr_owner;
        void    *ptr_private;
    }
    struct pthread_rwlockattr_t{
        uint    ptra_magic;
        void*   ptra_private;
    }

    alias uint pthread_key_t;
    alias void* pthread_t;
}
else version (DragonFlyBSD)
{
    alias int lwpid_t;

    alias void* pthread_attr_t;
    alias void* pthread_cond_t;
    alias void* pthread_condattr_t;
    alias void* pthread_key_t;
    alias void* pthread_mutex_t;
    alias void* pthread_mutexattr_t;
    alias void* pthread_once_t;
    alias void* pthread_rwlock_t;
    alias void* pthread_rwlockattr_t;
    alias void* pthread_t;
}
else version (Solaris)
{
    alias uint pthread_t;

    struct pthread_attr_t
    {
        void* __pthread_attrp;
    }

    struct pthread_cond_t
    {
        struct ___pthread_cond_flags
        {
            ubyte[4] __pthread_cond_flags;
            ushort __pthread_cond_type;
            ushort __pthread_cond_magic;
        }

        ___pthread_cond_flags __pthread_cond_flags;
        ulong __pthread_cond_data;
    }

    struct pthread_condattr_t
    {
        void* __pthread_condattrp;
    }

    struct pthread_rwlock_t
    {
        int __pthread_rwlock_readers;
        ushort __pthread_rwlock_type;
        ushort __pthread_rwlock_magic;
        pthread_mutex_t __pthread_rwlock_mutex;
        pthread_cond_t __pthread_rwlock_readercv;
        pthread_cond_t __pthread_rwlock_writercv;
    }

    struct pthread_rwlockattr_t
    {
        void* __pthread_rwlockattrp;
    }

    struct pthread_mutex_t
    {
        struct ___pthread_mutex_flags
        {
            ushort __pthread_mutex_flag1;
            ubyte __pthread_mutex_flag2;
            ubyte __pthread_mutex_ceiling;
            ushort __pthread_mutex_type;
            ushort __pthread_mutex_magic;
        }

        ___pthread_mutex_flags __pthread_mutex_flags;

        union ___pthread_mutex_lock
        {
            struct ___pthread_mutex_lock64
            {
                ubyte[8] __pthread_mutex_pad;
            }

            ___pthread_mutex_lock64 __pthread_mutex_lock64;

            struct ___pthread_mutex_lock32
            {
                uint __pthread_ownerpid;
                uint __pthread_lockword;
            }

            ___pthread_mutex_lock32 __pthread_mutex_lock32;
            ulong __pthread_mutex_owner64;
        }

        ___pthread_mutex_lock __pthread_mutex_lock;
        ulong __pthread_mutex_data;
    }

    struct pthread_mutexattr_t
    {
        void* __pthread_mutexattrp;
    }

    struct pthread_once_t
    {
        ulong[4] __pthread_once_pad;
    }

    alias uint pthread_key_t;
}
else version (CRuntime_Bionic)
{
    struct pthread_attr_t
    {
        uint    flags;
        void*   stack_base;
        size_t  stack_size;
        size_t  guard_size;
        int     sched_policy;
        int     sched_priority;
        version (D_LP64) char[16] __reserved = 0;
    }

    struct pthread_cond_t
    {
        version (D_LP64)
            int[12] __private;
        else
            int[1] __private;
    }

    alias c_long pthread_condattr_t;
    alias int    pthread_key_t;

    struct pthread_mutex_t
    {
        version (D_LP64)
            int[10] __private;
        else
            int[1] __private;
    }

    alias c_long pthread_mutexattr_t;
    alias int    pthread_once_t;

    struct pthread_rwlock_t
    {
        version (D_LP64)
            int[14] __private;
        else
            int[10] __private;
    }

    alias c_long pthread_rwlockattr_t;
    alias c_long pthread_t;
}
else version (CRuntime_UClibc)
{
     version (X86_64)
     {
        enum __SIZEOF_PTHREAD_ATTR_T        = 56;
        enum __SIZEOF_PTHREAD_MUTEX_T       = 40;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T   = 4;
        enum __SIZEOF_PTHREAD_COND_T        = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T    = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T      = 56;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T  = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T     = 32;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
     }
     else version (MIPS32)
     {
        enum __SIZEOF_PTHREAD_ATTR_T        = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T       = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T   = 4;
        enum __SIZEOF_PTHREAD_COND_T        = 48;
        enum __SIZEOF_PTHREAD_CONDATTR_T    = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T      = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T  = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T     = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
     }
     else version (ARM)
     {
        enum __SIZEOF_PTHREAD_ATTR_T = 36;
        enum __SIZEOF_PTHREAD_MUTEX_T = 24;
        enum __SIZEOF_PTHREAD_MUTEXATTR_T = 4;
        enum __SIZEOF_PTHREAD_COND_T = 48;
        enum __SIZEOF_PTHREAD_COND_COMPAT_T = 12;
        enum __SIZEOF_PTHREAD_CONDATTR_T = 4;
        enum __SIZEOF_PTHREAD_RWLOCK_T = 32;
        enum __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;
        enum __SIZEOF_PTHREAD_BARRIER_T = 20;
        enum __SIZEOF_PTHREAD_BARRIERATTR_T = 4;
     }
     else
     {
        static assert (false, "Architecture unsupported");
     }

    union pthread_attr_t
    {
        byte[__SIZEOF_PTHREAD_ATTR_T] __size;
        c_long __align;
    }

    union pthread_cond_t
    {
        struct data
        {
            int __lock;
            uint __futex;
            ulong __total_seq;
            ulong __wakeup_seq;
            ulong __woken_seq;
            void *__mutex;
            uint __nwaiters;
            uint __broadcast_seq;
        } data __data;
        byte[__SIZEOF_PTHREAD_COND_T] __size;
        long  __align;
    }

    union pthread_condattr_t
    {
        byte[__SIZEOF_PTHREAD_CONDATTR_T] __size;
        c_long __align;
    }

    alias uint pthread_key_t;

    struct __pthread_slist_t
    {
      __pthread_slist_t* __next;
    }

    union pthread_mutex_t
    {
      struct __pthread_mutex_s
      {
        int __lock;
        uint __count;
        int __owner;
        /* KIND must stay at this position in the structure to maintain
           binary compatibility.  */
        int __kind;
        uint __nusers;
        union
        {
          int __spins;
          __pthread_slist_t __list;
        }
      }
      __pthread_mutex_s __data;
        byte[__SIZEOF_PTHREAD_MUTEX_T] __size;
        c_long __align;
    }

    union pthread_mutexattr_t
    {
        byte[__SIZEOF_PTHREAD_MUTEXATTR_T] __size;
        c_long __align;
    }

    alias int pthread_once_t;

    struct pthread_rwlock_t
    {
        struct data
        {
            int __lock;
            uint __nr_readers;
            uint __readers_wakeup;
            uint __writer_wakeup;
            uint __nr_readers_queued;
            uint __nr_writers_queued;
            version (BigEndian)
            {
                ubyte __pad1;
                ubyte __pad2;
                ubyte __shared;
                ubyte __flags;
            }
            else
            {
                ubyte __flags;
                ubyte __shared;
                ubyte __pad1;
                ubyte __pad2;
            }
            int __writer;
        } data __data;
        byte[__SIZEOF_PTHREAD_RWLOCK_T] __size;
        c_long __align;
    }

    struct pthread_rwlockattr_t
    {
        byte[__SIZEOF_PTHREAD_RWLOCKATTR_T] __size;
        c_long __align;
    }

    alias c_ulong pthread_t;
}
else
{
    static assert(false, "Unsupported platform");
}

//
// Barrier (BAR)
//
/*
pthread_barrier_t
pthread_barrierattr_t
*/

version (CRuntime_Glibc)
{
    struct pthread_barrier_t
    {
        byte[__SIZEOF_PTHREAD_BARRIER_T] __size;
        c_long __align;
    }

    struct pthread_barrierattr_t
    {
        byte[__SIZEOF_PTHREAD_BARRIERATTR_T] __size;
        int __align;
    }
}
else version (FreeBSD)
{
    alias void* pthread_barrier_t;
    alias void* pthread_barrierattr_t;
}
else version (NetBSD)
{
    alias void* pthread_barrier_t;
    alias void* pthread_barrierattr_t;
}
else version (DragonFlyBSD)
{
    alias void* pthread_barrier_t;
    alias void* pthread_barrierattr_t;
}
else version (Darwin)
{
}
else version (Solaris)
{
    struct pthread_barrier_t
    {
        uint __pthread_barrier_count;
        uint __pthread_barrier_current;
        ulong __pthread_barrier_cycle;
        ulong __pthread_barrier_reserved;
        pthread_mutex_t __pthread_barrier_lock;
        pthread_cond_t __pthread_barrier_cond;
    }

    struct pthread_barrierattr_t
    {
        void* __pthread_barrierattrp;
    }
}
else version (CRuntime_Bionic)
{
}
else version (CRuntime_Musl)
{
}
else version (CRuntime_UClibc)
{
    struct pthread_barrier_t
    {
        byte[__SIZEOF_PTHREAD_BARRIER_T] __size;
        c_long __align;
    }

    struct pthread_barrierattr_t
    {
        byte[__SIZEOF_PTHREAD_BARRIERATTR_T] __size;
        int __align;
    }
}
else
{
    static assert(false, "Unsupported platform");
}

//
// Spin (SPN)
//
/*
pthread_spinlock_t
*/

version (CRuntime_Glibc)
{
    alias int pthread_spinlock_t; // volatile
}
else version (FreeBSD)
{
    alias void* pthread_spinlock_t;
}
else version (NetBSD)
{
    //already defined
}
else version (DragonFlyBSD)
{
    alias void* pthread_spinlock_t;
}
else version (Solaris)
{
    alias pthread_mutex_t pthread_spinlock_t;
}
else version (CRuntime_UClibc)
{
    alias int pthread_spinlock_t; // volatile
}

//
// Timer (TMR)
//
/*
clockid_t
timer_t
*/

//
// Trace (TRC)
//
/*
trace_attr_t
trace_event_id_t
trace_event_set_t
trace_id_t
*/
                                                                                                                                 /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.uio;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for ssize_t

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C) nothrow @nogc:

//
// Required
//
/*
struct iovec
{
    void*  iov_base;
    size_t iov_len;
}

ssize_t // from core.sys.posix.sys.types
size_t  // from core.sys.posix.sys.types

ssize_t readv(int, in iovec*, int);
ssize_t writev(int, in iovec*, int);
*/

version (CRuntime_Glibc)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (Darwin)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (FreeBSD)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (NetBSD)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (DragonFlyBSD)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (Solaris)
{
    struct iovec
    {
        void* iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (CRuntime_Bionic)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    int readv(int, in iovec*, int);
    int writev(int, in iovec*, int);
}
else version (CRuntime_Musl)
{
    struct iovec
    {
        void* iov_base;
        uint  iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else version (CRuntime_UClibc)
{
    struct iovec
    {
        void*  iov_base;
        size_t iov_len;
    }

    ssize_t readv(int, in iovec*, int);
    ssize_t writev(int, in iovec*, int);
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.un;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern(C):

public import core.sys.posix.sys.socket: sa_family_t;

//
// Required
//
/*
struct sockaddr_un
{
    sa_family_t sun_family;
    char        sa_data[];
}

sa_family_t    // From core.sys.posix.sys.socket
*/

version (linux)
{
    enum UNIX_PATH_MAX = 108;

    struct sockaddr_un
    {
        sa_family_t         sun_family;
        byte[UNIX_PATH_MAX] sun_path;
    }
}
else version (Darwin)
{
    struct sockaddr_un
    {
        ubyte       sun_len;
        sa_family_t sun_family;
        byte[104]   sun_path;
    }
}
else version (FreeBSD)
{
    struct sockaddr_un
    {
        ubyte       sun_len;
        sa_family_t sun_family;
        byte[104]   sun_path;
    }
}
else version (NetBSD)
{
    struct sockaddr_un
    {
        ubyte       sun_len;
        sa_family_t sun_family;
        byte[104]   sun_path;
    }
}
else version (DragonFlyBSD)
{
    struct sockaddr_un
    {
        ubyte       sun_len;
        sa_family_t sun_family;
        byte[104]   sun_path;
    }
}
else version (Solaris)
{
    struct sockaddr_un
    {
        sa_family_t  sun_family;
        byte[108]    sun_path;
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
// Interface to <sys/utsname.h>

module core.sys.posix.sys.utsname;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern(C):
nothrow:
@nogc:

version (CRuntime_Glibc)
{
    private enum utsNameLength = 65;

    struct utsname
    {
        char[utsNameLength] sysname = 0;
        char[utsNameLength] nodename = 0;
        char[utsNameLength] release = 0;
        char[utsNameLength] version_ = 0;
        // TODO Deprecate after version_ has been in an official release.
        alias update = version_;
        char[utsNameLength] machine = 0;

        char[utsNameLength] __domainname = 0;
    }

    int uname(utsname* __name);
}
else version (Darwin)
{
    private enum utsNameLength = 256;

    struct utsname
    {
        char[utsNameLength] sysname = 0;
        char[utsNameLength] nodename = 0;
        char[utsNameLength] release = 0;
        char[utsNameLength] version_ = 0;
        // TODO Deprecate after version_ has been in an official release.
        alias update = version_;
        char[utsNameLength] machine = 0;
    }

    int uname(utsname* __name);
}
else version (FreeBSD)
{
    //private enum SYS_NMLN = 32;       // old FreeBSD 1.1 ABI
    private enum SYS_NMLN = 256;

    struct utsname
    {
        char[SYS_NMLN] sysname = 0;
        char[SYS_NMLN] nodename = 0;
        char[SYS_NMLN] release = 0;
        char[SYS_NMLN] version_ = 0;
        // TODO Deprecate after version_ has been in an official release.
        alias update = version_;
        char[SYS_NMLN] machine = 0;
    }

    int __xuname(int, void*);
    int uname()(utsname* __name) { return __xuname(SYS_NMLN, cast(void*) __name); }
}
else version (NetBSD)
{
    private enum utsNameLength = 256;

    struct utsname
    {
        char[utsNameLength] sysname = 0;
        char[utsNameLength] nodename = 0;
        char[utsNameLength] release = 0;
        char[utsNameLength] version_ = 0;
        // TODO Deprecate after version_ has been in an official release.
        alias update = version_;
        char[utsNameLength] machine = 0;
    }

    int uname(utsname* __name);
}
else version (DragonFlyBSD)
{
    private enum utsNameLength = 32;

    struct utsname
    {
        char[utsNameLength] sysname = 0;
        char[utsNameLength] nodename = 0;
        char[utsNameLength] release = 0;
        char[utsNameLength] version_ = 0;
        // TODO Deprecate after version_ has been in an official release.
        alias update = version_;
        char[utsNameLength] machine = 0;
    }

    int uname(utsname* __name);
}
else version (Solaris)
{
    private enum SYS_NMLN = 257;

    struct utsname
    {
        char[SYS_NMLN] sysname = 0;
        char[SYS_NMLN] nodename = 0;
        char[SYS_NMLN] release = 0;
        // The field name is version but version is a keyword in D.
        char[SYS_NMLN] _version = 0;
        char[SYS_NMLN] machine = 0;
    }

    int uname(utsname* __name);
}
else version (CRuntime_Bionic)
{
    private enum SYS_NMLN = 65;

    struct utsname
    {
        char[SYS_NMLN] sysname = 0;
        char[SYS_NMLN] nodename = 0;
        char[SYS_NMLN] release = 0;
        // The field name is version but version is a keyword in D.
        char[SYS_NMLN] _version = 0;
        char[SYS_NMLN] machine = 0;
        char[SYS_NMLN] domainname = 0;
    }

    int uname(utsname*);
}
else version (CRuntime_Musl)
{
    private enum SYS_NMLN = 65;

    struct utsname
    {
        char[SYS_NMLN] sysname = 0;
        char[SYS_NMLN] nodename = 0;
        char[SYS_NMLN] release = 0;
        char[SYS_NMLN] _version = 0;
        char[SYS_NMLN] machine = 0;
        char[SYS_NMLN] domainname = 0;
    }

    int uname(utsname*);
}
else version (CRuntime_UClibc)
{
    private enum utsNameLength = 65;

    struct utsname
    {
        char[utsNameLength] sysname = 0;
        char[utsNameLength] nodename = 0;
        char[utsNameLength] release = 0;
        char[utsNameLength] version_ = 0;
        char[utsNameLength] machine = 0;
        char[utsNameLength] domainname = 0;
    }

    int uname(utsname*);
}
else
{
    static assert(false, "unsupported system");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
 * D header file for POSIX.
 *
 * Copyright: Copyright Sean Kelly 2005 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Sean Kelly, Alex Rønne Petersen
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Sean Kelly 2005 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.sys.wait;

private import core.sys.posix.config;
public import core.sys.posix.sys.types; // for id_t, pid_t
public import core.sys.posix.signal;    // for siginfo_t (XSI)
//public import core.sys.posix.resource; // for rusage (XSI)

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):
extern (C) nothrow @nogc:

//
// Required
//
/*
WNOHANG
WUNTRACED

WEXITSTATUS
WIFCONTINUED
WIFEXITED
WIFSIGNALED
WIFSTOPPED
WSTOPSIG
WTERMSIG

pid_t wait(int*);
pid_t waitpid(pid_t, int*, int);
*/

version (CRuntime_Glibc)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum __W_CONTINUED = 0xFFFF;

        extern (D) int __WTERMSIG( int status ) { return status & 0x7F; }
    }

    //
    // NOTE: These macros assume __USE_MISC is not defined in the relevant
    //       C headers as the parameter definition there is different and
    //       much more complicated.
    //
    extern (D) int  WEXITSTATUS( int status )  { return ( status & 0xFF00 ) >> 8;   }
    extern (D) int  WIFCONTINUED( int status ) { return status == __W_CONTINUED;    }
    extern (D) bool WIFEXITED( int status )    { return __WTERMSIG( status ) == 0;  }
    extern (D) bool WIFSIGNALED( int status )
    {
        return ( cast(byte) ( ( status & 0x7F ) + 1 ) >> 1 ) > 0;
    }
    extern (D) bool WIFSTOPPED( int status )   { return ( status & 0xFF ) == 0x7F;  }
    extern (D) int  WSTOPSIG( int status )     { return WEXITSTATUS( status );      }
    extern (D) int  WTERMSIG( int status )     { return status & 0x7F;              }
}
else version (Darwin)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum _WSTOPPED = 0x7F; // octal 0177
    }

    extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }
    extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }
    extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }
    extern (D) bool WIFEXITED( int status )     { return _WSTATUS(status) == 0;     }
    extern (D) bool WIFSIGNALED( int status )
    {
        return _WSTATUS( status ) != _WSTOPPED && _WSTATUS( status ) != 0;
    }
    extern (D) bool WIFSTOPPED( int status )   { return _WSTATUS( status ) == _WSTOPPED; }
    extern (D) int  WSTOPSIG( int status )     { return status >> 8;                     }
    extern (D) int  WTERMSIG( int status )     { return _WSTATUS( status );              }
}
else version (FreeBSD)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum _WSTOPPED = 0x7F; // octal 0177
    }

    extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }
    extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }
    extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }
    extern (D) bool WIFEXITED( int status )     { return _WSTATUS(status) == 0;     }
    extern (D) bool WIFSIGNALED( int status )
    {
        return _WSTATUS( status ) != _WSTOPPED && _WSTATUS( status ) != 0;
    }
    extern (D) bool WIFSTOPPED( int status )   { return _WSTATUS( status ) == _WSTOPPED; }
    extern (D) int  WSTOPSIG( int status )     { return status >> 8;                     }
    extern (D) int  WTERMSIG( int status )     { return _WSTATUS( status );              }
}
else version (NetBSD)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum _WSTOPPED = 0x7F; // octal 0177
    }

    extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }
    extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }
    extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }
    extern (D) bool WIFEXITED( int status )     { return _WSTATUS(status) == 0;     }
    extern (D) bool WIFSIGNALED( int status )
    {
        return _WSTATUS( status ) != _WSTOPPED && _WSTATUS( status ) != 0;
    }
    extern (D) bool WIFSTOPPED( int status )   { return _WSTATUS( status ) == _WSTOPPED; }
    extern (D) int  WSTOPSIG( int status )     { return status >> 8;                     }
    extern (D) int  WTERMSIG( int status )     { return _WSTATUS( status );              }
}
else version (DragonFlyBSD)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum _WSTOPPED = 0x7F; // octal 0177
    }

    extern (D) int _WSTATUS(int status)         { return (status & 0x7F);           }
    extern (D) int  WEXITSTATUS( int status )   { return (status >> 8);             }
    extern (D) int  WIFCONTINUED( int status )  { return status == 0x13;            }
    extern (D) bool WIFEXITED( int status )     { return _WSTATUS(status) == 0;     }
    extern (D) bool WIFSIGNALED( int status )
    {
        return _WSTATUS( status ) != _WSTOPPED && _WSTATUS( status ) != 0;
    }
    extern (D) bool WIFSTOPPED( int status )   { return _WSTATUS( status ) == _WSTOPPED; }
    extern (D) int  WSTOPSIG( int status )     { return status >> 8;                     }
    extern (D) int  WTERMSIG( int status )     { return _WSTATUS( status );              }
}
else version (Solaris)
{
    enum WNOHANG        = 64;
    enum WUNTRACED      = 4;

    extern (D) int WEXITSTATUS(int status) { return (status >> 8) & 0xff; }
    extern (D) int WIFCONTINUED(int status) { return (status & 0xffff) == 0xffff; }
    extern (D) bool WIFEXITED(int status) { return (status & 0xff) == 0;     }
    extern (D) bool WIFSIGNALED(int status) { return (status & 0xff) > 0 && (status & 0xff00) == 0; }
    extern (D) bool WIFSTOPPED(int status) { return (status & 0xff) == 0x7f && (status & 0xff00) != 0; }
    extern (D) int WSTOPSIG(int status) { return (status >> 8) & 0x7f; }
    extern (D) int WTERMSIG(int status) { return (status & 0x7f); }
}
else version (CRuntime_Bionic)
{
    enum WNOHANG   = 1;
    enum WUNTRACED = 2;

    extern (D) int  WEXITSTATUS( int status ) { return ( status & 0xFF00 ) >> 8; }
    extern (D) bool WIFEXITED( int status ) { return WTERMSIG(status) == 0; }
    extern (D) bool WIFSIGNALED( int status ) { return WTERMSIG(status + 1) >= 2; }
    extern (D) bool WIFSTOPPED( int status ) { return WTERMSIG(status) == 0x7F; }
    extern (D) int  WSTOPSIG( int status ) { return WEXITSTATUS(status); }
    extern (D) int  WTERMSIG( int status ) { return status & 0x7F; }
}
else version (CRuntime_Musl)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    extern (D) int  WEXITSTATUS( int status ) { return ( status & 0xFF00 ) >> 8; }
    extern (D) int  WIFCONTINUED( int status ) { return status == 0xffff; }
    extern (D) bool WIFEXITED( int status ) { return WTERMSIG( status ) == 0; }
    extern (D) bool WIFSIGNALED( int status ) { return (status&0xffff)-1U < 0xffU; }
    extern (D) bool WIFSTOPPED( int status ) { return cast(short)(((status&0xffff)*0x10001)>>8) > 0x7f00; }
    extern (D) int  WTERMSIG( int status ) { return status & 0x7F; }
    alias WEXITSTATUS WSTOPSIG;
}
else version (CRuntime_UClibc)
{
    enum WNOHANG        = 1;
    enum WUNTRACED      = 2;

    private
    {
        enum __W_CONTINUED = 0xFFFF;

        extern (D) int __WTERMSIG( int status ) { return status & 0x7F; }
    }

    //
    // NOTE: These macros assume __USE_BSD is not defined in the relevant
    //       C headers as the parameter definition there is different and
    //       much more complicated.
    //
    extern (D) int  WEXITSTATUS( int status )  { return ( status & 0xFF00 ) >> 8;   }
    extern (D) int  WIFCONTINUED( int status ) { return status == __W_CONTINUED;    }
    extern (D) bool WIFEXITED( int status )    { return __WTERMSIG( status ) == 0;  }
    extern (D) bool WIFSIGNALED( int status )
    {
        return ( cast(ulong) ( ( status & 0xffff ) - 1U ) >> 1 ) < 0xffU;
    }
    version (MIPS32)
    {
        extern (D) bool WIFSTOPPED( int status )   { return ( status & 0xFF ) == 0x7F;  }
    }
    else
    {
        extern (D) bool WIFSTOPPED( int status )   { return ( status & 0xFF ) == 0x7F && ( status & 0xFF00 );  }
    }
    extern (D) int  WSTOPSIG( int status )     { return WEXITSTATUS( status );      }
    extern (D) int  WTERMSIG( int status )     { return status & 0x7F;              }
}
else
{
    static assert(false, "Unsupported platform");
}

pid_t wait(int*);
pid_t waitpid(pid_t, int*, int);

//
// XOpen (XSI)
//
/*
WEXITED
WSTOPPED
WCONTINUED
WNOWAIT

enum idtype_t
{
    P_ALL,
    P_PID,
    P_PGID
}

int waitid(idtype_t, id_t, siginfo_t*, int);
*/

version (CRuntime_Glibc)
{
    enum WEXITED    = 4;
    enum WSTOPPED   = 2;
    enum WCONTINUED = 8;
    enum WNOWAIT    = 0x01000000;

    enum idtype_t
    {
        P_ALL,
        P_PID,
        P_PGID
    }

    int waitid(idtype_t, id_t, siginfo_t*, int);
}
else version (Darwin)
{
    enum WEXITED    = 0x00000004;
    enum WSTOPPED   = 0x00000008;
    enum WCONTINUED = 0x00000010;
    enum WNOWAIT    = 0x00000020;

    enum idtype_t
    {
        P_ALL,
        P_PID,
        P_PGID
    }

    int waitid(idtype_t, id_t, siginfo_t*, int);
}
else version (FreeBSD)
{
    enum WSTOPPED       = WUNTRACED;
    enum WCONTINUED     = 4;
    enum WNOWAIT        = 8;

    // http://www.freebsd.org/projects/c99/
}
else version (NetBSD)
{
    enum WSTOPPED       = WUNTRACED;
    //enum WCONTINUED     = 4;
    enum WNOWAIT        = 0x00010000;
}
else version (DragonFlyBSD)
{
    enum WSTOPPED       = WUNTRACED;
    enum WCONTINUED     = 4;
    enum WNOWAIT        = 8;
}
else version (Solaris)
{
    enum WEXITED = 1;
    enum WTRAPPED = 2;
    enum WSTOPPED = WUNTRACED;
    enum WCONTINUED = 8;
    enum WNOWAIT = 128;

    enum idtype_t
    {
        P_PID,          /* A process identifier.                */
        P_PPID,         /* A parent process identifier.         */
        P_PGID,         /* A process group (job control group)  */
                        /* identifier.                          */
        P_SID,          /* A session identifier.                */
        P_CID,          /* A scheduling class identifier.       */
        P_UID,          /* A user identifier.                   */
        P_GID,          /* A group identifier.                  */
        P_ALL,          /* All processes.                       */
        P_LWPID,        /* An LWP identifier.                   */
        P_TASKID,       /* A task identifier.                   */
        P_PROJID,       /* A project identifier.                */
        P_POOLID,       /* A pool identifier.                   */
        P_ZONEID,       /* A zone identifier.                   */
        P_CTID,         /* A (process) contract identifier.     */
        P_CPUID,        /* CPU identifier.                      */
        P_PSETID,       /* Processor set identifier             */
    }

    int waitid(idtype_t, id_t, siginfo_t*, int);
}
else version (CRuntime_Bionic)
{
    enum WEXITED    = 4;
    enum WSTOPPED   = 2;
    enum WCONTINUED = 8;
    enum WNOWAIT    = 0x01000000;

    alias int idtype_t;

    int waitid(idtype_t, id_t, siginfo_t*, int);
}
else version (CRuntime_Musl)
{
}
else version (CRuntime_UClibc)
{
    enum WEXITED    = 4;
    enum WSTOPPED   = 2;
    enum WCONTINUED = 8;
    enum WNOWAIT    = 0x01000000;

    enum idtype_t
    {
        P_ALL,
        P_PID,
        P_PGID
    }

    int waitid(idtype_t, id_t, siginfo_t*, int);
}
else
{
    static assert(false, "Unsupported platform");
}
                                                                                                                                                     /**
 * D header file for POSIX system logger API.
 * (http://pubs.opengroup.org/onlinepubs/007904875/basedefs/syslog.h.html)
 *
 * Copyright: Copyright Adil Baig 2013.
 * License:   $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   Adil Baig
 * Standards: The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition
 */

/*          Copyright Adil Baig 2013.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module core.sys.posix.syslog;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Posix):

extern (C) nothrow @nogc:

version (CRuntime_Glibc)
{
    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,  /* log the pid with each message */
        LOG_CONS   = 0x02,  /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,  /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,  /* don't delay open */
        LOG_NOWAIT = 0x10,  /* don't wait for console forks: DEPRECATED */
        LOG_PERROR = 0x20,  /* log to stderr as well */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (Darwin)
{
    //http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/osfmk/sys/syslog.h

    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,     /* log the pid with each message */
        LOG_CONS   = 0x02,  /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,  /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,  /* don't delay open */
        LOG_NOWAIT = 0x10,  /* don't wait for console forks: DEPRECATED */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /* reserved for local use */
        LOG_LOCAL6 = (22<<3), /* reserved for local use */
        LOG_LOCAL7 = (23<<3), /* reserved for local use */

        LOG_NFACILITIES = 24,  /* current number of facilities */
    };

    int LOG_MASK(int pri) { return 1 << pri; }        /* mask for one priority */
    int LOG_UPTO(int pri) { return (1 << (pri+1)) - 1; }  /* all priorities through pri */

    void openlog (const char *, int __option, int __facility);
    int  setlogmask (int __mask);
    void syslog (int __pri, const char *__fmt, ...);
    void closelog();
}
else version (FreeBSD)
{
    //http://fxr.watson.org/fxr/source/sys/syslog.h

    //PRIORITY
    enum {
        LOG_EMERG = 0,     /* system is unusable */
        LOG_ALERT = 1,     /* action must be taken immediately */
        LOG_CRIT  = 2,     /* critical conditions */
        LOG_ERR   = 3,     /* error conditions */
        LOG_WARNING = 4,   /* warning conditions */
        LOG_NOTICE  = 5,   /* normal but significant condition */
        LOG_INFO    = 6,   /* informational */
        LOG_DEBUG   = 7,   /* debug-level messages */
    };

    //OPTIONS
    enum {
        LOG_PID    = 0x01,    /* log the pid with each message */
        LOG_CONS   = 0x02,    /* log on the console if errors in sending */
        LOG_ODELAY = 0x04,    /* delay open until first syslog() (default) */
        LOG_NDELAY = 0x08,    /* don't delay open */
        LOG_NOWAIT = 0x10,    /* don't wait for console forks: DEPRECATED */
        LOG_PERROR = 0x20,    /* log to stderr as well */
    };

    //FACILITY
    enum {
        LOG_KERN   = (0<<3),  /* kernel messages */
        LOG_USER   = (1<<3),  /* random user-level messages */
        LOG_MAIL   = (2<<3),  /* mail system */
        LOG_DAEMON = (3<<3),  /* system daemons */
        LOG_AUTH   = (4<<3),  /* security/authorization messages */
        LOG_SYSLOG = (5<<3),  /* messages generated internally by syslogd */
        LOG_LPR    = (6<<3),  /* line printer subsystem */
        LOG_NEWS   = (7<<3),  /* network news subsystem */
        LOG_UUCP   = (8<<3),  /* UUCP subsystem */
        LOG_CRON   = (9<<3),  /* clock daemon */
        LOG_AUTHPRIV = (10<<3), /* security/authorization messages (private), */
        LOG_FTP    =  (11<<3), /* ftp daemon */
        LOG_NTP    = (12<<3), /* NTP subsystem */
        LOG_SECURITY = (13<<3), /* security subsystems (firewalling, etc.) */
        LOG_CONSOLE  = (14<<3), /* /dev/console output */

        /* other codes through 15 reserved for system use */
        LOG_LOCAL0 = (16<<3), /* reserved for local use */
        LOG_LOCAL1 = (17<<3), /* reserved for local use */
        LOG_LOCAL2 = (18<<3), /* reserved for local use */
        LOG_LOCAL3 = (19<<3), /* reserved for local use */
        LOG_LOCAL4 = (20<<3), /* reserved for local use */
        LOG_LOCAL5 = (21<<3), /