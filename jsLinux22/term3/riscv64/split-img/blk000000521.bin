# This file is part of the GNU C Library and contains locale data.
# The Free Software Foundation does not claim any copyright interest
# in the locale data contained in this file.  The foregoing does not
# affect the license of the GNU C Library as a whole.  It does not
# exempt you from the conditions of the license if your use would
# otherwise be governed by that license.

LC_COLLATE

copy "iso14651_t1_common"

reorder-after <BEFORE-LATIN>

<U5416> <U5416>;IGNORE;IGNORE;IGNORE	#吖104
<U814C> <U814C>;IGNORE;IGNORE;IGNORE	#腌185
<U9312> <U9312>;IGNORE;IGNORE;IGNORE	#錒0
<U9515> <U9515>;IGNORE;IGNORE;IGNORE	#锕7
<U963F> <U963F>;IGNORE;IGNORE;IGNORE	#阿23237
<U55C4> <U55C4>;IGNORE;IGNORE;IGNORE	#嗄60
<U554A> <U554A>;IGNORE;IGNORE;IGNORE	#啊16566
<U54C0> <U54C0>;IGNORE;IGNORE;IGNORE	#哀4070
<U54CE> <U54CE>;IGNORE;IGNORE;IGNORE	#哎2473
<U5509> <U5509>;IGNORE;IGNORE;IGNORE	#唉1811
<U57C3> <U57C3>;IGNORE;IGNORE;IGNORE	#埃5192
<U5A2D> <U5A2D>;IGNORE;IGNORE;IGNORE	#娭0
<U6328> <U6328>;IGNORE;IGNORE;IGNORE	#挨2599
<U6371> <U6371>;IGNORE;IGNORE;IGNORE	#捱187
<U6B38> <U6B38>;IGNORE;IGNORE;IGNORE	#欸5
<U8BF6> <U8BF6>;IGNORE;IGNORE;IGNORE	#诶52
<U92B0> <U92B0>;IGNORE;IGNORE;IGNORE	#銰0
<U9384> <U9384>;IGNORE;IGNORE;IGNORE	#鎄0
<U953F> <U953F>;IGNORE;IGNORE;IGNORE	#锿201
<U3C6F> <U3C6F>;IGNORE;IGNORE;IGNORE	#㱯0
<U4839> <U4839>;IGNORE;IGNORE;IGNORE	#䠹0
<U4DA3> <U4DA3>;IGNORE;IGNORE;IGNORE	#䶣0
<U51D2> <U51D2>;IGNORE;IGNORE;IGNORE	#凒0
<U5393> <U5393>;IGNORE;IGNORE;IGNORE	#厓0
<U5540> <U5540>;IGNORE;IGNORE;IGNORE	#啀0
<U560A> <U560A>;IGNORE;IGNORE;IGNORE	#嘊0
<U5A3E> <U5A3E>;IGNORE;IGNORE;IGNORE	#娾0
<U5D66> <U5D66>;IGNORE;IGNORE;IGNORE	#嵦0
<U6571> <U6571>;IGNORE;IGNORE;IGNORE	#敱0
<U6573> <U6573>;IGNORE;IGNORE;IGNORE	#敳0
<U764C> <U764C>;IGNORE;IGNORE;IGNORE	#癌576
<U7691> <U7691>;IGNORE;IGNORE;IGNORE	#皑150
<U769A> <U769A>;IGNORE;IGNORE;IGNORE	#皚0
<U9A03> <U9A03>;IGNORE;IGNORE;IGNORE	#騃2
<U3478> <U3478>;IGNORE;IGNORE;IGNORE	#㑸0
<U35E8> <U35E8>;IGNORE;IGNORE;IGNORE	#㗨0
<U388A> <U388A>;IGNORE;IGNORE;IGNORE	#㢊0
<U4442> <U4442>;IGNORE;IGNORE;IGNORE	#䑂0
<U4A20> <U4A20>;IGNORE;IGNORE;IGNORE	#䨠0
<U4F41> <U4F41>;IGNORE;IGNORE;IGNORE	#佁0
<U55F3> <U55F3>;IGNORE;IGNORE;IGNORE	#嗳222
<U566F> <U566F>;IGNORE;IGNORE;IGNORE	#噯5
<U6639> <U6639>;IGNORE;IGNORE;IGNORE	#昹0
<U6BD0> <U6BD0>;IGNORE;IGNORE;IGNORE	#毐122
<U77EE> <U77EE>;IGNORE;IGNORE;IGNORE	#矮1684
<U853C> <U853C>;IGNORE;IGNORE;IGNORE	#蔼429
<U85F9> <U85F9>;IGNORE;IGNORE;IGNORE	#藹2
<U8EB7> <U8EB7>;IGNORE;IGNORE;IGNORE	#躷0
<U972D> <U972D>;IGNORE;IGNORE;IGNORE	#霭228
<U9744> <U9744>;IGNORE;IGNORE;IGNORE	#靄3
<U99A4> <U99A4>;IGNORE;IGNORE;IGNORE	#馤0
<U354C> <U354C>;IGNORE;IGNORE;IGNORE	#㕌0
<U35D2> <U35D2>;IGNORE;IGNORE;IGNORE	#㗒0
<U3637> <U3637>;IGNORE;IGNORE;IGNORE	#㘷0
<U3776> <U3776>;IGNORE;IGNORE;IGNORE	#㝶0
<U3905> <U3905>;IGNORE;IGNORE;IGNORE	#㤅0
<U3FC4> <U3FC4>;IGNORE;IGNORE;IGNORE	#㿄0
<U4033> <U4033>;IGNORE;IGNORE;IGNORE	#䀳0
<U416C> <U416C>;IGNORE;IGNORE;IGNORE	#䅬0
<U453D> <U453D>;IGNORE;IGNORE;IGNORE	#䔽0
<U477D> <U477D>;IGNORE;IGNORE;IGNORE	#䝽0
<U4B35> <U4B35>;IGNORE;IGNORE;IGNORE	#䬵0
<U4F0C> <U4F0C>;IGNORE;IGNORE;IGNORE	#伌0
<U50FE> <U50FE>;IGNORE;IGNORE;IGNORE	#僾0
<U53C6> <U53C6>;IGNORE;IGNORE;IGNORE	#叆2
<U545D> <U545D>;IGNORE;IGNORE;IGNORE	#呝0
<U55CC> <U55CC>;IGNORE;IGNORE;IGNORE	#嗌0
<U5828> <U5828>;IGNORE;IGNORE;IGNORE	#堨0
<U5867> <U5867>;IGNORE;IGNORE;IGNORE	#塧0
<U5AD2> <U5AD2>;IGNORE;IGNORE;IGNORE	#嫒11
<U5B21> <U5B21>;IGNORE;IGNORE;IGNORE	#嬡0
<U611B> <U611B>;IGNORE;IGNORE;IGNORE	#愛447
<U61D3> <U61D3>;IGNORE;IGNORE;IGNORE	#懓0
<U61DD> <U61DD>;IGNORE;IGNORE;IGNORE	#懝0
<U66A7> <U66A7>;IGNORE;IGNORE;IGNORE	#暧507
<U66D6> <U66D6>;IGNORE;IGNORE;IGNORE	#曖9
<U6FED> <U6FED>;IGNORE;IGNORE;IGNORE	#濭0
<U7231> <U7231>;IGNORE;IGNORE;IGNORE	#爱60751
<U7477> <U7477>;IGNORE;IGNORE;IGNORE	#瑷3
<U74A6> <U74A6>;IGNORE;IGNORE;IGNORE	#璦0
<U76A7> <U76A7>;IGNORE;IGNORE;IGNORE	#皧0
<U77B9> <U77B9>;IGNORE;IGNORE;IGNORE	#瞹1
<U7839> <U7839>;IGNORE;IGNORE;IGNORE	#砹0
<U784B> <U784B>;IGNORE;IGNORE;IGNORE	#硋0
<U788D> <U788D>;IGNORE;IGNORE;IGNORE	#碍2438
<U7919> <U7919>;IGNORE;IGNORE;IGNORE	#礙19
<U827E> <U827E>;IGNORE;IGNORE;IGNORE	#艾4290
<U8586> <U8586>;IGNORE;IGNORE;IGNORE	#薆0
<U8B6A> <U8B6A>;IGNORE;IGNORE;IGNORE	#譪1
<U8CF9> <U8CF9>;IGNORE;IGNORE;IGNORE	#賹0
<U9440> <U9440>;IGNORE;IGNORE;IGNORE	#鑀0
<U9698> <U9698>;IGNORE;IGNORE;IGNORE	#隘242
<U9749> <U9749>;IGNORE;IGNORE;IGNORE	#靉0
<U9C6B> <U9C6B>;IGNORE;IGNORE;IGNORE	#鱫1
<U9D31> <U9D31>;IGNORE;IGNORE;IGNORE	#鴱0
<U4F92> <U4F92>;IGNORE;IGNORE;IGNORE	#侒0
<U5388> <U5388>;IGNORE;IGNORE;IGNORE	#厈0
<U5A95> <U5A95>;IGNORE;IGNORE;IGNORE	#媕0
<U5B89> <U5B89>;IGNORE;IGNORE;IGNORE	#安57385
<U5CD6> <U5CD6>;IGNORE;IGNORE;IGNORE	#峖0
<U5E83> <U5E83>;IGNORE;IGNORE;IGNORE	#広0
<U5EB5> <U5EB5>;IGNORE;IGNORE;IGNORE	#庵436
<U6849> <U6849>;IGNORE;IGNORE;IGNORE	#桉15
<U6C28> <U6C28>;IGNORE;IGNORE;IGNORE	#氨141
<U75F7> <U75F7>;IGNORE;IGNORE;IGNORE	#痷0
<U76E6> <U76E6>;IGNORE;IGNORE;IGNORE	#盦0
<U76EB> <U76EB>;IGNORE;IGNORE;IGNORE	#盫3
<U8164> <U8164>;IGNORE;IGNORE;IGNORE	#腤0
<U843B> <U843B>;IGNORE;IGNORE;IGNORE	#萻0
<U844A> <U844A>;IGNORE;IGNORE;IGNORE	#葊0
<U84ED> <U84ED>;IGNORE;IGNORE;IGNORE	#蓭0
<U8A9D> <U8A9D>;IGNORE;IGNORE;IGNORE	#誝0
<U8AF3> <U8AF3>;IGNORE;IGNORE;IGNORE	#諳1
<U8C19> <U8C19>;IGNORE;IGNORE;IGNORE	#谙169
<U9625> <U9625>;IGNORE;IGNORE;IGNORE	#阥0
<U978C> <U978C>;IGNORE;IGNORE;IGNORE	#鞌0
<U978D> <U978D>;IGNORE;IGNORE;IGNORE	#鞍364
<U97FD> <U97FD>;IGNORE;IGNORE;IGNORE	#韽0
<U9D6A> <U9D6A>;IGNORE;IGNORE;IGNORE	#鵪0
<U9D95> <U9D95>;IGNORE;IGNORE;IGNORE	#鶕0
<U9E4C> <U9E4C>;IGNORE;IGNORE;IGNORE	#鹌49
<U4719> <U4719>;IGNORE;IGNORE;IGNORE	#䜙0
<U557D> <U557D>;IGNORE;IGNORE;IGNORE	#啽0
<U73B5> <U73B5>;IGNORE;IGNORE;IGNORE	#玵0
<U96F8> <U96F8>;IGNORE;IGNORE;IGNORE	#雸0
<U371D> <U371D>;IGNORE;IGNORE;IGNORE	#㜝0
<U3F62> <U3F62>;IGNORE;IGNORE;IGNORE	#㽢0
<U4156> <U4156>;IGNORE;IGNORE;IGNORE	#䅖0
<U4FFA> <U4FFA>;IGNORE;IGNORE;IGNORE	#俺1752
<U5535> <U5535>;IGNORE;IGNORE;IGNORE	#唵9
<U57B5> <U57B5>;IGNORE;IGNORE;IGNORE	#垵0
<U57EF> <U57EF>;IGNORE;IGNORE;IGNORE	#埯0
<U5837> <U5837>;IGNORE;IGNORE;IGNORE	#堷0
<U63DE> <U63DE>;IGNORE;IGNORE;IGNORE	#揞2
<U667B> <U667B>;IGNORE;IGNORE;IGNORE	#晻0
<U7F6F> <U7F6F>;IGNORE;IGNORE;IGNORE	#罯0
<U92A8> <U92A8>;IGNORE;IGNORE;IGNORE	#銨0
<U94F5> <U94F5>;IGNORE;IGNORE;IGNORE	#铵2
<U968C> <U968C>;IGNORE;IGNORE;IGNORE	#隌0
<U37C1> <U37C1>;IGNORE;IGNORE;IGNORE	#㟁0
<U3C58> <U3C58>;IGNORE;IGNORE;IGNORE	#㱘0
<U3E29> <U3E29>;IGNORE;IGNORE;IGNORE	#㸩0
<U4141> <U4141>;IGNORE;IGNORE;IGNORE	#䅁0
<U438F> <U438F>;IGNORE;IGNORE;IGNORE	#䎏0
<U43A8> <U43A8>;IGNORE;IGNORE;IGNORE	#䎨0
<U4B13> <U4B13>;IGNORE;IGNORE;IGNORE	#䬓0
<U4B97> <U4B97>;IGNORE;IGNORE;IGNORE	#䮗0
<U4BE5> <U4BE5>;IGNORE;IGNORE;IGNORE	#䯥0
<U5111> <U5111>;IGNORE;IGNORE;IGNORE	#儑0
<U530E> <U530E>;IGNORE;IGNORE;IGNORE	#匎0
<U533C> <U533C>;IGNORE;IGNORE;IGNORE	#匼0
<U5813> <U5813>;IGNORE;IGNORE;IGNORE	#堓0
<U5A69> <U5A69>;IGNORE;IGNORE;IGNORE	#婩0
<U5CB8> <U5CB8>;IGNORE;IGNORE;IGNORE	#岸9657
<U6309> <U6309>;IGNORE;IGNORE;IGNORE	#按14058
<U6697> <U6697>;IGNORE;IGNORE;IGNORE	#暗15285
<U6848> <U6848>;IGNORE;IGNORE;IGNORE	#案23506
<U6D1D> <U6D1D>;IGNORE;IGNORE;IGNORE	#洝0
<U72B4> <U72B4>;IGNORE;IGNORE;IGNORE	#犴10
<U80FA> <U80FA>;IGNORE;IGNORE;IGNORE	#胺113
<U834C> <U834C>;IGNORE;IGNORE;IGNORE	#荌0
<U83F4> <U83F4>;IGNORE;IGNORE;IGNORE	#菴2
<U8C7B> <U8C7B>;IGNORE;IGNORE;IGNORE	#豻0
<U8C8B> <U8C8B>;IGNORE;IGNORE;IGNORE	#貋0
<U930C> <U930C>;IGNORE;IGNORE;IGNORE	#錌0
<U95C7> <U95C7>;IGNORE;IGNORE;IGNORE	#闇1
<U9B9F> <U9B9F>;IGNORE;IGNORE;IGNORE	#鮟1
<U9EEC> <U9EEC>;IGNORE;IGNORE;IGNORE	#黬0
<U9EEF> <U9EEF>;IGNORE;IGNORE;IGNORE	#黯1334
<U80AE> <U80AE>;IGNORE;IGNORE;IGNORE	#肮736
<U9AAF> <U9AAF>;IGNORE;IGNORE;IGNORE	#骯10
<U3B7F> <U3B7F>;IGNORE;IGNORE;IGNORE	#㭿0
<U401A> <U401A>;IGNORE;IGNORE;IGNORE	#䀚0
<U44A2> <U44A2>;IGNORE;IGNORE;IGNORE	#䒢0
<U4A55> <U4A55>;IGNORE;IGNORE;IGNORE	#䩕0
<U4B79> <U4B79>;IGNORE;IGNORE;IGNORE	#䭹0
<U4B7A> <U4B7A>;IGNORE;IGNORE;IGNORE	#䭺0
<U536C> <U536C>;IGNORE;IGNORE;IGNORE	#卬0
<U5C87> <U5C87>;IGNORE;IGNORE;IGNORE	#岇0
<U6602> <U6602>;IGNORE;IGNORE;IGNORE	#昂1769
<U663B> <U663B>;IGNORE;IGNORE;IGNORE	#昻0
<U4369> <U4369>;IGNORE;IGNORE;IGNORE	#䍩0
<U8EEE> <U8EEE>;IGNORE;IGNORE;IGNORE	#軮0
<U39B9> <U39B9>;IGNORE;IGNORE;IGNORE	#㦹0
<U3F1C> <U3F1C>;IGNORE;IGNORE;IGNORE	#㼜0
<U678A> <U678A>;IGNORE;IGNORE;IGNORE	#枊0
<U76CE> <U76CE>;IGNORE;IGNORE;IGNORE	#盎183
<U91A0> <U91A0>;IGNORE;IGNORE;IGNORE	#醠0
<U51F9> <U51F9>;IGNORE;IGNORE;IGNORE	#凹537
<U5773> <U5773>;IGNORE;IGNORE;IGNORE	#坳76
<U5787> <U5787>;IGNORE;IGNORE;IGNORE	#垇0
<U67EA> <U67EA>;IGNORE;IGNORE;IGNORE	#柪0
<U688E> <U688E>;IGNORE;IGNORE;IGNORE	#梎0
<U71AC> <U71AC>;IGNORE;IGNORE;IGNORE	#熬1473
<U8EEA> <U8EEA>;IGNORE;IGNORE;IGNORE	#軪0
<U37FC> <U37FC>;IGNORE;IGNORE;IGNORE	#㟼0
<U3802> <U3802>;IGNORE;IGNORE;IGNORE	#㠂0
<U3FF0> <U3FF0>;IGNORE;IGNORE;IGNORE	#㿰0
<U443F> <U443F>;IGNORE;IGNORE;IGNORE	#䐿0
<U46AB> <U46AB>;IGNORE;IGNORE;IGNORE	#䚫0
<U495D> <U495D>;IGNORE;IGNORE;IGNORE	#䥝0
<U498B> <U498B>;IGNORE;IGNORE;IGNORE	#䦋0
<U4D45> <U4D45>;IGNORE;IGNORE;IGNORE	#䵅0
<U53AB> <U53AB>;IGNORE;IGNORE;IGNORE	#厫0
<U55F7> <U55F7>;IGNORE;IGNORE;IGNORE	#嗷197
<U55F8> <U55F8>;IGNORE;IGNORE;IGNORE	#嗸0
<U56C2> <U56C2>;IGNORE;IGNORE;IGNORE	#囂13
<U5D85> <U5D85>;IGNORE;IGNORE;IGNORE	#嶅0
<U5ED2> <U5ED2>;IGNORE;IGNORE;IGNORE	#廒3
<U646E> <U646E>;IGNORE;IGNORE;IGNORE	#摮1
<U6556> <U6556>;IGNORE;IGNORE;IGNORE	#敖456
<U6EF6> <U6EF6>;IGNORE;IGNORE;IGNORE	#滶0
<U720A> <U720A>;IGNORE;IGNORE;IGNORE	#爊0
<U7352> <U7352>;IGNORE;IGNORE;IGNORE	#獒19
<U7353> <U7353>;IGNORE;IGNORE;IGNORE	#獓0
<U7488> <U7488>;IGNORE;IGNORE;IGNORE	#璈0
<U78DD> <U78DD>;IGNORE;IGNORE;IGNORE	#磝1
<U7C22> <U7C22>;IGNORE;IGNORE;IGNORE	#簢0
<U7FF1> <U7FF1>;IGNORE;IGNORE;IGNORE	#翱96
<U7FF6> <U7FF6>;IGNORE;IGNORE;IGNORE	#翶0
<U7FFA> <U7FFA>;IGNORE;IGNORE;IGNORE	#翺0
<U8071> <U8071>;IGNORE;IGNORE;IGNORE	#聱11
<U851C> <U851C>;IGNORE;IGNORE;IGNORE	#蔜0
<U87AF> <U87AF>;IGNORE;IGNORE;IGNORE	#螯46
<U8B37> <U8B37>;IGNORE;IGNORE;IGNORE	#謷0
<U8B38> <U8B38>;IGNORE;IGNORE;IGNORE	#謸0
<U9068> <U9068>;IGNORE;IGNORE;IGNORE	#遨95
<U93D6> <U93D6>;IGNORE;IGNORE;IGNORE	#鏖29
<U969E> <U969E>;IGNORE;IGNORE;IGNORE	#隞0
<U9A9C> <U9A9C>;IGNORE;IGNORE;IGNORE	#骜69
<U9C32> <U9C32>;IGNORE;IGNORE;IGNORE	#鰲0
<U9CCC> <U9CCC>;IGNORE;IGNORE;IGNORE	#鳌1207
<U9DD4> <U9DD4>;IGNORE;IGNORE;IGNORE	#鷔0
<U9F07> <U9F07>;IGNORE;IGNORE;IGNORE	#鼇0
<U3443> <U3443>;IGNORE;IGNORE;IGNORE	#㑃0
<U3907> <U3907>;IGNORE;IGNORE;IGNORE	#㤇0
<U479D> <U479D>;IGNORE;IGNORE;IGNORE	#䞝0
<U4BE0> <U4BE0>;IGNORE;IGNORE;IGNORE	#䯠0
<U4D08> <U4D08>;IGNORE;IGNORE;IGNORE	#䴈0
<U5AAA> <U5AAA>;IGNORE;IGNORE;IGNORE	#媪78
<U5ABC> <U5ABC>;IGNORE;IGNORE;IGNORE	#媼0
<U629D> <U629D>;IGNORE;IGNORE;IGNORE	#抝0
<U82BA> <U82BA>;IGNORE;IGNORE;IGNORE	#芺0
<U8884> <U8884>;IGNORE;IGNORE;IGNORE	#袄550
<U8956> <U8956>;IGNORE;IGNORE;IGNORE	#襖2
<U957A> <U957A>;IGNORE;IGNORE;IGNORE	#镺0
<U9D01> <U9D01>;IGNORE;IGNORE;IGNORE	#鴁0
<U356D> <U356D>;IGNORE;IGNORE;IGNORE	#㕭0
<U362C> <U362C>;IGNORE;IGNORE;IGNORE	#㘬0
<U362D> <U362D>;IGNORE;IGNORE;IGNORE	#㘭0
<U371C> <U371C>;IGNORE;IGNORE;IGNORE	#㜜0
<U3729> <U3729>;IGNORE;IGNORE;IGNORE	#㜩0
<U3817> <U3817>;IGNORE;IGNORE;IGNORE	#㠗0
<U397F> <U397F>;IGNORE;IGNORE;IGNORE	#㥿0
<U4071> <U4071>;IGNORE;IGNORE;IGNORE	#䁱0
<U4712> <U4712>;IGNORE;IGNORE;IGNORE	#䜒0
<U4AE8> <U4AE8>;IGNORE;IGNORE;IGNORE	#䫨0
<U4BAF> <U4BAF>;IGNORE;IGNORE;IGNORE	#䮯0
<U50B2> <U50B2>;IGNORE;IGNORE;IGNORE	#傲3629
<U58BA> <U58BA>;IGNORE;IGNORE;IGNORE	#墺0
<U5961> <U5961>;IGNORE;IGNORE;IGNORE	#奡0
<U5965> <U5965>;IGNORE;IGNORE;IGNORE	#奥8357
<U5967> <U5967>;IGNORE;IGNORE;IGNORE	#奧19
<U5AEF> <U5AEF>;IGNORE;IGNORE;IGNORE	#嫯0
<U5C99> <U5C99>;IGNORE;IGNORE;IGNORE	#岙7
<U5DB4> <U5DB4>;IGNORE;IGNORE;IGNORE	#嶴0
<U6160> <U6160>;IGNORE;IGNORE;IGNORE	#慠0
<U61CA> <U61CA>;IGNORE;IGNORE;IGNORE	#懊465
<U6277> <U6277>;IGNORE;IGNORE;IGNORE	#扷0
<U64D9> <U64D9>;IGNORE;IGNORE;IGNORE	#擙0
<U6F9A> <U6F9A>;IGNORE;IGNORE;IGNORE	#澚0
<U6FB3> <U6FB3>;IGNORE;IGNORE;IGNORE	#澳3259
<U8A4F> <U8A4F>;IGNORE;IGNORE;IGNORE	#詏0
<U93CA> <U93CA>;IGNORE;IGNORE;IGNORE	#鏊6
<U9A41> <U9A41>;IGNORE;IGNORE;IGNORE	#驁0
<U4EC8> <U4EC8>;IGNORE;IGNORE;IGNORE	#仈0
<U516B> <U516B>;IGNORE;IGNORE;IGNORE	#八24979
<U53ED> <U53ED>;IGNORE;IGNORE;IGNORE	#叭1022
<U5427> <U5427>;IGNORE;IGNORE;IGNORE	#吧28122
<U54F5> <U54F5>;IGNORE;IGNORE;IGNORE	#哵0
<U593F> <U593F>;IGNORE;IGNORE;IGNORE	#夿0
<U5C9C> <U5C9C>;IGNORE;IGNORE;IGNORE	#岜123
<U5DF4> <U5DF4>;IGNORE;IGNORE;IGNORE	#巴24063
<U6252> <U6252>;IGNORE;IGNORE;IGNORE	#扒672
<U634C> <U634C>;IGNORE;IGNORE;IGNORE	#捌7
<U6733> <U6733>;IGNORE;IGNORE;IGNORE	#朳0
<U7390> <U7390>;IGNORE;IGNORE;IGNORE	#玐0
<U75A4> <U75A4>;IGNORE;IGNORE;IGNORE	#疤604
<U7B06> <U7B06>;IGNORE;IGNORE;IGNORE	#笆174
<U7C91> <U7C91>;IGNORE;IGNORE;IGNORE	#粑50
<U7D26> <U7D26>;IGNORE;IGNORE;IGNORE	#紦0
<U7F93> <U7F93>;IGNORE;IGNORE;IGNORE	#羓0
<U82AD> <U82AD>;IGNORE;IGNORE;IGNORE	#芭597
<U8C5D> <U8C5D>;IGNORE;IGNORE;IGNORE	#豝0
<U91DF> <U91DF>;IGNORE;IGNORE;IGNORE	#釟0
<U9B5E> <U9B5E>;IGNORE;IGNORE;IGNORE	#魞0
<U9C83> <U9C83>;IGNORE;IGNORE;IGNORE	#鲃0
<U351C> <U351C>;IGNORE;IGNORE;IGNORE	#㔜0
<U39CA> <U39CA>;IGNORE;IGNORE;IGNORE	#㧊0
<U47E6> <U47E6>;IGNORE;IGNORE;IGNORE	#䟦0
<U4CC1> <U4CC1>;IGNORE;IGNORE;IGNORE	#䳁0
<U4CCA> <U4CCA>;IGNORE;IGNORE;IGNORE	#䳊0
<U53D0> <U53D0>;IGNORE;IGNORE;IGNORE	#叐0
<U577A> <U577A>;IGNORE;IGNORE;IGNORE	#坺0
<U58A2> <U58A2>;IGNORE;IGNORE;IGNORE	#墢0
<U59AD> <U59AD>;IGNORE;IGNORE;IGNORE	#妭0
<U629C> <U629C>;IGNORE;IGNORE;IGNORE	#抜0
<U62D4> <U62D4>;IGNORE;IGNORE;IGNORE	#拔3205
<U70A6> <U70A6>;IGNORE;IGNORE;IGNORE	#炦0
<U72AE> <U72AE>;IGNORE;IGNORE;IGNORE	#犮0
<U79E1> <U79E1>;IGNORE;IGNORE;IGNORE	#秡0
<U7B29> <U7B29>;IGNORE;IGNORE;IGNORE	#笩0
<U80C8> <U80C8>;IGNORE;IGNORE;IGNORE	#胈0
<U8307> <U8307>;IGNORE;IGNORE;IGNORE	#茇0
<U8337> <U8337>;IGNORE;IGNORE;IGNORE	#茷0
<U83DD> <U83DD>;IGNORE;IGNORE;IGNORE	#菝1
<U8A59> <U8A59>;IGNORE;IGNORE;IGNORE	#詙0
<U8DCB> <U8DCB>;IGNORE;IGNORE;IGNORE	#跋491
<U8EF7> <U8EF7>;IGNORE;IGNORE;IGNORE	#軷0
<U9238> <U9238>;IGNORE;IGNORE;IGNORE	#鈸0
<U94B9> <U94B9>;IGNORE;IGNORE;IGNORE	#钹27
<U98B0> <U98B0>;IGNORE;IGNORE;IGNORE	#颰0
<U999B> <U999B>;IGNORE;IGNORE;IGNORE	#馛0
<U9B43> <U9B43>;IGNORE;IGNORE;IGNORE	#魃12
<U9F25> <U9F25>;IGNORE;IGNORE;IGNORE	#鼥0
<U378E> <U378E>;IGNORE;IGNORE;IGNORE	#㞎0
<U628A> <U628A>;IGNORE;IGNORE;IGNORE	#把82906
<U6B1B> <U6B1B>;IGNORE;IGNORE;IGNORE	#欛0
<U9200> <U9200>;IGNORE;IGNORE;IGNORE	#鈀2
<U94AF> <U94AF>;IGNORE;IGNORE;IGNORE	#钯8
<U9776> <U9776>;IGNORE;IGNORE;IGNORE	#靶287
<U35A0> <U35A0>;IGNORE;IGNORE;IGNORE	#㖠0
<U3D9A> <U3D9A>;IGNORE;IGNORE;IGNORE	#㶚0
<U40FB> <U40FB>;IGNORE;IGNORE;IGNORE	#䃻0
<U4189> <U4189>;IGNORE;IGNORE;IGNORE	#䆉0
<U41D1> <U41D1>;IGNORE;IGNORE;IGNORE	#䇑0
<U43AC> <U43AC>;IGNORE;IGNORE;IGNORE	#䎬0
<U43B1> <U43B1>;IGNORE;IGNORE;IGNORE	#䎱0
<U496F> <U496F>;IGNORE;IGNORE;IGNORE	#䥯0
<U4A57> <U4A57>;IGNORE;IGNORE;IGNORE	#䩗0
<U4A7B> <U4A7B>;IGNORE;IGNORE;IGNORE	#䩻0
<U4C3E> <U4C3E>;IGNORE;IGNORE;IGNORE	#䰾0
<U4C5D> <U4C5D>;IGNORE;IGNORE;IGNORE	#䱝0
<U575D> <U575D>;IGNORE;IGNORE;IGNORE	#坝1078
<U57BB> <U57BB>;IGNORE;IGNORE;IGNORE	#垻0
<U58E9> <U58E9>;IGNORE;IGNORE;IGNORE	#壩0
<U5F1D> <U5F1D>;IGNORE;IGNORE;IGNORE	#弝0
<U705E> <U705E>;IGNORE;IGNORE;IGNORE	#灞23
<U7238> <U7238>;IGNORE;IGNORE;IGNORE	#爸9385
<U7308> <U7308>;IGNORE;IGNORE;IGNORE	#猈0
<U7F62> <U7F62>;IGNORE;IGNORE;IGNORE	#罢8866
<U7F77> <U7F77>;IGNORE;IGNORE;IGNORE	#罷32
<U8019> <U8019>;IGNORE;IGNORE;IGNORE	#耙115
<U8987> <U8987>;IGNORE;IGNORE;IGNORE	#覇0
<U9738> <U9738>;IGNORE;IGNORE;IGNORE	#霸2421
<U9B81> <U9B81>;IGNORE;IGNORE;IGNORE	#鮁0
<U9B8A> <U9B8A>;IGNORE;IGNORE;IGNORE	#鮊0
<U9C85> <U9C85>;IGNORE;IGNORE;IGNORE	#鲅2
<U9C8C> <U9C8C>;IGNORE;IGNORE;IGNORE	#鲌0
<U6777> <U6777>;IGNORE;IGNORE;IGNORE	#杷53
<U63B0> <U63B0>;IGNORE;IGNORE;IGNORE	#掰307
<U3F1F> <U3F1F>;IGNORE;IGNORE;IGNORE	#㼟0
<U3FDF> <U3FDF>;IGNORE;IGNORE;IGNORE	#㿟0
<U4CC6> <U4CC6>;IGNORE;IGNORE;IGNORE	#䳆0
<U767D> <U767D>;IGNORE;IGNORE;IGNORE	#白54567
<U35D7> <U35D7>;IGNORE;IGNORE;IGNORE	#㗗0
<U3F23> <U3F23>;IGNORE;IGNORE;IGNORE	#㼣0
<U4653> <U4653>;IGNORE;IGNORE;IGNORE	#䙓0
<U4F70> <U4F70>;IGNORE;IGNORE;IGNORE	#佰44
<U5161> <U5161>;IGNORE;IGNORE;IGNORE	#兡0
<U636D> <U636D>;IGNORE;IGNORE;IGNORE	#捭19
<U6446> <U6446>;IGNORE;IGNORE;IGNORE	#摆8987
<U64FA> <U64FA>;IGNORE;IGNORE;IGNORE	#擺81
<U6822> <U6822>;IGNORE;IGNORE;IGNORE	#栢0
<U767E> <U767E>;IGNORE;IGNORE;IGNORE	#百24259
<U77F2> <U77F2>;IGNORE;IGNORE;IGNORE	#矲0
<U7CA8> <U7CA8>;IGNORE;IGNORE;IGNORE	#粨0
<U7D54> <U7D54>;IGNORE;IGNORE;IGNORE	#絔0
<U896C> <U896C>;IGNORE;IGNORE;IGNORE	#襬10
<U35D1> <U35D1>;IGNORE;IGNORE;IGNORE	#㗑0
<U3814> <U3814>;IGNORE;IGNORE;IGNORE	#㠔0
<U4494> <U4494>;IGNORE;IGNORE;IGNORE	#䒔0
<U4899> <U4899>;IGNORE;IGNORE;IGNORE	#䢙0
<U4D3D> <U4D3D>;IGNORE;IGNORE;IGNORE	#䴽0
<U5457> <U5457>;IGNORE;IGNORE;IGNORE	#呗389
<U5504> <U5504>;IGNORE;IGNORE;IGNORE	#唄1
<U5E8D> <U5E8D>;IGNORE;IGNORE;IGNORE	#庍0
<U62DC> <U62DC>;IGNORE;IGNORE;IGNORE	#拜7522
<U62DD> <U62DD>;IGNORE;IGNORE;IGNORE	#拝0
<U6557> <U6557>;IGNORE;IGNORE;IGNORE	#敗47
<U7A17> <U7A17>;IGNORE;IGNORE;IGNORE	#稗89
<U7CBA> <U7CBA>;IGNORE;IGNORE;IGNORE	#粺0
<U85AD> <U85AD>;IGNORE;IGNORE;IGNORE	#薭0
<U86FD> <U86FD>;IGNORE;IGNORE;IGNORE	#蛽2
<U8D01> <U8D01>;IGNORE;IGNORE;IGNORE	#贁0
<U8D25> <U8D25>;IGNORE;IGNORE;IGNORE	#败8562
<U9781> <U9781>;IGNORE;IGNORE;IGNORE	#鞁0
<U6273> <U6273>;IGNORE;IGNORE;IGNORE	#扳514
<U642C> <U642C>;IGNORE;IGNORE;IGNORE	#搬4336
<U653D> <U653D>;IGNORE;IGNORE;IGNORE	#攽0
<U6591> <U6591>;IGNORE;IGNORE;IGNORE	#斑2249
<U6592> <U6592>;IGNORE;IGNORE;IGNORE	#斒0
<U670C> <U670C>;IGNORE;IGNORE;IGNORE	#朌0
<U73ED> <U73ED>;IGNORE;IGNORE;IGNORE	#班16393
<U7622> <U7622>;IGNORE;IGNORE;IGNORE	#瘢31
<U764D> <U764D>;IGNORE;IGNORE;IGNORE	#癍7
<U80A6> <U80A6>;IGNORE;IGNORE;IGNORE	#肦0
<U822C> <U822C>;IGNORE;IGNORE;IGNORE	#般19472
<U8668> <U8668>;IGNORE;IGNORE;IGNORE	#虨0
<U878C> <U878C>;IGNORE;IGNORE;IGNORE	#螌0
<U8929> <U8929>;IGNORE;IGNORE;IGNORE	#褩0
<U8FAC> <U8FAC>;IGNORE;IGNORE;IGNORE	#辬0
<U9812> <U9812>;IGNORE;IGNORE;IGNORE	#頒8
<U9881> <U9881>;IGNORE;IGNORE;IGNORE	#颁600
<U3A6F> <U3A6F>;IGNORE;IGNORE;IGNORE	#㩯0
<U3E1E> <U3E1E>;IGNORE;IGNORE;IGNORE	#㸞0
<U3E9C> <U3E9C>;IGNORE;IGNORE;IGNORE	#㺜0
<U427D> <U427D>;IGNORE;IGNORE;IGNORE	#䉽0
<U4B33> <U4B33>;IGNORE;IGNORE;IGNORE	#䬳0
<U5742> <U5742>;IGNORE;IGNORE;IGNORE	#坂594
<U5C85> <U5C85>;IGNORE;IGNORE;IGNORE	#岅0
<U6604> <U6604>;IGNORE;IGNORE;IGNORE	#昄0
<U677F> <U677F>;IGNORE;IGNORE;IGNORE	#板14041
<U7248> <U7248>;IGNORE;IGNORE;IGNORE	#版16923
<U74EA> <U74EA>;IGNORE;IGNORE;IGNORE	#瓪0
<U7C84> <U7C84>;IGNORE;IGNORE;IGNORE	#粄0
<U8228> <U8228>;IGNORE;IGNORE;IGNORE	#舨2
<U8742> <U8742>;IGNORE;IGNORE;IGNORE	#蝂0
<U9211> <U9211>;IGNORE;IGNORE;IGNORE	#鈑0
<U94A3> <U94A3>;IGNORE;IGNORE;IGNORE	#钣3
<U95C6> <U95C6>;IGNORE;IGNORE;IGNORE	#闆19
<U962A> <U962A>;IGNORE;IGNORE;IGNORE	#阪575
<U3698> <U3698>;IGNORE;IGNORE;IGNORE	#㚘0
<U3AB5> <U3AB5>;IGNORE;IGNORE;IGNORE	#㪵0
<U4570> <U4570>;IGNORE;IGNORE;IGNORE	#䕰0
<U4F34> <U4F34>;IGNORE;IGNORE;IGNORE	#伴5195
<U529E> <U529E>;IGNORE;IGNORE;IGNORE	#办23937
<U534A> <U534A>;IGNORE;IGNORE;IGNORE	#半27746
<U59C5> <U59C5>;IGNORE;IGNORE;IGNORE	#姅0
<U6011> <U6011>;IGNORE;IGNORE;IGNORE	#怑1
<U626E> <U626E>;IGNORE;IGNORE;IGNORE	#扮2846
<U62CC> <U62CC>;IGNORE;IGNORE;IGNORE	#拌448
<U67C8> <U67C8>;IGNORE;IGNORE;IGNORE	#柈1
<U6E74> <U6E74>;IGNORE;IGNORE;IGNORE	#湴0
<U74E3> <U74E3>;IGNORE;IGNORE;IGNORE	#瓣1491
<U79DA> <U79DA>;IGNORE;IGNORE;IGNORE	#秚0
<U7D46> <U7D46>;IGNORE;IGNORE;IGNORE	#絆5
<U7ECA> <U7ECA>;IGNORE;IGNORE;IGNORE	#绊534
<U8FA6> <U8FA6>;IGNORE;IGNORE;IGNORE	#辦165
<U9261> <U9261>;IGNORE;IGNORE;IGNORE	#鉡0
<U977D> <U977D>;IGNORE;IGNORE;IGNORE	#靽0
<U57B9> <U57B9>;IGNORE;IGNORE;IGNORE	#垹0
<U5E2E> <U5E2E>;IGNORE;IGNORE;IGNORE	#帮14375
<U5E47> <U5E47>;IGNORE;IGNORE;IGNORE	#幇0
<U5E5A> <U5E5A>;IGNORE;IGNORE;IGNORE	#幚0
<U5E6B> <U5E6B>;IGNORE;IGNORE;IGNORE	#幫152
<U6360> <U6360>;IGNORE;IGNORE;IGNORE	#捠0
<U6886> <U6886>;IGNORE;IGNORE;IGNORE	#梆190
<U6D5C> <U6D5C>;IGNORE;IGNORE;IGNORE	#浜115
<U7E0D> <U7E0D>;IGNORE;IGNORE;IGNORE	#縍0
<U90A6> <U90A6>;IGNORE;IGNORE;IGNORE	#邦2855
<U90AB> <U90AB>;IGNORE;IGNORE;IGNORE	#邫0
<U97A4> <U97A4>;IGNORE;IGNORE;IGNORE	#鞤0
<U3519> <U3519>;IGNORE;IGNORE;IGNORE	#㔙0
<U3B84> <U3B84>;IGNORE;IGNORE;IGNORE	#㮄0
<U47FA> <U47FA>;IGNORE;IGNORE;IGNORE	#䟺0
<U6337> <U6337>;IGNORE;IGNORE;IGNORE	#挷0
<U6412> <U6412>;IGNORE;IGNORE;IGNORE	#搒1
<U699C> <U699C>;IGNORE;IGNORE;IGNORE	#榜1264
<U6C06> <U6C06>;IGNORE;IGNORE;IGNORE	#氆3
<U7253> <U7253>;IGNORE;IGNORE;IGNORE	#牓0
<U7D81> <U7D81>;IGNORE;IGNORE;IGNORE	#綁9
<U7ED1> <U7ED1>;IGNORE;IGNORE;IGNORE	#绑1385
<U8180> <U8180>;IGNORE;IGNORE;IGNORE	#膀2000
<U9AC8> <U9AC8>;IGNORE;IGNORE;IGNORE	#髈11
<U3B4B> <U3B4B>;IGNORE;IGNORE;IGNORE	#㭋0
<U3BC1> <U3BC1>;IGNORE;IGNORE;IGNORE	#㯁0
<U3FA6> <U3FA6>;IGNORE;IGNORE;IGNORE	#㾦0
<U409C> <U409C>;IGNORE;IGNORE;IGNORE	#䂜0
<U43A7> <U43A7>;IGNORE;IGNORE;IGNORE	#䎧0
<U45AB> <U45AB>;IGNORE;IGNORE;IGNORE	#䖫0
<U49DB> <U49DB>;IGNORE;IGNORE;IGNORE	#䧛0
<U4C37> <U4C37>;IGNORE;IGNORE;IGNORE	#䰷0
<U508D> <U508D>;IGNORE;IGNORE;IGNORE	#傍1673
<U585D> <U585D>;IGNORE;IGNORE;IGNORE	#塝0
<U68D2> <U68D2>;IGNORE;IGNORE;IGNORE	#棒2579
<U68D3> <U68D3>;IGNORE;IGNORE;IGNORE	#棓1
<U78C5> <U78C5>;IGNORE;IGNORE;IGNORE	#磅317
<U7A16> <U7A16>;IGNORE;IGNORE;IGNORE	#稖0
<U8255> <U8255>;IGNORE;IGNORE;IGNORE	#艕0
<U84A1> <U84A1>;IGNORE;IGNORE;IGNORE	#蒡11
<U868C> <U868C>;IGNORE;IGNORE;IGNORE	#蚌106
<U872F> <U872F>;IGNORE;IGNORE;IGNORE	#蜯0
<U8B17> <U8B17>;IGNORE;IGNORE;IGNORE	#謗3
<U8C24> <U8C24>;IGNORE;IGNORE;IGNORE	#谤205
<U938A> <U938A>;IGNORE;IGNORE;IGNORE	#鎊0
<U9551> <U9551>;IGNORE;IGNORE;IGNORE	#镑417
<U5265> <U5265>;IGNORE;IGNORE;IGNORE	#剥1669
<U52F9> <U52F9>;IGNORE;IGNORE;IGNORE	#勹2
<U5305> <U5305>;IGNORE;IGNORE;IGNORE	#包27740
<U5B62> <U5B62>;IGNORE;IGNORE;IGNORE	#孢106
<U67B9> <U67B9>;IGNORE;IGNORE;IGNORE	#枹3
<U7172> <U7172>;IGNORE;IGNORE;IGNORE	#煲50
<U7B23> <U7B23>;IGNORE;IGNORE;IGNORE	#笣0
<U80DE> <U80DE>;IGNORE;IGNORE;IGNORE	#胞2754
<U82DE> <U82DE>;IGNORE;IGNORE;IGNORE	#苞438
<U8554> <U8554>;IGNORE;IGNORE;IGNORE	#蕔0
<U8912> <U8912>;IGNORE;IGNORE;IGNORE	#褒172
<U8943> <U8943>;IGNORE;IGNORE;IGNORE	#襃0
<U95C1> <U95C1>;IGNORE;IGNORE;IGNORE	#闁0
<U9F59> <U9F59>;IGNORE;IGNORE;IGNORE	#齙0
<U9F85> <U9F85>;IGNORE;IGNORE;IGNORE	#龅7
<U3D61> <U3D61>;IGNORE;IGNORE;IGNORE	#㵡0
<U3FFA> <U3FFA>;IGNORE;IGNORE;IGNORE	#㿺0
<U420F> <U420F>;IGNORE;IGNORE;IGNORE	#䈏0
<U4964> <U4964>;IGNORE;IGNORE;IGNORE	#䥤0
<U4A0C> <U4A0C>;IGNORE;IGNORE;IGNORE	#䨌0
<U4A14> <U4A14>;IGNORE;IGNORE;IGNORE	#䨔0
<U4AA8> <U4AA8>;IGNORE;IGNORE;IGNORE	#䪨0
<U5AD1> <U5AD1>;IGNORE;IGNORE;IGNORE	#嫑0
<U74DD> <U74DD>;IGNORE;IGNORE;IGNORE	#瓝0
<U7A87> <U7A87>;IGNORE;IGNORE;IGNORE	#窇0
<U8584> <U8584>;IGNORE;IGNORE;IGNORE	#薄2585
<U96F9> <U96F9>;IGNORE;IGNORE;IGNORE	#雹124
<U3645> <U3645>;IGNORE;IGNORE;IGNORE	#㙅0
<U3C8F> <U3C8F>;IGNORE;IGNORE;IGNORE	#㲏0
<U3EC4> <U3EC4>;IGNORE;IGNORE;IGNORE	#㻄0
<U4382> <U4382>;IGNORE;IGNORE;IGNORE	#䎂0
<U4B4B> <U4B4B>;IGNORE;IGNORE;IGNORE	#䭋0
<U4CC8> <U4CC8>;IGNORE;IGNORE;IGNORE	#䳈0
<U4CF0> <U4CF0>;IGNORE;IGNORE;IGNORE	#䳰0
<U4D10> <U4D10>;IGNORE;IGNORE;IGNORE	#䴐0
<U4FDD> <U4FDD>;IGNORE;IGNORE;IGNORE	#保27354
<U5821> <U5821>;IGNORE;IGNORE;IGNORE	#堡1965
<U5822> <U5822>;IGNORE;IGNORE;IGNORE	#堢0
<U5AAC> <U5AAC>;IGNORE;IGNORE;IGNORE	#媬1
<U5B9D> <U5B9D>;IGNORE;IGNORE;IGNORE	#宝9006
<U5BB2> <U5BB2>;IGNORE;IGNORE;IGNORE	#宲0
<U5BDA> <U5BDA>;IGNORE;IGNORE;IGNORE	#寚0
<U5BF3> <U5BF3>;IGNORE;IGNORE;IGNORE	#寳0
<U5BF6> <U5BF6>;IGNORE;IGNORE;IGNORE	#寶68
<U6009> <U6009>;IGNORE;IGNORE;IGNORE	#怉0
<U73E4> <U73E4>;IGNORE;IGNORE;IGNORE	#珤0
<U7DE5> <U7DE5>;IGNORE;IGNORE;IGNORE	#緥0
<U8446> <U8446>;IGNORE;IGNORE;IGNORE	#葆146
<U8913> <U8913>;IGNORE;IGNORE;IGNORE	#褓48
<U8CF2> <U8CF2>;IGNORE;IGNORE;IGNORE	#賲0
<U974C> <U974C>;IGNORE;IGNORE;IGNORE	#靌0
<U98FD> <U98FD>;IGNORE;IGNORE;IGNORE	#飽21
<U9971> <U9971>;IGNORE;IGNORE;IGNORE	#饱2425
<U99C2> <U99C2>;IGNORE;IGNORE;IGNORE	#駂0
<U9CF5> <U9CF5>;IGNORE;IGNORE;IGNORE	#鳵0
<U9D07> <U9D07>;IGNORE;IGNORE;IGNORE	#鴇1
<U9E28> <U9E28>;IGNORE;IGNORE;IGNORE	#鸨212
<U3678> <U3678>;IGNORE;IGNORE;IGNORE	#㙸0
<U3AE7> <U3AE7>;IGNORE;IGNORE;IGNORE	#㫧0
<U3C92> <U3C92>;IGNORE;IGNORE;IGNORE	#㲒0
<U4916> <U4916>;IGNORE;IGNORE;IGNORE	#䤖0
<U5124> <U5124>;IGNORE;IGNORE;IGNORE	#儤0
<U5228> <U5228>;IGNORE;IGNORE;IGNORE	#刨360
<U52FD> <U52FD>;IGNORE;IGNORE;IGNORE	#勽0
<U5697> <U5697>;IGNORE;IGNORE;IGNORE	#嚗2
<U5831> <U5831>;IGNORE;IGNORE;IGNORE	#報345
<U5FC1> <U5FC1>;IGNORE;IGNORE;IGNORE	#忁0
<U62A5> <U62A5>;IGNORE;IGNORE;IGNORE	#报39746
<U62B1> <U62B1>;IGNORE;IGNORE;IGNORE	#抱11458
<U66B4> <U66B4>;IGNORE;IGNORE;IGNORE	#暴7225
<U66D3> <U66D3>;IGNORE;IGNORE;IGNORE	#曓0
<U7206> <U7206>;IGNORE;IGNORE;IGNORE	#爆5458
<U72A6> <U72A6>;IGNORE;IGNORE;IGNORE	#犦0
<U83E2> <U83E2>;IGNORE;IGNORE;IGNORE	#菢0
<U8663> <U8663>;IGNORE;IGNORE;IGNORE	#虣0
<U86AB> <U86AB>;IGNORE;IGNORE;IGNORE	#蚫0
<U888C> <U888C>;IGNORE;IGNORE;IGNORE	#袌0
<U8C79> <U8C79>;IGNORE;IGNORE;IGNORE	#豹784
<U8DB5> <U8DB5>;IGNORE;IGNORE;IGNORE	#趵4
<U924B> <U924B>;IGNORE;IGNORE;IGNORE	#鉋0
<U9464> <U9464>;IGNORE;IGNORE;IGNORE	#鑤0
<U94C7> <U94C7>;IGNORE;IGNORE;IGNORE	#铇0
<U9AB2> <U9AB2>;IGNORE;IGNORE;IGNORE	#骲2
<U9B91> <U9B91>;IGNORE;IGNORE;IGNORE	#鮑108
<U9C8D> <U9C8D>;IGNORE;IGNORE;IGNORE	#鲍1799
<U4F13> <U4F13>;IGNORE;IGNORE;IGNORE	#伓0
<U4FFE> <U4FFE>;IGNORE;IGNORE;IGNORE	#俾52
<U505D> <U505D>;IGNORE;IGNORE;IGNORE	#偝0
<U5351> <U5351>;IGNORE;IGNORE;IGNORE	#卑2147
<U57E4> <U57E4>;IGNORE;IGNORE;IGNORE	#埤1
<U60B2> <U60B2>;IGNORE;IGNORE;IGNORE	#悲9131
<U63F9> <U63F9>;IGNORE;IGNORE;IGNORE	#揹7
<U676F> <U676F>;IGNORE;IGNORE;IGNORE	#杯9694
<U686E> <U686E>;IGNORE;IGNORE;IGNORE	#桮0
<U6911> <U6911>;IGNORE;IGNORE;IGNORE	#椑0
<U76C3> <U76C3>;IGNORE;IGNORE;IGNORE	#盃2
<U7891> <U7891>;IGNORE;IGNORE;IGNORE	#碑1235
<U7986> <U7986>;IGNORE;IGNORE;IGNORE	#禆3
<U7DBC> <U7DBC>;IGNORE;IGNORE;IGNORE	#綼0
<U8406> <U8406>;IGNORE;IGNORE;IGNORE	#萆0
<U85E3> <U85E3>;IGNORE;IGNORE;IGNORE	#藣0
<U88E8> <U88E8>;IGNORE;IGNORE;IGNORE	#裨53
<U9303> <U9303>;IGNORE;IGNORE;IGNORE	#錃0
<U9642> <U9642>;IGNORE;IGNORE;IGNORE	#陂35
<U9D6F> <U9D6F>;IGNORE;IGNORE;IGNORE	#鵯0
<U9E4E> <U9E4E>;IGNORE;IGNORE;IGNORE	#鹎1
<U3933> <U3933>;IGNORE;IGNORE;IGNORE	#㤳0
<U5317> <U5317>;IGNORE;IGNORE;IGNORE	#北37933
<U9273> <U9273>;IGNORE;IGNORE;IGNORE	#鉳0
<U34C8> <U34C8>;IGNORE;IGNORE;IGNORE	#㓈0
<U3528> <U3528>;IGNORE;IGNORE;IGNORE	#㔨0
<U36DD> <U36DD>;IGNORE;IGNORE;IGNORE	#㛝0
<U38C1> <U38C1>;IGNORE;IGNORE;IGNORE	#㣁0
<U3C06> <U3C06>;IGNORE;IGNORE;IGNORE	#㰆0
<U3D94> <U3D94>;IGNORE;IGNORE;IGNORE	#㶔0
<U3DF6> <U3DF6>;IGNORE;IGNORE;IGNORE	#㷶0
<U3E22> <U3E22>;IGNORE;IGNORE;IGNORE	#㸢0
<U3E2C> <U3E2C>;IGNORE;IGNORE;IGNORE	#㸬0
<U3E3D> <U3E3D>;IGNORE;IGNORE;IGNORE	#㸽0
<U3ED7> <U3ED7>;IGNORE;IGNORE;IGNORE	#㻗0
<U3F0E> <U3F0E>;IGNORE;IGNORE;IGNORE	#㼎0
<U3FB1> <U3FB1>;IGNORE;IGNORE;IGNORE	#㾱0
<U4045> <U4045>;IGNORE;IGNORE;IGNORE	#䁅0
<U42F3> <U42F3>;IGNORE;IGNORE;IGNORE	#䋳0
<U4512> <U4512>;IGNORE;IGNORE;IGNORE	#䔒0
<U4819> <U4819>;IGNORE;IGNORE;IGNORE	#䠙0
<U4876> <U4876>;IGNORE;IGNORE;IGNORE	#䡶0
<U4A40> <U4A40>;IGNORE;IGNORE;IGNORE	#䩀0
<U4C3D> <U4C3D>;IGNORE;IGNORE;IGNORE	#䰽0
<U4FFB> <U4FFB>;IGNORE;IGNORE;IGNORE	#俻0
<U500D> <U500D>;IGNORE;IGNORE;IGNORE	#倍3053
<U5079> <U5079>;IGNORE;IGNORE;IGNORE	#偹0
<U5099> <U5099>;IGNORE;IGNORE;IGNORE	#備137
<U50C3> <U50C3>;IGNORE;IGNORE;IGNORE	#僃0
<U54F1> <U54F1>;IGNORE;IGNORE;IGNORE	#哱0
<U5907> <U5907>;IGNORE;IGNORE;IGNORE	#备22206
<U5970> <U5970>;IGNORE;IGNORE;IGNORE	#奰0
<U5B5B> <U5B5B>;IGNORE;IGNORE;IGNORE	#孛64
<U6096> <U6096>;IGNORE;IGNORE;IGNORE	#悖536
<U60EB> <U60EB>;IGNORE;IGNORE;IGNORE	#惫989
<U6102> <U6102>;IGNORE;IGNORE;IGNORE	#愂0
<U618A> <U618A>;IGNORE;IGNORE;IGNORE	#憊3
<U6601> <U6601>;IGNORE;IGNORE;IGNORE	#昁0
<U676E> <U676E>;IGNORE;IGNORE;IGNORE	#杮0
<U6896> <U6896>;IGNORE;IGNORE;IGNORE	#梖0
<U7119> <U7119>;IGNORE;IGNORE;IGNORE	#焙34
<U726C> <U726C>;IGNORE;IGNORE;IGNORE	#牬0
<U7295> <U7295>;IGNORE;IGNORE;IGNORE	#犕0
<U72C8> <U72C8>;IGNORE;IGNORE;IGNORE	#狈519
<U72FD> <U72FD>;IGNORE;IGNORE;IGNORE	#狽2
<U73FC> <U73FC>;IGNORE;IGNORE;IGNORE	#珼0
<U7432> <U7432>;IGNORE;IGNORE;IGNORE	#琲0
<U789A> <U789A>;IGNORE;IGNORE;IGNORE	#碚7
<U7CD2> <U7CD2>;IGNORE;IGNORE;IGNORE	#糒4
<U7D34> <U7D34>;IGNORE;IGNORE;IGNORE	#紴0
<U80CC> <U80CC>;IGNORE;IGNORE;IGNORE	#背10000
<U84D3> <U84D3>;IGNORE;IGNORE;IGNORE	#蓓259
<U88AB> <U88AB>;IGNORE;IGNORE;IGNORE	#被73464
<U8919> <U8919>;IGNORE;IGNORE;IGNORE	#褙2
<U8A96> <U8A96>;IGNORE;IGNORE;IGNORE	#誖0
<U8C9D> <U8C9D>;IGNORE;IGNORE;IGNORE	#貝36
<U8D1D> <U8D1D>;IGNORE;IGNORE;IGNORE	#贝7456
<U8EF0> <U8EF0>;IGNORE;IGNORE;IGNORE	#軰0
<U8F29> <U8F29>;IGNORE;IGNORE;IGNORE	#輩24
<U8F88> <U8F88>;IGNORE;IGNORE;IGNORE	#辈4746
<U90B6> <U90B6>;IGNORE;IGNORE;IGNORE	#邶0
<U90E5> <U90E5>;IGNORE;IGNORE;IGNORE	#郥0
<U9101> <U9101>;IGNORE;IGNORE;IGNORE	#鄁0
<U92C7> <U92C7>;IGNORE;IGNORE;IGNORE	#鋇0
<U9434> <U9434>;IGNORE;IGNORE;IGNORE	#鐴1
<U943E> <U943E>;IGNORE;IGNORE;IGNORE	#鐾0
<U94A1> <U94A1>;IGNORE;IGNORE;IGNORE	#钡29
<U97B4> <U97B4>;IGNORE;IGNORE;IGNORE	#鞴1
<U97DB> <U97DB>;IGNORE;IGNORE;IGNORE	#韛0
<U5034> <U5034>;IGNORE;IGNORE;IGNORE	#倴0
<U5954> <U5954>;IGNORE;IGNORE;IGNORE	#奔5465
<U681F> <U681F>;IGNORE;IGNORE;IGNORE	#栟0
<U6CCD> <U6CCD>;IGNORE;IGNORE;IGNORE	#泍1
<U6E00> <U6E00>;IGNORE;IGNORE;IGNORE	#渀0
<U7287> <U7287>;IGNORE;IGNORE;IGNORE	#犇0
<U8CC1> <U8CC1>;IGNORE;IGNORE;IGNORE	#賁1
<U8D32> <U8D32>;IGNORE;IGNORE;IGNORE	#贲204
<U9029> <U9029>;IGNORE;IGNORE;IGNORE	#逩0
<U931B> <U931B>;IGNORE;IGNORE;IGNORE	#錛0
<U951B> <U951B>;IGNORE;IGNORE;IGNORE	#锛47
<U3877> <U3877>;IGNORE;IGNORE;IGNORE	#㡷0
<U3BBA> <U3BBA>;IGNORE;IGNORE;IGNORE	#㮺0
<U5932> <U5932>;IGNORE;IGNORE;IGNORE	#夲0
<U5959> <U5959>;IGNORE;IGNORE;IGNORE	#奙0
<U672C> <U672C>;IGNORE;IGNORE;IGNORE	#本99838
<U694D> <U694D>;IGNORE;IGNORE;IGNORE	#楍0
<U755A> <U755A>;IGNORE;IGNORE;IGNORE	#畚19
<U82EF> <U82EF>;IGNORE;IGNORE;IGNORE	#苯111
<U3913> <U3913>;IGNORE;IGNORE;IGNORE	#㤓0
<U3A27> <U3A27>;IGNORE;IGNORE;IGNORE	#㨧0
<U3C75> <U3C75>;IGNORE;IGNORE;IGNORE	#㱵0
<U4B31> <U4B31>;IGNORE;IGNORE;IGNORE	#䬱0
<U574C> <U574C>;IGNORE;IGNORE;IGNORE	#坌16
<U6379> <U6379>;IGNORE;IGNORE;IGNORE	#捹0
<U64AA> <U64AA>;IGNORE;IGNORE;IGNORE	#撪1
<U6873> <U6873>;IGNORE;IGNORE;IGNORE	#桳0
<U71CC> <U71CC>;IGNORE;IGNORE;IGNORE	#燌0
<U7356> <U7356>;IGNORE;IGNORE;IGNORE	#獖0
<U7B28> <U7B28>;IGNORE;IGNORE;IGNORE	#笨3650
<U8F3D> <U8F3D>;IGNORE;IGNORE;IGNORE	#輽0
<U4F3B> <U4F3B>;IGNORE;IGNORE;IGNORE	#伻0
<U5623> <U5623>;IGNORE;IGNORE;IGNORE	#嘣112
<U5874> <U5874>;IGNORE;IGNORE;IGNORE	#塴0
<U595F> <U595F>;IGNORE;IGNORE;IGNORE	#奟0
<U5D29> <U5D29>;IGNORE;IGNORE;IGNORE	#崩1485
<U5D6D> <U5D6D>;IGNORE;IGNORE;IGNORE	#嵭0
<U5F38> <U5F38>;IGNORE;IGNORE;IGNORE	#弸0
<U794A> <U794A>;IGNORE;IGNORE;IGNORE	#祊0
<U7D63> <U7D63>;IGNORE;IGNORE;IGNORE	#絣3
<U7DB3> <U7DB3>;IGNORE;IGNORE;IGNORE	#綳0
<U7E43> <U7E43>;IGNORE;IGNORE;IGNORE	#繃4
<U7EF7> <U7EF7>;IGNORE;IGNORE;IGNORE	#绷834
<U958D> <U958D>;IGNORE;IGNORE;IGNORE	#閍0
<U752D> <U752D>;IGNORE;IGNORE;IGNORE	#甭447
<U345F> <U345F>;IGNORE;IGNORE;IGNORE	#㑟0
<U42FD> <U42FD>;IGNORE;IGNORE;IGNORE	#䋽0
<U4640> <U4640>;IGNORE;IGNORE;IGNORE	#䙀0
<U4A6C> <U4A6C>;IGNORE;IGNORE;IGNORE	#䩬0
<U4B70> <U4B70>;IGNORE;IGNORE;IGNORE	#䭰0
<U4CDE> <U4CDE>;IGNORE;IGNORE;IGNORE	#䳞0
<U57F2> <U57F2>;IGNORE;IGNORE;IGNORE	#埲0
<U73A4> <U73A4>;IGNORE;IGNORE;IGNORE	#玤0
<U742B> <U742B>;IGNORE;IGNORE;IGNORE	#琫0
<U83F6> <U83F6>;IGNORE;IGNORE;IGNORE	#菶0
<U8A81> <U8A81>;IGNORE;IGNORE;IGNORE	#誁0
<U979B> <U979B>;IGNORE;IGNORE;IGNORE	#鞛0
<U3C76> <U3C76>;IGNORE;IGNORE;IGNORE	#㱶0
<U3DEF> <U3DEF>;IGNORE;IGNORE;IGNORE	#㷯0
<U4A3B> <U4A3B>;IGNORE;IGNORE;IGNORE	#䨻0
<U580B> <U580B>;IGNORE;IGNORE;IGNORE	#堋6
<U69F0> <U69F0>;IGNORE;IGNORE;IGNORE	#槰0
<U6CF5> <U6CF5>;IGNORE;IGNORE;IGNORE	#泵86
<U6D34> <U6D34>;IGNORE;IGNORE;IGNORE	#洴0
<U71A2> <U71A2>;IGNORE;IGNORE;IGNORE	#熢0
<U750F> <U750F>;IGNORE;IGNORE;IGNORE	#甏2
<U8DF0> <U8DF0>;IGNORE;IGNORE;IGNORE	#跰0
<U8E66> <U8E66>;IGNORE;IGNORE;IGNORE	#蹦1092
<U8FF8> <U8FF8>;IGNORE;IGNORE;IGNORE	#迸402
<U902C> <U902C>;IGNORE;IGNORE;IGNORE	#逬0
<U93F0> <U93F0>;IGNORE;IGNORE;IGNORE	#鏰0
<U955A> <U955A>;IGNORE;IGNORE;IGNORE	#镚1
<U506A> <U506A>;IGNORE;IGNORE;IGNORE	#偪0
<U5C44> <U5C44>;IGNORE;IGNORE;IGNORE	#屄12
<U6082> <U6082>;IGNORE;IGNORE;IGNORE	#悂0
<U6BF4> <U6BF4>;IGNORE;IGNORE;IGNORE	#毴0
<U7680> <U7680>;IGNORE;IGNORE;IGNORE	#皀0
<U7A2B> <U7A2B>;IGNORE;IGNORE;IGNORE	#稫0
<U8795> <U8795>;IGNORE;IGNORE;IGNORE	#螕0
<U8C4D> <U8C4D>;IGNORE;IGNORE;IGNORE	#豍0
<U903C> <U903C>;IGNORE;IGNORE;IGNORE	#逼3698
<U9CBE> <U9CBE>;IGNORE;IGNORE;IGNORE	#鲾0
<U3BB0> <U3BB0>;IGNORE;IGNORE;IGNORE	#㮰0
<U4A06> <U4A06>;IGNORE;IGNORE;IGNORE	#䨆0
<U4D44> <U4D44>;IGNORE;IGNORE;IGNORE	#䵄0
<U8378> <U8378>;IGNORE;IGNORE;IGNORE	#荸47
<U9F3B> <U9F3B>;IGNORE;IGNORE;IGNORE	#鼻5503
<U36B0> <U36B0>;IGNORE;IGNORE;IGNORE	#㚰0
<U3832> <U3832>;IGNORE;IGNORE;IGNORE	#㠲0
<U3A8F> <U3A8F>;IGNORE;IGNORE;IGNORE	#㪏0
<U3EF6> <U3EF6>;IGNORE;IGNORE;IGNORE	#㻶0
<U40FE> <U40FE>;IGNORE;IGNORE;IGNORE	#䃾0
<U41F7> <U41F7>;IGNORE;IGNORE;IGNORE	#䇷0
<U43E2> <U43E2>;IGNORE;IGNORE;IGNORE	#䏢0
<U4621> <U4621>;IGNORE;IGNORE;IGNORE	#䘡0
<U480B> <U480B>;IGNORE;IGNORE;IGNORE	#䠋0
<U48E5> <U48E5>;IGNORE;IGNORE;IGNORE	#䣥0
<U4F4A> <U4F4A>;IGNORE;IGNORE;IGNORE	#佊0
<U5315> <U5315>;IGNORE;IGNORE;IGNORE	#匕274
<U5421> <U5421>;IGNORE;IGNORE;IGNORE	#吡18
<U555A> <U555A>;IGNORE;IGNORE;IGNORE	#啚0
<U5936> <U5936>;IGNORE;IGNORE;IGNORE	#夶0
<U59A3> <U59A3>;IGNORE;IGNORE;IGNORE	#妣34
<U5F7C> <U5F7C>;IGNORE;IGNORE;IGNORE	#彼6578
<U673C> <U673C>;IGNORE;IGNORE;IGNORE	#朼0
<U67C0> <U67C0>;IGNORE;IGNORE;IGNORE	#柀0
<U6BD4> <U6BD4>;IGNORE;IGNORE;IGNORE	#比53691
<U6C98> <U6C98>;IGNORE;IGNORE;IGNORE	#沘0
<U7595> <U7595>;IGNORE;IGNORE;IGNORE	#疕0
<U79D5> <U79D5>;IGNORE;IGNORE;IGNORE	#秕14
<U7B14> <U7B14>;IGNORE;IGNORE;IGNORE	#笔11150
<U7B46> <U7B46>;IGNORE;IGNORE;IGNORE	#筆128
<U7C83> <U7C83>;IGNORE;IGNORE;IGNORE	#粃0
<U7EB0> <U7EB0>;IGNORE;IGNORE;IGNORE	#纰26
<U822D> <U822D>;IGNORE;IGNORE;IGNORE	#舭0
<U8C8F> <U8C8F>;IGNORE;IGNORE;IGNORE	#貏0
<U9119> <U9119>;IGNORE;IGNORE;IGNORE	#鄙1135
<U9B6E> <U9B6E>;IGNORE;IGNORE;IGNORE	#魮0
<U34D6> <U34D6>;IGNORE;IGNORE;IGNORE	#㓖0
<U35C9> <U35C9>;IGNORE;IGNORE;IGNORE	#㗉0
<U3620> <U3620>;IGNORE;IGNORE;IGNORE	#㘠0
<U3629> <U3629>;IGNORE;IGNORE;IGNORE	#㘩0
<U3644> <U3644>;IGNORE;IGNORE;IGNORE	#㙄0
<U3840> <U3840>;IGNORE;IGNORE;IGNORE	#㡀0
<U3859> <U3859>;IGNORE;IGNORE;IGNORE	#㡙0
<U38B0> <U38B0>;IGNORE;IGNORE;IGNORE	#㢰0
<U38B6> <U38B6>;IGNORE;IGNORE;IGNORE	#㢶0
<U38B8> <U38B8>;IGNORE;IGNORE;IGNORE	#㢸0
<U39D9> <U39D9>;IGNORE;IGNORE;IGNORE	#㧙0
<U3AA4> <U3AA4>;IGNORE;IGNORE;IGNORE	#㪤0
<U3BBF> <U3BBF>;IGNORE;IGNORE;IGNORE	#㮿0
<U3BC7> <U3BC7>;IGNORE;IGNORE;IGNORE	#㯇0
<U3C78> <U3C78>;IGNORE;IGNORE;IGNORE	#㱸0
<U3CFC> <U3CFC>;IGNORE;IGNORE;IGNORE	#㳼0
<U3D65> <U3D65>;IGNORE;IGNORE;IGNORE	#㵥0
<U3D68> <U3D68>;IGNORE;IGNORE;IGNORE	#㵨0
<U3E43> <U3E43>;IGNORE;IGNORE;IGNORE	#㹃0
<U3EEB> <U3EEB>;IGNORE;IGNORE;IGNORE	#㻫0
<U3FEB> <U3FEB>;IGNORE;IGNORE;IGNORE	#㿫0
<U4023> <U4023>;IGNORE;IGNORE;IGNORE	#䀣0
<U4079> <U4079>;IGNORE;IGNORE;IGNORE	#䁹0
<U4136> <U4136>;IGNORE;IGNORE;IGNORE	#䄶0
<U42A7> <U42A7>;IGNORE;IGNORE;IGNORE	#䊧0
<U42D4> <U42D4>;IGNORE;IGNORE;IGNORE	#䋔0
<U431F> <U431F>;IGNORE;IGNORE;IGNORE	#䌟0
<U43B5> <U43B5>;IGNORE;IGNORE;IGNORE	#䎵0
<U43F6> <U43F6>;IGNORE;IGNORE;IGNORE	#䏶0
<U4557> <U4557>;IGNORE;IGNORE;IGNORE	#䕗0
<U45A9> <U45A9>;IGNORE;IGNORE;IGNORE	#䖩0
<U47C6> <U47C6>;IGNORE;IGNORE;IGNORE	#䟆0
<U47E4> <U47E4>;IGNORE;IGNORE;IGNORE	#䟤0
<U4998> <U4998>;IGNORE;IGNORE;IGNORE	#䦘0
<U49D7> <U49D7>;IGNORE;IGNORE;IGNORE	#䧗0
<U4A5B> <U4A5B>;IGNORE;IGNORE;IGNORE	#䩛0
<U4A90> <U4A90>;IGNORE;IGNORE;IGNORE	#䪐0
<U4AC1> <U4AC1>;IGNORE;IGNORE;IGNORE	#䫁0
<U4AFE> <U4AFE>;IGNORE;IGNORE;IGNORE	#䫾0
<U4B1B> <U4B1B>;IGNORE;IGNORE;IGNORE	#䬛0
<U4B6E> <U4B6E>;IGNORE;IGNORE;IGNORE	#䭮0
<U4BA1> <U4BA1>;IGNORE;IGNORE;IGNORE	#䮡0
<U4BD7> <U4BD7>;IGNORE;IGNORE;IGNORE	#䯗0
<U4F56> <U4F56>;IGNORE;IGNORE;IGNORE	#佖0
<U54D4> <U54D4>;IGNORE;IGNORE;IGNORE	#哔73
<U55F6> <U55F6>;IGNORE;IGNORE;IGNORE	#嗶4
<U5752> <U5752>;IGNORE;IGNORE;IGNORE	#坒0
<U581B> <U581B>;IGNORE;IGNORE;IGNORE	#堛0
<U58C1> <U58C1>;IGNORE;IGNORE;IGNORE	#壁4859
<U59BC> <U59BC>;IGNORE;IGNORE;IGNORE	#妼0
<U5A62> <U5A62>;IGNORE;IGNORE;IGNORE	#婢310
<U5AF3> <U5AF3>;IGNORE;IGNORE;IGNORE	#嫳0
<U5B16> <U5B16>;IGNORE;IGNORE;IGNORE	#嬖4
<U5E01> <U5E01>;IGNORE;IGNORE;IGNORE	#币2432
<U5E63> <U5E63>;IGNORE;IGNORE;IGNORE	#幣11
<U5E64> <U5E64>;IGNORE;IGNORE;IGNORE	#幤0
<U5E87> <U5E87>;IGNORE;IGNORE;IGNORE	#庇713
<U5EB3> <U5EB3>;IGNORE;IGNORE;IGNORE	#庳2
<U5EE6> <U5EE6>;IGNORE;IGNORE;IGNORE	#廦0
<U5F0A> <U5F0A>;IGNORE;IGNORE;IGNORE	#弊820
<U5F3B> <U5F3B>;IGNORE;IGNORE;IGNORE	#弻12
<U5F3C> <U5F3C>;IGNORE;IGNORE;IGNORE	#弼150
<U5F43> <U5F43>;IGNORE;IGNORE;IGNORE	#彃0
<U5FC5> <U5FC5>;IGNORE;IGNORE;IGNORE	#必33027
<U602D> <U602D>;IGNORE;IGNORE;IGNORE	#怭0
<U610A> <U610A>;IGNORE;IGNORE;IGNORE	#愊1
<U610E> <U610E>;IGNORE;IGNORE;IGNORE	#愎57
<U6255> <U6255>;IGNORE;IGNORE;IGNORE	#払0
<U655D> <U655D>;IGNORE;IGNORE;IGNORE	#敝217
<U6583> <U6583>;IGNORE;IGNORE;IGNORE	#斃1
<U6707> <U6707>;IGNORE;IGNORE;IGNORE	#朇0
<U6788> <U6788>;IGNORE;IGNORE;IGNORE	#枈0
<U67EB> <U67EB>;IGNORE;IGNORE;IGNORE	#柫0
<U67F2> <U67F2>;IGNORE;IGNORE;IGNORE	#柲0
<U6890> <U6890>;IGNORE;IGNORE;IGNORE	#梐0
<U6945> <U6945>;IGNORE;IGNORE;IGNORE	#楅0
<U6A98> <U6A98>;IGNORE;IGNORE;IGNORE	#檘0
<U6BD5> <U6BD5>;IGNORE;IGNORE;IGNORE	#毕9709
<U6BD6> <U6BD6>;IGNORE;IGNORE;IGNORE	#毖14
<U6BD9> <U6BD9>;IGNORE;IGNORE;IGNORE	#毙801
<U6CCC> <U6CCC>;IGNORE;IGNORE;IGNORE	#泌236
<U6E62> <U6E62>;IGNORE;IGNORE;IGNORE	#湢0
<U6ED7> <U6ED7>;IGNORE;IGNORE;IGNORE	#滗0
<U6EED> <U6EED>;IGNORE;IGNORE;IGNORE	#滭0
<U6F77> <U6F77>;IGNORE;IGNORE;IGNORE	#潷0
<U6FDE> <U6FDE>;IGNORE;IGNORE;IGNORE	#濞1
<U714F> <U714F>;IGNORE;IGNORE;IGNORE	#煏0
<U719A> <U719A>;IGNORE;IGNORE;IGNORE	#熚0
<U72F4> <U72F4>;IGNORE;IGNORE;IGNORE	#狴3
<U7358> <U7358>;IGNORE;IGNORE;IGNORE	#獘0
<U7359> <U7359>;IGNORE;IGNORE;IGNORE	#獙0
<U73CC> <U73CC>;IGNORE;IGNORE;IGNORE	#珌0
<U74A7> <U74A7>;IGNORE;IGNORE;IGNORE	#璧443
<U7540> <U7540>;IGNORE;IGNORE;IGNORE	#畀4
<U7541> <U7541>;IGNORE;IGNORE;IGNORE	#畁0
<U7550> <U7550>;IGNORE;IGNORE;IGNORE	#畐0
<U7562> <U7562>;IGNORE;IGNORE;IGNORE	#畢112
<U75AA> <U75AA>;IGNORE;IGNORE;IGNORE	#疪0
<U75F9> <U75F9>;IGNORE;IGNORE;IGNORE	#痹197
<U75FA> <U75FA>;IGNORE;IGNORE;IGNORE	#痺3
<U7695> <U7695>;IGNORE;IGNORE;IGNORE	#皕0
<U78A7> <U78A7>;IGNORE;IGNORE;IGNORE	#碧1511
<U7B5A> <U7B5A>;IGNORE;IGNORE;IGNORE	#筚5
<U7B84> <U7B84>;IGNORE;IGNORE;IGNORE	#箄0
<U7B85> <U7B85>;IGNORE;IGNORE;IGNORE	#箅2
<U7B86> <U7B86>;IGNORE;IGNORE;IGNORE	#箆0
<U7BE6> <U7BE6>;IGNORE;IGNORE;IGNORE	#篦55
<U7BF3> <U7BF3>;IGNORE;IGNORE;IGNORE	#篳0
<U7C8A> <U7C8A>;IGNORE;IGNORE;IGNORE	#粊0
<U7E2A> <U7E2A>;IGNORE;IGNORE;IGNORE	#縪0
<U7F7C> <U7F7C>;IGNORE;IGNORE;IGNORE	#罼0
<U805B> <U805B>;IGNORE;IGNORE;IGNORE	#聛1
<U8177> <U8177>;IGNORE;IGNORE;IGNORE	#腷0
<U81C2> <U81C2>;IGNORE;IGNORE;IGNORE	#臂3638
<U8298> <U8298>;IGNORE;IGNORE;IGNORE	#芘0
<U82FE> <U82FE>;IGNORE;IGNORE;IGNORE	#苾2
<U835C> <U835C>;IGNORE;IGNORE;IGNORE	#荜5
<U84D6> <U84D6>;IGNORE;IGNORE;IGNORE	#蓖22
<U84FD> <U84FD>;IGNORE;IGNORE;IGNORE	#蓽0
<U853D> <U853D>;IGNORE;IGNORE;IGNORE	#蔽1108
<U859C> <U859C>;IGNORE;IGNORE;IGNORE	#薜5
<U870C> <U870C>;IGNORE;IGNORE;IGNORE	#蜌0
<U8890> <U8890>;IGNORE;IGNORE;IGNORE	#袐0
<U8952> <U8952>;IGNORE;IGNORE;IGNORE	#襒0
<U895E> <U895E>;IGNORE;IGNORE;IGNORE	#襞12
<U8963> <U8963>;IGNORE;IGNORE;IGNORE	#襣0
<U89F1> <U89F1>;IGNORE;IGNORE;IGNORE	#觱0
<U8A56> <U8A56>;IGNORE;IGNORE;IGNORE	#詖0
<U8BD0> <U8BD0>;IGNORE;IGNORE;IGNORE	#诐0
<U8CB1> <U8CB1>;IGNORE;IGNORE;IGNORE	#貱0
<U8D14> <U8D14>;IGNORE;IGNORE;IGNORE	#贔1
<U8D51> <U8D51>;IGNORE;IGNORE;IGNORE	#赑0
<U8DF8> <U8DF8>;IGNORE;IGNORE;IGNORE	#跸32
<U8E55> <U8E55>;IGNORE;IGNORE;IGNORE	#蹕0
<U8E83> <U8E83>;IGNORE;IGNORE;IGNORE	#躃0
<U8E84> <U8E84>;IGNORE;IGNORE;IGNORE	#躄1
<U8F9F> <U8F9F>;IGNORE;IGNORE;IGNORE	#辟924
<U907F> <U907F>;IGNORE;IGNORE;IGNORE	#避7213
<U90B2> <U90B2>;IGNORE;IGNORE;IGNORE	#邲0
<U9128> <U9128>;IGNORE;IGNORE;IGNORE	#鄨0
<U912A> <U912A>;IGNORE;IGNORE;IGNORE	#鄪0
<U924D> <U924D>;IGNORE;IGNORE;IGNORE	#鉍0
<U939E> <U939E>;IGNORE;IGNORE;IGNORE	#鎞0
<U93CE> <U93CE>;IGNORE;IGNORE;IGNORE	#鏎0
<U94CB> <U94CB>;IGNORE;IGNORE;IGNORE	#铋8
<U9587> <U9587>;IGNORE;IGNORE;IGNORE	#閇0
<U9589> <U9589>;IGNORE;IGNORE;IGNORE	#閉68
<U959F> <U959F>;IGNORE;IGNORE;IGNORE	#閟1
<U95E2> <U95E2>;IGNORE;IGNORE;IGNORE	#闢4
<U95ED> <U95ED>;IGNORE;IGNORE;IGNORE	#闭7133
<U965B> <U965B>;IGNORE;IGNORE;IGNORE	#陛345
<U97B8> <U97B8>;IGNORE;IGNORE;IGNORE	#鞸0
<U97E0> <U97E0>;IGNORE;IGNORE;IGNORE	#韠0
<U98F6> <U98F6>;IGNORE;IGNORE;IGNORE	#飶0
<U9946> <U9946>;IGNORE;IGNORE;IGNORE	#饆1
<U999D> <U999D>;IGNORE;IGNORE;IGNORE	#馝0
<U99DC> <U99DC>;IGNORE;IGNORE;IGNORE	#駜0
<U9A46> <U9A46>;IGNORE;IGNORE;IGNORE	#驆0
<U9AB3> <U9AB3>;IGNORE;IGNORE;IGNORE	#骳0
<U9AC0> <U9AC0>;IGNORE;IGNORE;IGNORE	#髀13
<U9B53> <U9B53>;IGNORE;IGNORE;IGNORE	#魓0
<U9B85> <U9B85>;IGNORE;IGNORE;IGNORE	#鮅0
<U9C0F> <U9C0F>;IGNORE;IGNORE;IGNORE	#鰏0
<U9D56> <U9D56>;IGNORE;IGNORE;IGNORE	#鵖0
<U9DDD> <U9DDD>;IGNORE;IGNORE;IGNORE	#鷝0
<U9DE9> <U9DE9>;IGNORE;IGNORE;IGNORE	#鷩0
<U9F0A> <U9F0A>;IGNORE;IGNORE;IGNORE	#鼊0
<U67C9> <U67C9>;IGNORE;IGNORE;IGNORE	#柉0
<U6944> <U6944>;IGNORE;IGNORE;IGNORE	#楄0
<U7178> <U7178>;IGNORE;IGNORE;IGNORE	#煸6
<U7251> <U7251>;IGNORE;IGNORE;IGNORE	#牑0
<U7335> <U7335>;IGNORE;IGNORE;IGNORE	#猵0
<U7371> <U7371>;IGNORE;IGNORE;IGNORE	#獱0
<U7502> <U7502>;IGNORE;IGNORE;IGNORE	#甂0
<U782D> <U782D>;IGNORE;IGNORE;IGNORE	#砭38
<U7A28> <U7A28>;IGNORE;IGNORE;IGNORE	#稨0
<U7B3E> <U7B3E>;IGNORE;IGNORE;IGNORE	#笾4
<U7BAF> <U7BAF>;IGNORE;IGNORE;IGNORE	#箯0
<U7C69> <U7C69>;IGNORE;IGNORE;IGNORE	#籩0
<U7CC4> <U7CC4>;IGNORE;IGNORE;IGNORE	#糄0
<U7DE8> <U7DE8>;IGNORE;IGNORE;IGNORE	#編35
<U7F16> <U7F16>;IGNORE;IGNORE;IGNORE	#编17914
<U8759> <U8759>;IGNORE;IGNORE;IGNORE	#蝙188
<U8FB9> <U8FB9>;IGNORE;IGNORE;IGNORE	#边60559
<U8FBA> <U8FBA>;IGNORE;IGNORE;IGNORE	#辺0
<U9089> <U9089>;IGNORE;IGNORE;IGNORE	#邉1
<U908A> <U908A>;IGNORE;IGNORE;IGNORE	#邊610
<U937D> <U937D>;IGNORE;IGNORE;IGNORE	#鍽0
<U97AD> <U97AD>;IGNORE;IGNORE;IGNORE	#鞭1393
<U9BFE> <U9BFE>;IGNORE;IGNORE;IGNORE	#鯾0
<U9BFF> <U9BFF>;IGNORE;IGNORE;IGNORE	#鯿0
<U9CCA> <U9CCA>;IGNORE;IGNORE;IGNORE	#鳊16
<U399A> <U399A>;IGNORE;IGNORE;IGNORE	#㦚0
<U4075> <U4075>;IGNORE;IGNORE;IGNORE	#䁵0
<U533E> <U533E>;IGNORE;IGNORE;IGNORE	#匾240
<U60FC> <U60FC>;IGNORE;IGNORE;IGNORE	#惼0
<U6241> <U6241>;IGNORE;IGNORE;IGNORE	#扁1527
<U78A5> <U78A5>;IGNORE;IGNORE;IGNORE	#碥4
<U7A86> <U7A86>;IGNORE;IGNORE;IGNORE	#窆4
<U8439> <U8439>;IGNORE;IGNORE;IGNORE	#萹0
<U85CA> <U85CA>;IGNORE;IGNORE;IGNORE	#藊0
<U890A> <U890A>;IGNORE;IGNORE;IGNORE	#褊7
<U8CB6> <U8CB6>;IGNORE;IGNORE;IGNORE	#貶4
<U8D2C> <U8D2C>;IGNORE;IGNORE;IGNORE	#贬609
<U3778> <U3778>;IGNORE;IGNORE;IGNORE	#㝸0
<U38D0> <U38D0>;IGNORE;IGNORE;IGNORE	#㣐0
<U3B53> <U3B53>;IGNORE;IGNORE;IGNORE	#㭓0
<U3CA2> <U3CA2>;IGNORE;IGNORE;IGNORE	#㲢0
<U3CCE> <U3CCE>;IGNORE;IGNORE;IGNORE	#㳎0
<U3CD2> <U3CD2>;IGNORE;IGNORE;IGNORE	#㳒0
<U3D1C> <U3D1C>;IGNORE;IGNORE;IGNORE	#㴜0
<U3D77> <U3D77>;IGNORE;IGNORE;IGNORE	#㵷0
<U3EB9> <U3EB9>;IGNORE;IGNORE;IGNORE	#㺹0
<U3EDE> <U3EDE>;IGNORE;IGNORE;IGNORE	#㻞0
<U4278> <U4278>;IGNORE;IGNORE;IGNORE	#䉸0
<U44AA> <U44AA>;IGNORE;IGNORE;IGNORE	#䒪0
<U46D2> <U46D2>;IGNORE;IGNORE;IGNORE	#䛒0
<U4862> <U4862>;IGNORE;IGNORE;IGNORE	#䡢0
<U4ABB> <U4ABB>;IGNORE;IGNORE;IGNORE	#䪻0
<U4FBF> <U4FBF>;IGNORE;IGNORE;IGNORE	#便40000
<U535E> <U535E>;IGNORE;IGNORE;IGNORE	#卞59
<U53D8> <U53D8>;IGNORE;IGNORE;IGNORE	#变43188
<U5909> <U5909>;IGNORE;IGNORE;IGNORE	#変0
<U5F01> <U5F01>;IGNORE;IGNORE;IGNORE	#弁68
<U5FA7> <U5FA7>;IGNORE;IGNORE;IGNORE	#徧0
<U5FED> <U5FED>;IGNORE;IGNORE;IGNORE	#忭1
<U6283> <U6283>;IGNORE;IGNORE;IGNORE	#抃2
<U63D9> <U63D9>;IGNORE;IGNORE;IGNORE	#揙0
<U662A> <U662A>;IGNORE;IGNORE;IGNORE	#昪0
<U6C73> <U6C73>;IGNORE;IGNORE;IGNORE	#汳0
<U6C74> <U6C74>;IGNORE;IGNORE;IGNORE	#汴365
<U709E> <U709E>;IGNORE;IGNORE;IGNORE	#炞0
<U73A3> <U73A3>;IGNORE;IGNORE;IGNORE	#玣0
<U7DF6> <U7DF6>;IGNORE;IGNORE;IGNORE	#緶0
<U7F0F> <U7F0F>;IGNORE;IGNORE;IGNORE	#缏0
<U8251> <U8251>;IGNORE;IGNORE;IGNORE	#艑0
<U82C4> <U82C4>;IGNORE;IGNORE;IGNORE	#苄1
<U898D> <U898D>;IGNORE;IGNORE;IGNORE	#覍0
<U8B8A> <U8B8A>;IGNORE;IGNORE;IGNORE	#變375
<U8FA1> <U8FA1>;IGNORE;IGNORE;IGNORE	#辡0
<U8FA7> <U8FA7>;IGNORE;IGNORE;IGNORE	#辧0
<U8FA8> <U8FA8>;IGNORE;IGNORE;IGNORE	#辨2021
<U8FA9> <U8FA9>;IGNORE;IGNORE;IGNORE	#辩4154
<U8FAB> <U8FAB>;IGNORE;IGNORE;IGNORE	#辫998
<U8FAE> <U8FAE>;IGNORE;IGNORE;IGNORE	#辮0
<U8FAF> <U8FAF>;IGNORE;IGNORE;IGNORE	#辯13
<U904D> <U904D>;IGNORE;IGNORE;IGNORE	#遍7908
<U91C6> <U91C6>;IGNORE;IGNORE;IGNORE	#釆6
<U959E> <U959E>;IGNORE;IGNORE;IGNORE	#閞2
<U9D18> <U9D18>;IGNORE;IGNORE;IGNORE	#鴘0
<U50C4> <U50C4>;IGNORE;IGNORE;IGNORE	#僄0
<U5126> <U5126>;IGNORE;IGNORE;IGNORE	#儦0
<U5882> <U5882>;IGNORE;IGNORE;IGNORE	#墂0
<U5E56> <U5E56>;IGNORE;IGNORE;IGNORE	#幖1
<U5F6A> <U5F6A>;IGNORE;IGNORE;IGNORE	#彪1594
<U5FB1> <U5FB1>;IGNORE;IGNORE;IGNORE	#徱0
<U647D> <U647D>;IGNORE;IGNORE;IGNORE	#摽1
<U6753> <U6753>;IGNORE;IGNORE;IGNORE	#杓29
<U6807> <U6807>;IGNORE;IGNORE;IGNORE	#标56806
<U6A19> <U6A19>;IGNORE;IGNORE;IGNORE	#標199
<U6EEE> <U6EEE>;IGNORE;IGNORE;IGNORE	#滮0
<U700C> <U700C>;IGNORE;IGNORE;IGNORE	#瀌0
<U706C> <U706C>;IGNORE;IGNORE;IGNORE	#灬1
<U719B> <U719B>;IGNORE;IGNORE;IGNORE	#熛0
<U7202> <U7202>;IGNORE;IGNORE;IGNORE	#爂0
<U730B> <U730B>;IGNORE;IGNORE;IGNORE	#猋0
<U762D> <U762D>;IGNORE;IGNORE;IGNORE	#瘭1
<U78E6> <U78E6>;IGNORE;IGNORE;IGNORE	#磦1
<U7A6E> <U7A6E>;IGNORE;IGNORE;IGNORE	#穮0
<U7F86> <U7F86>;IGNORE;IGNORE;IGNORE	#羆0
<U813F> <U813F>;IGNORE;IGNORE;IGNORE	#脿0
<U8198> <U8198>;IGNORE;IGNORE;IGNORE	#膘87
<U81D5> <U81D5>;IGNORE;IGNORE;IGNORE	#臕0
<U8508> <U8508>;IGNORE;IGNORE;IGNORE	#蔈0
<U85E8> <U85E8>;IGNORE;IGNORE;IGNORE	#藨0
<U8B24> <U8B24>;IGNORE;IGNORE;IGNORE	#謤0
<U8D06> <U8D06>;IGNORE;IGNORE;IGNORE	#贆0
<U93E2> <U93E2>;IGNORE;IGNORE;IGNORE	#鏢1
<U9463> <U9463>;IGNORE;IGNORE;IGNORE	#鑣1
<U9556> <U9556>;IGNORE;IGNORE;IGNORE	#镖379
<U9573> <U9573>;IGNORE;IGNORE;IGNORE	#镳78
<U98A9> <U98A9>;IGNORE;IGNORE;IGNORE	#颩0
<U98AE> <U98AE>;IGNORE;IGNORE;IGNORE	#颮0
<U98B7> <U98B7>;IGNORE;IGNORE;IGNORE	#颷0
<U98C6> <U98C6>;IGNORE;IGNORE;IGNORE	#飆4
<U98C7> <U98C7>;IGNORE;IGNORE;IGNORE	#飇0
<U98C8> <U98C8>;IGNORE;IGNORE;IGNORE	#飈0
<U98CD> <U98CD>;IGNORE;IGNORE;IGNORE	#飍0
<U98D1> <U98D1>;IGNORE;IGNORE;IGNORE	#飑2
<U98D9> <U98D9>;IGNORE;IGNORE;IGNORE	#飙107
<U98DA> <U98DA>;IGNORE;IGNORE;IGNORE	#飚25
<U9A43> <U9A43>;IGNORE;IGNORE;IGNORE	#驃0
<U9A6B> <U9A6B>;IGNORE;IGNORE;IGNORE	#驫0
<U9A89> <U9A89>;IGNORE;IGNORE;IGNORE	#骉0
<U9AA0> <U9AA0>;IGNORE;IGNORE;IGNORE	#骠27
<U9ADF> <U9ADF>;IGNORE;IGNORE;IGNORE	#髟73
<U9E83> <U9E83>;IGNORE;IGNORE;IGNORE	#麃8
<U37FD> <U37FD>;IGNORE;IGNORE;IGNORE	#㟽0
<U3812> <U3812>;IGNORE;IGNORE;IGNORE	#㠒0
<U3BF1> <U3BF1>;IGNORE;IGNORE;IGNORE	#㯱0
<U3BF9> <U3BF9>;IGNORE;IGNORE;IGNORE	#㯹0
<U4538> <U4538>;IGNORE;IGNORE;IGNORE	#䔸0
<U5A4A> <U5A4A>;IGNORE;IGNORE;IGNORE	#婊365
<U6AA6> <U6AA6>;IGNORE;IGNORE;IGNORE	#檦0
<U8868> <U8868>;IGNORE;IGNORE;IGNORE	#表58549
<U88F1> <U88F1>;IGNORE;IGNORE;IGNORE	#裱97
<U893E> <U893E>;IGNORE;IGNORE;IGNORE	#褾0
<U8AD8> <U8AD8>;IGNORE;IGNORE;IGNORE	#諘0
<U9336> <U9336>;IGNORE;IGNORE;IGNORE	#錶15
<U39FC> <U39FC>;IGNORE;IGNORE;IGNORE	#㧼0
<U4784> <U4784>;IGNORE;IGNORE;IGNORE	#䞄0
<U4FF5> <U4FF5>;IGNORE;IGNORE;IGNORE	#俵1
<U9C3E> <U9C3E>;IGNORE;IGNORE;IGNORE	#鰾0
<U9CD4> <U9CD4>;IGNORE;IGNORE;IGNORE	#鳔11
<U618B> <U618B>;IGNORE;IGNORE;IGNORE	#憋821
<U762A> <U762A>;IGNORE;IGNORE;IGNORE	#瘪351
<U765F> <U765F>;IGNORE;IGNORE;IGNORE	#癟7
<U864C> <U864C>;IGNORE;IGNORE;IGNORE	#虌0
<U9C49> <U9C49>;IGNORE;IGNORE;IGNORE	#鱉0
<U9CD6> <U9CD6>;IGNORE;IGNORE;IGNORE	#鳖156
<U9F08> <U9F08>;IGNORE;IGNORE;IGNORE	#鼈0
<U9F9E> <U9F9E>;IGNORE;IGNORE;IGNORE	#龞0
<U4825> <U4825>;IGNORE;IGNORE;IGNORE	#䠥0
<U4B71> <U4B71>;IGNORE;IGNORE;IGNORE	#䭱0
<U5225> <U5225>;IGNORE;IGNORE;IGNORE	#別402
<U522B> <U522B>;IGNORE;IGNORE;IGNORE	#别60595
<U5487> <U5487>;IGNORE;IGNORE;IGNORE	#咇0
<U5FB6> <U5FB6>;IGNORE;IGNORE;IGNORE	#徶1
<U8382> <U8382>;IGNORE;IGNORE;IGNORE	#莂0
<U87DE> <U87DE>;IGNORE;IGNORE;IGNORE	#蟞0
<U8E69> <U8E69>;IGNORE;IGNORE;IGNORE	#蹩157
<U3FDC> <U3FDC>;IGNORE;IGNORE;IGNORE	#㿜0
<U86C2> <U86C2>;IGNORE;IGNORE;IGNORE	#蛂0
<U38BC> <U38BC>;IGNORE;IGNORE;IGNORE	#㢼0
<U4272> <U4272>;IGNORE;IGNORE;IGNORE	#䉲0
<U42E2> <U42E2>;IGNORE;IGNORE;IGNORE	#䋢0
<U43DF> <U43DF>;IGNORE;IGNORE;IGNORE	#䏟0
<U5F46> <U5F46>;IGNORE;IGNORE;IGNORE	#彆2
<U50A7> <U50A7>;IGNORE;IGNORE;IGNORE	#傧27
<U5110> <U5110>;IGNORE;IGNORE;IGNORE	#儐0
<U5BBE> <U5BBE>;IGNORE;IGNORE;IGNORE	#宾2942
<U5F6C> <U5F6C>;IGNORE;IGNORE;IGNORE	#彬1313
<U658C> <U658C>;IGNORE;IGNORE;IGNORE	#斌492
<U68B9> <U68B9>;IGNORE;IGNORE;IGNORE	#梹0
<U6915> <U6915>;IGNORE;IGNORE;IGNORE	#椕0
<U69DF> <U69DF>;IGNORE;IGNORE;IGNORE	#槟220
<U6AB3> <U6AB3>;IGNORE;IGNORE;IGNORE	#檳9
<U6C43> <U6C43>;IGNORE;IGNORE;IGNORE	#汃0
<U6EE8> <U6EE8>;IGNORE;IGNORE;IGNORE	#滨953
<U6FD2> <U6FD2>;IGNORE;IGNORE;IGNORE	#濒236
<U6FF1> <U6FF1>;IGNORE;IGNORE;IGNORE	#濱7
<U6FF5> <U6FF5>;IGNORE;IGNORE;IGNORE	#濵0
<U6FF9> <U6FF9>;IGNORE;IGNORE;IGNORE	#濹0
<U7015> <U7015>;IGNORE;IGNORE;IGNORE	#瀕9
<U73A2> <U73A2>;IGNORE;IGNORE;IGNORE	#玢0
<U7478> <U7478>;IGNORE;IGNORE;IGNORE	#瑸0
<U74B8> <U74B8>;IGNORE;IGNORE;IGNORE	#璸0
<U77C9> <U77C9>;IGNORE;IGNORE;IGNORE	#矉0
<U7A66> <U7A66>;IGNORE;IGNORE;IGNORE	#穦0
<U7E7D> <U7E7D>;IGNORE;IGNORE;IGNORE	#繽3
<U7F24> <U7F24>;IGNORE;IGNORE;IGNORE	#缤279
<U8819> <U8819>;IGNORE;IGNORE;IGNORE	#蠙0
<U8C69> <U8C69>;IGNORE;IGNORE;IGNORE	#豩0
<U8C73> <U8C73>;IGNORE;IGNORE;IGNORE	#豳3
<U8CD3> <U8CD3>;IGNORE;IGNORE;IGNORE	#賓19
<U8CD4> <U8CD4>;IGNORE;IGNORE;IGNORE	#賔0
<U90A0> <U90A0>;IGNORE;IGNORE;IGNORE	#邠0
<U944C> <U944C>;IGNORE;IGNORE;IGNORE	#鑌0
<U9554> <U9554>;IGNORE;IGNORE;IGNORE	#镔6
<U9726> <U9726>;IGNORE;IGNORE;IGNORE	#霦0
<U986E> <U986E>;IGNORE;IGNORE;IGNORE	#顮0
<U99AA> <U99AA>;IGNORE;IGNORE;IGNORE	#馪0
<U9A5E> <U9A5E>;IGNORE;IGNORE;IGNORE	#驞0
<U4414> <U4414>;IGNORE;IGNORE;IGNORE	#䐔0
<U6448> <U6448>;IGNORE;IGNORE;IGNORE	#摈69
<U64EF> <U64EF>;IGNORE;IGNORE;IGNORE	#擯0
<U6BA1> <U6BA1>;IGNORE;IGNORE;IGNORE	#殡227
<U6BAF> <U6BAF>;IGNORE;IGNORE;IGNORE	#殯3
<U8191> <U8191>;IGNORE;IGNORE;IGNORE	#膑92
<U81CF> <U81CF>;IGNORE;IGNORE;IGNORE	#臏0
<U9ACC> <U9ACC>;IGNORE;IGNORE;IGNORE	#髌1
<U9AD5> <U9AD5>;IGNORE;IGNORE;IGNORE	#髕0
<U9AE9> <U9AE9>;IGNORE;IGNORE;IGNORE	#髩0
<U9B02> <U9B02>;IGNORE;IGNORE;IGNORE	#鬂0
<U9B13> <U9B13>;IGNORE;IGNORE;IGNORE	#鬓428
<U9B22> <U9B22>;IGNORE;IGNORE;IGNORE	#鬢2
<U9DA3> <U9DA3>;IGNORE;IGNORE;IGNORE	#鶣0
<U4ECC> <U4ECC>;IGNORE;IGNORE;IGNORE	#仌0
<U50A1> <U50A1>;IGNORE;IGNORE;IGNORE	#傡0
<U5175> <U5175>;IGNORE;IGNORE;IGNORE	#兵17247
<U51AB> <U51AB>;IGNORE;IGNORE;IGNORE	#冫1
<U51B0> <U51B0>;IGNORE;IGNORE;IGNORE	#冰9243
<U63A4> <U63A4>;IGNORE;IGNORE;IGNORE	#掤0
<U6C37> <U6C37>;IGNORE;IGNORE;IGNORE	#氷0
<U7ADD> <U7ADD>;IGNORE;IGNORE;IGNORE	#竝0
<U3A00> <U3A00>;IGNORE;IGNORE;IGNORE	#㨀0
<U42D1> <U42D1>;IGNORE;IGNORE;IGNORE	#䋑0
<U44D1> <U44D1>;IGNORE;IGNORE;IGNORE	#䓑0
<U4D35> <U4D35>;IGNORE;IGNORE;IGNORE	#䴵0
<U4E19> <U4E19>;IGNORE;IGNORE;IGNORE	#丙394
<U5EB0> <U5EB0>;IGNORE;IGNORE;IGNORE	#庰0
<U5EEA> <U5EEA>;IGNORE;IGNORE;IGNORE	#廪9
<U6032> <U6032>;IGNORE;IGNORE;IGNORE	#怲0
<U62A6> <U62A6>;IGNORE;IGNORE;IGNORE	#抦0
<U661E> <U661E>;IGNORE;IGNORE;IGNORE	#昞0
<U663A> <U663A>;IGNORE;IGNORE;IGNORE	#昺1
<U67C4> <U67C4>;IGNORE;IGNORE;IGNORE	#柄1024
<U68C5> <U68C5>;IGNORE;IGNORE;IGNORE	#棅0
<U70B3> <U70B3>;IGNORE;IGNORE;IGNORE	#炳369
<U7415> <U7415>;IGNORE;IGNORE;IGNORE	#琕0
<U765D> <U765D>;IGNORE;IGNORE;IGNORE	#癝0
<U772A> <U772A>;IGNORE;IGNORE;IGNORE	#眪0
<U7980> <U7980>;IGNORE;IGNORE;IGNORE	#禀707
<U79C9> <U79C9>;IGNORE;IGNORE;IGNORE	#秉471
<U7A1F> <U7A1F>;IGNORE;IGNORE;IGNORE	#稟1
<U7A89> <U7A89>;IGNORE;IGNORE;IGNORE	#窉0
<U82EA> <U82EA>;IGNORE;IGNORE;IGNORE	#苪0
<U86C3> <U86C3>;IGNORE;IGNORE;IGNORE	#蛃0
<U90B4> <U90B4>;IGNORE;IGNORE;IGNORE	#邴0
<U9235> <U9235>;IGNORE;IGNORE;IGNORE	#鈵0
<U927C> <U927C>;IGNORE;IGNORE;IGNORE	#鉼0
<U9643> <U9643>;IGNORE;IGNORE;IGNORE	#陃0
<U979E> <U979E>;IGNORE;IGNORE;IGNORE	#鞞1
<U9905> <U9905>;IGNORE;IGNORE;IGNORE	#餅3
<U9920> <U9920>;IGNORE;IGNORE;IGNORE	#餠0
<U997C> <U997C>;IGNORE;IGNORE;IGNORE	#饼1862
<U4202> <U4202>;IGNORE;IGNORE;IGNORE	#䈂0
<U45D2> <U45D2>;IGNORE;IGNORE;IGNORE	#䗒0
<U4E26> <U4E26>;IGNORE;IGNORE;IGNORE	#並384
<U4F75> <U4F75>;IGNORE;IGNORE;IGNORE	#併9
<U5002> <U5002>;IGNORE;IGNORE;IGNORE	#倂0
<U504B> <U504B>;IGNORE;IGNORE;IGNORE	#偋0
<U5BCE> <U5BCE>;IGNORE;IGNORE;IGNORE	#寎0
<U5E76> <U5E76>;IGNORE;IGNORE;IGNORE	#并59894
<U5E77> <U5E77>;IGNORE;IGNORE;IGNORE	#幷0
<U6452> <U6452>;IGNORE;IGNORE;IGNORE	#摒111
<U6824> <U6824>;IGNORE;IGNORE;IGNORE	#栤0
<U75C5> <U75C5>;IGNORE;IGNORE;IGNORE	#病17037
<U9750> <U9750>;IGNORE;IGNORE;IGNORE	#靐0
<U9BA9> <U9BA9>;IGNORE;IGNORE;IGNORE	#鮩0
<U9D67> <U9D67>;IGNORE;IGNORE;IGNORE	#鵧0
<U525D> <U525D>;IGNORE;IGNORE;IGNORE	#剝13
<U5575> <U5575>;IGNORE;IGNORE;IGNORE	#啵53
<U5CA5> <U5CA5>;IGNORE;IGNORE;IGNORE	#岥0
<U5D93> <U5D93>;IGNORE;IGNORE;IGNORE	#嶓0
<U5F42> <U5F42>;IGNORE;IGNORE;IGNORE	#彂0
<U62E8> <U62E8>;IGNORE;IGNORE;IGNORE	#拨3564
<U64A5> <U64A5>;IGNORE;IGNORE;IGNORE	#撥18
<U64AD> <U64AD>;IGNORE;IGNORE;IGNORE	#播4111
<U67ED> <U67ED>;IGNORE;IGNORE;IGNORE	#柭0
<U6CE2> <U6CE2>;IGNORE;IGNORE;IGNORE	#波12962
<U73BB> <U73BB>;IGNORE;IGNORE;IGNORE	#玻4019
<U7676> <U7676>;IGNORE;IGNORE;IGNORE	#癶0
<U76CB> <U76CB>;IGNORE;IGNORE;IGNORE	#盋0
<U7835> <U7835>;IGNORE;IGNORE;IGNORE	#砵0
<U7886> <U7886>;IGNORE;IGNORE;IGNORE	#碆0
<U7F3D> <U7F3D>;IGNORE;IGNORE;IGNORE	#缽94
<U83E0> <U83E0>;IGNORE;IGNORE;IGNORE	#菠137
<U889A> <U889A>;IGNORE;IGNORE;IGNORE	#袚0
<U894F> <U894F>;IGNORE;IGNORE;IGNORE	#襏0
<U8E73> <U8E73>;IGNORE;IGNORE;IGNORE	#蹳0
<U9262> <U9262>;IGNORE;IGNORE;IGNORE	#鉢0
<U94B5> <U94B5>;IGNORE;IGNORE;IGNORE	#钵256
<U9911> <U9911>;IGNORE;IGNORE;IGNORE	#餑0
<U997D> <U997D>;IGNORE;IGNORE;IGNORE	#饽260
<U9A4B> <U9A4B>;IGNORE;IGNORE;IGNORE	#驋0
<U9AC9> <U9AC9>;IGNORE;IGNORE;IGNORE	#髉0
<U9C4D> <U9C4D>;IGNORE;IGNORE;IGNORE	#鱍0
<U35D8> <U35D8>;IGNORE;IGNORE;IGNORE	#㗘0
<U377F> <U377F>;IGNORE;IGNORE;IGNORE	#㝿0
<U37D1> <U37D1>;IGNORE;IGNORE;IGNORE	#㟑0
<U39F3> <U39F3>;IGNORE;IGNORE;IGNORE	#㧳0
<U3A67> <U3A67>;IGNORE;IGNORE;IGNORE	#㩧0
<U3A6D> <U3A6D>;IGNORE;IGNORE;IGNORE	#㩭0
<U3A8D> <U3A8D>;IGNORE;IGNORE;IGNORE	#㪍0
<U3B0D> <U3B0D>;IGNORE;IGNORE;IGNORE	#㬍0
<U3B27> <U3B27>;IGNORE;IGNORE;IGNORE	#㬧0
<U3C5F> <U3C5F>;IGNORE;IGNORE;IGNORE	#㱟0
<U3D3E> <U3D3E>;IGNORE;IGNORE;IGNORE	#㴾0
<U3DBF> <U3DBF>;IGNORE;IGNORE;IGNORE	#㶿0
<U3E40> <U3E40>;IGNORE;IGNORE;IGNORE	#㹀0
<U408D> <U408D>;IGNORE;IGNORE;IGNORE	#䂍0
<U42BF> <U42BF>;IGNORE;IGNORE;IGNORE	#䊿0
<U4368> <U4368>;IGNORE;IGNORE;IGNORE	#䍨0
<U4378> <U4378>;IGNORE;IGNORE;IGNORE	#䍸0
<U4448> <U4448>;IGNORE;IGNORE;IGNORE	#䑈0
<U4484> <U4484>;IGNORE;IGNORE;IGNORE	#䒄0
<U45DA> <U45DA>;IGNORE;IGNORE;IGNORE	#䗚0
<U464F> <U464F>;IGNORE;IGNORE;IGNORE	#䙏0
<U47B3> <U47B3>;IGNORE;IGNORE;IGNORE	#䞳0
<U47DB> <U47DB>;IGNORE;IGNORE;IGNORE	#䟛0
<U488C> <U488C>;IGNORE;IGNORE;IGNORE	#䢌0
<U48AA> <U48AA>;IGNORE;IGNORE;IGNORE	#䢪0
<U496C> <U496C>;IGNORE;IGNORE;IGNORE	#䥬0
<U4A87> <U4A87>;IGNORE;IGNORE;IGNORE	#䪇0
<U4AAC> <U4AAC>;IGNORE;IGNORE;IGNORE	#䪬0
<U4ACA> <U4ACA>;IGNORE;IGNORE;IGNORE	#䫊0
<U4B2A> <U4B2A>;IGNORE;IGNORE;IGNORE	#䬪0
<U4B66> <U4B66>;IGNORE;IGNORE;IGNORE	#䭦0
<U4B6F> <U4B6F>;IGNORE;IGNORE;IGNORE	#䭯0
<U4B80> <U4B80>;IGNORE;IGNORE;IGNORE	#䮀0
<U4B82> <U4B82>;IGNORE;IGNORE;IGNORE	#䮂0
<U4BCB> <U4BCB>;IGNORE;IGNORE;IGNORE	#䯋0
<U4C0A> <U4C0A>;IGNORE;IGNORE;IGNORE	#䰊0
<U4D88> <U4D88>;IGNORE;IGNORE;IGNORE	#䶈0
<U4EB3> <U4EB3>;IGNORE;IGNORE;IGNORE	#亳21
<U4F2F> <U4F2F>;IGNORE;IGNORE;IGNORE	#伯9675
<U4FBC> <U4FBC>;IGNORE;IGNORE;IGNORE	#侼0
<U50F0> <U50F0>;IGNORE;IGNORE;IGNORE	#僰1
<U52C3> <U52C3>;IGNORE;IGNORE;IGNORE	#勃3252
<U535A> <U535A>;IGNORE;IGNORE;IGNORE	#博6173
<U5D8F> <U5D8F>;IGNORE;IGNORE;IGNORE	#嶏0
<U5E1B> <U5E1B>;IGNORE;IGNORE;IGNORE	#帛139
<U613D> <U613D>;IGNORE;IGNORE;IGNORE	#愽0
<U61EA> <U61EA>;IGNORE;IGNORE;IGNORE	#懪0
<U632C> <U632C>;IGNORE;IGNORE;IGNORE	#挬0
<U640F> <U640F>;IGNORE;IGNORE;IGNORE	#搏880
<U6540> <U6540>;IGNORE;IGNORE;IGNORE	#敀0
<U67CF> <U67CF>;IGNORE;IGNORE;IGNORE	#柏2000
<U6872> <U6872>;IGNORE;IGNORE;IGNORE	#桲5
<U6A97> <U6A97>;IGNORE;IGNORE;IGNORE	#檗3
<U6B02> <U6B02>;IGNORE;IGNORE;IGNORE	#欂0
<U6CCA> <U6CCA>;IGNORE;IGNORE;IGNORE	#泊1392
<U6CFA> <U6CFA>;IGNORE;IGNORE;IGNORE	#泺2
<U6D61> <U6D61>;IGNORE;IGNORE;IGNORE	#浡0
<U6E24> <U6E24>;IGNORE;IGNORE;IGNORE	#渤68
<U717F> <U717F>;IGNORE;IGNORE;IGNORE	#煿0
<U7254> <U7254>;IGNORE;IGNORE;IGNORE	#牔0
<U72BB> <U72BB>;IGNORE;IGNORE;IGNORE	#犻0
<U733C> <U733C>;IGNORE;IGNORE;IGNORE	#猼0
<U7921> <U7921>;IGNORE;IGNORE;IGNORE	#礡0
<U7934> <U7934>;IGNORE;IGNORE;IGNORE	#礴50
<U7B94> <U7B94>;IGNORE;IGNORE;IGNORE	#箔89
<U7C19> <U7C19>;IGNORE;IGNORE;IGNORE	#簙0
<U7CEA> <U7CEA>;IGNORE;IGNORE;IGNORE	#糪0
<U80C9> <U80C9>;IGNORE;IGNORE;IGNORE	#胉0
<U8116> <U8116>;IGNORE;IGNORE;IGNORE	#脖3061
<U818A> <U818A>;IGNORE;IGNORE;IGNORE	#膊2493
<U8236> <U8236>;IGNORE;IGNORE;IGNORE	#舶107
<U824A> <U824A>;IGNORE;IGNORE;IGNORE	#艊0
<U82E9> <U82E9>;IGNORE;IGNORE;IGNORE	#苩0
<U8467> <U8467>;IGNORE;IGNORE;IGNORE	#葧0
<U88AF> <U88AF>;IGNORE;IGNORE;IGNORE	#袯0
<U896E> <U896E>;IGNORE;IGNORE;IGNORE	#襮0
<U8B08> <U8B08>;IGNORE;IGNORE;IGNORE	#謈0
<U8E04> <U8E04>;IGNORE;IGNORE;IGNORE	#踄0
<U8E23> <U8E23>;IGNORE;IGNORE;IGNORE	#踣0
<U90E3> <U90E3>;IGNORE;IGNORE;IGNORE	#郣0
<U9251> <U9251>;IGNORE;IGNORE;IGNORE	#鉑0
<U92CD> <U92CD>;IGNORE;IGNORE;IGNORE	#鋍0
<U939B> <U939B>;IGNORE;IGNORE;IGNORE	#鎛2
<U946E> <U946E>;IGNORE;IGNORE;IGNORE	#鑮0
<U94C2> <U94C2>;IGNORE;IGNORE;IGNORE	#铂63
<U9548> <U9548>;IGNORE;IGNORE;IGNORE	#镈0
<U993A> <U993A>;IGNORE;IGNORE;IGNORE	#餺0
<U998E> <U998E>;IGNORE;IGNORE;IGNORE	#馎0
<U999E> <U999E>;IGNORE;IGNORE;IGNORE	#馞0
<U99C1> <U99C1>;IGNORE;IGNORE;IGNORE	#駁25
<U99EE> <U99EE>;IGNORE;IGNORE;IGNORE	#駮0
<U9A73> <U9A73>;IGNORE;IGNORE;IGNORE	#驳2067
<U9AC6> <U9AC6>;IGNORE;IGNORE;IGNORE	#髆1
<U9D53> <U9D53>;IGNORE;IGNORE;IGNORE	#鵓0
<U9E14> <U9E14>;IGNORE;IGNORE;IGNORE	#鸔0
<U9E41> <U9E41>;IGNORE;IGNORE;IGNORE	#鹁14
<U7BA5> <U7BA5>;IGNORE;IGNORE;IGNORE	#箥0
<U7C38> <U7C38>;IGNORE;IGNORE;IGNORE	#簸328
<U86BE> <U86BE>;IGNORE;IGNORE;IGNORE	#蚾0
<U8DDB> <U8DDB>;IGNORE;IGNORE;IGNORE	#跛244
<U99CA> <U99CA>;IGNORE;IGNORE;IGNORE	#駊0
<U3595> <U3595>;IGNORE;IGNORE;IGNORE	#㖕0
<U5B79> <U5B79>;IGNORE;IGNORE;IGNORE	#孹0
<U6300> <U6300>;IGNORE;IGNORE;IGNORE	#挀0
<U64D7> <U64D7>;IGNORE;IGNORE;IGNORE	#擗2
<U64D8> <U64D8>;IGNORE;IGNORE;IGNORE	#擘40
<U7588> <U7588>;IGNORE;IGNORE;IGNORE	#疈0
<U7E74> <U7E74>;IGNORE;IGNORE;IGNORE	#繴0
<U8617> <U8617>;IGNORE;IGNORE;IGNORE	#蘗1
<U8B52> <U8B52>;IGNORE;IGNORE;IGNORE	#譒0
<U535C> <U535C>;IGNORE;IGNORE;IGNORE	#卜1771
<U5643> <U5643>;IGNORE;IGNORE;IGNORE	#噃0
<U8514> <U8514>;IGNORE;IGNORE;IGNORE	#蔔0
<U5CEC> <U5CEC>;IGNORE;IGNORE;IGNORE	#峬0
<U5EAF> <U5EAF>;IGNORE;IGNORE;IGNORE	#庯0
<U6661> <U6661>;IGNORE;IGNORE;IGNORE	#晡1
<U900B> <U900B>;IGNORE;IGNORE;IGNORE	#逋10
<U923D> <U923D>;IGNORE;IGNORE;IGNORE	#鈽0
<U94B8> <U94B8>;IGNORE;IGNORE;IGNORE	#钸1
<U9914> <U9914>;IGNORE;IGNORE;IGNORE	#餔1
<U9D4F> <U9D4F>;IGNORE;IGNORE;IGNORE	#鵏0
<U4E0D> <U4E0D>;IGNORE;IGNORE;IGNORE	#不376503
<U91AD> <U91AD>;IGNORE;IGNORE;IGNORE	#醭0
<U365B> <U365B>;IGNORE;IGNORE;IGNORE	#㙛0
<U3A10> <U3A10>;IGNORE;IGNORE;IGNORE	#㨐0
<U402F> <U402F>;IGNORE;IGNORE;IGNORE	#䀯0
<U42E0> <U42E0>;IGNORE;IGNORE;IGNORE	#䋠0
<U4488> <U4488>;IGNORE;IGNORE;IGNORE	#䒈0
<U4A81> <U4A81>;IGNORE;IGNORE;IGNORE	#䪁0
<U4A94> <U4A94>;IGNORE;IGNORE;IGNORE	#䪔0
<U535F> <U535F>;IGNORE;IGNORE;IGNORE	#卟59
<U54FA> <U54FA>;IGNORE;IGNORE;IGNORE	#哺256
<U6355> <U6355>;IGNORE;IGNORE;IGNORE	#捕3662
<U735B> <U735B>;IGNORE;IGNORE;IGNORE	#獛0
<U8865> <U8865>;IGNORE;IGNORE;IGNORE	#补7091
<U88DC> <U88DC>;IGNORE;IGNORE;IGNORE	#補60
<U9CEA> <U9CEA>;IGNORE;IGNORE;IGNORE	#鳪0
<U3635> <U3635>;IGNORE;IGNORE;IGNORE	#㘵0
<U36B4> <U36B4>;IGNORE;IGNORE;IGNORE	#㚴0
<U3CCD> <U3CCD>;IGNORE;IGNORE;IGNORE	#㳍0
<U3EC9> <U3EC9>;IGNORE;IGNORE;IGNORE	#㻉0
<U3F9F> <U3F9F>;IGNORE;IGNORE;IGNORE	#㾟0
<U4287> <U4287>;IGNORE;IGNORE;IGNORE	#䊇0
<U434C> <U434C>;IGNORE;IGNORE;IGNORE	#䍌0
<U43FD> <U43FD>;IGNORE;IGNORE;IGNORE	#䏽0
<U4470> <U4470>;IGNORE;IGNORE;IGNORE	#䑰0
<U4775> <U4775>;IGNORE;IGNORE;IGNORE	#䝵0
<U4B0F> <U4B0F>;IGNORE;IGNORE;IGNORE	#䬏0
<U4CDD> <U4CDD>;IGNORE;IGNORE;IGNORE	#䳝0
<U4D1D> <U4D1D>;IGNORE;IGNORE;IGNORE	#䴝0
<U4D3A> <U4D3A>;IGNORE;IGNORE;IGNORE	#䴺0
<U4F48> <U4F48>;IGNORE;IGNORE;IGNORE	#佈35
<U52CF> <U52CF>;IGNORE;IGNORE;IGNORE	#勏0
<U5498> <U5498>;IGNORE;IGNORE;IGNORE	#咘0
<U57D4> <U57D4>;IGNORE;IGNORE;IGNORE	#埔268
<U57D7> <U57D7>;IGNORE;IGNORE;IGNORE	#埗2
<U57E0> <U57E0>;IGNORE;IGNORE;IGNORE	#埠340
<U5E03> <U5E03>;IGNORE;IGNORE;IGNORE	#布27866
<U6016> <U6016>;IGNORE;IGNORE;IGNORE	#怖4272
<U6091> <U6091>;IGNORE;IGNORE;IGNORE	#悑0
<U6357> <U6357>;IGNORE;IGNORE;IGNORE	#捗0
<U6B65> <U6B65>;IGNORE;IGNORE;IGNORE	#步28886
<U6B68> <U6B68>;IGNORE;IGNORE;IGNORE	#歨0
<U6B69> <U6B69>;IGNORE;IGNORE;IGNORE	#歩0
<U74FF> <U74FF>;IGNORE;IGNORE;IGNORE	#瓿3
<U7BF0> <U7BF0>;IGNORE;IGNORE;IGNORE	#篰0
<U7C3F> <U7C3F>;IGNORE;IGNORE;IGNORE	#簿473
<U8379> <U8379>;IGNORE;IGNORE;IGNORE	#荹0
<U8500> <U8500>;IGNORE;IGNORE;IGNORE	#蔀0
<U90E8> <U90E8>;IGNORE;IGNORE;IGNORE	#部65674
<U90F6> <U90F6>;IGNORE;IGNORE;IGNORE	#郶0
<U9208> <U9208>;IGNORE;IGNORE;IGNORE	#鈈0
<U949A> <U949A>;IGNORE;IGNORE;IGNORE	#钚20
<U9922> <U9922>;IGNORE;IGNORE;IGNORE	#餢0
<U50AA> <U50AA>;IGNORE;IGNORE;IGNORE	#傪3
<U5693> <U5693>;IGNORE;IGNORE;IGNORE	#嚓440
<U64E6> <U64E6>;IGNORE;IGNORE;IGNORE	#擦4777
<U7924> <U7924>;IGNORE;IGNORE;IGNORE	#礤0
<U47C3> <U47C3>;IGNORE;IGNORE;IGNORE	#䟃0
<U4D7D> <U4D7D>;IGNORE;IGNORE;IGNORE	#䵽0
<U56C3> <U56C3>;IGNORE;IGNORE;IGNORE	#囃0
<U5072> <U5072>;IGNORE;IGNORE;IGNORE	#偲1
<U731C> <U731C>;IGNORE;IGNORE;IGNORE	#猜4847
<U7775> <U7775>;IGNORE;IGNORE;IGNORE	#睵0
<U34B2> <U34B2>;IGNORE;IGNORE;IGNORE	#㒲0
<U4D2D> <U4D2D>;IGNORE;IGNORE;IGNORE	#䴭0
<U624D> <U624D>;IGNORE;IGNORE;IGNORE	#才60339
<U6750> <U6750>;IGNORE;IGNORE;IGNORE	#材5559
<U6EA8> <U6EA8>;IGNORE;IGNORE;IGNORE	#溨0
<U7E94> <U7E94>;IGNORE;IGNORE;IGNORE	#纔4
<U88C1> <U88C1>;IGNORE;IGNORE;IGNORE	#裁3302
<U8CA1> <U8CA1>;IGNORE;IGNORE;IGNORE	#財22
<U8D22> <U8D22>;IGNORE;IGNORE;IGNORE	#财6839
<U3952> <U3952>;IGNORE;IGNORE;IGNORE	#㥒0
<U433D> <U433D>;IGNORE;IGNORE;IGNORE	#䌽0
<U4406> <U4406>;IGNORE;IGNORE;IGNORE	#䐆0
<U48CB> <U48CB>;IGNORE;IGNORE;IGNORE	#䣋0
<U5038> <U5038>;IGNORE;IGNORE;IGNORE	#倸0
<U5A47> <U5A47>;IGNORE;IGNORE;IGNORE	#婇0
<U5BC0> <U5BC0>;IGNORE;IGNORE;IGNORE	#寀0
<U5F69> <U5F69>;IGNORE;IGNORE;IGNORE	#彩7464
<U63A1> <U63A1>;IGNORE;IGNORE;IGNORE	#採56
<U68CC> <U68CC>;IGNORE;IGNORE;IGNORE	#棌0
<U776C> <U776C>;IGNORE;IGNORE;IGNORE	#睬554
<U7DB5> <U7DB5>;IGNORE;IGNORE;IGNORE	#綵0
<U8DF4> <U8DF4>;IGNORE;IGNORE;IGNORE	#跴0
<U8E29> <U8E29>;IGNORE;IGNORE;IGNORE	#踩1884
<U91C7> <U91C7>;IGNORE;IGNORE;IGNORE	#采11023
<U4328> <U4328>;IGNORE;IGNORE;IGNORE	#䌨0
<U4C02> <U4C02>;IGNORE;IGNORE;IGNORE	#䰂0
<U57F0> <U57F0>;IGNORE;IGNORE;IGNORE	#埰0
<U7E29> <U7E29>;IGNORE;IGNORE;IGNORE	#縩0
<U83DC> <U83DC>;IGNORE;IGNORE;IGNORE	#菜8409
<U8521> <U8521>;IGNORE;IGNORE;IGNORE	#蔡1637
<U53C2> <U53C2>;IGNORE;IGNORE;IGNORE	#参20000
<U53C3> <U53C3>;IGNORE;IGNORE;IGNORE	#參111
<U53C4> <U53C4>;IGNORE;IGNORE;IGNORE	#叄0
<U53C5> <U53C5>;IGNORE;IGNORE;IGNORE	#叅0
<U55B0> <U55B0>;IGNORE;IGNORE;IGNORE	#喰0
<U6B7A> <U6B7A>;IGNORE;IGNORE;IGNORE	#歺1
<U6E4C> <U6E4C>;IGNORE;IGNORE;IGNORE	#湌0
<U84E1> <U84E1>;IGNORE;IGNORE;IGNORE	#蓡0
<U8B32> <U8B32>;IGNORE;IGNORE;IGNORE	#謲0
<U98E1> <U98E1>;IGNORE;IGNORE;IGNORE	#飡0
<U9910> <U9910>;IGNORE;IGNORE;IGNORE	#餐5651
<U9A42> <U9A42>;IGNORE;IGNORE;IGNORE	#驂0
<U9A96> <U9A96>;IGNORE;IGNORE;IGNORE	#骖5
<U9BF5> <U9BF5>;IGNORE;IGNORE;IGNORE	#鯵0
<U9C3A> <U9C3A>;IGNORE;IGNORE;IGNORE	#鰺0
<U3947> <U3947>;IGNORE;IGNORE;IGNORE	#㥇0
<U3A3B> <U3A3B>;IGNORE;IGNORE;IGNORE	#㨻0
<U3C5A> <U3C5A>;IGNORE;IGNORE;IGNORE	#㱚0
<U3E91> <U3E91>;IGNORE;IGNORE;IGNORE	#㺑0
<U437C> <U437C>;IGNORE;IGNORE;IGNORE	#䍼0
<U43FC> <U43FC>;IGNORE;IGNORE;IGNORE	#䏼0
<U4476> <U4476>;IGNORE;IGNORE;IGNORE	#䑶0
<U45DD> <U// Written in the D programming language

/++

$(DIVC quickindex,
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD Types) $(TD
    $(LREF Clock)
    $(LREF SysTime)
    $(LREF DosFileTime)
))
$(TR $(TD Conversion) $(TD
    $(LREF parseRFC822DateTime)
    $(LREF DosFileTimeToSysTime)
    $(LREF FILETIMEToStdTime)
    $(LREF FILETIMEToSysTime)
    $(LREF stdTimeToFILETIME)
    $(LREF stdTimeToUnixTime)
    $(LREF SYSTEMTIMEToSysTime)
    $(LREF SysTimeToDosFileTime)
    $(LREF SysTimeToFILETIME)
    $(LREF SysTimeToSYSTEMTIME)
    $(LREF unixTimeToStdTime)
))
))

    License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
    Authors:   $(HTTP jmdavisprog.com, Jonathan M Davis)
    Source:    $(PHOBOSSRC std/datetime/systime.d)
+/
module std.datetime.systime;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

/// Get the current time as a $(LREF SysTime)
@safe unittest
{
    import std.datetime.timezone : LocalTime;
    SysTime today = Clock.currTime();
    assert(today.timezone is LocalTime());
}

/// Construct a $(LREF SysTime) from a ISO time string
@safe unittest
{
    import std.datetime.date : DateTime;
    import std.datetime.timezone : UTC;

    auto st = SysTime.fromISOExtString("2018-01-01T10:30:00Z");
    assert(st == SysTime(DateTime(2018, 1, 1, 10, 30, 0), UTC()));
}

/// Make a specific point in time in the New York timezone
@safe unittest
{
    import core.time : hours;
    import std.datetime.date : DateTime;
    import std.datetime.timezone : SimpleTimeZone;

    auto ny = SysTime(
        DateTime(2018, 1, 1, 10, 30, 0),
        new immutable SimpleTimeZone(-5.hours, "America/New_York")
    );

    // ISO standard time strings
    assert(ny.toISOString() == "20180101T103000-05:00");
    assert(ny.toISOExtString() == "2018-01-01T10:30:00-05:00");
}

// Note: reconsider using specific imports below after
// https://issues.dlang.org/show_bug.cgi?id=17630 has been fixed
import core.time;// : ClockType, convert, dur, Duration, seconds, TimeException;
import std.datetime.date;// : _monthNames, AllowDayOverflow, CmpTimeUnits, Date,
    //DateTime, DateTimeException, DayOfWeek, enforceValid, getDayOfWeek, maxDay,
    //Month, splitUnitsFromHNSecs, TimeOfDay, validTimeUnits, yearIsLeapYear;
import std.datetime.timezone;// : LocalTime, SimpleTimeZone, TimeZone, UTC;
import std.exception : enforce;
import std.format : format;
import std.range.primitives;
import std.traits : isIntegral, isSigned, isSomeString, isNarrowString;

version (Windows)
{
    import core.stdc.time : time_t;
    import core.sys.windows.winbase;
    import core.sys.windows.winnt;
    import core.sys.windows.winsock2;
}
else version (Posix)
{
    import core.sys.posix.signal : timespec;
    import core.sys.posix.sys.types : time_t;
}

version (StdUnittest)
{
    import core.exception : AssertError;
    import std.exception : assertThrown;
}


@safe unittest
{
    initializeTests();
}

version (unittest) private bool clockSupported(ClockType c)
{
    // Skip unsupported clocks on older linux kernels, assume that only
    // CLOCK_MONOTONIC and CLOCK_REALTIME exist, as that is the lowest
    // common denominator supported by all versions of Linux pre-2.6.12.
    version (Linux_Pre_2639)
        return c == ClockType.normal || c == ClockType.precise;
    else
        return true;
}

/++
    Effectively a namespace to make it clear that the methods it contains are
    getting the time from the system clock. It cannot be instantiated.
 +/
final class Clock
{
public:

    /++
        Returns the current time in the given time zone.

        Params:
            clockType = The $(REF ClockType, core,time) indicates which system
                        clock to use to get the current time. Very few programs
                        need to use anything other than the default.
            tz = The time zone for the SysTime that's returned.

        Throws:
            $(REF DateTimeException,std,datetime,date) if it fails to get the
            time.
      +/
    static SysTime currTime(ClockType clockType = ClockType.normal)(immutable TimeZone tz = LocalTime()) @safe
    {
        return SysTime(currStdTime!clockType, tz);
    }

    @safe unittest
    {
        import std.format : format;
        import core.time;
        assert(currTime().timezone is LocalTime());
        assert(currTime(UTC()).timezone is UTC());

        // core.stdc.time.time does not always use unix time on Windows systems.
        // In particular, dmc does not use unix time. If we can guarantee that
        // the MS runtime uses unix time, then we may be able run this test
        // then, but for now, we're just not going to run this test on Windows.
        version (Posix)
        {
            static import core.stdc.time;
            static import std.math;
            immutable unixTimeD = currTime().toUnixTime();
            immutable unixTimeC = core.stdc.time.time(null);
            assert(std.math.abs(unixTimeC - unixTimeD) <= 2);
        }

        auto norm1 = Clock.currTime;
        auto norm2 = Clock.currTime(UTC());
        assert(norm1 <= norm2, format("%s %s", norm1, norm2));
        assert(abs(norm1 - norm2) <= seconds(2));

        import std.meta : AliasSeq;
        static foreach (ct; AliasSeq!(ClockType.coarse, ClockType.precise, ClockType.second))
        {{
            static if (clockSupported(ct))
            {
                auto value1 = Clock.currTime!ct;
                auto value2 = Clock.currTime!ct(UTC());
                assert(value1 <= value2, format("%s %s (ClockType: %s)", value1, value2, ct));
                assert(abs(value1 - value2) <= seconds(2), format("ClockType.%s", ct));
            }
        }}
    }


    /++
        Returns the number of hnsecs since midnight, January 1st, 1 A.D. for the
        current time.

        Params:
            clockType = The $(REF ClockType, core,time) indicates which system
                        clock to use to get the current time. Very few programs
                        need to use anything other than the default.

        Throws:
            $(REF DateTimeException,std,datetime,date) if it fails to get the
            time.
      +/
    static @property long currStdTime(ClockType clockType = ClockType.normal)() @trusted
    {
        static if (clockType != ClockType.coarse &&
                   clockType != ClockType.normal &&
                   clockType != ClockType.precise &&
                   clockType != ClockType.second)
        {
            static assert(0, format("ClockType.%s is not supported by Clock.currTime or Clock.currStdTime", clockType));
        }

        version (Windows)
        {
            FILETIME fileTime;
            GetSystemTimeAsFileTime(&fileTime);
            immutable result = FILETIMEToStdTime(&fileTime);
            static if (clockType == ClockType.second)
            {
                // Ideally, this would use core.std.time.time, but the C runtime
                // has to be using unix time for that to work, and that's not
                // guaranteed on Windows. Digital Mars does not use unix time.
                // MS may or may not. If it does, then this can be made to use
                // core.stdc.time for MS, but for now, we'll leave it like this.
                return convert!("seconds", "hnsecs")(convert!("hnsecs", "seconds")(result));
            }
            else
                return result;
        }
        else version (Posix)
        {
            static import core.stdc.time;
            enum hnsecsToUnixEpoch = unixTimeToStdTime(0);

            version (Darwin)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.posix.sys.time : gettimeofday, timeval;
                    timeval tv = void;
                    // Posix gettimeofday called with a valid timeval address
                    // and a null second parameter doesn't fail.
                    gettimeofday(&tv, null);
                    return convert!("seconds", "hnsecs")(tv.tv_sec) +
                           tv.tv_usec * 10 +
                           hnsecsToUnixEpoch;
                }
            }
            else version (linux)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.linux.time : CLOCK_REALTIME_COARSE;
                    import core.sys.posix.time : clock_gettime, CLOCK_REALTIME;
                    static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME_COARSE;
                    else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME;
                    else static assert(0, "Previous static if is wrong.");
                    timespec ts = void;
                    immutable error = clock_gettime(clockArg, &ts);
                    // Posix clock_gettime called with a valid address and valid clock_id is only
                    // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                    // is long or larger overflow won't happen before 292 billion years A.D.
                    static if (ts.tv_sec.max < long.max)
                    {
                        if (error)
                            throw new TimeException("Call to clock_gettime() failed");
                    }
                    return convert!("seconds", "hnsecs")(ts.tv_sec) +
                           ts.tv_nsec / 100 +
                           hnsecsToUnixEpoch;
                }
            }
            else version (FreeBSD)
            {
                import core.sys.freebsd.time : clock_gettime, CLOCK_REALTIME,
                    CLOCK_REALTIME_FAST, CLOCK_REALTIME_PRECISE, CLOCK_SECOND;
                static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME_FAST;
                else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME_PRECISE;
                else static if (clockType == ClockType.second)  alias clockArg = CLOCK_SECOND;
                else static assert(0, "Previous static if is wrong.");
                timespec ts = void;
                immutable error = clock_gettime(clockArg, &ts);
                // Posix clock_gettime called with a valid address and valid clock_id is only
                // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                // is long or larger overflow won't happen before 292 billion years A.D.
                static if (ts.tv_sec.max < long.max)
                {
                    if (error)
                        throw new TimeException("Call to clock_gettime() failed");
                }
                return convert!("seconds", "hnsecs")(ts.tv_sec) +
                       ts.tv_nsec / 100 +
                       hnsecsToUnixEpoch;
            }
            else version (NetBSD)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.netbsd.time : clock_gettime, CLOCK_REALTIME;
                    timespec ts = void;
                    immutable error = clock_gettime(CLOCK_REALTIME, &ts);
                    // Posix clock_gettime called with a valid address and valid clock_id is only
                    // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                    // is long or larger overflow won't happen before 292 billion years A.D.
                    static if (ts.tv_sec.max < long.max)
                    {
                        if (error)
                            throw new TimeException("Call to clock_gettime() failed");
                    }
                    return convert!("seconds", "hnsecs")(ts.tv_sec) +
                           ts.tv_nsec / 100 +
                           hnsecsToUnixEpoch;
                }
            }
            else version (OpenBSD)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.openbsd.time : clock_gettime, CLOCK_REALTIME;
                    static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME;
                    else static assert(0, "Previous static if is wrong.");
                    timespec ts;
                    if (clock_gettime(clockArg, &ts) != 0)
                        throw new TimeException("Call to clock_gettime() failed");
                    return convert!("seconds", "hnsecs")(ts.tv_sec) +
                           ts.tv_nsec / 100 +
                           hnsecsToUnixEpoch;
                }
            }
            else version (DragonFlyBSD)
            {
                import core.sys.dragonflybsd.time : clock_gettime, CLOCK_REALTIME,
                    CLOCK_REALTIME_FAST, CLOCK_REALTIME_PRECISE, CLOCK_SECOND;
                static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME_FAST;
                else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME_PRECISE;
                else static if (clockType == ClockType.second)  alias clockArg = CLOCK_SECOND;
                else static assert(0, "Previous static if is wrong.");
                timespec ts = void;
                immutable error = clock_gettime(clockArg, &ts);
                // Posix clock_gettime called with a valid address and valid clock_id is only
                // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                // is long or larger overflow won't happen before 292 billion years A.D.
                static if (ts.tv_sec.max < long.max)
                {
                    if (error)
                        throw new TimeException("Call to clock_gettime() failed");
                }
                return convert!("seconds", "hnsecs")(ts.tv_sec) +
                       ts.tv_nsec / 100 +
                       hnsecsToUnixEpoch;
            }
            else version (Solaris)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.solaris.time : clock_gettime, CLOCK_REALTIME;
                    static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME;
                    else static assert(0, "Previous static if is wrong.");
                    timespec ts = void;
                    immutable error = clock_gettime(clockArg, &ts);
                    // Posix clock_gettime called with a valid address and valid clock_id is only
                    // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                    // is long or larger overflow won't happen before 292 billion years A.D.
                    static if (ts.tv_sec.max < long.max)
                    {
                        if (error)
                            throw new TimeException("Call to clock_gettime() failed");
                    }
                    return convert!("seconds", "hnsecs")(ts.tv_sec) +
                           ts.tv_nsec / 100 +
                           hnsecsToUnixEpoch;
                }
            }
            else version (Hurd)
            {
                static if (clockType == ClockType.second)
                    return unixTimeToStdTime(core.stdc.time.time(null));
                else
                {
                    import core.sys.hurd.time : CLOCK_REALTIME_COARSE;
                    import core.sys.posix.time : clock_gettime, CLOCK_REALTIME;
                    static if (clockType == ClockType.coarse)       alias clockArg = CLOCK_REALTIME_COARSE;
                    else static if (clockType == ClockType.normal)  alias clockArg = CLOCK_REALTIME;
                    else static if (clockType == ClockType.precise) alias clockArg = CLOCK_REALTIME;
                    else static assert(0, "Previous static if is wrong.");
                    timespec ts = void;
                    immutable error = clock_gettime(clockArg, &ts);
                    // Posix clock_gettime called with a valid address and valid clock_id is only
                    // permitted to fail if the number of seconds does not fit in time_t. If tv_sec
                    // is long or larger overflow won't happen before 292 billion years A.D.
                    static if (ts.tv_sec.max < long.max)
                    {
                        if (error)
                            throw new TimeException("Call to clock_gettime() failed");
                    }
                    return convert!("seconds", "hnsecs")(ts.tv_sec) +
                           ts.tv_nsec / 100 +
                           hnsecsToUnixEpoch;
                }
            }
            else static assert(0, "Unsupported OS");
        }
        else static assert(0, "Unsupported OS");
    }

    @safe unittest
    {
        import std.format : format;
        import std.math.algebraic : abs;
        import std.meta : AliasSeq;
        enum limit = convert!("seconds", "hnsecs")(2);

        auto norm1 = Clock.currStdTime;
        auto norm2 = Clock.currStdTime;
        assert(norm1 <= norm2, format("%s %s", norm1, norm2));
        assert(abs(norm1 - norm2) <= limit);

        static foreach (ct; AliasSeq!(ClockType.coarse, ClockType.precise, ClockType.second))
        {{
            static if (clockSupported(ct))
            {
                auto value1 = Clock.currStdTime!ct;
                auto value2 = Clock.currStdTime!ct;
                assert(value1 <= value2, format("%s %s (ClockType: %s)", value1, value2, ct));
                assert(abs(value1 - value2) <= limit);
            }
        }}
    }


private:

    @disable this();
}

/// Get the current time as a $(LREF SysTime)
@safe unittest
{
    import std.datetime.timezone : LocalTime;
    SysTime today = Clock.currTime();
    assert(today.timezone is LocalTime());
}


/++
    `SysTime` is the type used to get the current time from the
    system or doing anything that involves time zones. Unlike
    $(REF DateTime,std,datetime,date), the time zone is an integral part of
    `SysTime` (though for local time applications, time zones can be ignored
    and it will work, since it defaults to using the local time zone). It holds
    its internal time in std time (hnsecs since midnight, January 1st, 1 A.D.
    UTC), so it interfaces well with the system time.

    An $(I hnsec) (hecto-nanosecond) is 100 nanoseconds. There are 10,000,000 hnsecs in a second.

$(PANEL
    Unlike $(REF_SHORT DateTime,std,datetime,date), `SysTime` is not optimized for
    calendar-based operations, and getting individual units from it such as
    years or days is going to involve conversions and be less efficient.

    For calendar-based operations that don't
    care about time zones, then $(REF_SHORT DateTime,std,datetime,date) would be
    the type to use. For system time, use `SysTime`.
)
$(P
    Casting a `SysTime` to one of the following types will perform a conversion:
)
    * $(REF Date,std,datetime,date)
    * $(REF_SHORT DateTime,std,datetime,date)
    * $(REF_SHORT TimeOfDay,std,datetime,date)
$(P
    To convert a
    $(REF_SHORT Date,std,datetime,date) or $(REF_SHORT DateTime,std,datetime,date) to a
    `SysTime`, use `SysTime`'s constructor, and pass in the intended time
    zone with it (or don't pass in a $(REF TimeZone,std,datetime,timezone), and
    the local time zone will be used). Be aware, however, that converting from a
    $(REF_SHORT DateTime,std,datetime,date) to a `SysTime` will not necessarily
    be 100% accurate due to DST (one hour of the year doesn't exist and another
    occurs twice). To not risk any conversion errors, keep times as
    `SysTime`s. Aside from DST though, there shouldn't be any conversion
    problems.
)
$(PANEL
    For using time zones other than local time or UTC, use
    $(REF PosixTimeZone,std,datetime,timezone) on Posix systems (or on Windows,
    if providing the TZ Database files), and use
    $(REF WindowsTimeZone,std,datetime,timezone) on Windows systems. The time in
    `SysTime` is kept internally in hnsecs from midnight, January 1st, 1 A.D.
    UTC. Conversion error cannot happen when changing the time zone of a
    `SysTime`. $(REF LocalTime,std,datetime,timezone) is the
    $(REF_SHORT TimeZone,std,datetime,timezone) class which represents the local time,
    and `UTC` is the $(REF_SHORT TimeZone,std,datetime,timezone) class which
    represents UTC. `SysTime` uses $(REF_SHORT LocalTime,std,datetime,timezone) if
    no $(REF_SHORT TimeZone,std,datetime,timezone) is provided. For more details on
    time zones, see the documentation for $(REF_SHORT TimeZone,std,datetime,timezone),
    $(REF_SHORT PosixTimeZone,std,datetime,timezone), and
    $(REF_SHORT WindowsTimeZone,std,datetime,timezone).
)
$(P
    `SysTime`'s range is from approximately 29,000 B.C. to approximately
    29,000 A.D.
)
See_Also:
    $(RELATIVE_LINK2 .Clock.currTime, `Clock.currTime`) will return the current time as a `SysTime`.
  +/
struct SysTime
{
    import core.stdc.time : tm;
    version (Posix) import core.sys.posix.sys.time : timeval;
    import std.typecons : Rebindable;

public:

    /++
        Params:
            dateTime = The $(REF DateTime,std,datetime,date) to use to set
                       this $(LREF SysTime)'s internal std time. As
                       $(REF DateTime,std,datetime,date) has no concept of
                       time zone, tz is used as its time zone.
            tz       = The $(REF TimeZone,std,datetime,timezone) to use for this
                       $(LREF SysTime). If null,
                       $(REF LocalTime,std,datetime,timezone) will be used. The
                       given $(REF DateTime,std,datetime,date) is assumed to
                       be in the given time zone.
      +/
    this(DateTime dateTime, return scope immutable TimeZone tz = null) return scope @safe nothrow
    {
        try
            this(dateTime, Duration.zero, tz);
        catch (Exception e)
            assert(0, "SysTime's constructor threw when it shouldn't have.");
    }

    @safe unittest
    {
        static void test(DateTime dt, immutable TimeZone tz, long expected)
        {
            auto sysTime = SysTime(dt, tz);
            assert(sysTime._stdTime == expected);
            assert(sysTime._timezone is (tz is null ? LocalTime() : tz), format("Given DateTime: %s", dt));
        }

        test(DateTime.init, UTC(), 0);
        test(DateTime(1, 1, 1, 12, 30, 33), UTC(), 450_330_000_000L);
        test(DateTime(0, 12, 31, 12, 30, 33), UTC(), -413_670_000_000L);
        test(DateTime(1, 1, 1, 0, 0, 0), UTC(), 0);
        test(DateTime(1, 1, 1, 0, 0, 1), UTC(), 10_000_000L);
        test(DateTime(0, 12, 31, 23, 59, 59), UTC(), -10_000_000L);

        test(DateTime(1, 1, 1, 0, 0, 0), new immutable SimpleTimeZone(dur!"minutes"(-60)), 36_000_000_000L);
        test(DateTime(1, 1, 1, 0, 0, 0), new immutable SimpleTimeZone(Duration.zero), 0);
        test(DateTime(1, 1, 1, 0, 0, 0), new immutable SimpleTimeZone(dur!"minutes"(60)), -36_000_000_000L);

        static void testScope(scope ref DateTime dt) @safe
        {
            auto st = SysTime(dt);
        }
    }

    /++
        Params:
            dateTime = The $(REF DateTime,std,datetime,date) to use to set
                       this $(LREF SysTime)'s internal std time. As
                       $(REF DateTime,std,datetime,date) has no concept of
                       time zone, tz is used as its time zone.
            fracSecs = The fractional seconds portion of the time.
            tz       = The $(REF TimeZone,std,datetime,timezone) to use for this
                       $(LREF SysTime). If null,
                       $(REF LocalTime,std,datetime,timezone) will be used. The
                       given $(REF DateTime,std,datetime,date) is assumed to
                       be in the given time zone.

        Throws:
            $(REF DateTimeException,std,datetime,date) if `fracSecs` is negative or if it's
            greater than or equal to one second.
      +/
    this(DateTime dateTime, Duration fracSecs, return scope immutable TimeZone tz = null) return scope @safe
    {
        enforce(fracSecs >= Duration.zero, new DateTimeException("A SysTime cannot have negative fractional seconds."));
        enforce(fracSecs < seconds(1), new DateTimeException("Fractional seconds must be less than one second."));
        auto nonNullTZ = tz is null ? LocalTime() : tz;

        immutable dateDiff = dateTime.date - Date.init;
        immutable todDiff = dateTime.timeOfDay - TimeOfDay.init;

        immutable adjustedTime = dateDiff + todDiff + fracSecs;
        immutable standardTime = nonNullTZ.tzToUTC(adjustedTime.total!"hnsecs");

        this(standardTime, nonNullTZ);
    }

    @safe unittest
    {
        import core.time;
        static void test(DateTime dt, Duration fracSecs, immutable TimeZone tz, long expected)
        {
            auto sysTime = SysTime(dt, fracSecs, tz);
            assert(sysTime._stdTime == expected);
            assert(sysTime._timezone is (tz is null ? LocalTime() : tz),
                   format("Given DateTime: %s, Given Duration: %s", dt, fracSecs));
        }

        test(DateTime.init, Duration.zero, UTC(), 0);
        test(DateTime(1, 1, 1, 12, 30, 33), Duration.zero, UTC(), 450_330_000_000L);
        test(DateTime(0, 12, 31, 12, 30, 33), Duration.zero, UTC(), -413_670_000_000L);
        test(DateTime(1, 1, 1, 0, 0, 0), msecs(1), UTC(), 10_000L);
        test(DateTime(0, 12, 31, 23, 59, 59), msecs(999), UTC(), -10_000L);

        test(DateTime(0, 12, 31, 23, 59, 59), hnsecs(9_999_999), UTC(), -1);
        test(DateTime(0, 12, 31, 23, 59, 59), hnsecs(1), UTC(), -9_999_999);
        test(DateTime(0, 12, 31, 23, 59, 59), Duration.zero, UTC(), -10_000_000);

        assertThrown!DateTimeException(SysTime(DateTime.init, hnsecs(-1), UTC()));
        assertThrown!DateTimeException(SysTime(DateTime.init, seconds(1), UTC()));

        static void testScope(scope ref DateTime dt, scope ref Duration d) @safe
        {
            auto st = SysTime(dt, d);
        }
    }

    /++
        Params:
            date = The $(REF Date,std,datetime,date) to use to set this
                   $(LREF SysTime)'s internal std time. As
                   $(REF Date,std,datetime,date) has no concept of time zone, tz
                   is used as its time zone.
            tz   = The $(REF TimeZone,std,datetime,timezone) to use for this
                   $(LREF SysTime). If null,
                   $(REF LocalTime,std,datetime,timezone) will be used. The
                   given $(REF Date,std,datetime,date) is assumed to be in the
                   given time zone.
      +/
    this(Date date, return scope immutable TimeZone tz = null) return scope @safe nothrow
    {
        _timezone = tz is null ? LocalTime() : tz;

        try
        {
            immutable adjustedTime = (date - Date(1, 1, 1)).total!"hnsecs";
            immutable standardTime = _timezone.tzToUTC(adjustedTime);

            this(standardTime, _timezone);
        }
        catch (Exception e)
            assert(0, "Date's constructor through when it shouldn't have.");
    }

    @safe unittest
    {
        static void test(Date d, immutable TimeZone tz, long expected)
        {
            auto sysTime = SysTime(d, tz);
            assert(sysTime._stdTime == expected);
            assert(sysTime._timezone is (tz is null ? LocalTime() : tz), format("Given Date: %s", d));
        }

        test(Date.init, UTC(), 0);
        test(Date(1, 1, 1), UTC(), 0);
        test(Date(1, 1, 2), UTC(), 864000000000);
        test(Date(0, 12, 31), UTC(), -864000000000);

        static void testScope(scope ref Date d) @safe
        {
            auto st = SysTime(d);
        }
    }

    /++
        Note:
            Whereas the other constructors take in the given date/time, assume
            that it's in the given time zone, and convert it to hnsecs in UTC
            since midnight, January 1st, 1 A.D. UTC - i.e. std time - this
            constructor takes a std time, which is specifically already in UTC,
            so no conversion takes place. Of course, the various getter
            properties and functions will use the given time zone's conversion
            function to convert the results to that time zone, but no conversion
            of the arguments to this constructor takes place.

        Params:
            stdTime = The number of hnsecs since midnight, January 1st, 1 A.D.
                      UTC.
            tz      = The $(REF TimeZone,std,datetime,timezone) to use for this
                      $(LREF SysTime). If null,
                      $(REF LocalTime,std,datetime,timezone) will be used.
      +/
    this(long stdTime, return scope immutable TimeZone tz = null) return scope @safe pure nothrow
    {
        _stdTime = stdTime;
        _timezone = tz is null ? LocalTime() : tz;
    }

    @safe unittest
    {
        static void test(long stdTime, immutable TimeZone tz)
        {
            auto sysTime = SysTime(stdTime, tz);
            assert(sysTime._stdTime == stdTime);
            assert(sysTime._timezone is (tz is null ? LocalTime() : tz), format("Given stdTime: %s", stdTime));
        }

        foreach (stdTime; [-1234567890L, -250, 0, 250, 1235657390L])
        {
            foreach (tz; testTZs)
                test(stdTime, tz);
        }
    }


    /++
        Params:
            rhs = The $(LREF SysTime) to assign to this one.

        Returns: The `this` of this `SysTime`.
      +/
    ref SysTime opAssign()(auto ref const(SysTime) rhs) scope return @safe pure nothrow
    {
        _stdTime = rhs._stdTime;
        _timezone = rhs._timezone;
        return this;
    }

    @safe unittest
    {
        SysTime st;
        st = SysTime(DateTime(2012, 12, 21, 1, 2, 3), UTC());
        assert(st == SysTime(DateTime(2012, 12, 21, 1, 2, 3), UTC()));

        const other = SysTime(DateTime(19, 1, 7, 13, 14, 15), LocalTime());
        st = other;
        assert(st == other);

        version (none) // https://issues.dlang.org/show_bug.cgi?id=21175
        static void testScope(scope ref SysTime left, const scope SysTime right) @safe
        {
            left = right;
        }
    }


    /++
        Checks for equality between this $(LREF SysTime) and the given
        $(LREF SysTime).

        Note that the time zone is ignored. Only the internal
        std times (which are in UTC) are compared.
     +/
    bool opEquals()(auto ref const(SysTime) rhs) @safe const pure nothrow scope
    {
        return _stdTime == rhs._stdTime;
    }

    @safe unittest
    {
        import std.range : chain;

        assert(SysTime(DateTime.init, UTC()) == SysTime(0, UTC()));
        assert(SysTime(DateTime.init, UTC()) == SysTime(0));
        assert(SysTime(Date.init, UTC()) == SysTime(0));
        assert(SysTime(0) == SysTime(0));

        static void test(DateTime dt, immutable TimeZone tz1, immutable TimeZone tz2)
        {
            auto st1 = SysTime(dt);
            st1.timezone = tz1;

            auto st2 = SysTime(dt);
            st2.timezone = tz2;

            assert(st1 == st2);
        }

        foreach (tz1; testTZs)
        {
            foreach (tz2; testTZs)
            {
                foreach (dt; chain(testDateTimesBC, testDateTimesAD))
                    test(dt, tz1, tz2);
            }
        }

        auto st = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        const cst = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        assert(st == st);
        assert(st == cst);
        assert(st == ist);
        assert(cst == st);
        assert(cst == cst);
        assert(cst == ist);
        assert(ist == st);
        assert(ist == cst);
        assert(ist == ist);

        static void testScope(scope ref SysTime left, const scope SysTime right) @safe
        {
            assert(left == right);
            assert(right == left);
        }
    }


    /++
        Compares this $(LREF SysTime) with the given $(LREF SysTime).

        Time zone is irrelevant when comparing $(LREF SysTime)s.

        Returns:
            $(BOOKTABLE,
            $(TR $(TD this &lt; rhs) $(TD &lt; 0))
            $(TR $(TD this == rhs) $(TD 0))
            $(TR $(TD this &gt; rhs) $(TD &gt; 0))
            )
     +/
    int opCmp()(auto ref const(SysTime) rhs) @safe const pure nothrow scope
    {
        if (_stdTime < rhs._stdTime)
            return -1;
        if (_stdTime > rhs._stdTime)
            return 1;
        return 0;
    }

    @safe unittest
    {
        import std.algorithm.iteration : map;
        import std.array : array;
        import std.range : chain;

        assert(SysTime(DateTime.init, UTC()).opCmp(SysTime(0, UTC())) == 0);
        assert(SysTime(DateTime.init, UTC()).opCmp(SysTime(0)) == 0);
        assert(SysTime(Date.init, UTC()).opCmp(SysTime(0)) == 0);
        assert(SysTime(0).opCmp(SysTime(0)) == 0);

        static void testEqual(SysTime st, immutable TimeZone tz1, immutable TimeZone tz2)
        {
            auto st1 = st;
            st1.timezone = tz1;

            auto st2 = st;
            st2.timezone = tz2;

            assert(st1.opCmp(st2) == 0);
        }

        auto sts = array(map!SysTime(chain(testDateTimesBC, testDateTimesAD)));

        foreach (st; sts)
        {
            foreach (tz1; testTZs)
            {
                foreach (tz2; testTZs)
                    testEqual(st, tz1, tz2);
            }
        }

        static void testCmp(SysTime st1, immutable TimeZone tz1, SysTime st2, immutable TimeZone tz2)
        {
            st1.timezone = tz1;
            st2.timezone = tz2;
            assert(st1.opCmp(st2) < 0);
            assert(st2.opCmp(st1) > 0);
        }

        foreach (si, st1; sts)
        {
            foreach (st2; sts[si + 1 .. $])
            {
                foreach (tz1; testTZs)
                {
                    foreach (tz2; testTZs)
                        testCmp(st1, tz1, st2, tz2);
                }
            }
        }

        auto st = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        const cst = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 33, 30));
        assert(st.opCmp(st) == 0);
        assert(st.opCmp(cst) == 0);
        assert(st.opCmp(ist) == 0);
        assert(cst.opCmp(st) == 0);
        assert(cst.opCmp(cst) == 0);
        assert(cst.opCmp(ist) == 0);
        assert(ist.opCmp(st) == 0);
        assert(ist.opCmp(cst) == 0);
        assert(ist.opCmp(ist) == 0);

        static void testScope(scope ref SysTime left, const scope SysTime right) @safe
        {
            assert(left < right);
            assert(right > left);
        }
    }


    /++
        Returns: A hash of the $(LREF SysTime).
     +/
    size_t toHash() const @nogc pure nothrow @safe scope
    {
        static if (is(size_t == ulong))
            return _stdTime;
        else
        {
            // MurmurHash2
            enum ulong m = 0xc6a4a7935bd1e995UL;
            enum ulong n = m * 16;
            enum uint r = 47;

            ulong k = _stdTime;
            k *= m;
            k ^= k >> r;
            k *= m;

            ulong h = n;
            h ^= k;
            h *= m;

            return cast(size_t) h;
        }
    }

    @safe unittest
    {
        assert(SysTime(0).toHash == SysTime(0).toHash);
        assert(SysTime(DateTime(2000, 1, 1)).toHash == SysTime(DateTime(2000, 1, 1)).toHash);
        assert(SysTime(DateTime(2000, 1, 1)).toHash != SysTime(DateTime(2000, 1, 2)).toHash);

        // test that timezones aren't taken into account
        assert(SysTime(0, LocalTime()).toHash == SysTime(0, LocalTime()).toHash);
        assert(SysTime(0, LocalTime()).toHash == SysTime(0, UTC()).toHash);
        assert(SysTime(DateTime(2000, 1, 1), LocalTime()).toHash == SysTime(DateTime(2000, 1, 1), LocalTime()).toHash);
        immutable zone = new SimpleTimeZone(dur!"minutes"(60));
        assert(SysTime(DateTime(2000, 1, 1, 1), zone).toHash == SysTime(DateTime(2000, 1, 1), UTC()).toHash);
        assert(SysTime(DateTime(2000, 1, 1), zone).toHash != SysTime(DateTime(2000, 1, 1), UTC()).toHash);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.toHash();
        }
    }


    /++
        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.
     +/
    @property short year() @safe const nothrow scope
    {
        return (cast(Date) this).year;
    }

    @safe unittest
    {
        import std.range : chain;
        static void test(SysTime sysTime, long expected)
        {
            assert(sysTime.year == expected, format("Value given: %s", sysTime));
        }

        test(SysTime(0, UTC()), 1);
        test(SysTime(1, UTC()), 1);
        test(SysTime(-1, UTC()), 0);

        foreach (year; chain(testYearsBC, testYearsAD))
        {
            foreach (md; testMonthDays)
            {
                foreach (tod; testTODs)
                {
                    auto dt = DateTime(Date(year, md.month, md.day), tod);
                    foreach (tz; testTZs)
                    {
                        foreach (fs; testFracSecs)
                            test(SysTime(dt, fs, tz), year);
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        assert(cst.year == 1999);
        assert(ist.year == 1999);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.year;
        }
    }

    /++
        Year of the Gregorian Calendar. Positive numbers are A.D. Non-positive
        are B.C.

        Params:
            year = The year to set this $(LREF SysTime)'s year to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if the new year is not
            a leap year and the resulting date would be on February 29th.
     +/
    @property void year(int year) @safe scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        auto date = Date(cast(int) days);
        date.year = year;

        immutable newDaysHNSecs = convert!("days", "hnsecs")(date.dayOfGregorianCal - 1);
        adjTime = newDaysHNSecs + hnsecs;
    }

    ///
    @safe unittest
    {
        import std.datetime.date : DateTime;

        assert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).year == 1999);
        assert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).year == 2010);
        assert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).year == -7);
    }

    @safe unittest
    {
        import std.range : chain;

        static void test(SysTime st, int year, SysTime expected)
        {
            st.year = year;
            assert(st == expected);
        }

        foreach (st; chain(testSysTimesBC, testSysTimesAD))
        {
            auto dt = cast(DateTime) st;

            foreach (year; chain(testYearsBC, testYearsAD))
            {
                auto e = SysTime(DateTime(year, dt.month, dt.day, dt.hour, dt.minute, dt.second),
                                 st.fracSecs,
                                 st.timezone);
                test(st, year, e);
            }
        }

        foreach (fs; testFracSecs)
        {
            foreach (tz; testTZs)
            {
                foreach (tod; testTODs)
                {
                    test(SysTime(DateTime(Date(1999, 2, 28), tod), fs, tz), 2000,
                         SysTime(DateTime(Date(2000, 2, 28), tod), fs, tz));
                    test(SysTime(DateTime(Date(2000, 2, 28), tod), fs, tz), 1999,
                         SysTime(DateTime(Date(1999, 2, 28), tod), fs, tz));
                }

                foreach (tod; testTODsThrown)
                {
                    auto st = SysTime(DateTime(Date(2000, 2, 29), tod), fs, tz);
                    assertThrown!DateTimeException(st.year = 1999);
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        static assert(!__traits(compiles, cst.year = 7));
        static assert(!__traits(compiles, ist.year = 7));

        static void testScope(scope ref SysTime st) @safe
        {
            st.year = 42;
        }
    }

    /++
        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.

        Throws:
            $(REF DateTimeException,std,datetime,date) if `isAD` is true.
     +/
    @property ushort yearBC() @safe const scope
    {
        return (cast(Date) this).yearBC;
    }

    ///
    @safe unittest
    {
        import std.datetime.date : DateTime;

        assert(SysTime(DateTime(0, 1, 1, 12, 30, 33)).yearBC == 1);
        assert(SysTime(DateTime(-1, 1, 1, 10, 7, 2)).yearBC == 2);
        assert(SysTime(DateTime(-100, 1, 1, 4, 59, 0)).yearBC == 101);
    }

    @safe unittest
    {
        import std.exception : assertNotThrown;
        foreach (st; testSysTimesBC)
        {
            auto msg = format("SysTime: %s", st);
            assertNotThrown!DateTimeException(st.yearBC, msg);
            assert(st.yearBC == (st.year * -1) + 1, msg);
        }

        foreach (st; [testSysTimesAD[0], testSysTimesAD[$/2], testSysTimesAD[$-1]])
            assertThrown!DateTimeException(st.yearBC, format("SysTime: %s", st));

        auto st = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        st.year = 12;
        assert(st.year == 12);
        static assert(!__traits(compiles, cst.year = 12));
        static assert(!__traits(compiles, ist.year = 12));

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.yearBC;
        }
    }


    /++
        Year B.C. of the Gregorian Calendar counting year 0 as 1 B.C.

        Params:
            year = The year B.C. to set this $(LREF SysTime)'s year to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if a non-positive value
            is given.
     +/
    @property void yearBC(int year) @safe scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        auto date = Date(cast(int) days);
        date.yearBC = year;

        immutable newDaysHNSecs = convert!("days", "hnsecs")(date.dayOfGregorianCal - 1);
        adjTime = newDaysHNSecs + hnsecs;
    }

    @safe unittest
    {
        auto st = SysTime(DateTime(2010, 1, 1, 7, 30, 0));
        st.yearBC = 1;
        assert(st == SysTime(DateTime(0, 1, 1, 7, 30, 0)));

        st.yearBC = 10;
        assert(st == SysTime(DateTime(-9, 1, 1, 7, 30, 0)));
    }

    @safe unittest
    {
        import std.range : chain;
        static void test(SysTime st, int year, SysTime expected)
        {
            st.yearBC = year;
            assert(st == expected, format("SysTime: %s", st));
        }

        foreach (st; chain(testSysTimesBC, testSysTimesAD))
        {
            auto dt = cast(DateTime) st;

            foreach (year; testYearsBC)
            {
                auto e = SysTime(DateTime(year, dt.month, dt.day, dt.hour, dt.minute, dt.second),
                                 st.fracSecs,
                                 st.timezone);
                test(st, (year * -1) + 1, e);
            }
        }

        foreach (st; [testSysTimesBC[0], testSysTimesBC[$ - 1], testSysTimesAD[0], testSysTimesAD[$ - 1]])
        {
            foreach (year; testYearsBC)
                assertThrown!DateTimeException(st.yearBC = year);
        }

        foreach (fs; testFracSecs)
        {
            foreach (tz; testTZs)
            {
                foreach (tod; testTODs)
                {
                    test(SysTime(DateTime(Date(-1999, 2, 28), tod), fs, tz), 2001,
                         SysTime(DateTime(Date(-2000, 2, 28), tod), fs, tz));
                    test(SysTime(DateTime(Date(-2000, 2, 28), tod), fs, tz), 2000,
                         SysTime(DateTime(Date(-1999, 2, 28), tod), fs, tz));
                }

                foreach (tod; testTODsThrown)
                {
                    auto st = SysTime(DateTime(Date(-2000, 2, 29), tod), fs, tz);
                    assertThrown!DateTimeException(st.year = -1999);
                }
            }
        }

        auto st = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        st.yearBC = 12;
        assert(st.yearBC == 12);
        static assert(!__traits(compiles, cst.yearBC = 12));
        static assert(!__traits(compiles, ist.yearBC = 12));

        static void testScope(scope ref SysTime st) @safe
        {
            st.yearBC = 42;
        }
    }


    /++
        Month of a Gregorian Year.
     +/
    @property Month month() @safe const nothrow scope
    {
        return (cast(Date) this).month;
    }

    ///
    @safe unittest
    {
        import std.datetime.date : DateTime;

        assert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).month == 7);
        assert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).month == 10);
        assert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).month == 4);
    }

    @safe unittest
    {
        import std.range : chain;

        static void test(SysTime sysTime, Month expected)
        {
            assert(sysTime.month == expected, format("Value given: %s", sysTime));
        }

        test(SysTime(0, UTC()), Month.jan);
        test(SysTime(1, UTC()), Month.jan);
        test(SysTime(-1, UTC()), Month.dec);

        foreach (year; chain(testYearsBC, testYearsAD))
        {
            foreach (md; testMonthDays)
            {
                foreach (tod; testTODs)
                {
                    auto dt = DateTime(Date(year, md.month, md.day), tod);
                    foreach (fs; testFracSecs)
                    {
                        foreach (tz; testTZs)
                            test(SysTime(dt, fs, tz), md.month);
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        assert(cst.month == 7);
        assert(ist.month == 7);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.month;
        }
    }


    /++
        Month of a Gregorian Year.

        Params:
            month = The month to set this $(LREF SysTime)'s month to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if the given month is
            not a valid month.
     +/
    @property void month(Month month) @safe scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        auto date = Date(cast(int) days);
        date.month = month;

        immutable newDaysHNSecs = convert!("days", "hnsecs")(date.dayOfGregorianCal - 1);
        adjTime = newDaysHNSecs + hnsecs;
    }

    @safe unittest
    {
        import std.algorithm.iteration : filter;
        import std.range : chain;

        static void test(SysTime st, Month month, SysTime expected)
        {
            st.month = cast(Month) month;
            assert(st == expected);
        }

        foreach (st; chain(testSysTimesBC, testSysTimesAD))
        {
            auto dt = cast(DateTime) st;

            foreach (md; testMonthDays)
            {
                if (st.day > maxDay(dt.year, md.month))
                    continue;
                auto e = SysTime(DateTime(dt.year, md.month, dt.day, dt.hour, dt.minute, dt.second),
                                 st.fracSecs,
                                 st.timezone);
                test(st, md.month, e);
            }
        }

        foreach (fs; testFracSecs)
        {
            foreach (tz; testTZs)
            {
                foreach (tod; testTODs)
                {
                    foreach (year; filter!((a){return yearIsLeapYear(a);}) (chain(testYearsBC, testYearsAD)))
                    {
                        test(SysTime(DateTime(Date(year, 1, 29), tod), fs, tz),
                             Month.feb,
                             SysTime(DateTime(Date(year, 2, 29), tod), fs, tz));
                    }

                    foreach (year; chain(testYearsBC, testYearsAD))
                    {
                        test(SysTime(DateTime(Date(year, 1, 28), tod), fs, tz),
                             Month.feb,
                             SysTime(DateTime(Date(year, 2, 28), tod), fs, tz));
                        test(SysTime(DateTime(Date(year, 7, 30), tod), fs, tz),
                             Month.jun,
                             SysTime(DateTime(Date(year, 6, 30), tod), fs, tz));
                    }
                }
            }
        }

        foreach (fs; [testFracSecs[0], testFracSecs[$-1]])
        {
            foreach (tz; testTZs)
            {
                foreach (tod; testTODsThrown)
                {
                    foreach (year; [testYearsBC[$-3], testYearsBC[$-2],
                                    testYearsBC[$-2], testYearsAD[0],
                                    testYearsAD[$-2], testYearsAD[$-1]])
                    {
                        auto day = yearIsLeapYear(year) ? 30 : 29;
                        auto st1 = SysTime(DateTime(Date(year, 1, day), tod), fs, tz);
                        assertThrown!DateTimeException(st1.month = Month.feb);

                        auto st2 = SysTime(DateTime(Date(year, 7, 31), tod), fs, tz);
                        assertThrown!DateTimeException(st2.month = Month.jun);
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        static assert(!__traits(compiles, cst.month = Month.dec));
        static assert(!__traits(compiles, ist.month = Month.dec));

        static void testScope(scope ref SysTime st) @safe
        {
            st.month = Month.dec;
        }
    }

    /++
        Day of a Gregorian Month.
     +/
    @property ubyte day() @safe const nothrow scope
    {
        return (cast(Date) this).day;
    }

    ///
    @safe unittest
    {
        import std.datetime.date : DateTime;

        assert(SysTime(DateTime(1999, 7, 6, 9, 7, 5)).day == 6);
        assert(SysTime(DateTime(2010, 10, 4, 0, 0, 30)).day == 4);
        assert(SysTime(DateTime(-7, 4, 5, 7, 45, 2)).day == 5);
    }

    @safe unittest
    {
        import std.range : chain;

        static void test(SysTime sysTime, int expected)
        {
            assert(sysTime.day == expected, format("Value given: %s", sysTime));
        }

        test(SysTime(0, UTC()), 1);
        test(SysTime(1, UTC()), 1);
        test(SysTime(-1, UTC()), 31);

        foreach (year; chain(testYearsBC, testYearsAD))
        {
            foreach (md; testMonthDays)
            {
                foreach (tod; testTODs)
                {
                    auto dt = DateTime(Date(year, md.month, md.day), tod);

                    foreach (tz; testTZs)
                    {
                        foreach (fs; testFracSecs)
                            test(SysTime(dt, fs, tz), md.day);
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
         assert(cst.day == 6);
        assert(ist.day == 6);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.day;
        }
    }


    /++
        Day of a Gregorian Month.

        Params:
            day = The day of the month to set this $(LREF SysTime)'s day to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if the given day is not
            a valid day of the current month.
     +/
    @property void day(int day) @safe scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        auto date = Date(cast(int) days);
        date.day = day;

        immutable newDaysHNSecs = convert!("days", "hnsecs")(date.dayOfGregorianCal - 1);
        adjTime = newDaysHNSecs + hnsecs;
    }

    @safe unittest
    {
        import std.range : chain;
        import std.traits : EnumMembers;

        foreach (day; chain(testDays))
        {
            foreach (st; chain(testSysTimesBC, testSysTimesAD))
            {
                auto dt = cast(DateTime) st;

                if (day > maxDay(dt.year, dt.month))
                    continue;
                auto expected = SysTime(DateTime(dt.year, dt.month, day, dt.hour, dt.minute, dt.second),
                                        st.fracSecs,
                                        st.timezone);
                st.day = day;
                assert(st == expected, format("[%s] [%s]", st, expected));
            }
        }

        foreach (tz; testTZs)
        {
            foreach (tod; testTODs)
            {
                foreach (fs; testFracSecs)
                {
                    foreach (year; chain(testYearsBC, testYearsAD))
                    {
                        foreach (month; EnumMembers!Month)
                        {
                            auto st = SysTime(DateTime(Date(year, month, 1), tod), fs, tz);
                            immutable max = maxDay(year, month);
                            auto expected = SysTime(DateTime(Date(year, month, max), tod), fs, tz);

                            st.day = max;
                            assert(st == expected, format("[%s] [%s]", st, expected));
                        }
                    }
                }
            }
        }

        foreach (tz; testTZs)
        {
            foreach (tod; testTODsThrown)
            {
                foreach (fs; [testFracSecs[0], testFracSecs[$-1]])
                {
                    foreach (year; [testYearsBC[$-3], testYearsBC[$-2],
                                    testYearsBC[$-2], testYearsAD[0],
                                    testYearsAD[$-2], testYearsAD[$-1]])
                    {
                        foreach (month; EnumMembers!Month)
                        {
                            auto st = SysTime(DateTime(Date(year, month, 1), tod), fs, tz);
                            immutable max = maxDay(year, month);

                            assertThrown!DateTimeException(st.day = max + 1);
                        }
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        static assert(!__traits(compiles, cst.day = 27));
        static assert(!__traits(compiles, ist.day = 27));

        static void testScope(scope ref SysTime st) @safe
        {
            st.day = 12;
        }
    }


    /++
        Hours past midnight.
     +/
    @property ubyte hour() @safe const nothrow scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        return cast(ubyte) getUnitsFromHNSecs!"hours"(hnsecs);
    }

    @safe unittest
    {
        import std.range : chain;

        static void test(SysTime sysTime, int expected)
        {
            assert(sysTime.hour == expected, format("Value given: %s", sysTime));
        }

        test(SysTime(0, UTC()), 0);
        test(SysTime(1, UTC()), 0);
        test(SysTime(-1, UTC()), 23);

        foreach (tz; testTZs)
        {
            foreach (year; chain(testYearsBC, testYearsAD))
            {
                foreach (md; testMonthDays)
                {
                    foreach (hour; testHours)
                    {
                        foreach (minute; testMinSecs)
                        {
                            foreach (second; testMinSecs)
                            {
                                auto dt = DateTime(Date(year, md.month, md.day), TimeOfDay(hour, minute, second));
                                foreach (fs; testFracSecs)
                                    test(SysTime(dt, fs, tz), hour);
                            }
                        }
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        assert(cst.hour == 12);
        assert(ist.hour == 12);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.hour;
        }
    }


    /++
        Hours past midnight.

        Params:
            hour = The hours to set this $(LREF SysTime)'s hour to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if the given hour are
            not a valid hour of the day.
     +/
    @property void hour(int hour) @safe scope
    {
        enforceValid!"hours"(hour);

        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs);
        immutable daysHNSecs = convert!("days", "hnsecs")(days);
        immutable negative = hnsecs < 0;

        if (negative)
            hnsecs += convert!("hours", "hnsecs")(24);

        hnsecs = removeUnitsFromHNSecs!"hours"(hnsecs);
        hnsecs += convert!("hours", "hnsecs")(hour);

        if (negative)
            hnsecs -= convert!("hours", "hnsecs")(24);

        adjTime = daysHNSecs + hnsecs;
    }

    @safe unittest
    {
        import std.range : chain;

        foreach (hour; chain(testHours))
        {
            foreach (st; chain(testSysTimesBC, testSysTimesAD))
            {
                auto dt = cast(DateTime) st;
                auto expected = SysTime(DateTime(dt.year, dt.month, dt.day, hour, dt.minute, dt.second),
                                        st.fracSecs,
                                        st.timezone);
                st.hour = hour;
                assert(st == expected, format("[%s] [%s]", st, expected));
            }
        }

        auto st = testSysTimesAD[0];
        assertThrown!DateTimeException(st.hour = -1);
        assertThrown!DateTimeException(st.hour = 60);

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        static assert(!__traits(compiles, cst.hour = 27));
        static assert(!__traits(compiles, ist.hour = 27));

        static void testScope(scope ref SysTime st) @safe
        {
            st.hour = 12;
        }
    }


    /++
        Minutes past the current hour.
     +/
    @property ubyte minute() @safe const nothrow scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        hnsecs = removeUnitsFromHNSecs!"hours"(hnsecs);

        return cast(ubyte) getUnitsFromHNSecs!"minutes"(hnsecs);
    }

    @safe unittest
    {
        import std.range : chain;

        static void test(SysTime sysTime, int expected)
        {
            assert(sysTime.minute == expected, format("Value given: %s", sysTime));
        }

        test(SysTime(0, UTC()), 0);
        test(SysTime(1, UTC()), 0);
        test(SysTime(-1, UTC()), 59);

        foreach (tz; testTZs)
        {
            foreach (year; chain(testYearsBC, testYearsAD))
            {
                foreach (md; testMonthDays)
                {
                    foreach (hour; testHours)
                    {
                        foreach (minute; testMinSecs)
                        {
                            foreach (second; testMinSecs)
                            {
                                auto dt = DateTime(Date(year, md.month, md.day), TimeOfDay(hour, minute, second));
                                foreach (fs; testFracSecs)
                                    test(SysTime(dt, fs, tz), minute);
                            }
                        }
                    }
                }
            }
        }

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        assert(cst.minute == 30);
        assert(ist.minute == 30);

        static void testScope(scope ref SysTime st) @safe
        {
            auto result = st.minute;
        }
    }


    /++
        Minutes past the current hour.

        Params:
            minute = The minute to set this $(LREF SysTime)'s minute to.

        Throws:
            $(REF DateTimeException,std,datetime,date) if the given minute are
            not a valid minute of an hour.
     +/
    @property void minute(int minute) @safe scope
    {
        enforceValid!"minutes"(minute);

        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs);
        immutable daysHNSecs = convert!("days", "hnsecs")(days);
        immutable negative = hnsecs < 0;

        if (negative)
            hnsecs += convert!("hours", "hnsecs")(24);

        immutable hour = splitUnitsFromHNSecs!"hours"(hnsecs);
        hnsecs = removeUnitsFromHNSecs!"minutes"(hnsecs);

        hnsecs += convert!("hours", "hnsecs")(hour);
        hnsecs += convert!("minutes", "hnsecs")(minute);

        if (negative)
            hnsecs -= convert!("hours", "hnsecs")(24);

        adjTime = daysHNSecs + hnsecs;
    }

    @safe unittest
    {
        import std.range : chain;

        foreach (minute; testMinSecs)
        {
            foreach (st; chain(testSysTimesBC, testSysTimesAD))
            {
                auto dt = cast(DateTime) st;
                auto expected = SysTime(DateTime(dt.year, dt.month, dt.day, dt.hour, minute, dt.second),
                                        st.fracSecs,
                                        st.timezone);
                st.minute = minute;
                assert(st == expected, format("[%s] [%s]", st, expected));
            }
        }

        auto st = testSysTimesAD[0];
        assertThrown!DateTimeException(st.minute = -1);
        assertThrown!DateTimeException(st.minute = 60);

        const cst = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        immutable ist = SysTime(DateTime(1999, 7, 6, 12, 30, 33));
        static assert(!__traits(compiles, cst.minute = 27));
        static assert(!__traits(compiles, ist.minute = 27));

        static void testScope(scope ref SysTime st) @safe
        {
            st.minute = 12;
        }
    }


    /++
        Seconds past the current minute.
     +/
    @property ubyte second() @safe const nothrow scope
    {
        auto hnsecs = adjTime;
        auto days = splitUnitsFromHNSecs!"days"(hnsecs) + 1;

        if (hnsecs < 0)
        {
            hnsecs += convert!("hours", "hnsecs")(24);
            --days;
        }

        hnsecs = removeUnitsFromHNSecs!"hours"(hnsecs);
        hnsecs = removeUnitsFromHNSecs!"minutes"(hnsecs);

        return cast(ubyte) getUnitsFromHN// Written in the D programming language

/++

$(SCRIPT inhibitQuickIndex = 1;)
$(DIVC quickindex,
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD Time zones) $(TD
    $(LREF TimeZone)
    $(LREF UTC)
    $(LREF LocalTime)
    $(LREF PosixTimeZone)
    $(LREF WindowsTimeZone)
    $(LREF SimpleTimeZone)
))
$(TR $(TD Utilities) $(TD
    $(LREF clearTZEnvVar)
    $(LREF parseTZConversions)
    $(LREF setTZEnvVar)
    $(LREF TZConversions)
))
))

    License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
    Authors:   $(HTTP jmdavisprog.com, Jonathan M Davis)
    Source:    $(PHOBOSSRC std/datetime/timezone.d)
+/
module std.datetime.timezone;

import core.time : abs, convert, dur, Duration, hours, minutes;
import std.datetime.systime : Clock, stdTimeToUnixTime, SysTime;
import std.range.primitives : back, empty, front, isOutputRange, popFront;
import std.traits : isIntegral, isSomeString;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Windows)
{
    import core.stdc.time : time_t;
    import core.sys.windows.winbase;
    import core.sys.windows.winsock2;
    import std.windows.registry;

    // Uncomment and run unittests to print missing Windows TZ translations.
    // Please subscribe to Microsoft Daylight Saving Time & Time Zone Blog
    // (https://blogs.technet.microsoft.com/dst2007/) if you feel responsible
    // for updating the translations.
    // version = UpdateWindowsTZTranslations;
}
else version (Posix)
{
    import core.sys.posix.signal : timespec;
    import core.sys.posix.sys.types : time_t;
}

version (StdUnittest) import std.exception : assertThrown;


/++
    Represents a time zone. It is used with $(REF SysTime,std,datetime,systime)
    to indicate the time zone of a $(REF SysTime,std,datetime,systime).
  +/
abstract class TimeZone
{
public:

    /++
        The name of the time zone. Exactly how the time zone name is formatted
        depends on the derived class. In the case of $(LREF PosixTimeZone), it's
        the TZ Database name, whereas with $(LREF WindowsTimeZone), it's the
        name that Windows chose to give the registry key for that time zone
        (typically the name that they give $(LREF stdTime) if the OS is in
        English). For other time zone types, what it is depends on how they're
        implemented.

        See_Also:
            $(HTTP en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ
              Database)<br>
            $(HTTP en.wikipedia.org/wiki/List_of_tz_database_time_zones, List of
              Time Zones)
      +/
    @property string name() @safe const nothrow
    {
        return _name;
    }


    /++
        Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.

        However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Standard Time). Regardless, it is not the same as name.
      +/
    @property string stdName() @safe const scope nothrow
    {
        return _stdName;
    }


    /++
        Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.

        However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Daylight Time). Regardless, it is not the same as name.
      +/
    @property string dstName() @safe const scope nothrow
    {
        return _dstName;
    }


    /++
        Whether this time zone has Daylight Savings Time at any point in time.
        Note that for some time zone types it may not have DST for current dates
        but will still return true for `hasDST` because the time zone did at
        some point have DST.
      +/
    @property abstract bool hasDST() @safe const nothrow;


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and returns whether DST is effect in this
        time zone at the given point in time.

        Params:
            stdTime = The UTC time that needs to be checked for DST in this time
                      zone.
      +/
    abstract bool dstInEffect(long stdTime) @safe const scope nothrow;


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and converts it to this time zone's time.

        Params:
            stdTime = The UTC time that needs to be adjusted to this time zone's
                      time.
      +/
    abstract long utcToTZ(long stdTime) @safe const scope nothrow;


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in this time zone's time and converts it to UTC (i.e. std time).

        Params:
            adjTime = The time in this time zone that needs to be adjusted to
                      UTC time.
      +/
    abstract long tzToUTC(long adjTime) @safe const scope nothrow;


    /++
        Returns what the offset from UTC is at the given std time.
        It includes the DST offset in effect at that time (if any).

        Params:
            stdTime = The UTC time for which to get the offset from UTC for this
                      time zone.
      +/
    Duration utcOffsetAt(long stdTime) @safe const scope nothrow
    {
        return dur!"hnsecs"(utcToTZ(stdTime) - stdTime);
    }

    // The purpose of this is to handle the case where a Windows time zone is
    // new and exists on an up-to-date Windows box but does not exist on Windows
    // boxes which have not been properly updated. The "date added" is included
    // on the theory that we'll be able to remove them at some point in the
    // the future once enough time has passed, and that way, we know how much
    // time has passed.
    private static string _getOldName(string windowsTZName) @safe pure nothrow
    {
        switch (windowsTZName)
        {
            case "Belarus Standard Time": return "Kaliningrad Standard Time"; // Added 2014-10-08
            case "Russia Time Zone 10": return "Magadan Standard Time"; // Added 2014-10-08
            case "Russia Time Zone 11": return "Magadan Standard Time"; // Added 2014-10-08
            case "Russia Time Zone 3": return "Russian Standard Time"; // Added 2014-10-08
            default: return null;
        }
    }

    // Since reading in the time zone files could be expensive, most unit tests
    // are consolidated into this one unittest block which minimizes how often
    // it reads a time zone file.
    @system unittest
    {
        import core.exception : AssertError;
        import std.conv : to;
        import std.file : exists, isFile;
        import std.format : format;
        import std.path : chainPath;
        import std.stdio : writefln;
        import std.typecons : tuple;

        version (Posix) alias getTimeZone = PosixTimeZone.getTimeZone;
        else version (Windows) alias getTimeZone = WindowsTimeZone.getTimeZone;

        version (Posix) scope(exit) clearTZEnvVar();

        static immutable(TimeZone) testTZ(string tzName,
                                          string stdName,
                                          string dstName,
                                          Duration utcOffset,
                                          Duration dstOffset,
                                          bool north = true)
        {
            scope(failure) writefln("Failed time zone: %s", tzName);

            version (Posix)
            {
                immutable tz = PosixTimeZone.getTimeZone(tzName);
                assert(tz.name == tzName);
            }
            else version (Windows)
            {
                immutable tz = WindowsTimeZone.getTimeZone(tzName);
                assert(tz.name == stdName);
            }

            immutable hasDST = dstOffset != Duration.zero;

            //assert(tz.stdName == stdName);  //Locale-dependent
            //assert(tz.dstName == dstName);  //Locale-dependent
            assert(tz.hasDST == hasDST);

            import std.datetime.date : DateTime;
            immutable stdDate = DateTime(2010, north ? 1 : 7, 1, 6, 0, 0);
            immutable dstDate = DateTime(2010, north ? 7 : 1, 1, 6, 0, 0);
            auto std = SysTime(stdDate, tz);
            auto dst = SysTime(dstDate, tz);
            auto stdUTC = SysTime(stdDate - utcOffset, UTC());
            auto dstUTC = SysTime(stdDate - utcOffset + dstOffset, UTC());

            assert(!std.dstInEffect);
            assert(dst.dstInEffect == hasDST);
            assert(tz.utcOffsetAt(std.stdTime) == utcOffset);
            assert(tz.utcOffsetAt(dst.stdTime) == utcOffset + dstOffset);

            assert(cast(DateTime) std == stdDate);
            assert(cast(DateTime) dst == dstDate);
            assert(std == stdUTC);

            version (Posix)
            {
                setTZEnvVar(tzName);

                static void testTM(scope const SysTime st)
                {
                    import core.stdc.time : tm;
                    import core.sys.posix.time : localtime_r;

                    time_t unixTime = st.toUnixTime();
                    tm osTimeInfo = void;
                    localtime_r(&unixTime, &osTimeInfo);
                    tm ourTimeInfo = st.toTM();

                    assert(ourTimeInfo.tm_sec == osTimeInfo.tm_sec);
                    assert(ourTimeInfo.tm_min == osTimeInfo.tm_min);
                    assert(ourTimeInfo.tm_hour == osTimeInfo.tm_hour);
                    assert(ourTimeInfo.tm_mday == osTimeInfo.tm_mday);
                    assert(ourTimeInfo.tm_mon == osTimeInfo.tm_mon);
                    assert(ourTimeInfo.tm_year == osTimeInfo.tm_year);
                    assert(ourTimeInfo.tm_wday == osTimeInfo.tm_wday);
                    assert(ourTimeInfo.tm_yday == osTimeInfo.tm_yday);
                    assert(ourTimeInfo.tm_isdst == osTimeInfo.tm_isdst);
                    assert(ourTimeInfo.tm_gmtoff == osTimeInfo.tm_gmtoff);
                    assert(to!string(ourTimeInfo.tm_zone) == to!string(osTimeInfo.tm_zone));
                }

                testTM(std);
                testTM(dst);

                // Apparently, right/ does not exist on Mac OS X. I don't know
                // whether or not it exists on FreeBSD. It's rather pointless
                // normally, since the Posix standard requires that leap seconds
                // be ignored, so it does make some sense that right/ wouldn't
                // be there, but since PosixTimeZone _does_ use leap seconds if
                // the time zone file does, we'll test that functionality if the
                // appropriate files exist.
                if (chainPath(PosixTimeZone.defaultTZDatabaseDir, "right", tzName).exists)
                {
                    auto leapTZ = PosixTimeZone.getTimeZone("right/" ~ tzName);

                    assert(leapTZ.name == "right/" ~ tzName);
                    //assert(leapTZ.stdName == stdName);  //Locale-dependent
                    //assert(leapTZ.dstName == dstName);  //Locale-dependent
                    assert(leapTZ.hasDST == hasDST);

                    auto leapSTD = SysTime(std.stdTime, leapTZ);
                    auto leapDST = SysTime(dst.stdTime, leapTZ);

                    assert(!leapSTD.dstInEffect);
                    assert(leapDST.dstInEffect == hasDST);

                    assert(leapSTD.stdTime == std.stdTime);
                    assert(leapDST.stdTime == dst.stdTime);

                    // Whenever a leap second is added/removed,
                    // this will have to be adjusted.
                    //enum leapDiff = convert!("seconds", "hnsecs")(25);
                    //assert(leapSTD.adjTime - leapDiff == std.adjTime);
                    //assert(leapDST.adjTime - leapDiff == dst.adjTime);
                }
            }

            return tz;
        }

        import std.datetime.date : DateTime;
        auto dstSwitches = [/+America/Los_Angeles+/ tuple(DateTime(2012, 3, 11),  DateTime(2012, 11, 4), 2, 2),
                            /+America/New_York+/    tuple(DateTime(2012, 3, 11),  DateTime(2012, 11, 4), 2, 2),
                            ///+America/Santiago+/    tuple(DateTime(2011, 8, 21),  DateTime(2011, 5, 8), 0, 0),
                            /+Europe/London+/       tuple(DateTime(2012, 3, 25),  DateTime(2012, 10, 28), 1, 2),
                            /+Europe/Paris+/        tuple(DateTime(2012, 3, 25),  DateTime(2012, 10, 28), 2, 3),
                            /+Australia/Adelaide+/  tuple(DateTime(2012, 10, 7),  DateTime(2012, 4, 1), 2, 3)];

        import std.datetime.date : DateTimeException;
        version (Posix)
        {
            version (FreeBSD)            enum utcZone = "Etc/UTC";
            else version (OpenBSD)       enum utcZone = "UTC";
            else version (NetBSD)        enum utcZone = "UTC";
            else version (DragonFlyBSD)  enum utcZone = "UTC";
            else version (linux)         enum utcZone = "UTC";
            else version (Darwin)        enum utcZone = "UTC";
            else version (Solaris)       enum utcZone = "UTC";
            else static assert(0, "The location of the UTC timezone file on this Posix platform must be set.");

            auto tzs = [testTZ("America/Los_Angeles", "PST", "PDT", dur!"hours"(-8), dur!"hours"(1)),
                        testTZ("America/New_York", "EST", "EDT", dur!"hours"(-5), dur!"hours"(1)),
                        //testTZ("America/Santiago", "CLT", "CLST", dur!"hours"(-4), dur!"hours"(1), false),
                        testTZ("Europe/London", "GMT", "BST", dur!"hours"(0), dur!"hours"(1)),
                        testTZ("Europe/Paris", "CET", "CEST", dur!"hours"(1), dur!"hours"(1)),
                        // Per www.timeanddate.com, it should be "CST" and "CDT",
                        // but the OS insists that it's "CST" for both. We should
                        // probably figure out how to report an error in the TZ
                        // database and report it.
                        testTZ("Australia/Adelaide", "CST", "CST",
                               dur!"hours"(9) + dur!"minutes"(30), dur!"hours"(1), false)];

            testTZ(utcZone, "UTC", "UTC", dur!"hours"(0), dur!"hours"(0));
            assertThrown!DateTimeException(PosixTimeZone.getTimeZone("hello_world"));
        }
        else version (Windows)
        {
            auto tzs = [testTZ("Pacific Standard Time", "Pacific Standard Time",
                               "Pacific Daylight Time", dur!"hours"(-8), dur!"hours"(1)),
                        testTZ("Eastern Standard Time", "Eastern Standard Time",
                               "Eastern Daylight Time", dur!"hours"(-5), dur!"hours"(1)),
                        //testTZ("Pacific SA Standard Time", "Pacific SA Standard Time",
                               //"Pacific SA Daylight Time", dur!"hours"(-4), dur!"hours"(1), false),
                        testTZ("GMT Standard Time", "GMT Standard Time",
                               "GMT Daylight Time", dur!"hours"(0), dur!"hours"(1)),
                        testTZ("Romance Standard Time", "Romance Standard Time",
                               "Romance Daylight Time", dur!"hours"(1), dur!"hours"(1)),
                        testTZ("Cen. Australia Standard Time", "Cen. Australia Standard Time",
                               "Cen. Australia Daylight Time",
                               dur!"hours"(9) + dur!"minutes"(30), dur!"hours"(1), false)];

            testTZ("Greenwich Standard Time", "Greenwich Standard Time",
                   "Greenwich Daylight Time", dur!"hours"(0), dur!"hours"(0));
            assertThrown!DateTimeException(WindowsTimeZone.getTimeZone("hello_world"));
        }
        else
            assert(0, "OS not supported.");

        foreach (i; 0 .. tzs.length)
        {
            auto tz = tzs[i];
            immutable spring = dstSwitches[i][2];
            immutable fall = dstSwitches[i][3];
            auto stdOffset = SysTime(dstSwitches[i][0] + dur!"days"(-1), tz).utcOffset;
            auto dstOffset = stdOffset + dur!"hours"(1);

            // Verify that creating a SysTime in the given time zone results
            // in a SysTime with the correct std time during and surrounding
            // a DST switch.
            foreach (hour; -12 .. 13)
            {
                import std.exception : enforce;
                auto st = SysTime(dstSwitches[i][0] + dur!"hours"(hour), tz);
                immutable targetHour = hour < 0 ? hour + 24 : hour;

                static void testHour(SysTime st, int hour, string tzName, size_t line = __LINE__)
                {
                    enforce(st.hour == hour,
                            new AssertError(format("[%s] [%s]: [%s] [%s]", st, tzName, st.hour, hour),
                                            __FILE__, line));
                }

                void testOffset1(Duration offset, bool dstInEffect, size_t line = __LINE__)
                {
                    AssertError msg(string tag)
                    {
                        return new AssertError(format("%s [%s] [%s]: [%s] [%s] [%s]",
                                                      tag, st, tz.name, st.utcOffset, stdOffset, dstOffset),
                                               __FILE__, line);
                    }

                    enforce(st.dstInEffect == dstInEffect, msg("1"));
                    enforce(st.utcOffset == offset, msg("2"));
                    enforce((st + dur!"minutes"(1)).utcOffset == offset, msg("3"));
                }

                if (hour == spring)
                {
                    testHour(st, spring + 1, tz.name);
                    testHour(st + dur!"minutes"(1), spring + 1, tz.name);
                }
                else
                {
                    testHour(st, targetHour, tz.name);
                    testHour(st + dur!"minutes"(1), targetHour, tz.name);
                }

                if (hour < spring)
                    testOffset1(stdOffset, false);
                else
                    testOffset1(dstOffset, true);

                st = SysTime(dstSwitches[i][1] + dur!"hours"(hour), tz);
                testHour(st, targetHour, tz.name);

                // Verify that 01:00 is the first 01:00 (or whatever hour before the switch is).
                if (hour == fall - 1)
                    testHour(st + dur!"hours"(1), targetHour, tz.name);

                if (hour < fall)
                    testOffset1(dstOffset, true);
                else
                    testOffset1(stdOffset, false);
            }

            // Verify that converting a time in UTC to a time in another
            // time zone results in the correct time during and surrounding
            // a DST switch.
            bool first = true;
            auto springSwitch = SysTime(dstSwitches[i][0] + dur!"hours"(spring), UTC()) - stdOffset;
            auto fallSwitch = SysTime(dstSwitches[i][1] + dur!"hours"(fall), UTC()) - dstOffset;
            // https://issues.dlang.org/show_bug.cgi?id=3659 makes this necessary.
            auto fallSwitchMinus1 = fallSwitch - dur!"hours"(1);

            foreach (hour; -24 .. 25)
            {
                auto utc = SysTime(dstSwitches[i][0] + dur!"hours"(hour), UTC());
                auto local = utc.toOtherTZ(tz);

                void testOffset2(Duration offset, size_t line = __LINE__)
                {
                    AssertError msg(string tag)
                    {
                        return new AssertError(format("%s [%s] [%s]: [%s] [%s]", tag, hour, tz.name, utc, local),
                                               __FILE__, line);
                    }

                    import std.exception : enforce;
                    enforce((utc + offset).hour == local.hour, msg("1"));
                    enforce((utc + offset + dur!"minutes"(1)).hour == local.hour, msg("2"));
                }

                if (utc < springSwitch)
                    testOffset2(stdOffset);
                else
                    testOffset2(dstOffset);

                utc = SysTime(dstSwitches[i][1] + dur!"hours"(hour), UTC());
                local = utc.toOtherTZ(tz);

                if (utc == fallSwitch || utc == fallSwitchMinus1)
                {
                    if (first)
                    {
                        testOffset2(dstOffset);
                        first = false;
                    }
                    else
                        testOffset2(stdOffset);
                }
                else if (utc > fallSwitch)
                    testOffset2(stdOffset);
                else
                    testOffset2(dstOffset);
            }
        }
    }


protected:

    /++
        Params:
            name    = The name of the time zone.
            stdName = The abbreviation for the time zone during std time.
            dstName = The abbreviation for the time zone during DST.
      +/
    this(string name, string stdName, string dstName) @safe immutable pure
    {
        _name = name;
        _stdName = stdName;
        _dstName = dstName;
    }


private:

    immutable string _name;
    immutable string _stdName;
    immutable string _dstName;
}


/++
    A TimeZone which represents the current local time zone on
    the system running your program.

    This uses the underlying C calls to adjust the time rather than using
    specific D code based off of system settings to calculate the time such as
    $(LREF PosixTimeZone) and $(LREF WindowsTimeZone) do. That also means that
    it will use whatever the current time zone is on the system, even if the
    system's time zone changes while the program is running.
  +/
final class LocalTime : TimeZone
{
public:

    /++
        $(LREF LocalTime) is a singleton class. $(LREF LocalTime) returns its
        only instance.
      +/
    static immutable(LocalTime) opCall() @trusted pure nothrow
    {
        alias FuncType = immutable(LocalTime) function() @safe pure nothrow;
        return (cast(FuncType)&singleton)();
    }


    version (StdDdoc)
    {
        /++
            In principle, this is the name of the local time zone. However,
            this always returns the empty string. This is because time zones
            cannot be uniquely identified by the attributes given by the
            OS (such as the `stdName` and `dstName`), and neither Posix systems
            nor Windows systems provide an easy way to get the TZ Database name
            of the local time zone.

            See_Also:
                $(HTTP en.wikipedia.org/wiki/Tz_database, Wikipedia entry on TZ
                  Database)<br>
                $(HTTP en.wikipedia.org/wiki/List_of_tz_database_time_zones, List
                  of Time Zones)
          +/
        @property override string name() @safe const nothrow;
    }


    /++
        Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST is $(I not) in effect (e.g. PST). It is not necessarily unique.

        However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Standard Time). Regardless, it is not the same as name.

        This property is overridden because the local time of the system could
        change while the program is running and we need to determine it
        dynamically rather than it being fixed like it would be with most time
        zones.
      +/
    @property override string stdName() @trusted const scope nothrow
    {
        version (Posix)
        {
            import core.stdc.time : tzname;
            import std.conv : to;
            try
                return to!string(tzname[0]);
            catch (Exception e)
                assert(0, "to!string(tzname[0]) failed.");
        }
        else version (Windows)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            // Cannot use to!string() like this should, probably due to bug
            // https://issues.dlang.org/show_bug.cgi?id=5016
            //return to!string(tzInfo.StandardName);

            wchar[32] str;

            foreach (i, ref wchar c; str)
                c = tzInfo.StandardName[i];

            string retval;

            try
            {
                foreach (dchar c; str)
                {
                    if (c == '\0')
                        break;

                    retval ~= c;
                }

                return retval;
            }
            catch (Exception e)
                assert(0, "GetTimeZoneInformation() returned invalid UTF-16.");
        }
    }

    @safe unittest
    {
        version (FreeBSD)
        {
            // A bug on FreeBSD 9+ makes it so that this test fails.
            // https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=168862
        }
        else version (NetBSD)
        {
            // The same bug on NetBSD 7+
        }
        else
        {
            assert(LocalTime().stdName !is null);

            version (Posix)
            {
                scope(exit) clearTZEnvVar();

                setTZEnvVar("America/Los_Angeles");
                assert(LocalTime().stdName == "PST");

                setTZEnvVar("America/New_York");
                assert(LocalTime().stdName == "EST");
            }
        }
    }


    /++
        Typically, the abbreviation (generally 3 or 4 letters) for the time zone
        when DST $(I is) in effect (e.g. PDT). It is not necessarily unique.

        However, on Windows, it may be the unabbreviated name (e.g. Pacific
        Daylight Time). Regardless, it is not the same as name.

        This property is overridden because the local time of the system could
        change while the program is running and we need to determine it
        dynamically rather than it being fixed like it would be with most time
        zones.
      +/
    @property override string dstName() @trusted const scope nothrow
    {
        version (Posix)
        {
            import core.stdc.time : tzname;
            import std.conv : to;
            try
                return to!string(tzname[1]);
            catch (Exception e)
                assert(0, "to!string(tzname[1]) failed.");
        }
        else version (Windows)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            // Cannot use to!string() like this should, probably due to bug
            // https://issues.dlang.org/show_bug.cgi?id=5016
            //return to!string(tzInfo.DaylightName);

            wchar[32] str;

            foreach (i, ref wchar c; str)
                c = tzInfo.DaylightName[i];

            string retval;

            try
            {
                foreach (dchar c; str)
                {
                    if (c == '\0')
                        break;

                    retval ~= c;
                }

                return retval;
            }
            catch (Exception e)
                assert(0, "GetTimeZoneInformation() returned invalid UTF-16.");
        }
    }

    @safe unittest
    {
        // tzname, called from dstName, isn't set by default for Musl.
        version (CRuntime_Musl)
            assert(LocalTime().dstName is null);
        else
            assert(LocalTime().dstName !is null);

        version (Posix)
        {
            scope(exit) clearTZEnvVar();

            version (FreeBSD)
            {
                // A bug on FreeBSD 9+ makes it so that this test fails.
                // https://bugs.freebsd.org/bugzilla/show_bug.cgi?id=168862
            }
            else version (NetBSD)
            {
                // The same bug on NetBSD 7+
            }
            else
            {
                setTZEnvVar("America/Los_Angeles");
                assert(LocalTime().dstName == "PDT");

                setTZEnvVar("America/New_York");
                assert(LocalTime().dstName == "EDT");
            }
        }
    }


    /++
        Whether this time zone has Daylight Savings Time at any point in time.
        Note that for some time zone types it may not have DST for current
        dates but will still return true for `hasDST` because the time zone
        did at some point have DST.
      +/
    @property override bool hasDST() @trusted const nothrow
    {
        version (Posix)
        {
            static if (is(typeof(daylight)))
                return cast(bool)(daylight);
            else
            {
                try
                {
                    import std.datetime.date : Date;
                    auto currYear = (cast(Date) Clock.currTime()).year;
                    auto janOffset = SysTime(Date(currYear, 1, 4), cast(immutable) this).stdTime -
                                     SysTime(Date(currYear, 1, 4), UTC()).stdTime;
                    auto julyOffset = SysTime(Date(currYear, 7, 4), cast(immutable) this).stdTime -
                                      SysTime(Date(currYear, 7, 4), UTC()).stdTime;

                    return janOffset != julyOffset;
                }
                catch (Exception e)
                    assert(0, "Clock.currTime() threw.");
            }
        }
        else version (Windows)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            return tzInfo.DaylightDate.wMonth != 0;
        }
    }

    @safe unittest
    {
        LocalTime().hasDST;

        version (Posix)
        {
            scope(exit) clearTZEnvVar();

            setTZEnvVar("America/Los_Angeles");
            assert(LocalTime().hasDST);

            setTZEnvVar("America/New_York");
            assert(LocalTime().hasDST);

            setTZEnvVar("UTC");
            assert(!LocalTime().hasDST);
        }
    }


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and returns whether DST is in effect in this
        time zone at the given point in time.

        Params:
            stdTime = The UTC time that needs to be checked for DST in this time
                      zone.
      +/
    override bool dstInEffect(long stdTime) @trusted const scope nothrow
    {
        import core.stdc.time : tm;

        time_t unixTime = stdTimeToUnixTime(stdTime);

        version (Posix)
        {
            import core.sys.posix.time : localtime_r;

            tm timeInfo = void;
            localtime_r(&unixTime, &timeInfo);

            return cast(bool)(timeInfo.tm_isdst);
        }
        else version (Windows)
        {
            import core.stdc.time : localtime;

            // Apparently Windows isn't smart enough to deal with negative time_t.
            if (unixTime >= 0)
            {
                tm* timeInfo = localtime(&unixTime);

                if (timeInfo)
                    return cast(bool)(timeInfo.tm_isdst);
            }

            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            return WindowsTimeZone._dstInEffect(&tzInfo, stdTime);
        }
    }

    @safe unittest
    {
        auto currTime = Clock.currStdTime;
        LocalTime().dstInEffect(currTime);
    }


    /++
        Returns hnsecs in the local time zone using the standard C function
        calls on Posix systems and the standard Windows system calls on Windows
        systems to adjust the time to the appropriate time zone from std time.

        Params:
            stdTime = The UTC time that needs to be adjusted to this time zone's
                      time.

        See_Also:
            `TimeZone.utcToTZ`
      +/
    override long utcToTZ(long stdTime) @trusted const scope nothrow
    {
        version (Solaris)
            return stdTime + convert!("seconds", "hnsecs")(tm_gmtoff(stdTime));
        else version (Posix)
        {
            import core.stdc.time : tm;
            import core.sys.posix.time : localtime_r;
            time_t unixTime = stdTimeToUnixTime(stdTime);
            tm timeInfo = void;
            localtime_r(&unixTime, &timeInfo);

            return stdTime + convert!("seconds", "hnsecs")(timeInfo.tm_gmtoff);
        }
        else version (Windows)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            return WindowsTimeZone._utcToTZ(&tzInfo, stdTime, hasDST);
        }
    }

    @safe unittest
    {
        LocalTime().utcToTZ(0);
    }


    /++
        Returns std time using the standard C function calls on Posix systems
        and the standard Windows system calls on Windows systems to adjust the
        time to UTC from the appropriate time zone.

        See_Also:
            `TimeZone.tzToUTC`

        Params:
            adjTime = The time in this time zone that needs to be adjusted to
                      UTC time.
      +/
    override long tzToUTC(long adjTime) @trusted const scope nothrow
    {
        version (Posix)
        {
            import core.stdc.time : tm;
            import core.sys.posix.time : localtime_r;
            time_t unixTime = stdTimeToUnixTime(adjTime);

            immutable past = unixTime - cast(time_t) convert!("days", "seconds")(1);
            tm timeInfo = void;
            localtime_r(past < unixTime ? &past : &unixTime, &timeInfo);
            immutable pastOffset = timeInfo.tm_gmtoff;

            immutable future = unixTime + cast(time_t) convert!("days", "seconds")(1);
            localtime_r(future > unixTime ? &future : &unixTime, &timeInfo);
            immutable futureOffset = timeInfo.tm_gmtoff;

            if (pastOffset == futureOffset)
                return adjTime - convert!("seconds", "hnsecs")(pastOffset);

            if (pastOffset < futureOffset)
                unixTime -= cast(time_t) convert!("hours", "seconds")(1);

            unixTime -= pastOffset;
            localtime_r(&unixTime, &timeInfo);

            return adjTime - convert!("seconds", "hnsecs")(timeInfo.tm_gmtoff);
        }
        else version (Windows)
        {
            TIME_ZONE_INFORMATION tzInfo;
            GetTimeZoneInformation(&tzInfo);

            return WindowsTimeZone._tzToUTC(&tzInfo, adjTime, hasDST);
        }
    }

    @safe unittest
    {
        import core.exception : AssertError;
        import std.format : format;
        import std.typecons : tuple;

        assert(LocalTime().tzToUTC(LocalTime().utcToTZ(0)) == 0);
        assert(LocalTime().utcToTZ(LocalTime().tzToUTC(0)) == 0);

        assert(LocalTime().tzToUTC(LocalTime().utcToTZ(0)) == 0);
        assert(LocalTime().utcToTZ(LocalTime().tzToUTC(0)) == 0);

        version (Posix)
        {
            scope(exit) clearTZEnvVar();

            import std.datetime.date : DateTime;
            auto tzInfos = [tuple("America/Los_Angeles", DateTime(2012, 3, 11), DateTime(2012, 11, 4), 2, 2),
                            tuple("America/New_York",    DateTime(2012, 3, 11), DateTime(2012, 11, 4), 2, 2),
                            //tuple("America/Santiago",    DateTime(2011, 8, 21), DateTime(2011, 5, 8), 0, 0),
                            tuple("Atlantic/Azores",     DateTime(2011, 3, 27), DateTime(2011, 10, 30), 0, 1),
                            tuple("Europe/London",       DateTime(2012, 3, 25), DateTime(2012, 10, 28), 1, 2),
                            tuple("Europe/Paris",        DateTime(2012, 3, 25), DateTime(2012, 10, 28), 2, 3),
                            tuple("Australia/Adelaide",  DateTime(2012, 10, 7), DateTime(2012, 4, 1), 2, 3)];

            foreach (i; 0 .. tzInfos.length)
            {
                import std.exception : enforce;
                auto tzName = tzInfos[i][0];
                setTZEnvVar(tzName);
                immutable spring = tzInfos[i][3];
                immutable fall = tzInfos[i][4];
                auto stdOffset = SysTime(tzInfos[i][1] + dur!"hours"(-12)).utcOffset;
                auto dstOffset = stdOffset + dur!"hours"(1);

                // Verify that creating a SysTime in the given time zone results
                // in a SysTime with the correct std time during and surrounding
                // a DST switch.
                foreach (hour; -12 .. 13)
                {
                    auto st = SysTime(tzInfos[i][1] + dur!"hours"(hour));
                    immutable targetHour = hour < 0 ? hour + 24 : hour;

                    static void testHour(SysTime st, int hour, string tzName, size_t line = __LINE__)
                    {
                        enforce(st.hour == hour,
                                new AssertError(format("[%s] [%s]: [%s] [%s]", st, tzName, st.hour, hour),
                                                __FILE__, line));
                    }

                    void testOffset1(Duration offset, bool dstInEffect, size_t line = __LINE__)
                    {
                        AssertError msg(string tag)
                        {
                            return new AssertError(format("%s [%s] [%s]: [%s] [%s] [%s]",
                                                          tag, st, tzName, st.utcOffset, stdOffset, dstOffset),
                                                   __FILE__, line);
                        }

                        enforce(st.dstInEffect == dstInEffect, msg("1"));
                        enforce(st.utcOffset == offset, msg("2"));
                        enforce((st + dur!"minutes"(1)).utcOffset == offset, msg("3"));
                    }

                    if (hour == spring)
                    {
                        testHour(st, spring + 1, tzName);
                        testHour(st + dur!"minutes"(1), spring + 1, tzName);
                    }
                    else
                    {
                        testHour(st, targetHour, tzName);
                        testHour(st + dur!"minutes"(1), targetHour, tzName);
                    }

                    if (hour < spring)
                        testOffset1(stdOffset, false);
                    else
                        testOffset1(dstOffset, true);

                    st = SysTime(tzInfos[i][2] + dur!"hours"(hour));
                    testHour(st, targetHour, tzName);

                    // Verify that 01:00 is the first 01:00 (or whatever hour before the switch is).
                    if (hour == fall - 1)
                        testHour(st + dur!"hours"(1), targetHour, tzName);

                    if (hour < fall)
                        testOffset1(dstOffset, true);
                    else
                        testOffset1(stdOffset, false);
                }

                // Verify that converting a time in UTC to a time in another
                // time zone results in the correct time during and surrounding
                // a DST switch.
                bool first = true;
                auto springSwitch = SysTime(tzInfos[i][1] + dur!"hours"(spring), UTC()) - stdOffset;
                auto fallSwitch = SysTime(tzInfos[i][2] + dur!"hours"(fall), UTC()) - dstOffset;
                // https://issues.dlang.org/show_bug.cgi?id=3659 makes this necessary.
                auto fallSwitchMinus1 = fallSwitch - dur!"hours"(1);

                foreach (hour; -24 .. 25)
                {
                    auto utc = SysTime(tzInfos[i][1] + dur!"hours"(hour), UTC());
                    auto local = utc.toLocalTime();

                    void testOffset2(Duration offset, size_t line = __LINE__)
                    {
                        AssertError msg(string tag)
                        {
                            return new AssertError(format("%s [%s] [%s]: [%s] [%s]", tag, hour, tzName, utc, local),
                                                   __FILE__, line);
                        }

                        enforce((utc + offset).hour == local.hour, msg("1"));
                        enforce((utc + offset + dur!"minutes"(1)).hour == local.hour, msg("2"));
                    }

                    if (utc < springSwitch)
                        testOffset2(stdOffset);
                    else
                        testOffset2(dstOffset);

                    utc = SysTime(tzInfos[i][2] + dur!"hours"(hour), UTC());
                    local = utc.toLocalTime();

                    if (utc == fallSwitch || utc == fallSwitchMinus1)
                    {
                        if (first)
                        {
                            testOffset2(dstOffset);
                            first = false;
                        }
                        else
                            testOffset2(stdOffset);
                    }
                    else if (utc > fallSwitch)
                        testOffset2(stdOffset);
                    else
                        testOffset2(dstOffset);
                }
            }
        }
    }


private:

    this() @safe immutable pure
    {
        super("", "", "");
    }


    // This is done so that we can maintain purity in spite of doing an impure
    // operation the first time that LocalTime() is called.
    static immutable(LocalTime) singleton() @trusted
    {
        import core.stdc.time : tzset;
        import std.concurrency : initOnce;
        static instance = new immutable(LocalTime)();
        static shared bool guard;
        initOnce!guard({tzset(); return true;}());
        return instance;
    }


    // The Solaris version of struct tm has no tm_gmtoff field, so do it here
    version (Solaris)
    {
        long tm_gmtoff(long stdTime) @trusted const nothrow
        {
            import core.stdc.time : tm;
            import core.sys.posix.time : localtime_r, gmtime_r;

            time_t unixTime = stdTimeToUnixTime(stdTime);
            tm timeInfo = void;
            localtime_r(&unixTime, &timeInfo);
            tm timeInfoGmt = void;
            gmtime_r(&unixTime, &timeInfoGmt);

            return timeInfo.tm_sec - timeInfoGmt.tm_sec +
                   convert!("minutes", "seconds")(timeInfo.tm_min - timeInfoGmt.tm_min) +
                   convert!("hours", "seconds")(timeInfo.tm_hour - timeInfoGmt.tm_hour);
        }
    }
}


/++
    A $(LREF TimeZone) which represents UTC.
  +/
final class UTC : TimeZone
{
public:

    /++
        `UTC` is a singleton class. `UTC` returns its only instance.
      +/
    static immutable(UTC) opCall() @safe pure nothrow
    {
        return _utc;
    }


    /++
        Always returns false.
      +/
    @property override bool hasDST() @safe const nothrow
    {
        return false;
    }


    /++
        Always returns false.
      +/
    override bool dstInEffect(long stdTime) @safe const scope nothrow
    {
        return false;
    }


    /++
        Returns the given hnsecs without changing them at all.

        Params:
            stdTime = The UTC time that needs to be adjusted to this time zone's
                      time.

        See_Also:
            `TimeZone.utcToTZ`
      +/
    override long utcToTZ(long stdTime) @safe const scope nothrow
    {
        return stdTime;
    }

    @safe unittest
    {
        assert(UTC().utcToTZ(0) == 0);

        version (Posix)
        {
            scope(exit) clearTZEnvVar();

            setTZEnvVar("UTC");
            import std.datetime.date : Date;
            auto std = SysTime(Date(2010, 1, 1));
            auto dst = SysTime(Date(2010, 7, 1));
            assert(UTC().utcToTZ(std.stdTime) == std.stdTime);
            assert(UTC().utcToTZ(dst.stdTime) == dst.stdTime);
        }
    }


    /++
        Returns the given hnsecs without changing them at all.

        See_Also:
            `TimeZone.tzToUTC`

        Params:
            adjTime = The time in this time zone that needs to be adjusted to
                      UTC time.
      +/
    override long tzToUTC(long adjTime) @safe const scope nothrow
    {
        return adjTime;
    }

    @safe unittest
    {
        assert(UTC().tzToUTC(0) == 0);

        version (Posix)
        {
            scope(exit) clearTZEnvVar();

            setTZEnvVar("UTC");
            import std.datetime.date : Date;
            auto std = SysTime(Date(2010, 1, 1));
            auto dst = SysTime(Date(2010, 7, 1));
            assert(UTC().tzToUTC(std.stdTime) == std.stdTime);
            assert(UTC().tzToUTC(dst.stdTime) == dst.stdTime);
        }
    }


    /++
        Returns a $(REF Duration, core,time) of 0.

        Params:
            stdTime = The UTC time for which to get the offset from UTC for this
                      time zone.
      +/
    override Duration utcOffsetAt(long stdTime) @safe const scope nothrow
    {
        return dur!"hnsecs"(0);
    }


private:

    this() @safe immutable pure
    {
        super("UTC", "UTC", "UTC");
    }


    static immutable UTC _utc = new immutable(UTC)();
}


/++
    Represents a time zone with an offset (in minutes, west is negative) from
    UTC but no DST.

    It's primarily used as the time zone in the result of
    $(REF SysTime,std,datetime,systime)'s `fromISOString`,
    `fromISOExtString`, and `fromSimpleString`.

    `name` and `dstName` are always the empty string since this time zone
    has no DST, and while it may be meant to represent a time zone which is in
    the TZ Database, obviously it's not likely to be following the exact rules
    of any of the time zones in the TZ Database, so it makes no sense to set it.
  +/
final class SimpleTimeZone : TimeZone
{
public:

    /++
        Always returns false.
      +/
    @property override bool hasDST() @safe const nothrow
    {
        return false;
    }


    /++
        Always returns false.
      +/
    override bool dstInEffect(long stdTime) @safe const scope nothrow
    {
        return false;
    }


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in UTC time (i.e. std time) and converts it to this time zone's time.

        Params:
            stdTime = The UTC time that needs to be adjusted to this time zone's
                      time.
      +/
    override long utcToTZ(long stdTime) @safe const scope nothrow
    {
        return stdTime + _utcOffset.total!"hnsecs";
    }

    @safe unittest
    {
        auto west = new immutable SimpleTimeZone(dur!"hours"(-8));
        auto east = new immutable SimpleTimeZone(dur!"hours"(8));

        assert(west.utcToTZ(0) == -288_000_000_000L);
        assert(east.utcToTZ(0) == 288_000_000_000L);
        assert(west.utcToTZ(54_321_234_567_890L) == 54_033_234_567_890L);

        const cstz = west;
        assert(cstz.utcToTZ(50002) == west.utcToTZ(50002));
    }


    /++
        Takes the number of hnsecs (100 ns) since midnight, January 1st, 1 A.D.
        in this time zone's time and converts it to UTC (i.e. std time).

        Params:
            adjTime = The time in this time zone that needs to be adjusted to
                      UTC time.
      +/
    override long tzToUTC(long adjTime) @safe const scope nothrow
    {
        return adjTime - _utcOffset.total!"hnsecs";
    }

    @safe unittest
    {
        auto west = new immutable SimpleTimeZone(dur!"hours"(-8));
        auto east = new immutable SimpleTimeZone(dur!"hours"(8));

        assert(west.tzToUTC(-288_000_000_000L) == 0);
        assert(east.tzToUTC(288_000_000_000L) == 0);
        assert(west.tzToUTC(54_033_234_567_890L) == 54_321_234_567_890L);

        const cstz = west;
        assert(cstz.tzToUTC(20005) == west.tzToUTC(20005));
    }


    /++
        Returns utcOffset as a $(REF Duration, core,time).

        Params:
            stdTime = The UTC time for which to get the offset from UTC for this
                      time zone.
      +/
    override Duration utcOffsetAt(long stdTime) @safe const scope nothrow
    {
        return _utcOffset;
    }


    /++
        Params:
            utcOffset = This time zone's offset from UTC with west of UTC being
                        negative (it is added to UTC to get the adjusted time).
            stdName   = The `stdName` for this time zone.
      +/
    this(Duration utcOffset, string stdName = "") @safe immutable pure
    {
        // FIXME This probably needs to be changed to something like (-12 - 13).
        import std.datetime.date : DateTimeException;
        import std.exception : enforce;
        enforce!DateTimeException(abs(utcOffset) < dur!"minutes"(1440),
                                    "Offset from UTC must be within range (-24:00 - 24:00).");
        super("", stdName, "");
        this._utcOffset = utcOffset;
    }

    @safe unittest
    {
        auto stz = new immutable SimpleTimeZone(dur!"hours"(-8), "PST");
        assert(stz.name == "");
        assert(stz.stdName == "PST");
        assert(stz.dstName == "");
        assert(stz.utcOffset == dur!"hours"(-8));
    }


    /++
        The amount of time the offset from UTC is (negative is west of UTC,
        positive is east).
      +/
    @property Duration utcOffset() @safe const pure nothrow
    {
        return _utcOffset;
    }


package:

    /+
        Returns a time zone as a string with an offset from UTC.

        Time zone offsets will be in the form +HHMM or -HHMM.

        Params:
            utcOffset = The number of minutes offset from UTC (negative means
                        west).
      +/
    static string toISOString(Duration utcOffset) @safe pure
    {
        import std.array : appender;
        auto w = appender!string();
        w.reserve(5);
        toISOString(w, utcOffset);
        return w.data;
    }

    // ditto
    static void toISOString(W)(ref W writer, Duration utcOffset)
    if (isOutputRange!(W, char))
    {
        import std.datetime.date : DateTimeException;
        import std.exception : enforce;
        import std.format.write : formattedWrite;
        immutable absOffset = abs(utcOffset);
        enforce!DateTimeException(absOffset < dur!"minutes"(1440),
                                  "Offset from UTC must be within range (-24:00 - 24:00).");
        int hours;
        int minutes;
        absOffset.split!("hours", "minutes")(hours, minutes);
        formattedWrite(
            writer,
            utcOffset < Duration.zero ? "-%02d%02d" : "+%02d%02d",
            hours,
            minutes
        );
    }

    @safe unittest
    {
        static string testSTZInvalid(Duration offset)
        {
            return SimpleTimeZone.toISOString(offset);
        }

        import std.datetime.date : DateTimeException;
        assertThrown!DateTimeException(testSTZInvalid(dur!"minutes"(1440)));
        assertThrown!DateTimeException(testSTZInvalid(dur!"minutes"(-1440)));

        assert(toISOString(dur!"minutes"(0)) == "+0000");
        assert(toISOString(dur!"minutes"(1)) == "+0001");
        assert(toISOString(dur!"minutes"(10)) == "+0010");
        assert(toISOString(dur!"minutes"(59)) == "+0059");
        assert(toISOString(dur!"minutes"(60)) == "+0100");
        assert(toISOString(dur!"minutes"(90)) == "+0130");
        assert(toISOString(dur!"minutes"(120)) == "+0200");
        assert(toISOString(dur!"minutes"(480)) == "+0800");
        assert(toISOString(dur!"minutes"(1439)) == "+2359");

        assert(toISOString(dur!"minutes"(-1)) == "-0001");
        assert(toISOString(dur!"minutes"(-10)) == "-0010");
        assert(toISOString(dur!"minutes"(-59)) == "-0059");
        assert(toISOString(dur!"minutes"(-60)) == "-0100");
        assert(toISOString(dur!"minutes"(-90)) == "-0130");
        assert(toISOString(dur!"minutes"(-120)) == "-0200");
        assert(toISOString(dur!"minutes"(-480)) == "-0800");
        assert(toISOString(dur!"minutes"(-1439)) == "-2359");
    }


    /+
        Returns a time zone as a string with an offset from UTC.

        Time zone offsets will be in the form +HH:MM or -HH:MM.

        Params:
            utcOffset = The number of minutes offset from UTC (negative means
                        west).
      +/
    static string toISOExtString(Duration utcOffset) @safe pure
    {
        import std.array : appender;
        auto w = appender!string();
        w.reserve(6);
        toISOExtString(w, utcOffset);
        return w.data;
    }

    // ditto
    static void toISOExtString(W)(ref W writer, Duration utcOffset)
    {
        import std.datetime.date : DateTimeException;
        import std.format.write : formattedWrite;
        import std.exception : enforce;

        immutable absOffset = abs(utcOffset);
        enforce!DateTimeException(absOffset < dur!"minutes"(1440),
                                  "Offset from UTC must be within range (-24:00 - 24:00).");
        int hours;
        int minutes;
        absOffset.split!("hours", "minutes")(hours, minutes);
        formattedWrite(
            writer,
            utcOffset < Duration.zero ? "-%02d:%02d" : "+%02d:%02d",
            hours,
            minutes
        );
    }

    @safe unittest
    {
        static string testSTZInvalid(Duration offset)
        {
            return SimpleTimeZone.toISOExtString(offset);
        }

        import std.datetime.date : DateTimeException;
        assertThrown!DateTimeException(testSTZInvalid(dur!"minutes"(1440)));
        assertThrown!DateTimeException(testSTZInvalid(dur!"minutes"(-1440)));

        assert(toISOExtString(dur!"minutes"(0)) == "+00:00");
        assert(toISOExtString(dur!"minutes"(1)) == "+00:01");
        assert(toISOExtString(dur!"minutes"(10)) == "+00:10");
        assert(toISOExtString(dur!"minutes"(59)) == "+00:59");
        assert(toISOExtString(dur!"minutes"(60)) == "+01:00");
        assert(toISOExtString(dur!"minutes"(90)) == "+01:30");
        assert(toISOExtString(dur!"minutes"(120)) == "+02:00");
        assert(toISOExtString(dur!"minutes"(480)) == "+08:00");
        assert(toISOExtString(dur!"minutes"(1439)) == "+23:59");

        assert(toISOExtString(dur!"minutes"(-1)) == "-00:01");
        assert(toISOExtString(dur!"minutes"(-10)) == "-00:10");
        assert(toISOExtString(dur!"minutes"(-59)) == "-00:59");
        assert(toISOExtString(dur!"minutes"(-60)) == "-01:00");
        assert(toISOExtString(dur!"minutes"(-90)) == "-01:30");
        assert(toISOExtString(dur!"minutes"(-120)) == "-02:00");
        assert(toISOExtString(dur!"minutes"(-480)) == "-08:00");
        assert(toISOExtString(dur!"minutes"(-1439)) == "-23:59");
    }


    /+
        Takes a time zone as a string with an offset from UTC and returns a
        $(LREF SimpleTimeZone) which matches.

        The accepted formats for time zone offsets are +HH, -HH, +HHMM, and
        -HHMM.

        Params:
            isoString = A string which represents a time zone in the ISO format.
      +/
    static immutable(SimpleTimeZone) fromISOString(S)(S isoString) @safe pure
        if (isSomeString!S)
    {
        import std.algorithm.searching : startsWith;
        import std.conv : text, to, ConvException;
        import std.datetime.date : DateTimeException;
        import std.exception : enforce;

        auto whichSign = isoString.startsWith('-', '+');
        enforce!DateTimeException(whichSign > 0, text("Invalid ISO String ", isoString));

        isoString = isoString[1 .. $];
        auto sign = whichSign == 1 ? -1 : 1;
        int hours;
        int minutes;

        try
        {
            // cast to int from uint is used because it checks for
            // non digits without extra loops
            if (isoString.length == 2)
            {
                hours = cast(int) to!uint(isoString);
            }
            else if (isoString.length == 4)
            {
                hours = cast(int) to!uint(isoString[0 .. 2]);
                minutes = cast(int) to!uint(isoString[2 .. 4]);
            }
            else
            {
                throw new DateTimeException(text("Invalid ISO String ", isoString));
            }
        }
        catch (ConvException)
        {
            throw new DateTimeException(text("Invalid ISO String ", isoString));
        }

        enforce!DateTimeException(hours < 24 && minutes < 60, text("Invalid ISO String ", isoString));

        return new immutable SimpleTimeZone(sign * (dur!"hours"(hours) + dur!"minutes"(minutes)));
    }

    @safe unittest
    {
        import core.exception : AssertError;
        import std.format : format;

        foreach (str; ["", "Z", "-", "+", "-:", "+:", "-1:", "+1:", "+1", "-1",
                       "-24:00", "+24:00", "-24", "+24", "-2400", "+2400",
                       "1", "+1", "-1", "+9", "-9",
                       "+1:0", "+01:0", "+1:00", "+01:000", "+01:60",
                       "-1:0", "-01:0", "-1:00", "-01:000", "-01:60",
                       "000", "00000", "0160", "-0160",
                       " +08:00", "+ 08:00", "+08 :00", "+08: 00", "+08:00 ",
                       " -08:00", "- 08:00", "-08 :00", "-08: 00", "-08:00 ",
                       " +0800", "+ 0800", "+08 00", "+08 00", "+0800 ",
                       " -0800", "- 0800", "-08 00", "-08 00", "-0800 ",
                       "+ab:cd", "+abcd", "+0Z:00", "+Z", "+00Z",
                       "-ab:cd", "+abcd", "-0Z:00", "-Z", "-00Z",
                       "01:00", "12:00", "23:59"])
        {
            import std.datetime.date : DateTimeException;
            assertThrown!DateTimeException(SimpleTimeZone.fromISOString(str), format("[%s]", str));
        }

        static void test(string str, Duration utcOffset, size_t line = __LINE__)
        {
            if (SimpleTimeZone.fromISOString(str).utcOffset != (new immutable SimpleTimeZone(utcOffset)).utcOffset)
                throw new AssertError("unittest failure", __FILE__, line);
        }

        test("+0000", Duration.zero);
        test("+0001", minutes(1));
        test("+0010", minutes(10));
        test("+0059", minutes(59));
        test("+0100", hours(1));
        test("+0130", hours(1) + minutes(30));
        test("+0200", hours(2));
        test("+0800", hours(8));
        test("+2359", hours(23) + minutes(59));

        test("-0001", minutes(-1));
        test("-0010", minutes(-10));
        test("-0059", minutes(-59));
        test("-0100", hours(-1));
        test("-0130", hours(-1) - minutes(30));
        test("-0200", hours(-2));
        test("-0800", hours(-8));
        test("-2359", hours(-23) - minutes(59));

        test("+00", Duration.zero);
        test("+01", hours(1));
        test("+02", hours(2));
        test("+12", hours(12));
        test("+23", hours(23));

        test("-00", Duration.zero);
        test("-01", hours(-1));
        test("-02", hours(-2));
        test("-12", hours(-12));
        test("-23", hours(-23));
    }

    @safe unittest
    {
        import core.exception : AssertError;
        import std.format : format;

        static void test(scope const string isoString, int expectedOffset, size_t line = __LINE__)
        {
            auto stz = SimpleTimeZone.fromISOExtString(isoString);
            if (stz.utcOffset != dur!"minutes"(expectedOffset))
                throw new AssertError(format("unittest failure: wrong offset [%s]", stz.utcOffset), __FILE__, line);

            auto result = SimpleTimeZone.toISOExtString(stz.utcOffset);
            if (result != isoString)
                throw new AssertError(format("unittest failure: [%s] != [%s]", result, isoString), __FILE__, line);
        }

        test("+00:00", 0);
        test("+00:01", 1);
        test("+00:10", 10);
        test("+00:59", 59);
        test("+01:00", 60);
        test("+01:30", 90);
        test("+02:00", 120);
        test("+08:00", 480);
        test("+08:00", 480);
        test("+23:59", 1439);

        test("-00:01", -1);
        test("-00:10", -10);
        test("-00:59", -59);
        test("-01:00", -60);
        test("-01:30", -90);
        test("-02:00", -120);
        test("-08:00", -480);
        test("-08:00", -480);
        test("-23:59", -1439);
    }


    /+
        Takes a time zone as a string with an offset from UTC and returns a
        $(LREF SimpleTimeZone) which matches.

        The accepted formats for time zone offsets are +HH, -HH, +HH:MM, and
        -HH:MM.

        Params:
            isoExtString = A string which represents a time zone in the ISO format.
      +/
    static immutable(SimpleTimeZone) fromISOExtString(S)(scope S isoExtString) @safe pure
        if (isSomeString!S)
    {
        import std.algorithm.searching : startsWith;
        import std.conv : ConvException, to;
        import std.datetime.date : DateTimeException;
        import std.exception : enforce;
        import std.format : format;
        import std.string : indexOf;

        auto whichSign = isoExtString.startsWith('-', '+');
        enforce!DateTimeException(whichSign > 0, format("Invalid ISO String: %s", isoExtString));
        auto sign = whichSign == 1 ? -1 : 1;

        isoExtString = isoExtString[1 .. $];
        enforce!DateTimeException(!isoExtString.empty, format("Invalid ISO String: %s", isoExtString));

        immutable colon = isoExtString.indexOf(':');
        S hoursStr;
        S minutesStr;
        int hours, minutes;

        if (colon != -1)
        {
            hoursStr = isoExtString[0 .. colon];
            minutesStr = isoExtString[colon + 1 .. $];
            enforce!DateTimeException(minutesStr.length == 2, format("Invalid ISO String: %s", isoExtString));
        }
        else
        {
            hoursStr = isoExtString;
        }

        enforce!DateTimeException(hoursStr.length == 2, format("Invalid ISO String: %s", isoExtString));

        try
        {
            // cast to int from uint is used because it checks for
            // non digits without extra loops
            hours = cast(int) to!uint(hoursStr);
            minutes = cast(int) (minutesStr.empty ? 0 : to!uint(minutesStr));
        }
        catch (ConvException)
        {
            throw new DateTimeException(format("Invalid ISO String: %s", isoExtString));
        }

        enforce!DateTimeException(hours < 24 && minutes < 60, format("Invalid ISO String: %s", isoExtString));

        return new immutable SimpleTimeZone(sign * (dur!"hours"(hours) + dur!"minutes"(minutes)));
    }

    @safe unittest
    {
        import core.exception : AssertError;
        import std.format : format;

        foreach (str; ["", "Z", "-", "+", "-:", "+:", "-1:", "+1:", "+1", "-1",
                       "-24:00", "+24:00", "-24", "+24", "-2400", "-2400",
                       "1", "+1", "-1", "+9", "-9",
                       "+1:0", "+01:0", "+1:00", "+01:000", "+01:60",
                       "-1:0", "-01:0", "-1:00", "-01:000", "-01:60",
                       "000", "00000", "0160", "-0160",
                       " +08:00", "+ 08:00", "+08 :00", "+08: 00", "+08:00 ",
                       " -08:00", "- 08:00", "-08 :00", "-08: 00", "-08:00 ",
                       " +0800", "+ 0800", "+08 00", "+08 00", "+0800 ",
                       " -0800", "- 0800", "-08 00", "-08 00", "-0800 ",
                       "+ab:cd", "abcd", "+0Z:00", "+Z", "+00Z",
                       "-ab:cd", "abcd", "-0Z:00", "-Z", "-00Z",
                       "0100", "1200", "2359"])
        {
            import std.datetime.date : DateTimeException;
            assertThrown!DateTimeException(SimpleTimeZone.fromISOExtString(str), format("[%s]", str));
        }

        static void test(string str, Duration utcOffset, size_t line = __LINE__)
        {
            if (SimpleTimeZone.fromISOExtString(str).utcOffset != (new immutable SimpleTimeZone(utcOffset)).utcOffset)
                throw new AssertError("unittest failure", __FILE__, line);
        }

        test("+00:00", Duration.zero);
        test("+00:01", minutes(1));
        test("+00:10", minutes(10));
        test("+00:59", minutes(59));
        test("+01:00", hours(1));
        test("+01:30", hours(1) + minutes(30));
        test("+02:00", hours(2));
        test("+08:00", hours(8));
        test("+23:59", hours(23) + minutes(59));

        test("-00:01", minutes(-1));
        test("-00:10", minutes(-10));
        test("-00:59", minutes(-59));
        test("-01:00", hours(-1));
        test("-01:30", hours(-1) - minutes(30));
        test("-02:00", hours(-2));
        test("-08:00", hours(-8));
        test("-23:59", hours(-23) - minutes(59));

        test("+00", Duration.zero);
        test("+01", hours(1));
        test("+02", hours(2));
        test("+12", hours(12));
        test("+23", hours(23));

        test("-00", Duration.zero);
        test("-01", hours(-1));
        test("-02", hours(-2));
        test("-12", hours(-12));
        test("-23", hours(-23));
    }

    @safe unittest
    {
        import core.exception : AssertError;
        import std.format : format;

        static void test(scope const string isoExtString, int expectedOffset, size_t line = __LINE__)
        {
            auto stz = SimpleTimeZone.fromISOExtString(isoExtString);
            if (stz.utcOffset != dur!"minutes"(expectedOffset))
                throw new AssertError(format("unittest failure: wrong offset [%s]", stz.utcOffset), __FILE__, line);

            auto result = SimpleTimeZone.toISOExtString(stz.utcOffset);
            if (result != isoExtString)
                thr// Written in the D programming language.

/**
 * Demangle D mangled names.
 *
 * Copyright: Copyright The D Language Foundation 2000 - 2009.
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:   $(HTTP digitalmars.com, Walter Bright),
 *                        Thomas K$(UUML)hne, Frits van Bommel
 * Source:    $(PHOBOSSRC std/demangle.d)
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
/*
 *          Copyright The D Language Foundation 2000 - 2009.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module std.demangle;

/**
Demangle D mangled names.

Params:
    name = the mangled name
Returns:
    A `string`. If it is not a D mangled name, it returns its argument name.
 */
string demangle(string name) @safe pure nothrow
{
    import core.demangle : demangle;
    import std.exception : assumeUnique;
    auto ret = demangle(name);
    return () @trusted { return ret.assumeUnique; } ();
}

///
@safe pure unittest
{
    // int b in module a
    assert(demangle("_D1a1bi") == "int a.b");
    // char array foo in module test
    assert(demangle("_D4test3fooAa") == "char[] test.foo");
}

/**
This program reads standard in and writes it to standard out,
pretty-printing any found D mangled names.
 */
@system unittest
{
    import std.ascii : isAlphaNum;
    import std.algorithm.iteration : chunkBy, joiner, map;
    import std.algorithm.mutation : copy;
    import std.conv : to;
    import std.demangle : demangle;
    import std.functional : pipe;
    import std.stdio : stdin, stdout;

    void main()
    {
        stdin.byLineCopy
            .map!(
                l => l.chunkBy!(a => isAlphaNum(a) || a == '_')
                      .map!(a => a[1].pipe!(to!string, demangle)).joiner
            )
            .copy(stdout.lockingTextWriter);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
Cyclic Redundancy Check (32-bit) implementation.

$(SCRIPT inhibitQuickIndex = 1;)

$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Category) $(TH Functions)
)
$(TR $(TDNW Template API) $(TD $(MYREF CRC) $(MYREF CRC32) $(MYREF CRC64ECMA) $(MYREF CRC64ISO)
)
)
$(TR $(TDNW OOP API) $(TD $(MYREF CRC32Digest) $(MYREF CRC64ECMADigest) $(MYREF CRC64ISODigest))
)
$(TR $(TDNW Helpers) $(TD $(MYREF crcHexString) $(MYREF crc32Of) $(MYREF crc64ECMAOf) $(MYREF crc64ISOOf))
)
)
)

 *
 * This module conforms to the APIs defined in `std.digest`. To understand the
 * differences between the template and the OOP API, see $(MREF std, digest).
 *
 * This module publicly imports $(MREF std, digest) and can be used as a stand-alone
 * module.
 *
 * Note:
 * CRCs are usually printed with the MSB first. When using
 * $(REF toHexString, std,digest) the result will be in an unexpected
 * order. Use $(REF toHexString, std,digest)'s optional order parameter
 * to specify decreasing order for the correct result. The $(LREF crcHexString)
 * alias can also be used for this purpose.
 *
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * Authors:   Pavel "EvilOne" Minayev, Alex Rønne Petersen, Johannes Pfau
 *
 * References:
 *      $(LINK2 http://en.wikipedia.org/wiki/Cyclic_redundancy_check, Wikipedia on CRC)
 *
 * Source: $(PHOBOSSRC std/digest/crc.d)
 *
 * Standards:
 * Implements the 'common' IEEE CRC32 variant
 * (LSB-first order, Initial value uint.max, complement result)
 *
 * CTFE:
 * Digests do not work in CTFE
 */
/*
 * Copyright (c) 2001 - 2002
 * Pavel "EvilOne" Minayev
 * Copyright (c) 2012
 * Alex Rønne Petersen
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module std.digest.crc;

public import std.digest;

///
@safe unittest
{
    //Template API
    import std.digest.crc;

    ubyte[4] hash = crc32Of("The quick brown fox jumps over the lazy dog");
    assert(crcHexString(hash) == "414FA339");

    //Feeding data
    ubyte[1024] data;
    CRC32 crc;
    crc.put(data[]);
    crc.start(); //Start again
    crc.put(data[]);
    hash = crc.finish();
}

///
@safe unittest
{
    //OOP API
    import std.digest.crc;

    auto crc = new CRC32Digest();
    ubyte[] hash = crc.digest("The quick brown fox jumps over the lazy dog");
    assert(crcHexString(hash) == "414FA339"); //352441c2

    //Feeding data
    ubyte[1024] data;
    crc.put(data[]);
    crc.reset(); //Start again
    crc.put(data[]);
    hash = crc.finish();
}

private T[256][8] genTables(T)(T polynomial)
{
    T[256][8] res = void;

    foreach (i; 0 .. 0x100)
    {
        T crc = i;
        foreach (_; 0 .. 8)
            crc = (crc >> 1) ^ (-int(crc & 1) & polynomial);
        res[0][i] = crc;
    }

    foreach (i; 0 .. 0x100)
    {
        res[1][i] = (res[0][i] >> 8) ^ res[0][res[0][i] & 0xFF];
        res[2][i] = (res[1][i] >> 8) ^ res[0][res[1][i] & 0xFF];
        res[3][i] = (res[2][i] >> 8) ^ res[0][res[2][i] & 0xFF];
        res[4][i] = (res[3][i] >> 8) ^ res[0][res[3][i] & 0xFF];
        res[5][i] = (res[4][i] >> 8) ^ res[0][res[4][i] & 0xFF];
        res[6][i] = (res[5][i] >> 8) ^ res[0][res[5][i] & 0xFF];
        res[7][i] = (res[6][i] >> 8) ^ res[0][res[6][i] & 0xFF];
    }
    return res;
}

@system unittest
{
    auto tables = genTables(0xEDB88320);
    assert(tables[0][0] == 0x00000000 && tables[0][$ - 1] == 0x2d02ef8d && tables[7][$ - 1] == 0x264b06e6);
}

/**
 * Template API CRC32 implementation.
 * See `std.digest` for differences between template and OOP API.
 */
alias CRC32 = CRC!(32, 0xEDB88320);

/**
 * Template API CRC64-ECMA implementation.
 * See `std.digest` for differences between template and OOP API.
 */
alias CRC64ECMA = CRC!(64, 0xC96C5795D7870F42);

/**
 * Template API CRC64-ISO implementation.
 * See `std.digest` for differences between template and OOP API.
 */
alias CRC64ISO = CRC!(64, 0xD800000000000000);

/**
 * Generic Template API used for CRC32 and CRC64 implementations.
 *
 * The N parameter indicate the size of the hash in bits.
 * The parameter P specify the polynomial to be used for reduction.
 *
 * You may want to use the CRC32, CRC65ECMA and CRC64ISO aliases
 * for convenience.
 *
 * See `std.digest` for differences between template and OOP API.
 */
struct CRC(uint N, ulong P)
if (N == 32 || N == 64)
{
    private:
        static if (N == 32)
        {
            alias T = uint;
        }
        else
        {
            alias T = ulong;
        }

        static immutable T[256][8] tables = genTables!T(P);

        /**
         * Type of the finished CRC hash.
         * ubyte[4] if N is 32, ubyte[8] if N is 64.
         */
        alias R = ubyte[T.sizeof];

        // magic initialization constants
        T _state = T.max;

    public:
        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         */
        void put(scope const(ubyte)[] data...) @trusted pure nothrow @nogc
        {
            T crc = _state;
            // process eight bytes at once
            while (data.length >= 8)
            {
                // Use byte-wise reads to support architectures without HW support
                // for unaligned reads. This can be optimized by compilers to a single
                // 32-bit read if unaligned reads are supported.
                // DMD is not able to do this optimization though, so explicitly
                // do unaligned reads for DMD's architectures.
                version (X86)
                    enum hasLittleEndianUnalignedReads = true;
                else version (X86_64)
                    enum hasLittleEndianUnalignedReads = true;
                else
                    enum hasLittleEndianUnalignedReads = false; // leave decision to optimizer

                uint one = void;
                uint two = void;

                if (!__ctfe && hasLittleEndianUnalignedReads)
                {
                    one = (cast(uint*) data.ptr)[0];
                    two = (cast(uint*) data.ptr)[1];
                }
                else
                {
                    one = (data.ptr[3] << 24 | data.ptr[2] << 16 | data.ptr[1] << 8 | data.ptr[0]);
                    two = (data.ptr[7] << 24 | data.ptr[6] << 16 | data.ptr[5] << 8 | data.ptr[4]);
                }

                static if (N == 32)
                {
                    one ^= crc;
                }
                else
                {
                    one ^= (crc & 0xffffffff);
                    two ^= (crc >> 32);
                }

                crc =
                    tables[0][two >> 24] ^
                    tables[1][(two >> 16) & 0xFF] ^
                    tables[2][(two >>  8) & 0xFF] ^
                    tables[3][two & 0xFF] ^
                    tables[4][one >> 24] ^
                    tables[5][(one >> 16) & 0xFF] ^
                    tables[6][(one >>  8) & 0xFF] ^
                    tables[7][one & 0xFF];

                data = data[8 .. $];
            }
            // remaining 1 to 7 bytes
            foreach (d; data)
                crc = (crc >> 8) ^ tables[0][(crc & 0xFF) ^ d];
            _state = crc;
        }

        /**
         * Used to initialize the CRC32 digest.
         *
         * Note:
         * For this CRC32 Digest implementation calling start after default construction
         * is not necessary. Calling start is only necessary to reset the Digest.
         *
         * Generic code which deals with different Digest types should always call start though.
         */
        void start() @safe pure nothrow @nogc
        {
            this = CRC.init;
        }

        /**
         * Returns the finished CRC hash. This also calls $(LREF start) to
         * reset the internal state.
         */
        R finish() @safe pure nothrow @nogc
        {
            auto tmp = peek();
            start();
            return tmp;
        }

        /**
         * Works like `finish` but does not reset the internal state, so it's possible
         * to continue putting data into this CRC after a call to peek.
         */
        R peek() const @safe pure nothrow @nogc
        {
            import std.bitmanip : nativeToLittleEndian;
            //Complement, LSB first / Little Endian, see http://rosettacode.org/wiki/CRC-32
            return nativeToLittleEndian(~_state);
        }
}

@safe unittest
{
    // https://issues.dlang.org/show_bug.cgi?id=13471
    static ubyte[4] foo(string str)
    {
        ubyte[4] result = str.crc32Of();
        if (result == (ubyte[4]).init)
            throw new Exception("this should not be thrown");
        return result;
    }
    enum buggy1 = foo("Hello World!");
    enum buggy2 = crc32Of("Hello World!");
    assert(buggy1 == buggy2);
    assert(buggy1 == "Hello World!".crc32Of());
}

///
@safe unittest
{
    //Simple example, hashing a string using crc32Of helper function
    ubyte[4] hash32 = crc32Of("abc");
    //Let's get a hash string
    assert(crcHexString(hash32) == "352441C2");
    // Repeat for CRC64
    ubyte[8] hash64ecma = crc64ECMAOf("abc");
    assert(crcHexString(hash64ecma) == "2CD8094A1A277627");
    ubyte[8] hash64iso = crc64ISOOf("abc");
    assert(crcHexString(hash64iso) == "3776C42000000000");
}

///
@safe unittest
{
    ubyte[1024] data;
    //Using the basic API
    CRC32 hash32;
    CRC64ECMA hash64ecma;
    CRC64ISO hash64iso;
    //Initialize data here...
    hash32.put(data);
    ubyte[4] result32 = hash32.finish();
    hash64ecma.put(data);
    ubyte[8] result64ecma = hash64ecma.finish();
    hash64iso.put(data);
    ubyte[8] result64iso = hash64iso.finish();
}

///
@safe unittest
{
    //Let's use the template features:
    //Note: When passing a CRC32 to a function, it must be passed by reference!
    void doSomething(T)(ref T hash)
    if (isDigest!T)
    {
      hash.put(cast(ubyte) 0);
    }
    CRC32 crc32;
    crc32.start();
    doSomething(crc32);
    assert(crcHexString(crc32.finish()) == "D202EF8D");
    // repeat for CRC64
    CRC64ECMA crc64ecma;
    crc64ecma.start();
    doSomething(crc64ecma);
    assert(crcHexString(crc64ecma.finish()) == "1FADA17364673F59");
    CRC64ISO crc64iso;
    crc64iso.start();
    doSomething(crc64iso);
    assert(crcHexString(crc64iso.finish()) == "6F90000000000000");
}

@safe unittest
{
    assert(isDigest!CRC32);
    assert(isDigest!CRC64ECMA);
    assert(isDigest!CRC64ISO);
}

@system unittest
{
    import std.conv : hexString;
    ubyte[4] digest;

    CRC32 crc;
    crc.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    assert(crc.peek() == cast(ubyte[]) hexString!"bd50274c");
    crc.start();
    crc.put(cast(ubyte[])"");
    assert(crc.finish() == cast(ubyte[]) hexString!"00000000");

    digest = crc32Of("");
    assert(digest == cast(ubyte[]) hexString!"00000000");

    //Test vector from http://rosettacode.org/wiki/CRC-32
    assert(crcHexString(crc32Of("The quick brown fox jumps over the lazy dog")) == "414FA339");

    digest = crc32Of("a");
    assert(digest == cast(ubyte[]) hexString!"43beb7e8");

    digest = crc32Of("abc");
    assert(digest == cast(ubyte[]) hexString!"c2412435");

    digest = crc32Of("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"5f3f1a17");

    digest = crc32Of("message digest");
    assert(digest == cast(ubyte[]) hexString!"7f9d1520");

    digest = crc32Of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"d2e6c21f");

    digest = crc32Of("1234567890123456789012345678901234567890"~
                    "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"724aa97c");

    enum ubyte[4] input = cast(ubyte[4]) hexString!"c3fcd3d7";
    assert(crcHexString(input) == "D7D3FCC3");
}

@system unittest
{
    import std.conv : hexString;
    ubyte[8] digest;

    CRC64ECMA crc;
    crc.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    assert(crc.peek() == cast(ubyte[]) hexString!"2f121b7575789626");
    crc.start();
    crc.put(cast(ubyte[])"");
    assert(crc.finish() == cast(ubyte[]) hexString!"0000000000000000");
    digest = crc64ECMAOf("");
    assert(digest == cast(ubyte[]) hexString!"0000000000000000");

    //Test vector from http://rosettacode.org/wiki/CRC-32
    assert(crcHexString(crc64ECMAOf("The quick brown fox jumps over the lazy dog")) == "5B5EB8C2E54AA1C4");

    digest = crc64ECMAOf("a");
    assert(digest == cast(ubyte[]) hexString!"052b652e77840233");

    digest = crc64ECMAOf("abc");
    assert(digest == cast(ubyte[]) hexString!"2776271a4a09d82c");

    digest = crc64ECMAOf("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"4b7cdce3746c449f");

    digest = crc64ECMAOf("message digest");
    assert(digest == cast(ubyte[]) hexString!"6f9b8a3156c9bc5d");

    digest = crc64ECMAOf("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"2656b716e1bf0503");

    digest = crc64ECMAOf("1234567890123456789012345678901234567890"~
                         "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"bd3eb7765d0a22ae");

    enum ubyte[8] input = cast(ubyte[8]) hexString!"c3fcd3d7efbeadde";
    assert(crcHexString(input) == "DEADBEEFD7D3FCC3");
}

@system unittest
{
    import std.conv : hexString;
    ubyte[8] digest;

    CRC64ISO crc;
    crc.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    assert(crc.peek() == cast(ubyte[]) hexString!"f0494ab780989b42");
    crc.start();
    crc.put(cast(ubyte[])"");
    assert(crc.finish() == cast(ubyte[]) hexString!"0000000000000000");
    digest = crc64ISOOf("");
    assert(digest == cast(ubyte[]) hexString!"0000000000000000");

    //Test vector from http://rosettacode.org/wiki/CRC-32
    assert(crcHexString(crc64ISOOf("The quick brown fox jumps over the lazy dog")) == "4EF14E19F4C6E28E");

    digest = crc64ISOOf("a");
    assert(digest == cast(ubyte[]) hexString!"0000000000002034");

    digest = crc64ISOOf("abc");
    assert(digest == cast(ubyte[]) hexString!"0000000020c47637");

    digest = crc64ISOOf("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"5173f717971365e5");

    digest = crc64ISOOf("message digest");
    assert(digest == cast(ubyte[]) hexString!"a2c355bbc0b93f86");

    digest = crc64ISOOf("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"598B258292E40084");

    digest = crc64ISOOf("1234567890123456789012345678901234567890"~
                        "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"760cd2d3588bf809");

    enum ubyte[8] input = cast(ubyte[8]) hexString!"c3fcd3d7efbeadde";
    assert(crcHexString(input) == "DEADBEEFD7D3FCC3");
}

/**
 * This is a convenience alias for $(REF digest, std,digest) using the
 * CRC32 implementation.
 *
 * Params:
 *      data = `InputRange` of `ElementType` implicitly convertible to
 *             `ubyte`, `ubyte[]` or `ubyte[num]` or one or more arrays
 *             of any type.
 *
 * Returns:
 *      CRC32 of data
 */
//simple alias doesn't work here, hope this gets inlined...
ubyte[4] crc32Of(T...)(T data)
{
    return digest!(CRC32, T)(data);
}

///
@system unittest
{
    ubyte[] data = [4,5,7,25];
    assert(data.crc32Of == [167, 180, 199, 131]);

    import std.utf : byChar;
    assert("hello"d.byChar.crc32Of == [134, 166, 16, 54]);

    ubyte[4] hash = "abc".crc32Of();
    assert(hash == digest!CRC32("ab", "c"));

    import std.range : iota;
    enum ubyte S = 5, F = 66;
    assert(iota(S, F).crc32Of == [59, 140, 234, 154]);
}

/**
 * This is a convenience alias for $(REF digest, std,digest) using the
 * CRC64-ECMA implementation.
 *
 * Params:
 *      data = `InputRange` of `ElementType` implicitly convertible to
 *             `ubyte`, `ubyte[]` or `ubyte[num]` or one or more arrays
 *             of any type.
 *
 * Returns:
 *      CRC64-ECMA of data
 */
//simple alias doesn't work here, hope this gets inlined...
ubyte[8] crc64ECMAOf(T...)(T data)
{
    return digest!(CRC64ECMA, T)(data);
}

///
@system unittest
{
    ubyte[] data = [4,5,7,25];
    assert(data.crc64ECMAOf == [58, 142, 220, 214, 118, 98, 105, 69]);

    import std.utf : byChar;
    assert("hello"d.byChar.crc64ECMAOf == [177, 55, 185, 219, 229, 218, 30, 155]);

    ubyte[8] hash = "abc".crc64ECMAOf();
    assert("abc".crc64ECMAOf == [39, 118, 39, 26, 74, 9, 216, 44]);
    assert(hash == digest!CRC64ECMA("ab", "c"));

    import std.range : iota;
    enum ubyte S = 5, F = 66;
    assert(iota(S, F).crc64ECMAOf == [6, 184, 91, 238, 46, 213, 127, 188]);
}

/**
 * This is a convenience alias for $(REF digest, std,digest) using the
 * CRC64-ISO implementation.
 *
 * Params:
 *      data = `InputRange` of `ElementType` implicitly convertible to
 *             `ubyte`, `ubyte[]` or `ubyte[num]` or one or more arrays
 *             of any type.
 *
 * Returns:
 *      CRC64-ISO of data
 */
//simple alias doesn't work here, hope this gets inlined...
ubyte[8] crc64ISOOf(T...)(T data)
{
    return digest!(CRC64ISO, T)(data);
}

///
@system unittest
{
    ubyte[] data = [4,5,7,25];
    assert(data.crc64ISOOf == [0, 0, 0, 80, 137, 232, 203, 120]);

    import std.utf : byChar;
    assert("hello"d.byChar.crc64ISOOf == [0, 0, 16, 216, 226, 238, 62, 60]);

    ubyte[8] hash = "abc".crc64ISOOf();
    assert("abc".crc64ISOOf == [0, 0, 0, 0, 32, 196, 118, 55]);
    assert(hash == digest!CRC64ISO("ab", "c"));

    import std.range : iota;
    enum ubyte S = 5, F = 66;

    assert(iota(S, F).crc64ISOOf == [21, 185, 116, 95, 219, 11, 54, 7]);
}

/**
 * producing the usual CRC32 string output.
 */
public alias crcHexString = toHexString!(Order.decreasing);
///ditto
public alias crcHexString = toHexString!(Order.decreasing, 16);

/**
 * OOP API CRC32 implementation.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!CRC32), see
 * there for more information.
 */
alias CRC32Digest = WrapperDigest!CRC32;

/**
 * OOP API CRC64-ECMA implementation.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!CRC64ECMA),
 * see there for more information.
 */
alias CRC64ECMADigest = WrapperDigest!CRC64ECMA;

/**
 * OOP API CRC64-ISO implementation.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!CRC64ISO),
 * see there for more information.
 */
alias CRC64ISODigest = WrapperDigest!CRC64ISO;

///
@safe unittest
{
    //Simple example, hashing a string using CRC32Digest.digest helper function
    auto crc = new CRC32Digest();
    ubyte[] hash = crc.digest("abc");
    //Let's get a hash string
    assert(crcHexString(hash) == "352441C2");
}

///
@system unittest
{
     //Let's use the OOP features:
    void test(Digest dig)
    {
      dig.put(cast(ubyte) 0);
    }
    auto crc = new CRC32Digest();
    test(crc);

    //Let's use a custom buffer:
    ubyte[4] buf;
    ubyte[] result = crc.finish(buf[]);
    assert(crcHexString(result) == "D202EF8D");
}

///
@safe unittest
{
    //Simple example
    auto hash = new CRC32Digest();
    hash.put(cast(ubyte) 0);
    ubyte[] result = hash.finish();
}

///
@system unittest
{
    //using a supplied buffer
    ubyte[4] buf;
    auto hash = new CRC32Digest();
    hash.put(cast(ubyte) 0);
    ubyte[] result = hash.finish(buf[]);
    //The result is now in result (and in buf. If you pass a buffer which is bigger than
    //necessary, result will have the correct length, but buf will still have it's original
    //length)
}

@system unittest
{
    import std.conv : hexString;
    import std.range;
    import std.exception;

    auto crc = new CRC32Digest();

    crc.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    assert(crc.peek() == cast(ubyte[]) hexString!"bd50274c");
    crc.reset();
    crc.put(cast(ubyte[])"");
    assert(crc.finish() == cast(ubyte[]) hexString!"00000000");

    crc.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    ubyte[20] result;
    auto result2 = crc.finish(result[]);
    assert(result[0 .. 4] == result2 && result2 == cast(ubyte[]) hexString!"bd50274c");

    debug
        assertThrown!Error(crc.finish(result[0 .. 3]));

    assert(crc.length == 4);

    assert(crc.digest("") == cast(ubyte[]) hexString!"00000000");

    assert(crc.digest("a") == cast(ubyte[]) hexString!"43beb7e8");

    assert(crc.digest("abc") == cast(ubyte[]) hexString!"c2412435");

    assert(crc.digest("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")
           == cast(ubyte[]) hexString!"5f3f1a17");

    assert(crc.digest("message digest") == cast(ubyte[]) hexString!"7f9d1520");

    assert(crc.digest("abcdefghijklmnopqrstuvwxyz")
           == cast(ubyte[]) hexString!"bd50274c");

    assert(crc.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
           == cast(ubyte[]) hexString!"d2e6c21f");

    assert(crc.digest("1234567890123456789012345678901234567890",
                                   "1234567890123456789012345678901234567890")
           == cast(ubyte[]) hexString!"724aa97c");

    ubyte[] onemilliona = new ubyte[1000000];
    onemilliona[] = 'a';
    auto digest = crc32Of(onemilliona);
    assert(digest == cast(ubyte[]) hexString!"BCBF25DC");

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    digest = crc32Of(oneMillionRange);
    assert(digest == cast(ubyte[]) hexString!"BCBF25DC");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // Written in the D programming language.

/**
This package implements the hash-based message authentication code (_HMAC)
algorithm as defined in $(HTTP tools.ietf.org/html/rfc2104, RFC2104). See also
the corresponding $(HTTP en.wikipedia.org/wiki/Hash-based_message_authentication_code, Wikipedia article).

$(SCRIPT inhibitQuickIndex = 1;)

Macros:

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Source: $(PHOBOSSRC std/digest/hmac.d)
 */

module std.digest.hmac;

import std.digest : isDigest, hasBlockSize, isDigestibleRange, DigestType;
import std.meta : allSatisfy;

@safe:

/**
 * Template API HMAC implementation.
 *
 * This implements an _HMAC over the digest H. If H doesn't provide
 * information about the block size, it can be supplied explicitly using
 * the second overload.
 *
 * This type conforms to $(REF isDigest, std,digest).
 */

/// Compute HMAC over an input string
@safe unittest
{
    import std.ascii : LetterCase;
    import std.digest : toHexString;
    import std.digest.sha : SHA1;
    import std.string : representation;

    auto secret = "secret".representation;
    assert("The quick brown fox jumps over the lazy dog"
            .representation
            .hmac!SHA1(secret)
            .toHexString!(LetterCase.lower) == "198ea1ea04c435c1246b586a06d5cf11c3ffcda6");
}

template HMAC(H)
if (isDigest!H && hasBlockSize!H)
{
    alias HMAC = HMAC!(H, H.blockSize);
}

/**
 * Overload of HMAC to be used if H doesn't provide information about its
 * block size.
 */

struct HMAC(H, size_t hashBlockSize)
if (hashBlockSize % 8 == 0)
{
    enum blockSize = hashBlockSize;

    private H digest;
    private ubyte[blockSize / 8] key;

    /**
     * Constructs the HMAC digest using the specified secret.
     */

    this(scope const(ubyte)[] secret)
    {
        // if secret is too long, shorten it by computing its hash
        typeof(digest.finish()) buffer = void;
        typeof(secret) secretBytes = secret;

        if (secret.length > blockSize / 8)
        {
            digest.start();
            digest.put(secret);
            buffer = digest.finish();
            secretBytes = buffer[];
        }

        // if secret is too short, it will be padded with zeroes
        // (the key buffer is already zero-initialized)
        import std.algorithm.mutation : copy;
        secretBytes.copy(key[]);

        start();
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.digest.sha : SHA1;
        import std.string : representation;
        auto hmac = HMAC!SHA1("My s3cR3T keY".representation);
        hmac.put("Hello, world".representation);
        static immutable expected = [
            130, 32, 235, 44, 208, 141,
            150, 232, 211, 214, 162, 195,
            188, 127, 52, 89, 100, 68, 90, 216];
        assert(hmac.finish() == expected);
    }

    /**
     * Reinitializes the digest, making it ready for reuse.
     *
     * Note:
     * The constructor leaves the digest in an initialized state, so that this
     * method only needs to be called if an unfinished digest is to be reused.
     *
     * Returns:
     * A reference to the digest for convenient chaining.
     */

    ref HMAC!(H, blockSize) start() return
    {
        ubyte[blockSize / 8] ipad = void;
        foreach (immutable i; 0 .. blockSize / 8)
            ipad[i] = key[i] ^ 0x36;

        digest.start();
        digest.put(ipad[]);

        return this;
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.digest.sha : SHA1;
        import std.string : representation;
        string data1 = "Hello, world", data2 = "Hola mundo";
        auto hmac = HMAC!SHA1("My s3cR3T keY".representation);
        hmac.put(data1.representation);
        hmac.start();                   // reset digest
        hmac.put(data2.representation); // start over
        static immutable expected = [
            122, 151, 232, 240, 249, 80,
            19, 178, 186, 77, 110, 23, 208,
            52, 11, 88, 34, 151, 192, 255];
        assert(hmac.finish() == expected);
    }

    /**
     * Feeds a piece of data into the hash computation. This method allows the
     * type to be used as an $(REF OutputRange, std,range).
     *
     * Returns:
     * A reference to the digest for convenient chaining.
     */

    ref HMAC!(H, blockSize) put(in ubyte[] data...) return
    {
        digest.put(data);
        return this;
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.digest.hmac, std.digest.sha;
        import std.string : representation;
        string data1 = "Hello, world", data2 = "Hola mundo";
        auto hmac = HMAC!SHA1("My s3cR3T keY".representation);
        hmac.put(data1.representation)
            .put(data2.representation);
        static immutable expected = [
            197, 57, 52, 3, 13, 194, 13,
            36, 117, 228, 8, 11, 111, 51,
            165, 3, 123, 31, 251, 113];
        assert(hmac.finish() == expected);
    }

    /**
     * Resets the digest and returns the finished hash.
     */

    DigestType!H finish()
    {
        ubyte[blockSize / 8] opad = void;
        foreach (immutable i; 0 .. blockSize / 8)
            opad[i] = key[i] ^ 0x5c;

        auto tmp = digest.finish();

        digest.start();
        digest.put(opad[]);
        digest.put(tmp);
        auto result = digest.finish();
        start();    // reset the digest
        return result;
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.digest.sha : SHA1;
        import std.string : representation;
        string data1 = "Hello, world", data2 = "Hola mundo";
        auto hmac = HMAC!SHA1("My s3cR3T keY".representation);
        auto testDigest = hmac.put(data1.representation)
                          .put(data2.representation)
                          .finish();
        static immutable expected = [
            197, 57, 52, 3, 13, 194, 13,
            36, 117, 228, 8, 11, 111, 51,
            165, 3, 123, 31, 251, 113];
        assert(testDigest == expected);
    }
}

/// ditto
template hmac(H)
if (isDigest!H && hasBlockSize!H)
{
    alias hmac = hmac!(H, H.blockSize);
}

/// ditto
template hmac(H, size_t blockSize)
if (isDigest!H)
{
    /**
     * Constructs an HMAC digest with the specified secret.
     *
     * Returns:
     * An instance of HMAC that can be fed data as desired, and finished
     * to compute the final hash when done.
     */
    auto hmac(scope const(ubyte)[] secret)
    {
        return HMAC!(H, blockSize)(secret);
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.digest.sha : SHA1;
        import std.string : representation;
        string data1 = "Hello, world", data2 = "Hola mundo";
        auto digest = hmac!SHA1("My s3cR3T keY".representation)
                          .put(data1.representation)
                          .put(data2.representation)
                          .finish();
        static immutable expected = [
            197, 57, 52, 3, 13, 194, 13, 36,
            117, 228, 8, 11, 111, 51, 165,
            3, 123, 31, 251, 113];
        assert(digest == expected);
    }

    /**
     * Computes an _HMAC digest over the given range of data with the
     * specified secret.
     *
     * Returns:
     * The final _HMAC hash.
     */
    DigestType!H hmac(T...)(scope T data, scope const(ubyte)[] secret)
    if (allSatisfy!(isDigestibleRange, typeof(data)))
    {
        import std.range.primitives : put;
        auto hash = HMAC!(H, blockSize)(secret);
        foreach (datum; data)
            put(hash, datum);
        return hash.finish();
    }

    ///
    @safe pure nothrow @nogc unittest
    {
        import std.algorithm.iteration : map;
        import std.digest.sha : SHA1;
        import std.string : representation;
        string data = "Hello, world";
        auto digest = data.representation
                      .map!(a => cast(ubyte)(a+1))
                      .hmac!SHA1("My s3cR3T keY".representation);
        static assert(is(typeof(digest) == ubyte[20]));
        static immutable expected = [
            163, 208, 118, 179, 216, 93,
            17, 10, 84, 200, 87, 104, 244,
            111, 136, 214, 167, 210, 58, 10];
        assert(digest == expected);
    }
}

///
@safe pure nothrow @nogc unittest
{
    import std.digest.sha : SHA1;
    import std.string : representation;
    string data1 = "Hello, world", data2 = "Hola mundo";
    auto hmac = HMAC!SHA1("My s3cR3T keY".representation);
    auto digest = hmac.put(data1.representation)
                      .put(data2.representation)
                      .finish();
    static immutable expected = [
        197, 57, 52, 3, 13, 194, 13,
        36, 117, 228, 8, 11, 111, 51,
        165, 3, 123, 31, 251, 113];
    assert(digest == expected);
}

@safe pure nothrow @nogc
unittest
{
    import std.digest.md : MD5;
    import std.range : isOutputRange;
    static assert(isOutputRange!(HMAC!MD5, ubyte));
    static assert(isDigest!(HMAC!MD5));
    static assert(hasBlockSize!(HMAC!MD5) && HMAC!MD5.blockSize == MD5.blockSize);
}

@safe pure nothrow
unittest
{
    import std.digest.md : MD5;
    import std.digest.sha : SHA1, SHA256;

    // Note, can't be UFCS because we don't want to import inside
    // version (StdUnittest).
    import std.digest : toHexString, LetterCase;
    alias hex = toHexString!(LetterCase.lower);

    ubyte[] nada;
    assert(hex(hmac!MD5   (nada, nada)) == "74e6f7298a9c2d168935f58c001bad88");
    assert(hex(hmac!SHA1  (nada, nada)) == "fbdb1d1b18aa6c08324b7d64b71fb76370690e1d");
    assert(hex(hmac!SHA256(nada, nada)) == "b613679a0814d9ec772f95d778c35fc5ff1697c493715653c6c712144292c5ad");

    import std.string : representation;
    auto key      = "key".representation,
         long_key = ("012345678901234567890123456789012345678901"
            ~"234567890123456789012345678901234567890123456789").representation,
         data1    = "The quick brown fox ".representation,
         data2    = "jumps over the lazy dog".representation,
         data     = data1 ~ data2;

    assert(hex(data.hmac!MD5   (key)) == "80070713463e7749b90c2dc24911e275");
    assert(hex(data.hmac!SHA1  (key)) == "de7c9b85b8b78aa6bc8a7a36f70a90701c9db4d9");
    assert(hex(data.hmac!SHA256(key)) == "f7bc83f430538424b13298e6aa6fb143ef4d59a14946175997479dbc2d1a3cd8");

    assert(hex(data.hmac!MD5   (long_key)) == "e1728d68e05beae186ea768561963778");
    assert(hex(data.hmac!SHA1  (long_key)) == "560d3cd77316e57ab4bba0c186966200d2b37ba3");
    assert(hex(data.hmac!SHA256(long_key)) == "a1b0065a5d1edd93152c677e1bc1b1e3bc70d3a76619842e7f733f02b8135c04");

    assert(hmac!MD5   (key).put(data1).put(data2).finish == data.hmac!MD5   (key));
    assert(hmac!SHA1  (key).put(data1).put(data2).finish == data.hmac!SHA1  (key));
    assert(hmac!SHA256(key).put(data1).put(data2).finish == data.hmac!SHA256(key));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /**
 * Computes MD5 hashes of arbitrary data. MD5 hashes are 16 byte quantities that are like a
 * checksum or CRC, but are more robust.
 *
$(SCRIPT inhibitQuickIndex = 1;)

$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Category) $(TH Functions)
)
$(TR $(TDNW Template API) $(TD $(MYREF MD5)
)
)
$(TR $(TDNW OOP API) $(TD $(MYREF MD5Digest))
)
$(TR $(TDNW Helpers) $(TD $(MYREF md5Of))
)
)
)

 * This module conforms to the APIs defined in `std.digest`. To understand the
 * differences between the template and the OOP API, see $(MREF std, digest).
 *
 * This module publicly imports $(MREF std, digest) and can be used as a stand-alone
 * module.
 *
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * CTFE:
 * Digests do not work in CTFE
 *
 * Authors:
 * Piotr Szturmaj, Kai Nacke, Johannes Pfau $(BR)
 * The routines and algorithms are derived from the $(I RSA Data Security, Inc. MD5 Message-Digest Algorithm).
 *
 * References:
 *      $(LINK2 http://en.wikipedia.org/wiki/Md5, Wikipedia on MD5)
 *
 * Source: $(PHOBOSSRC std/digest/md.d)
 *
 */

/* md5.d - RSA Data Security, Inc., MD5 message-digest algorithm
 * Derived from the RSA Data Security, Inc. MD5 Message-Digest Algorithm.
 */
module std.digest.md;

public import std.digest;

///
@safe unittest
{
    //Template API
    import std.digest.md;

    //Feeding data
    ubyte[1024] data;
    MD5 md5;
    md5.start();
    md5.put(data[]);
    md5.start(); //Start again
    md5.put(data[]);
    auto hash = md5.finish();
}

///
@safe unittest
{
    //OOP API
    import std.digest.md;

    auto md5 = new MD5Digest();
    ubyte[] hash = md5.digest("abc");
    assert(toHexString(hash) == "900150983CD24FB0D6963F7D28E17F72");

    //Feeding data
    ubyte[1024] data;
    md5.put(data[]);
    md5.reset(); //Start again
    md5.put(data[]);
    hash = md5.finish();
}

/**
 * Template API MD5 implementation.
 * See `std.digest` for differences between template and OOP API.
 */
struct MD5
{
    import core.bitop : rol;
    private:
        // magic initialization constants
        uint[4] _state = [0x67452301,0xefcdab89,0x98badcfe,0x10325476]; // state (ABCD)
        ulong _count; //number of bits, modulo 2^64
        ubyte[64] _buffer; // input buffer

        static immutable ubyte[64] _padding =
        [
          0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        ];

        // F, G, H and I are basic MD5 functions
        static @safe pure nothrow @nogc
        {
            uint F(uint x, uint y, uint z) { return (x & y) | (~x & z); }
            uint G(uint x, uint y, uint z) { return (x & z) | (y & ~z); }
            uint H(uint x, uint y, uint z) { return x ^ y ^ z; }
            uint I(uint x, uint y, uint z) { return y ^ (x | ~z); }
        }


        /*
         * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
         * Rotation is separate from addition to prevent recomputation.
         */
        static void FF(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)
            @safe pure nothrow @nogc
        {
            a += F (b, c, d) + x + ac;
            a = rol(a, s);
            a += b;
        }

        static void GG(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)
            @safe pure nothrow @nogc
        {
            a += G (b, c, d) + x + ac;
            a = rol(a, s);
            a += b;
        }

        static void HH(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)
            @safe pure nothrow @nogc
        {
            a += H (b, c, d) + x + ac;
            a = rol(a, s);
            a += b;
        }

        static void II(ref uint a, uint b, uint c, uint d, uint x, uint s, uint ac)
            @safe pure nothrow @nogc
        {
            a += I (b, c, d) + x + ac;
            a = rol(a, s);
            a += b;
        }

        /*
         * MD5 basic transformation. Transforms state based on block.
         */

        //Constants for MD5Transform routine.
        enum
        {
            S11 = 7,
            S12 = 12,
            S13 = 17,
            S14 = 22,
            S21 = 5,
            S22 = 9,
            S23 = 14,
            S24 = 20,
            S31 = 4,
            S32 = 11,
            S33 = 16,
            S34 = 23,
            S41 = 6,
            S42 = 10,
            S43 = 15,
            S44 = 21,
        }

        private void transform(const(ubyte[64])* block) pure nothrow @nogc
        {
            uint a = _state[0],
                 b = _state[1],
                 c = _state[2],
                 d = _state[3];

            uint[16] x = void;

            version (BigEndian)
            {
                import std.bitmanip : littleEndianToNative;

                for (size_t i = 0; i < 16; i++)
                {
                    x[i] = littleEndianToNative!uint(*cast(ubyte[4]*)&(*block)[i*4]);
                }
            }
            else
            {
                (cast(ubyte*) x.ptr)[0 .. 64] = (cast(ubyte*) block)[0 .. 64];
            }

            //Round 1
            FF (a, b, c, d, x[ 0], S11, 0xd76aa478); /* 1 */
            FF (d, a, b, c, x[ 1], S12, 0xe8c7b756); /* 2 */
            FF (c, d, a, b, x[ 2], S13, 0x242070db); /* 3 */
            FF (b, c, d, a, x[ 3], S14, 0xc1bdceee); /* 4 */
            FF (a, b, c, d, x[ 4], S11, 0xf57c0faf); /* 5 */
            FF (d, a, b, c, x[ 5], S12, 0x4787c62a); /* 6 */
            FF (c, d, a, b, x[ 6], S13, 0xa8304613); /* 7 */
            FF (b, c, d, a, x[ 7], S14, 0xfd469501); /* 8 */
            FF (a, b, c, d, x[ 8], S11, 0x698098d8); /* 9 */
            FF (d, a, b, c, x[ 9], S12, 0x8b44f7af); /* 10 */
            FF (c, d, a, b, x[10], S13, 0xffff5bb1); /* 11 */
            FF (b, c, d, a, x[11], S14, 0x895cd7be); /* 12 */
            FF (a, b, c, d, x[12], S11, 0x6b901122); /* 13 */
            FF (d, a, b, c, x[13], S12, 0xfd987193); /* 14 */
            FF (c, d, a, b, x[14], S13, 0xa679438e); /* 15 */
            FF (b, c, d, a, x[15], S14, 0x49b40821); /* 16 */

            //Round 2
            GG (a, b, c, d, x[ 1], S21, 0xf61e2562); /* 17 */
            GG (d, a, b, c, x[ 6], S22, 0xc040b340); /* 18 */
            GG (c, d, a, b, x[11], S23, 0x265e5a51); /* 19 */
            GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa); /* 20 */
            GG (a, b, c, d, x[ 5], S21, 0xd62f105d); /* 21 */
            GG (d, a, b, c, x[10], S22,  0x2441453); /* 22 */
            GG (c, d, a, b, x[15], S23, 0xd8a1e681); /* 23 */
            GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8); /* 24 */
            GG (a, b, c, d, x[ 9], S21, 0x21e1cde6); /* 25 */
            GG (d, a, b, c, x[14], S22, 0xc33707d6); /* 26 */
            GG (c, d, a, b, x[ 3], S23, 0xf4d50d87); /* 27 */
            GG (b, c, d, a, x[ 8], S24, 0x455a14ed); /* 28 */
            GG (a, b, c, d, x[13], S21, 0xa9e3e905); /* 29 */
            GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8); /* 30 */
            GG (c, d, a, b, x[ 7], S23, 0x676f02d9); /* 31 */
            GG (b, c, d, a, x[12], S24, 0x8d2a4c8a); /* 32 */

            //Round 3
            HH (a, b, c, d, x[ 5], S31, 0xfffa3942); /* 33 */
            HH (d, a, b, c, x[ 8], S32, 0x8771f681); /* 34 */
            HH (c, d, a, b, x[11], S33, 0x6d9d6122); /* 35 */
            HH (b, c, d, a, x[14], S34, 0xfde5380c); /* 36 */
            HH (a, b, c, d, x[ 1], S31, 0xa4beea44); /* 37 */
            HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9); /* 38 */
            HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60); /* 39 */
            HH (b, c, d, a, x[10], S34, 0xbebfbc70); /* 40 */
            HH (a, b, c, d, x[13], S31, 0x289b7ec6); /* 41 */
            HH (d, a, b, c, x[ 0], S32, 0xeaa127fa); /* 42 */
            HH (c, d, a, b, x[ 3], S33, 0xd4ef3085); /* 43 */
            HH (b, c, d, a, x[ 6], S34,  0x4881d05); /* 44 */
            HH (a, b, c, d, x[ 9], S31, 0xd9d4d039); /* 45 */
            HH (d, a, b, c, x[12], S32, 0xe6db99e5); /* 46 */
            HH (c, d, a, b, x[15], S33, 0x1fa27cf8); /* 47 */
            HH (b, c, d, a, x[ 2], S34, 0xc4ac5665); /* 48 */

            //Round 4
            II (a, b, c, d, x[ 0], S41, 0xf4292244); /* 49 */
            II (d, a, b, c, x[ 7], S42, 0x432aff97); /* 50 */
            II (c, d, a, b, x[14], S43, 0xab9423a7); /* 51 */
            II (b, c, d, a, x[ 5], S44, 0xfc93a039); /* 52 */
            II (a, b, c, d, x[12], S41, 0x655b59c3); /* 53 */
            II (d, a, b, c, x[ 3], S42, 0x8f0ccc92); /* 54 */
            II (c, d, a, b, x[10], S43, 0xffeff47d); /* 55 */
            II (b, c, d, a, x[ 1], S44, 0x85845dd1); /* 56 */
            II (a, b, c, d, x[ 8], S41, 0x6fa87e4f); /* 57 */
            II (d, a, b, c, x[15], S42, 0xfe2ce6e0); /* 58 */
            II (c, d, a, b, x[ 6], S43, 0xa3014314); /* 59 */
            II (b, c, d, a, x[13], S44, 0x4e0811a1); /* 60 */
            II (a, b, c, d, x[ 4], S41, 0xf7537e82); /* 61 */
            II (d, a, b, c, x[11], S42, 0xbd3af235); /* 62 */
            II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb); /* 63 */
            II (b, c, d, a, x[ 9], S44, 0xeb86d391); /* 64 */

            _state[0] += a;
            _state[1] += b;
            _state[2] += c;
            _state[3] += d;

            //Zeroize sensitive information.
            x[] = 0;
        }

    public:
        enum blockSize = 512;

        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         *
         * Example:
         * ----
         * MD5 dig;
         * dig.put(cast(ubyte) 0); //single ubyte
         * dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
         * ubyte[10] buf;
         * dig.put(buf); //buffer
         * ----
         */
        void put(scope const(ubyte)[] data...) @trusted pure nothrow @nogc
        {
            size_t i;
            uint index, partLen;
            auto inputLen = data.length;

            //Compute number of bytes mod 64
            index = (cast(uint)_count >> 3) & (64 - 1);

            //Update number of bits
            _count += inputLen * 8;

            partLen = 64 - index;

            //Transform as many times as possible
            if (inputLen >= partLen)
            {
                (&_buffer[index])[0 .. partLen] = data.ptr[0 .. partLen];
                transform(&_buffer);

                for (i = partLen; i + 63 < inputLen; i += 64)
                {
                    transform(cast(const(ubyte[64])*)(data[i .. i + 64].ptr));
                }

                index = 0;
            }
            else
            {
                i = 0;
            }

            /* Buffer remaining input */
            if (inputLen - i)
                (&_buffer[index])[0 .. inputLen-i] = (&data[i])[0 .. inputLen-i];
        }

        /**
         * Used to (re)initialize the MD5 digest.
         *
         * Note:
         * For this MD5 Digest implementation calling start after default construction
         * is not necessary. Calling start is only necessary to reset the Digest.
         *
         * Generic code which deals with different Digest types should always call start though.
         *
         * Example:
         * --------
         * MD5 digest;
         * //digest.start(); //Not necessary
         * digest.put(0);
         * --------
         */
        void start() @safe pure nothrow @nogc
        {
            this = MD5.init;
        }

        /**
         * Returns the finished MD5 hash. This also calls $(LREF start) to
         * reset the internal state.
          */
        ubyte[16] finish() @trusted pure nothrow @nogc
        {
            import std.bitmanip : nativeToLittleEndian;

            ubyte[16] data = void;
            ubyte[8] bits = void;
            uint index, padLen;

            //Save number of bits
            bits[0 .. 8] = nativeToLittleEndian(_count)[];

            //Pad out to 56 mod 64
            index = (cast(uint)_count >> 3) & (64 - 1);
            padLen = (index < 56) ? (56 - index) : (120 - index);
            put(_padding[0 .. padLen]);

            //Append length (before padding)
            put(bits);

            //Store state in digest
            data[0 .. 4]   = nativeToLittleEndian(_state[0])[];
            data[4 .. 8]   = nativeToLittleEndian(_state[1])[];
            data[8 .. 12]  = nativeToLittleEndian(_state[2])[];
            data[12 .. 16] = nativeToLittleEndian(_state[3])[];

            /* Zeroize sensitive information. */
            start();
            return data;
        }
        ///
        @safe unittest
        {
            //Simple example
            MD5 hash;
            hash.start();
            hash.put(cast(ubyte) 0);
            ubyte[16] result = hash.finish();
        }
}

///
@safe unittest
{
    //Simple example, hashing a string using md5Of helper function
    ubyte[16] hash = md5Of("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "900150983CD24FB0D6963F7D28E17F72");
}

///
@safe unittest
{
    //Using the basic API
    MD5 hash;
    hash.start();
    ubyte[1024] data;
    //Initialize data here...
    hash.put(data);
    ubyte[16] result = hash.finish();
}

///
@safe unittest
{
    //Let's use the template features:
    void doSomething(T)(ref T hash)
    if (isDigest!T)
    {
        hash.put(cast(ubyte) 0);
    }
    MD5 md5;
    md5.start();
    doSomething(md5);
    assert(toHexString(md5.finish()) == "93B885ADFE0DA089CDF634904FD59F71");
}

@safe unittest
{
    assert(isDigest!MD5);
}

@system unittest
{
    import std.range;
    import std.conv : hexString;

    ubyte[16] digest;

    MD5 md5;
    md5.put(cast(ubyte[])"abcdef");
    md5.start();
    md5.put(cast(ubyte[])"");
    assert(md5.finish() == cast(ubyte[]) hexString!"d41d8cd98f00b204e9800998ecf8427e");

    digest = md5Of("");
    assert(digest == cast(ubyte[]) hexString!"d41d8cd98f00b204e9800998ecf8427e");

    digest = md5Of("a");
    assert(digest == cast(ubyte[]) hexString!"0cc175b9c0f1b6a831c399e269772661");

    digest = md5Of("abc");
    assert(digest == cast(ubyte[]) hexString!"900150983cd24fb0d6963f7d28e17f72");

    digest = md5Of("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"8215ef0796a20bcaaae116d3876c664a");

    digest = md5Of("message digest");
    assert(digest == cast(ubyte[]) hexString!"f96b697d7cb7938d525a2f31aaf161d0");

    digest = md5Of("abcdefghijklmnopqrstuvwxyz");
    assert(digest == cast(ubyte[]) hexString!"c3fcd3d76192e4007dfb496cca67e13b");

    digest = md5Of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"d174ab98d277d9f5a5611c2c9f419d9f");

    digest = md5Of("1234567890123456789012345678901234567890"~
                    "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"57edf4a22be3c955ac49da2e2107b67a");

    enum ubyte[16] input = cast(ubyte[16]) hexString!"c3fcd3d76192e4007dfb496cca67e13b";
    assert(toHexString(input)
        == "C3FCD3D76192E4007DFB496CCA67E13B");

    ubyte[] onemilliona = new ubyte[1000000];
    onemilliona[] = 'a';
    digest = md5Of(onemilliona);
    assert(digest == cast(ubyte[]) hexString!"7707D6AE4E027C70EEA2A935C2296F21");

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    digest = md5Of(oneMillionRange);
    assert(digest == cast(ubyte[]) hexString!"7707D6AE4E027C70EEA2A935C2296F21");
}

/**
 * This is a convenience alias for $(REF digest, std,digest) using the
 * MD5 implementation.
 */
//simple alias doesn't work here, hope this gets inlined...
auto md5Of(T...)(T data)
{
    return digest!(MD5, T)(data);
}

///
@safe unittest
{
    ubyte[16] hash = md5Of("abc");
    assert(hash == digest!MD5("abc"));
}

/**
 * OOP API MD5 implementation.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!MD5), see
 * there for more information.
 */
alias MD5Digest = WrapperDigest!MD5;

///
@safe unittest
{
    //Simple example, hashing a string using Digest.digest helper function
    auto md5 = new MD5Digest();
    ubyte[] hash = md5.digest("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "900150983CD24FB0D6963F7D28E17F72");
}

///
@system unittest
{
     //Let's use the OOP features:
    void test(Digest dig)
    {
      dig.put(cast(ubyte) 0);
    }
    auto md5 = new MD5Digest();
    test(md5);

    //Let's use a custom buffer:
    ubyte[16] buf;
    ubyte[] result = md5.finish(buf[]);
    assert(toHexString(result) == "93B885ADFE0DA089CDF634904FD59F71");
}

@system unittest
{
    import std.conv : hexString;
    auto md5 = new MD5Digest();

    md5.put(cast(ubyte[])"abcdef");
    md5.reset();
    md5.put(cast(ubyte[])"");
    assert(md5.finish() == cast(ubyte[]) hexString!"d41d8cd98f00b204e9800998ecf8427e");

    md5.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    ubyte[20] result;
    auto result2 = md5.finish(result[]);
    assert(result[0 .. 16] == result2 && result2 == cast(ubyte[]) hexString!"c3fcd3d76192e4007dfb496cca67e13b");

    debug
    {
        import std.exception;
        assertThrown!Error(md5.finish(result[0 .. 15]));
    }

    assert(md5.length == 16);

    assert(md5.digest("") == cast(ubyte[]) hexString!"d41d8cd98f00b204e9800998ecf8427e");

    assert(md5.digest("a") == cast(ubyte[]) hexString!"0cc175b9c0f1b6a831c399e269772661");

    assert(md5.digest("abc") == cast(ubyte[]) hexString!"900150983cd24fb0d6963f7d28e17f72");

    assert(md5.digest("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")
           == cast(ubyte[]) hexString!"8215ef0796a20bcaaae116d3876c664a");

    assert(md5.digest("message digest") == cast(ubyte[]) hexString!"f96b697d7cb7938d525a2f31aaf161d0");

    assert(md5.digest("abcdefghijklmnopqrstuvwxyz")
           == cast(ubyte[]) hexString!"c3fcd3d76192e4007dfb496cca67e13b");

    assert(md5.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
           == cast(ubyte[]) hexString!"d174ab98d277d9f5a5611c2c9f419d9f");

    assert(md5.digest("1234567890123456789012345678901234567890",
                                   "1234567890123456789012345678901234567890")
           == cast(ubyte[]) hexString!"57edf4a22be3c955ac49da2e2107b67a");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
Computes $(LINK2 https://en.wikipedia.org/wiki/MurmurHash, MurmurHash) hashes
of arbitrary data. MurmurHash is a non-cryptographic hash function suitable
for general hash-based lookup. It is optimized for x86 but can be used on
all architectures.

The current version is MurmurHash3, which yields a 32-bit or 128-bit hash value.
The older MurmurHash 1 and 2 are currently not supported.

MurmurHash3 comes in three flavors, listed in increasing order of throughput:
$(UL
$(LI `MurmurHash3!32` produces a 32-bit value and is optimized for 32-bit architectures)
$(LI $(D MurmurHash3!(128, 32)) produces a 128-bit value and is optimized for 32-bit architectures)
$(LI $(D MurmurHash3!(128, 64)) produces a 128-bit value and is optimized for 64-bit architectures)
)

Note:
$(UL
$(LI $(D MurmurHash3!(128, 32)) and $(D MurmurHash3!(128, 64)) produce different values.)
$(LI The current implementation is optimized for little endian architectures.
  It will exhibit different results on big endian architectures and a slightly
  less uniform distribution.)
)

This module conforms to the APIs defined in $(MREF std, digest).

This module publicly imports $(MREF std, digest) and can be used as a stand-alone module.

Source: $(PHOBOSSRC std/digest/murmurhash.d)
License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
Authors: Guillaume Chatelet
References: $(LINK2 https://github.com/aappleby/smhasher, Reference implementation)
$(BR) $(LINK2 https://en.wikipedia.org/wiki/MurmurHash, Wikipedia)
*/
/* Copyright Guillaume Chatelet 2016.
 * Distributed under the Boost Software License, Version 1.0.
 * (See LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
 */
module std.digest.murmurhash;

///
@safe unittest
{
    // MurmurHash3!32, MurmurHash3!(128, 32) and MurmurHash3!(128, 64) implement
    // the std.digest Template API.
    static assert(isDigest!(MurmurHash3!32));
    // The convenient digest template allows for quick hashing of any data.
    ubyte[4] hashed = digest!(MurmurHash3!32)([1, 2, 3, 4]);
    assert(hashed == [0, 173, 69, 68]);
}

///
@safe unittest
{
    // One can also hash ubyte data piecewise by instanciating a hasher and call
    // the 'put' method.
    const(ubyte)[] data1 = [1, 2, 3];
    const(ubyte)[] data2 = [4, 5, 6, 7];
    // The incoming data will be buffered and hashed element by element.
    MurmurHash3!32 hasher;
    hasher.put(data1);
    hasher.put(data2);
    // The call to 'finish' ensures:
    // - the remaining bits are processed
    // - the hash gets finalized
    auto hashed = hasher.finish();
    assert(hashed == [181, 151, 88, 252]);
}

///
@safe unittest
{
    // Using `putElements`, `putRemainder` and `finalize` you gain full
    // control over which part of the algorithm to run.
    // This allows for maximum throughput but needs extra care.

    // Data type must be the same as the hasher's element type:
    // - uint for MurmurHash3!32
    // - uint[4] for MurmurHash3!(128, 32)
    // - ulong[2] for MurmurHash3!(128, 64)
    const(uint)[] data = [1, 2, 3, 4];
    // Note the hasher starts with 'Fast'.
    MurmurHash3!32 hasher;
    // Push as many array of elements as you need. The less calls the better.
    hasher.putElements(data);
    // Put remainder bytes if needed. This method can be called only once.
    hasher.putRemainder(ubyte(1), ubyte(1), ubyte(1));
    // Call finalize to incorporate data length in the hash.
    hasher.finalize();
    // Finally get the hashed value.
    auto hashed = hasher.getBytes();
    assert(hashed == [188, 165, 108, 2]);
}

version (X86)
    version = HaveUnalignedLoads;
else version (X86_64)
    version = HaveUnalignedLoads;

public import std.digest;

@safe:

/*
Performance notes:
 - To help a bit with the performance when compiling with DMD some
   functions have been rewritten to pass by value instead of by reference.
 - GDC and LDC are on par with their C++ counterpart.
 - DMD is typically between 20% to 50% of the GCC version.
*/

/++
 + Implements the MurmurHash3 functions. You can specify the `size` of the
 + hash in bit. For 128 bit hashes you can specify whether to optimize for 32
 + or 64 bit architectures. If you don't specify the `opt` value it will select
 + the fastest version of the host platform.
 +
 + This hasher is compatible with the `Digest` API:
 + $(UL
 + $(LI `void start()`)
 + $(LI `void put(scope const(ubyte)[] data...)`)
 + $(LI `ubyte[Element.sizeof] finish()`)
 + )
 +
 + It also provides a faster, low level API working with data of size
 + `Element.sizeof`:
 + $(UL
 + $(LI `void putElements(scope const(Element[]) elements...)`)
 + $(LI `void putRemainder(scope const(ubyte[]) data...)`)
 + $(LI `void finalize()`)
 + $(LI `Element get()`)
 + $(LI `ubyte[Element.sizeof] getBytes()`)
 + )
 +/
struct MurmurHash3(uint size /* 32 or 128 */ , uint opt = size_t.sizeof == 8 ? 64 : 32)
{
    enum blockSize = size; // Number of bits of the hashed value.
    size_t element_count; // The number of full elements pushed, this is used for finalization.

    static if (size == 32)
    {
        private enum uint c1 = 0xcc9e2d51;
        private enum uint c2 = 0x1b873593;
        private uint h1;
        alias Element = uint; /// The element type for 32-bit implementation.

        this(uint seed)
        {
            h1 = seed;
        }
        /++
        Adds a single Element of data without increasing `element_count`.
        Make sure to increase `element_count` by `Element.sizeof` for each call to `putElement`.
        +/
        void putElement(uint block) pure nothrow @nogc
        {
            h1 = update(h1, block, 0, c1, c2, 15, 13, 0xe6546b64U);
        }

        /// Put remainder bytes. This must be called only once after `putElement` and before `finalize`.
        void putRemainder(scope const(ubyte[]) data...) pure nothrow @nogc
        {
            assert(data.length < Element.sizeof);
            assert(data.length >= 0);
            element_count += data.length;
            uint k1 = 0;
            final switch (data.length & 3)
            {
            case 3:
                k1 ^= data[2] << 16;
                goto case;
            case 2:
                k1 ^= data[1] << 8;
                goto case;
            case 1:
                k1 ^= data[0];
                h1 ^= shuffle(k1, c1, c2, 15);
                goto case;
            case 0:
            }
        }

        /// Incorporate `element_count` and finalizes the hash.
        void finalize() pure nothrow @nogc
        {
            h1 ^= element_count;
            h1 = fmix(h1);
        }

        /// Returns the hash as an uint value.
        Element get() pure nothrow @nogc
        {
            return h1;
        }

        /// Returns the current hashed value as an ubyte array.
        ubyte[4] getBytes() pure nothrow @nogc
        {
            return cast(typeof(return)) cast(uint[1])[get()];
        }
    }
    else static if (size == 128 && opt == 32)
    {
        private enum uint c1 = 0x239b961b;
        private enum uint c2 = 0xab0e9789;
        private enum uint c3 = 0x38b34ae5;
        private enum uint c4 = 0xa1e38b93;
        private uint h4, h3, h2, h1;

        alias Element = uint[4]; /// The element type for 128-bit implementation.

        this(uint seed4, uint seed3, uint seed2, uint seed1) pure nothrow @nogc
        {
            h4 = seed4;
            h3 = seed3;
            h2 = seed2;
            h1 = seed1;
        }

        this(uint seed) pure nothrow @nogc
        {
            h4 = h3 = h2 = h1 = seed;
        }

        /++
        Adds a single Element of data without increasing element_count.
        Make sure to increase `element_count` by `Element.sizeof` for each call to `putElement`.
        +/
        void putElement(Element block) pure nothrow @nogc
        {
            h1 = update(h1, block[0], h2, c1, c2, 15, 19, 0x561ccd1bU);
            h2 = update(h2, block[1], h3, c2, c3, 16, 17, 0x0bcaa747U);
            h3 = update(h3, block[2], h4, c3, c4, 17, 15, 0x96cd1c35U);
            h4 = update(h4, block[3], h1, c4, c1, 18, 13, 0x32ac3b17U);
        }

        /// Put remainder bytes. This must be called only once after `putElement` and before `finalize`.
        void putRemainder(scope const(ubyte[]) data...) pure nothrow @nogc
        {
            assert(data.length < Element.sizeof);
            assert(data.length >= 0);
            element_count += data.length;
            uint k1 = 0;
            uint k2 = 0;
            uint k3 = 0;
            uint k4 = 0;

            final switch (data.length & 15)
            {
            case 15:
                k4 ^= data[14] << 16;
                goto case;
            case 14:
                k4 ^= data[13] << 8;
                goto case;
            case 13:
                k4 ^= data[12] << 0;
                h4 ^= shuffle(k4, c4, c1, 18);
                goto case;
            case 12:
                k3 ^= data[11] << 24;
                goto case;
            case 11:
                k3 ^= data[10] << 16;
                goto case;
            case 10:
                k3 ^= data[9] << 8;
                goto case;
            case 9:
                k3 ^= data[8] << 0;
                h3 ^= shuffle(k3, c3, c4, 17);
                goto case;
            case 8:
                k2 ^= data[7] << 24;
                goto case;
            case 7:
                k2 ^= data[6] << 16;
                goto case;
            case 6:
                k2 ^= data[5] << 8;
                goto case;
            case 5:
                k2 ^= data[4] << 0;
                h2 ^= shuffle(k2, c2, c3, 16);
                goto case;
            case 4:
                k1 ^= data[3] << 24;
                goto case;
            case 3:
                k1 ^= data[2] << 16;
                goto case;
            case 2:
                k1 ^= data[1] << 8;
                goto case;
            case 1:
                k1 ^= data[0] << 0;
                h1 ^= shuffle(k1, c1, c2, 15);
                goto case;
            case 0:
            }
        }

        /// Incorporate `element_count` and finalizes the hash.
        void finalize() pure nothrow @nogc
        {
            h1 ^= element_count;
            h2 ^= element_count;
            h3 ^= element_count;
            h4 ^= element_count;

            h1 += h2;
            h1 += h3;
            h1 += h4;
            h2 += h1;
            h3 += h1;
            h4 += h1;

            h1 = fmix(h1);
            h2 = fmix(h2);
            h3 = fmix(h3);
            h4 = fmix(h4);

            h1 += h2;
            h1 += h3;
            h1 += h4;
            h2 += h1;
            h3 += h1;
            h4 += h1;
        }

        /// Returns the hash as an uint[4] value.
        Element get() pure nothrow @nogc
        {
            return [h1, h2, h3, h4];
        }

        /// Returns the current hashed value as an ubyte array.
        ubyte[16] getBytes() pure nothrow @nogc
        {
            return cast(typeof(return)) get();
        }
    }
    else static if (size == 128 && opt == 64)
    {
        private enum ulong c1 = 0x87c37b91114253d5;
        private enum ulong c2 = 0x4cf5ad432745937f;
        private ulong h2, h1;

        alias Element = ulong[2]; /// The element type for 128-bit implementation.

        this(ulong seed) pure nothrow @nogc
        {
            h2 = h1 = seed;
        }

        this(ulong seed2, ulong seed1) pure nothrow @nogc
        {
            h2 = seed2;
            h1 = seed1;
        }

        /++
        Adds a single Element of data without increasing `element_count`.
        Make sure to increase `element_count` by `Element.sizeof` for each call to `putElement`.
        +/
        void putElement(Element block) pure nothrow @nogc
        {
            h1 = update(h1, block[0], h2, c1, c2, 31, 27, 0x52dce729U);
            h2 = update(h2, block[1], h1, c2, c1, 33, 31, 0x38495ab5U);
        }

        /// Put remainder bytes. This must be called only once after `putElement` and before `finalize`.
        void putRemainder(scope const(ubyte[]) data...) pure nothrow @nogc
        {
            assert(data.length < Element.sizeof);
            assert(data.length >= 0);
            element_count += data.length;
            ulong k1 = 0;
            ulong k2 = 0;
            final switch (data.length & 15)
            {
            case 15:
                k2 ^= ulong(data[14]) << 48;
                goto case;
            case 14:
                k2 ^= ulong(data[13]) << 40;
                goto case;
            case 13:
                k2 ^= ulong(data[12]) << 32;
                goto case;
            case 12:
                k2 ^= ulong(data[11]) << 24;
                goto case;
            case 11:
                k2 ^= ulong(data[10]) << 16;
                goto case;
            case 10:
                k2 ^= ulong(data[9]) << 8;
                goto case;
            case 9:
                k2 ^= ulong(data[8]) << 0;
                h2 ^= shuffle(k2, c2, c1, 33);
                goto case;
            case 8:
                k1 ^= ulong(data[7]) << 56;
                goto case;
            case 7:
                k1 ^= ulong(data[6]) << 48;
                goto case;
            case 6:
                k1 ^= ulong(data[5]) << 40;
                goto case;
            case 5:
                k1 ^= ulong(data[4]) << 32;
                goto case;
            case 4:
                k1 ^= ulong(data[3]) << 24;
                goto case;
            case 3:
                k1 ^= ulong(data[2]) << 16;
                goto case;
            case 2:
                k1 ^= ulong(data[1]) << 8;
                goto case;
            case 1:
                k1 ^= ulong(data[0]) << 0;
                h1 ^= shuffle(k1, c1, c2, 31);
                goto case;
            case 0:
            }
        }

        /// Incorporate `element_count` and finalizes the hash.
        void finalize() pure nothrow @nogc
        {
            h1 ^= element_count;
            h2 ^= element_count;

            h1 += h2;
            h2 += h1;
            h1 = fmix(h1);
            h2 = fmix(h2);
            h1 += h2;
            h2 += h1;
        }

        /// Returns the hash as an ulong[2] value.
        Element get() pure nothrow @nogc
        {
            return [h1, h2];
        }

        /// Returns the current hashed value as an ubyte array.
        ubyte[16] getBytes() pure nothrow @nogc
        {
            return cast(typeof(return)) get();
        }
    }
    else
    {
        alias Element = char; // This is needed to trigger the following error message.
        static assert(false, "MurmurHash3(" ~ size.stringof ~ ", " ~ opt.stringof ~ ") is not implemented");
    }

    /++
    Pushes an array of elements at once. It is more efficient to push as much data as possible in a single call.
    On platforms that do not support unaligned reads (MIPS or old ARM chips), the compiler may produce slower code to ensure correctness.
    +/
    void putElements(scope const(Element[]) elements...) pure nothrow @nogc
    {
        foreach (const block; elements)
        {
            putElement(block);
        }
        element_count += elements.length * Element.sizeof;
    }

    //-------------------------------------------------------------------------
    // Implementation of the Digest API.
    //-------------------------------------------------------------------------

    private union BufferUnion
    {
        Element block;
        ubyte[Element.sizeof] data;
    }

    private BufferUnion buffer;
    private size_t bufferSize;

    @disable this(this);

    // Initialize
    void start()
    {
        this = this.init;
    }

    /++
    Adds data to the digester. This function can be called many times in a row
    after start but before finish.
    +/
    void put(scope const(ubyte)[] data...) pure nothrow
    {
        // Buffer should never be full while entering this function.
        assert(bufferSize < Element.sizeof);

        // Check if the incoming data doesn't fill up a whole block buffer.
        if (bufferSize + data.length < Element.sizeof)
        {
            buffer.data[bufferSize .. bufferSize + data.length] = data[];
            bufferSize += data.length;
            return;
        }

        // Check if there's some leftover data in the first block buffer, and
        // fill the remaining space first.
        if (bufferSize != 0)
        {
            const bufferLeeway = Element.sizeof - bufferSize;
            buffer.data[bufferSize .. $] = data[0 .. bufferLeeway];
            putElement(buffer.block);
            element_count += Element.sizeof;
            data = data[bufferLeeway .. $];
        }

        // Do main work: process chunks of `Element.sizeof` bytes.
        const numElements = data.length / Element.sizeof;
        const remainderStart = numElements * Element.sizeof;
        version (HaveUnalignedLoads)
        {
            foreach (ref const Element block; cast(const(Element[])) data[0 .. remainderStart])
            {
                putElement(block);
            }
        }
        else
        {
            void processChunks(T)() @trusted
            {
                alias TChunk = T[Element.sizeof / T.sizeof];
                foreach (ref const chunk; cast(const(TChunk[])) data[0 .. remainderStart])
                {
                    static if (T.alignof >= Element.alignof)
                    {
                        putElement(*cast(const(Element)*) chunk.ptr);
                    }
                    else
                    {
                        Element[1] alignedCopy = void;
                        (cast(T[]) alignedCopy)[] = chunk[];
                        putElement(alignedCopy[0]);
                    }
                }
            }

            const startAddress = cast(size_t) data.ptr;
            static if (size >= 64)
            {
                if ((startAddress & 7) == 0)
                {
                    processChunks!ulong();
                    goto L_end;
                }
            }
            static assert(size >= 32);
            if ((startAddress & 3) == 0)
                processChunks!uint();
            else if ((startAddress & 1) == 0)
                processChunks!ushort();
            else
                processChunks!ubyte();

L_end:
        }
        element_count += numElements * Element.sizeof;
        data = data[remainderStart .. $];

        // Now add remaining data to buffer.
        assert(data.length < Element.sizeof);
        bufferSize = data.length;
        buffer.data[0 .. data.length] = data[];
    }

    /++
    Finalizes the computation of the hash and returns the computed value.
    Note that `finish` can be called only once and that no subsequent calls
    to `put` is allowed.
    +/
    ubyte[Element.sizeof] finish() pure nothrow
    {
        auto tail = buffer.data[0 .. bufferSize];
        if (tail.length > 0)
        {
            putRemainder(tail);
        }
        finalize();
        return getBytes();
    }

    //-------------------------------------------------------------------------
    // MurmurHash3 utils
    //-------------------------------------------------------------------------

    private T rotl(T)(T x, uint y)
    in
    {
        import std.traits : isUnsigned;

        static assert(isUnsigned!T);
        debug assert(y >= 0 && y <= (T.sizeof * 8));
    }
    do
    {
        return ((x << y) | (x >> ((T.sizeof * 8) - y)));
    }

    private T shuffle(T)(T k, T c1, T c2, ubyte r1)
    {
        import std.traits : isUnsigned;

        static assert(isUnsigned!T);
        k *= c1;
        k = rotl(k, r1);
        k *= c2;
        return k;
    }

    private T update(T)(ref T h, T k, T mixWith, T c1, T c2, ubyte r1, ubyte r2, T n)
    {
        import std.traits : isUnsigned;

        static assert(isUnsigned!T);
        h ^= shuffle(k, c1, c2, r1);
        h = rotl(h, r2);
        h += mixWith;
        return h * 5 + n;
    }

    private uint fmix(uint h) pure nothrow @nogc
    {
        h ^= h >> 16;
        h *= 0x85ebca6b;
        h ^= h >> 13;
        h *= 0xc2b2ae35;
        h ^= h >> 16;
        return h;
    }

    private ulong fmix(ulong k) pure nothrow @nogc
    {
        k ^= k >> 33;
        k *= 0xff51afd7ed558ccd;
        k ^= k >> 33;
        k *= 0xc4ceb9fe1a85ec53;
        k ^= k >> 33;
        return k;
    }
}


/// The convenient digest template allows for quick hashing of any data.
@safe unittest
{
    ubyte[4] hashed = digest!(MurmurHash3!32)([1, 2, 3, 4]);
    assert(hashed == [0, 173, 69, 68]);
}

/**
One can also hash ubyte data piecewise by instanciating a hasher and call
the 'put' method.
*/
@safe unittest
{
    const(ubyte)[] data1 = [1, 2, 3];
    const(ubyte)[] data2 = [4, 5, 6, 7];
    // The incoming data will be buffered and hashed element by element.
    MurmurHash3!32 hasher;
    hasher.put(data1);
    hasher.put(data2);
    // The call to 'finish' ensures:
    // - the remaining bits are processed
    // - the hash gets finalized
    auto hashed = hasher.finish();
    assert(hashed == [181, 151, 88, 252]);
}

version (StdUnittest)
{
    private auto hash(H, Element = H.Element)(string data)
    {
        H hasher;
        immutable elements = data.length / Element.sizeof;
        hasher.putElements(cast(const(Element)[]) data[0 .. elements * Element.sizeof]);
        hasher.putRemainder(cast(const(ubyte)[]) data[elements * Element.sizeof .. $]);
        hasher.finalize();
        return hasher.getBytes();
    }

    private void checkResult(H)(in string[string] groundtruth)
    {
        foreach (data, expectedHash; groundtruth)
        {
            assert(data.digest!H.toHexString() == expectedHash);
            assert(data.hash!H.toHexString() == expectedHash);
            H hasher;
            foreach (element; data)
            {
                hasher.put(element);
            }
            assert(hasher.finish.toHexString() == expectedHash);
        }
    }
}

@safe unittest
{
    // dfmt off
    checkResult!(MurmurHash3!32)([
        "" : "00000000",
        "a" : "B269253C",
        "ab" : "5FD7BF9B",
        "abc" : "FA93DDB3",
        "abcd" : "6A67ED43",
        "abcde" : "F69A9BE8",
        "abcdef" : "85C08161",
        "abcdefg" : "069B3C88",
        "abcdefgh" : "C4CCDD49",
        "abcdefghi" : "F0061442",
        "abcdefghij" : "91779288",
        "abcdefghijk" : "DF253B5F",
        "abcdefghijkl" : "273D6FA3",
        "abcdefghijklm" : "1B1612F2",
        "abcdefghijklmn" : "F06D52F8",
        "abcdefghijklmno" : "D2F7099D",
        "abcdefghijklmnop" : "ED9162E7",
        "abcdefghijklmnopq" : "4A5E65B6",
        "abcdefghijklmnopqr" : "94A819C2",
        "abcdefghijklmnopqrs" : "C15BBF85",
        "abcdefghijklmnopqrst" : "9A711CBE",
        "abcdefghijklmnopqrstu" : "ABE7195A",
        "abcdefghijklmnopqrstuv" : "C73CB670",
        "abcdefghijklmnopqrstuvw" : "1C4D1EA5",
        "abcdefghijklmnopqrstuvwx" : "3939F9B0",
        "abcdefghijklmnopqrstuvwxy" : "1A568338",
        "abcdefghijklmnopqrstuvwxyz" : "6D034EA3"]);
    // dfmt on
}

@safe unittest
{
    // dfmt off
    checkResult!(MurmurHash3!(128,32))([
        "" : "00000000000000000000000000000000",
        "a" : "3C9394A71BB056551BB056551BB05655",
        "ab" : "DF5184151030BE251030BE251030BE25",
        "abc" : "D1C6CD75A506B0A2A506B0A2A506B0A2",
        "abcd" : "AACCB6962EC6AF452EC6AF452EC6AF45",
        "abcde" : "FB2E40C5BCC5245D7701725A7701725A",
        "abcdef" : "0AB97CE12127AFA1F9DFBEA9F9DFBEA9",
        "abcdefg" : "D941B590DE3A86092869774A2869774A",
        "abcdefgh" : "3611F4AE8714B1AD92806CFA92806CFA",
        "abcdefghi" : "1C8C05AD6F590622107DD2147C4194DD",
        "abcdefghij" : "A72ED9F50E90379A2AAA92C77FF12F69",
        "abcdefghijk" : "DDC9C8A01E111FCA2DF1FE8257975EBD",
        "abcdefghijkl" : "FE038573C02482F4ADDFD42753E58CD2",
        "abcdefghijklm" : "15A23AC1ECA1AEDB66351CF470DE2CD9",
        "abcdefghijklmn" : "8E11EC75D71F5D60F4456F944D89D4F1",
        "abcdefghijklmno" : "691D6DEEAED51A4A5714CE84A861A7AD",
        "abcdefghijklmnop" : "2776D29F5612B990218BCEE445BA93D1",
        "abcdefghijklmnopq" : "D3A445046F5C51642ADC6DD99D07111D",
        "abcdefghijklmnopqr" : "AA5493A0DA291D966A9E7128585841D9",
        "abcdefghijklmnopqrs" : "281B6A4F9C45B9BFC3B77850930F2C20",
        "abcdefghijklmnopqrst" : "19342546A8216DB62873B49E545DCB1F",
        "abcdefghijklmnopqrstu" : "A6C0F30D6C738620E7B9590D2E088D99",
        "abcdefghijklmnopqrstuv" : "A7D421D9095CDCEA393CBBA908342384",
        "abcdefghijklmnopqrstuvw" : "C3A93D572B014949317BAD7EE809158F",
        "abcdefghijklmnopqrstuvwx" : "802381D77956833791F87149326E4801",
        "abcdefghijklmnopqrstuvwxy" : "0AC619A5302315755A80D74ADEFAA842",
        "abcdefghijklmnopqrstuvwxyz" : "1306343E662F6F666E56F6172C3DE344"]);
    // dfmt on
}

@safe unittest
{
    // dfmt off
    checkResult!(MurmurHash3!(128,64))([
        "" : "00000000000000000000000000000000",
        "a" : "897859F6655555855A890E51483AB5E6",
        "ab" : "2E1BED16EA118B93ADD4529B01A75EE6",
        "abc" : "6778AD3F3F3F96B4522DCA264174A23B",
        "abcd" : "4FCD5646D6B77BB875E87360883E00F2",
        "abcde" : "B8BB96F491D036208CECCF4BA0EEC7C5",
        "abcdef" : "55BFA3ACBF867DE45C842133990971B0",
        "abcdefg" : "99E49EC09F2FCDA6B6BB55B13AA23A1C",
        "abcdefgh" : "028CEF37B00A8ACCA14069EB600D8948",
        "abcdefghi" : "64793CF1CFC0470533E041B7F53DB579",
        "abcdefghij" : "998C2F770D5BC1B6C91A658CDC854DA2",
        "abcdefghijk" : "029D78DFB8D095A871E75A45E2317CBB",
        "abcdefghijkl" : "94E17AE6B19BF38E1C62FF7232309E1F",
        "abcdefghijklm" : "73FAC0A78D2848167FCCE70DFF7B652E",
        "abcdefghijklmn" : "E075C3F5A794D09124336AD2276009EE",
        "abcdefghijklmno" : "FB2F0C895124BE8A612A969C2D8C546A",
        "abcdefghijklmnop" : "23B74C22A33CCAC41AEB31B395D63343",
        "abcdefghijklmnopq" : "57A6BD887F746475E40D11A19D49DAEC",
        "abcdefghijklmnopqr" : "508A7F90EC8CF0776BC7005A29A8D471",
        "abcdefghijklmnopqrs" : "886D9EDE23BC901574946FB62A4D8AA6",
        "abcdefghijklmnopqrst" : "F1E237F926370B314BD016572AF40996",
        "abcdefghijklmnopqrstu" : "3CC9FF79E268D5C9FB3C9BE9C148CCD7",
        "abcdefghijklmnopqrstuv" : "56F8ABF430E388956DA9F4A8741FDB46",
        "abcdefghijklmnopqrstuvw" : "8E234F9DBA0A4840FFE9541CEBB7BE83",
        "abcdefghijklmnopqrstuvwx" : "F72CDED40F96946408F22153A3CF0F79",
        "abcdefghijklmnopqrstuvwxy" : "0F96072FA4CBE771DBBD9E398115EEED",
        "abcdefghijklmnopqrstuvwxyz" : "A94A6F517E9D9C7429D5A7B6899CADE9"]);
    // dfmt on
}

@safe unittest
{
    // Pushing unaligned data and making sure the result is still coherent.
    void testUnalignedHash(H)()
    {
        immutable ubyte[1028] data = 0xAC;
        immutable alignedHash = digest!H(data[0 .. 1024]);
        foreach (i; 1 .. 5)
        {
            immutable unalignedHash = digest!H(data[i .. 1024 + i]);
            assert(alignedHash == unalignedHash);
        }
    }

    testUnalignedHash!(MurmurHash3!32)();
    testUnalignedHash!(MurmurHash3!(128, 32))();
    testUnalignedHash!(MurmurHash3!(128, 64))();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /**
 * This module describes the digest APIs used in Phobos. All digests follow
 * these APIs. Additionally, this module contains useful helper methods which
 * can be used with every digest type.
 *
$(SCRIPT inhibitQuickIndex = 1;)

$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Category) $(TH Functions)
)
$(TR $(TDNW Template API) $(TD $(MYREF isDigest) $(MYREF DigestType) $(MYREF hasPeek)
  $(MYREF hasBlockSize)
  $(MYREF ExampleDigest) $(MYREF digest) $(MYREF hexDigest) $(MYREF makeDigest)
)
)
$(TR $(TDNW OOP API) $(TD $(MYREF Digest)
)
)
$(TR $(TDNW Helper functions) $(TD $(MYREF toHexString) $(MYREF secureEqual))
)
$(TR $(TDNW Implementation helpers) $(TD $(MYREF digestLength) $(MYREF WrapperDigest))
)
)
)

 * APIs:
 * There are two APIs for digests: The template API and the OOP API. The template API uses structs
 * and template helpers like $(LREF isDigest). The OOP API implements digests as classes inheriting
 * the $(LREF Digest) interface. All digests are named so that the template API struct is called "$(B x)"
 * and the OOP API class is called "$(B x)Digest". For example we have `MD5` <--> `MD5Digest`,
 * `CRC32` <--> `CRC32Digest`, etc.
 *
 * The template API is slightly more efficient. It does not have to allocate memory dynamically,
 * all memory is allocated on the stack. The OOP API has to allocate in the finish method if no
 * buffer was provided. If you provide a buffer to the OOP APIs finish function, it doesn't allocate,
 * but the $(LREF Digest) classes still have to be created using `new` which allocates them using the GC.
 *
 * The OOP API is useful to change the digest function and/or digest backend at 'runtime'. The benefit here
 * is that switching e.g. Phobos MD5Digest and an OpenSSLMD5Digest implementation is ABI compatible.
 *
 * If just one specific digest type and backend is needed, the template API is usually a good fit.
 * In this simplest case, the template API can even be used without templates: Just use the "$(B x)" structs
 * directly.
 *
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Johannes Pfau
 *
 * Source:    $(PHOBOSSRC std/digest/package.d)
 *
 * CTFE:
 * Digests do not work in CTFE
 *
 * TODO:
 * Digesting single bits (as opposed to bytes) is not implemented. This will be done as another
 * template constraint helper (hasBitDigesting!T) and an additional interface (BitDigest)
 */
/*          Copyright Johannes Pfau 2012.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module std.digest;

public import std.ascii : LetterCase;
import std.meta : allSatisfy;
import std.range.primitives;
import std.traits;


///
@system unittest
{
    import std.digest.crc;

    //Simple example
    char[8] hexHash = hexDigest!CRC32("The quick brown fox jumps over the lazy dog");
    assert(hexHash == "39A34F41");

    //Simple example, using the API manually
    CRC32 context = makeDigest!CRC32();
    context.put(cast(ubyte[])"The quick brown fox jumps over the lazy dog");
    ubyte[4] hash = context.finish();
    assert(toHexString(hash) == "39A34F41");
}

///
@system unittest
{
    //Generating the hashes of a file, idiomatic D way
    import std.digest.crc, std.digest.md, std.digest.sha;
    import std.stdio;

    // Digests a file and prints the result.
    void digestFile(Hash)(string filename)
    if (isDigest!Hash)
    {
        auto file = File(filename);
        auto result = digest!Hash(file.byChunk(4096 * 1024));
        writefln("%s (%s) = %s", Hash.stringof, filename, toHexString(result));
    }

    void main(string[] args)
    {
        foreach (name; args[1 .. $])
        {
            digestFile!MD5(name);
            digestFile!SHA1(name);
            digestFile!CRC32(name);
        }
    }
}
///
@system unittest
{
    //Generating the hashes of a file using the template API
    import std.digest.crc, std.digest.md, std.digest.sha;
    import std.stdio;
    // Digests a file and prints the result.
    void digestFile(Hash)(ref Hash hash, string filename)
    if (isDigest!Hash)
    {
        File file = File(filename);

        //As digests imlement OutputRange, we could use std.algorithm.copy
        //Let's do it manually for now
        foreach (buffer; file.byChunk(4096 * 1024))
            hash.put(buffer);

        auto result = hash.finish();
        writefln("%s (%s) = %s", Hash.stringof, filename, toHexString(result));
    }

    void uMain(string[] args)
    {
        MD5 md5;
        SHA1 sha1;
        CRC32 crc32;

        md5.start();
        sha1.start();
        crc32.start();

        foreach (arg; args[1 .. $])
        {
            digestFile(md5, arg);
            digestFile(sha1, arg);
            digestFile(crc32, arg);
        }
    }
}

///
@system unittest
{
    import std.digest.crc, std.digest.md, std.digest.sha;
    import std.stdio;

    // Digests a file and prints the result.
    void digestFile(Digest hash, string filename)
    {
        File file = File(filename);

        //As digests implement OutputRange, we could use std.algorithm.copy
        //Let's do it manually for now
        foreach (buffer; file.byChunk(4096 * 1024))
          hash.put(buffer);

        ubyte[] result = hash.finish();
        writefln("%s (%s) = %s", typeid(hash).toString(), filename, toHexString(result));
    }

    void umain(string[] args)
    {
        auto md5 = new MD5Digest();
        auto sha1 = new SHA1Digest();
        auto crc32 = new CRC32Digest();

        foreach (arg; args[1 .. $])
        {
          digestFile(md5, arg);
          digestFile(sha1, arg);
          digestFile(crc32, arg);
        }
    }
}

version (StdDdoc)
    version = ExampleDigest;

version (ExampleDigest)
{
    /**
     * This documents the general structure of a Digest in the template API.
     * All digest implementations should implement the following members and therefore pass
     * the $(LREF isDigest) test.
     *
     * Note:
     * $(UL
     * $(LI A digest must be a struct (value type) to pass the $(LREF isDigest) test.)
     * $(LI A digest passing the $(LREF isDigest) test is always an `OutputRange`)
     * )
     */
    struct ExampleDigest
    {
        public:
            /**
             * Use this to feed the digest with data.
             * Also implements the $(REF isOutputRange, std,range,primitives)
             * interface for `ubyte` and `const(ubyte)[]`.
             * The following usages of `put` must work for any type which
             * passes $(LREF isDigest):
             * Example:
             * ----
             * ExampleDigest dig;
             * dig.put(cast(ubyte) 0); //single ubyte
             * dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
             * ubyte[10] buf;
             * dig.put(buf); //buffer
             * ----
             */
            @trusted void put(scope const(ubyte)[] data...)
            {

            }

            /**
             * This function is used to (re)initialize the digest.
             * It must be called before using the digest and it also works as a 'reset' function
             * if the digest has already processed data.
             */
            @trusted void start()
            {

            }

            /**
             * The finish function returns the final hash sum and resets the Digest.
             *
             * Note:
             * The actual type returned by finish depends on the digest implementation.
             * `ubyte[16]` is just used as an example. It is guaranteed that the type is a
             * static array of ubytes.
             *
             * $(UL
             * $(LI Use $(LREF DigestType) to obtain the actual return type.)
             * $(LI Use $(LREF digestLength) to obtain the length of the ubyte array.)
             * )
             */
            @trusted ubyte[16] finish()
            {
                return (ubyte[16]).init;
            }
    }
}

///
@system unittest
{
    //Using the OutputRange feature
    import std.algorithm.mutation : copy;
    import std.digest.md;
    import std.range : repeat;

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    auto ctx = makeDigest!MD5();
    copy(oneMillionRange, &ctx); //Note: You must pass a pointer to copy!
    assert(ctx.finish().toHexString() == "7707D6AE4E027C70EEA2A935C2296F21");
}

/**
 * Use this to check if a type is a digest. See $(LREF ExampleDigest) to see what
 * a type must provide to pass this check.
 *
 * Note:
 * This is very useful as a template constraint (see examples)
 *
 * BUGS:
 * $(UL
 * $(LI Does not yet verify that put takes scope parameters.)
 * $(LI Should check that finish() returns a ubyte[num] array)
 * )
 */
template isDigest(T)
{
    import std.range : isOutputRange;
    enum bool isDigest = isOutputRange!(T, const(ubyte)[]) && isOutputRange!(T, ubyte) &&
        is(T == struct) &&
        is(typeof(
        {
            T dig = void; //Can define
            dig.put(cast(ubyte) 0, cast(ubyte) 0); //varags
            dig.start(); //has start
            auto value = dig.finish(); //has finish
        }));
}

///
@system unittest
{
    import std.digest.crc;
    static assert(isDigest!CRC32);
}
///
@system unittest
{
    import std.digest.crc;
    void myFunction(T)()
    if (isDigest!T)
    {
        T dig;
        dig.start();
        auto result = dig.finish();
    }
    myFunction!CRC32();
}

/**
 * Use this template to get the type which is returned by a digest's $(LREF finish) method.
 */
template DigestType(T)
{
    static if (isDigest!T)
    {
        alias DigestType =
            ReturnType!(typeof(
            {
                T dig = void;
                return dig.finish();
            }));
    }
    else
        static assert(false, T.stringof ~ " is not a digest! (fails isDigest!T)");
}

///
@system unittest
{
    import std.digest.crc;
    assert(is(DigestType!(CRC32) == ubyte[4]));
}
///
@system unittest
{
    import std.digest.crc;
    CRC32 dig;
    dig.start();
    DigestType!CRC32 result = dig.finish();
}

/**
 * Used to check if a digest supports the `peek` method.
 * Peek has exactly the same function signatures as finish, but it doesn't reset
 * the digest's internal state.
 *
 * Note:
 * $(UL
 * $(LI This is very useful as a template constraint (see examples))
 * $(LI This also checks if T passes $(LREF isDigest))
 * )
 */
template hasPeek(T)
{
    enum bool hasPeek = isDigest!T &&
        is(typeof(
        {
            T dig = void; //Can define
            DigestType!T val = dig.peek();
        }));
}

///
@system unittest
{
    import std.digest.crc, std.digest.md;
    assert(!hasPeek!(MD5));
    assert(hasPeek!CRC32);
}
///
@system unittest
{
    import std.digest.crc;
    void myFunction(T)()
    if (hasPeek!T)
    {
        T dig;
        dig.start();
        auto result = dig.peek();
    }
    myFunction!CRC32();
}

/**
 * Checks whether the digest has a `blockSize` member, which contains the
 * digest's internal block size in bits. It is primarily used by $(REF HMAC, std,digest,hmac).
 */

template hasBlockSize(T)
if (isDigest!T)
{
    enum bool hasBlockSize = __traits(compiles, { size_t blockSize = T.blockSize; });
}

///
@system unittest
{
    import std.digest.hmac, std.digest.md;
    static assert(hasBlockSize!MD5        && MD5.blockSize      == 512);
    static assert(hasBlockSize!(HMAC!MD5) && HMAC!MD5.blockSize == 512);
}

package template isDigestibleRange(Range)
{
    import std.digest.md;
    import std.range : isInputRange, ElementType;
    enum bool isDigestibleRange = isInputRange!Range && is(typeof(
          {
          MD5 ha; //Could use any conformant hash
          ElementType!Range val;
          ha.put(val);
          }));
}

/**
 * This is a convenience function to calculate a hash using the template API.
 * Every digest passing the $(LREF isDigest) test can be used with this function.
 *
 * Params:
 *  range= an `InputRange` with `ElementType` `ubyte`, `ubyte[]` or `ubyte[num]`
 */
DigestType!Hash digest(Hash, Range)(auto ref Range range)
if (!isArray!Range
    && isDigestibleRange!Range)
{
    Hash hash;
    hash.start();
    alias E = ElementType!Range; // Not necessarily ubyte. Could be ubyte[N] or ubyte[] or something w/alias this.
    static if (!(__traits(isScalar, E) && E.sizeof == 1))
    {
        foreach (e; range)
            hash.put(e);
        return hash.finish();
    }
    else
    {
        static if (hasBlockSize!Hash)
            enum bufferBytes = Hash.blockSize >= (8192 * 8) ? 8192 : Hash.blockSize <= 64 ? 8 : (Hash.blockSize / 8);
        else
            enum bufferBytes = 8;
        ubyte[bufferBytes] buffer = void;
        static if (isRandomAccessRange!Range && hasLength!Range)
        {
            const end = range.length;
            size_t i = 0;
            while (end - i >= buffer.length)
            {
                foreach (ref e; buffer)
                    e = range[i++];
                hash.put(buffer);
            }
            if (const remaining = end - i)
            {
                foreach (ref e; buffer[0 .. remaining])
                    e = range[i++];
                hash.put(buffer[0 .. remaining]);
            }
            return hash.finish();
        }
        else
        {
            for (;;)
            {
                size_t n = buffer.length;
                foreach (i, ref e; buffer)
                {
                    if (range.empty)
                    {
                        n = i;
                        break;
                    }
                    e = range.front;
                    range.popFront();
                }
                if (n)
                    hash.put(buffer[0 .. n]);
                if (n != buffer.length)
                    return hash.finish();
            }
        }
    }
}

///
@system unittest
{
    import std.digest.md;
    import std.range : repeat;
    auto testRange = repeat!ubyte(cast(ubyte)'a', 100);
    auto md5 = digest!MD5(testRange);
}

/**
 * This overload of the digest function handles arrays.
 *
 * Params:
 *  data= one or more arrays of any type
 */
DigestType!Hash digest(Hash, T...)(scope const T data)
if (allSatisfy!(isArray, typeof(data)))
{
    Hash hash;
    hash.start();
    foreach (datum; data)
        hash.put(cast(const(ubyte[]))datum);
    return hash.finish();
}

///
@system unittest
{
    import std.digest.crc, std.digest.md, std.digest.sha;
    auto md5   = digest!MD5(  "The quick brown fox jumps over the lazy dog");
    auto sha1  = digest!SHA1( "The quick brown fox jumps over the lazy dog");
    auto crc32 = digest!CRC32("The quick brown fox jumps over the lazy dog");
    assert(toHexString(crc32) == "39A34F41");
}

///
@system unittest
{
    import std.digest.crc;
    auto crc32 = digest!CRC32("The quick ", "brown ", "fox jumps over the lazy dog");
    assert(toHexString(crc32) == "39A34F41");
}

/**
 * This is a convenience function similar to $(LREF digest), but it returns the string
 * representation of the hash. Every digest passing the $(LREF isDigest) test can be used with this
 * function.
 *
 * Params:
 *  order= the order in which the bytes are processed (see $(LREF toHexString))
 *  range= an `InputRange` with `ElementType` `ubyte`, `ubyte[]` or `ubyte[num]`
 */
char[digestLength!(Hash)*2] hexDigest(Hash, Order order = Order.increasing, Range)(ref Range range)
if (!isArray!Range && isDigestibleRange!Range)
{
    return toHexString!order(digest!Hash(range));
}

///
@system unittest
{
    import std.digest.md;
    import std.range : repeat;
    auto testRange = repeat!ubyte(cast(ubyte)'a', 100);
    assert(hexDigest!MD5(testRange) == "36A92CC94A9E0FA21F625F8BFB007ADF");
}

/**
 * This overload of the hexDigest function handles arrays.
 *
 * Params:
 *  order= the order in which the bytes are processed (see $(LREF toHexString))
 *  data= one or more arrays of any type
 */
char[digestLength!(Hash)*2] hexDigest(Hash, Order order = Order.increasing, T...)(scope const T data)
if (allSatisfy!(isArray, typeof(data)))
{
    return toHexString!order(digest!Hash(data));
}

///
@system unittest
{
    import std.digest.crc;
    assert(hexDigest!(CRC32, Order.decreasing)("The quick brown fox jumps over the lazy dog") == "414FA339");
}
///
@system unittest
{
    import std.digest.crc;
    assert(hexDigest!(CRC32, Order.decreasing)("The quick ", "brown ", "fox jumps over the lazy dog") == "414FA339");
}

/**
 * This is a convenience function which returns an initialized digest, so it's not necessary to call
 * start manually.
 */
Hash makeDigest(Hash)()
{
    Hash hash;
    hash.start();
    return hash;
}

///
@system unittest
{
    import std.digest.md;
    auto md5 = makeDigest!MD5();
    md5.put(0);
    assert(toHexString(md5.finish()) == "93B885ADFE0DA089CDF634904FD59F71");
}

/*+*************************** End of template part, welcome to OOP land **************************/

/**
 * This describes the OOP API. To understand when to use the template API and when to use the OOP API,
 * see the module documentation at the top of this page.
 *
 * The Digest interface is the base interface which is implemented by all digests.
 *
 * Note:
 * A Digest implementation is always an `OutputRange`
 */
interface Digest
{
    public:
        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         *
         * Example:
         * ----
         * void test(Digest dig)
         * {
         *     dig.put(cast(ubyte) 0); //single ubyte
         *     dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
         *     ubyte[10] buf;
         *     dig.put(buf); //buffer
         * }
         * ----
         */
        @trusted nothrow void put(scope const(ubyte)[] data...);

        /**
         * Resets the internal state of the digest.
         * Note:
         * $(LREF finish) calls this internally, so it's not necessary to call
         * `reset` manually after a call to $(LREF finish).
         */
        @trusted nothrow void reset();

        /**
         * This is the length in bytes of the hash value which is returned by $(LREF finish).
         * It's also the required size of a buffer passed to $(LREF finish).
         */
        @trusted nothrow @property size_t length() const;

        /**
         * The finish function returns the hash value. It takes an optional buffer to copy the data
         * into. If a buffer is passed, it must be at least $(LREF length) bytes big.
         */
        @trusted nothrow ubyte[] finish();
        ///ditto
        nothrow ubyte[] finish(ubyte[] buf);
        // https://issues.dlang.org/show_bug.cgi?id=6549
        /*in
        {
            assert(buf.length >= this.length);
        }*/

        /**
         * This is a convenience function to calculate the hash of a value using the OOP API.
         */
        final @trusted nothrow ubyte[] digest(scope const(void[])[] data...)
        {
            this.reset();
            foreach (datum; data)
                this.put(cast(ubyte[]) datum);
            return this.finish();
        }
}

///
@system unittest
{
    //Using the OutputRange feature
    import std.algorithm.mutation : copy;
    import std.digest.md;
    import std.range : repeat;

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    auto ctx = new MD5Digest();
    copy(oneMillionRange, ctx);
    assert(ctx.finish().toHexString() == "7707D6AE4E027C70EEA2A935C2296F21");
}

///
@system unittest
{
    import std.digest.crc, std.digest.md, std.digest.sha;
    ubyte[] md5   = (new MD5Digest()).digest("The quick brown fox jumps over the lazy dog");
    ubyte[] sha1  = (new SHA1Digest()).digest("The quick brown fox jumps over the lazy dog");
    ubyte[] crc32 = (new CRC32Digest()).digest("The quick brown fox jumps over the lazy dog");
    assert(crcHexString(crc32) == "414FA339");
}

///
@system unittest
{
    import std.digest.crc;
    ubyte[] crc32 = (new CRC32Digest()).digest("The quick ", "brown ", "fox jumps over the lazy dog");
    assert(crcHexString(crc32) == "414FA339");
}

@system unittest
{
    import std.range : isOutputRange;
    assert(!isDigest!(Digest));
    assert(isOutputRange!(Digest, ubyte));
}

///
@system unittest
{
    void test(Digest dig)
    {
        dig.put(cast(ubyte) 0); //single ubyte
        dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
        ubyte[10] buf;
        dig.put(buf); //buffer
    }
}

/*+*************************** End of OOP part, helper functions follow ***************************/

/**
 * See $(LREF toHexString)
 */
enum Order : bool
{
    increasing, ///
    decreasing ///
}

///
@safe unittest
{
    import std.digest.crc : CRC32;

    auto crc32 = digest!CRC32("The quick ", "brown ", "fox jumps over the lazy dog");
    assert(crc32.toHexString!(Order.decreasing) == "414FA339");
    assert(crc32.toHexString!(LetterCase.lower, Order.decreasing) == "414fa339");
}


/**
 * Used to convert a hash value (a static or dynamic array of ubytes) to a string.
 * Can be used with the OOP and with the template API.
 *
 * The additional order parameter can be used to specify the order of the input data.
 * By default the data is processed in increasing order, starting at index 0. To process it in the
 * opposite order, pass Order.decreasing as a parameter.
 *
 * The additional letterCase parameter can be used to specify the case of the output data.
 * By default the output is in upper case. To change it to the lower case
 * pass LetterCase.lower as a parameter.
 *
 * Note:
 * The function overloads returning a string allocate their return values
 * using the GC. The versions returning static arrays use pass-by-value for
 * the return value, effectively avoiding dynamic allocation.
 */
char[num*2] toHexString(Order order = Order.increasing, size_t num, LetterCase letterCase = LetterCase.upper)
(const ubyte[num] digest)
{

    char[num*2] result;
    size_t i;
    toHexStringImpl!(order, letterCase)(digest, result);
    return result;
}

///ditto
char[num*2] toHexString(LetterCase letterCase, Order order = Order.increasing, size_t num)(in ubyte[num] digest)
{
    return toHexString!(order, num, letterCase)(digest);
}

///ditto
string toHexString(Order order = Order.increasing, LetterCase letterCase = LetterCase.upper)
(in ubyte[] digest)
{
    auto result = new char[digest.length*2];
    toHexStringImpl!(order, letterCase)(digest, result);
    import std.exception : assumeUnique;
    // memory was just created, so casting to immutable is safe
    return () @trusted { return assumeUnique(result); }();
}

///ditto
string toHexString(LetterCase letterCase, Order order = Order.increasing)(in ubyte[] digest)
{
    return toHexString!(order, letterCase)(digest);
}

//For more example unittests, see Digest.digest, digest

///
@safe unittest
{
    import std.digest.crc;
    //Test with template API:
    auto crc32 = digest!CRC32("The quick ", "brown ", "fox jumps over the lazy dog");
    //Lower case variant:
    assert(toHexString!(LetterCase.lower)(crc32) == "39a34f41");
    //Usually CRCs are printed in this order, though:
    assert(toHexString!(Order.decreasing)(crc32) == "414FA339");
    assert(toHexString!(LetterCase.lower, Order.decreasing)(crc32) == "414fa339");
}

///
@safe unittest
{
    import std.digest.crc;
    // With OOP API
    auto crc32 = (new CRC32Digest()).digest("The quick ", "brown ", "fox jumps over the lazy dog");
    //Usually CRCs are printed in this order, though:
    assert(toHexString!(Order.decreasing)(crc32) == "414FA339");
}

@safe unittest
{
    ubyte[16] data;
    assert(toHexString(data) == "00000000000000000000000000000000");

    assert(toHexString(cast(ubyte[4])[42, 43, 44, 45]) == "2A2B2C2D");
    assert(toHexString(cast(ubyte[])[42, 43, 44, 45]) == "2A2B2C2D");
    assert(toHexString!(Order.decreasing)(cast(ubyte[4])[42, 43, 44, 45]) == "2D2C2B2A");
    assert(toHexString!(Order.decreasing, LetterCase.lower)(cast(ubyte[4])[42, 43, 44, 45]) == "2d2c2b2a");
    assert(toHexString!(Order.decreasing)(cast(ubyte[])[42, 43, 44, 45]) == "2D2C2B2A");
}

/*+*********************** End of public helper part, private helpers follow ***********************/

/*
 * Used to convert from a ubyte[] slice to a ref ubyte[N].
 * This helper is used internally in the WrapperDigest template to wrap the template API's
 * finish function.
 */
ref T[N] asArray(size_t N, T)(ref T[] source, string errorMsg = "")
{
     assert(source.length >= N, errorMsg);
     return *cast(T[N]*) source.ptr;
}

/*
 * Fill in a preallocated buffer with the ASCII hex representation from a byte buffer
 */
private void toHexStringImpl(Order order, LetterCase letterCase, BB, HB)
(scope const ref BB byteBuffer, ref HB hexBuffer){
    static if (letterCase == LetterCase.upper)
    {
        import std.ascii : hexDigits = hexDigits;
    }
    else
    {
        import std.ascii : hexDigits = lowerHexDigits;
    }

    size_t i;
    static if (order == Order.increasing)
    {
        foreach (u; byteBuffer)
        {
            hexBuffer[i++] = hexDigits[u >> 4];
            hexBuffer[i++] = hexDigits[u & 15];
        }
    }
    else
    {
        size_t j = byteBuffer.length -1;
        while (i < byteBuffer.length*2)
        {
            hexBuffer[i++] = hexDigits[byteBuffer[j] >> 4];
            hexBuffer[i++] = hexDigits[byteBuffer[j] & 15];
            j--;
        }
    }
}


/*
 * Returns the length (in bytes) of the hash value produced by T.
 */
template digestLength(T)
if (isDigest!T)
{
    enum size_t digestLength = (ReturnType!(T.finish)).length;
}

@safe pure nothrow @nogc
unittest
{
    import std.digest.md : MD5;
    import std.digest.sha : SHA1, SHA256, SHA512;
    assert(digestLength!MD5 == 16);
    assert(digestLength!SHA1 == 20);
    assert(digestLength!SHA256 == 32);
    assert(digestLength!SHA512 == 64);
}

/**
 * Wraps a template API hash struct into a Digest interface.
 * Modules providing digest implementations will usually provide
 * an alias for this template (e.g. MD5Digest, SHA1Digest, ...).
 */
class WrapperDigest(T)
if (isDigest!T) : Digest
{
    protected:
        T _digest;

    public final:
        /**
         * Initializes the digest.
         */
        this()
        {
            _digest.start();
        }

        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         */
        @trusted nothrow void put(scope const(ubyte)[] data...)
        {
            _digest.put(data);
        }

        /**
         * Resets the internal state of the digest.
         * Note:
         * $(LREF finish) calls this internally, so it's not necessary to call
         * `reset` manually after a call to $(LREF finish).
         */
        @trusted nothrow void reset()
        {
            _digest.start();
        }

        /**
         * This is the length in bytes of the hash value which is returned by $(LREF finish).
         * It's also the required size of a buffer passed to $(LREF finish).
         */
        @trusted nothrow @property size_t length() const pure
        {
            return digestLength!T;
        }

        /**
         * The finish function returns the hash value. It takes an optional buffer to copy the data
         * into. If a buffer is passed, it must have a length at least $(LREF length) bytes.
         *
         * Example:
         * --------
         *
         * import std.digest.md;
         * ubyte[16] buf;
         * auto hash = new WrapperDigest!MD5();
         * hash.put(cast(ubyte) 0);
         * auto result = hash.finish(buf[]);
         * //The result is now in result (and in buf). If you pass a buffer which is bigger than
         * //necessary, result will have the correct length, but buf will still have it's original
         * //length
         * --------
         */
        nothrow ubyte[] finish(ubyte[] buf)
        in
        {
            assert(buf.length >= this.length, "Given buffer is smaller than the local buffer.");
        }
        do
        {
            enum string msg = "Buffer needs to be at least " ~ digestLength!(T).stringof ~ " bytes " ~
                "big, check " ~ typeof(this).stringof ~ ".length!";
            asArray!(digestLength!T)(buf, msg) = _digest.finish();
            return buf[0 .. digestLength!T];
        }

        ///ditto
        @trusted nothrow ubyte[] finish()
        {
            enum len = digestLength!T;
            auto buf = new ubyte[len];
            asArray!(digestLength!T)(buf) = _digest.finish();
            return buf;
        }

        version (StdDdoc)
        {
            /**
             * Works like `finish` but does not reset the internal state, so it's possible
             * to continue putting data into this WrapperDigest after a call to peek.
             *
             * These functions are only available if `hasPeek!T` is true.
             */
            @trusted ubyte[] peek(ubyte[] buf) const;
            ///ditto
            @trusted ubyte[] peek() const;
        }
        else static if (hasPeek!T)
        {
            @trusted ubyte[] peek(ubyte[] buf) const
            in
            {
                assert(buf.length >= this.length, "Given buffer is smaller than the local buffer.");
            }
            do
            {
                enum string msg = "Buffer needs to be at least " ~ digestLength!(T).stringof ~ " bytes " ~
                    "big, check " ~ typeof(this).stringof ~ ".length!";
                asArray!(digestLength!T)(buf, msg) = _digest.peek();
                return buf[0 .. digestLength!T];
            }

            @trusted ubyte[] peek() const
            {
                enum len = digestLength!T;
                auto buf = new ubyte[len];
                asArray!(digestLength!T)(buf) = _digest.peek();
                return buf;
            }
        }
}

///
@system unittest
{
    import std.digest.md;
    //Simple example
    auto hash = new WrapperDigest!MD5();
    hash.put(cast(ubyte) 0);
    auto result = hash.finish();
}

///
@system unittest
{
    //using a supplied buffer
    import std.digest.md;
    ubyte[16] buf;
    auto hash = new WrapperDigest!MD5();
    hash.put(cast(ubyte) 0);
    auto result = hash.finish(buf[]);
    //The result is now in result (and in buf). If you pass a buffer which is bigger than
    //necessary, result will have the correct length, but buf will still have it's original
    //length
}

@safe unittest
{
    // Test peek & length
    import std.digest.crc;
    auto hash = new WrapperDigest!CRC32();
    assert(hash.length == 4);
    hash.put(cast(const(ubyte[]))"The quick brown fox jumps over the lazy dog");
    assert(hash.peek().toHexString() == "39A34F41");
    ubyte[5] buf;
    assert(hash.peek(buf).toHexString() == "39A34F41");
}

/**
 * Securely compares two digest representations while protecting against timing
 * attacks. Do not use `==` to compare digest representations.
 *
 * The attack happens as follows:
 *
 * $(OL
 *     $(LI An attacker wants to send harmful data to your server, which
 *     requires a integrity HMAC SHA1 token signed with a secret.)
 *     $(LI The length of the token is known to be 40 characters long due to its format,
 *     so the attacker first sends `"0000000000000000000000000000000000000000"`,
 *     then `"1000000000000000000000000000000000000000"`, and so on.)
 *     $(LI The given HMAC token is compared with the expected token using the
 *     `==` string comparison, which returns `false` as soon as the first wrong
 *     element is found. If a wrong element is found, then a rejection is sent
 *     back to the sender.)
 *     $(LI Eventually, the attacker is able to determine the first character in
 *     the correct token because the sever takes slightly longer to return a
 *     rejection. This is due to the comparison moving on to second item in
 *     the two arrays, seeing they are different, and then sending the rejection.)
 *     $(LI It may seem like too small of a difference in time for the attacker
 *     to notice, but security researchers have shown that differences as
 *     small as $(LINK2 http://www.cs.rice.edu/~dwallach/pub/crosby-timing2009.pdf,
 *     20µs can be reliably distinguished) even with network inconsistencies.)
 *     $(LI Repeat the process for each character until the attacker has the whole
 *     correct token and the server accepts the harmful data. This can be done
 *     in a week with the attacker pacing the attack to 10 requests per second
 *     with only one client.)
 * )
 *
 * This function defends against this attack by always comparing every single
 * item in the array if the two arrays are the same length. Therefore, this
 * function is always $(BIGOH n) for ranges of the same length.
 *
 * This attack can also be mitigated via rate limiting and banning IPs which have too
 * many rejected requests. However, this does not completely solve the problem,
 * as the attacker could be in control of a bot net. To fully defend against
 * the timing attack, rate limiting, banning IPs, and using this function
 * should be used together.
 *
 * Params:
 *     r1 = A digest representation
 *     r2 = A digest representation
 * Returns:
 *     `true` if both representations are equal, `false` otherwise
 * See_Also:
 *     $(LINK2 https://en.wikipedia.org/wiki/Timing_attack, The Wikipedia article
 *     on timing attacks).
 */
bool secureEqual(R1, R2)(R1 r1, R2 r2)
if (isInputRange!R1 && isInputRange!R2 && !isInfinite!R1 && !isInfinite!R2 &&
    (isIntegral!(ElementEncodingType!R1) || isSomeChar!(ElementEncodingType!R1)) &&
    !is(CommonType!(ElementEncodingType!R1, ElementEncodingType!R2) == void))
{
    static if (hasLength!R1 && hasLength!R2)
        if (r1.length != r2.length)
            return false;

    int result;

    static if (isRandomAccessRange!R1 && isRandomAccessRange!R2 &&
               hasLength!R1 && hasLength!R2)
    {
        foreach (i; 0 .. r1.length)
            result |= r1[i] ^ r2[i];
    }
    else static if (hasLength!R1 && hasLength!R2)
    {
        // Lengths are the same so we can squeeze out a bit of performance
        // by not checking if r2 is empty
        for (; !r1.empty; r1.popFront(), r2.popFront())
        {
            result |= r1.front ^ r2.front;
        }
    }
    else
    {
        // Generic case, walk both ranges
        for (; !r1.empty; r1.popFront(), r2.popFront())
        {
            if (r2.empty) return false;
            result |= r1.front ^ r2.front;
        }
        if (!r2.empty) return false;
    }

    return result == 0;
}

///
@system pure unittest
{
    import std.digest.hmac : hmac;
    import std.digest.sha : SHA1;
    import std.string : representation;

    // a typical HMAC data integrity verification
    auto secret = "A7GZIP6TAQA6OHM7KZ42KB9303CEY0MOV5DD6NTV".representation;
    auto data = "data".representation;

    auto hex1 = data.hmac!SHA1(secret).toHexString;
    auto hex2 = data.hmac!SHA1(secret).toHexString;
    auto hex3 = "data1".representation.hmac!SHA1(secret).toHexString;

    assert( secureEqual(hex1[], hex2[]));
    assert(!secureEqual(hex1[], hex3[]));
}

@system pure unittest
{
    import std.internal.test.dummyrange : ReferenceInputRange;
    import std.range : takeExactly;
    import std.string : representation;
    import std.utf : byWchar, byDchar;

    {
        auto hex1 = "02CA3484C375EDD3C0F08D3F50D119E61077".representation;
        auto hex2 = "02CA3484C375EDD3C0F08D3F50D119E610779018".representation;
        assert(!secureEqual(hex1, hex2));
    }
    {
        auto hex1 = "02CA3484C375EDD3C0F08D3F50D119E610779018"w.representation;
        auto hex2 = "02CA3484C375EDD3C0F08D3F50D119E610779018"d.representation;
        assert(secureEqual(hex1, hex2));
    }
    {
        auto hex1 = "02CA3484C375EDD3C0F08D3F50D119E610779018".byWchar;
        auto hex2 = "02CA3484C375EDD3C0F08D3F50D119E610779018".byDchar;
        assert(secureEqual(hex1, hex2));
    }
    {
        auto hex1 = "02CA3484C375EDD3C0F08D3F50D119E61077".byWchar;
        auto hex2 = "02CA3484C375EDD3C0F08D3F50D119E610779018".byDchar;
        assert(!secureEqual(hex1, hex2));
    }
    {
        auto hex1 = new ReferenceInputRange!int([0, 1, 2, 3, 4, 5, 6, 7, 8]).takeExactly(9);
        auto hex2 = new ReferenceInputRange!int([0, 1, 2, 3, 4, 5, 6, 7, 8]).takeExactly(9);
        assert(secureEqual(hex1, hex2));
    }
    {
        auto hex1 = new ReferenceInputRange!int([0, 1, 2, 3, 4, 5, 6, 7, 8]).takeExactly(9);
        auto hex2 = new ReferenceInputRange!int([0, 1, 2, 3, 4, 5, 6, 7, 9]).takeExactly(9);
        assert(!secureEqual(hex1, hex2));
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * Computes RIPEMD-160 hashes of arbitrary data. RIPEMD-160 hashes are 20 byte quantities
 * that are like a checksum or CRC, but are more robust.
 *
$(SCRIPT inhibitQuickIndex = 1;)

$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Category) $(TH Functions)
)
$(TR $(TDNW Template API) $(TD $(MYREF RIPEMD160)
)
)
$(TR $(TDNW OOP API) $(TD $(MYREF RIPEMD160Digest))
)
$(TR $(TDNW Helpers) $(TD $(MYREF ripemd160Of))
)
)
)

 * This module conforms to the APIs defined in $(MREF std, digest). To understand the
 * differences between the template and the OOP API, see $(MREF std, digest).
 *
 * This module publicly imports `std.digest` and can be used as a stand-alone
 * module.
 *
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * CTFE:
 * Digests do not work in CTFE
 *
 * Authors:
 * Kai Nacke $(BR)
 * The algorithm was designed by Hans Dobbertin, Antoon Bosselaers, and Bart Preneel. $(BR)
 * The D implementation is a direct translation of the ANSI C implementation by Antoon Bosselaers.
 *
 * References:
 * $(UL
 * $(LI $(LINK2 http://homes.esat.kuleuven.be/~bosselae/ripemd160.html, The hash function RIPEMD-160))
 * $(LI $(LINK2 http://en.wikipedia.org/wiki/RIPEMD-160, Wikipedia on RIPEMD-160))
 * )
 *
 * Source: $(PHOBOSSRC std/digest/ripemd.d)
 *
 */

module std.digest.ripemd;

public import std.digest;

///
@safe unittest
{
    //Template API
    import std.digest.md;

    ubyte[20] hash = ripemd160Of("abc");
    assert(toHexString(hash) == "8EB208F7E05D987A9B044A8E98C6B087F15A0BFC");

    //Feeding data
    ubyte[1024] data;
    RIPEMD160 md;
    md.start();
    md.put(data[]);
    md.start(); //Start again
    md.put(data[]);
    hash = md.finish();
}

///
@safe unittest
{
    //OOP API
    import std.digest.md;

    auto md = new RIPEMD160Digest();
    ubyte[] hash = md.digest("abc");
    assert(toHexString(hash) == "8EB208F7E05D987A9B044A8E98C6B087F15A0BFC");

    //Feeding data
    ubyte[1024] data;
    md.put(data[]);
    md.reset(); //Start again
    md.put(data[]);
    hash = md.finish();
}

/**
 * Template API RIPEMD160 implementation.
 * See `std.digest` for differences between template and OOP API.
 */
struct RIPEMD160
{
    import core.bitop : rol;
    private:
        // magic initialization constants
        uint[5] _state = [0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0]; // state (ABCDE)
        ulong _count; //number of bits, modulo 2^64
        ubyte[64] _buffer; // input buffer

        static immutable ubyte[64] _padding =
        [
          0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        ];

        // F, G, H, I and J are basic RIPEMD160 functions
        static @safe pure nothrow @nogc
        {
            uint F(uint x, uint y, uint z) { return x ^ y ^ z; }
            uint G(uint x, uint y, uint z) { return (x & y) | (~x & z); }
            uint H(uint x, uint y, uint z) { return (x | ~y) ^ z; }
            uint I(uint x, uint y, uint z) { return (x & z) | (y & ~z); }
            uint J(uint x, uint y, uint z) { return x ^ (y | ~z); }
        }

        /*
         * FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
         * Rotation is separate from addition to prevent recomputation.
         */

        /* the ten basic operations FF() through III() */
        static void FF(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += F(b, c, d) + x;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void GG(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += G(b, c, d) + x + 0x5a827999UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void HH(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += H(b, c, d) + x + 0x6ed9eba1UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void II(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += I(b, c, d) + x + 0x8f1bbcdcUL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void JJ(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += J(b, c, d) + x + 0xa953fd4eUL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        /*
         * FFF, GGG, HHH, and III transformations for parallel rounds 1, 2, 3, and 4.
         * Rotation is separate from addition to prevent recomputation.
         */

        static void FFF(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += F(b, c, d) + x;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void GGG(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += G(b, c, d) + x + 0x7a6d76e9UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void HHH(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += H(b, c, d) + x + 0x6d703ef3UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void III(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += I(b, c, d) + x + 0x5c4dd124UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        static void JJJ(ref uint a, uint b, ref uint c, uint d, uint e, uint x, uint s)
            @safe pure nothrow @nogc
        {
            a += J(b, c, d) + x + 0x50a28be6UL;
            a = rol(a, s) + e;
            c = rol(c, 10);
        }

        /*
         * RIPEMD160 basic transformation. Transforms state based on block.
         */

        void transform(const(ubyte[64])* block)
            pure nothrow @nogc
        {
            uint aa = _state[0],
                 bb = _state[1],
                 cc = _state[2],
                 dd = _state[3],
                 ee = _state[4];
            uint aaa = _state[0],
                 bbb = _state[1],
                 ccc = _state[2],
                 ddd = _state[3],
                 eee = _state[4];

            uint[16] x = void;

            version (BigEndian)
            {
                import std.bitmanip : littleEndianToNative;

                for (size_t i = 0; i < 16; i++)
                {
                    x[i] = littleEndianToNative!uint(*cast(ubyte[4]*)&(*block)[i*4]);
                }
            }
            else
            {
                (cast(ubyte*) x.ptr)[0 .. 64] = (cast(ubyte*) block)[0 .. 64];
            }

            /* round 1 */
            FF(aa, bb, cc, dd, ee, x[ 0], 11);
            FF(ee, aa, bb, cc, dd, x[ 1], 14);
            FF(dd, ee, aa, bb, cc, x[ 2], 15);
            FF(cc, dd, ee, aa, bb, x[ 3], 12);
            FF(bb, cc, dd, ee, aa, x[ 4],  5);
            FF(aa, bb, cc, dd, ee, x[ 5],  8);
            FF(ee, aa, bb, cc, dd, x[ 6],  7);
            FF(dd, ee, aa, bb, cc, x[ 7],  9);
            FF(cc, dd, ee, aa, bb, x[ 8], 11);
            FF(bb, cc, dd, ee, aa, x[ 9], 13);
            FF(aa, bb, cc, dd, ee, x[10], 14);
            FF(ee, aa, bb, cc, dd, x[11], 15);
            FF(dd, ee, aa, bb, cc, x[12],  6);
            FF(cc, dd, ee, aa, bb, x[13],  7);
            FF(bb, cc, dd, ee, aa, x[14],  9);
            FF(aa, bb, cc, dd, ee, x[15],  8);

            /* round 2 */
            GG(ee, aa, bb, cc, dd, x[ 7],  7);
            GG(dd, ee, aa, bb, cc, x[ 4],  6);
            GG(cc, dd, ee, aa, bb, x[13],  8);
            GG(bb, cc, dd, ee, aa, x[ 1], 13);
            GG(aa, bb, cc, dd, ee, x[10], 11);
            GG(ee, aa, bb, cc, dd, x[ 6],  9);
            GG(dd, ee, aa, bb, cc, x[15],  7);
            GG(cc, dd, ee, aa, bb, x[ 3], 15);
            GG(bb, cc, dd, ee, aa, x[12],  7);
            GG(aa, bb, cc, dd, ee, x[ 0], 12);
            GG(ee, aa, bb, cc, dd, x[ 9], 15);
            GG(dd, ee, aa, bb, cc, x[ 5],  9);
            GG(cc, dd, ee, aa, bb, x[ 2], 11);
            GG(bb, cc, dd, ee, aa, x[14],  7);
            GG(aa, bb, cc, dd, ee, x[11], 13);
            GG(ee, aa, bb, cc, dd, x[ 8], 12);

            /* round 3 */
            HH(dd, ee, aa, bb, cc, x[ 3], 11);
            HH(cc, dd, ee, aa, bb, x[10], 13);
            HH(bb, cc, dd, ee, aa, x[14],  6);
            HH(aa, bb, cc, dd, ee, x[ 4],  7);
            HH(ee, aa, bb, cc, dd, x[ 9], 14);
            HH(dd, ee, aa, bb, cc, x[15],  9);
            HH(cc, dd, ee, aa, bb, x[ 8], 13);
            HH(bb, cc, dd, ee, aa, x[ 1], 15);
            HH(aa, bb, cc, dd, ee, x[ 2], 14);
            HH(ee, aa, bb, cc, dd, x[ 7],  8);
            HH(dd, ee, aa, bb, cc, x[ 0], 13);
            HH(cc, dd, ee, aa, bb, x[ 6],  6);
            HH(bb, cc, dd, ee, aa, x[13],  5);
            HH(aa, bb, cc, dd, ee, x[11], 12);
            HH(ee, aa, bb, cc, dd, x[ 5],  7);
            HH(dd, ee, aa, bb, cc, x[12],  5);

            /* round 4 */
            II(cc, dd, ee, aa, bb, x[ 1], 11);
            II(bb, cc, dd, ee, aa, x[ 9], 12);
            II(aa, bb, cc, dd, ee, x[11], 14);
            II(ee, aa, bb, cc, dd, x[10], 15);
            II(dd, ee, aa, bb, cc, x[ 0], 14);
            II(cc, dd, ee, aa, bb, x[ 8], 15);
            II(bb, cc, dd, ee, aa, x[12],  9);
            II(aa, bb, cc, dd, ee, x[ 4],  8);
            II(ee, aa, bb, cc, dd, x[13],  9);
            II(dd, ee, aa, bb, cc, x[ 3], 14);
            II(cc, dd, ee, aa, bb, x[ 7],  5);
            II(bb, cc, dd, ee, aa, x[15],  6);
            II(aa, bb, cc, dd, ee, x[14],  8);
            II(ee, aa, bb, cc, dd, x[ 5],  6);
            II(dd, ee, aa, bb, cc, x[ 6],  5);
            II(cc, dd, ee, aa, bb, x[ 2], 12);

            /* round 5 */
            JJ(bb, cc, dd, ee, aa, x[ 4],  9);
            JJ(aa, bb, cc, dd, ee, x[ 0], 15);
            JJ(ee, aa, bb, cc, dd, x[ 5],  5);
            JJ(dd, ee, aa, bb, cc, x[ 9], 11);
            JJ(cc, dd, ee, aa, bb, x[ 7],  6);
            JJ(bb, cc, dd, ee, aa, x[12],  8);
            JJ(aa, bb, cc, dd, ee, x[ 2], 13);
            JJ(ee, aa, bb, cc, dd, x[10], 12);
            JJ(dd, ee, aa, bb, cc, x[14],  5);
            JJ(cc, dd, ee, aa, bb, x[ 1], 12);
            JJ(bb, cc, dd, ee, aa, x[ 3], 13);
            JJ(aa, bb, cc, dd, ee, x[ 8], 14);
            JJ(ee, aa, bb, cc, dd, x[11], 11);
            JJ(dd, ee, aa, bb, cc, x[ 6],  8);
            JJ(cc, dd, ee, aa, bb, x[15],  5);
            JJ(bb, cc, dd, ee, aa, x[13],  6);

            /* parallel round 1 */
            JJJ(aaa, bbb, ccc, ddd, eee, x[ 5],  8);
            JJJ(eee, aaa, bbb, ccc, ddd, x[14],  9);
            JJJ(ddd, eee, aaa, bbb, ccc, x[ 7],  9);
            JJJ(ccc, ddd, eee, aaa, bbb, x[ 0], 11);
            JJJ(bbb, ccc, ddd, eee, aaa, x[ 9], 13);
            JJJ(aaa, bbb, ccc, ddd, eee, x[ 2], 15);
            JJJ(eee, aaa, bbb, ccc, ddd, x[11], 15);
            JJJ(ddd, eee, aaa, bbb, ccc, x[ 4],  5);
            JJJ(ccc, ddd, eee, aaa, bbb, x[13],  7);
            JJJ(bbb, ccc, ddd, eee, aaa, x[ 6],  7);
            JJJ(aaa, bbb, ccc, ddd, eee, x[15],  8);
            JJJ(eee, aaa, bbb, ccc, ddd, x[ 8], 11);
            JJJ(ddd, eee, aaa, bbb, ccc, x[ 1], 14);
            JJJ(ccc, ddd, eee, aaa, bbb, x[10], 14);
            JJJ(bbb, ccc, ddd, eee, aaa, x[ 3], 12);
            JJJ(aaa, bbb, ccc, ddd, eee, x[12],  6);

            /* parallel round 2 */
            III(eee, aaa, bbb, ccc, ddd, x[ 6],  9);
            III(ddd, eee, aaa, bbb, ccc, x[11], 13);
            III(ccc, ddd, eee, aaa, bbb, x[ 3], 15);
            III(bbb, ccc, ddd, eee, aaa, x[ 7],  7);
            III(aaa, bbb, ccc, ddd, eee, x[ 0], 12);
            III(eee, aaa, bbb, ccc, ddd, x[13],  8);
            III(ddd, eee, aaa, bbb, ccc, x[ 5],  9);
            III(ccc, ddd, eee, aaa, bbb, x[10], 11);
            III(bbb, ccc, ddd, eee, aaa, x[14],  7);
            III(aaa, bbb, ccc, ddd, eee, x[15],  7);
            III(eee, aaa, bbb, ccc, ddd, x[ 8], 12);
            III(ddd, eee, aaa, bbb, ccc, x[12],  7);
            III(ccc, ddd, eee, aaa, bbb, x[ 4],  6);
            III(bbb, ccc, ddd, eee, aaa, x[ 9], 15);
            III(aaa, bbb, ccc, ddd, eee, x[ 1], 13);
            III(eee, aaa, bbb, ccc, ddd, x[ 2], 11);

            /* parallel round 3 */
            HHH(ddd, eee, aaa, bbb, ccc, x[15],  9);
            HHH(ccc, ddd, eee, aaa, bbb, x[ 5],  7);
            HHH(bbb, ccc, ddd, eee, aaa, x[ 1], 15);
            HHH(aaa, bbb, ccc, ddd, eee, x[ 3], 11);
            HHH(eee, aaa, bbb, ccc, ddd, x[ 7],  8);
            HHH(ddd, eee, aaa, bbb, ccc, x[14],  6);
            HHH(ccc, ddd, eee, aaa, bbb, x[ 6],  6);
            HHH(bbb, ccc, ddd, eee, aaa, x[ 9], 14);
            HHH(aaa, bbb, ccc, ddd, eee, x[11], 12);
            HHH(eee, aaa, bbb, ccc, ddd, x[ 8], 13);
            HHH(ddd, eee, aaa, bbb, ccc, x[12],  5);
            HHH(ccc, ddd, eee, aaa, bbb, x[ 2], 14);
            HHH(bbb, ccc, ddd, eee, aaa, x[10], 13);
            HHH(aaa, bbb, ccc, ddd, eee, x[ 0], 13);
            HHH(eee, aaa, bbb, ccc, ddd, x[ 4],  7);
            HHH(ddd, eee, aaa, bbb, ccc, x[13],  5);

            /* parallel round 4 */
            GGG(ccc, ddd, eee, aaa, bbb, x[ 8], 15);
            GGG(bbb, ccc, ddd, eee, aaa, x[ 6],  5);
            GGG(aaa, bbb, ccc, ddd, eee, x[ 4],  8);
            GGG(eee, aaa, bbb, ccc, ddd, x[ 1], 11);
            GGG(ddd, eee, aaa, bbb, ccc, x[ 3], 14);
            GGG(ccc, ddd, eee, aaa, bbb, x[11], 14);
            GGG(bbb, ccc, ddd, eee, aaa, x[15],  6);
            GGG(aaa, bbb, ccc, ddd, eee, x[ 0], 14);
            GGG(eee, aaa, bbb, ccc, ddd, x[ 5],  6);
            GGG(ddd, eee, aaa, bbb, ccc, x[12],  9);
            GGG(ccc, ddd, eee, aaa, bbb, x[ 2], 12);
            GGG(bbb, ccc, ddd, eee, aaa, x[13],  9);
            GGG(aaa, bbb, ccc, ddd, eee, x[ 9], 12);
            GGG(eee, aaa, bbb, ccc, ddd, x[ 7],  5);
            GGG(ddd, eee, aaa, bbb, ccc, x[10], 15);
            GGG(ccc, ddd, eee, aaa, bbb, x[14],  8);

            /* parallel round 5 */
            FFF(bbb, ccc, ddd, eee, aaa, x[12] ,  8);
            FFF(aaa, bbb, ccc, ddd, eee, x[15] ,  5);
            FFF(eee, aaa, bbb, ccc, ddd, x[10] , 12);
            FFF(ddd, eee, aaa, bbb, ccc, x[ 4] ,  9);
            FFF(ccc, ddd, eee, aaa, bbb, x[ 1] , 12);
            FFF(bbb, ccc, ddd, eee, aaa, x[ 5] ,  5);
            FFF(aaa, bbb, ccc, ddd, eee, x[ 8] , 14);
            FFF(eee, aaa, bbb, ccc, ddd, x[ 7] ,  6);
            FFF(ddd, eee, aaa, bbb, ccc, x[ 6] ,  8);
            FFF(ccc, ddd, eee, aaa, bbb, x[ 2] , 13);
            FFF(bbb, ccc, ddd, eee, aaa, x[13] ,  6);
            FFF(aaa, bbb, ccc, ddd, eee, x[14] ,  5);
            FFF(eee, aaa, bbb, ccc, ddd, x[ 0] , 15);
            FFF(ddd, eee, aaa, bbb, ccc, x[ 3] , 13);
            FFF(ccc, ddd, eee, aaa, bbb, x[ 9] , 11);
            FFF(bbb, ccc, ddd, eee, aaa, x[11] , 11);

            /* combine results */
            ddd += cc + _state[1];               /* final result for _state[0] */
            _state[1] = _state[2] + dd + eee;
            _state[2] = _state[3] + ee + aaa;
            _state[3] = _state[4] + aa + bbb;
            _state[4] = _state[0] + bb + ccc;
            _state[0] = ddd;

            //Zeroize sensitive information.
            x[] = 0;
        }

    public:
        enum blockSize = 512;

        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         *
         * Example:
         * ----
         * RIPEMD160 dig;
         * dig.put(cast(ubyte) 0); //single ubyte
         * dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
         * ubyte[10] buf;
         * dig.put(buf); //buffer
         * ----
         */
        void put(scope const(ubyte)[] data...) @trusted pure nothrow @nogc
        {
            uint i, index, partLen;
            auto inputLen = data.length;

            //Compute number of bytes mod 64
            index = (cast(uint)_count >> 3) & (64 - 1);

            //Update number of bits
            _count += inputLen * 8;

            partLen = 64 - index;

            //Transform as many times as possible
            if (inputLen >= partLen)
            {
                (&_buffer[index])[0 .. partLen] = data.ptr[0 .. partLen];
                transform(&_buffer);

                for (i = partLen; i + 63 < inputLen; i += 64)
                {
                    transform(cast(const(ubyte[64])*)(data[i .. i + 64].ptr));
                }

                index = 0;
            }
            else
            {
                i = 0;
            }

            /* Buffer remaining input */
            if (inputLen - i)
                (&_buffer[index])[0 .. inputLen-i] = (&data[i])[0 .. inputLen-i];
        }

        /**
         * Used to (re)initialize the RIPEMD160 digest.
         *
         * Note:
         * For this RIPEMD160 Digest implementation calling start after default construction
         * is not necessary. Calling start is only necessary to reset the Digest.
         *
         * Generic code which deals with different Digest types should always call start though.
         *
         * Example:
         * --------
         * RIPEMD160 digest;
         * //digest.start(); //Not necessary
         * digest.put(0);
         * --------
         */
        void start() @safe pure nothrow @nogc
        {
            this = RIPEMD160.init;
        }

        /**
         * Returns the finished RIPEMD160 hash. This also calls $(LREF start) to
         * reset the internal state.
         *
         * Example:
         * --------
         * //Simple example
         * RIPEMD160 hash;
         * hash.start();
         * hash.put(cast(ubyte) 0);
         * ubyte[20] result = hash.finish();
         * assert(toHexString(result) == "C81B94933420221A7AC004A90242D8B1D3E5070D");
         * --------
         */
        ubyte[20] finish() @trusted pure nothrow @nogc
        {
            import std.bitmanip : nativeToLittleEndian;

            ubyte[20] data = void;
            ubyte[8] bits = void;
            uint index, padLen;

            //Save number of bits
            bits[0 .. 8] = nativeToLittleEndian(_count)[];

            //Pad out to 56 mod 64
            index = (cast(uint)_count >> 3) & (64 - 1);
            padLen = (index < 56) ? (56 - index) : (120 - index);
            put(_padding[0 .. padLen]);

            //Append length (before padding)
            put(bits);

            //Store state in digest
            data[0 .. 4]   = nativeToLittleEndian(_state[0])[];
            data[4 .. 8]   = nativeToLittleEndian(_state[1])[];
            data[8 .. 12]  = nativeToLittleEndian(_state[2])[];
            data[12 .. 16] = nativeToLittleEndian(_state[3])[];
            data[16 .. 20] = nativeToLittleEndian(_state[4])[];

            /* Zeroize sensitive information. */
            start();
            return data;
        }
}

///
@safe unittest
{
    //Simple example, hashing a string using ripemd160Of helper function
    ubyte[20] hash = ripemd160Of("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "8EB208F7E05D987A9B044A8E98C6B087F15A0BFC");
}

///
@safe unittest
{
    //Using the basic API
    RIPEMD160 hash;
    hash.start();
    ubyte[1024] data;
    //Initialize data here...
    hash.put(data);
    ubyte[20] result = hash.finish();
}

///
@safe unittest
{
    //Let's use the template features:
    void doSomething(T)(ref T hash)
    if (isDigest!T)
    {
        hash.put(cast(ubyte) 0);
    }
    RIPEMD160 md;
    md.start();
    doSomething(md);
    assert(toHexString(md.finish()) == "C81B94933420221A7AC004A90242D8B1D3E5070D");
}

///
@safe unittest
{
    //Simple example
    RIPEMD160 hash;
    hash.start();
    hash.put(cast(ubyte) 0);
    ubyte[20] result = hash.finish();
    assert(toHexString(result) == "C81B94933420221A7AC004A90242D8B1D3E5070D");
}

@safe unittest
{
    assert(isDigest!RIPEMD160);
}

@system unittest
{
    import std.conv : hexString;
    import std.range;

    ubyte[20] digest;

    RIPEMD160 md;
    md.put(cast(ubyte[])"abcdef");
    md.start();
    md.put(cast(ubyte[])"");
    assert(md.finish() == cast(ubyte[]) hexString!"9c1185a5c5e9fc54612808977ee8f548b2258d31");

    digest = ripemd160Of("");
    assert(digest == cast(ubyte[]) hexString!"9c1185a5c5e9fc54612808977ee8f548b2258d31");

    digest = ripemd160Of("a");
    assert(digest == cast(ubyte[]) hexString!"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe");

    digest = ripemd160Of("abc");
    assert(digest == cast(ubyte[]) hexString!"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc");

    digest = ripemd160Of("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"12a053384a9c0c88e405a06c27dcf49ada62eb2b");

    digest = ripemd160Of("message digest");
    assert(digest == cast(ubyte[]) hexString!"5d0689ef49d2fae572b881b123a85ffa21595f36");

    digest = ripemd160Of("abcdefghijklmnopqrstuvwxyz");
    assert(digest == cast(ubyte[]) hexString!"f71c27109c692c1b56bbdceb5b9d2865b3708dbc");

    digest = ripemd160Of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"b0e20b6e3116640286ed3a87a5713079b21f5189");

    digest = ripemd160Of("1234567890123456789012345678901234567890"~
                    "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"9b752e45573d4b39f4dbd3323cab82bf63326bfb");

    enum ubyte[20] input = cast(ubyte[20]) hexString!"f71c27109c692c1b56bbdceb5b9d2865b3708dbc";
    assert(toHexString(input)
        == "F71C27109C692C1B56BBDCEB5B9D2865B3708DBC");

    ubyte[] onemilliona = new ubyte[1000000];
    onemilliona[] = 'a';
    digest = ripemd160Of(onemilliona);
    assert(digest == cast(ubyte[]) hexString!"52783243c1697bdbe16d37f97f68f08325dc1528");

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    digest = ripemd160Of(oneMillionRange);
    assert(digest == cast(ubyte[]) hexString!"52783243c1697bdbe16d37f97f68f08325dc1528");
}

/**
 * This is a convenience alias for $(REF digest, std,digest) using the
 * RIPEMD160 implementation.
 */
//simple alias doesn't work here, hope this gets inlined...
auto ripemd160Of(T...)(T data)
{
    return digest!(RIPEMD160, T)(data);
}

///
@safe unittest
{
    ubyte[20] hash = ripemd160Of("abc");
    assert(hash == digest!RIPEMD160("abc"));
}

/**
 * OOP API RIPEMD160 implementation.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!RIPEMD160),
 * see there for more information.
 */
alias RIPEMD160Digest = WrapperDigest!RIPEMD160;

///
@safe unittest
{
    //Simple example, hashing a string using Digest.digest helper function
    auto md = new RIPEMD160Digest();
    ubyte[] hash = md.digest("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "8EB208F7E05D987A9B044A8E98C6B087F15A0BFC");
}

///
@system unittest
{
    //Let's use the OOP features:
    void test(Digest dig)
    {
      dig.put(cast(ubyte) 0);
    }
    auto md = new RIPEMD160Digest();
    test(md);

    //Let's use a custom buffer:
    ubyte[20] buf;
    ubyte[] result = md.finish(buf[]);
    assert(toHexString(result) == "C81B94933420221A7AC004A90242D8B1D3E5070D");
}

@system unittest
{
    import std.conv : hexString;
    auto md = new RIPEMD160Digest();

    md.put(cast(ubyte[])"abcdef");
    md.reset();
    md.put(cast(ubyte[])"");
    assert(md.finish() == cast(ubyte[]) hexString!"9c1185a5c5e9fc54612808977ee8f548b2258d31");

    md.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    ubyte[20] result;
    auto result2 = md.finish(result[]);
    assert(result[0 .. 20] == result2 && result2 == cast(ubyte[]) hexString!"f71c27109c692c1b56bbdceb5b9d2865b3708dbc");

    debug
    {
        import std.exception;
        assertThrown!Error(md.finish(result[0 .. 19]));
    }

    assert(md.length == 20);

    assert(md.digest("") == cast(ubyte[]) hexString!"9c1185a5c5e9fc54612808977ee8f548b2258d31");

    assert(md.digest("a") == cast(ubyte[]) hexString!"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe");

    assert(md.digest("abc") == cast(ubyte[]) hexString!"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc");

    assert(md.digest("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")
           == cast(ubyte[]) hexString!"12a053384a9c0c88e405a06c27dcf49ada62eb2b");

    assert(md.digest("message digest") == cast(ubyte[]) hexString!"5d0689ef49d2fae572b881b123a85ffa21595f36");

    assert(md.digest("abcdefghijklmnopqrstuvwxyz")
           == cast(ubyte[]) hexString!"f71c27109c692c1b56bbdceb5b9d2865b3708dbc");

    assert(md.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
           == cast(ubyte[]) hexString!"b0e20b6e3116640286ed3a87a5713079b21f5189");

    assert(md.digest("1234567890123456789012345678901234567890",
                                   "1234567890123456789012345678901234567890")
           == cast(ubyte[]) hexString!"9b752e45573d4b39f4dbd3323cab82bf63326bfb");

    assert(md.digest(new ubyte[160/8]) // 160 zero bits
           == cast(ubyte[]) hexString!"5c00bd4aca04a9057c09b20b05f723f2e23deb65");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // Written in the D programming language.
/**
 * Computes SHA1 and SHA2 hashes of arbitrary data. SHA hashes are 20 to 64 byte
 * quantities (depending on the SHA algorithm) that are like a checksum or CRC,
 * but are more robust.
 *
$(SCRIPT inhibitQuickIndex = 1;)

$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Category) $(TH Functions)
)
$(TR $(TDNW Template API) $(TD $(MYREF SHA1)
)
)
$(TR $(TDNW OOP API) $(TD $(MYREF SHA1Digest))
)
$(TR $(TDNW Helpers) $(TD $(MYREF sha1Of))
)
)
)

 * SHA2 comes in several different versions, all supported by this module:
 * SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.
 *
 * This module conforms to the APIs defined in $(MREF std, digest). To understand the
 * differences between the template and the OOP API, see $(MREF std, digest).
 *
 * This module publicly imports `std.digest` and can be used as a stand-alone
 * module.
 *
 * License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * CTFE:
 * Digests do not work in CTFE
 *
 * Authors:
 * The routines and algorithms are derived from the
 * $(I Secure Hash Signature Standard (SHS) (FIPS PUB 180-2)). $(BR )
 * Kai Nacke, Johannes Pfau, Nick Sabalausky
 *
 * References:
 * $(UL
 * $(LI $(LINK2 http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf, FIPS PUB180-2))
 * $(LI $(LINK2 http://software.intel.com/en-us/articles/improving-the-performance-of-the-secure-hash-algorithm-1/, Fast implementation of SHA1))
 * $(LI $(LINK2 http://en.wikipedia.org/wiki/Secure_Hash_Algorithm, Wikipedia article about SHA))
 * )
 *
 * Source: $(PHOBOSSRC std/digest/sha.d)
 *
 */

/*          Copyright Kai Nacke 2012.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
module std.digest.sha;

///
@safe unittest
{
    //Template API
    import std.digest.sha;

    ubyte[20] hash1 = sha1Of("abc");
    assert(toHexString(hash1) == "A9993E364706816ABA3E25717850C26C9CD0D89D");

    ubyte[28] hash224 = sha224Of("abc");
    assert(toHexString(hash224) == "23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7");

    //Feeding data
    ubyte[1024] data;
    SHA1 sha1;
    sha1.start();
    sha1.put(data[]);
    sha1.start(); //Start again
    sha1.put(data[]);
    hash1 = sha1.finish();
}

///
@safe unittest
{
    //OOP API
    import std.digest.sha;

    auto sha1 = new SHA1Digest();
    ubyte[] hash1 = sha1.digest("abc");
    assert(toHexString(hash1) == "A9993E364706816ABA3E25717850C26C9CD0D89D");

    auto sha224 = new SHA224Digest();
    ubyte[] hash224 = sha224.digest("abc");
    assert(toHexString(hash224) == "23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7");

    //Feeding data
    ubyte[1024] data;
    sha1.put(data[]);
    sha1.reset(); //Start again
    sha1.put(data[]);
    hash1 = sha1.finish();
}

version (D_InlineAsm_X86)
{
    version (D_PIC) {} // https://issues.dlang.org/show_bug.cgi?id=9378
    else private version = USE_SSSE3;
}
else version (D_InlineAsm_X86_64)
{
    private version = USE_SSSE3;
}

import core.bitop;

public import std.digest;

/*
 * Helper methods for encoding the buffer.
 * Can be removed if the optimizer can inline the methods from std.bitmanip.
 */
version (LittleEndian)
{
    private alias nativeToBigEndian = bswap;
    private alias bigEndianToNative = bswap;
}
else pragma(inline, true) private pure @nogc nothrow @safe
{
    uint nativeToBigEndian(uint val) { return val; }
    ulong nativeToBigEndian(ulong val) { return val; }
    alias bigEndianToNative = nativeToBigEndian;
}

/**
 * Template API SHA1/SHA2 implementation. Supports: SHA-1, SHA-224, SHA-256,
 * SHA-384, SHA-512, SHA-512/224 and SHA-512/256.
 *
 * The hashBlockSize and digestSize are in bits. However, it's likely easier to
 * simply use the convenience aliases: SHA1, SHA224, SHA256, SHA384, SHA512,
 * SHA512_224 and SHA512_256.
 *
 * See `std.digest` for differences between template and OOP API.
 */
struct SHA(uint hashBlockSize, uint digestSize)
{
    enum blockSize = hashBlockSize;

    static assert(blockSize == 512 || blockSize == 1024,
        "Invalid SHA blockSize, must be 512 or 1024");
    static assert(digestSize == 160 || digestSize == 224 || digestSize == 256 || digestSize == 384 || digestSize == 512,
        "Invalid SHA digestSize, must be 224, 256, 384 or 512");
    static assert(!(blockSize == 512 && digestSize > 256),
        "Invalid SHA digestSize for a blockSize of 512. The digestSize must be 160, 224 or 256.");
    static assert(!(blockSize == 1024 && digestSize < 224),
        "Invalid SHA digestSize for a blockSize of 1024. The digestSize must be 224, 256, 384 or 512.");

    static if (digestSize == 160) /* SHA-1 */
    {
        version (USE_SSSE3)
        {
            import core.cpuid : ssse3;
            import std.internal.digest.sha_SSSE3 : sse3_constants=constants, transformSSSE3;

            static void transform(uint[5]* state, const(ubyte[64])* block) pure nothrow @nogc
            {
                if (ssse3)
                {
                    version (D_InlineAsm_X86_64)
                        // constants as extra argument for PIC
                        // see https://issues.dlang.org/show_bug.cgi?id=9378
                        transformSSSE3(state, block, &sse3_constants);
                    else
                        transformSSSE3(state, block);
                }
                else
                    transformX86(state, block);
            }
        }
        else
        {
            alias transform = transformX86;
        }
    }
    else static if (blockSize == 512) /* SHA-224, SHA-256 */
        alias transform = transformSHA2!uint;
    else static if (blockSize == 1024) /* SHA-384, SHA-512, SHA-512/224, SHA-512/256 */
        alias transform = transformSHA2!ulong;
    else
        static assert(0);

    private:
        /* magic initialization constants - state (ABCDEFGH) */
        static if (blockSize == 512 && digestSize == 160) /* SHA-1 */
        {
            uint[5] state =
            [0x67452301,0xefcdab89,0x98badcfe,0x10325476,0xc3d2e1f0];
        }
        else static if (blockSize == 512 && digestSize == 224) /* SHA-224 */
        {
            uint[8] state = [
                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
            ];
        }
        else static if (blockSize == 512 && digestSize == 256) /* SHA-256 */
        {
            uint[8] state = [
                0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
                0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
            ];
        }
        else static if (blockSize == 1024 && digestSize == 224) /* SHA-512/224 */
        {
            ulong[8] state = [
                0x8C3D37C8_19544DA2, 0x73E19966_89DCD4D6,
                0x1DFAB7AE_32FF9C82, 0x679DD514_582F9FCF,
                0x0F6D2B69_7BD44DA8, 0x77E36F73_04C48942,
                0x3F9D85A8_6A1D36C8, 0x1112E6AD_91D692A1,
            ];
        }
        else static if (blockSize == 1024 && digestSize == 256) /* SHA-512/256 */
        {
            ulong[8] state = [
                0x22312194_FC2BF72C, 0x9F555FA3_C84C64C2,
                0x2393B86B_6F53B151, 0x96387719_5940EABD,
                0x96283EE2_A88EFFE3, 0xBE5E1E25_53863992,
                0x2B0199FC_2C85B8AA, 0x0EB72DDC_81C52CA2,
            ];
        }
        else static if (blockSize == 1024 && digestSize == 384) /* SHA-384 */
        {
            ulong[8] state = [
                0xcbbb9d5d_c1059ed8, 0x629a292a_367cd507,
                0x9159015a_3070dd17, 0x152fecd8_f70e5939,
                0x67332667_ffc00b31, 0x8eb44a87_68581511,
                0xdb0c2e0d_64f98fa7, 0x47b5481d_befa4fa4,
            ];
        }
        else static if (blockSize == 1024 && digestSize == 512) /* SHA-512 */
        {
            ulong[8] state = [
                0x6a09e667_f3bcc908, 0xbb67ae85_84caa73b,
                0x3c6ef372_fe94f82b, 0xa54ff53a_5f1d36f1,
                0x510e527f_ade682d1, 0x9b05688c_2b3e6c1f,
                0x1f83d9ab_fb41bd6b, 0x5be0cd19_137e2179,
            ];
        }
        else
            static assert(0);

        /* constants */
        static if (blockSize == 512)
        {
            static immutable uint[64] constants = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
            ];
        }
        else static if (blockSize == 1024)
        {
            static immutable ulong[80] constants = [
                0x428a2f98_d728ae22, 0x71374491_23ef65cd, 0xb5c0fbcf_ec4d3b2f, 0xe9b5dba5_8189dbbc,
                0x3956c25b_f348b538, 0x59f111f1_b605d019, 0x923f82a4_af194f9b, 0xab1c5ed5_da6d8118,
                0xd807aa98_a3030242, 0x12835b01_45706fbe, 0x243185be_4ee4b28c, 0x550c7dc3_d5ffb4e2,
                0x72be5d74_f27b896f, 0x80deb1fe_3b1696b1, 0x9bdc06a7_25c71235, 0xc19bf174_cf692694,
                0xe49b69c1_9ef14ad2, 0xefbe4786_384f25e3, 0x0fc19dc6_8b8cd5b5, 0x240ca1cc_77ac9c65,
                0x2de92c6f_592b0275, 0x4a7484aa_6ea6e483, 0x5cb0a9dc_bd41fbd4, 0x76f988da_831153b5,
                0x983e5152_ee66dfab, 0xa831c66d_2db43210, 0xb00327c8_98fb213f, 0xbf597fc7_beef0ee4,
                0xc6e00bf3_3da88fc2, 0xd5a79147_930aa725, 0x06ca6351_e003826f, 0x14292967_0a0e6e70,
                0x27b70a85_46d22ffc, 0x2e1b2138_5c26c926, 0x4d2c6dfc_5ac42aed, 0x53380d13_9d95b3df,
                0x650a7354_8baf63de, 0x766a0abb_3c77b2a8, 0x81c2c92e_47edaee6, 0x92722c85_1482353b,
                0xa2bfe8a1_4cf10364, 0xa81a664b_bc423001, 0xc24b8b70_d0f89791, 0xc76c51a3_0654be30,
                0xd192e819_d6ef5218, 0xd6990624_5565a910, 0xf40e3585_5771202a, 0x106aa070_32bbd1b8,
                0x19a4c116_b8d2d0c8, 0x1e376c08_5141ab53, 0x2748774c_df8eeb99, 0x34b0bcb5_e19b48a8,
                0x391c0cb3_c5c95a63, 0x4ed8aa4a_e3418acb, 0x5b9cca4f_7763e373, 0x682e6ff3_d6b2b8a3,
                0x748f82ee_5defb2fc, 0x78a5636f_43172f60, 0x84c87814_a1f0ab72, 0x8cc70208_1a6439ec,
                0x90befffa_23631e28, 0xa4506ceb_de82bde9, 0xbef9a3f7_b2c67915, 0xc67178f2_e372532b,
                0xca273ece_ea26619c, 0xd186b8c7_21c0c207, 0xeada7dd6_cde0eb1e, 0xf57d4f7f_ee6ed178,
                0x06f067aa_72176fba, 0x0a637dc5_a2c898a6, 0x113f9804_bef90dae, 0x1b710b35_131c471b,
                0x28db77f5_23047d84, 0x32caab7b_40c72493, 0x3c9ebe0a_15c9bebc, 0x431d67c4_9c100d4c,
                0x4cc5d4be_cb3e42b6, 0x597f299c_fc657e2a, 0x5fcb6fab_3ad6faec, 0x6c44198c_4a475817,
            ];
        }
        else
            static assert(0);

        /*
         * number of bits, modulo 2^64 (ulong[1]) or 2^128 (ulong[2]),
         * should just use ucent instead of ulong[2] once it's available
         */
        ulong[blockSize/512] count;
        ubyte[blockSize/8]   buffer; /* input buffer */

        static immutable ubyte[128] padding =
        [
          0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,

          0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        ];

        /*
         * Basic SHA1/SHA2 functions.
         */
        pragma(inline, true)
        static @safe pure nothrow @nogc
        {
            /* All SHA1/SHA2 */
            T Ch(T)(T x, T y, T z) { return z ^ (x & (y ^ z)); }
            T Maj(T)(T x, T y, T z) { return (x & y) | (z & (x ^ y)); }

            /* SHA-1 */
            uint Parity(uint x, uint y, uint z) { return x ^ y ^ z; }

            /* SHA-224, SHA-256 */
            uint BigSigma0(uint x) { return core.bitop.ror(x, 2) ^ core.bitop.ror(x, 13) ^ core.bitop.ror(x, 22); }
            uint BigSigma1(uint x) { return core.bitop.ror(x, 6) ^ core.bitop.ror(x, 11) ^ core.bitop.ror(x, 25); }
            uint SmSigma0(uint x) { return core.bitop.ror(x, 7) ^ core.bitop.ror(x, 18) ^ x >> 3; }
            uint SmSigma1(uint x) { return core.bitop.ror(x, 17) ^ core.bitop.ror(x, 19) ^ x >> 10; }

            /* SHA-384, SHA-512, SHA-512/224, SHA-512/256 */
            ulong BigSigma0(ulong x) { return core.bitop.ror(x, 28) ^ core.bitop.ror(x, 34) ^ core.bitop.ror(x, 39); }
            ulong BigSigma1(ulong x) { return core.bitop.ror(x, 14) ^ core.bitop.ror(x, 18) ^ core.bitop.ror(x, 41); }
            ulong SmSigma0(ulong x) { return core.bitop.ror(x, 1) ^ core.bitop.ror(x, 8) ^ x >> 7; }
            ulong SmSigma1(ulong x) { return core.bitop.ror(x, 19) ^ core.bitop.ror(x, 61) ^ x >> 6; }
        }

        /*
         * SHA1 basic transformation. Transforms state based on block.
         */
        static void T_0_15(int i, const(ubyte[64])* input, ref uint[16] W, uint A, ref uint B, uint C, uint D,
            uint E, ref uint T) pure nothrow @nogc
        {
            uint Wi = W[i] = bigEndianToNative(*cast(uint*) &((*input)[i*4]));
            T = Ch(B, C, D) + E + core.bitop.rol(A, 5) + Wi + 0x5a827999;
            B = core.bitop.rol(B, 30);
        }

        static void T_16_19(int i, ref uint[16] W, uint A, ref uint B, uint C, uint D, uint E, ref uint T)
            pure nothrow @nogc
        {
            W[i&15] = core.bitop.rol(W[(i-3)&15] ^ W[(i-8)&15] ^ W[(i-14)&15] ^ W[(i-16)&15], 1);
            T = Ch(B, C, D) + E + core.bitop.rol(A, 5) + W[i&15] + 0x5a827999;
            B = core.bitop.rol(B, 30);
        }

        static void T_20_39(int i, ref uint[16] W, uint A, ref uint B, uint C, uint D, uint E,
            ref uint T) pure nothrow @nogc
        {
            W[i&15] = core.bitop.rol(W[(i-3)&15] ^ W[(i-8)&15] ^ W[(i-14)&15] ^ W[(i-16)&15], 1);
            T = Parity(B, C, D) + E + core.bitop.rol(A, 5) + W[i&15] + 0x6ed9eba1;
            B = core.bitop.rol(B, 30);
        }

        static void T_40_59(int i, ref uint[16] W, uint A, ref uint B, uint C, uint D, uint E,
            ref uint T) pure nothrow @nogc
        {
            W[i&15] = core.bitop.rol(W[(i-3)&15] ^ W[(i-8)&15] ^ W[(i-14)&15] ^ W[(i-16)&15], 1);
            T = Maj(B, C, D) + E + core.bitop.rol(A, 5) + W[i&15] + 0x8f1bbcdc;
            B = core.bitop.rol(B, 30);
        }

        static void T_60_79(int i, ref uint[16] W, uint A, ref uint B, uint C, uint D, uint E,
            ref uint T) pure nothrow @nogc
        {
            W[i&15] = core.bitop.rol(W[(i-3)&15] ^ W[(i-8)&15] ^ W[(i-14)&15] ^ W[(i-16)&15], 1);
            T = Parity(B, C, D) + E + core.bitop.rol(A, 5) + W[i&15] + 0xca62c1d6;
            B = core.bitop.rol(B, 30);
        }

        private static void transformX86(uint[5]* state, const(ubyte[64])* block) pure nothrow @nogc
        {
            uint A, B, C, D, E, T;
            uint[16] W = void;

            A = (*state)[0];
            B = (*state)[1];
            C = (*state)[2];
            D = (*state)[3];
            E = (*state)[4];

            T_0_15 ( 0, block, W, A, B, C, D, E, T);
            T_0_15 ( 1, block, W, T, A, B, C, D, E);
            T_0_15 ( 2, block, W, E, T, A, B, C, D);
            T_0_15 ( 3, block, W, D, E, T, A, B, C);
            T_0_15 ( 4, block, W, C, D, E, T, A, B);
            T_0_15 ( 5, block, W, B, C, D, E, T, A);
            T_0_15 ( 6, block, W, A, B, C, D, E, T);
            T_0_15 ( 7, block, W, T, A, B, C, D, E);
            T_0_15 ( 8, block, W, E, T, A, B, C, D);
            T_0_15 ( 9, block, W, D, E, T, A, B, C);
            T_0_15 (10, block, W, C, D, E, T, A, B);
            T_0_15 (11, block, W, B, C, D, E, T, A);
            T_0_15 (12, block, W, A, B, C, D, E, T);
            T_0_15 (13, block, W, T, A, B, C, D, E);
            T_0_15 (14, block, W, E, T, A, B, C, D);
            T_0_15 (15, block, W, D, E, T, A, B, C);
            T_16_19(16, W, C, D, E, T, A, B);
            T_16_19(17, W, B, C, D, E, T, A);
            T_16_19(18, W, A, B, C, D, E, T);
            T_16_19(19, W, T, A, B, C, D, E);
            T_20_39(20, W, E, T, A, B, C, D);
            T_20_39(21, W, D, E, T, A, B, C);
            T_20_39(22, W, C, D, E, T, A, B);
            T_20_39(23, W, B, C, D, E, T, A);
            T_20_39(24, W, A, B, C, D, E, T);
            T_20_39(25, W, T, A, B, C, D, E);
            T_20_39(26, W, E, T, A, B, C, D);
            T_20_39(27, W, D, E, T, A, B, C);
            T_20_39(28, W, C, D, E, T, A, B);
            T_20_39(29, W, B, C, D, E, T, A);
            T_20_39(30, W, A, B, C, D, E, T);
            T_20_39(31, W, T, A, B, C, D, E);
            T_20_39(32, W, E, T, A, B, C, D);
            T_20_39(33, W, D, E, T, A, B, C);
            T_20_39(34, W, C, D, E, T, A, B);
            T_20_39(35, W, B, C, D, E, T, A);
            T_20_39(36, W, A, B, C, D, E, T);
            T_20_39(37, W, T, A, B, C, D, E);
            T_20_39(38, W, E, T, A, B, C, D);
            T_20_39(39, W, D, E, T, A, B, C);
            T_40_59(40, W, C, D, E, T, A, B);
            T_40_59(41, W, B, C, D, E, T, A);
            T_40_59(42, W, A, B, C, D, E, T);
            T_40_59(43, W, T, A, B, C, D, E);
            T_40_59(44, W, E, T, A, B, C, D);
            T_40_59(45, W, D, E, T, A, B, C);
            T_40_59(46, W, C, D, E, T, A, B);
            T_40_59(47, W, B, C, D, E, T, A);
            T_40_59(48, W, A, B, C, D, E, T);
            T_40_59(49, W, T, A, B, C, D, E);
            T_40_59(50, W, E, T, A, B, C, D);
            T_40_59(51, W, D, E, T, A, B, C);
            T_40_59(52, W, C, D, E, T, A, B);
            T_40_59(53, W, B, C, D, E, T, A);
            T_40_59(54, W, A, B, C, D, E, T);
            T_40_59(55, W, T, A, B, C, D, E);
            T_40_59(56, W, E, T, A, B, C, D);
            T_40_59(57, W, D, E, T, A, B, C);
            T_40_59(58, W, C, D, E, T, A, B);
            T_40_59(59, W, B, C, D, E, T, A);
            T_60_79(60, W, A, B, C, D, E, T);
            T_60_79(61, W, T, A, B, C, D, E);
            T_60_79(62, W, E, T, A, B, C, D);
            T_60_79(63, W, D, E, T, A, B, C);
            T_60_79(64, W, C, D, E, T, A, B);
            T_60_79(65, W, B, C, D, E, T, A);
            T_60_79(66, W, A, B, C, D, E, T);
            T_60_79(67, W, T, A, B, C, D, E);
            T_60_79(68, W, E, T, A, B, C, D);
            T_60_79(69, W, D, E, T, A, B, C);
            T_60_79(70, W, C, D, E, T, A, B);
            T_60_79(71, W, B, C, D, E, T, A);
            T_60_79(72, W, A, B, C, D, E, T);
            T_60_79(73, W, T, A, B, C, D, E);
            T_60_79(74, W, E, T, A, B, C, D);
            T_60_79(75, W, D, E, T, A, B, C);
            T_60_79(76, W, C, D, E, T, A, B);
            T_60_79(77, W, B, C, D, E, T, A);
            T_60_79(78, W, A, B, C, D, E, T);
            T_60_79(79, W, T, A, B, C, D, E);

            (*state)[0] += E;
            (*state)[1] += T;
            (*state)[2] += A;
            (*state)[3] += B;
            (*state)[4] += C;

            /* Zeroize sensitive information. */
            W[] = 0;
        }

        /*
         * SHA2 basic transformation. Transforms state based on block.
         */
        pragma(inline, true)
        static void T_SHA2_0_15(Word)(int i, const(ubyte[blockSize/8])* input, ref Word[16] W,
            Word A, Word B, Word C, ref Word D, Word E, Word F, Word G, ref Word H, Word K)
            pure nothrow @nogc
        {
            Word Wi = W[i] = bigEndianToNative(*cast(Word*) &((*input)[i*Word.sizeof]));
            Word T1 = H + BigSigma1(E) + Ch(E, F, G) + K + Wi;
            Word T2 = BigSigma0(A) + Maj(A, B, C);
            D += T1;
            H = T1 + T2;
        }

        // Temporarily disable inlining because it increases build speed by 10x.
        // pragma(inline, true)
        static void T_SHA2_16_79(Word)(int i, ref Word[16] W,
            Word A, Word B, Word C, ref Word D, Word E, Word F, Word G, ref Word H, Word K)
            pure nothrow @nogc
        {
            W[i&15] = SmSigma1(W[(i-2)&15]) + W[(i-7)&15] + SmSigma0(W[(i-15)&15]) + W[i&15];
            Word T1 = H + BigSigma1(E) + Ch(E, F, G) + K + W[i&15];
            Word T2 = BigSigma0(A) + Maj(A, B, C);
            D += T1;
            H = T1 + T2;
        }

        private static void transformSHA2(Word)(Word[8]* state, const(ubyte[blockSize/8])* block)
            pure nothrow @nogc
        {
            Word A, B, C, D, E, F, G, H;
            Word[16] W = void;

            A = (*state)[0];
            B = (*state)[1];
            C = (*state)[2];
            D = (*state)[3];
            E = (*state)[4];
            F = (*state)[5];
            G = (*state)[6];
            H = (*state)[7];

            T_SHA2_0_15!Word ( 0, block, W, A, B, C, D, E, F, G, H, constants[ 0]);
            T_SHA2_0_15!Word ( 1, block, W, H, A, B, C, D, E, F, G, constants[ 1]);
            T_SHA2_0_15!Word ( 2, block, W, G, H, A, B, C, D, E, F, constants[ 2]);
            T_SHA2_0_15!Word ( 3, block, W, F, G, H, A, B, C, D, E, constants[ 3]);
            T_SHA2_0_15!Word ( 4, block, W, E, F, G, H, A, B, C, D, constants[ 4]);
            T_SHA2_0_15!Word ( 5, block, W, D, E, F, G, H, A, B, C, constants[ 5]);
            T_SHA2_0_15!Word ( 6, block, W, C, D, E, F, G, H, A, B, constants[ 6]);
            T_SHA2_0_15!Word ( 7, block, W, B, C, D, E, F, G, H, A, constants[ 7]);
            T_SHA2_0_15!Word ( 8, block, W, A, B, C, D, E, F, G, H, constants[ 8]);
            T_SHA2_0_15!Word ( 9, block, W, H, A, B, C, D, E, F, G, constants[ 9]);
            T_SHA2_0_15!Word (10, block, W, G, H, A, B, C, D, E, F, constants[10]);
            T_SHA2_0_15!Word (11, block, W, F, G, H, A, B, C, D, E, constants[11]);
            T_SHA2_0_15!Word (12, block, W, E, F, G, H, A, B, C, D, constants[12]);
            T_SHA2_0_15!Word (13, block, W, D, E, F, G, H, A, B, C, constants[13]);
            T_SHA2_0_15!Word (14, block, W, C, D, E, F, G, H, A, B, constants[14]);
            T_SHA2_0_15!Word (15, block, W, B, C, D, E, F, G, H, A, constants[15]);
            T_SHA2_16_79!Word(16, W, A, B, C, D, E, F, G, H, constants[16]);
            T_SHA2_16_79!Word(17, W, H, A, B, C, D, E, F, G, constants[17]);
            T_SHA2_16_79!Word(18, W, G, H, A, B, C, D, E, F, constants[18]);
            T_SHA2_16_79!Word(19, W, F, G, H, A, B, C, D, E, constants[19]);
            T_SHA2_16_79!Word(20, W, E, F, G, H, A, B, C, D, constants[20]);
            T_SHA2_16_79!Word(21, W, D, E, F, G, H, A, B, C, constants[21]);
            T_SHA2_16_79!Word(22, W, C, D, E, F, G, H, A, B, constants[22]);
            T_SHA2_16_79!Word(23, W, B, C, D, E, F, G, H, A, constants[23]);
            T_SHA2_16_79!Word(24, W, A, B, C, D, E, F, G, H, constants[24]);
            T_SHA2_16_79!Word(25, W, H, A, B, C, D, E, F, G, constants[25]);
            T_SHA2_16_79!Word(26, W, G, H, A, B, C, D, E, F, constants[26]);
            T_SHA2_16_79!Word(27, W, F, G, H, A, B, C, D, E, constants[27]);
            T_SHA2_16_79!Word(28, W, E, F, G, H, A, B, C, D, constants[28]);
            T_SHA2_16_79!Word(29, W, D, E, F, G, H, A, B, C, constants[29]);
            T_SHA2_16_79!Word(30, W, C, D, E, F, G, H, A, B, constants[30]);
            T_SHA2_16_79!Word(31, W, B, C, D, E, F, G, H, A, constants[31]);
            T_SHA2_16_79!Word(32, W, A, B, C, D, E, F, G, H, constants[32]);
            T_SHA2_16_79!Word(33, W, H, A, B, C, D, E, F, G, constants[33]);
            T_SHA2_16_79!Word(34, W, G, H, A, B, C, D, E, F, constants[34]);
            T_SHA2_16_79!Word(35, W, F, G, H, A, B, C, D, E, constants[35]);
            T_SHA2_16_79!Word(36, W, E, F, G, H, A, B, C, D, constants[36]);
            T_SHA2_16_79!Word(37, W, D, E, F, G, H, A, B, C, constants[37]);
            T_SHA2_16_79!Word(38, W, C, D, E, F, G, H, A, B, constants[38]);
            T_SHA2_16_79!Word(39, W, B, C, D, E, F, G, H, A, constants[39]);
            T_SHA2_16_79!Word(40, W, A, B, C, D, E, F, G, H, constants[40]);
            T_SHA2_16_79!Word(41, W, H, A, B, C, D, E, F, G, constants[41]);
            T_SHA2_16_79!Word(42, W, G, H, A, B, C, D, E, F, constants[42]);
            T_SHA2_16_79!Word(43, W, F, G, H, A, B, C, D, E, constants[43]);
            T_SHA2_16_79!Word(44, W, E, F, G, H, A, B, C, D, constants[44]);
            T_SHA2_16_79!Word(45, W, D, E, F, G, H, A, B, C, constants[45]);
            T_SHA2_16_79!Word(46, W, C, D, E, F, G, H, A, B, constants[46]);
            T_SHA2_16_79!Word(47, W, B, C, D, E, F, G, H, A, constants[47]);
            T_SHA2_16_79!Word(48, W, A, B, C, D, E, F, G, H, constants[48]);
            T_SHA2_16_79!Word(49, W, H, A, B, C, D, E, F, G, constants[49]);
            T_SHA2_16_79!Word(50, W, G, H, A, B, C, D, E, F, constants[50]);
            T_SHA2_16_79!Word(51, W, F, G, H, A, B, C, D, E, constants[51]);
            T_SHA2_16_79!Word(52, W, E, F, G, H, A, B, C, D, constants[52]);
            T_SHA2_16_79!Word(53, W, D, E, F, G, H, A, B, C, constants[53]);
            T_SHA2_16_79!Word(54, W, C, D, E, F, G, H, A, B, constants[54]);
            T_SHA2_16_79!Word(55, W, B, C, D, E, F, G, H, A, constants[55]);
            T_SHA2_16_79!Word(56, W, A, B, C, D, E, F, G, H, constants[56]);
            T_SHA2_16_79!Word(57, W, H, A, B, C, D, E, F, G, constants[57]);
            T_SHA2_16_79!Word(58, W, G, H, A, B, C, D, E, F, constants[58]);
            T_SHA2_16_79!Word(59, W, F, G, H, A, B, C, D, E, constants[59]);
            T_SHA2_16_79!Word(60, W, E, F, G, H, A, B, C, D, constants[60]);
            T_SHA2_16_79!Word(61, W, D, E, F, G, H, A, B, C, constants[61]);
            T_SHA2_16_79!Word(62, W, C, D, E, F, G, H, A, B, constants[62]);
            T_SHA2_16_79!Word(63, W, B, C, D, E, F, G, H, A, constants[63]);

            static if (is(Word == ulong))
            {
                T_SHA2_16_79!Word(64, W, A, B, C, D, E, F, G, H, constants[64]);
                T_SHA2_16_79!Word(65, W, H, A, B, C, D, E, F, G, constants[65]);
                T_SHA2_16_79!Word(66, W, G, H, A, B, C, D, E, F, constants[66]);
                T_SHA2_16_79!Word(67, W, F, G, H, A, B, C, D, E, constants[67]);
                T_SHA2_16_79!Word(68, W, E, F, G, H, A, B, C, D, constants[68]);
                T_SHA2_16_79!Word(69, W, D, E, F, G, H, A, B, C, constants[69]);
                T_SHA2_16_79!Word(70, W, C, D, E, F, G, H, A, B, constants[70]);
                T_SHA2_16_79!Word(71, W, B, C, D, E, F, G, H, A, constants[71]);
                T_SHA2_16_79!Word(72, W, A, B, C, D, E, F, G, H, constants[72]);
                T_SHA2_16_79!Word(73, W, H, A, B, C, D, E, F, G, constants[73]);
                T_SHA2_16_79!Word(74, W, G, H, A, B, C, D, E, F, constants[74]);
                T_SHA2_16_79!Word(75, W, F, G, H, A, B, C, D, E, constants[75]);
                T_SHA2_16_79!Word(76, W, E, F, G, H, A, B, C, D, constants[76]);
                T_SHA2_16_79!Word(77, W, D, E, F, G, H, A, B, C, constants[77]);
                T_SHA2_16_79!Word(78, W, C, D, E, F, G, H, A, B, constants[78]);
                T_SHA2_16_79!Word(79, W, B, C, D, E, F, G, H, A, constants[79]);
            }

            (*state)[0] += A;
            (*state)[1] += B;
            (*state)[2] += C;
            (*state)[3] += D;
            (*state)[4] += E;
            (*state)[5] += F;
            (*state)[6] += G;
            (*state)[7] += H;

            /* Zeroize sensitive information. */
            W[] = 0;
        }

    public:
        /**
         * SHA initialization. Begins an SHA1/SHA2 operation.
         *
         * Note:
         * For this SHA Digest implementation calling start after default construction
         * is not necessary. Calling start is only necessary to reset the Digest.
         *
         * Generic code which deals with different Digest types should always call start though.
         *
         * Example:
         * --------
         * SHA1 digest;
         * //digest.start(); //Not necessary
         * digest.put(0);
         * --------
         */
        void start() @safe pure nothrow @nogc
        {
            this = typeof(this).init;
        }

        /**
         * Use this to feed the digest with data.
         * Also implements the $(REF isOutputRange, std,range,primitives)
         * interface for `ubyte` and `const(ubyte)[]`.
         */
        void put(scope const(ubyte)[] input...) @trusted pure nothrow @nogc
        {
            enum blockSizeInBytes = blockSize/8;

            size_t i;
            uint index, partLen;
            auto inputLen = input.length;

            /* Compute number of bytes mod block size (64 or 128 bytes) */
            index = (cast(uint) count[0] >> 3) & (blockSizeInBytes - 1);

            /* Update number of bits */
            static if (blockSize == 512)
                count[0] += inputLen * 8;
            else static if (blockSize == 1024)
            {
                /* ugly hack to work around lack of ucent */
                auto oldCount0 = count[0];
                count[0] += inputLen * 8;
                if (count[0] < oldCount0)
                    count[1]++;
            }
            else
                static assert(0);

            partLen = blockSizeInBytes - index;

            /* Transform as many times as possible. */
            if (inputLen >= partLen)
            {
                (&buffer[index])[0 .. partLen] = input.ptr[0 .. partLen];
                transform (&state, &buffer);

                for (i = partLen; i + blockSizeInBytes-1 < inputLen; i += blockSizeInBytes)
                   transform(&state, cast(ubyte[blockSizeInBytes]*)(input.ptr + i));

                index = 0;
            }
            else
                i = 0;

            /* Buffer remaining input */
            if (inputLen - i)
                (&buffer[index])[0 .. inputLen-i] = (&input[i])[0 .. inputLen-i];
        }

        @safe unittest
        {
            typeof(this) dig;
            dig.put(cast(ubyte) 0); //single ubyte
            dig.put(cast(ubyte) 0, cast(ubyte) 0); //variadic
            ubyte[10] buf;
            dig.put(buf); //buffer
        }


        /**
         * Returns the finished SHA hash. This also calls $(LREF start) to
         * reset the internal state.
         */
        ubyte[digestSize/8] finish() @trusted pure nothrow @nogc
        {
            static if (blockSize == 512)
            {
                uint[8] data = void;
                uint index, padLen;

                /* Save number of bits */
                ulong bits = nativeToBigEndian(count[0]);

                /* Pad out to 56 mod 64. */
                index = (cast(uint) count[0] >> 3) & (64 - 1);
                padLen = (index < 56) ? (56 - index) : (120 - index);
                put(padding[0 .. padLen]);

                /* Append length (before padding) */
                put((cast(ubyte*) &bits)[0 .. bits.sizeof]);

                /* Store state in digest */
                static foreach (i; 0 .. (digestSize == 160) ? 5 : 8)
                    data[i] = nativeToBigEndian(state[i]);

                /* Zeroize sensitive information. */
                start();
                return (cast(ubyte*) data.ptr)[0 .. digestSize/8];
            }
            else static if (blockSize == 1024)
            {
                ulong[8] data = void;
                uint index, padLen;

                /* Save number of bits */
                ulong[2] bits = [nativeToBigEndian(count[1]), nativeToBigEndian(count[0])];

                /* Pad out to 112 mod 128. */
                index = (cast(uint) count[0] >> 3) & (128 - 1);
                padLen = (index < 112) ? (112 - index) : (240 - index);
                put(padding[0 .. padLen]);

                /* Append length (before padding) */
                put((cast(ubyte*) &bits)[0 .. bits.sizeof]);

                /* Store state in digest */
                static foreach (i; 0 .. 8)
                    data[i] = nativeToBigEndian(state[i]);

                /* Zeroize sensitive information. */
                start();
                return (cast(ubyte*) data.ptr)[0 .. digestSize/8];
            }
            else
                static assert(0);
        }
        ///
        @safe unittest
        {
            //Simple example
            SHA1 hash;
            hash.start();
            hash.put(cast(ubyte) 0);
            ubyte[20] result = hash.finish();
        }
}

///
@safe unittest
{
    //Simple example, hashing a string using sha1Of helper function
    ubyte[20] hash = sha1Of("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "A9993E364706816ABA3E25717850C26C9CD0D89D");

    //The same, but using SHA-224
    ubyte[28] hash224 = sha224Of("abc");
    assert(toHexString(hash224) == "23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7");
}

///
@safe unittest
{
    //Using the basic API
    SHA1 hash;
    hash.start();
    ubyte[1024] data;
    //Initialize data here...
    hash.put(data);
    ubyte[20] result = hash.finish();
}

///
@safe unittest
{
    //Let's use the template features:
    //Note: When passing a SHA1 to a function, it must be passed by reference!
    void doSomething(T)(ref T hash)
    if (isDigest!T)
    {
      hash.put(cast(ubyte) 0);
    }
    SHA1 sha;
    sha.start();
    doSomething(sha);
    assert(toHexString(sha.finish()) == "5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F");
}

alias SHA1 = SHA!(512, 160);  /// SHA alias for SHA-1, hash is ubyte[20]
alias SHA224 = SHA!(512, 224);  /// SHA alias for SHA-224, hash is ubyte[28]
alias SHA256 = SHA!(512, 256);  /// SHA alias for SHA-256, hash is ubyte[32]
alias SHA384 = SHA!(1024, 384); /// SHA alias for SHA-384, hash is ubyte[48]
alias SHA512 = SHA!(1024, 512); /// SHA alias for SHA-512, hash is ubyte[64]
alias SHA512_224 = SHA!(1024, 224); /// SHA alias for SHA-512/224, hash is ubyte[28]
alias SHA512_256 = SHA!(1024, 256); /// SHA alias for SHA-512/256, hash is ubyte[32]

@safe unittest
{
    assert(isDigest!SHA1);
    assert(isDigest!SHA224);
    assert(isDigest!SHA256);
    assert(isDigest!SHA384);
    assert(isDigest!SHA512);
    assert(isDigest!SHA512_224);
    assert(isDigest!SHA512_256);
}

@system unittest
{
    import std.conv : hexString;
    import std.range;

    ubyte[20] digest;
    ubyte[28] digest224;
    ubyte[32] digest256;
    ubyte[48] digest384;
    ubyte[64] digest512;
    ubyte[28] digest512_224;
    ubyte[32] digest512_256;

    SHA1 sha;
    sha.put(cast(ubyte[])"abcdef");
    sha.start();
    sha.put(cast(ubyte[])"");
    assert(sha.finish() == cast(ubyte[]) hexString!"da39a3ee5e6b4b0d3255bfef95601890afd80709");

    SHA224 sha224;
    sha224.put(cast(ubyte[])"abcdef");
    sha224.start();
    sha224.put(cast(ubyte[])"");
    assert(sha224.finish() == cast(ubyte[]) hexString!"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f");

    SHA256 sha256;
    sha256.put(cast(ubyte[])"abcdef");
    sha256.start();
    sha256.put(cast(ubyte[])"");
    assert(sha256.finish() == cast(ubyte[])
            hexString!"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");

    SHA384 sha384;
    sha384.put(cast(ubyte[])"abcdef");
    sha384.start();
    sha384.put(cast(ubyte[])"");
    assert(sha384.finish() == cast(ubyte[]) hexString!("38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c"
        ~"0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"));

    SHA512 sha512;
    sha512.put(cast(ubyte[])"abcdef");
    sha512.start();
    sha512.put(cast(ubyte[])"");
    assert(sha512.finish() == cast(ubyte[])
            hexString!("cf83e1357eefb8bdf1542850d66d8007d620e4050b571"
        ~"5dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"));

    SHA512_224 sha512_224;
    sha512_224.put(cast(ubyte[])"abcdef");
    sha512_224.start();
    sha512_224.put(cast(ubyte[])"");
    assert(sha512_224.finish() == cast(ubyte[]) hexString!"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4");

    SHA512_256 sha512_256;
    sha512_256.put(cast(ubyte[])"abcdef");
    sha512_256.start();
    sha512_256.put(cast(ubyte[])"");
    assert(sha512_256.finish() == cast(ubyte[])
            hexString!"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a");

    digest        = sha1Of      ("");
    digest224     = sha224Of    ("");
    digest256     = sha256Of    ("");
    digest384     = sha384Of    ("");
    digest512     = sha512Of    ("");
    digest512_224 = sha512_224Of("");
    digest512_256 = sha512_256Of("");
    assert(digest == cast(ubyte[]) hexString!"da39a3ee5e6b4b0d3255bfef95601890afd80709");
    assert(digest224 == cast(ubyte[]) hexString!"d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f");
    assert(digest256 == cast(ubyte[]) hexString!"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855");
    assert(digest384 == cast(ubyte[]) hexString!("38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c"
        ~"0cc7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"));
    assert(digest512 == cast(ubyte[]) hexString!("cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83"
        ~"f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"));
    assert(digest512_224 == cast(ubyte[]) hexString!"6ed0dd02806fa89e25de060c19d3ac86cabb87d6a0ddd05c333b84f4");
    assert(digest512_256 == cast(ubyte[]) hexString!"c672b8d1ef56ed28ab87c3622c5114069bdd3ad7b8f9737498d0c01ecef0967a");

    digest        = sha1Of      ("a");
    digest224     = sha224Of    ("a");
    digest256     = sha256Of    ("a");
    digest384     = sha384Of    ("a");
    digest512     = sha512Of    ("a");
    digest512_224 = sha512_224Of("a");
    digest512_256 = sha512_256Of("a");
    assert(digest == cast(ubyte[]) hexString!"86f7e437faa5a7fce15d1ddcb9eaeaea377667b8");
    assert(digest224 == cast(ubyte[]) hexString!"abd37534c7d9a2efb9465de931cd7055ffdb8879563ae98078d6d6d5");
    assert(digest256 == cast(ubyte[]) hexString!"ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb");
    assert(digest384 == cast(ubyte[]) hexString!("54a59b9f22b0b80880d8427e548b7c23abd873486e1f035dce9"
        ~"cd697e85175033caa88e6d57bc35efae0b5afd3145f31"));
    assert(digest512 == cast(ubyte[]) hexString!("1f40fc92da241694750979ee6cf582f2d5d7d28e18335de05ab"
        ~"c54d0560e0f5302860c652bf08d560252aa5e74210546f369fbbbce8c12cfc7957b2652fe9a75"));
    assert(digest512_224 == cast(ubyte[]) hexString!"d5cdb9ccc769a5121d4175f2bfdd13d6310e0d3d361ea75d82108327");
    assert(digest512_256 == cast(ubyte[]) hexString!"455e518824bc0601f9fb858ff5c37d417d67c2f8e0df2babe4808858aea830f8");

    digest        = sha1Of      ("abc");
    digest224     = sha224Of    ("abc");
    digest256     = sha256Of    ("abc");
    digest384     = sha384Of    ("abc");
    digest512     = sha512Of    ("abc");
    digest512_224 = sha512_224Of("abc");
    digest512_256 = sha512_256Of("abc");
    assert(digest == cast(ubyte[]) hexString!"a9993e364706816aba3e25717850c26c9cd0d89d");
    assert(digest224 == cast(ubyte[]) hexString!"23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7");
    assert(digest256 == cast(ubyte[]) hexString!"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad");
    assert(digest384 == cast(ubyte[]) hexString!("cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a"
        ~"8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"));
    assert(digest512 == cast(ubyte[]) hexString!("ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9"
        ~"eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"));
    assert(digest512_224 == cast(ubyte[]) hexString!"4634270f707b6a54daae7530460842e20e37ed265ceee9a43e8924aa");
    assert(digest512_256 == cast(ubyte[]) hexString!"53048e2681941ef99b2e29b76b4c7dabe4c2d0c634fc6d46e0e2f13107e7af23");

    digest        = sha1Of      ("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest224     = sha224Of    ("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest256     = sha256Of    ("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest384     = sha384Of    ("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest512     = sha512Of    ("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest512_224 = sha512_224Of("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    digest512_256 = sha512_256Of("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq");
    assert(digest == cast(ubyte[]) hexString!"84983e441c3bd26ebaae4aa1f95129e5e54670f1");
    assert(digest224 == cast(ubyte[]) hexString!"75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525");
    assert(digest256 == cast(ubyte[]) hexString!"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1");
    assert(digest384 == cast(ubyte[]) hexString!("3391fdddfc8dc7393707a65b1b4709397cf8b1d162af05abfe"
        ~"8f450de5f36bc6b0455a8520bc4e6f5fe95b1fe3c8452b"));
    assert(digest512 == cast(ubyte[]) hexString!("204a8fc6dda82f0a0ced7beb8e08a41657c16ef468b228a827"
        ~"9be331a703c33596fd15c13b1b07f9aa1d3bea57789ca031ad85c7a71dd70354ec631238ca3445"));
    assert(digest512_224 == cast(ubyte[]) hexString!"e5302d6d54bb242275d1e7622d68df6eb02dedd13f564c13dbda2174");
    assert(digest512_256 == cast(ubyte[]) hexString!"bde8e1f9f19bb9fd3406c90ec6bc47bd36d8ada9f11880dbc8a22a7078b6a461");

    digest        = sha1Of      ("message digest");
    digest224     = sha224Of    ("message digest");
    digest256     = sha256Of    ("message digest");
    digest384     = sha384Of    ("message digest");
    digest512     = sha512Of    ("message digest");
    digest512_224 = sha512_224Of("message digest");
    digest512_256 = sha512_256Of("message digest");
    assert(digest == cast(ubyte[]) hexString!"c12252ceda8be8994d5fa0290a47231c1d16aae3");
    assert(digest224 == cast(ubyte[]) hexString!"2cb21c83ae2f004de7e81c3c7019cbcb65b71ab656b22d6d0c39b8eb");
    assert(digest256 == cast(ubyte[]) hexString!"f7846f55cf23e14eebeab5b4e1550cad5b509e3348fbc4efa3a1413d393cb650");
    assert(digest384 == cast(ubyte[]) hexString!("473ed35167ec1f5d8e550368a3db39be54639f828868e9454c"
        ~"239fc8b52e3c61dbd0d8b4de1390c256dcbb5d5fd99cd5"));
    assert(digest512 == cast(ubyte[]) hexString!("107dbf389d9e9f71a3a95f6c055b9251bc5268c2be16d6c134"
        ~"92ea45b0199f3309e16455ab1e96118e8a905d5597b72038ddb372a89826046de66687bb420e7c"));
    assert(digest512_224 == cast(ubyte[]) hexString!"ad1a4db188fe57064f4f24609d2a83cd0afb9b398eb2fcaeaae2c564");
    assert(digest512_256 == cast(ubyte[]) hexString!"0cf471fd17ed69d990daf3433c89b16d63dec1bb9cb42a6094604ee5d7b4e9fb");

    digest        = sha1Of      ("abcdefghijklmnopqrstuvwxyz");
    digest224     = sha224Of    ("abcdefghijklmnopqrstuvwxyz");
    digest256     = sha256Of    ("abcdefghijklmnopqrstuvwxyz");
    digest384     = sha384Of    ("abcdefghijklmnopqrstuvwxyz");
    digest512     = sha512Of    ("abcdefghijklmnopqrstuvwxyz");
    digest512_224 = sha512_224Of("abcdefghijklmnopqrstuvwxyz");
    digest512_256 = sha512_256Of("abcdefghijklmnopqrstuvwxyz");
    assert(digest == cast(ubyte[]) hexString!"32d10c7b8cf96570ca04ce37f2a19d84240d3a89");
    assert(digest224 == cast(ubyte[]) hexString!"45a5f72c39c5cff2522eb3429799e49e5f44b356ef926bcf390dccc2");
    assert(digest256 == cast(ubyte[]) hexString!"71c480df93d6ae2f1efad1447c66c9525e316218cf51fc8d9ed832f2daf18b73");
    assert(digest384 == cast(ubyte[]) hexString!("feb67349df3db6f5924815d6c3dc133f091809213731fe5c7b5"
        ~"f4999e463479ff2877f5f2936fa63bb43784b12f3ebb4"));
    assert(digest512 == cast(ubyte[]) hexString!("4dbff86cc2ca1bae1e16468a05cb9881c97f1753bce3619034"
        ~"898faa1aabe429955a1bf8ec483d7421fe3c1646613a59ed5441fb0f321389f77f48a879c7b1f1"));
    assert(digest512_224 == cast(ubyte[]) hexString!"ff83148aa07ec30655c1b40aff86141c0215fe2a54f767d3f38743d8");
    assert(digest512_256 == cast(ubyte[]) hexString!"fc3189443f9c268f626aea08a756abe7b726b05f701cb08222312ccfd6710a26");

    digest        = sha1Of      ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest224     = sha224Of    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest256     = sha256Of    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest384     = sha384Of    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest512     = sha512Of    ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest512_224 = sha512_224Of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    digest512_256 = sha512_256Of("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789");
    assert(digest == cast(ubyte[]) hexString!"761c457bf73b14d27e9e9265c46f4b4dda11f940");
    assert(digest224 == cast(ubyte[]) hexString!"bff72b4fcb7d75e5632900ac5f90d219e05e97a7bde72e740db393d9");
    assert(digest256 == cast(ubyte[]) hexString!"db4bfcbd4da0cd85a60c3c37d3fbd8805c77f15fc6b1fdfe614ee0a7c8fdb4c0");
    assert(digest384 == cast(ubyte[]) hexString!("1761336e3f7cbfe51deb137f026f89e01a448e3b1fafa64039"
        ~"c1464ee8732f11a5341a6f41e0c202294736ed64db1a84"));
    assert(digest512 == cast(ubyte[]) hexString!("1e07be23c26a86ea37ea810c8ec7809352515a970e9253c26f"
        ~"536cfc7a9996c45c8370583e0a78fa4a90041d71a4ceab7423f19c71b9d5a3e01249f0bebd5894"));
    assert(digest512_224 == cast(ubyte[]) hexString!"a8b4b9174b99ffc67d6f49be9981587b96441051e16e6dd036b140d3");
    assert(digest512_256 == cast(ubyte[]) hexString!"cdf1cc0effe26ecc0c13758f7b4a48e000615df241284185c39eb05d355bb9c8");

    digest        = sha1Of      ("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest224     = sha224Of    ("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest256     = sha256Of    ("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest384     = sha384Of    ("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest512     = sha512Of    ("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest512_224 = sha512_224Of("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    digest512_256 = sha512_256Of("1234567890123456789012345678901234567890"~
                                 "1234567890123456789012345678901234567890");
    assert(digest == cast(ubyte[]) hexString!"50abf5706a150990a08b2c5ea40fa0e585554732");
    assert(digest224 == cast(ubyte[]) hexString!"b50aecbe4e9bb0b57bc5f3ae760a8e01db24f203fb3cdcd13148046e");
    assert(digest256 == cast(ubyte[]) hexString!"f371bc4a311f2b009eef952dd83ca80e2b60026c8e935592d0f9c308453c813e");
    assert(digest384 == cast(ubyte[]) hexString!("b12932b0627d1c060942f5447764155655bd4da0c9afa6dd9b"
        ~"9ef53129af1b8fb0195996d2de9ca0df9d821ffee67026"));
    assert(digest512 == cast(ubyte[]) hexString!("72ec1ef1124a45b047e8b7c75a932195135bb61de24ec0d191"
        ~"4042246e0aec3a2354e093d76f3048b456764346900cb130d2a4fd5dd16abb5e30bcb850dee843"));
    assert(digest512_224 == cast(ubyte[]) hexString!"ae988faaa47e401a45f704d1272d99702458fea2ddc6582827556dd2");
    assert(digest512_256 == cast(ubyte[]) hexString!"2c9fdbc0c90bdd87612ee8455474f9044850241dc105b1e8b94b8ddf5fac9148");

    ubyte[] onemilliona = new ubyte[1000000];
    onemilliona[] = 'a';
    digest = sha1Of(onemilliona);
    digest224 = sha224Of(onemilliona);
    digest256 = sha256Of(onemilliona);
    digest384 = sha384Of(onemilliona);
    digest512 = sha512Of(onemilliona);
    digest512_224 = sha512_224Of(onemilliona);
    digest512_256 = sha512_256Of(onemilliona);
    assert(digest == cast(ubyte[]) hexString!"34aa973cd4c4daa4f61eeb2bdbad27316534016f");
    assert(digest224 == cast(ubyte[]) hexString!"20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67");
    assert(digest256 == cast(ubyte[]) hexString!"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0");
    assert(digest384 == cast(ubyte[]) hexString!("9d0e1809716474cb086e834e310a4a1ced149e9c00f2485279"
        ~"72cec5704c2a5b07b8b3dc38ecc4ebae97ddd87f3d8985"));
    assert(digest512 == cast(ubyte[]) hexString!("e718483d0ce769644e2e42c7bc15b4638e1f98b13b20442856"
        ~"32a803afa973ebde0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"));
    assert(digest512_224 == cast(ubyte[]) hexString!"37ab331d76f0d36de422bd0edeb22a28accd487b7a8453ae965dd287");
    assert(digest512_256 == cast(ubyte[]) hexString!"9a59a052930187a97038cae692f30708aa6491923ef5194394dc68d56c74fb21");

    auto oneMillionRange = repeat!ubyte(cast(ubyte)'a', 1000000);
    digest = sha1Of(oneMillionRange);
    digest224 = sha224Of(oneMillionRange);
    digest256 = sha256Of(oneMillionRange);
    digest384 = sha384Of(oneMillionRange);
    digest512 = sha512Of(oneMillionRange);
    digest512_224 = sha512_224Of(oneMillionRange);
    digest512_256 = sha512_256Of(oneMillionRange);
    assert(digest == cast(ubyte[]) hexString!"34aa973cd4c4daa4f61eeb2bdbad27316534016f");
    assert(digest224 == cast(ubyte[]) hexString!"20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67");
    assert(digest256 == cast(ubyte[]) hexString!"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0");
    assert(digest384 == cast(ubyte[]) hexString!("9d0e1809716474cb086e834e310a4a1ced149e9c00f2485279"
        ~"72cec5704c2a5b07b8b3dc38ecc4ebae97ddd87f3d8985"));
    assert(digest512 == cast(ubyte[]) hexString!("e718483d0ce769644e2e42c7bc15b4638e1f98b13b20442856"
        ~"32a803afa973ebde0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"));
    assert(digest512_224 == cast(ubyte[]) hexString!"37ab331d76f0d36de422bd0edeb22a28accd487b7a8453ae965dd287");
    assert(digest512_256 == cast(ubyte[]) hexString!"9a59a052930187a97038cae692f30708aa6491923ef5194394dc68d56c74fb21");

    enum ubyte[20] input = cast(ubyte[20]) hexString!"a9993e364706816aba3e25717850c26c9cd0d89d";
    assert(toHexString(input)
        == "A9993E364706816ABA3E25717850C26C9CD0D89D");
}

/**
 * These are convenience aliases for $(REF digest, std,digest) using the
 * SHA implementation.
 */
//simple alias doesn't work here, hope this gets inlined...
auto sha1Of(T...)(T data)
{
    return digest!(SHA1, T)(data);
}
///ditto
auto sha224Of(T...)(T data)
{
    return digest!(SHA224, T)(data);
}
///ditto
auto sha256Of(T...)(T data)
{
    return digest!(SHA256, T)(data);
}
///ditto
auto sha384Of(T...)(T data)
{
    return digest!(SHA384, T)(data);
}
///ditto
auto sha512Of(T...)(T data)
{
    return digest!(SHA512, T)(data);
}
///ditto
auto sha512_224Of(T...)(T data)
{
    return digest!(SHA512_224, T)(data);
}
///ditto
auto sha512_256Of(T...)(T data)
{
    return digest!(SHA512_256, T)(data);
}

///
@safe unittest
{
    ubyte[20] hash = sha1Of("abc");
    assert(hash == digest!SHA1("abc"));

    ubyte[28] hash224 = sha224Of("abc");
    assert(hash224 == digest!SHA224("abc"));

    ubyte[32] hash256 = sha256Of("abc");
    assert(hash256 == digest!SHA256("abc"));

    ubyte[48] hash384 = sha384Of("abc");
    assert(hash384 == digest!SHA384("abc"));

    ubyte[64] hash512 = sha512Of("abc");
    assert(hash512 == digest!SHA512("abc"));

    ubyte[28] hash512_224 = sha512_224Of("abc");
    assert(hash512_224 == digest!SHA512_224("abc"));

    ubyte[32] hash512_256 = sha512_256Of("abc");
    assert(hash512_256 == digest!SHA512_256("abc"));
}

@safe unittest
{
    string a = "Mary has ", b = "a little lamb";
    int[] c = [ 1, 2, 3, 4, 5 ];
    auto d = toHexString(sha1Of(a, b, c));
    version (LittleEndian)
        assert(d[] == "CDBB611D00AC2387B642D3D7BDF4C3B342237110", d.dup);
    else
        assert(d[] == "A0F1196C7A379C09390476D9CA4AA11B71FD11C8", d.dup);
}

/**
 * OOP API SHA1 and SHA2 implementations.
 * See `std.digest` for differences between template and OOP API.
 *
 * This is an alias for $(D $(REF WrapperDigest, std,digest)!SHA1), see
 * there for more information.
 */
alias SHA1Digest = WrapperDigest!SHA1;
alias SHA224Digest = WrapperDigest!SHA224; ///ditto
alias SHA256Digest = WrapperDigest!SHA256; ///ditto
alias SHA384Digest = WrapperDigest!SHA384; ///ditto
alias SHA512Digest = WrapperDigest!SHA512; ///ditto
alias SHA512_224Digest = WrapperDigest!SHA512_224; ///ditto
alias SHA512_256Digest = WrapperDigest!SHA512_256; ///ditto

///
@safe unittest
{
    //Simple example, hashing a string using Digest.digest helper function
    auto sha = new SHA1Digest();
    ubyte[] hash = sha.digest("abc");
    //Let's get a hash string
    assert(toHexString(hash) == "A9993E364706816ABA3E25717850C26C9CD0D89D");

    //The same, but using SHA-224
    auto sha224 = new SHA224Digest();
    ubyte[] hash224 = sha224.digest("abc");
    //Let's get a hash string
    assert(toHexString(hash224) == "23097D223405D8228642A477BDA255B32AADBCE4BDA0B3F7E36C9DA7");
}

///
@system unittest
{
    //Let's use the OOP features:
    void test(Digest dig)
    {
      dig.put(cast(ubyte) 0);
    }
    auto sha = new SHA1Digest();
    test(sha);

    //Let's use a custom buffer:
    ubyte[20] buf;
    ubyte[] result = sha.finish(buf[]);
    assert(toHexString(result) == "5BA93C9DB0CFF93F52B521D7420E43F6EDA2784F");
}

@system unittest
{
    import std.conv : hexString;
    import std.exception;
    auto sha = new SHA1Digest();

    sha.put(cast(ubyte[])"abcdef");
    sha.reset();
    sha.put(cast(ubyte[])"");
    assert(sha.finish() == cast(ubyte[]) hexString!"da39a3ee5e6b4b0d3255bfef95601890afd80709");

    sha.put(cast(ubyte[])"abcdefghijklmnopqrstuvwxyz");
    ubyte[22] result;
    auto result2 = sha.finish(result[]);
    assert(result[0 .. 20] == result2 && result2 == cast(ubyte[]) hexString!"32d10c7b8cf96570ca04ce37f2a19d84240d3a89");

    debug
        assertThrown!Error(sha.finish(result[0 .. 15]));

    assert(sha.length == 20);

    assert(sha.digest("") == cast(ubyte[]) hexString!"da39a3ee5e6b4b0d3255bfef95601890afd80709");

    assert(sha.digest("a") == cast(ubyte[]) hexString!"86f7e437faa5a7fce15d1ddcb9eaeaea377667b8");

    assert(sha.digest("abc") == cast(ubyte[]) hexString!"a9993e364706816aba3e25717850c26c9cd0d89d");

    assert(sha.digest("abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq")
           == cast(ubyte[]) hexString!"84983e441c3bd26ebaae4aa1f95129e5e54670f1");

    assert(sha.digest("message digest") == cast(ubyte[]) hexString!"c12252ceda8be8994d5fa0290a47231c1d16aae3");

    assert(sha.digest("abcdefghijklmnopqrstuvwxyz")
           == cast(ubyte[]) hexString!"32d10c7b8cf96570ca04ce37f2a19d84240d3a89");

    assert(sha.digest("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789")
           == cast(ubyte[]) hexString!"761c457bf73b14d27e9e9265c46f4b4dda11f940");

    assert(sha.digest("1234567890123456789012345678901234567890",
                                   "1234567890123456789012345678901234567890")
           == cast(ubyte[]) hexString!"50abf5706a150990a08b2c5ea40fa0e585554732");

    ubyte[] onemilliona = new ubyte[1000000];
    onemilliona[] = 'a';
    assert(sha.digest(onemilliona) == cast(ubyte[]) hexString!"34aa973cd4c4daa4f61eeb2bdbad27316534016f");
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // Written in the D programming language.

/**
Classes and functions for handling and transcoding between various encodings.

For cases where the encoding is known at compile-time, functions are provided
for arbitrary encoding and decoding of characters, arbitrary transcoding
between strings of different type, as well as validation and sanitization.

Encodings currently supported are UTF-8, UTF-16, UTF-32, ASCII, ISO-8859-1
(also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250, WINDOWS-1251
and WINDOWS-1252.

$(SCRIPT inhibitQuickIndex = 1;)
$(DIVC quickindex,
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD Decode) $(TD
    $(LREF codePoints)
    $(LREF decode)
    $(LREF decodeReverse)
    $(LREF safeDecode)
))
$(TR $(TD Conversion) $(TD
    $(LREF codeUnits)
    $(LREF sanitize)
    $(LREF transcode)
))
$(TR $(TD Classification) $(TD
    $(LREF canEncode)
    $(LREF isValid)
    $(LREF isValidCodePoint)
    $(LREF isValidCodeUnit)
))
$(TR $(TD BOM) $(TD
    $(LREF BOM)
    $(LREF BOMSeq)
    $(LREF getBOM)
    $(LREF utfBOM)
))
$(TR $(TD Length &amp; Index) $(TD
    $(LREF firstSequence)
    $(LREF encodedLength)
    $(LREF index)
    $(LREF lastSequence)
    $(LREF validLength)
))
$(TR $(TD Encoding schemes) $(TD
    $(LREF encodingName)
    $(LREF EncodingScheme)
    $(LREF EncodingSchemeASCII)
    $(LREF EncodingSchemeLatin1)
    $(LREF EncodingSchemeLatin2)
    $(LREF EncodingSchemeUtf16Native)
    $(LREF EncodingSchemeUtf32Native)
    $(LREF EncodingSchemeUtf8)
    $(LREF EncodingSchemeWindows1250)
    $(LREF EncodingSchemeWindows1251)
    $(LREF EncodingSchemeWindows1252)
))
$(TR $(TD Representation) $(TD
    $(LREF AsciiChar)
    $(LREF AsciiString)
    $(LREF Latin1Char)
    $(LREF Latin1String)
    $(LREF Latin2Char)
    $(LREF Latin2String)
    $(LREF Windows1250Char)
    $(LREF Windows1250String)
    $(LREF Windows1251Char)
    $(LREF Windows1251String)
    $(LREF Windows1252Char)
    $(LREF Windows1252String)
))
$(TR $(TD Exceptions) $(TD
    $(LREF INVALID_SEQUENCE)
    $(LREF EncodingException)
))
))

For cases where the encoding is not known at compile-time, but is
known at run-time, the abstract class $(LREF EncodingScheme)
and its subclasses is provided.  To construct a run-time encoder/decoder,
one does e.g.

----------------------------------------------------
auto e = EncodingScheme.create("utf-8");
----------------------------------------------------

This library supplies $(LREF EncodingScheme) subclasses for ASCII,
ISO-8859-1 (also known as LATIN-1), ISO-8859-2 (LATIN-2), WINDOWS-1250,
WINDOWS-1251, WINDOWS-1252, UTF-8, and (on little-endian architectures)
UTF-16LE and UTF-32LE; or (on big-endian architectures) UTF-16BE and UTF-32BE.

This library provides a mechanism whereby other modules may add $(LREF
EncodingScheme) subclasses for any other encoding.

Copyright: Copyright Janice Caron 2008 - 2009.
License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
Authors:   Janice Caron
Source:    $(PHOBOSSRC std/encoding.d)
*/
/*
         Copyright Janice Caron 2008 - 2009.
Distributed under the Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt or copy at
         http://www.boost.org/LICENSE_1_0.txt)
*/
module std.encoding;

import std.range.primitives;
import std.traits;
import std.typecons;

@system unittest
{
    static ubyte[][] validStrings =
    [
        // Plain ASCII
        cast(ubyte[])"hello",

        // First possible sequence of a certain length
        [ 0x00 ],                       // U+00000000   one byte
        [ 0xC2, 0x80 ],                 // U+00000080   two bytes
        [ 0xE0, 0xA0, 0x80 ],           // U+00000800   three bytes
        [ 0xF0, 0x90, 0x80, 0x80 ],     // U+00010000   three bytes

        // Last possible sequence of a certain length
        [ 0x7F ],                       // U+0000007F   one byte
        [ 0xDF, 0xBF ],                 // U+000007FF   two bytes
        [ 0xEF, 0xBF, 0xBF ],           // U+0000FFFF   three bytes

        // Other boundary conditions
        [ 0xED, 0x9F, 0xBF ],
        // U+0000D7FF   Last character before surrogates
        [ 0xEE, 0x80, 0x80 ],
        // U+0000E000   First character after surrogates
        [ 0xEF, 0xBF, 0xBD ],
        // U+0000FFFD   Unicode replacement character
        [ 0xF4, 0x8F, 0xBF, 0xBF ],
        // U+0010FFFF   Very last character

        // Non-character code points
        /*  NOTE: These are legal in UTF, and may be converted from
            one UTF to another, however they do not represent Unicode
            characters. These code points have been reserved by
            Unicode as non-character code points. They are permissible
            for data exchange within an application, but they are are
            not permitted to be used as characters. Since this module
            deals with UTF, and not with Unicode per se, we choose to
            accept them here. */
        [ 0xDF, 0xBE ],                 // U+0000FFFE
        [ 0xDF, 0xBF ],                 // U+0000FFFF
    ];

    static ubyte[][] invalidStrings =
    [
        // First possible sequence of a certain length, but greater
        // than U+10FFFF
        [ 0xF8, 0x88, 0x80, 0x80, 0x80 ],           // U+00200000   five bytes
        [ 0xFC, 0x84, 0x80, 0x80, 0x80, 0x80 ],     // U+04000000   six bytes

        // Last possible sequence of a certain length, but greater than U+10FFFF
        [ 0xF7, 0xBF, 0xBF, 0xBF ],                 // U+001FFFFF   four bytes
        [ 0xFB, 0xBF, 0xBF, 0xBF, 0xBF ],           // U+03FFFFFF   five bytes
        [ 0xFD, 0xBF, 0xBF, 0xBF, 0xBF, 0xBF ],     // U+7FFFFFFF   six bytes

        // Other boundary conditions
        [ 0xF4, 0x90, 0x80, 0x80 ],                 // U+00110000
                                                    // First code
                                                    // point after
                                                    // last character

        // Unexpected continuation bytes
        [ 0x80 ],
        [ 0xBF ],
        [ 0x20, 0x80, 0x20 ],
        [ 0x20, 0xBF, 0x20 ],
        [ 0x80, 0x9F, 0xA0 ],

        // Lonely start bytes
        [ 0xC0 ],
        [ 0xCF ],
        [ 0x20, 0xC0, 0x20 ],
        [ 0x20, 0xCF, 0x20 ],
        [ 0xD0 ],
        [ 0xDF ],
        [ 0x20, 0xD0, 0x20 ],
        [ 0x20, 0xDF, 0x20 ],
        [ 0xE0 ],
        [ 0xEF ],
        [ 0x20, 0xE0, 0x20 ],
        [ 0x20, 0xEF, 0x20 ],
        [ 0xF0 ],
        [ 0xF1 ],
        [ 0xF2 ],
        [ 0xF3 ],
        [ 0xF4 ],
        [ 0xF5 ],   // If this were legal it would start a character > U+10FFFF
        [ 0xF6 ],   // If this were legal it would start a character > U+10FFFF
        [ 0xF7 ],   // If this were legal it would start a character > U+10FFFF

        [ 0xEF, 0xBF ],             // Three byte sequence with third byte missing
        [ 0xF7, 0xBF, 0xBF ],       // Four byte sequence with fourth byte missing
        [ 0xEF, 0xBF, 0xF7, 0xBF, 0xBF ],   // Concatenation of the above

        // Impossible bytes
        [ 0xF8 ],
        [ 0xF9 ],
        [ 0xFA ],
        [ 0xFB ],
        [ 0xFC ],
        [ 0xFD ],
        [ 0xFE ],
        [ 0xFF ],
        [ 0x20, 0xF8, 0x20 ],
        [ 0x20, 0xF9, 0x20 ],
        [ 0x20, 0xFA, 0x20 ],
        [ 0x20, 0xFB, 0x20 ],
        [ 0x20, 0xFC, 0x20 ],
        [ 0x20, 0xFD, 0x20 ],
        [ 0x20, 0xFE, 0x20 ],
        [ 0x20, 0xFF, 0x20 ],

        // Overlong sequences, all representing U+002F
        /*  With a safe UTF-8 decoder, all of the following five overlong
            representations of the ASCII character slash ("/") should be
            rejected like a malformed UTF-8 sequence */
        [ 0xC0, 0xAF ],
        [ 0xE0, 0x80, 0xAF ],
        [ 0xF0, 0x80, 0x80, 0xAF ],
        [ 0xF8, 0x80, 0x80, 0x80, 0xAF ],
        [ 0xFC, 0x80, 0x80, 0x80, 0x80, 0xAF ],

        // Maximum overlong sequences
        /*  Below you see the highest Unicode value that is still resulting in
            an overlong sequence if represented with the given number of bytes.
            This is a boundary test for safe UTF-8 decoders. All five
            characters should be rejected like malformed UTF-8 sequences. */
        [ 0xC1, 0xBF ],                             // U+0000007F
        [ 0xE0, 0x9F, 0xBF ],                       // U+000007FF
        [ 0xF0, 0x8F, 0xBF, 0xBF ],                 // U+0000FFFF
        [ 0xF8, 0x87, 0xBF, 0xBF, 0xBF ],           // U+001FFFFF
        [ 0xFC, 0x83, 0xBF, 0xBF, 0xBF, 0xBF ],     // U+03FFFFFF

        // Overlong representation of the NUL character
        /*  The following five sequences should also be rejected like malformed
            UTF-8 sequences and should not be treated like the ASCII NUL
            character. */
        [ 0xC0, 0x80 ],
        [ 0xE0, 0x80, 0x80 ],
        [ 0xF0, 0x80, 0x80, 0x80 ],
        [ 0xF8, 0x80, 0x80, 0x80, 0x80 ],
        [ 0xFC, 0x80, 0x80, 0x80, 0x80, 0x80 ],

        // Illegal code positions
        /*  The following UTF-8 sequences should be rejected like malformed
            sequences, because they never represent valid ISO 10646 characters
            and a UTF-8 decoder that accepts them might introduce security
            problems comparable to overlong UTF-8 sequences. */
        [ 0xED, 0xA0, 0x80 ],       // U+D800
        [ 0xED, 0xAD, 0xBF ],       // U+DB7F
        [ 0xED, 0xAE, 0x80 ],       // U+DB80
        [ 0xED, 0xAF, 0xBF ],       // U+DBFF
        [ 0xED, 0xB0, 0x80 ],       // U+DC00
        [ 0xED, 0xBE, 0x80 ],       // U+DF80
        [ 0xED, 0xBF, 0xBF ],       // U+DFFF
    ];

    static string[] sanitizedStrings =
    [
        "\uFFFD","\uFFFD",
        "\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD"," \uFFFD ",
        " \uFFFD ","\uFFFD\uFFFD\uFFFD","\uFFFD","\uFFFD"," \uFFFD "," \uFFFD ",
        "\uFFFD","\uFFFD"," \uFFFD "," \uFFFD ","\uFFFD","\uFFFD"," \uFFFD ",
        " \uFFFD ","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD",
        "\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD\uFFFD","\uFFFD","\uFFFD",
        "\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD"," \uFFFD ",
        " \uFFFD "," \uFFFD "," \uFFFD "," \uFFFD "," \uFFFD "," \uFFFD ",
        " \uFFFD ","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD",
        "\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD",
        "\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD","\uFFFD",
    ];

    // HELPER FUNCTIONS
    // we can probably do this better...
    static char toHexDigit(int n)
    {
        return "0123456789ABCDEF"[n & 0xF];
    }

    static string makeReadable(string s)
    {
        string r = "\"";
        foreach (char c;s)
        {
            if (c >= 0x20 && c < 0x80)
            {
                r ~= c;
            }
            else
            {
                r ~= "\\x";
                r ~= toHexDigit(c >> 4);
                r ~= toHexDigit(c);
            }
        }
        r ~= "\"";
        return r;
    }

    void transcodeReverse(Src,Dst)(immutable(Src)[] s, out immutable(Dst)[] r)
    {
        static if (is(Src == Dst))
        {
            return s;
        }
        else static if (is(Src == AsciiChar))
        {
            transcodeReverse!(char,Dst)(cast(string) s,r);
        }
        else
        {
            foreach_reverse (d;codePoints(s))
            {
                foreach_reverse (c;codeUnits!(Dst)(d))
                {
                    r = c ~ r;
                }
            }
        }
    }

    // Make sure everything that should be valid, is
    foreach (a;validStrings)
    {
        string s = cast(string) a;
        assert(isValid(s),"Failed to validate: "~makeReadable(s));
    }

    // Make sure everything that shouldn't be valid, isn't
    foreach (a;invalidStrings)
    {
        string s = cast(string) a;
        assert(!isValid(s),"Incorrectly validated: "~makeReadable(s));
    }

    // Make sure we can sanitize everything bad
    assert(invalidStrings.length == sanitizedStrings.length);
    for (int i=0; i<invalidStrings.length; ++i)
    {
        string s = cast(string) invalidStrings[i];
        string t = sanitize(s);
        assert(isValid(t));
        assert(t == sanitizedStrings[i]);
        ubyte[] u = cast(ubyte[]) t;
        validStrings ~= u;
    }

    // Make sure all transcodings work in both directions, using both forward
    // and reverse iteration
    foreach (a; validStrings)
    {
        string s = cast(string) a;
        string s2;
        wstring ws, ws2;
        dstring ds, ds2;

        transcode(s,ws);
        assert(isValid(ws));
        transcode(ws,s2);
        assert(s == s2);

        transcode(s,ds);
        assert(isValid(ds));
        transcode(ds,s2);
        assert(s == s2);

        transcode(ws,s);
        assert(isValid(s));
        transcode(s,ws2);
        assert(ws == ws2);

        transcode(ws,ds);
        assert(isValid(ds));
        transcode(ds,ws2);
        assert(ws == ws2);

        transcode(ds,s);
        assert(isValid(s));
        transcode(s,ds2);
        assert(ds == ds2);

        transcode(ds,ws);
        assert(isValid(ws));
        transcode(ws,ds2);
        assert(ds == ds2);

        transcodeReverse(s,ws);
        assert(isValid(ws));
        transcodeReverse(ws,s2);
        assert(s == s2);

        transcodeReverse(s,ds);
        assert(isValid(ds));
        transcodeReverse(ds,s2);
        assert(s == s2);

        transcodeReverse(ws,s);
        assert(isValid(s));
        transcodeReverse(s,ws2);
        assert(ws == ws2);

        transcodeReverse(ws,ds);
        assert(isValid(ds));
        transcodeReverse(ds,ws2);
        assert(ws == ws2);

        transcodeReverse(ds,s);
        assert(isValid(s));
        transcodeReverse(s,ds2);
        assert(ds == ds2);

        transcodeReverse(ds,ws);
        assert(isValid(ws));
        transcodeReverse(ws,ds2);
        assert(ds == ds2);
    }

    // Make sure the non-UTF encodings work too
    {
        auto s = "\u20AC100";
        Windows1252String t;
        transcode(s,t);
        assert(t == cast(Windows1252Char[])[0x80, '1', '0', '0']);
        string u;
        transcode(s,u);
        assert(s == u);
        Latin1String v;
        transcode(s,v);
        assert(cast(string) v == "?100");
        AsciiString w;
        transcode(v,w);
        assert(cast(string) w == "?100");
        s = "\u017Dlu\u0165ou\u010Dk\u00FD k\u016F\u0148";
        Latin2String x;
        transcode(s,x);
        assert(x == cast(Latin2Char[])[0xae, 'l', 'u', 0xbb, 'o', 'u', 0xe8, 'k', 0xfd, ' ', 'k', 0xf9, 0xf2]);
        Windows1250String y;
        transcode(s,y);
        assert(y == cast(Windows1250Char[])[0x8e, 'l', 'u', 0x9d, 'o', 'u', 0xe8, 'k', 0xfd, ' ', 'k', 0xf9, 0xf2]);
        s = "\u0402lu\u0403ou\u201D\u045C k\u0414\u044F";
        Windows1251String s51;
        transcode(s,s51);
        assert(s51 == cast(Windows1251Char[])[0x80, 'l', 'u', 0x81, 'o', 'u', 0x94, 0x9d, ' ', 'k', 0xc4, 0xff]);
    }

    // Make sure we can count properly
    {
        assert(encodedLength!(char)('A') == 1);
        assert(encodedLength!(char)('\u00E3') == 2);
        assert(encodedLength!(char)('\u2028') == 3);
        assert(encodedLength!(char)('\U0010FFF0') == 4);
        assert(encodedLength!(wchar)('A') == 1);
        assert(encodedLength!(wchar)('\U0010FFF0') == 2);
    }

    // Make sure we can write into mutable arrays
    {
        char[4] buffer;
        auto n = encode(cast(dchar)'\u00E3',buffer);
        assert(n == 2);
        assert(buffer[0] == 0xC3);
        assert(buffer[1] == 0xA3);
    }
}

//=============================================================================

/** Special value returned by `safeDecode` */
enum dchar INVALID_SEQUENCE = cast(dchar) 0xFFFFFFFF;

template EncoderFunctions()
{
    // Various forms of read

    template ReadFromString()
    {
        @property bool canRead() { return s.length != 0; }
        E peek() @safe pure @nogc nothrow { return s[0]; }
        E read() @safe pure @nogc nothrow { E t = s[0]; s = s[1..$]; return t; }
    }

    template ReverseReadFromString()
    {
        @property bool canRead() { return s.length != 0; }
        E peek() @safe pure @nogc nothrow { return s[$-1]; }
        E read() @safe pure @nogc nothrow { E t = s[$-1]; s = s[0..$-1]; return t; }
    }

    // Various forms of Write

    template WriteToString()
    {
        E[] s;
        void write(E c) @safe pure nothrow { s ~= c; }
    }

    template WriteToArray()
    {
        void write(E c) @safe pure @nogc nothrow { array[0] = c; array = array[1..$]; }
    }

    template WriteToDelegate()
    {
        void write(E c) { dg(c); }
    }

    // Functions we will export

    template EncodeViaWrite()
    {
        mixin encodeViaWrite;
        void encode(dchar c) { encodeViaWrite(c); }
    }

    template SkipViaRead()
    {
        mixin skipViaRead;
        void skip() @safe pure @nogc nothrow { skipViaRead(); }
    }

    template DecodeViaRead()
    {
        mixin decodeViaRead;
        dchar decode() @safe pure @nogc nothrow { return decodeViaRead(); }
    }

    template SafeDecodeViaRead()
    {
        mixin safeDecodeViaRead;
        dchar safeDecode() @safe pure @nogc nothrow { return safeDecodeViaRead(); }
    }

    template DecodeReverseViaRead()
    {
        mixin decodeReverseViaRead;
        dchar decodeReverse() @safe pure @nogc nothrow { return decodeReverseViaRead(); }
    }

    // Encoding to different destinations

    template EncodeToString()
    {
        mixin WriteToString;
        mixin EncodeViaWrite;
    }

    template EncodeToArray()
    {
        mixin WriteToArray;
        mixin EncodeViaWrite;
    }

    template EncodeToDelegate()
    {
        mixin WriteToDelegate;
        mixin EncodeViaWrite;
    }

    // Decoding functions

    template SkipFromString()
    {
        mixin ReadFromString;
        mixin SkipViaRead;
    }

    template DecodeFromString()
    {
        mixin ReadFromString;
        mixin DecodeViaRead;
    }

    template SafeDecodeFromString()
    {
        mixin ReadFromString;
        mixin SafeDecodeViaRead;
    }

    template DecodeReverseFromString()
    {
        mixin ReverseReadFromString;
        mixin DecodeReverseViaRead;
    }

    //=========================================================================

    // Below are the functions we will ultimately expose to the user

    E[] encode(dchar c) @safe pure nothrow
    {
        mixin EncodeToString e;
        e.encode(c);
        return e.s;
    }

    void encode(dchar c, ref E[] array) @safe pure nothrow
    {
        mixin EncodeToArray e;
        e.encode(c);
    }

    void encode(dchar c, void delegate(E) dg)
    {
        mixin EncodeToDelegate e;
        e.encode(c);
    }

    void skip(ref const(E)[] s) @safe pure nothrow
    {
        mixin SkipFromString e;
        e.skip();
    }

    dchar decode(S)(ref S s)
    {
        mixin DecodeFromString e;
        return e.decode();
    }

    dchar safeDecode(S)(ref S s)
    {
        mixin SafeDecodeFromString e;
        return e.safeDecode();
    }

    dchar decodeReverse(ref const(E)[] s) @safe pure nothrow
    {
        mixin DecodeReverseFromString e;
        return e.decodeReverse();
    }
}

//=========================================================================

struct CodePoints(E)
{
    const(E)[] s;

    this(const(E)[] s)
    in
    {
        assert(isValid(s));
    }
    do
    {
        this.s = s;
    }

    int opApply(scope int delegate(ref dchar) dg)
    {
        int result = 0;
        while (s.length != 0)
        {
            dchar c = decode(s);
            result = dg(c);
            if (result != 0) break;
        }
        return result;
    }

    int opApply(scope int delegate(ref size_t, ref dchar) dg)
    {
        size_t i = 0;
        int result = 0;
        while (s.length != 0)
        {
            immutable len = s.length;
            dchar c = decode(s);
            size_t j = i; // We don't want the delegate corrupting i
            result = dg(j,c);
            if (result != 0) break;
            i += len - s.length;
        }
        return result;
    }

    int opApplyReverse(scope int delegate(ref dchar) dg)
    {
        int result = 0;
        while (s.length != 0)
        {
            dchar c = decodeReverse(s);
            result = dg(c);
            if (result != 0) break;
        }
        return result;
    }

    int opApplyReverse(scope int delegate(ref size_t, ref dchar) dg)
    {
        int result = 0;
        while (s.length != 0)
        {
            dchar c = decodeReverse(s);
            size_t i = s.length;
            result = dg(i,c);
            if (result != 0) break;
        }
        return result;
    }
}

struct CodeUnits(E)
{
    E[] s;

    this(dchar d)
    in
    {
        assert(isValidCodePoint(d));
    }
    do
    {
        s = encode!(E)(d);
    }

    int opApply(scope int delegate(ref E) dg)
    {
        int result = 0;
        foreach (E c;s)
        {
            result = dg(c);
            if (result != 0) break;
        }
        return result;
    }

    int opApplyReverse(scope int delegate(ref E) dg)
    {
        int result = 0;
        foreach_reverse (E c;s)
        {
            result = dg(c);
            if (result != 0) break;
        }
        return result;
    }
}

//=============================================================================

template EncoderInstance(E)
{
    static assert(false,"Cannot instantiate EncoderInstance for type "
        ~ E.stringof);
}

private template GenericEncoder()
{
    bool canEncode(dchar c) @safe pure @nogc nothrow
    {
        if (c < m_charMapStart || (c > m_charMapEnd && c < 0x100)) return true;
        if (c >= 0xFFFD) return false;

        auto idx = 0;
        while (idx < bstMap.length)
        {
            if (bstMap[idx][0] == c) return true;
            idx = bstMap[idx][0] > c ? 2 * idx + 1 : 2 * idx + 2; // next BST index
        }

        return false;
    }

    bool isValidCodeUnit(E c) @safe pure @nogc nothrow
    {
        if (c < m_charMapStart || c > m_charMapEnd) return true;
        return charMap[c-m_charMapStart] != 0xFFFD;
    }

    size_t encodedLength(dchar c) @safe pure @nogc nothrow
    in
    {
        assert(canEncode(c));
    }
    do
    {
        return 1;
    }

    void encodeViaWrite()(dchar c)
    {
        if (c < m_charMapStart || (c > m_charMapEnd && c < 0x100)) {}
        else if (c >= 0xFFFD) { c = '?'; }
        else
        {
            auto idx = 0;
            while (idx < bstMap.length)
            {
                if (bstMap[idx][0] == c)
                {
                    write(cast(E) bstMap[idx][1]);
                    return;
                }
                idx = bstMap[idx][0] > c ? 2 * idx + 1 : 2 * idx + 2; // next BST index
            }
            c = '?';
        }
        write(cast(E) c);
    }

    void skipViaRead()()
    {
        read();
    }

    dchar decodeViaRead()()
    {
        E c = read();
        return (c >= m_charMapStart && c <= m_charMapEnd) ? charMap[c-m_charMapStart] : c;
    }

    dchar safeDecodeViaRead()()
    {
        immutable E c = read();
        immutable d = (c >= m_charMapStart && c <= m_charMapEnd) ? charMap[c-m_charMapStart] : c;
        return d == 0xFFFD ? INVALID_SEQUENCE : d;
    }

    dchar decodeReverseViaRead()()
    {
        E c = read();
        return (c >= m_charMapStart && c <= m_charMapEnd) ? charMap[c-m_charMapStart] : c;
    }

    @property EString replacementSequence() @safe pure @nogc nothrow
    {
        return cast(EString)("?");
    }

    mixin EncoderFunctions;
}

//=============================================================================
//          ASCII
//=============================================================================

/** Defines various character sets. */
enum AsciiChar : ubyte { _init }
/// Ditto
alias AsciiString = immutable(AsciiChar)[];

template EncoderInstance(CharType : AsciiChar)
{
    alias E = AsciiChar;
    alias EString = AsciiString;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "ASCII";
    }

    bool canEncode(dchar c) @safe pure nothrow @nogc
    {
        return c < 0x80;
    }

    bool isValidCodeUnit(AsciiChar c) @safe pure nothrow @nogc
    {
        return c < 0x80;
    }

    size_t encodedLength(dchar c) @safe pure nothrow @nogc
    in
    {
        assert(canEncode(c));
    }
    do
    {
        return 1;
    }

    void encodeX(Range)(dchar c, Range r)
    {
        if (!canEncode(c)) c = '?';
        r.write(cast(AsciiChar) c);
    }

    void encodeViaWrite()(dchar c)
    {
        if (!canEncode(c)) c = '?';
        write(cast(AsciiChar) c);
    }

    void skipViaRead()()
    {
        read();
    }

    dchar decodeViaRead()()
    {
        return read();
    }

    dchar safeDecodeViaRead()()
    {
        immutable c = read();
        return canEncode(c) ? c : INVALID_SEQUENCE;
    }

    dchar decodeReverseViaRead()()
    {
        return read();
    }

    @property EString replacementSequence() @safe pure nothrow @nogc
    {
        return cast(EString)("?");
    }

    mixin EncoderFunctions;
}

//=============================================================================
//          ISO-8859-1
//=============================================================================

/** Defines an Latin1-encoded character. */
enum Latin1Char : ubyte { _init }
/**
Defines an Latin1-encoded string (as an array of $(D
immutable(Latin1Char))).
 */
alias Latin1String = immutable(Latin1Char)[];

template EncoderInstance(CharType : Latin1Char)
{
    alias E = Latin1Char;
    alias EString = Latin1String;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "ISO-8859-1";
    }

    bool canEncode(dchar c) @safe pure nothrow @nogc
    {
        return c < 0x100;
    }

    bool isValidCodeUnit(Latin1Char c) @safe pure nothrow @nogc
    {
        return true;
    }

    size_t encodedLength(dchar c) @safe pure nothrow @nogc
    in
    {
        assert(canEncode(c));
    }
    do
    {
        return 1;
    }

    void encodeViaWrite()(dchar c)
    {
        if (!canEncode(c)) c = '?';
        write(cast(Latin1Char) c);
    }

    void skipViaRead()()
    {
        read();
    }

    dchar decodeViaRead()()
    {
        return read();
    }

    dchar safeDecodeViaRead()()
    {
        return read();
    }

    dchar decodeReverseViaRead()()
    {
        return read();
    }

    @property EString replacementSequence() @safe pure nothrow @nogc
    {
        return cast(EString)("?");
    }

    mixin EncoderFunctions;
}

//=============================================================================
//          ISO-8859-2
//=============================================================================

/// Defines a Latin2-encoded character.
enum Latin2Char : ubyte { _init }

/**
 * Defines an Latin2-encoded string (as an array of $(D
 * immutable(Latin2Char))).
 */
alias Latin2String = immutable(Latin2Char)[];

private template EncoderInstance(CharType : Latin2Char)
{
    import std.typecons : Tuple, tuple;

    alias E = Latin2Char;
    alias EString = Latin2String;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "ISO-8859-2";
    }

    private static immutable dchar m_charMapStart = 0xa1;
    private static immutable dchar m_charMapEnd = 0xff;

    private immutable wstring charMap =
        "\u0104\u02D8\u0141\u00A4\u013D\u015A\u00A7\u00A8"~
        "\u0160\u015E\u0164\u0179\u00AD\u017D\u017B\u00B0"~
        "\u0105\u02DB\u0142\u00B4\u013E\u015B\u02C7\u00B8"~
        "\u0161\u015F\u0165\u017A\u02DD\u017E\u017C\u0154"~
        "\u00C1\u00C2\u0102\u00C4\u0139\u0106\u00C7\u010C"~
        "\u00C9\u0118\u00CB\u011A\u00CD\u00CE\u010E\u0110"~
        "\u0143\u0147\u00D3\u00D4\u0150\u00D6\u00D7\u0158"~
        "\u016E\u00DA\u0170\u00DC\u00DD\u0162\u00DF\u0155"~
        "\u00E1\u00E2\u0103\u00E4\u013A\u0107\u00E7\u010D"~
        "\u00E9\u0119\u00EB\u011B\u00ED\u00EE\u010F\u0111"~
        "\u0144\u0148\u00F3\u00F4\u0151\u00F6\u00F7\u0159"~
        "\u016F\u00FA\u0171\u00FC\u00FD\u0163\u02D9";

    private immutable Tuple!(wchar, char)[] bstMap = [
        tuple('\u0148','\xF2'), tuple('\u00F3','\xF3'), tuple('\u0165','\xBB'),
        tuple('\u00D3','\xD3'), tuple('\u010F','\xEF'), tuple('\u015B','\xB6'),
        tuple('\u017C','\xBF'), tuple('\u00C1','\xC1'), tuple('\u00E1','\xE1'),
        tuple('\u0103','\xE3'), tuple('\u013A','\xE5'), tuple('\u0155','\xE0'),
        tuple('\u0161','\xB9'), tuple('\u0171','\xFB'), tuple('\u02D8','\xA2'),
        tuple('\u00AD','\xAD'), tuple('\u00C9','\xC9'), tuple('\u00DA','\xDA'),
        tuple('\u00E9','\xE9'), tuple('\u00FA','\xFA'), tuple('\u0107','\xE6'),
        tuple('\u0119','\xEA'), tuple('\u0142','\xB3'), tuple('\u0151','\xF5'),
        tuple('\u0159','\xF8'), tuple('\u015F','\xBA'), tuple('\u0163','\xFE'),
        tuple('\u016F','\xF9'), tuple('\u017A','\xBC'), tuple('\u017E','\xBE'),
        tuple('\u02DB','\xB2'), tuple('\u00A7','\xA7'), tuple('\u00B4','\xB4'),
        tuple('\u00C4','\xC4'), tuple('\u00CD','\xCD'), tuple('\u00D6','\xD6'),
        tuple('\u00DD','\xDD'), tuple('\u00E4','\xE4'), tuple('\u00ED','\xED'),
        tuple('\u00F6','\xF6'), tuple('\u00FD','\xFD'), tuple('\u0105','\xB1'),
        tuple('\u010D','\xE8'), tuple('\u0111','\xF0'), tuple('\u011B','\xEC'),
        tuple('\u013E','\xB5'), tuple('\u0144','\xF1'), tuple('\u0150','\xD5'),
        tuple('\u0154','\xC0'), tuple('\u0158','\xD8'), tuple('\u015A','\xA6'),
        tuple('\u015E','\xAA'), tuple('\u0160','\xA9'), tuple('\u0162','\xDE'),
        tuple('\u0164','\xAB'), tuple('\u016E','\xD9'), tuple('\u0170','\xDB'),
        tuple('\u0179','\xAC'), tuple('\u017B','\xAF'), tuple('\u017D','\xAE'),
        tuple('\u02C7','\xB7'), tuple('\u02D9','\xFF'), tuple('\u02DD','\xBD'),
        tuple('\u00A4','\xA4'), tuple('\u00A8','\xA8'), tuple('\u00B0','\xB0'),
        tuple('\u00B8','\xB8'), tuple('\u00C2','\xC2'), tuple('\u00C7','\xC7'),
        tuple('\u00CB','\xCB'), tuple('\u00CE','\xCE'), tuple('\u00D4','\xD4'),
        tuple('\u00D7','\xD7'), tuple('\u00DC','\xDC'), tuple('\u00DF','\xDF'),
        tuple('\u00E2','\xE2'), tuple('\u00E7','\xE7'), tuple('\u00EB','\xEB'),
        tuple('\u00EE','\xEE'), tuple('\u00F4','\xF4'), tuple('\u00F7','\xF7'),
        tuple('\u00FC','\xFC'), tuple('\u0102','\xC3'), tuple('\u0104','\xA1'),
        tuple('\u0106','\xC6'), tuple('\u010C','\xC8'), tuple('\u010E','\xCF'),
        tuple('\u0110','\xD0'), tuple('\u0118','\xCA'), tuple('\u011A','\xCC'),
        tuple('\u0139','\xC5'), tuple('\u013D','\xA5'), tuple('\u0141','\xA3'),
        tuple('\u0143','\xD1'), tuple('\u0147','\xD2')
    ];

    mixin GenericEncoder!();
}

//=============================================================================
//          WINDOWS-1250
//=============================================================================

/// Defines a Windows1250-encoded character.
enum Windows1250Char : ubyte { _init }

/**
 * Defines an Windows1250-encoded string (as an array of $(D
 * immutable(Windows1250Char))).
 */
alias Windows1250String = immutable(Windows1250Char)[];

private template EncoderInstance(CharType : Windows1250Char)
{
    import std.typecons : Tuple, tuple;

    alias E = Windows1250Char;
    alias EString = Windows1250String;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "windows-1250";
    }

    private static immutable dchar m_charMapStart = 0x80;
    private static immutable dchar m_charMapEnd = 0xff;

    private immutable wstring charMap =
        "\u20AC\uFFFD\u201A\uFFFD\u201E\u2026\u2020\u2021"~
        "\uFFFD\u2030\u0160\u2039\u015A\u0164\u017D\u0179"~
        "\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014"~
        "\uFFFD\u2122\u0161\u203A\u015B\u0165\u017E\u017A"~
        "\u00A0\u02C7\u02D8\u0141\u00A4\u0104\u00A6\u00A7"~
        "\u00A8\u00A9\u015E\u00AB\u00AC\u00AD\u00AE\u017B"~
        "\u00B0\u00B1\u02DB\u0142\u00B4\u00B5\u00B6\u00B7"~
        "\u00B8\u0105\u015F\u00BB\u013D\u02DD\u013E\u017C"~
        "\u0154\u00C1\u00C2\u0102\u00C4\u0139\u0106\u00C7"~
        "\u010C\u00C9\u0118\u00CB\u011A\u00CD\u00CE\u010E"~
        "\u0110\u0143\u0147\u00D3\u00D4\u0150\u00D6\u00D7"~
        "\u0158\u016E\u00DA\u0170\u00DC\u00DD\u0162\u00DF"~
        "\u0155\u00E1\u00E2\u0103\u00E4\u013A\u0107\u00E7"~
        "\u010D\u00E9\u0119\u00EB\u011B\u00ED\u00EE\u010F"~
        "\u0111\u0144\u0148\u00F3\u00F4\u0151\u00F6\u00F7"~
        "\u0159\u016F\u00FA\u0171\u00FC\u00FD\u0163\u02D9";

    private immutable Tuple!(wchar, char)[] bstMap = [
        tuple('\u011A','\xCC'), tuple('\u00DC','\xDC'), tuple('\u0179','\x8F'),
        tuple('\u00B7','\xB7'), tuple('\u00FC','\xFC'), tuple('\u0158','\xD8'),
        tuple('\u201C','\x93'), tuple('\u00AC','\xAC'), tuple('\u00CB','\xCB'),
        tuple('\u00EB','\xEB'), tuple('\u010C','\xC8'), tuple('\u0143','\xD1'),
        tuple('\u0162','\xDE'), tuple('\u02D9','\xFF'), tuple('\u2039','\x8B'),
        tuple('\u00A7','\xA7'), tuple('\u00B1','\xB1'), tuple('\u00C2','\xC2'),
        tuple('\u00D4','\xD4'), tuple('\u00E2','\xE2'), tuple('\u00F4','\xF4'),
        tuple('\u0104','\xA5'), tuple('\u0110','\xD0'), tuple('\u013D','\xBC'),
        tuple('\u0150','\xD5'), tuple('\u015E','\xAA'), tuple('\u016E','\xD9'),
        tuple('\u017D','\x8E'), tuple('\u2014','\x97'), tuple('\u2021','\x87'),
        tuple('\u20AC','\x80'), tuple('\u00A4','\xA4'), tuple('\u00A9','\xA9'),
        tuple('\u00AE','\xAE'), tuple('\u00B5','\xB5'), tuple('\u00BB','\xBB'),
        tuple('\u00C7','\xC7'), tuple('\u00CE','\xCE'), tuple('\u00D7','\xD7'),
        tuple('\u00DF','\xDF'), tuple('\u00E7','\xE7'), tuple('\u00EE','\xEE'),
        tuple('\u00F7','\xF7'), tuple('\u0102','\xC3'), tuple('\u0106','\xC6'),
        tuple('\u010E','\xCF'), tuple('\u0118','\xCA'), tuple('\u0139','\xC5'),
        tuple('\u0141','\xA3'), tuple('\u0147','\xD2'), tuple('\u0154','\xC0'),
        tuple('\u015A','\x8C'), tuple('\u0160','\x8A'), tuple('\u0164','\x8D'),
        tuple('\u0170','\xDB'), tuple('\u017B','\xAF'), tuple('\u02C7','\xA1'),
        tuple('\u02DD','\xBD'), tuple('\u2019','\x92'), tuple('\u201E','\x84'),
        tuple('\u2026','\x85'), tuple('\u203A','\x9B'), tuple('\u2122','\x99'),
        tuple('\u00A0','\xA0'), tuple('\u00A6','\xA6'), tuple('\u00A8','\xA8'),
        tuple('\u00AB','\xAB'), tuple('\u00AD','\xAD'), tuple('\u00B0','\xB0'),
        tuple('\u00B4','\xB4'), tuple('\u00B6','\xB6'), tuple('\u00B8','\xB8'),
        tuple('\u00C1','\xC1'), tuple('\u00C4','\xC4'), tuple('\u00C9','\xC9'),
        tuple('\u00CD','\xCD'), tuple('\u00D3','\xD3'), tuple('\u00D6','\xD6'),
        tuple('\u00DA','\xDA'), tuple('\u00DD','\xDD'), tuple('\u00E1','\xE1'),
        tuple('\u00E4','\xE4'), tuple('\u00E9','\xE9'), tuple('\u00ED','\xED'),
        tuple('\u00F3','\xF3'), tuple('\u00F6','\xF6'), tuple('\u00FA','\xFA'),
        tuple('\u00FD','\xFD'), tuple('\u0103','\xE3'), tuple('\u0105','\xB9'),
        tuple('\u0107','\xE6'), tuple('\u010D','\xE8'), tuple('\u010F','\xEF'),
        tuple('\u0111','\xF0'), tuple('\u0119','\xEA'), tuple('\u011B','\xEC'),
        tuple('\u013A','\xE5'), tuple('\u013E','\xBE'), tuple('\u0142','\xB3'),
        tuple('\u0144','\xF1'), tuple('\u0148','\xF2'), tuple('\u0151','\xF5'),
        tuple('\u0155','\xE0'), tuple('\u0159','\xF8'), tuple('\u015B','\x9C'),
        tuple('\u015F','\xBA'), tuple('\u0161','\x9A'), tuple('\u0163','\xFE'),
        tuple('\u0165','\x9D'), tuple('\u016F','\xF9'), tuple('\u0171','\xFB'),
        tuple('\u017A','\x9F'), tuple('\u017C','\xBF'), tuple('\u017E','\x9E'),
        tuple('\u02D8','\xA2'), tuple('\u02DB','\xB2'), tuple('\u2013','\x96'),
        tuple('\u2018','\x91'), tuple('\u201A','\x82'), tuple('\u201D','\x94'),
        tuple('\u2020','\x86'), tuple('\u2022','\x95'), tuple('\u2030','\x89')
    ];

    mixin GenericEncoder!();
}

//=============================================================================
//          WINDOWS-1251
//=============================================================================

/// Defines a Windows1251-encoded character.
enum Windows1251Char : ubyte { _init }

/**
 * Defines an Windows1251-encoded string (as an array of $(D
 * immutable(Windows1251Char))).
 */
alias Windows1251String = immutable(Windows1251Char)[];

private template EncoderInstance(CharType : Windows1251Char)
{
    import std.typecons : Tuple, tuple;

    alias E = Windows1251Char;
    alias EString = Windows1251String;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "windows-1251";
    }

    private static immutable dchar m_charMapStart = 0x80;
    private static immutable dchar m_charMapEnd = 0xff;

    private immutable wstring charMap =
        "\u0402\u0403\u201A\u0453\u201E\u2026\u2020\u2021"~
        "\u20AC\u2030\u0409\u2039\u040A\u040C\u040B\u040F"~
        "\u0452\u2018\u2019\u201C\u201D\u2022\u2013\u2014"~
        "\uFFFD\u2122\u0459\u203A\u045A\u045C\u045B\u045F"~
        "\u00A0\u040E\u045E\u0408\u00A4\u0490\u00A6\u00A7"~
        "\u0401\u00A9\u0404\u00AB\u00AC\u00AD\u00AE\u0407"~
        "\u00B0\u00B1\u0406\u0456\u0491\u00B5\u00B6\u00B7"~
        "\u0451\u2116\u0454\u00BB\u0458\u0405\u0455\u0457"~
        "\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417"~
        "\u0418\u0419\u041A\u041B\u041C\u041D\u041E\u041F"~
        "\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427"~
        "\u0428\u0429\u042A\u042B\u042C\u042D\u042E\u042F"~
        "\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437"~
        "\u0438\u0439\u043A\u043B\u043C\u043D\u043E\u043F"~
        "\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447"~
        "\u0448\u0449\u044A\u044B\u044C\u044D\u044E\u044F";

    private immutable Tuple!(wchar, char)[] bstMap = [
        tuple('\u0432','\xE2'),tuple('\u0412','\xC2'),tuple('\u0453','\x83'),
        tuple('\u0401','\xA8'),tuple('\u0422','\xD2'),tuple('\u0442','\xF2'),
        tuple('\u2018','\x91'),tuple('\u00AD','\xAD'),tuple('\u0409','\x8A'),
        tuple('\u041A','\xCA'),tuple('\u042A','\xDA'),tuple('\u043A','\xEA'),
        tuple('\u044A','\xFA'),tuple('\u045B','\x9E'),tuple('\u2022','\x95'),
        tuple('\u00A7','\xA7'),tuple('\u00B5','\xB5'),tuple('\u0405','\xBD'),
        tuple('\u040E','\xA1'),tuple('\u0416','\xC6'),tuple('\u041E','\xCE'),
        tuple('\u0426','\xD6'),tuple('\u042E','\xDE'),tuple('\u0436','\xE6'),
        tuple('\u043E','\xEE'),tuple('\u0446','\xF6'),tuple('\u044E','\xFE'),
        tuple('\u0457','\xBF'),tuple('\u0490','\xA5'),tuple('\u201D','\x94'),
        tuple('\u203A','\x9B'),tuple('\u00A4','\xA4'),tuple('\u00AB','\xAB'),
        tuple('\u00B0','\xB0'),tuple('\u00B7','\xB7'),tuple('\u0403','\x81'),
        tuple('\u0407','\xAF'),tuple('\u040B','\x8E'),tuple('\u0410','\xC0'),
        tuple('\u0414','\xC4'),tuple('\u0418','\xC8'),tuple('\u041C','\xCC'),
        tuple('\u0420','\xD0'),tuple('\u0424','\xD4'),tuple('\u0428','\xD8'),
        tuple('\u042C','\xDC'),tuple('\u0430','\xE0'),tuple('\u0434','\xE4'),
        tuple('\u0438','\xE8'),tuple('\u043C','\xEC'),tuple('\u0440','\xF0'),
        tuple('\u0444','\xF4'),tuple('\u0448','\xF8'),tuple('\u044C','\xFC'),
        tuple('\u0451','\xB8'),tuple('\u0455','\xBE'),tuple('\u0459','\x9A'),
        tuple('\u045E','\xA2'),tuple('\u2013','\x96'),tuple('\u201A','\x82'),
        tuple('\u2020','\x86'),tuple('\u2030','\x89'),tuple('\u2116','\xB9'),
        tuple('\u00A0','\xA0'),tuple('\u00A6','\xA6'),tuple('\u00A9','\xA9'),
        tuple('\u00AC','\xAC'),tuple('\u00AE','\xAE'),tuple('\u00B1','\xB1'),
        tuple('\u00B6','\xB6'),tuple('\u00BB','\xBB'),tuple('\u0402','\x80'),
        tuple('\u0404','\xAA'),tuple('\u0406','\xB2'),tuple('\u0408','\xA3'),
        tuple('\u040A','\x8C'),tuple('\u040C','\x8D'),tuple('\u040F','\x8F'),
        tuple('\u0411','\xC1'),tuple('\u0413','\xC3'),tuple('\u0415','\xC5'),
        tuple('\u0417','\xC7'),tuple('\u0419','\xC9'),tuple('\u041B','\xCB'),
        tuple('\u041D','\xCD'),tuple('\u041F','\xCF'),tuple('\u0421','\xD1'),
        tuple('\u0423','\xD3'),tuple('\u0425','\xD5'),tuple('\u0427','\xD7'),
        tuple('\u0429','\xD9'),tuple('\u042B','\xDB'),tuple('\u042D','\xDD'),
        tuple('\u042F','\xDF'),tuple('\u0431','\xE1'),tuple('\u0433','\xE3'),
        tuple('\u0435','\xE5'),tuple('\u0437','\xE7'),tuple('\u0439','\xE9'),
        tuple('\u043B','\xEB'),tuple('\u043D','\xED'),tuple('\u043F','\xEF'),
        tuple('\u0441','\xF1'),tuple('\u0443','\xF3'),tuple('\u0445','\xF5'),
        tuple('\u0447','\xF7'),tuple('\u0449','\xF9'),tuple('\u044B','\xFB'),
        tuple('\u044D','\xFD'),tuple('\u044F','\xFF'),tuple('\u0452','\x90'),
        tuple('\u0454','\xBA'),tuple('\u0456','\xB3'),tuple('\u0458','\xBC'),
        tuple('\u045A','\x9C'),tuple('\u045C','\x9D'),tuple('\u045F','\x9F'),
        tuple('\u0491','\xB4'),tuple('\u2014','\x97'),tuple('\u2019','\x92'),
        tuple('\u201C','\x93'),tuple('\u201E','\x84'),tuple('\u2021','\x87'),
        tuple('\u2026','\x85'),tuple('\u2039','\x8B'),tuple('\u20AC','\x88'),
        tuple('\u2122','\x99')
    ];

    mixin GenericEncoder!();
}

//=============================================================================
//          WINDOWS-1252
//=============================================================================

/// Defines a Windows1252-encoded character.
enum Windows1252Char : ubyte { _init }

/**
 * Defines an Windows1252-encoded string (as an array of $(D
 * immutable(Windows1252Char))).
 */
alias Windows1252String = immutable(Windows1252Char)[];

template EncoderInstance(CharType : Windows1252Char)
{
    import std.typecons : Tuple, tuple;

    alias E = Windows1252Char;
    alias EString = Windows1252String;

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "windows-1252";
    }

    private static immutable dchar m_charMapStart = 0x80;
    private static immutable dchar m_charMapEnd = 0x9f;

    private immutable wstring charMap =
        "\u20AC\uFFFD\u201A\u0192\u201E\u2026\u2020\u2021"~
        "\u02C6\u2030\u0160\u2039\u0152\uFFFD\u017D\uFFFD"~
        "\uFFFD\u2018\u2019\u201C\u201D\u2022\u2013\u2014"~
        "\u02DC\u2122\u0161\u203A\u0153\uFFFD\u017E\u0178";

    private immutable Tuple!(wchar, char)[] bstMap = [
        tuple('\u201C','\x93'), tuple('\u0192','\x83'), tuple('\u2039','\x8B'),
        tuple('\u0161','\x9A'), tuple('\u2014','\x97'), tuple('\u2021','\x87'),
        tuple('\u20AC','\x80'), tuple('\u0153','\x9C'), tuple('\u017D','\x8E'),
        tuple('\u02DC','\x98'), tuple('\u2019','\x92'), tuple('\u201E','\x84'),
        tuple('\u2026','\x85'), tuple('\u203A','\x9B'), tuple('\u2122','\x99'),
        tuple('\u0152','\x8C'), tuple('\u0160','\x8A'), tuple('\u0178','\x9F'),
        tuple('\u017E','\x9E'), tuple('\u02C6','\x88'), tuple('\u2013','\x96'),
        tuple('\u2018','\x91'), tuple('\u201A','\x82'), tuple('\u201D','\x94'),
        tuple('\u2020','\x86'), tuple('\u2022','\x95'), tuple('\u2030','\x89')
    ];

    mixin GenericEncoder!();
}

//=============================================================================
//          UTF-8
//=============================================================================

template EncoderInstance(CharType : char)
{
    alias E = char;
    alias EString = immutable(char)[];

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "UTF-8";
    }

    bool canEncode(dchar c) @safe pure nothrow @nogc
    {
        return isValidCodePoint(c);
    }

    bool isValidCodeUnit(char c) @safe pure nothrow @nogc
    {
        return (c < 0xC0 || (c >= 0xC2 && c < 0xF5));
    }

    immutable ubyte[128] tailTable =
    [
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
        2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
        3,3,3,3,3,3,3,3,4,4,4,4,5,5,6,0,
    ];

    private int tails(char c) @safe pure nothrow @nogc
    in
    {
        assert(c >= 0x80);
    }
    do
    {
        return tailTable[c-0x80];
    }

    size_t encodedLength(dchar c) @safe pure nothrow @nogc
    in
    {
        assert(canEncode(c));
    }
    do
    {
        if (c < 0x80) return 1;
        if (c < 0x800) return 2;
        if (c < 0x10000) return 3;
        return 4;
    }

    void encodeViaWrite()(dchar c)
    {
        if (c < 0x80)
        {
            write(cast(char) c);
        }
        else if (c < 0x800)
        {
            write(cast(char)((c >> 6) + 0xC0));
            write(cast(char)((c & 0x3F) + 0x80));
        }
        else if (c < 0x10000)
        {
            write(cast(char)((c >> 12) + 0xE0));
            write(cast(char)(((c >> 6) & 0x3F) + 0x80));
            write(cast(char)((c & 0x3F) + 0x80));
        }
        else
        {
            write(cast(char)((c >> 18) + 0xF0));
            write(cast(char)(((c >> 12) & 0x3F) + 0x80));
            write(cast(char)(((c >> 6) & 0x3F) + 0x80));
            write(cast(char)((c & 0x3F) + 0x80));
        }
    }

    void skipViaRead()()
    {
        auto c = read();
        if (c < 0xC0) return;
        int n = tails(cast(char) c);
        for (size_t i=0; i<n; ++i)
        {
            read();
        }
    }

    dchar decodeViaRead()()
    {
        dchar c = read();
        if (c < 0xC0) return c;
        int n = tails(cast(char) c);
        c &= (1 << (6 - n)) - 1;
        for (size_t i=0; i<n; ++i)
        {
            c = (c << 6) + (read() & 0x3F);
        }
        return c;
    }

    dchar safeDecodeViaRead()()
    {
        dchar c = read();
        if (c < 0x80) return c;
        int n = tails(cast(char) c);
        if (n == 0) return INVALID_SEQUENCE;

        if (!canRead) return INVALID_SEQUENCE;
        size_t d = peek();
        immutable err =
        (
            (c < 0xC2)                              // fail overlong 2-byte sequences
        ||  (c > 0xF4)                              // fail overlong 4-6-byte sequences
        ||  (c == 0xE0 && ((d & 0xE0) == 0x80))     // fail overlong 3-byte sequences
        ||  (c == 0xED && ((d & 0xE0) == 0xA0))     // fail surrogates
        ||  (c == 0xF0 && ((d & 0xF0) == 0x80))     // fail overlong 4-byte sequences
        ||  (c == 0xF4 && ((d & 0xF0) >= 0x90))     // fail code points > 0x10FFFF
        );

        c &= (1 << (6 - n)) - 1;
        for (size_t i=0; i<n; ++i)
        {
            if (!canRead) return INVALID_SEQUENCE;
            d = peek();
            if ((d & 0xC0) != 0x80) return INVALID_SEQUENCE;
            c = (c << 6) + (read() & 0x3F);
        }

        return err ? INVALID_SEQUENCE : c;
    }

    dchar decodeReverseViaRead()()
    {
        dchar c = read();
        if (c < 0x80) return c;
        size_t shift = 0;
        c &= 0x3F;
        for (size_t i=0; i<4; ++i)
        {
            shift += 6;
            auto d = read();
            size_t n = tails(cast(char) d);
            immutable mask = n == 0 ? 0x3F : (1 << (6 - n)) - 1;
            c += ((d & mask) << shift);
            if (n != 0) break;
        }
        return c;
    }

    @property EString replacementSequence() @safe pure nothrow @nogc
    {
        return "\uFFFD";
    }

    mixin EncoderFunctions;
}

//=============================================================================
//          UTF-16
//=============================================================================

template EncoderInstance(CharType : wchar)
{
    alias E = wchar;
    alias EString = immutable(wchar)[];

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "UTF-16";
    }

    bool canEncode(dchar c) @safe pure nothrow @nogc
    {
        return isValidCodePoint(c);
    }

    bool isValidCodeUnit(wchar c) @safe pure nothrow @nogc
    {
        return true;
    }

    size_t encodedLength(dchar c) @safe pure nothrow @nogc
    in
    {
        assert(canEncode(c));
    }
    do
    {
        return (c < 0x10000) ? 1 : 2;
    }

    void encodeViaWrite()(dchar c)
    {
        if (c < 0x10000)
        {
            write(cast(wchar) c);
        }
        else
        {
            size_t n = c - 0x10000;
            write(cast(wchar)(0xD800 + (n >> 10)));
            write(cast(wchar)(0xDC00 + (n & 0x3FF)));
        }
    }

    void skipViaRead()()
    {
        immutable c = read();
        if (c < 0xD800 || c >= 0xE000) return;
        read();
    }

    dchar decodeViaRead()()
    {
        wchar c = read();
        if (c < 0xD800 || c >= 0xE000) return cast(dchar) c;
        wchar d = read();
        c &= 0x3FF;
        d &= 0x3FF;
        return 0x10000 + (c << 10) + d;
    }

    dchar safeDecodeViaRead()()
    {
        wchar c = read();
        if (c < 0xD800 || c >= 0xE000) return cast(dchar) c;
        if (c >= 0xDC00) return INVALID_SEQUENCE;
        if (!canRead) return INVALID_SEQUENCE;
        wchar d = peek();
        if (d < 0xDC00 || d >= 0xE000) return INVALID_SEQUENCE;
        d = read();
        c &= 0x3FF;
        d &= 0x3FF;
        return 0x10000 + (c << 10) + d;
    }

    dchar decodeReverseViaRead()()
    {
        wchar c = read();
        if (c < 0xD800 || c >= 0xE000) return cast(dchar) c;
        wchar d = read();
        c &= 0x3FF;
        d &= 0x3FF;
        return 0x10000 + (d << 10) + c;
    }

    @property EString replacementSequence() @safe pure nothrow @nogc
    {
        return "\uFFFD"w;
    }

    mixin EncoderFunctions;
}

//=============================================================================
//          UTF-32
//=============================================================================

template EncoderInstance(CharType : dchar)
{
    alias E = dchar;
    alias EString = immutable(dchar)[];

    @property string encodingName() @safe pure nothrow @nogc
    {
        return "UTF-32";
    }

    bool canEncode(dchar c) @safe pure @nogc nothrow
    {
        return isValidCodePoint(c);
    }

    bool isValidCodeUnit(dchar c) @safe pure @nogc nothrow
    {
        return isValidCodePoint(c);
    }

    size_t encodedLength(dchar c) @safe pure @nogc nothrow
    in
    {
        assert(canEncode(c));
    }
    do
    {
        return 1;
    }

    void encodeViaWrite()(dchar c)
    {
        write(c);
    }

    void skipViaRead()()
    {
        read();
    }

    dchar decodeViaRead()()
    {
        return cast(dchar) read();
    }

    dchar safeDecodeViaRead()()
    {
        immutable c = read();
        return isValidCodePoint(c) ? c : INVALID_SEQUENCE;
    }

    dchar decodeReverseViaRead()()
    {
        return cast(dchar) read();
    }

    @property EString replacementSequence() @safe pure nothrow @nogc
    {
        return "\uFFFD"d;
    }

    mixin EncoderFunctions;
}

//=============================================================================
// Below are forwarding functions which expose the function to the user

/**
Returns true if c is a valid code point

 Note that this includes the non-character code points U+FFFE and U+FFFF,
 since these are valid code points (even though they are not valid
 characters).

 Supersedes:
 This function supersedes `std.utf.startsValidDchar()`.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    c = the code point to be tested
 */
bool isValidCodePoint(dchar c) @safe pure nothrow @nogc
{
    return c < 0xD800 || (c >= 0xE000 && c < 0x110000);
}

/**
 Returns the name of an encoding.

 The type of encoding cannot be deduced. Therefore, it is necessary to
 explicitly specify the encoding type.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252
 */
@property string encodingName(T)()
{
    return EncoderInstance!(T).encodingName;
}

///
@safe unittest
{
    assert(encodingName!(char) == "UTF-8");
    assert(encodingName!(wchar) == "UTF-16");
    assert(encodingName!(dchar) == "UTF-32");
    assert(encodingName!(AsciiChar) == "ASCII");
    assert(encodingName!(Latin1Char) == "ISO-8859-1");
    assert(encodingName!(Latin2Char) == "ISO-8859-2");
    assert(encodingName!(Windows1250Char) == "windows-1250");
    assert(encodingName!(Windows1251Char) == "windows-1251");
    assert(encodingName!(Windows1252Char) == "windows-1252");
}

/**
 Returns true iff it is possible to represent the specified codepoint
 in the encoding.

 The type of encoding cannot be deduced. Therefore, it is necessary to
 explicitly specify the encoding type.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252
 */
bool canEncode(E)(dchar c)
{
    return EncoderInstance!(E).canEncode(c);
}

///
@safe pure unittest
{
    assert( canEncode!(Latin1Char)('A'));
    assert( canEncode!(Latin2Char)('A'));
    assert(!canEncode!(AsciiChar)('\u00A0'));
    assert( canEncode!(Latin1Char)('\u00A0'));
    assert( canEncode!(Latin2Char)('\u00A0'));
    assert( canEncode!(Windows1250Char)('\u20AC'));
    assert(!canEncode!(Windows1250Char)('\u20AD'));
    assert(!canEncode!(Windows1250Char)('\uFFFD'));
    assert( canEncode!(Windows1251Char)('\u0402'));
    assert(!canEncode!(Windows1251Char)('\u20AD'));
    assert(!canEncode!(Windows1251Char)('\uFFFD'));
    assert( canEncode!(Windows1252Char)('\u20AC'));
    assert(!canEncode!(Windows1252Char)('\u20AD'));
    assert(!canEncode!(Windows1252Char)('\uFFFD'));
    assert(!canEncode!(char)(cast(dchar) 0x110000));
}

/// How to check an entire string
@safe pure unittest
{
    import std.algorithm.searching : find;
    import std.utf : byDchar;

    assert("The quick brown fox"
        .byDchar
        .find!(x => !canEncode!AsciiChar(x))
        .empty);
}

/**
 Returns true if the code unit is legal. For example, the byte 0x80 would
 not be legal in ASCII, because ASCII code units must always be in the range
 0x00 to 0x7F.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    c = the code unit to be tested
 */
bool isValidCodeUnit(E)(E c)
{
    return EncoderInstance!(E).isValidCodeUnit(c);
}

///
@system pure unittest
{
    assert(!isValidCodeUnit(cast(char) 0xC0));
    assert(!isValidCodeUnit(cast(char) 0xFF));
    assert( isValidCodeUnit(cast(wchar) 0xD800));
    assert(!isValidCodeUnit(cast(dchar) 0xD800));
    assert(!isValidCodeUnit(cast(AsciiChar) 0xA0));
    assert( isValidCodeUnit(cast(Windows1250Char) 0x80));
    assert(!isValidCodeUnit(cast(Windows1250Char) 0x81));
    assert( isValidCodeUnit(cast(Windows1251Char) 0x80));
    assert(!isValidCodeUnit(cast(Windows1251Char) 0x98));
    assert( isValidCodeUnit(cast(Windows1252Char) 0x80));
    assert(!isValidCodeUnit(cast(Windows1252Char) 0x81));
}

/**
 Returns true if the string is encoded correctly

 Supersedes:
 This function supersedes std.utf.validate(), however note that this
 function returns a bool indicating whether the input was valid or not,
 whereas the older function would throw an exception.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string to be tested
 */
bool isValid(E)(const(E)[] s)
{
    return s.length == validLength(s);
}

///
@system pure unittest
{
    assert( isValid("\u20AC100"));
    assert(!isValid(cast(char[3])[167, 133, 175]));
}

/**
 Returns the length of the longest possible substring, starting from
 the first code unit, which is validly encoded.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string to be tested
 */
size_t validLength(E)(const(E)[] s)
{
    size_t result, before = void;
    while ((before = s.length) > 0)
    {
        if (EncoderInstance!(E).safeDecode(s) == INVALID_SEQUENCE)
            break;
        result += before - s.length;
    }
    return result;
}

/**
 Sanitizes a string by replacing malformed code unit sequences with valid
 code unit sequences. The result is guaranteed to be valid for this encoding.

 If the input string is already valid, this function returns the original,
 otherwise it constructs a new string by replacing all illegal code unit
 sequences with the encoding's replacement character, Invalid sequences will
 be replaced with the Unicode replacement character (U+FFFD) if the
 character repertoire contains it, otherwise invalid sequences will be
 replaced with '?'.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string to be sanitized
 */
immutable(E)[] sanitize(E)(immutable(E)[] s)
{
    size_t n = validLength(s);
    if (n == s.length) return s;

    auto repSeq = EncoderInstance!(E).replacementSequence;

    // Count how long the string needs to be.
    // Overestimating is not a problem
    size_t len = s.length;
    const(E)[] t = s[n..$];
    while (t.length != 0)
    {
        immutable c = EncoderInstance!(E).safeDecode(t);
        assert(c == INVALID_SEQUENCE);
        len += repSeq.length;
        t = t[validLength(t)..$];
    }

    // Now do the write
    E[] array = new E[len];
    array[0 .. n] = s[0 .. n];
    size_t offset = n;

    t = s[n..$];
    while (t.length != 0)
    {
        immutable c = EncoderInstance!(E).safeDecode(t);
        assert(c == INVALID_SEQUENCE);
        array[offset .. offset+repSeq.length] = repSeq[];
        offset += repSeq.length;
        n = validLength(t);
        array[offset .. offset+n] = t[0 .. n];
        offset += n;
        t = t[n..$];
    }
    return cast(immutable(E)[])array[0 .. offset];
}

///
@system pure unittest
{
    assert(sanitize("hello \xF0\x80world") == "hello \xEF\xBF\xBDworld");
}

/**
 Returns the length of the first encoded sequence.

 The input to this function MUST be validly encoded.
 This is enforced by the function's in-contract.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
 s = the string to be sliced
 */
size_t firstSequence(E)(const(E)[] s)
in
{
    assert(s.length != 0);
    const(E)[] u = s;
    assert(safeDecode(u) != INVALID_SEQUENCE);
}
do
{
    auto before = s.length;
    EncoderInstance!(E).skip(s);
    return before - s.length;
}

///
@system pure unittest
{
    assert(firstSequence("\u20AC1000") == "\u20AC".length);
    assert(firstSequence("hel") == "h".length);
}

/**
 Returns the length of the last encoded sequence.

 The input to this function MUST be validly encoded.
 This is enforced by the function's in-contract.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string to be sliced
 */
size_t lastSequence(E)(const(E)[] s)
in
{
    assert(s.length != 0);
    assert(isValid(s));
}
do
{
    const(E)[] t = s;
    EncoderInstance!(E).decodeReverse(s);
    return t.length - s.length;
}

///
@system pure unittest
{
    assert(lastSequence("1000\u20AC") == "\u20AC".length);
    assert(lastSequence("hellö") == "ö".length);
}

/**
 Returns the array index at which the (n+1)th code point begins.

 The input to this function MUST be validly encoded.
 This is enforced by the function's in-contract.

 Supersedes:
 This function supersedes std.utf.toUTFindex().

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string to be counted
    n = the current code point index
 */
ptrdiff_t index(E)(const(E)[] s,int n)
in
{
    assert(isValid(s));
    assert(n >= 0);
}
do
{
    const(E)[] t = s;
    for (size_t i=0; i<n; ++i) EncoderInstance!(E).skip(s);
    return t.length - s.length;
}

///
@system pure unittest
{
    assert(index("\u20AC100",1) == 3);
    assert(index("hällo",2) == 3);
}

/**
 Decodes a single code point.

 This function removes one or more code units from the start of a string,
 and returns the decoded code point which those code units represent.

 The input to this function MUST be validly encoded.
 This is enforced by the function's in-contract.

 Supersedes:
 This function supersedes std.utf.decode(), however, note that the
 function codePoints() supersedes it more conveniently.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string whose first code point is to be decoded
 */
dchar decode(S)(ref S s)
in
{
    assert(s.length != 0);
    auto u = s;
    assert(safeDecode(u) != INVALID_SEQUENCE);
}
do
{
    return EncoderInstance!(typeof(s[0])).decode(s);
}

/**
 Decodes a single code point from the end of a string.

 This function removes one or more code units from the end of a string,
 and returns the decoded code point which those code units represent.

 The input to this function MUST be validly encoded.
 This is enforced by the function's in-contract.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string whose first code point is to be decoded
 */
dchar decodeReverse(E)(ref const(E)[] s)
in
{
    assert(s.length != 0);
    assert(isValid(s));
}
do
{
    return EncoderInstance!(E).decodeReverse(s);
}

/**
 Decodes a single code point. The input does not have to be valid.

 This function removes one or more code units from the start of a string,
 and returns the decoded code point which those code units represent.

 This function will accept an invalidly encoded string as input.
 If an invalid sequence is found at the start of the string, this
 function will remove it, and return the value INVALID_SEQUENCE.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    s = the string whose first code point is to be decoded
 */
dchar safeDecode(S)(ref S s)
in
{
    assert(s.length != 0);
}
do
{
    return EncoderInstance!(typeof(s[0])).safeDecode(s);
}

/**
 Returns the number of code units required to encode a single code point.

 The input to this function MUST be a valid code point.
 This is enforced by the function's in-contract.

 The type of the output cannot be deduced. Therefore, it is necessary to
 explicitly specify the encoding as a template parameter.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    c = the code point to be encoded
 */
size_t encodedLength(E)(dchar c)
in
{
    assert(isValidCodePoint(c));
}
do
{
    return EncoderInstance!(E).encodedLength(c);
}

/**
 Encodes a single code point.

 This function encodes a single code point into one or more code units.
 It returns a string containing those code units.

 The input to this function MUST be a valid code point.
 This is enforced by the function's in-contract.

 The type of the output cannot be deduced. Therefore, it is necessary to
 explicitly specify the encoding as a template parameter.

 Supersedes:
 This function supersedes std.utf.encode(), however, note that the
 function codeUnits() supersedes it more conveniently.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    c = the code point to be encoded
 */
E[] encode(E)(dchar c)
in
{
    assert(isValidCodePoint(c));
}
do
{
    return EncoderInstance!(E).encode(c);
}

/**
 Encodes a single code point into an array.

 This function encodes a single code point into one or more code units
 The code units are stored in a user-supplied fixed-size array,
 which must be passed by reference.

 The input to this function MUST be a valid code point.
 This is enforced by the function's in-contract.

 The type of the output cannot be deduced. Therefore, it is necessary to
 explicitly specify the encoding as a template parameter.

 Supersedes:
 This function supersedes std.utf.encode(), however, note that the
 function codeUnits() supersedes it more conveniently.

 Standards: Unicode 5.0, ASCII, ISO-8859-1, ISO-8859-2, WINDOWS-1250,
 WINDOWS-1251, WINDOWS-1252

 Params:
    c     = the code point to be encoded
    array = the destination array

 Returns:
          the number of code units written to the array
 */
size_t encode(E)(dchar c, E[] array)
in
{
    assert(isValidCodePoint(c));
}
do
{
    E[] t = array;
    EncoderInstance!(E).encode(c,t);
    return array.length - t.length;
}

/*
Encodes `c` in units of type `E` and writes the result to the
output range `R`. Returns the number of `E`s written.
 */
size_t encode(E, R)(dchar c, auto ref R range)
if (isNativeOutputRange!(R, E))
{
    static if (is(immutable E == immutable char))
    {
        if (c <= 0x7F)
        {
            put(range, cast(char) c);
            return 1;
        }
        if (c <= 0x7FF)
        {
            put(range, cast(char)(0xC0 | (c >> 6)));
            put(range, cast(char)(0x80 | (c & 0x3F)));
            return 2;
        }
        if (c <= 0xFFFF)
        {
            put(range, cast(char)(0xE0 | (c >> 12)));
            put(range, cast(char)(0x80 | ((c >> 6) & 0x3F)));
            put(range, cast(char)(0x80 | (c & 0x3F)));
            return 3;
        }
        if (c <= 0x10FFFF)
        {
            put(range, cast(char)(0xF0 | (c >> 18)));
            pu// Written in the D programming language.

/++
    This module defines functions related to exceptions and general error
    handling. It also defines functions intended to aid in unit testing.

$(SCRIPT inhibitQuickIndex = 1;)
$(DIVC quickindex,
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD Assumptions) $(TD
        $(LREF assertNotThrown)
        $(LREF assertThrown)
        $(LREF assumeUnique)
        $(LREF assumeWontThrow)
        $(LREF mayPointTo)
))
$(TR $(TD Enforce) $(TD
        $(LREF doesPointTo)
        $(LREF enforce)
        $(LREF errnoEnforce)
))
$(TR $(TD Handlers) $(TD
        $(LREF collectException)
        $(LREF collectExceptionMsg)
        $(LREF ifThrown)
        $(LREF handle)
))
$(TR $(TD Other) $(TD
        $(LREF basicExceptionCtors)
        $(LREF emptyExceptionMsg)
        $(LREF ErrnoException)
        $(LREF RangePrimitive)
))
))

    Copyright: Copyright Andrei Alexandrescu 2008-, Jonathan M Davis 2011-.
    License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0)
    Authors:   $(HTTP erdani.org, Andrei Alexandrescu) and
               $(HTTP jmdavisprog.com, Jonathan M Davis)
    Source:    $(PHOBOSSRC std/exception.d)

 +/
module std.exception;

/// Synopis
@system unittest
{
    import core.stdc.stdlib : malloc, free;
    import std.algorithm.comparison : equal;
    import std.algorithm.iteration : map, splitter;
    import std.algorithm.searching : endsWith;
    import std.conv : ConvException, to;
    import std.range : front, retro;

    // use enforce like assert
    int a = 3;
    enforce(a > 2, "a needs to be higher than 2.");

    // enforce can throw a custom exception
    enforce!ConvException(a > 2, "a needs to be higher than 2.");

    // enforce will return it's input
    enum size = 42;
    auto memory = enforce(malloc(size), "malloc failed")[0 .. size];
    scope(exit) free(memory.ptr);

    // collectException can be used to test for exceptions
    Exception e = collectException("abc".to!int);
    assert(e.file.endsWith("conv.d"));

    // and just for the exception message
    string msg = collectExceptionMsg("abc".to!int);
    assert(msg == "Unexpected 'a' when converting from type string to type int");

    // assertThrown can be used to assert that an exception is thrown
    assertThrown!ConvException("abc".to!int);

    // ifThrown can be used to provide a default value if an exception is thrown
    assert("x".to!int().ifThrown(0) == 0);

    // handle is a more advanced version of ifThrown for ranges
    auto r = "12,1337z32,54".splitter(',').map!(a => to!int(a));
    auto h = r.handle!(ConvException, RangePrimitive.front, (e, r) => 0);
    assert(h.equal([12, 0, 54]));
    assertThrown!ConvException(h.retro.equal([54, 0, 12]));

    // basicExceptionCtors avoids the boilerplate when creating custom exceptions
    static class MeaCulpa : Exception
    {
        mixin basicExceptionCtors;
    }
    e = collectException((){throw new MeaCulpa("diagnostic message");}());
    assert(e.msg == "diagnostic message");
    assert(e.file == __FILE__);
    assert(e.line == __LINE__ - 3);

    // assumeWontThrow can be used to cast throwing code into `nothrow`
    void exceptionFreeCode() nothrow
    {
        // auto-decoding only throws if an invalid UTF char is given
        assumeWontThrow("abc".front);
    }

    // assumeUnique can be used to cast mutable instance to an `immutable` one
    // use with care
    char[] str = "  mutable".dup;
    str[0 .. 2] = "im";
    immutable res = assumeUnique(str);
    assert(res == "immutable");
}

import std.range.primitives;
import std.traits;

/++
    Asserts that the given expression does $(I not) throw the given type
    of `Throwable`. If a `Throwable` of the given type is thrown,
    it is caught and does not escape assertNotThrown. Rather, an
    `AssertError` is thrown. However, any other `Throwable`s will escape.

    Params:
        T          = The `Throwable` to test for.
        expression = The expression to test.
        msg        = Optional message to output on test failure.
                     If msg is empty, and the thrown exception has a
                     non-empty msg field, the exception's msg field
                     will be output on test failure.
        file       = The file where the error occurred.
                     Defaults to `__FILE__`.
        line       = The line where the error occurred.
                     Defaults to `__LINE__`.

    Throws:
        `AssertError` if the given `Throwable` is thrown.

    Returns:
        the result of `expression`.
 +/
auto assertNotThrown(T : Throwable = Exception, E)
                    (lazy E expression,
                     string msg = null,
                     string file = __FILE__,
                     size_t line = __LINE__)
{
    import core.exception : AssertError;
    try
    {
        return expression();
    }
    catch (T t)
    {
        immutable message = msg.length == 0 ? t.msg : msg;
        immutable tail = message.length == 0 ? "." : ": " ~ message;
        throw new AssertError("assertNotThrown failed: " ~ T.stringof ~ " was thrown" ~ tail, file, line, t);
    }
}
///
@system unittest
{
    import core.exception : AssertError;

    import std.string;
    assertNotThrown!StringException(enforce!StringException(true, "Error!"));

    //Exception is the default.
    assertNotThrown(enforce!StringException(true, "Error!"));

    assert(collectExceptionMsg!AssertError(assertNotThrown!StringException(
               enforce!StringException(false, "Error!"))) ==
           `assertNotThrown failed: StringException was thrown: Error!`);
}
@system unittest
{
    import core.exception : AssertError;
    import std.string;
    assert(collectExceptionMsg!AssertError(assertNotThrown!StringException(
               enforce!StringException(false, ""), "Error!")) ==
           `assertNotThrown failed: StringException was thrown: Error!`);

    assert(collectExceptionMsg!AssertError(assertNotThrown!StringException(
               enforce!StringException(false, ""))) ==
           `assertNotThrown failed: StringException was thrown.`);

    assert(collectExceptionMsg!AssertError(assertNotThrown!StringException(
               enforce!StringException(false, ""), "")) ==
           `assertNotThrown failed: StringException was thrown.`);
}

@system unittest
{
    import core.exception : AssertError;

    static noreturn throwEx(Throwable t) { throw t; }
    bool nothrowEx() { return true; }

    try
    {
        assert(assertNotThrown!Exception(nothrowEx()));
    }
    catch (AssertError) assert(0);

    try
    {
        assert(assertNotThrown!Exception(nothrowEx(), "It's a message"));
    }
    catch (AssertError) assert(0);

    try
    {
        assert(assertNotThrown!AssertError(nothrowEx()));
    }
    catch (AssertError) assert(0);

    try
    {
        assert(assertNotThrown!AssertError(nothrowEx(), "It's a message"));
    }
    catch (AssertError) assert(0);

    {
        bool thrown = false;
        try
        {
            assertNotThrown!Exception(
                throwEx(new Exception("It's an Exception")));
        }
        catch (AssertError) thrown = true;
        assert(thrown);
    }

    {
        bool thrown = false;
        try
        {
            assertNotThrown!Exception(
                throwEx(new Exception("It's an Exception")), "It's a message");
        }
        catch (AssertError) thrown = true;
        assert(thrown);
    }

    {
        bool thrown = false;
        try
        {
            assertNotThrown!AssertError(
                throwEx(new AssertError("It's an AssertError", __FILE__, __LINE__)));
        }
        catch (AssertError) thrown = true;
        assert(thrown);
    }

    {
        bool thrown = false;
        try
        {
            assertNotThrown!AssertError(
                throwEx(new AssertError("It's an AssertError", __FILE__, __LINE__)),
                        "It's a message");
        }
        catch (AssertError) thrown = true;
        assert(thrown);
    }
}

/++
    Asserts that the given expression throws the given type of `Throwable`.
    The `Throwable` is caught and does not escape assertThrown. However,
    any other `Throwable`s $(I will) escape, and if no `Throwable`
    of the given type is thrown, then an `AssertError` is thrown.

    Params:
        T          = The `Throwable` to test for.
        expression = The expression to test.
        msg        = Optional message to output on test failure.
        file       = The file where the error occurred.
                     Defaults to `__FILE__`.
        line       = The line where the error occurred.
                     Defaults to `__LINE__`.

    Throws:
        `AssertError` if the given `Throwable` is not thrown.
  +/
void assertThrown(T : Throwable = Exception, E)
                 (lazy E expression,
                  string msg = null,
                  string file = __FILE__,
                  size_t line = __LINE__)
{
    import core.exception : AssertError;

    try
        expression();
    catch (T)
        return;

    static if (!is(immutable E == immutable noreturn))
        throw new AssertError("assertThrown failed: No " ~ T.stringof ~ " was thrown"
                                 ~ (msg.length == 0 ? "." : ": ") ~ msg,
                          file, line);
}
///
@system unittest
{
    import core.exception : AssertError;
    import std.string;

    assertThrown!StringException(enforce!StringException(false, "Error!"));

    //Exception is the default.
    assertThrown(enforce!StringException(false, "Error!"));

    assert(collectExceptionMsg!AssertError(assertThrown!StringException(
               enforce!StringException(true, "Error!"))) ==
           `assertThrown failed: No StringException was thrown.`);
}

@system unittest
{
    import core.exception : AssertError;

    static noreturn throwEx(Throwable t) { throw t; }
    void nothrowEx() { }

    try
    {
        assertThrown!Exception(throwEx(new Exception("It's an Exception")));
    }
    catch (AssertError) assert(0);

    try
    {
        assertThrown!Exception(throwEx(new Exception("It's an Exception")),
                               "It's a message");
    }
    catch (AssertError) assert(0);

    try
    {
        assertThrown!AssertError(throwEx(new AssertError("It's an AssertError",
                                                         __FILE__, __LINE__)));
    }
    catch (AssertError) assert(0);

    try
    {
        assertThrown!AssertError(throwEx(new AssertError("It's an AssertError",
                                                         __FILE__, __LINE__)),
                                 "It's a message");
    }
    catch (AssertError) assert(0);


    {
        bool thrown = false;
        try
            assertThrown!Exception(nothrowEx());
        catch (AssertError)
            thrown = true;

        assert(thrown);
    }

    {
        bool thrown = false;
        try
            assertThrown!Exception(nothrowEx(), "It's a message");
        catch (AssertError)
            thrown = true;

        assert(thrown);
    }

    {
        bool thrown = false;
        try
            assertThrown!AssertError(nothrowEx());
        catch (AssertError)
            thrown = true;

        assert(thrown);
    }

    {
        bool thrown = false;
        try
            assertThrown!AssertError(nothrowEx(), "It's a message");
        catch (AssertError)
            thrown = true;

        assert(thrown);
    }
}


/++
    Enforces that the given value is true.
    If the given value is false, an exception is thrown.
    The
    $(UL
        $(LI `msg` - error message as a `string`)
        $(LI `dg` - custom delegate that return a string and is only called if an exception occurred)
        $(LI `ex` - custom exception to be thrown. It is `lazy` and is only created if an exception occurred)
    )

    Params:
        value = The value to test.
        E = Exception type to throw if the value evaluates to false.
        msg = The error message to put in the exception if it is thrown.
        dg = The delegate to be called if the value evaluates to false.
        ex = The exception to throw if the value evaluates to false.
        file = The source file of the caller.
        line = The line number of the caller.

    Returns: `value`, if `cast(bool) value` is true. Otherwise,
    depending on the chosen overload, `new Exception(msg)`, `dg()` or `ex` is thrown.

        $(PANEL
        $(NOTE `enforce` is used to throw exceptions and is therefore intended to
        aid in error handling. It is $(I not) intended for verifying the logic
        of your program - that is what `assert` is for.)

        Do not use
        `enforce` inside of contracts (i.e. inside of `in` and `out`
        blocks and `invariant`s), because contracts are compiled out when
        compiling with $(I -release).
        )

        If a delegate is passed, the safety and purity of this function are inferred
        from `Dg`'s safety and purity.
 +/
template enforce(E : Throwable = Exception)
if (is(typeof(new E("", string.init, size_t.init)) : Throwable) ||
    is(typeof(new E(string.init, size_t.init)) : Throwable))
{
    ///
    T enforce(T)(T value, lazy const(char)[] msg = null,
    string file = __FILE__, size_t line = __LINE__)
    if (is(typeof({ if (!value) {} })))
    {
        if (!value) bailOut!E(file, line, msg);
        return value;
    }
}

/// ditto
T enforce(T, Dg, string file = __FILE__, size_t line = __LINE__)
    (T value, scope Dg dg)
if (isSomeFunction!Dg && is(typeof( dg() )) &&
    is(typeof({ if (!value) {} })))
{
    if (!value) dg();
    return value;
}

/// ditto
T enforce(T)(T value, lazy Throwable ex)
{
    if (!value) throw ex();
    return value;
}

///
@system unittest
{
    import core.stdc.stdlib : malloc, free;
    import std.conv : ConvException, to;

    // use enforce like assert
    int a = 3;
    enforce(a > 2, "a needs to be higher than 2.");

    // enforce can throw a custom exception
    enforce!ConvException(a > 2, "a needs to be higher than 2.");

    // enforce will return it's input
    enum size = 42;
    auto memory = enforce(malloc(size), "malloc failed")[0 .. size];
    scope(exit) free(memory.ptr);
}

///
@safe unittest
{
    assertNotThrown(enforce(true, new Exception("this should not be thrown")));
    assertThrown(enforce(false, new Exception("this should be thrown")));
}

///
@safe unittest
{
    assert(enforce(123) == 123);

    try
    {
        enforce(false, "error");
        assert(false);
    }
    catch (Exception e)
    {
        assert(e.msg == "error");
        assert(e.file == __FILE__);
        assert(e.line == __LINE__-7);
    }
}

/// Alias your own enforce function
@safe unittest
{
    import std.conv : ConvException;
    alias convEnforce = enforce!ConvException;
    assertNotThrown(convEnforce(true));
    assertThrown!ConvException(convEnforce(false, "blah"));
}

private noreturn bailOut(E : Throwable = Exception)(string file, size_t line, scope const(char)[] msg)
{
    static if (is(typeof(new E(string.init, string.init, size_t.init))))
    {
        throw new E(msg ? msg.idup : "Enforcement failed", file, line);
    }
    else static if (is(typeof(new E(string.init, size_t.init))))
    {
        throw new E(file, line);
    }
    else
    {
        static assert(0, "Expected this(string, string, size_t) or this(string, size_t)" ~
            " constructor for " ~ __traits(identifier, E));
    }
}

// https://issues.dlang.org/show_bug.cgi?id=10510
@safe unittest
{
    extern(C) void cFoo() { }
    enforce(false, &cFoo);
}

// purity and safety inference test
@system unittest
{
    static foreach (EncloseSafe; [false, true])
    static foreach (EnclosePure; [false, true])
    {
        static foreach (BodySafe; [false, true])
        static foreach (BodyPure; [false, true])
        {{
            enum code =
                "delegate void() " ~
                (EncloseSafe ? "@safe " : "") ~
                (EnclosePure ? "pure " : "") ~
                "{ enforce(true, { " ~
                        "int n; " ~
                        (BodySafe ? "" : "auto p = &n + 10; "    ) ~    // unsafe code
                        (BodyPure ? "" : "static int g; g = 10; ") ~    // impure code
                    "}); " ~
                "}";
            enum expect =
                (BodySafe || !EncloseSafe) && (!EnclosePure || BodyPure);

            version (none)
            pragma(msg, "safe = ", EncloseSafe?1:0, "/", BodySafe?1:0, ", ",
                        "pure = ", EnclosePure?1:0, "/", BodyPure?1:0, ", ",
                        "expect = ", expect?"OK":"NG", ", ",
                        "code = ", code);

            static assert(__traits(compiles, mixin(code)()) == expect);
        }}
    }
}

// Test for https://issues.dlang.org/show_bug.cgi?id=8637
@system unittest
{
    struct S
    {
        static int g;
        ~this() {}  // impure & unsafe destructor
        bool opCast(T:bool)() {
            int* p = cast(int*) 0;   // unsafe operation
            int n = g;              // impure operation
            return true;
        }
    }
    S s;

    enforce(s);
    enforce(s, {});
    enforce(s, new Exception(""));

    errnoEnforce(s);

    alias E1 = Exception;
    static class E2 : Exception
    {
        this(string fn, size_t ln) { super("", fn, ln); }
    }
    static class E3 : Exception
    {
        this(string msg) { super(msg, __FILE__, __LINE__); }
    }
    enforce!E1(s);
    enforce!E2(s);
}

// https://issues.dlang.org/show_bug.cgi?id=14685
@safe unittest
{
    class E : Exception
    {
        this() { super("Not found"); }
    }
    static assert(!__traits(compiles, { enforce!E(false); }));
}

/++
    Enforces that the given value is true, throwing an `ErrnoException` if it
    is not.

    Params:
        value = The value to test.
        msg = The message to include in the `ErrnoException` if it is thrown.

    Returns: `value`, if `cast(bool) value` is true. Otherwise,
    $(D new ErrnoException(msg)) is thrown.  It is assumed that the last
    operation set `errno` to an error code corresponding with the failed
    condition.
 +/
alias errnoEnforce = enforce!ErrnoException;

///
@system unittest
{
    import core.stdc.stdio : fclose, fgets, fopen;
    import std.file : thisExePath;
    import std.string : toStringz;

    auto f = fopen(thisExePath.toStringz, "r").errnoEnforce;
    scope(exit) fclose(f);
    char[100] buf;
    auto line = fgets(buf.ptr, buf.length, f);
    enforce(line !is null); // expect a non-empty line
}

/++
    Catches and returns the exception thrown from the given expression.
    If no exception is thrown, then null is returned and `result` is
    set to the result of the expression.

    Note that while `collectException` $(I can) be used to collect any
    `Throwable` and not just `Exception`s, it is generally ill-advised to
    catch anything that is neither an `Exception` nor a type derived from
    `Exception`. So, do not use `collectException` to collect
    non-`Exception`s unless you're sure that that's what you really want to
    do.

    Params:
        T          = The type of exception to catch.
        expression = The expression which may throw an exception.
        result     = The result of the expression if no exception is thrown.
+/
T collectException(T = Exception, E)(lazy E expression, ref E result)
{
    try
    {
        result = expression();
    }
    catch (T e)
    {
        return e;
    }
    // Avoid "statement not reachable" warning
    static if (!is(immutable E == immutable noreturn))
        return null;
}
///
@system unittest
{
    int b;
    int foo() { throw new Exception("blah"); }
    assert(collectException(foo(), b));

    version (D_NoBoundsChecks) {}
    else
    {
        // check for out of bounds error
        int[] a = new int[3];
        import core.exception : RangeError;
        assert(collectException!RangeError(a[4], b));
    }
}

/++
    Catches and returns the exception thrown from the given expression.
    If no exception is thrown, then null is returned. `E` can be
    `void`.

    Note that while `collectException` $(I can) be used to collect any
    `Throwable` and not just `Exception`s, it is generally ill-advised to
    catch anything that is neither an `Exception` nor a type derived from
    `Exception`. So, do not use `collectException` to collect
    non-`Exception`s unless you're sure that that's what you really want to
    do.

    Params:
        T          = The type of exception to catch.
        expression = The expression which may throw an exception.
+/
T collectException(T : Throwable = Exception, E)(lazy E expression)
{
    try
    {
        expression();
    }
    catch (T t)
    {
        return t;
    }
    // Avoid "statement not reachable" warning
    static if (!is(immutable E == immutable noreturn))
        return null;
}

///
@safe unittest
{
    int foo() { throw new Exception("blah"); }
    assert(collectException(foo()).msg == "blah");
}

/++
    Catches the exception thrown from the given expression and returns the
    msg property of that exception. If no exception is thrown, then null is
    returned. `E` can be `void`.

    If an exception is thrown but it has an empty message, then
    `emptyExceptionMsg` is returned.

    Note that while `collectExceptionMsg` $(I can) be used to collect any
    `Throwable` and not just `Exception`s, it is generally ill-advised to
    catch anything that is neither an `Exception` nor a type derived from
    `Exception`. So, do not use `collectExceptionMsg` to collect
    non-`Exception`s unless you're sure that that's what you really want to
    do.

    Params:
        T          = The type of exception to catch.
        expression = The expression which may throw an exception.
+/
string collectExceptionMsg(T = Exception, E)(lazy E expression)
{
    import std.array : empty;
    try
    {
        expression();

        // Avoid "statement not reachable" warning
        static if (!is(immutable E == immutable noreturn))
            return cast(string) null;
    }
    catch (T e)
        return e.msg.empty ? emptyExceptionMsg : e.msg;
}
///
@safe unittest
{
    void throwFunc() { throw new Exception("My Message."); }
    assert(collectExceptionMsg(throwFunc()) == "My Message.");

    void nothrowFunc() {}
    assert(collectExceptionMsg(nothrowFunc()) is null);

    void throwEmptyFunc() { throw new Exception(""); }
    assert(collectExceptionMsg(throwEmptyFunc()) == emptyExceptionMsg);
}

/++
    Value that collectExceptionMsg returns when it catches an exception
    with an empty exception message.
 +/
enum emptyExceptionMsg = "<Empty Exception Message>";

// https://issues.dlang.org/show_bug.cgi?id=22364
@system unittest
{
    static noreturn foo() { throw new Exception(""); }

    const ex = collectException!(Exception, noreturn)(foo());
    assert(ex);

    const msg = collectExceptionMsg!(Exception, noreturn)(foo());
    assert(msg);

    noreturn n;

    // Triggers a backend assertion failure
    // collectException!(Exception, noreturn)(foo(), n);

    static assert(__traits(compiles, collectException!(Exception, noreturn)(foo(), n)));
}

/**
Casts a mutable array to an immutable array in an idiomatic
manner. Technically, `assumeUnique` just inserts a cast,
but its name documents assumptions on the part of the
caller. `assumeUnique(arr)` should only be called when
there are no more active mutable aliases to elements of $(D
arr). To strengthen this assumption, `assumeUnique(arr)`
also clears `arr` before returning. Essentially $(D
assumeUnique(arr)) indicates commitment from the caller that there
is no more mutable access to any of `arr`'s elements
(transitively), and that all future accesses will be done through
the immutable array returned by `assumeUnique`.

Typically, `assumeUnique` is used to return arrays from
functions that have allocated and built them.

Params:
 array = The array to cast to immutable.

Returns: The immutable array.

Example:

$(RUNNABLE_EXAMPLE
----
string letters()
{
  char[] result = new char['z' - 'a' + 1];
  foreach (i, ref e; result)
  {
    e = cast(char)('a' + i);
  }
  return assumeUnique(result);
}
----
)

The use in the example above is correct because `result`
was private to `letters` and the memory it referenced can no longer be written to
after the function returns. The following example shows an
incorrect use of `assumeUnique`.

Bad:

$(RUNNABLE_EXAMPLE
----
char[] buffer;
string letters(char first, char last)
{
  if (first >= last) return null; // fine
  auto sneaky = buffer;
  sneaky.length = last - first + 1;
  foreach (i, ref e; sneaky)
  {
    e = cast(char)('a' + i);
  }
  return assumeUnique(sneaky); // BAD
}
----
)

The example above wreaks havoc on client code because it modifies the
returned array that the previous caller considered immutable. To obtain an
immutable array from the writable array `buffer`, replace
the last line with:

----
return to!(string)(sneaky); // not that sneaky anymore
----

The `to` call will duplicate the array appropriately.

$(PANEL
$(NOTE Checking for uniqueness during compilation is
possible in certain cases, especially when a function is
marked (or inferred) as `pure`. The following example does not
need to call `assumeUnique` because the compiler can infer the
uniqueness of the array in the pure function:)

$(RUNNABLE_EXAMPLE
----
static string letters() pure
{
  char[] result = new char['z' - 'a' + 1];
  foreach (i, ref e; result)
  {
    e = cast(char)('a' + i);
  }
  return result;
}
----
)

For more on infering uniqueness see the $(B unique) and
$(B lent) keywords in the
$(HTTP www.cs.cmu.edu/~aldrich/papers/aldrich-dissertation.pdf, ArchJava)
language.
)

The downside of using `assumeUnique`'s
convention-based usage is that at this time there is no
formal checking of the correctness of the assumption;
on the upside, the idiomatic use of `assumeUnique` is
simple and rare enough to be tolerable.
 */
immutable(T)[] assumeUnique(T)(T[] array) pure nothrow
{
    return .assumeUnique(array);    // call ref version
}
/// ditto
immutable(T)[] assumeUnique(T)(ref T[] array) pure nothrow
{
    auto result = cast(immutable(T)[]) array;
    array = null;
    return result;
}
/// ditto
immutable(T[U]) assumeUnique(T, U)(ref T[U] array) pure nothrow
{
    auto result = cast(immutable(T[U])) array;
    array = null;
    return result;
}

///
@system unittest
{
    int[] arr = new int[1];
    auto arr1 = arr.assumeUnique;
    static assert(is(typeof(arr1) == immutable(int)[]));
    assert(arr == null);
    assert(arr1 == [0]);
}

///
@system unittest
{
    int[string] arr = ["a":1];
    auto arr1 = arr.assumeUnique;
    static assert(is(typeof(arr1) == immutable(int[string])));
    assert(arr == null);
    assert(arr1.keys == ["a"]);
}

/**
 * Wraps a possibly-throwing expression in a `nothrow` wrapper so that it
 * can be called by a `nothrow` function.
 *
 * This wrapper function documents commitment on the part of the caller that
 * the appropriate steps have been taken to avoid whatever conditions may
 * trigger an exception during the evaluation of `expr`.  If it turns out
 * that the expression $(I does) throw at runtime, the wrapper will throw an
 * `AssertError`.
 *
 * (Note that `Throwable` objects such as `AssertError` that do not
 * subclass `Exception` may be thrown even from `nothrow` functions,
 * since they are considered to be serious runtime problems that cannot be
 * recovered from.)
 *
 * Params:
 *  expr = The expression asserted not to throw.
 *  msg = The message to include in the `AssertError` if the assumption turns
 *      out to be false.
 *  file = The source file name of the caller.
 *  line = The line number of the caller.
 *
 * Returns:
 *  The value of `expr`, if any.
 */
T assumeWontThrow(T)(lazy T expr,
                     string msg = null,
                     string file = __FILE__,
                     size_t line = __LINE__) nothrow
{
    import core.exception : AssertError;
    try
    {
        return expr;
    }
    catch (Exception e)
    {
        import std.range.primitives : empty;
        immutable tail = msg.empty ? "." : ": " ~ msg;
        throw new AssertError("assumeWontThrow failed: Expression did throw" ~
                              tail, file, line);
    }
}

///
@safe unittest
{
    import std.math.algebraic : sqrt;

    // This function may throw.
    int squareRoot(int x)
    {
        if (x < 0)
            throw new Exception("Tried to take root of negative number");
        return cast(int) sqrt(cast(double) x);
    }

    // This function never throws.
    int computeLength(int x, int y) nothrow
    {
        // Since x*x + y*y is always positive, we can safely assume squareRoot
        // won't throw, and use it to implement this nothrow function. If it
        // does throw (e.g., if x*x + y*y overflows a 32-bit value), then the
        // program will terminate.
        return assumeWontThrow(squareRoot(x*x + y*y));
    }

    assert(computeLength(3, 4) == 5);
}

@system unittest
{
    import core.exception : AssertError;

    void alwaysThrows()
    {
        throw new Exception("I threw up");
    }
    void bad() nothrow
    {
        assumeWontThrow(alwaysThrows());
    }
    assertThrown!AssertError(bad());
}

/**
Checks whether a given source object contains pointers or references to a given
target object.

Params:
    source = The source object
    target = The target object

Bugs:
    The function is explicitly annotated `@nogc` because inference could fail,
    see $(LINK2 https://issues.dlang.org/show_bug.cgi?id=17084, Bugzilla issue 17084).

Returns: `true` if `source`'s representation embeds a pointer
that points to `target`'s representation or somewhere inside
it.

If `source` is or contains a dynamic array, then, then these functions will check
if there is overlap between the dynamic array and `target`'s representation.

If `source` is a class, then it will be handled as a pointer.

If `target` is a pointer, a dynamic array or a class, then these functions will only
check if `source` points to `target`, $(I not) what `target` references.

If `source` is or contains a union or `void[n]`, then there may be either false positives or
false negatives:

`doesPointTo` will return `true` if it is absolutely certain
`source` points to `target`. It may produce false negatives, but never
false positives. This function should be prefered when trying to validate
input data.

`mayPointTo` will return `false` if it is absolutely certain
`source` does not point to `target`. It may produce false positives, but never
false negatives. This function should be prefered for defensively choosing a
code path.

Note: Evaluating $(D doesPointTo(x, x)) checks whether `x` has
internal pointers. This should only be done as an assertive test,
as the language is free to assume objects don't have internal pointers
(TDPL 7.1.3.5).
*/
bool doesPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @nogc @trusted pure nothrow
if (__traits(isRef, source) || isDynamicArray!S ||
    is(S == U*, U) || is(S == class))
{
    static if (is(S == U*, U) || is(S == class) || is(S == interface))
    {
        const m = *cast(void**) &source;
        const b = cast(void*) &target;
        const e = b + target.sizeof;
        return b <= m && m < e;
    }
    else static if (is(S == struct) || is(S == union))
    {
        foreach (i, Subobj; typeof(source.tupleof))
            static if (!isUnionAliased!(S, i))
                if (doesPointTo(source.tupleof[i], target)) return true;
        return false;
    }
    else static if (isStaticArray!S)
    {
        static if (!is(S == void[n], size_t n))
        {
            foreach (ref s; source)
                if (doesPointTo(s, target)) return true;
        }
        return false;
    }
    else static if (isDynamicArray!S)
    {
        import std.array : overlap;
        return overlap(cast(void[]) source, cast(void[])(&target)[0 .. 1]).length != 0;
    }
    else
    {
        return false;
    }
}

// for shared objects
/// ditto
bool doesPointTo(S, T)(auto ref const shared S source, ref const shared T target) @trusted pure nothrow
{
    return doesPointTo!(shared S, shared T, void)(source, target);
}

/// ditto
bool mayPointTo(S, T, Tdummy=void)(auto ref const S source, ref const T target) @trusted pure nothrow
if (__traits(isRef, source) || isDynamicArray!S ||
    is(S == U*, U) || is(S == class))
{
    static if (is(S == U*, U) || is(S == class) || is(S == interface))
    {
        const m = *cast(void**) &source;
        const b = cast(void*) &target;
        const e = b + target.sizeof;
        return b <= m && m < e;
    }
    else static if (is(S == struct) || is(S == union))
    {
        foreach (i, Subobj; typeof(source.tupleof))
            if (mayPointTo(source.tupleof[i], target)) return true;
        return false;
    }
    else static if (isStaticArray!S)
    {
        static if (is(S == void[n], size_t n))
        {
            static if (n >= (void[]).sizeof)
            {
                // could contain a slice, which could point at anything.
                // But a void[N] that is all 0 cannot point anywhere
                import std.algorithm.searching : any;
                if (__ctfe || any(cast(ubyte[]) source[]))
                    return true;
            }
            else static if (n >= (void*).sizeof)
            {
                // Reinterpreting cast is impossible during ctfe
                if (__ctfe)
                    return true;

                // Only check for properly aligned pointers
                enum al = (void*).alignof - 1;
                const base = cast(size_t) &source;
                const alBase = (base + al) & ~al;

                if ((n - (alBase - base)) >= (void*).sizeof &&
                    mayPointTo(*(cast(void**) alBase), target))
                    return true;
            }
        }
        else
        {
            foreach (size_t i; 0 .. S.length)
                if (mayPointTo(source[i], target)) return true;
        }

        return false;
    }
    else static if (isDynamicArray!S)
    {
        import std.array : overlap;
        return overlap(cast(void[]) source, cast(void[])(&target)[0 .. 1]).length != 0;
    }
    else
    {
        return false;
    }
}

// for shared objects
/// ditto
bool mayPointTo(S, T)(auto ref const shared S source, ref const shared T target) @trusted pure nothrow
{
    return mayPointTo!(shared S, shared T, void)(source, target);
}

/// Pointers
@system unittest
{
    int  i = 0;
    int* p = null;
    assert(!p.doesPointTo(i));
    p = &i;
    assert( p.doesPointTo(i));
}

/// Structs and Unions
@system unittest
{
    struct S
    {
        int v;
        int* p;
    }
    int i;
    auto s = S(0, &i);

    // structs and unions "own" their members
    // pointsTo will answer true if one of the members pointsTo.
    assert(!s.doesPointTo(s.v)); //s.v is just v member of s, so not pointed.
    assert( s.p.doesPointTo(i)); //i is pointed by s.p.
    assert( s  .doesPointTo(i)); //which means i is pointed by s itself.

    // Unions will behave exactly the same. Points to will check each "member"
    // individually, even if they share the same memory
}

/// Arrays (dynamic and static)
@system unittest
{
    int i;
     // trick the compiler when initializing slice
     // https://issues.dlang.org/show_bug.cgi?id=18637
    int* p = &i;
    int[]  slice = [0, 1, 2, 3, 4];
    int[5] arr   = [0, 1, 2, 3, 4];
    int*[]  slicep = [p];
    int*[1] arrp   = [&i];

    // A slice points to all of its members:
    assert( slice.doesPointTo(slice[3]));
    assert(!slice[0 .. 2].doesPointTo(slice[3])); // Object 3 is outside of the
                                                  // slice [0 .. 2]

    // Note that a slice will not take into account what its members point to.
    assert( slicep[0].doesPointTo(i));
    assert(!slicep   .doesPointTo(i));

    // static arrays are objects that own their members, just like structs:
    assert(!arr.doesPointTo(arr[0])); // arr[0] is just a member of arr, so not
                                      // pointed.
    assert( arrp[0].doesPointTo(i));  // i is pointed by arrp[0].
    assert( arrp   .doesPointTo(i));  // which means i is pointed by arrp
                                      // itself.

    // Notice the difference between static and dynamic arrays:
    assert(!arr  .doesPointTo(arr[0]));
    assert( arr[].doesPointTo(arr[0]));
    assert( arrp  .doesPointTo(i));
    assert(!arrp[].doesPointTo(i));
}

/// Classes
@system unittest
{
    class C
    {
        this(int* p){this.p = p;}
        int* p;
    }
    int i;
    C a = new C(&i);
    C b = a;

    // Classes are a bit particular, as they are treated like simple pointers
    // to a class payload.
    assert( a.p.doesPointTo(i)); // a.p points to i.
    assert(!a  .doesPointTo(i)); // Yet a itself does not point i.

    //To check the class payload itself, iterate on its members:
    ()
    {
        import std.traits : Fields;

        foreach (index, _; Fields!C)
            if (doesPointTo(a.tupleof[index], i))
                return;
        assert(0);
    }();

    // To check if a class points a specific payload, a direct memmory check
    // can be done:
    auto aLoc = cast(ubyte[__traits(classInstanceSize, C)]*) a;
    assert(b.doesPointTo(*aLoc)); // b points to where a is pointing
}


version (StdUnittest)
{
    // https://issues.dlang.org/show_bug.cgi?id=17084
    // the bug doesn't happen if these declarations are in the unittest block
    // (static or not).
    private struct Page17084
    {
        URL17084 url;
        int opCmp(P)(P) { return 0; }
        int opCmp(P)(shared(P)) shared { return 0; }
    }

    private struct URL17084
    {
        int[] queryParams;
        string toString()() const { return ""; }
        alias toString this;
    }
}

// https://issues.dlang.org/show_bug.cgi?id=17084
@system unittest
{
    import std.algorithm.sorting : sort;
    Page17084[] s;
    sort(s);
    shared(Page17084)[] p;
    sort(p);
}

@system unittest
{
    struct S1 { int a; S1 * b; }
    S1 a1;
    S1 * p = &a1;
    assert(doesPointTo(p, a1));

    S1 a2;
    a2.b = &a1;
    assert(doesPointTo(a2, a1));

    struct S3 { int[10] a; }
    S3 a3;
    auto a4 = a3.a[2 .. 3];
    assert(doesPointTo(a4, a3));

    auto a5 = new double[4];
    auto a6 = a5[1 .. 2];
    assert(!doesPointTo(a5, a6));

    auto a7 = new double[3];
    auto a8 = new double[][1];
    a8[0] = a7;
    assert(!doesPointTo(a8[0], a8[0]));

    // don't invoke postblit on subobjects
    {
        static struct NoCopy { this(this) { assert(0); } }
        static struct Holder { NoCopy a, b, c; }
        Holder h;
        cast(void) doesPointTo(h, h);
    }

    shared S3 sh3;
    shared sh3sub = sh3.a[];
    assert(doesPointTo(sh3sub, sh3));

    int[] darr = [1, 2, 3, 4];

    //dynamic arrays don't point to each other, or slices of themselves
    assert(!doesPointTo(darr, darr));
    assert(!doesPointTo(darr[0 .. 1], darr));

    //But they do point their elements
    foreach (i; 0 .. 4)
        assert(doesPointTo(darr, darr[i]));
    assert(doesPointTo(darr[0 .. 3], darr[2]));
    assert(!doesPointTo(darr[0 .. 3], darr[3]));
}

@system unittest
{
    //tests with static arrays
    //Static arrays themselves are just objects, and don't really *point* to anything.
    //They aggregate their contents, much the same way a structure aggregates its attributes.
    //*However* The elements inside the static array may themselves point to stuff.

    //Standard array
    int[2] k;
    assert(!doesPointTo(k, k)); //an array doesn't point to itself
    //Technically, k doesn't point its elements, although it does alias them
    assert(!doesPointTo(k, k[0]));
    assert(!doesPointTo(k, k[1]));
    //But an extracted slice will point to the same array.
    assert(doesPointTo(k[], k));
    assert(doesPointTo(k[], k[1]));

    //An array of pointers
    int*[2] pp;
    int a;
    int b;
    pp[0] = &a;
    assert( doesPointTo(pp, a));  //The array contains a pointer to a
    assert(!doesPointTo(pp, b));  //The array does NOT contain a pointer to b
    assert(!doesPointTo(pp, pp)); //The array does not point itslef

    //A struct containing a static array of pointers
    static struct S
    {
        int*[2] p;
    }
    S s;
    s.p[0] = &a;
    assert( doesPointTo(s, a)); //The struct contains an array that points a
    assert(!doesPointTo(s, b)); //But doesn't point b
    assert(!doesPointTo(s, s)); //The struct doesn't actually point itslef.

    //An array containing structs that have pointers
    static struct SS
    {
        int* p;
    }
    SS[2] ss = [SS(&a), SS(null)];
    assert( doesPointTo(ss, a));  //The array contains a struct that points to a
    assert(!doesPointTo(ss, b));  //The array doesn't contains a struct that points to b
    assert(!doesPointTo(ss, ss)); //The array doesn't point itself.

    // https://issues.dlang.org/show_bug.cgi?id=20426
    align((void*).alignof) void[32] voidArr = void;
    (cast(void*[]) voidArr[])[] = null; // Ensure no false pointers

    // zeroed void ranges can't point at anything
    assert(!mayPointTo(voidArr, a));
    assert(!mayPointTo(voidArr, b));

    *cast(void**) &voidArr[16] = &a; // Pointers should be found

    alias SA = void[size_t.sizeof + 3];
    SA *smallArr1 = cast(SA*)&voidArr;
    SA *smallArr2 = cast(SA*)&(voidArr[16]);

    // But it should only consider properly aligned pointers
    // Write single bytes to avoid issues due to misaligned writes
    void*[1] tmp = [&b];
    (cast(ubyte[]) voidArr[3 .. 3 + (void*).sizeof])[] = cast(ubyte[]) tmp[];


    assert( mayPointTo(*smallArr2, a));
    assert(!mayPointTo(*smallArr1, b));

    assert(!doesPointTo(voidArr, a)); // Value might be a false pointer
    assert(!doesPointTo(voidArr, b));

    SA *smallArr3 = cast(SA *) &voidArr[13]; // Works for weird sizes/alignments
    assert( mayPointTo(*smallArr3, a));
    assert(!mayPointTo(*smallArr3, b));

    assert(!doesPointTo(*smallArr3, a));
    assert(!doesPointTo(*smallArr3, b));

    auto v3 = cast(void[3]*) &voidArr[16]; // Arrays smaller than pointers are ignored
    assert(!mayPointTo(*v3, a));
    assert(!mayPointTo(*v3, b));

    assert(!doesPointTo(*v3, a));
    assert(!doesPointTo(*v3, b));

    assert(mayPointTo(voidArr, a)); // slice-contiaining void[N] might point at anything
    assert(mayPointTo(voidArr, b));

    static assert(() {
        void[16] arr1 = void;
        void[size_t.sizeof] arr2 = void;
        int var;
        return mayPointTo(arr1, var) && !doesPointTo(arr1, var) &&
               mayPointTo(arr2, var) && !doesPointTo(arr2, var);
    }());
}


@system unittest //Unions
{
    int i;
    union U //Named union
    {
        size_t asInt = 0;
        int*   asPointer;
    }
    struct S
    {
        union //Anonymous union
        {
            size_t asInt = 0;
            int*   asPointer;
        }
    }

    U u;
    S s;
    assert(!doesPointTo(u, i));
    assert(!doesPointTo(s, i));
    assert(!mayPointTo(u, i));
    assert(!mayPointTo(s, i));

    u.asPointer = &i;
    s.asPointer = &i;
    assert(!doesPointTo(u, i));
    assert(!doesPointTo(s, i));
    assert( mayPointTo(u, i));
    assert( mayPointTo(s, i));

    u.asInt = cast(size_t)&i;
    s.asInt = cast(size_t)&i;
    assert(!doesPointTo(u, i));
    assert(!doesPointTo(s, i));
    assert( mayPointTo(u, i));
    assert( mayPointTo(s, i));
}

@system unittest //Classes
{
    int i;
    static class A
    {
        int* p;
    }
    A a = new A, b = a;
    assert(!doesPointTo(a, b)); //a does not point to b
    a.p = &i;
    assert(!doesPointTo(a, i)); //a does not point to i
}
@safe unittest //alias this test
{
    static int i;
    static int j;
    struct S
    {
        int* p;
        @property int* foo(){return &i;}
        alias foo this;
    }
    assert(is(S : int*));
    S s = S(&j);
    assert(!doesPointTo(s, i));
    assert( doesPointTo(s, j));
    assert( doesPointTo(cast(int*) s, i));
    assert(!doesPointTo(cast(int*) s, j));
}

/+
Returns true if the field at index `i` in ($D T) shares its address with another field.

Note: This does not merelly check if the field is a member of an union, but also that
it is not a single child.
+/
package enum isUnionAliased(T, size_t i) = isUnionAliasedImpl!T(T.tupleof[i].offsetof);
private bool isUnionAliasedImpl(T)(size_t offset)
{
    int count = 0;
    foreach (i, U; typeof(T.tupleof))
        if (T.tupleof[i].offsetof == offset)
            ++count;
    return count >= 2;
}
//
@safe unittest
{
    static struct S
    {
        int a0; //Not aliased
        union
        {
            int a1; //Not aliased
        }
        union
        {
            int a2; //Aliased
            int a3; //Aliased
        }
        union A4
        {
            int b0; //Not aliased
        }
        A4 a4;
        union A5
        {
            int b0; //Aliased
            int b1; //Aliased
        }
        A5 a5;
    }

    static assert(!isUnionAliased!(S, 0)); //a0;
    static assert(!isUnionAliased!(S, 1)); //a1;
    static assert( isUnionAliased!(S, 2)); //a2;
    static assert( isUnionAliased!(S, 3)); //a3;
    static assert(!isUnionAliased!(S, 4)); //a4;
        static assert(!isUnionAliased!(S.A4, 0)); //a4.b0;
    static assert(!isUnionAliased!(S, 5)); //a5;
        static assert( isUnionAliased!(S.A5, 0)); //a5.b0;
        static assert( isUnionAliased!(S.A5, 1)); //a5.b1;
}

version (CRuntime_Glibc) version = GNU_STRERROR;
version (CRuntime_UClibc) version = GNU_STRERROR;

package string errnoString(int errno) nothrow @trusted
{
    import core.stdc.string : strlen;
    version (GNU_STRERROR)
    {
        import core.stdc.string : strerror_r;
        char[1024] buf = void;
        auto s = strerror_r(errno, buf.ptr, buf.length);
    }
    else version (Posix)
    {
        // XSI-compliant
        import core.stdc.string : strerror_r;
        char[1024] buf = void;
        const(char)* s;
        if (strerror_r(errno, buf.ptr, buf.length) == 0)
            s = buf.ptr;
        else
            return "Unknown error";
    }
    else
    {
        import core.stdc.string : strerror;
        auto s = strerror(errno);
    }
    return s[0 .. s.strlen].idup;
}

/*********************
 * Thrown if errors that set `errno` occur.
 */
class ErrnoException : Exception
{
    /// Operating system error code.
    final @property uint errno() nothrow pure scope @nogc @safe { return _errno; }
    private uint _errno;
    /// Localized error message generated through $(REF strerror_r, core,stdc,string) or $(REF strerror, core,stdc,string).
    final @property string errnoMsg() nothrow pure scope @nogc @safe { return _errnoMsg; }
    private string _errnoMsg;
    /// Constructor which takes an error message. The current global $(REF errno, core,stdc,errno) value is used as error code.
    this(string msg, string file = null, size_t line = 0) @safe
    {
        import core.stdc.errno : errno;
        this(msg, errno, file, line);
    }
    /// Constructor which takes an error message and error code.
    this(string msg, int errno, string file = null, size_t line = 0) @safe
    {
        _errno = errno;
        _errnoMsg = errnoString(errno);
        super(msg ~ " (" ~ errnoMsg ~ ")", file, line);
    }
}

///
@safe unittest
{
    import core.stdc.errno : EAGAIN;
    auto ex = new ErrnoException("oh no", EAGAIN);
    assert(ex.errno == EAGAIN);
}

/// errno is used by default if no explicit error code is provided
@safe unittest
{
    import core.stdc.errno : errno, EAGAIN;

    auto old = errno;
    scope(exit) errno = old;

    // fake that errno got set by the callee
    errno = EAGAIN;
    auto ex = new ErrnoException("oh no");
    assert(ex.errno == EAGAIN);
}

/++
    ML-style functional exception handling. Runs the supplied expression and
    returns its result. If the expression throws a `Throwable`, runs the
    supplied error handler instead and return its result. The error handler's
    type must be the same as the expression's type.

    Params:
        E            = The type of `Throwable`s to catch. Defaults to `Exception`
        T1           = The type of the expression.
        T2           = The return type of the error handler.
        expression   = The expression to run and return its result.
        errorHandler = The handler to run if the expression throwed.

    Returns:
        expression, if it does not throw. Otherwise, returns the result of
        errorHandler.
+/
//lazy version
CommonType!(T1, T2) ifThrown(E : Throwable = Exception, T1, T2)(lazy scope T1 expression, lazy scope T2 errorHandler)
{
    static assert(!is(typeof(return) == void),
        "The error handler's return value("
        ~ T2.stringof ~
        ") does not have a common type with the expression("
        ~ T1.stringof ~
        ")."
    );
    try
    {
        return expression();
    }
    catch (E)
    {
        return errorHandler();
    }
}

///ditto
//delegate version
CommonType!(T1, T2) ifThrown(E : Throwable, T1, T2)(lazy scope T1 expression, scope T2 delegate(E) errorHandler)
{
    static assert(!is(typeof(return) == void),
        "The error handler's return value("
        ~ T2.stringof ~
        ") does not have a common type with the expression("
        ~ T1.stringof ~
        ")."
    );
    try
    {
        return expression();
    }
    catch (E e)
    {
        return errorHandler(e);
    }
}

///ditto
//delegate version, general overload to catch any Exception
CommonType!(T1, T2) ifThrown(T1, T2)(lazy scope T1 expression, scope T2 delegate(Exception) errorHandler)
{
    static assert(!is(typeof(return) == void),
        "The error handler's return value("
        ~ T2.stringof ~
        ") does not have a common type with the expression("
        ~ T1.stringof ~
        ")."
    );
    try
    {
        return expression();
    }
    catch (Exception e)
    {
        return errorHandler(e);
    }
}

/// Revert to a default value upon an error:
@safe unittest
{
    import std.conv : to;
    assert("x".to!int.ifThrown(0) == 0);
}

/**
Chain multiple calls to ifThrown, each capturing errors from the
entire preceding expression.
*/
@safe unittest
{
    import std.conv : ConvException, to;
    string s = "true";
    assert(s.to!int.ifThrown(cast(int) s.to!double)
                   .ifThrown(cast(int) s.to!bool) == 1);

    s = "2.0";
    assert(s.to!int.ifThrown(cast(int) s.to!double)
                   .ifThrown(cast(int) s.to!bool) == 2);

    // Respond differently to different types of errors
    alias orFallback = (lazy a)  => a.ifThrown!ConvException("not a number")
                                     .ifThrown!Exception("number too small");

    assert(orFallback(enforce("x".to!int < 1).to!string) == "not a number");
    assert(orFallback(enforce("2".to!int < 1).to!string) == "number too small");
}

/**
The expression and the errorHandler must have a common type they can both
be implicitly casted to, and that type will be the type of the compound
expression.
*/
@safe unittest
{
    // null and new Object have a common type(Object).
    static assert(is(typeof(null.ifThrown(new Object())) == Object));
    static assert(is(typeof((new Object()).ifThrown(null)) == Object));

    // 1 and new Object do not have a common type.
    static assert(!__traits(compiles, 1.ifThrown(new Object())));
    static assert(!__traits(compiles, (new Object()).ifThrown(1)));
}

/// Use a lambda to get the thrown object.
@system unittest
{
    import std.format : format;
    assert("%s".format.ifThrown!Exception(e => e.classinfo.name) == "std.format.FormatException");
}

//Verify Examples
@system unittest
{
    import std.conv;
    import std.string;
    //Revert to a default value upon an error:
    assert("x".to!int().ifThrown(0) == 0);

    //Chaining multiple calls to ifThrown to attempt multiple things in a row:
    string s="true";
    assert(s.to!int().
            ifThrown(cast(int) s.to!double()).
            ifThrown(cast(int) s.to!bool())
            == 1);

    //Respond differently to different types of errors
    assert(enforce("x".to!int() < 1).to!string()
            .ifThrown!ConvException("not a number")
            .ifThrown!Exception("number too small")
            == "not a number");

    //null and new Object have a common type(Object).
    static assert(is(typeof(null.ifThrown(new Object())) == Object));
    static assert(is(typeof((new Object()).ifThrown(null)) == Object));

    //1 and new Object do not have a common type.
    static assert(!__traits(compiles, 1.ifThrown(new Object())));
    static assert(!__traits(compiles, (new Object()).ifThrown(1)));

    //Use a lambda to get the thrown object.
    assert("%s".format().ifThrown(e => e.classinfo.name) == "std.format.FormatException");
}

@system unittest
{
    import core.exception;
    import std.conv;
    import std.string;
    //Basic behaviour - all versions.
    assert("1".to!int().ifThrown(0) == 1);
    assert("x".to!int().ifThrown(0) == 0);
    assert("1".to!int().ifThrown!ConvException(0) == 1);
    assert("x".to!int().ifThrown!ConvException(0) == 0);
    assert("1".to!int().ifThrown(e=>0) == 1);
    assert("x".to!int().ifThrown(e=>0) == 0);
    static if (__traits(compiles, 0.ifThrown!Exception(e => 0))) //This will only work with a fix that was not yet pulled
    {
        assert("1".to!int().ifThrown!ConvException(e=>0) == 1);
        assert("x".to!int().ifThrown!ConvException(e=>0) == 0);
    }

    //Exceptions other than stated not caught.
    assert("x".to!int().ifThrown!StringException(0).collectException!ConvException() !is null);
    static if (__traits(compiles, 0.ifThrown!Exception(e => 0))) //This will only work with a fix that was not yet pulled
    {
        assert("x".to!int().ifThrown!StringException(e=>0).collectException!ConvException() !is null);
    }

    //Default does not include errors.
    int throwRangeError() { throw new RangeError; }
    assert(throwRangeError().ifThrown(0).collectException!RangeError() !is null);
    assert(throwRangeError().ifThrown(e=>0).collectException!RangeError() !is null);

    //Incompatible types are not accepted.
    static assert(!__traits(compiles, 1.ifThrown(new Object())));
    static assert(!__traits(compiles, (new Object()).ifThrown(1)));
    static assert(!__traits(compiles, 1.ifThrown(e=>new Object())));
    static assert(!__traits(compiles, (new Object()).ifThrown(e=>1)));
}

version (StdUnittest) package
void assertCTFEable(alias dg)()
{
    static assert({ cast(void) dg(); return true; }());
    cast(void) dg();
}

/** This `enum` is used to select the primitives of the range to handle by the
  $(LREF handle) range wrapper. The values of the `enum` can be `OR`'d to
  select multiple primitives to be handled.

  `RangePrimitive.access` is a shortcut for the access primitives; `front`,
  `back` and `opIndex`.

  `RangePrimitive.pop` is a shortcut for the mutating primitives;
  `popFront` and `popBack`.
 */
enum RangePrimitive
{
    front    = 0b00_0000_0001, ///
    back     = 0b00_0000_0010, /// Ditto
    popFront = 0b00_0000_0100, /// Ditto
    popBack  = 0b00_0000_1000, /// Ditto
    empty    = 0b00_0001_0000, /// Ditto
    save     = 0b00_0010_0000, /// Ditto
    length   = 0b00_0100_0000, /// Ditto
    opDollar = 0b00_1000_0000, /// Ditto
    opIndex  = 0b01_0000_0000, /// Ditto
    opSlice  = 0b10_0000_0000, /// Ditto
    access   = front | back | opIndex, /// Ditto
    pop      = popFront | popBack, /// Ditto
}

///
pure @safe unittest
{
    import std.algorithm.comparison : equal;
    import std.algorithm.iteration : map, splitter;
    import std.conv : to, ConvException;

    auto s = "12,1337z32,54,2,7,9,1z,6,8";

    // The next line composition will throw when iterated
    // as some elements of the input do not convert to integer
    auto r = s.splitter(',').map!(a => to!int(a));

    // Substitute 0 for cases of ConvException
    auto h = r.handle!(ConvException, RangePrimitive.front, (e, r) => 0);
    assert(h.equal([12, 0, 54, 2, 7, 9, 0, 6, 8]));
}

///
pure @safe unittest
{
    import std.algorithm.comparison : equal;
    import std.range : retro;
    import std.utf : UTFException;

    auto str = "hello\xFFworld"; // 0xFF is an invalid UTF-8 code unit

    auto handled = str.handle!(UTFException, RangePrimitive.access,
            (e, r) => ' '); // Replace invalid code points with spaces

    assert(handled.equal("hello world")); // `front` is handled,
    assert(handled.retro.equal("dlrow olleh")); // as well as `back`
}

/** Handle exceptions thrown from range primitives.

Use the $(LREF RangePrimitive) enum to specify which primitives to _handle.
Multiple range primitives can be handled at once by using the `OR` operator
or the pseudo-primitives `RangePrimitive.access` and `RangePrimitive.pop`.
All handled primitives must have return types or values compatible with the
user-supplied handler.

Params:
    E = The type of `Throwable` to _handle.
    primitivesToHandle = Set of range primitives to _handle.
    handler = The callable that is called when a handled primitive throws a
    `Throwable` of type `E`. The handler must accept arguments of
    the form $(D E, ref IRange) and its return value is used as the primitive's
    return value whenever `E` is thrown. For `opIndex`, the handler can
    optionally recieve a third argument; the index that caused the exception.
    input = The range to _handle.

Returns: A wrapper `struct` that preserves the range interface of `input`.

Note:
Infinite ranges with slicing support must return an instance of
$(REF Take, std,range) when sliced with a specific lower and upper
bound (see $(REF hasSlicing, std,range,primitives)); `handle` deals with
this by `take`ing 0 from the return value of the handler function and
returning that when an exception is caught.
*/
auto handle(E : Throwable, RangePrimitive primitivesToHandle, alias handler, Range)(Range input)
if (isInputRange!Range)
{
    static struct Handler
    {
        private Range range;

        static if (isForwardRange!Range)
        {
            @property typeof(this) save()
            {
                static if (primitivesToHandle & RangePrimitive.save)
                {
                    try
                    {
                        return typeof(this)(range.save);
                    }
                    catch (E exception)
                    {
                        return typeof(this)(handler(exception, this.range));
                    }
                }
                else
                    return typeof(this)(range.save);
            }
        }

        static if (isInfinite!Range)
        {
            enum bool empty = false;
        }
        else
        {
            @property bool empty()
            {
                static if (primitivesToHandle & RangePrimitive.empty)
                {
                    try
                    {
                        return this.range.empty;
                    }
                    catch (E exception)
                    {
                        return handler(exception, this.range);
                    }
                }
                else
                    return this.range.empty;
            }
        }

        @property auto ref front()
        {
            static if (primitivesToHandle & RangePrimitive.front)
            {
                try
                {
                    return this.range.front;
                }
                catch (E exception)
                {
                    return handler(exception, this.range);
                }
            }
            else
                return this.range.front;
        }

        void popFront()
        {
            static if (primitivesToHandle & RangePrimitive.popFront)
            {
                try
                {
                    this.range.popFront();
                }
                catch (E exception)
                {
                    handler(exception, this.range);
                }
            }
            else
                this.range.popFront();
        }

        static if (isBidirectionalRange!Range)
        {
            @property auto ref back()
            {
                static if (primitivesToHandle & RangePrimitive.back)
                {
                    try
                    {
                        return this.range.back;
                    }
                    catch (E exception)
                    {
                        return handler(exception, this.range);
                    }
                }
                else
                    return this.range.back;
            }

            void popBack()
            {
                static if (primitivesToHandle & RangePrimitive.popBack)
                {
                    try
                    {
                        this.range.popBack();
                    }
                    catch (E exception)
                    {
                        handler(exception, this.range);
                    }
                }
                else
                    this.range.popBack();
            }
        }

        static if (isRandomAccessRange!Range)
        {
            auto ref opIndex(size_t index)
            {
                static if (primitivesToHandle & RangePrimitive.opIndex)
                {
                    try
                    {
                        return this.range[index];
                    }
                    catch (E exception)
                    {
                        static if (__traits(compiles, handler(exception, this.range, index)))
                            return handler(exception, this.range, index);
                        else
                            return handler(exception, this.range);
                    }
                }
                else
                    return this.range[index];
            }
        }

        static if (hasLength!Range)
        {
            @property auto length()
            {
                static if (primitivesToHandle & RangePrimitive.length)
                {
                    try
                    {
                        return this.range.length;
                    }
                    catch (E exception)
                    {
                        return handler(exception, this.range);
                    }
                }
                else
                    return this.range.length;
            }
        }

        static if (hasSlicing!Range)
        {
            static if (hasLength!Range)
            {
                typeof(this) opSlice(size_t lower, size_t upper)
                {
                    static if (primitivesToHandle & RangePrimitive.opSlice)
                    {
                        try
                        {
                            return typeof(this)(this.range[lower .. upper]);
                        }
                        catch (E exception)
                        {
                            return typeof(this)(handler(exception, this.range));
                        }
                    }
                    else
                        return typeof(this)(this.range[lower .. upper]);
                }
            }
            else static if (is(typeof(Range.init[size_t.init .. $])))
            {
                import std.range : Take, takeExactly;
                static struct DollarToken {}
                enum opDollar = DollarToken.init;

                typeof(this) opSlice(size_t lower, DollarToken)
                {
                    static if (primitivesToHandle & RangePrimitive.opSlice)
                    {
                        try
                        {
                            return typeof(this)(this.range[lower .. $]);
                        }
                        catch (E exception)
                        {
                            return typeof(this)(handler(exception, this.range));
                        }
                    }
                    else
                        return typeof(this)(this.range[lower .. $]);
                }

                Take!Handler opSlice(size_t lower, size_t upper)
                {
                    static if (primitivesToHandle & RangePrimitive.opSlice)
                    {
                        try
                        {
                            return takeExactly(typeof(this)(this.range[lower .. $]), upper - 1);
                        }
                        catch (E exception)
                        {
                            return takeExactly(typeof(this)(handler(exception, this.range)), 0);
                        }
                    }
                    else
                        return takeExactly(typeof(this)(this.range[lower .. $]), upper - 1);
                }
            }
        }
    }

    return Handler(input);
}

///
pure @safe unittest
{
    import std.algorithm.comparison : equal;
    import std.algorithm.iteration : map, splitter;
    import std.conv : to, ConvException;

    auto s = "12,1337z32,54,2,7,9,1z,6,8";

    // The next line composition wil// Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/affix_allocator.d)
*/
module std.experimental.allocator.building_blocks.affix_allocator;

/**

Allocator that adds some extra data before (of type `Prefix`) and/or after
(of type `Suffix`) any allocation made with its parent allocator. This is
useful for uses where additional allocation-related information is needed, such
as mutexes, reference counts, or walls for debugging memory corruption errors.

If `Prefix` is not `void`, `Allocator` must guarantee an alignment at
least as large as `Prefix.alignof`.

Suffixes are slower to get at because of alignment rounding, so prefixes should
be preferred. However, small prefixes blunt the alignment so if a large
alignment with a small affix is needed, suffixes should be chosen.

The following methods are defined if `Allocator` defines them, and forward to it: `deallocateAll`, `empty`, `owns`.
 */
struct AffixAllocator(Allocator, Prefix, Suffix = void)
{
    import std.algorithm.comparison : min;
    import core.lifetime : emplace;
    import std.experimental.allocator : RCIAllocator, theAllocator;
    import std.experimental.allocator.common : stateSize, forwardToMember,
        roundUpToMultipleOf, alignedAt, alignDownTo, roundUpToMultipleOf,
        hasStaticallyKnownAlignment;
    import std.math.traits : isPowerOf2;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    static if (hasStaticallyKnownAlignment!Allocator)
    {
        static assert(
                !stateSize!Prefix || Allocator.alignment >= Prefix.alignof,
                "AffixAllocator does not work with allocators offering a smaller"
                ~ " alignment than the prefix alignment.");
    }
    static assert(alignment % Suffix.alignof == 0,
        "This restriction could be relaxed in the future.");

    /**
    If `Prefix` is `void`, the alignment is that of the parent. Otherwise, the alignment is the same as the `Prefix`'s alignment.
    */
    static if (hasStaticallyKnownAlignment!Allocator)
    {
        enum uint alignment = isPowerOf2(stateSize!Prefix)
            ? min(stateSize!Prefix, Allocator.alignment)
            : (stateSize!Prefix ? Prefix.alignof : Allocator.alignment);
    }
    else static if (is(Prefix == void))
    {
        enum uint alignment = platformAlignment;
    }
    else
    {
        enum uint alignment = Prefix.alignof;
    }

    /**
    If the parent allocator `Allocator` is stateful, an instance of it is
    stored as a member. Otherwise, `AffixAllocator` uses
    `Allocator.instance`. In either case, the name `_parent` is uniformly
    used for accessing the parent allocator.
    */
    static if (stateSize!Allocator)
    {
        Allocator _parent;
        static if (is(Allocator == RCIAllocator))
        {
            @nogc nothrow pure @safe
            Allocator parent()
            {
                static @nogc nothrow
                RCIAllocator wrapAllocatorObject()
                {
                    import std.experimental.allocator.gc_allocator : GCAllocator;
                    import std.experimental.allocator : allocatorObject;

                    return allocatorObject(GCAllocator.instance);
                }

                if (_parent.isNull)
                {
                    // If the `_parent` allocator is `null` we will assign
                    // an object that references the GC as the `parent`.
                    auto fn = (() @trusted =>
                            cast(RCIAllocator function() @nogc nothrow pure @safe)(&wrapAllocatorObject))();
                    _parent = fn();
                }

                // `RCIAllocator.alignment` currently doesn't have any attributes
                // so we must cast; throughout the allocators module, `alignment`
                // is defined as an `enum` for the existing allocators.
                // `alignment` should always be `@nogc nothrow pure @safe`; once
                // this is enforced by the interface we can remove the cast
                auto pureAlign = (() @trusted =>
                        cast(uint delegate() @nogc nothrow pure @safe)(&_parent.alignment))();
                assert(alignment <= pureAlign());
                return _parent;
            }
        }
        else
        {
            alias parent = _parent;
        }
    }
    else
    {
        alias parent = Allocator.instance;
    }

    private template Impl()
    {

        size_t goodAllocSize(size_t s)
        {
            import std.experimental.allocator.common : goodAllocSize;
            auto a = actualAllocationSize(s);
            return roundUpToMultipleOf(parent.goodAllocSize(a)
                    - stateSize!Prefix - stateSize!Suffix,
                this.alignment);
        }

        private size_t actualAllocationSize(size_t s) const
        {
            assert(s > 0);
            static if (!stateSize!Suffix)
            {
                return s + stateSize!Prefix;
            }
            else
            {
                return
                    roundUpToMultipleOf(s + stateSize!Prefix, Suffix.alignof)
                    + stateSize!Suffix;
            }
        }

        private void[] actualAllocation(void[] b) const
        {
            assert(b !is null);
            return (b.ptr - stateSize!Prefix)
                [0 .. actualAllocationSize(b.length)];
        }

        // Common code shared between allocate and allocateZeroed.
        private enum _processAndReturnAllocateResult =
        q{
            if (result is null) return null;
            static if (stateSize!Prefix)
            {
                assert(result.ptr.alignedAt(Prefix.alignof));
                emplace!Prefix(cast(Prefix*) result.ptr);
            }
            static if (stateSize!Suffix)
            {
                auto suffixP = result.ptr + result.length - Suffix.sizeof;
                assert(suffixP.alignedAt(Suffix.alignof));
                emplace!Suffix(cast(Suffix*)(suffixP));
            }
            return result[stateSize!Prefix .. stateSize!Prefix + bytes];
        };

        void[] allocate(size_t bytes)
        {
            if (!bytes) return null;
            auto result = parent.allocate(actualAllocationSize(bytes));
            mixin(_processAndReturnAllocateResult);
        }

        static if (hasMember!(Allocator, "allocateZeroed"))
        package(std) void[] allocateZeroed()(size_t bytes)
        {
            if (!bytes) return null;
            auto result = parent.allocateZeroed(actualAllocationSize(bytes));
            mixin(_processAndReturnAllocateResult);
        }

        static if (hasMember!(Allocator, "allocateAll"))
        void[] allocateAll()
        {
            auto result = parent.allocateAll();
            if (result is null) return null;
            if (result.length < actualAllocationSize(1))
            {
                deallocate(result);
                return null;
            }
            static if (stateSize!Prefix)
            {
                assert(result.length > stateSize!Prefix);
                emplace!Prefix(cast(Prefix*) result.ptr);
                result = result[stateSize!Prefix .. $];
            }
            static if (stateSize!Suffix)
            {
                assert(result.length > stateSize!Suffix);
                // Ehm, find a properly aligned place for the suffix
                auto p = (result.ptr + result.length - stateSize!Suffix)
                    .alignDownTo(Suffix.alignof);
                assert(p > result.ptr);
                emplace!Suffix(cast(Suffix*) p);
                result = result[0 .. p - result.ptr];
            }
            return result;
        }

        static if (hasMember!(Allocator, "owns"))
        Ternary owns(void[] b)
        {
            if (b is null) return Ternary.no;
            return parent.owns((() @trusted => actualAllocation(b))());
        }

        static if (hasMember!(Allocator, "resolveInternalPointer"))
        Ternary resolveInternalPointer(const void* p, ref void[] result)
        {
            void[] p1;
            Ternary r = parent.resolveInternalPointer(p, p1);
            if (r != Ternary.yes || p1 is null)
                return r;
            p1 = p1[stateSize!Prefix .. $];
            auto p2 = (() @trusted => (&p1[0] + p1.length - stateSize!Suffix)
                                      .alignDownTo(Suffix.alignof))();
            result = p1[0 .. p2 - &p1[0]];
            return Ternary.yes;
        }

        static if (!stateSize!Suffix && hasMember!(Allocator, "expand")
                    && hasMember!(Allocator, "owns"))
        bool expand(ref void[] b, size_t delta)
        {
            if (!b || delta == 0) return delta == 0;
            if (owns(b) == Ternary.no) return false;
            auto t = (() @trusted => actualAllocation(b))();
            const result = parent.expand(t, delta);
            if (!result) return false;
            b = (() @trusted => b.ptr[0 .. b.length + delta])();
            return true;
        }

        static if (hasMember!(Allocator, "reallocate"))
        bool reallocate(ref void[] b, size_t s)
        {
            if (b is null)
            {
                b = allocate(s);
                return b.length == s;
            }
            auto t = actualAllocation(b);
            const result = parent.reallocate(t, actualAllocationSize(s));
            if (!result) return false; // no harm done
            b = t.ptr[stateSize!Prefix .. stateSize!Prefix + s];
            return true;
        }

        static if (hasMember!(Allocator, "deallocate"))
        bool deallocate(void[] b)
        {
            if (!b.ptr) return true;
            return parent.deallocate(actualAllocation(b));
        }

        /* The following methods are defined if `ParentAllocator` defines
        them, and forward to it: `deallocateAll`, `empty`.*/
        mixin(forwardToMember("parent",
            "deallocateAll", "empty"));

        // Computes suffix type given buffer type
        private template Payload2Affix(Payload, Affix)
        {
            static if (is(Payload[] : void[]))
                alias Payload2Affix = Affix;
            else static if (is(Payload[] : shared(void)[]))
                alias Payload2Affix = shared Affix;
            else static if (is(Payload[] : immutable(void)[]))
                alias Payload2Affix = shared Affix;
            else static if (is(Payload[] : const(shared(void))[]))
                alias Payload2Affix = shared Affix;
            else static if (is(Payload[] : const(void)[]))
                alias Payload2Affix = const Affix;
            else
                static assert(0, "Internal error for type " ~ Payload.stringof);
        }

        // Extra functions
        static if (stateSize!Prefix)
        {
            static auto ref prefix(T)(T[] b)
            {
                assert(b.ptr && b.ptr.alignedAt(Prefix.alignof));
                return (cast(Payload2Affix!(T, Prefix)*) b.ptr)[-1];
            }
        }
        static if (stateSize!Suffix)
            auto ref suffix(T)(T[] b)
            {
                assert(b.ptr);
                auto p = b.ptr - stateSize!Prefix
                    + actualAllocationSize(b.length);
                assert(p && p.alignedAt(Suffix.alignof));
                return (cast(Payload2Affix!(T, Suffix)*) p)[-1];
            }
    }

    version (StdDdoc)
    {
        /**
        Standard allocator methods. Each is defined if and only if the parent
        allocator defines the homonym method (except for `goodAllocSize`,
        which may use the global default). Also, the methods will be $(D
        shared) if the parent allocator defines them as such.
        */
        size_t goodAllocSize(size_t);
        /// Ditto
        void[] allocate(size_t);
        /// Ditto
        Ternary owns(void[]);
        /// Ditto
        bool expand(ref void[] b, size_t delta);
        /// Ditto
        bool reallocate(ref void[] b, size_t s);
        /// Ditto
        bool deallocate(void[] b);
        /// Ditto
        bool deallocateAll();
        /// Ditto
        Ternary empty();

        /**
        The `instance` singleton is defined if and only if the parent allocator
        has no state and defines its own `it` object.
        */
        static AffixAllocator instance;

        /**
        Affix access functions offering references to the affixes of a
        block `b` previously allocated with this allocator. `b` may not be null.
        They are defined if and only if the corresponding affix is not `void`.

        The qualifiers of the affix are not always the same as the qualifiers
        of the argument. This is because the affixes are not part of the data
        itself, but instead are just $(I associated) with the data and known
        to the allocator. The table below documents the type of `preffix(b)` and
        `affix(b)` depending on the type of `b`.

        $(BOOKTABLE Result of `prefix`/`suffix` depending on argument (`U` is
        any unqualified type, `Affix` is `Prefix` or `Suffix`),
            $(TR $(TH Argument$(NBSP)Type) $(TH Return) $(TH Comments))

            $(TR $(TD `shared(U)[]`) $(TD `ref shared Affix`)
            $(TD Data is shared across threads and the affix follows suit.))

            $(TR $(TD `immutable(U)[]`) $(TD `ref shared Affix`)
            $(TD Although the data is immutable, the allocator "knows" the
            underlying memory is mutable, so `immutable` is elided for the affix
            which is independent from the data itself. However, the result is
            `shared` because `immutable` is implicitly shareable so multiple
            threads may access and manipulate the affix for the same data.))

            $(TR $(TD `const(shared(U))[]`) $(TD `ref shared Affix`)
            $(TD The data is always shareable across threads. Even if the data
            is `const`, the affix is modifiable by the same reasoning as for
            `immutable`.))

            $(TR $(TD `const(U)[]`) $(TD `ref const Affix`)
            $(TD The input may have originated from `U[]` or `immutable(U)[]`,
            so it may be actually shared or not. Returning an unqualified affix
            may result in race conditions, whereas returning a `shared` affix
            may result in inadvertent sharing of mutable thread-local data
            across multiple threads. So the returned type is conservatively
            `ref const`.))

            $(TR $(TD `U[]`) $(TD `ref Affix`)
            $(TD Unqualified data has unqualified affixes.))
        )

        Precondition: `b !is null` and `b` must have been allocated with
        this allocator.
        */
        static ref auto prefix(T)(T[] b);
        /// Ditto
        ref auto suffix(T)(T[] b);
    }
    else static if (is(typeof(Allocator.instance) == shared))
    {
        static assert(stateSize!Allocator == 0);
        static shared AffixAllocator instance;
        shared { mixin Impl!(); }
    }
    else static if (is(Allocator == shared))
    {
        static assert(stateSize!Allocator != 0);
        shared { mixin Impl!(); }
    }
    else
    {
        mixin Impl!();
        static if (stateSize!Allocator == 0)
            __gshared AffixAllocator instance;
    }
}

///
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    // One word before and after each allocation.
    alias A = AffixAllocator!(Mallocator, size_t, size_t);
    auto b = A.instance.allocate(11);
    A.instance.prefix(b) = 0xCAFE_BABE;
    A.instance.suffix(b) = 0xDEAD_BEEF;
    assert(A.instance.prefix(b) == 0xCAFE_BABE
        && A.instance.suffix(b) == 0xDEAD_BEEF);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator : theAllocator, RCIAllocator;

    // One word before and after each allocation.
    auto A = AffixAllocator!(RCIAllocator, size_t, size_t)(theAllocator);
    auto a = A.allocate(11);
    A.prefix(a) = 0xCAFE_BABE;
    A.suffix(a) = 0xDEAD_BEEF;
    assert(A.prefix(a) == 0xCAFE_BABE
        && A.suffix(a) == 0xDEAD_BEEF);

    // One word before and after each allocation.
    auto B = AffixAllocator!(RCIAllocator, size_t, size_t)();
    auto b = B.allocate(11);
    B.prefix(b) = 0xCAFE_BABE;
    B.suffix(b) = 0xDEAD_BEEF;
    assert(B.prefix(b) == 0xCAFE_BABE
        && B.suffix(b) == 0xDEAD_BEEF);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block
        : BitmappedBlock;
    import std.experimental.allocator.common : testAllocator;
    testAllocator!({
        auto a = AffixAllocator!(BitmappedBlock!128, ulong, ulong)
            (BitmappedBlock!128(new ubyte[128 * 4096]));
        return a;
    });
}

// Test empty
@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.typecons : Ternary;

    auto a = AffixAllocator!(BitmappedBlock!128, ulong, ulong)
                (BitmappedBlock!128(new ubyte[128 * 4096]));
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.no);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    alias A = AffixAllocator!(Mallocator, size_t);
    auto b = A.instance.allocate(10);
    A.instance.prefix(b) = 10;
    assert(A.instance.prefix(b) == 10);

    import std.experimental.allocator.building_blocks.null_allocator
        : NullAllocator;
    alias B = AffixAllocator!(NullAllocator, size_t);
    b = B.instance.allocate(100);
    assert(b is null);
}

@system unittest
{
    import std.experimental.allocator;
    import std.experimental.allocator.gc_allocator;
    import std.typecons : Ternary;
    alias MyAllocator = AffixAllocator!(GCAllocator, uint);
    auto a = MyAllocator.instance.makeArray!(shared int)(100);
    static assert(is(typeof(&MyAllocator.instance.prefix(a)) == shared(uint)*));
    auto b = MyAllocator.instance.makeArray!(shared const int)(100);
    static assert(is(typeof(&MyAllocator.instance.prefix(b)) == shared(uint)*));
    auto c = MyAllocator.instance.makeArray!(immutable int)(100);
    static assert(is(typeof(&MyAllocator.instance.prefix(c)) == shared(uint)*));
    auto d = MyAllocator.instance.makeArray!(int)(100);
    static assert(is(typeof(&MyAllocator.instance.prefix(d)) == uint*));
    auto e = MyAllocator.instance.makeArray!(const int)(100);
    static assert(is(typeof(&MyAllocator.instance.prefix(e)) == const(uint)*));

    void[] p;
    assert((() nothrow @safe @nogc => MyAllocator.instance.resolveInternalPointer(null, p))() == Ternary.no);
    assert((() nothrow @safe => MyAllocator.instance.resolveInternalPointer(&d[0], p))() == Ternary.yes);
    assert(p.ptr is d.ptr && p.length >= d.length);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator;
    alias a = AffixAllocator!(GCAllocator, uint).instance;

    // Check that goodAllocSize inherits from parent, i.e. GCAllocator
    assert(__traits(compiles, (() nothrow @safe @nogc => a.goodAllocSize(1))()));

    // Ensure deallocate inherits from parent
    auto b = a.allocate(42);
    assert(b.length == 42);
    () nothrow @nogc { a.deallocate(b); }();
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    auto a = AffixAllocator!(BorrowedRegion!(), uint)(BorrowedRegion!()(new ubyte[1024 * 64]));
    auto b = a.allocate(42);
    assert(b.length == 42);
    // Test that expand infers from parent
    assert((() pure nothrow @safe @nogc => a.expand(b, 58))());
    assert(b.length == 100);
    // Test that deallocateAll infers from parent
    assert((() nothrow @nogc => a.deallocateAll())());
}

// Test that reallocate infers from parent
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    alias a = AffixAllocator!(Mallocator, uint).instance;
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() nothrow @nogc => a.deallocate(b))());
}

@system unittest
{
    import std.experimental.allocator : processAllocator, RCISharedAllocator;
    import std.traits;

    alias SharedAllocT = shared AffixAllocator!(RCISharedAllocator, int);
    static assert(is(RCISharedAllocator == shared));
    static assert(!is(SharedAllocT.instance));

    SharedAllocT a = SharedAllocT(processAllocator);
    auto buf = a.allocate(10);
    static assert(is(typeof(a.allocate) == shared));
    assert(buf.length == 10);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // Written in the D programming language.
/**
`AlignedBlockList` represents a wrapper around a chain of allocators, allowing for fast deallocations
and preserving a low degree of fragmentation by means of aligned allocations.

Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/aligned_block_list.d)
*/
module std.experimental.allocator.building_blocks.aligned_block_list;

import std.experimental.allocator.common;
import std.experimental.allocator.building_blocks.null_allocator;

// Common function implementation for thread local and shared AlignedBlockList
private mixin template AlignedBlockListImpl(bool isShared)
{
    import std.traits : hasMember;
    import std.typecons : Ternary;

    static if (isShared)
    import core.internal.spinlock : SpinLock;

private:
    // Doubly linked list of 'AlignedBlockNode'
    // Each node contains an `Allocator` followed by its payload
    static struct AlignedBlockNode
    {
        AlignedBlockNode* next, prev;
        Allocator bAlloc;

        static if (isShared)
        {
            shared(size_t) bytesUsed;
            // Since the lock is not taken when allocating, this acts like a refcount
            // keeping the node alive
            uint keepAlive;
        }
        else
        {
            size_t bytesUsed;
        }
    }

    // Root of the internal doubly linked list
    AlignedBlockNode* root;

    // Number of active nodes
    uint numNodes;

    // If the numNodes exceeds this limit, we will start deallocating nodes
    enum uint maxNodes = 64;

    // This lock is always taken when changing the list
    // To improve performance, the lock is not taken when the allocation logic is called
    static if (isShared)
    SpinLock lock = SpinLock(SpinLock.Contention.brief);

    // Moves a node to the front of the list, allowing for quick allocations
    void moveToFront(AlignedBlockNode* tmp)
    {
        auto localRoot = cast(AlignedBlockNode*) root;
        if (tmp == localRoot)
            return;

        if (tmp.prev) tmp.prev.next = tmp.next;
        if (tmp.next) tmp.next.prev = tmp.prev;
        if (localRoot) localRoot.prev = tmp;
        tmp.next = localRoot;
        tmp.prev = null;

        root = cast(typeof(root)) tmp;
    }

    // Removes a node from the list, including its payload
    // The payload is deallocated by calling 'parent.deallocate'
    void removeNode(AlignedBlockNode* tmp)
    {
        auto next = tmp.next;
        if (tmp.prev) tmp.prev.next = tmp.next;
        if (tmp.next) tmp.next.prev = tmp.prev;
        parent.deallocate((cast(void*) tmp)[0 .. theAlignment]);

        if (tmp == cast(AlignedBlockNode*) root)
            root = cast(typeof(root)) next;

        static if (isShared)
        {
            import core.atomic : atomicOp;
            atomicOp!"-="(numNodes, 1);
        }
        else
        {
            numNodes--;
        }
    }

    // If the nodes do not have available space, a new node is created
    // by drawing memory from the parent allocator with aligned allocations.
    // The new node is inserted at the front of the list
    bool insertNewNode()
    {
        void[] buf = parent.alignedAllocate(theAlignment, theAlignment);
        if (buf is null)
            return false;

        auto localRoot = cast(AlignedBlockNode*) root;
        auto newNode = cast(AlignedBlockNode*) buf;

        // The first part of the allocation represent the node contents
        // followed by the actual payload
        ubyte[] payload = cast(ubyte[]) buf[AlignedBlockNode.sizeof .. $];
        newNode.bAlloc = Allocator(payload);

        newNode.next = localRoot;
        newNode.prev = null;
        if (localRoot)
            localRoot.prev = newNode;
        root = cast(typeof(root)) newNode;

        static if (isShared)
        {
            import core.atomic : atomicOp;
            atomicOp!"+="(numNodes, 1);
        }
        else
        {
            numNodes++;
        }

        return true;
    }

public:
    static if (stateSize!ParentAllocator) ParentAllocator parent;
    else alias parent = ParentAllocator.instance;

    enum ulong alignment = Allocator.alignment;

    // Since all memory is drawn from ParentAllocator, we can
    // forward this to the parent
    static if (hasMember!(ParentAllocator, "owns"))
    Ternary owns(void[] b)
    {
        return parent.owns(b);
    }

    // Use `theAlignment` to find the node which allocated this block
    bool deallocate(void[] b)
    {
        if (b is null)
            return true;

        // Round buffer to nearest `theAlignment` multiple to quickly find
        // the `parent` `AlignedBlockNode`
        enum ulong mask = ~(theAlignment - 1);
        ulong ptr = ((cast(ulong) b.ptr) & mask);
        AlignedBlockNode *node = cast(AlignedBlockNode*) ptr;
        if (node.bAlloc.deallocate(b))
        {
            static if (isShared)
            {
                import core.atomic : atomicOp;
                atomicOp!"-="(node.bytesUsed, b.length);
            }
            else
            {
                node.bytesUsed -= b.length;
            }
            return true;
        }
        return false;
    }

    // Allocate works only if memory can be provided via `alignedAllocate` from the parent
    static if (hasMember!(ParentAllocator, "alignedAllocate"))
    void[] allocate(size_t n)
    {
        static if (isShared)
        import core.atomic : atomicOp, atomicLoad;

        if (n == 0 || n > theAlignment)
            return null;

        static if (isShared)
        {
            lock.lock();
            scope(exit) lock.unlock();
        }

        auto tmp = cast(AlignedBlockNode*) root;

        // Iterate through list and find first node which has memory available
        while (tmp)
        {
            auto next = tmp.next;
            static if (isShared)
            {
                // Allocations can happen outside the lock
                // Make sure nobody deletes this node while using it
                tmp.keepAlive++;
                if (next) next.keepAlive++;
                lock.unlock();
            }

            auto result = tmp.bAlloc.allocate(n);
            if (result.length == n)
            {
                // Success
                static if (isShared)
                {
                    atomicOp!"+="(tmp.bytesUsed, n);
                    lock.lock();
                }
                else
                {
                    tmp.bytesUsed += n;
                }

                // Most likely this node has memory for more allocations
                // Move it to the front
                moveToFront(tmp);

                static if (isShared)
                {
                    tmp.keepAlive--;
                    if (next) next.keepAlive--;
                }

                return result;
            }

            // This node can now be removed if necessary
            static if (isShared)
            {
                lock.lock();
                tmp.keepAlive--;
                if (next) next.keepAlive--;
            }

            if (!next)
                break;

            tmp = next;
            next = tmp.next;

            // If there are too many nodes, free memory by removing empty nodes
            static if (isShared)
            {
                if (atomicLoad(numNodes) > maxNodes &&
                    atomicLoad(tmp.bytesUsed) == 0 &&
                    tmp.keepAlive == 0)
                {
                    removeNode(tmp);
                }
            }
            else
            {
                if (numNodes > maxNodes && tmp.bytesUsed == 0)
                {
                    removeNode(tmp);
                }
            }

            tmp = next;
        }

        // Cannot create new AlignedBlockNode. Most likely the ParentAllocator ran out of resources
        if (!insertNewNode())
            return null;

        tmp = cast(typeof(tmp)) root;
        void[] result = tmp.bAlloc.allocate(n);

        static if (isShared)
        {
            atomicOp!"+="(root.bytesUsed, result.length);
        }
        else
        {
            root.bytesUsed += result.length;
        }

        return result;
    }

    // goodAllocSize should not use state
    size_t goodAllocSize(const size_t n)
    {
        Allocator a = null;
        return a.goodAllocSize(n);
    }
}

/**
`AlignedBlockList` represents a wrapper around a chain of allocators, allowing for fast deallocations
and preserving a low degree of fragmentation.
The allocator holds internally a doubly linked list of `Allocator` objects, which will serve allocations
in a most-recently-used fashion. Most recent allocators used for `allocate` calls, will be
moved to the front of the list.

Although allocations are in theory served in linear searching time, `deallocate` calls take
$(BIGOH 1) time, by using aligned allocations. `ParentAllocator` must implement `alignedAllocate`
and it must be able to allocate `theAlignment` bytes at the same alignment. Each aligned allocation
done by `ParentAllocator` will contain metadata for an `Allocator`, followed by its payload.

Params:
    Allocator = the allocator which is used to manage each node; it must have a constructor which receives
        `ubyte[]` and it must not have any parent allocators, except for the `NullAllocator`
    ParentAllocator = each node draws memory from the parent allocator; it must support `alignedAllocate`
    theAlignment = alignment of each block and at the same time length of each node
*/
struct AlignedBlockList(Allocator, ParentAllocator, ulong theAlignment = (1 << 21))
{
    version (StdDdoc)
    {
        import std.typecons : Ternary;
        import std.traits : hasMember;

        /**
        Returns a chunk of memory of size `n`
        It finds the first node in the `AlignedBlockNode` list which has available memory,
        and moves it to the front of the list.

        All empty nodes which cannot return new memory, are removed from the list.

        Params:
            n = bytes to allocate
        Returns:
            A chunk of memory of the required length or `null` on failure or
        */
        static if (hasMember!(ParentAllocator, "alignedAllocate"))
        void[] allocate(size_t n);

        /**
        Deallocates the buffer `b` given as parameter. Deallocations take place in constant
        time, regardless of the number of nodes in the list. `b.ptr` is rounded down
        to the nearest multiple of the `alignment` to quickly find the corresponding
        `AlignedBlockNode`.

        Params:
            b = buffer candidate for deallocation
        Returns:
            `true` on success and `false` on failure
        */
        bool deallocate(void[] b);

        /**
        Returns `Ternary.yes` if the buffer belongs to the parent allocator and
        `Ternary.no` otherwise.

        Params:
            b = buffer tested if owned by this allocator
        Returns:
            `Ternary.yes` if owned by this allocator and `Ternary.no` otherwise
        */
        static if (hasMember!(ParentAllocator, "owns"))
        Ternary owns(void[] b);
    }
    else
    {
        import std.math.traits : isPowerOf2;
        static assert(isPowerOf2(alignment));
        mixin AlignedBlockListImpl!false;
    }
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.experimental.allocator.building_blocks.segregator : Segregator;
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.typecons : Ternary;

    /*
    In this example we use 'AlignedBlockList' in conjunction with other allocators
    in order to create a more complex allocator.

    The 'SuperAllocator' uses a 'Segregator' to distribute allocations to sub-allocators,
    based on the requested size.

    Each sub-allocator is represented by an 'AlignedBlockList' of 'BitmappedBlocks'.
    Each 'AlignedBlockList' draws memory from a root allocator which in this case is an 'AscendingPageAllocator'

    Such an allocator not only provides good performance, but also a low degree of memory fragmentation.
    */
    alias SuperAllocator = Segregator!(
        32,
        AlignedBlockList!(BitmappedBlock!32, AscendingPageAllocator*, 1 << 12),
        Segregator!(

        64,
        AlignedBlockList!(BitmappedBlock!64, AscendingPageAllocator*, 1 << 12),
        Segregator!(

        128,
        AlignedBlockList!(BitmappedBlock!128, AscendingPageAllocator*, 1 << 12),
        AscendingPageAllocator*
    )));

    SuperAllocator a;
    auto pageAlloc = AscendingPageAllocator(128 * 4096);

    // Set the parent allocator for all the sub allocators
    a.allocatorForSize!256 = &pageAlloc;
    a.allocatorForSize!128.parent = &pageAlloc;
    a.allocatorForSize!64.parent = &pageAlloc;
    a.allocatorForSize!32.parent = &pageAlloc;

    enum testNum = 10;
    void[][testNum] buf;

    // Allocations of size 32 will go to the first 'AlignedBlockList'
    foreach (j; 0 .. testNum)
    {
        buf[j] = a.allocate(32);
        assert(buf[j].length == 32);

        // This is owned by the first 'AlignedBlockList'
        assert(a.allocatorForSize!32.owns(buf[j]) == Ternary.yes);
    }

    // Free the memory
    foreach (j; 0 .. testNum)
        assert(a.deallocate(buf[j]));

    // Allocations of size 64 will go to the second 'AlignedBlockList'
    foreach (j; 0 .. testNum)
    {
        buf[j] = a.allocate(64);
        assert(buf[j].length == 64);

        // This is owned by the second 'AlignedBlockList'
        assert(a.allocatorForSize!64.owns(buf[j]) == Ternary.yes);
    }

    // Free the memory
    foreach (j; 0 .. testNum)
        assert(a.deallocate(buf[j]));

    // Allocations of size 128 will go to the third 'AlignedBlockList'
    foreach (j; 0 .. testNum)
    {
        buf[j] = a.allocate(128);
        assert(buf[j].length == 128);

        // This is owned by the third 'AlignedBlockList'
        assert(a.allocatorForSize!128.owns(buf[j]) == Ternary.yes);
    }

    // Free the memory
    foreach (j; 0 .. testNum)
        assert(a.deallocate(buf[j]));

    // Allocations which exceed 128, will go to the 'AscendingPageAllocator*'
    void[] b = a.allocate(256);
    assert(b.length == 256);
    a.deallocate(b);
}

/**
`SharedAlignedBlockList` is the threadsafe version of `AlignedBlockList`.
The `Allocator` template parameter must refer a shared allocator.
Also, `ParentAllocator` must be a shared allocator, supporting `alignedAllocate`.

Params:
    Allocator = the shared allocator which is used to manage each node; it must have a constructor which receives
        `ubyte[]` and it must not have any parent allocators, except for the `NullAllocator`
    ParentAllocator = each node draws memory from the parent allocator; it must be shared and support `alignedAllocate`
    theAlignment = alignment of each block and at the same time length of each node
*/
shared struct SharedAlignedBlockList(Allocator, ParentAllocator, ulong theAlignment = (1 << 21))
{
    version (StdDdoc)
    {
        import std.typecons : Ternary;
        import std.traits : hasMember;

        /**
        Returns a chunk of memory of size `n`
        It finds the first node in the `AlignedBlockNode` list which has available memory,
        and moves it to the front of the list.

        All empty nodes which cannot return new memory, are removed from the list.

        Params:
            n = bytes to allocate
        Returns:
            A chunk of memory of the required length or `null` on failure or
        */
        static if (hasMember!(ParentAllocator, "alignedAllocate"))
        void[] allocate(size_t n);

        /**
        Deallocates the buffer `b` given as parameter. Deallocations take place in constant
        time, regardless of the number of nodes in the list. `b.ptr` is rounded down
        to the nearest multiple of the `alignment` to quickly find the corresponding
        `AlignedBlockNode`.

        Params:
            b = buffer candidate for deallocation
        Returns:
            `true` on success and `false` on failure
        */
        bool deallocate(void[] b);

        /**
        Returns `Ternary.yes` if the buffer belongs to the parent allocator and
        `Ternary.no` otherwise.

        Params:
            b = buffer tested if owned by this allocator
        Returns:
            `Ternary.yes` if owned by this allocator and `Ternary.no` otherwise
        */
        static if (hasMember!(ParentAllocator, "owns"))
        Ternary owns(void[] b);
    }
    else
    {
        import std.math.traits : isPowerOf2;
        static assert(isPowerOf2(alignment));
        mixin AlignedBlockListImpl!true;
    }
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.region : SharedBorrowedRegion;
    import std.experimental.allocator.building_blocks.ascending_page_allocator : SharedAscendingPageAllocator;
    import std.experimental.allocator.building_blocks.null_allocator : NullAllocator;
    import core.thread : ThreadGroup;

    enum numThreads = 8;
    enum size = 2048;
    enum maxIter = 10;

    /*
    In this example we use 'SharedAlignedBlockList' together with
    'SharedBorrowedRegion', in order to create a fast, thread-safe allocator.
    */
    alias SuperAllocator = SharedAlignedBlockList!(
            SharedBorrowedRegion!(1),
            SharedAscendingPageAllocator,
            4096);

    SuperAllocator a;
    // The 'SuperAllocator' will draw memory from a 'SharedAscendingPageAllocator'
    a.parent = SharedAscendingPageAllocator(4096 * 1024);

    // Launch 'numThreads', each performing allocations
    void fun()
    {
        foreach (i; 0 .. maxIter)
        {
            void[] b = a.allocate(size);
            assert(b.length == size);
        }
    }

    auto tg = new ThreadGroup;
    foreach (i; 0 .. numThreads)
    {
        tg.create(&fun);
    }
    tg.joinAll();
}

version (StdUnittest)
{
    static void testrw(void[] b)
    {
        ubyte* buf = cast(ubyte*) b.ptr;
        size_t len = (b.length).roundUpToMultipleOf(4096);
        for (int i = 0; i < len; i += 4096)
        {
            buf[i] =  (cast(ubyte) i % 256);
            assert(buf[i] == (cast(ubyte) i % 256));
        }
    }
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region;
    import std.experimental.allocator.building_blocks.ascending_page_allocator;
    import std.random;
    import std.algorithm.sorting : sort;
    import core.thread : ThreadGroup;
    import core.internal.spinlock : SpinLock;

    enum pageSize = 4096;
    enum numThreads = 10;
    enum maxIter = 20;
    enum totalAllocs = maxIter * numThreads;
    size_t count = 0;
    SpinLock lock = SpinLock(SpinLock.Contention.brief);

    alias SuperAllocator = SharedAlignedBlockList!(
            SharedBorrowedRegion!(1),
            SharedAscendingPageAllocator,
            1 << 16);
    void[][totalAllocs] buf;

    SuperAllocator a;
    a.parent = SharedAscendingPageAllocator(4096 * 1024);

    void fun()
    {
        auto rnd = Random(1000);

        foreach (i; 0 .. maxIter)
        {
            auto size = uniform(1, pageSize + 1, rnd);
            void[] b = a.allocate(size);
            assert(b.length == size);
            testrw(b);

            lock.lock();
            buf[count++] = b;
            lock.unlock();
        }
    }
    auto tg = new ThreadGroup;
    foreach (i; 0 .. numThreads)
    {
        tg.create(&fun);
    }
    tg.joinAll();

    sort!((a, b) => a.ptr < b.ptr)(buf[0 .. totalAllocs]);
    foreach (i; 0 .. totalAllocs - 1)
    {
        assert(buf[i].ptr + a.goodAllocSize(buf[i].length) <= buf[i + 1].ptr);
    }

    foreach (i; 0 .. totalAllocs)
    {
        assert(a.deallocate(buf[totalAllocs - 1 - i]));
    }
}

@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.experimental.allocator.building_blocks.segregator : Segregator;
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.random;

    alias SuperAllocator = Segregator!(
        256,
        AlignedBlockList!(BitmappedBlock!256, AscendingPageAllocator*, 1 << 16),
        Segregator!(

        512,
        AlignedBlockList!(BitmappedBlock!512, AscendingPageAllocator*, 1 << 16),
        Segregator!(

        1024,
        AlignedBlockList!(BitmappedBlock!1024, AscendingPageAllocator*, 1 << 16),
        Segregator!(

        2048,
        AlignedBlockList!(BitmappedBlock!2048, AscendingPageAllocator*, 1 << 16),
        AscendingPageAllocator*
    ))));

    SuperAllocator a;
    auto pageAlloc = AscendingPageAllocator(4096 * 4096);
    a.allocatorForSize!4096 = &pageAlloc;
    a.allocatorForSize!2048.parent = &pageAlloc;
    a.allocatorForSize!1024.parent = &pageAlloc;
    a.allocatorForSize!512.parent = &pageAlloc;
    a.allocatorForSize!256.parent = &pageAlloc;

    auto rnd = Random(1000);

    size_t maxIter = 10;
    enum testNum = 10;
    void[][testNum] buf;
    int maxSize = 8192;
    foreach (i; 0 .. maxIter)
    {
        foreach (j; 0 .. testNum)
        {
            auto size = uniform(1, maxSize + 1, rnd);
            buf[j] = a.allocate(size);
            assert(buf[j].length == size);
            testrw(buf[j]);
        }

        randomShuffle(buf[]);

        foreach (j; 0 .. testNum)
        {
            assert(a.deallocate(buf[j]));
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/allocator_list.d)
*/
module std.experimental.allocator.building_blocks.allocator_list;

import core.memory : pageSize;

import std.experimental.allocator.building_blocks.null_allocator;
import std.experimental.allocator.common;
import std.experimental.allocator.gc_allocator;

// Turn this on for debugging
// debug = allocator_list;

/**

Given an $(LINK2 https://en.wikipedia.org/wiki/Factory_(object-oriented_programming),
object factory) of type `Factory` or a factory function
`factoryFunction`, and optionally also `BookkeepingAllocator` as a supplemental
allocator for bookkeeping, `AllocatorList` creates an allocator that lazily
creates as many allocators are needed for satisfying client allocation requests.

An embedded list builds a most-recently-used strategy: the most recent
allocators used in calls to either `allocate`, `owns` (successful calls
only), or `deallocate` are tried for new allocations in order of their most
recent use. Thus, although core operations take in theory $(BIGOH k) time for
`k` allocators in current use, in many workloads the factor is sublinear.
Details of the actual strategy may change in future releases.

`AllocatorList` is primarily intended for coarse-grained handling of
allocators, i.e. the number of allocators in the list is expected to be
relatively small compared to the number of allocations handled by each
allocator. However, the per-allocator overhead is small so using
`AllocatorList` with a large number of allocators should be satisfactory as long
as the most-recently-used strategy is fast enough for the application.

`AllocatorList` makes an effort to return allocated memory back when no
longer used. It does so by destroying empty allocators. However, in order to
avoid thrashing (excessive creation/destruction of allocators under certain use
patterns), it keeps unused allocators for a while.

Params:
factoryFunction = A function or template function (including function literals).
New allocators are created by calling `factoryFunction(n)` with strictly
positive numbers `n`. Delegates that capture their enviroment are not created
amid concerns regarding garbage creation for the environment. When the factory
needs state, a `Factory` object should be used.

BookkeepingAllocator = Allocator used for storing bookkeeping data. The size of
bookkeeping data is proportional to the number of allocators. If $(D
BookkeepingAllocator) is `NullAllocator`, then `AllocatorList` is
"ouroboros-style", i.e. it keeps the bookkeeping data in memory obtained from
the allocators themselves. Note that for ouroboros-style management, the size
`n` passed to `make` will be occasionally different from the size
requested by client code.

Factory = Type of a factory object that returns new allocators on a need
basis. For an object `sweatshop` of type `Factory`, `sweatshop(n)` should
return an allocator able to allocate at least `n` bytes (i.e. `Factory` must
define `opCall(size_t)` to return an allocator object). Usually the capacity of
allocators created should be much larger than `n` such that an allocator can
be used for many subsequent allocations. `n` is passed only to ensure the
minimum necessary for the next allocation. The factory object is allowed to hold
state, which will be stored inside `AllocatorList` as a direct `public` member
called `factory`.

*/
struct AllocatorList(Factory, BookkeepingAllocator = GCAllocator)
{
    import core.lifetime : emplace;
    import std.experimental.allocator.building_blocks.stats_collector
        : StatsCollector, Options;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    private enum ouroboros = is(BookkeepingAllocator == NullAllocator);

    /**
    Alias for `typeof(Factory()(1))`, i.e. the type of the individual
    allocators.
    */
    alias Allocator = typeof(Factory.init(1));
    // Allocator used internally
    private alias SAllocator = StatsCollector!(Allocator, Options.bytesUsed);

    private static struct Node
    {
        // Allocator in this node
        SAllocator a;
        Node* next;

        @disable this(this);

        // Is this node unused?
        void setUnused() { next = &this; }
        bool unused() const { return next is &this; }

        // Just forward everything to the allocator
        alias a this;
    }

    /**
    If `BookkeepingAllocator` is not `NullAllocator`, `bkalloc` is
    defined and accessible.
    */

    // State is stored in an array, but it has a list threaded through it by
    // means of "nextIdx".

    // state
    static if (!ouroboros)
    {
        static if (stateSize!BookkeepingAllocator) BookkeepingAllocator bkalloc;
        else alias bkalloc = BookkeepingAllocator.instance;
    }
    static if (stateSize!Factory)
    {
        Factory factory;
    }
    private Node[] allocators;
    private Node* root;

    static if (stateSize!Factory)
    {
        private auto make(size_t n) { return factory(n); }
    }
    else
    {
        private auto make(size_t n) { Factory f; return f(n); }
    }

    /**
    Constructs an `AllocatorList` given a factory object. This constructor is
    defined only if `Factory` has state.
    */
    static if (stateSize!Factory)
    this(ref Factory plant)
    {
        factory = plant;
    }
    /// Ditto
    static if (stateSize!Factory)
    this(Factory plant)
    {
        factory = plant;
    }

    static if (hasMember!(Allocator, "deallocateAll")
        && hasMember!(Allocator, "owns"))
    ~this()
    {
        deallocateAll;
    }

    /**
    The alignment offered.
    */
    enum uint alignment = Allocator.alignment;

    /**
    Allocate a block of size `s`. First tries to allocate from the existing
    list of already-created allocators. If neither can satisfy the request,
    creates a new allocator by calling `make(s)` and delegates the request
    to it. However, if the allocation fresh off a newly created allocator
    fails, subsequent calls to `allocate` will not cause more calls to $(D
    make).
    */
    void[] allocate(size_t s)
    {
        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            auto result = n.allocate(s);
            if (result.length != s) continue;
            // Bring to front if not already
            if (root != n)
            {
                *p = n.next;
                n.next = root;
                root = n;
            }
            return result;
        }

        // Add a new allocator
        if (auto a = addAllocator(s))
        {
            auto result = a.allocate(s);
            assert(owns(result) == Ternary.yes || !result.ptr);
            return result;
        }
        return null;
    }

    static if (hasMember!(Allocator, "allocateZeroed"))
    package(std) void[] allocateZeroed()(size_t s)
    {
        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            auto result = n.allocateZeroed(s);
            if (result.length != s) continue;
            // Bring to front if not already
            if (root != n)
            {
                *p = n.next;
                n.next = root;
                root = n;
            }
            return result;
        }

        // Add a new allocator
        if (auto a = addAllocator(s))
        {
            auto result = a.allocateZeroed(s);
            assert(owns(result) == Ternary.yes || !result.ptr);
            return result;
        }
        return null;
    }

    /**
    Allocate a block of size `s` with alignment `a`. First tries to allocate
    from the existing list of already-created allocators. If neither can
    satisfy the request, creates a new allocator by calling `make(s + a - 1)`
    and delegates the request to it. However, if the allocation fresh off a
    newly created allocator fails, subsequent calls to `alignedAllocate`
    will not cause more calls to `make`.
    */
    static if (hasMember!(Allocator, "alignedAllocate"))
    void[] alignedAllocate(size_t s, uint theAlignment)
    {
        import std.algorithm.comparison : max;
        import core.checkedint : addu;

        if (theAlignment == 0 || s == 0)
            return null;

        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            auto result = n.alignedAllocate(s, theAlignment);
            if (result.length != s) continue;
            // Bring to front if not already
            if (root != n)
            {
                *p = n.next;
                n.next = root;
                root = n;
            }
            return result;
        }

        bool overflow = false;
        size_t maxSize = addu(s - 1, cast(size_t) theAlignment, overflow);
        assert(!overflow, "Requested size is too large");
        if (overflow)
            return null;

        // Add a new allocator
        if (auto a = addAllocator(maxSize))
        {
            auto result = a.alignedAllocate(s, theAlignment);
            assert(owns(result) == Ternary.yes || !result.ptr);
            return result;
        }
        return null;
    }

    private void moveAllocators(void[] newPlace)
    {
        assert(newPlace.ptr.alignedAt(Node.alignof));
        assert(newPlace.length % Node.sizeof == 0);
        auto newAllocators = cast(Node[]) newPlace;
        assert(allocators.length <= newAllocators.length);

        // Move allocators
        foreach (i, ref e; allocators)
        {
            if (e.unused)
            {
                newAllocators[i].setUnused;
                continue;
            }
            import core.stdc.string : memcpy;
            memcpy(&newAllocators[i].a, &e.a, e.a.sizeof);
            if (e.next)
            {
                newAllocators[i].next = newAllocators.ptr
                    + (e.next - allocators.ptr);
            }
            else
            {
                newAllocators[i].next = null;
            }
        }

        // Mark the unused portion as unused
        foreach (i; allocators.length .. newAllocators.length)
        {
            newAllocators[i].setUnused;
        }
        auto toFree = allocators;

        // Change state
        root = newAllocators.ptr + (root - allocators.ptr);
        allocators = newAllocators;

        // Free the olden buffer
        static if (ouroboros)
        {
            static if (hasMember!(Allocator, "deallocate")
                    && hasMember!(Allocator, "owns"))
                deallocate(toFree);
        }
        else
        {
            bkalloc.deallocate(toFree);
        }
    }

    static if (ouroboros)
    private Node* addAllocator(size_t atLeastBytes)
    {
        void[] t = allocators;
        static if (hasMember!(Allocator, "expand")
            && hasMember!(Allocator, "owns"))
        {
            immutable bool expanded = t && this.expand(t, Node.sizeof);
        }
        else
        {
            enum expanded = false;
        }
        if (expanded)
        {
            import core.stdc.string : memcpy;
            assert(t.length % Node.sizeof == 0);
            assert(t.ptr.alignedAt(Node.alignof));
            allocators = cast(Node[]) t;
            allocators[$ - 1].setUnused;
            auto newAlloc = SAllocator(make(atLeastBytes));
            memcpy(&allocators[$ - 1].a, &newAlloc, newAlloc.sizeof);
            emplace(&newAlloc);
        }
        else
        {
            immutable toAlloc = (allocators.length + 1) * Node.sizeof
                + atLeastBytes + 128;
            auto newAlloc = SAllocator(make(toAlloc));
            auto newPlace = newAlloc.allocate(
                (allocators.length + 1) * Node.sizeof);
            if (!newPlace) return null;
            moveAllocators(newPlace);
            import core.stdc.string : memcpy;
            memcpy(&allocators[$ - 1].a, &newAlloc, newAlloc.sizeof);
            emplace(&newAlloc);
            assert(allocators[$ - 1].owns(allocators) == Ternary.yes);
        }
        // Insert as new root
        if (root != &allocators[$ - 1])
        {
            allocators[$ - 1].next = root;
            root = &allocators[$ - 1];
        }
        else
        {
            // This is the first one
            root.next = null;
        }
        assert(!root.unused);
        return root;
    }

    static if (!ouroboros)
    private Node* addAllocator(size_t atLeastBytes)
    {
        void[] t = allocators;
        static if (hasMember!(BookkeepingAllocator, "expand"))
            immutable bool expanded = bkalloc.expand(t, Node.sizeof);
        else
            immutable bool expanded = false;
        if (expanded)
        {
            assert(t.length % Node.sizeof == 0);
            assert(t.ptr.alignedAt(Node.alignof));
            allocators = cast(Node[]) t;
            allocators[$ - 1].setUnused;
        }
        else
        {
            // Could not expand, create a new block
            t = bkalloc.allocate((allocators.length + 1) * Node.sizeof);
            assert(t.length % Node.sizeof == 0);
            if (!t.ptr) return null;
            moveAllocators(t);
        }
        assert(allocators[$ - 1].unused);
        auto newAlloc = SAllocator(make(atLeastBytes));
        import core.stdc.string : memcpy;
        memcpy(&allocators[$ - 1].a, &newAlloc, newAlloc.sizeof);
        emplace(&newAlloc);
        // Creation succeeded, insert as root
        if (allocators.length == 1)
            allocators[$ - 1].next = null;
        else
            allocators[$ - 1].next = root;
        assert(allocators[$ - 1].a.bytesUsed == 0);
        root = &allocators[$ - 1];
        return root;
    }

    /**
    Defined only if `Allocator` defines `owns`. Tries each allocator in
    turn, in most-recently-used order. If the owner is found, it is moved to
    the front of the list as a side effect under the assumption it will be used
    soon.

    Returns: `Ternary.yes` if one allocator was found to return `Ternary.yes`,
    `Ternary.no` if all component allocators returned `Ternary.no`, and
    `Ternary.unknown` if no allocator returned `Ternary.yes` and at least one
    returned  `Ternary.unknown`.
    */
    static if (hasMember!(Allocator, "owns"))
    Ternary owns(void[] b)
    {
        auto result = Ternary.no;
        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            immutable t = n.owns(b);
            if (t != Ternary.yes)
            {
                if (t == Ternary.unknown) result = t;
                continue;
            }
            // Move the owner to front, speculating it'll be used
            if (n != root)
            {
                *p = n.next;
                n.next = root;
                root = n;
            }
            return Ternary.yes;
        }
        return result;
    }

    /**
    Defined only if `Allocator.expand` is defined. Finds the owner of `b`
    and calls `expand` for it. The owner is not brought to the head of the
    list.
    */
    static if (hasMember!(Allocator, "expand")
        && hasMember!(Allocator, "owns"))
    bool expand(ref void[] b, size_t delta)
    {
        if (!b) return delta == 0;
        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            if (n.owns(b) == Ternary.yes) return n.expand(b, delta);
        }
        return false;
    }

    /**
    Defined only if `Allocator.reallocate` is defined. Finds the owner of
    `b` and calls `reallocate` for it. If that fails, calls the global
    `reallocate`, which allocates a new block and moves memory.
    */
    static if (hasMember!(Allocator, "reallocate"))
    bool reallocate(ref void[] b, size_t s)
    {
        // First attempt to reallocate within the existing node
        if (!b.ptr)
        {
            b = allocate(s);
            return b.length == s;
        }
        for (auto p = &root, n = *p; n; p = &n.next, n = *p)
        {
            if (n.owns(b) == Ternary.yes) return n.reallocate(b, s);
        }
        // Failed, but we may find new memory in a new node.
        return .reallocate(this, b, s);
    }

    /**
     Defined if `Allocator.deallocate` and `Allocator.owns` are defined.
    */
    static if (hasMember!(Allocator, "deallocate")
        && hasMember!(Allocator, "owns"))
    bool deallocate(void[] b)
    {
        if (!b.ptr) return true;
        assert(allocators.length);
        assert(owns(b) == Ternary.yes);
        bool result;
        for (auto p = &root, n = *p; ; p = &n.next, n = *p)
        {
            assert(n);
            if (n.owns(b) != Ternary.yes) continue;
            result = n.deallocate(b);
            // Bring to front
            if (n != root)
            {
                *p = n.next;
                n.next = root;
                root = n;
            }
            if (n.empty != Ternary.yes) return result;
            break;
        }
        // Hmmm... should we return this allocator back to the wild? Let's
        // decide if there are TWO empty allocators we can release ONE. This
        // is to avoid thrashing.
        // Note that loop starts from the second element.
        for (auto p = &root.next, n = *p; n; p = &n.next, n = *p)
        {
            if (n.unused || n.empty != Ternary.yes) continue;
            // Used and empty baby, nuke it!
            n.a.destroy;
            *p = n.next;
            n.setUnused;
            break;
        }
        return result;
    }

    /**
    Defined only if `Allocator.owns` and `Allocator.deallocateAll` are
    defined.
    */
    static if (ouroboros && hasMember!(Allocator, "deallocateAll")
        && hasMember!(Allocator, "owns"))
    bool deallocateAll()
    {
        Node* special;
        foreach (ref n; allocators)
        {
            if (n.unused) continue;
            if (n.owns(allocators) == Ternary.yes)
            {
                special = &n;
                continue;
            }
            n.a.deallocateAll;
            n.a.destroy;
        }
        assert(special || !allocators.ptr);
        if (special)
        {
            static if (stateSize!SAllocator)
            {
                import core.stdc.string : memcpy;
                SAllocator specialCopy;
                assert(special.a.sizeof == specialCopy.sizeof);
                memcpy(&specialCopy, &special.a, specialCopy.sizeof);
                emplace(&special.a);
                specialCopy.deallocateAll();
            }
            else
            {
                special.deallocateAll();
            }
        }
        allocators = null;
        root = null;
        return true;
    }

    static if (!ouroboros && hasMember!(Allocator, "deallocateAll")
        && hasMember!(Allocator, "owns"))
    bool deallocateAll()
    {
        foreach (ref n; allocators)
        {
            if (n.unused) continue;
            n.a.deallocateAll;
            n.a.destroy;
        }
        bkalloc.deallocate(allocators);
        allocators = null;
        root = null;
        return true;
    }

    /**
     Returns `Ternary.yes` if no allocators are currently active,
    `Ternary.no` otherwise. This methods never returns `Ternary.unknown`.
    */
    pure nothrow @safe @nogc
    Ternary empty() const
    {
        return Ternary(!allocators.length);
    }
}

/// Ditto
template AllocatorList(alias factoryFunction,
    BookkeepingAllocator = GCAllocator)
{
    alias A = typeof(factoryFunction(1));
    static assert(
        // is a template function (including literals)
        is(typeof({A function(size_t) @system x = factoryFunction!size_t;}))
        ||
        // or a function (including literals)
        is(typeof({A function(size_t) @system x = factoryFunction;}))
        ,
        "Only function names and function literals that take size_t"
            ~ " and return an allocator are accepted, not "
            ~ typeof(factoryFunction).stringof
    );
    static struct Factory
    {
        A opCall(size_t n) { return factoryFunction(n); }
    }
    alias AllocatorList = .AllocatorList!(Factory, BookkeepingAllocator);
}

///
version (Posix) @system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.free_list : ContiguousFreeList;
    import std.experimental.allocator.building_blocks.null_allocator : NullAllocator;
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.building_blocks.segregator : Segregator;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mmap_allocator : MmapAllocator;

    // Ouroboros allocator list based upon 4MB regions, fetched directly from
    // mmap. All memory is released upon destruction.
    alias A1 = AllocatorList!((n) => Region!MmapAllocator(max(n, 1024 * 4096)),
        NullAllocator);

    // Allocator list based upon 4MB regions, fetched from the garbage
    // collector. All memory is released upon destruction.
    alias A2 = AllocatorList!((n) => Region!GCAllocator(max(n, 1024 * 4096)));

    // Ouroboros allocator list based upon 4MB regions, fetched from the garbage
    // collector. Memory is left to the collector.
    alias A3 = AllocatorList!(
        (n) => Region!NullAllocator(new ubyte[max(n, 1024 * 4096)]),
        NullAllocator);

    // Allocator list that creates one freelist for all objects
    alias A4 =
        Segregator!(
            64, AllocatorList!(
                (n) => ContiguousFreeList!(NullAllocator, 0, 64)(
                    cast(ubyte[])(GCAllocator.instance.allocate(4096)))),
            GCAllocator);

    A4 a;
    auto small = a.allocate(64);
    assert(small);
    a.deallocate(small);
    auto b1 = a.allocate(1024 * 8192);
    assert(b1 !is null); // still works due to overdimensioning
    b1 = a.allocate(1024 * 10);
    assert(b1.length == 1024 * 10);
}

@system unittest
{
    // Create an allocator based upon 4MB regions, fetched from the GC heap.
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : Region;
    AllocatorList!((n) => Region!GCAllocator(new ubyte[max(n, 1024 * 4096)]),
        NullAllocator) a;
    const b1 = a.allocate(1024 * 8192);
    assert(b1 !is null); // still works due to overdimensioning
    const b2 = a.allocate(1024 * 10);
    assert(b2.length == 1024 * 10);
    a.deallocateAll();
}

@system unittest
{
    // Create an allocator based upon 4MB regions, fetched from the GC heap.
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;
    auto b1 = a.alignedAllocate(1024 * 8192, 1024);
    assert(b1 !is null); // still works due to overdimensioning
    assert(b1.length == 1024 * 8192);
    assert(b1.ptr.alignedAt(1024));
    assert(a.allocators.length == 1);

    b1 = a.alignedAllocate(0, 1024);
    assert(b1.length == 0);
    assert(a.allocators.length == 1);

    b1 = a.allocate(1024 * 10);
    assert(b1.length == 1024 * 10);

    assert(a.reallocate(b1, 1024));
    assert(b1.length == 1024);

    a.deallocateAll();
}

@system unittest
{
    import core.exception : AssertError;
    import std.exception : assertThrown;

    // Create an allocator based upon 4MB regions, fetched from the GC heap.
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;
    auto b1 = a.alignedAllocate(0, 1);
    assert(b1 is null);

    b1 = a.alignedAllocate(1, 0);
    assert(b1 is null);

    b1 = a.alignedAllocate(0, 0);
    assert(b1 is null);

    assertThrown!AssertError(a.alignedAllocate(size_t.max, 1024));
    a.deallocateAll();
}

@system unittest
{
    import std.typecons : Ternary;

    // Create an allocator based upon 4MB regions, fetched from the GC heap.
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;
    auto b0 = a.alignedAllocate(1, 1024);
    assert(b0.length == 1);
    assert(b0.ptr.alignedAt(1024));
    assert(a.allocators.length == 1);

    auto b1 = a.alignedAllocate(1024 * 4096, 1024);
    assert(b1.length == 1024 * 4096);
    assert(b1.ptr.alignedAt(1024));
    assert(a.allocators.length == 2);

    auto b2 = a.alignedAllocate(1024, 128);
    assert(b2.length == 1024);
    assert(b2.ptr.alignedAt(128));
    assert(a.allocators.length == 2);

    auto b3 = a.allocate(1024);
    assert(b3.length == 1024);
    assert(a.allocators.length == 2);

    auto b4 = a.allocate(1024 * 4096);
    assert(b4.length == 1024 * 4096);
    assert(a.allocators.length == 3);

    assert(a.root.empty == Ternary.no);
    assert(a.deallocate(b4));
    assert(a.root.empty == Ternary.yes);

    assert(a.deallocate(b1));
    a.deallocateAll();
}

@system unittest
{
    // Create an allocator based upon 4MB regions, fetched from the GC heap.
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)])) a;
    auto b1 = a.allocate(1024 * 8192);
    assert(b1 !is null); // still works due to overdimensioning
    b1 = a.allocate(1024 * 10);
    assert(b1.length == 1024 * 10);
    assert(a.reallocate(b1, 1024));
    assert(b1.length == 1024);
    a.deallocateAll();
}

@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    AllocatorList!((n) => BorrowedRegion!()(new ubyte[max(n, 1024 * 4096)]), Mallocator) a;
    auto b1 = a.allocate(1024 * 8192);
    assert(b1 !is null);
    b1 = a.allocate(1024 * 10);
    assert(b1.length == 1024 * 10);
    assert((() pure nothrow @safe @nogc => a.expand(b1, 10))());
    assert(b1.length == 1025 * 10);
    a.allocate(1024 * 4095);
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.no);
    // Ensure deallocateAll infers from parent
    assert((() nothrow @nogc => a.deallocateAll())());
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    enum bs = GCAllocator.alignment;
    AllocatorList!((n) => Region!GCAllocator(256 * bs)) a;
    auto b1 = a.allocate(192 * bs);
    assert(b1.length == 192 * bs);
    assert(a.allocators.length == 1);
    auto b2 = a.allocate(64 * bs);
    assert(b2.length == 64 * bs);
    assert(a.allocators.length == 1);
    auto b3 = a.allocate(192 * bs);
    assert(b3.length == 192 * bs);
    assert(a.allocators.length == 2);
    // Ensure deallocate inherits from parent allocators
    () nothrow @nogc { a.deallocate(b1); }();
    b1 = a.allocate(64 * bs);
    assert(b1.length == 64 * bs);
    assert(a.allocators.length == 2);
    a.deallocateAll();
}

@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.algorithm.comparison : max;
    import std.typecons : Ternary;

    static void testrw(void[] b)
    {
        ubyte* buf = cast(ubyte*) b.ptr;
        for (int i = 0; i < b.length; i += pageSize)
        {
            buf[i] = cast(ubyte) (i % 256);
            assert(buf[i] == cast(ubyte) (i % 256));
        }
    }

    enum numPages = 2;
    AllocatorList!((n) => AscendingPageAllocator(max(n, numPages * pageSize)), Mallocator) a;

    void[] b1 = a.allocate(1);
    assert(b1.length == 1);
    b1 = a.allocate(2);
    assert(b1.length == 2);
    testrw(b1);
    assert(a.root.a.parent.getAvailableSize() == 0);

    void[] b2 = a.allocate((numPages + 1) * pageSize);
    assert(b2.length == (numPages + 1) * pageSize);
    testrw(b2);

    void[] b3 = a.allocate(3);
    assert(b3.length == 3);
    testrw(b3);

    void[] b4 = a.allocate(0);
    assert(b4.length == 0);

    assert(a.allocators.length == 3);
    assert(a.owns(b1) == Ternary.yes);
    assert(a.owns(b2) == Ternary.yes);
    assert(a.owns(b3) == Ternary.yes);

    assert(a.expand(b1, pageSize - b1.length));
    assert(b1.length == pageSize);
    assert(!a.expand(b1, 1));
    assert(!a.expand(b2, 1));

    testrw(b1);
    testrw(b2);
    testrw(b3);

    assert(a.deallocate(b1));
    assert(a.deallocate(b2));

    assert(a.deallocateAll());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.algorithm.comparison : max;
    import std.typecons : Ternary;

    static void testrw(void[] b)
    {
        ubyte* buf = cast(ubyte*) b.ptr;
        for (int i = 0; i < b.length; i += pageSize)
        {
            buf[i] = cast(ubyte) (i % 256);
            assert(buf[i] == cast(ubyte) (i % 256));
        }
    }

    enum numPages = 2;
    AllocatorList!((n) => AscendingPageAllocator(max(n, numPages * pageSize)), NullAllocator) a;

    void[] b1 = a.allocate(1);
    assert(b1.length == 1);
    b1 = a.allocate(2);
    assert(b1.length == 2);
    testrw(b1);

    void[] b2 = a.allocate((numPages + 1) * pageSize);
    assert(b2.length == (numPages + 1) * pageSize);
    testrw(b2);

    void[] b3 = a.allocate(3);
    assert(b3.length == 3);
    testrw(b3);

    void[] b4 = a.allocate(0);
    assert(b4.length == 0);

    assert(a.allocators.length == 3);
    assert(a.owns(b1) == Ternary.yes);
    assert(a.owns(b2) == Ternary.yes);
    assert(a.owns(b3) == Ternary.yes);

    assert(a.expand(b1, pageSize - b1.length));
    assert(b1.length == pageSize);
    assert(!a.expand(b1, 1));
    assert(!a.expand(b2, 1));

    testrw(b1);
    testrw(b2);
    testrw(b3);

    assert(a.deallocate(b1));
    assert(a.deallocate(b2));

    const alignment = cast(uint) (70 * pageSize);
    b3 = a.alignedAllocate(70 * pageSize, alignment);
    assert(b3.length == 70 * pageSize);
    assert(b3.ptr.alignedAt(alignment));
    testrw(b3);
    assert(a.allocators.length == 4);
    assert(a.deallocate(b3));


    assert(a.deallocateAll());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.algorithm.comparison : max;
    import std.typecons : Ternary;

    static void testrw(void[] b)
    {
        ubyte* buf = cast(ubyte*) b.ptr;
        for (int i = 0; i < b.length; i += pageSize)
        {
            buf[i] = cast(ubyte) (i % 256);
            assert(buf[i] == cast(ubyte) (i % 256));
        }
    }

    enum numPages = 5;
    AllocatorList!((n) => AscendingPageAllocator(max(n, numPages * pageSize)), NullAllocator) a;
    const alignment = cast(uint) (2 * pageSize);
    auto b = a.alignedAllocate(1, alignment);
    assert(b.length == 1);
    assert(a.expand(b, pageSize - 1));
    assert(b.ptr.alignedAt(alignment));
    assert(b.length == pageSize);

    b = a.allocate(pageSize);
    assert(b.length == pageSize);
    assert(a.allocators.length == 1);

    assert(a.allocate(pageSize * 5).length == pageSize * 5);
    assert(a.allocators.length == 2);

    assert(a.deallocateAll());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.ascending_page_allocator : AscendingPageAllocator;
    import std.algorithm.comparison : max;

    enum maxIter = 100;
    enum numPages = 10;
    const chunkSize = pageSize / 8;

    AllocatorList!((n) => AscendingPageAllocator(max(n, numPages * pageSize)), NullAllocator) a;
    foreach (i; 0 .. maxIter)
    {
        auto b1 = a.allocate(chunkSize);
        assert(b1.length == chunkSize);

        assert(a.deallocate(b1));
    }

    assert(a.deallocateAll());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/ascending_page_allocator.d)
*/
module std.experimental.allocator.building_blocks.ascending_page_allocator;

import core.memory : pageSize;

import std.experimental.allocator.common;

// Common implementations for shared and thread local AscendingPageAllocator
private mixin template AscendingPageAllocatorImpl(bool isShared)
{
    bool deallocate(void[] buf) nothrow @nogc
    {
        size_t goodSize = goodAllocSize(buf.length);
        version (Posix)
        {
            import core.sys.posix.sys.mman : mmap, MAP_FAILED, MAP_PRIVATE,
                MAP_ANON, MAP_FIXED, PROT_NONE, munmap;

            auto ptr = mmap(buf.ptr, goodSize, PROT_NONE, MAP_ANON | MAP_PRIVATE | MAP_FIXED, -1, 0);
            if (ptr == MAP_FAILED)
                 return false;
        }
        else version (Windows)
        {
            import core.sys.windows.winbase : VirtualFree;
            import core.sys.windows.winnt : MEM_DECOMMIT;

            auto ret = VirtualFree(buf.ptr, goodSize, MEM_DECOMMIT);
            if (ret == 0)
                 return false;
        }
        else
        {
            static assert(0, "Unsupported OS");
        }

        static if (!isShared)
        {
            pagesUsed -= goodSize / pageSize;
        }

        return true;
    }

    Ternary owns(void[] buf) nothrow @nogc
    {
        if (!data)
            return Ternary.no;
        return Ternary(buf.ptr >= data && buf.ptr < buf.ptr + numPages * pageSize);
    }

    bool deallocateAll() nothrow @nogc
    {
        version (Posix)
        {
            import core.sys.posix.sys.mman : munmap;
            auto ret = munmap(cast(void*) data, numPages * pageSize);
            if (ret != 0)
                assert(0, "Failed to unmap memory, munmap failure");
        }
        else version (Windows)
        {
            import core.sys.windows.winbase : VirtualFree;
            import core.sys.windows.winnt : MEM_RELEASE;
            auto ret = VirtualFree(cast(void*) data, 0, MEM_RELEASE);
            if (ret == 0)
                assert(0, "Failed to unmap memory, VirtualFree failure");
        }
        else
        {
            static assert(0, "Unsupported OS version");
        }
        data = null;
        offset = null;
        return true;
    }

    size_t goodAllocSize(size_t n) nothrow @nogc
    {
        return n.roundUpToMultipleOf(cast(uint) pageSize);
    }

    this(size_t n) nothrow @nogc
    {
        static if (isShared)
        {
            lock = SpinLock(SpinLock.Contention.brief);
        }

        pageSize = .pageSize;
        numPages = n.roundUpToMultipleOf(cast(uint) pageSize) / pageSize;

        version (Posix)
        {
            import core.sys.posix.sys.mman : mmap, MAP_ANON, PROT_NONE,
                MAP_PRIVATE, MAP_FAILED;

            data = cast(typeof(data)) mmap(null, pageSize * numPages,
                PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);
            if (data == MAP_FAILED)
                assert(0, "Failed to mmap memory");
        }
        else version (Windows)
        {
            import core.sys.windows.winbase : VirtualAlloc;
            import core.sys.windows.winnt : MEM_RESERVE, PAGE_NOACCESS;

            data = cast(typeof(data)) VirtualAlloc(null, pageSize * numPages,
                MEM_RESERVE, PAGE_NOACCESS);
            if (!data)
                assert(0, "Failed to VirtualAlloc memory");
        }
        else
        {
            static assert(0, "Unsupported OS version");
        }

        offset = data;
        readWriteLimit = data;
    }

    size_t getAvailableSize() nothrow @nogc
    {
        static if (isShared)
        {
            lock.lock();
        }

        auto size = numPages * pageSize + data - offset;
        static if (isShared)
        {
            lock.unlock();
        }
        return size;
    }

    // Sets the protection of a memory range to read/write
    private bool extendMemoryProtection(void* start, size_t size) nothrow @nogc
    {
        version (Posix)
        {
            import core.sys.posix.sys.mman : mprotect, PROT_WRITE, PROT_READ;

            auto ret = mprotect(start, size, PROT_WRITE | PROT_READ);
            return ret == 0;
        }
        else version (Windows)
        {
            import core.sys.windows.winbase : VirtualAlloc;
            import core.sys.windows.winnt : MEM_COMMIT, PAGE_READWRITE;

            auto ret = VirtualAlloc(start, size, MEM_COMMIT, PAGE_READWRITE);
            return ret != null;
        }
        else
        {
            static assert(0, "Unsupported OS");
        }
    }
}

/**
`AscendingPageAllocator` is a fast and safe allocator that rounds all allocations
to multiples of the system's page size. It reserves a range of virtual addresses
(using `mmap` on Posix and `VirtualAlloc` on Windows) and allocates memory at consecutive virtual
addresses.

When a chunk of memory is requested, the allocator finds a range of
virtual pages that satisfy the requested size, changing their protection to
read/write using OS primitives (`mprotect` and `VirtualProtect`, respectively).
The physical memory is allocated on demand, when the pages are accessed.

Deallocation removes any read/write permissions from the target pages
and notifies the OS to reclaim the physical memory, while keeping the virtual
memory.

Because the allocator does not reuse memory, any dangling references to
deallocated memory will always result in deterministically crashing the process.

See_Also:
$(HTTPS microsoft.com/en-us/research/wp-content/uploads/2017/03/kedia2017mem.pdf, Simple Fast and Safe Manual Memory Management) for the general approach.
*/
struct AscendingPageAllocator
{
    import std.typecons : Ternary;

    // Docs for mixin functions
    version (StdDdoc)
    {
        /**
        Rounds the mapping size to the next multiple of the page size and calls
        the OS primitive responsible for creating memory mappings: `mmap` on POSIX and
        `VirtualAlloc` on Windows.

        Params:
        n = mapping size in bytes
        */
        this(size_t n) nothrow @nogc;

        /**
        Rounds the requested size to the next multiple of the page size.
        */
        size_t goodAllocSize(size_t n) nothrow @nogc;

        /**
        Decommit all physical memory associated with the buffer given as parameter,
        but keep the range of virtual addresses.

        On POSIX systems `deallocate` calls `mmap` with `MAP_FIXED' a second time to decommit the memory.
        On Windows, it uses `VirtualFree` with `MEM_DECOMMIT`.
        */
        void deallocate(void[] b) nothrow @nogc;

        /**
        Returns `Ternary.yes` if the passed buffer is inside the range of virtual adresses.
        Does not guarantee that the passed buffer is still valid.
        */
        Ternary owns(void[] buf) nothrow @nogc;

        /**
        Removes the memory mapping causing all physical memory to be decommited and
        the virtual address space to be reclaimed.
        */
        bool deallocateAll() nothrow @nogc;

        /**
        Returns the available size for further allocations in bytes.
        */
        size_t getAvailableSize() nothrow @nogc;
    }

private:
    size_t pageSize;
    size_t numPages;

    // The start of the virtual address range
    void* data;

    // Keeps track of there the next allocation should start
    void* offset;

    // Number of pages which contain alive objects
    size_t pagesUsed;

    // On allocation requests, we allocate an extra 'extraAllocPages' pages
    // The address up to which we have permissions is stored in 'readWriteLimit'
    void* readWriteLimit;
    enum extraAllocPages = 1000;

public:
    enum uint alignment = 4096;

    // Inject common function implementations
    mixin AscendingPageAllocatorImpl!false;

    /**
    Rounds the allocation size to the next multiple of the page size.
    The allocation only reserves a range of virtual pages but the actual
    physical memory is allocated on demand, when accessing the memory.

    Params:
    n = Bytes to allocate

    Returns:
    `null` on failure or if the requested size exceeds the remaining capacity.
    */
    void[] allocate(size_t n) nothrow @nogc
    {
        import std.algorithm.comparison : min;

        immutable pagedBytes = numPages * pageSize;
        size_t goodSize = goodAllocSize(n);

        // Requested exceeds the virtual memory range
        if (goodSize > pagedBytes || offset - data > pagedBytes - goodSize)
            return null;

        // Current allocation exceeds readable/writable memory area
        if (offset + goodSize > readWriteLimit)
        {
            // Extend r/w memory range to new limit
            void* newReadWriteLimit = min(data + pagedBytes,
                offset + goodSize + extraAllocPages * pageSize);
            if (newReadWriteLimit != readWriteLimit)
            {
                assert(newReadWriteLimit > readWriteLimit);
                if (!extendMemoryProtection(readWriteLimit, newReadWriteLimit - readWriteLimit))
                    return null;

                readWriteLimit = newReadWriteLimit;
            }
        }

        void* result = offset;
        offset += goodSize;
        pagesUsed += goodSize / pageSize;

        return cast(void[]) result[0 .. n];
    }

    /**
    Rounds the allocation size to the next multiple of the page size.
    The allocation only reserves a range of virtual pages but the actual
    physical memory is allocated on demand, when accessing the memory.

    The allocated memory is aligned to the specified alignment `a`.

    Params:
    n = Bytes to allocate
    a = Alignment

    Returns:
    `null` on failure or if the requested size exceeds the remaining capacity.
    */
    void[] alignedAllocate(size_t n, uint a) nothrow @nogc
    {
        void* alignedStart = cast(void*) roundUpToMultipleOf(cast(size_t) offset, a);
        assert(alignedStart.alignedAt(a));
        immutable pagedBytes = numPages * pageSize;
        size_t goodSize = goodAllocSize(n);
        if (goodSize > pagedBytes ||
            alignedStart - data > pagedBytes - goodSize)
            return null;

        // Same logic as allocate, only that the buffer must be properly aligned
        auto oldOffset = offset;
        offset = alignedStart;
        auto result = allocate(n);
        if (!result)
            offset = oldOffset;
        return result;
    }

    /**
    If the passed buffer is not the last allocation, then `delta` can be
    at most the number of bytes left on the last page.
    Otherwise, we can expand the last allocation until the end of the virtual
    address range.
    */
    bool expand(ref void[] b, size_t delta) nothrow @nogc
    {
        import std.algorithm.comparison : min;

        if (!delta) return true;
        if (b is null) return false;

        size_t goodSize = goodAllocSize(b.length);
        size_t bytesLeftOnPage = goodSize - b.length;

        // If this is not the last allocation, we can only expand until
        // completely filling the last page covered by this buffer
        if (b.ptr + goodSize != offset && delta > bytesLeftOnPage)
            return false;

        size_t extraPages = 0;

        // If the extra `delta` bytes requested do not fit the last page
        // compute how many extra pages are neeeded
        if (delta > bytesLeftOnPage)
        {
            extraPages = goodAllocSize(delta - bytesLeftOnPage) / pageSize;
        }
        else
        {
            b = cast(void[]) b.ptr[0 .. b.length + delta];
            return true;
        }

        if (extraPages > numPages || offset - data > pageSize * (numPages - extraPages))
            return false;

        void* newPtrEnd = b.ptr + goodSize + extraPages * pageSize;
        if (newPtrEnd > readWriteLimit)
        {
            void* newReadWriteLimit = min(data + numPages * pageSize,
                newPtrEnd + extraAllocPages * pageSize);
            if (newReadWriteLimit > readWriteLimit)
            {
                if (!extendMemoryProtection(readWriteLimit, newReadWriteLimit - readWriteLimit))
                    return false;

                readWriteLimit = newReadWriteLimit;
            }
        }

        pagesUsed += extraPages;
        offset += extraPages * pageSize;
        b = cast(void[]) b.ptr[0 .. b.length + delta];
        return true;
    }

    /**
    Returns `Ternary.yes` if the allocator does not contain any alive objects
    and `Ternary.no` otherwise.
    */
    Ternary empty() nothrow @nogc
    {
        return Ternary(pagesUsed == 0);
    }

    /**
    Unmaps the whole virtual address range on destruction.
    */
    ~this() nothrow @nogc
    {
        if (data)
            deallocateAll();
    }
}

///
@system @nogc nothrow unittest
{
    import core.memory : pageSize;

    size_t numPages = 100;
    void[] buf;
    void[] prevBuf = null;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);

    foreach (i; 0 .. numPages)
    {
        // Allocation is rounded up to page size
        buf = a.allocate(pageSize - 100);
        assert(buf.length == pageSize - 100);

        // Allocations are served at increasing addresses
        if (prevBuf)
            assert(prevBuf.ptr + pageSize == buf.ptr);

        assert(a.deallocate(buf));
        prevBuf = buf;
    }
}

/**
`SharedAscendingPageAllocator` is the threadsafe version of `AscendingPageAllocator`.
*/
shared struct SharedAscendingPageAllocator
{
    import std.typecons : Ternary;
    import core.internal.spinlock : SpinLock;

    // Docs for mixin functions
    version (StdDdoc)
    {
        /**
        Rounds the mapping size to the next multiple of the page size and calls
        the OS primitive responsible for creating memory mappings: `mmap` on POSIX and
        `VirtualAlloc` on Windows.

        Params:
        n = mapping size in bytes
        */
        this(size_t n) nothrow @nogc;

        /**
        Rounds the requested size to the next multiple of the page size.
        */
        size_t goodAllocSize(size_t n) nothrow @nogc;

        /**
        Decommit all physical memory associated with the buffer given as parameter,
        but keep the range of virtual addresses.

        On POSIX systems `deallocate` calls `mmap` with `MAP_FIXED' a second time to decommit the memory.
        On Windows, it uses `VirtualFree` with `MEM_DECOMMIT`.
        */
        void deallocate(void[] b) nothrow @nogc;

        /**
        Returns `Ternary.yes` if the passed buffer is inside the range of virtual adresses.
        Does not guarantee that the passed buffer is still valid.
        */
        Ternary owns(void[] buf) nothrow @nogc;

        /**
        Removes the memory mapping causing all physical memory to be decommited and
        the virtual address space to be reclaimed.
        */
        bool deallocateAll() nothrow @nogc;

        /**
        Returns the available size for further allocations in bytes.
        */
        size_t getAvailableSize() nothrow @nogc;
    }

private:
    size_t pageSize;
    size_t numPages;

    // The start of the virtual address range
    shared void* data;

    // Keeps track of there the next allocation should start
    shared void* offset;

    // On allocation requests, we allocate an extra 'extraAllocPages' pages
    // The address up to which we have permissions is stored in 'readWriteLimit'
    shared void* readWriteLimit;
    enum extraAllocPages = 1000;
    SpinLock lock;

public:
    enum uint alignment = 4096;

    // Inject common function implementations
    mixin AscendingPageAllocatorImpl!true;

    /**
    Rounds the allocation size to the next multiple of the page size.
    The allocation only reserves a range of virtual pages but the actual
    physical memory is allocated on demand, when accessing the memory.

    Params:
    n = Bytes to allocate

    Returns:
    `null` on failure or if the requested size exceeds the remaining capacity.
    */
    void[] allocate(size_t n) nothrow @nogc
    {
        return allocateImpl(n, 1);
    }

    /**
    Rounds the allocation size to the next multiple of the page size.
    The allocation only reserves a range of virtual pages but the actual
    physical memory is allocated on demand, when accessing the memory.

    The allocated memory is aligned to the specified alignment `a`.

    Params:
    n = Bytes to allocate
    a = Alignment

    Returns:
    `null` on failure or if the requested size exceeds the remaining capacity.
    */
    void[] alignedAllocate(size_t n, uint a) nothrow @nogc
    {
        // For regular `allocate` calls, `a` will be set to 1
        return allocateImpl(n, a);
    }

    private void[] allocateImpl(size_t n, uint a) nothrow @nogc
    {
        import std.algorithm.comparison : min;

        size_t localExtraAlloc;
        void* localOffset;
        immutable pagedBytes = numPages * pageSize;
        size_t goodSize = goodAllocSize(n);

        if (goodSize > pagedBytes)
            return null;

        lock.lock();
        scope(exit) lock.unlock();

        localOffset = cast(void*) offset;
        void* alignedStart = cast(void*) roundUpToMultipleOf(cast(size_t) localOffset, a);
        assert(alignedStart.alignedAt(a));
        if (alignedStart - data > pagedBytes - goodSize)
            return null;

        localOffset = alignedStart + goodSize;
        if (localOffset > readWriteLimit)
        {
            void* newReadWriteLimit = min(cast(void*) data + pagedBytes,
                cast(void*) localOffset + extraAllocPages * pageSize);
            assert(newReadWriteLimit > readWriteLimit);
            localExtraAlloc = newReadWriteLimit - readWriteLimit;
            if (!extendMemoryProtection(cast(void*) readWriteLimit, localExtraAlloc))
                return null;
            readWriteLimit = cast(shared(void*)) newReadWriteLimit;
        }

        offset = cast(typeof(offset)) localOffset;
        return cast(void[]) alignedStart[0 .. n];
    }

    /**
    If the passed buffer is not the last allocation, then `delta` can be
    at most the number of bytes left on the last page.
    Otherwise, we can expand the last allocation until the end of the virtual
    address range.
    */
    bool expand(ref void[] b, size_t delta) nothrow @nogc
    {
        import std.algorithm.comparison : min;

        if (!delta) return true;
        if (b is null) return false;

        void* localOffset;
        size_t localExtraAlloc;
        size_t goodSize = goodAllocSize(b.length);
        size_t bytesLeftOnPage = goodSize - b.length;

        if (bytesLeftOnPage >= delta)
        {
            b = cast(void[]) b.ptr[0 .. b.length + delta];
            return true;
        }

        lock.lock();
        scope(exit) lock.unlock();

        localOffset = cast(void*) offset;
        if (b.ptr + goodSize != localOffset)
            return false;

        size_t extraPages = goodAllocSize(delta - bytesLeftOnPage) / pageSize;
        if (extraPages > numPages || localOffset - data > pageSize * (numPages - extraPages))
            return false;


        localOffset = b.ptr + goodSize + extraPages * pageSize;
        if (localOffset > readWriteLimit)
        {
            void* newReadWriteLimit = min(cast(void*) data + numPages * pageSize,
                localOffset + extraAllocPages * pageSize);
            assert(newReadWriteLimit > readWriteLimit);
            localExtraAlloc = newReadWriteLimit - readWriteLimit;
            if (!extendMemoryProtection(cast(void*) readWriteLimit, localExtraAlloc))
                return false;
            readWriteLimit = cast(shared(void*)) newReadWriteLimit;
        }

        offset = cast(typeof(offset)) localOffset;
        b = cast(void[]) b.ptr[0 .. b.length + delta];
        return true;
    }
}

///
@system unittest
{
    import core.memory : pageSize;
    import core.thread : ThreadGroup;

    enum numThreads = 100;
    shared SharedAscendingPageAllocator a = SharedAscendingPageAllocator(pageSize * numThreads);

    void fun()
    {
        void[] b = a.allocate(pageSize);
        assert(b.length == pageSize);

        assert(a.deallocate(b));
    }

    auto tg = new ThreadGroup;
    foreach (i; 0 .. numThreads)
    {
        tg.create(&fun);
    }
    tg.joinAll();
}

version (StdUnittest)
{
    private static void testrw(void[] b) @nogc nothrow
    {
        ubyte* buf = cast(ubyte*) b.ptr;
        buf[0] = 100;
        assert(buf[0] == 100);
        buf[b.length - 1] = 101;
        assert(buf[b.length - 1] == 101);
    }
}

@system @nogc nothrow unittest
{
    static void testAlloc(Allocator)(ref Allocator a) @nogc nothrow
    {
        void[] b1 = a.allocate(1);
        assert(a.getAvailableSize() == 3 * pageSize);
        testrw(b1);
        void[] b2 = a.allocate(2);
        assert(a.getAvailableSize() == 2 * pageSize);
        testrw(b2);
        void[] b3 = a.allocate(pageSize + 1);
        assert(a.getAvailableSize() == 0);

        testrw(b3);
        assert(b1.length == 1);
        assert(b2.length == 2);
        assert(b3.length == pageSize + 1);

        assert(a.offset - a.data == 4 * pageSize);
        void[] b4 = a.allocate(4);
        assert(!b4);

        a.deallocate(b1);
        assert(a.data);
        a.deallocate(b2);
        assert(a.data);
        a.deallocate(b3);
    }

    AscendingPageAllocator a = AscendingPageAllocator(4 * pageSize);
    shared SharedAscendingPageAllocator aa = SharedAscendingPageAllocator(4 * pageSize);

    testAlloc(a);
    testAlloc(aa);
}

@system @nogc nothrow unittest
{
    size_t numPages = 26214;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);
    foreach (i; 0 .. numPages)
    {
        void[] buf = a.allocate(pageSize);
        assert(buf.length == pageSize);
        testrw(buf);
        a.deallocate(buf);
    }

    assert(!a.allocate(1));
    assert(a.getAvailableSize() == 0);
}

@system @nogc nothrow unittest
{
    size_t numPages = 26214;
    uint alignment = cast(uint) pageSize;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);

    foreach (i; 0 .. numPages)
    {
        void[] buf = a.alignedAllocate(pageSize, alignment);
        assert(buf.length == pageSize);
        testrw(buf);
        a.deallocate(buf);
    }

    assert(!a.allocate(1));
    assert(a.getAvailableSize() == 0);
}

@system @nogc nothrow unittest
{
    static void testAlloc(Allocator)(ref Allocator a) @nogc nothrow
    {
        import std.traits : hasMember;

        size_t numPages = 5;
        uint alignment = cast(uint) pageSize;

        void[] b1 = a.allocate(pageSize / 2);
        assert(b1.length == pageSize / 2);

        void[] b2 = a.alignedAllocate(pageSize / 2, alignment);
        assert(a.expand(b1, pageSize / 2));
        assert(a.expand(b1, 0));
        assert(!a.expand(b1, 1));
        testrw(b1);

        assert(a.expand(b2, pageSize / 2));
        testrw(b2);
        assert(b2.length == pageSize);

        assert(a.getAvailableSize() == pageSize * 3);

        void[] b3 = a.allocate(pageSize / 2);
        assert(a.reallocate(b1, b1.length));
        assert(a.reallocate(b2, b2.length));
        assert(a.reallocate(b3, b3.length));

        assert(b3.length == pageSize / 2);
        testrw(b3);
        assert(a.expand(b3, pageSize / 4));
        testrw(b3);
        assert(a.expand(b3, 0));
        assert(b3.length == pageSize / 2 + pageSize / 4);
        assert(a.expand(b3, pageSize / 4 - 1));
        testrw(b3);
        assert(a.expand(b3, 0));
        assert(b3.length == pageSize - 1);
        assert(a.expand(b3, 2));
        assert(a.expand(b3, 0));
        assert(a.getAvailableSize() == pageSize);
        assert(b3.length == pageSize + 1);
        testrw(b3);

        assert(a.reallocate(b1, b1.length));
        assert(a.reallocate(b2, b2.length));
        assert(a.reallocate(b3, b3.length));

        assert(a.reallocate(b3, 2 * pageSize));
        testrw(b3);
        assert(a.reallocate(b1, pageSize - 1));
        testrw(b1);
        assert(a.expand(b1, 1));
        testrw(b1);
        assert(!a.expand(b1, 1));

        a.deallocate(b1);
        a.deallocate(b2);
        a.deallocate(b3);
    }

    size_t numPages = 5;
    uint alignment = cast(uint) pageSize;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);
    shared SharedAscendingPageAllocator aa = SharedAscendingPageAllocator(numPages * pageSize);

    testAlloc(a);
    testAlloc(aa);
}

@system @nogc nothrow unittest
{
    size_t numPages = 21000;
    enum testNum = 100;
    enum allocPages = 10;
    void[][testNum] buf;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);

    for (int i = 0; i < numPages; i += testNum * allocPages)
    {
        foreach (j; 0 .. testNum)
        {
            buf[j] = a.allocate(pageSize * allocPages);
            testrw(buf[j]);
        }

        foreach (j; 0 .. testNum)
        {
            a.deallocate(buf[j]);
        }
    }
}

@system @nogc nothrow unittest
{
    size_t numPages = 21000;
    enum testNum = 100;
    enum allocPages = 10;
    void[][testNum] buf;
    shared SharedAscendingPageAllocator a = SharedAscendingPageAllocator(numPages * pageSize);

    for (int i = 0; i < numPages; i += testNum * allocPages)
    {
        foreach (j; 0 .. testNum)
        {
            buf[j] = a.allocate(pageSize * allocPages);
            testrw(buf[j]);
        }

        foreach (j; 0 .. testNum)
        {
            a.deallocate(buf[j]);
        }
    }
}

@system @nogc nothrow unittest
{
    enum numPages = 2;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);
    void[] b = a.allocate((numPages + 1) * pageSize);
    assert(b is null);
    b = a.allocate(1);
    assert(b.length == 1);
    assert(a.getAvailableSize() == pageSize);
    a.deallocateAll();
    assert(!a.data && !a.offset);
}

@system @nogc nothrow unittest
{
    enum numPages = 26;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);
    uint alignment = cast(uint) ((numPages / 2) * pageSize);
    void[] b = a.alignedAllocate(pageSize, alignment);
    assert(b.length == pageSize);
    testrw(b);
    assert(b.ptr.alignedAt(alignment));
    a.deallocateAll();
    assert(!a.data && !a.offset);
}

@system @nogc nothrow unittest
{
    enum numPages = 10;
    AscendingPageAllocator a = AscendingPageAllocator(numPages * pageSize);
    uint alignment = cast(uint) (2 * pageSize);

    void[] b1 = a.alignedAllocate(pageSize, alignment);
    assert(b1.length == pageSize);
    testrw(b1);
    assert(b1.ptr.alignedAt(alignment));

    void[] b2 = a.alignedAllocate(pageSize, alignment);
    assert(b2.length == pageSize);
    testrw(b2);
    assert(b2.ptr.alignedAt(alignment));

    void[] b3 = a.alignedAllocate(pageSize, alignment);
    assert(b3.length == pageSize);
    testrw(b3);
    assert(b3.ptr.alignedAt(alignment));

    void[] b4 = a.allocate(pageSize);
    assert(b4.length == pageSize);
    testrw(b4);

    assert(a.deallocate(b1));
    assert(a.deallocate(b2));
    assert(a.deallocate(b3));
    assert(a.deallocate(b4));

    a.deallocateAll();
    assert(!a.data && !a.offset);
}

@system unittest
{
    import core.thread : ThreadGroup;
    import std.algorithm.sorting : sort;
    import core.internal.spinlock : SpinLock;

    enum numThreads = 100;
    SpinLock lock = SpinLock(SpinLock.Contention.brief);
    ulong[numThreads] ptrVals;
    size_t count = 0;
    shared SharedAscendingPageAllocator a = SharedAscendingPageAllocator(pageSize * numThreads);

    void fun()
    {
        void[] b = a.allocate(4000);
        assert(b.length == 4000);

        assert(a.expand(b, 96));
        assert(b.length == 4096);

        lock.lock();
        ptrVals[count] = cast(ulong) b.ptr;
        count++;
        lock.unlock();
    }

    auto tg = new ThreadGroup;
    foreach (i; 0 .. numThreads)
    {
        tg.create(&fun);
    }
    tg.joinAll();

    ptrVals[].sort();
    foreach (i; 0 .. numThreads - 1)
    {
        assert(ptrVals[i] + pageSize == ptrVals[i + 1]);
    }
}

@system unittest
{
    import core.thread : ThreadGroup;
    import std.algorithm.sorting : sort;
    import core.internal.spinlock : SpinLock;

    SpinLock lock = SpinLock(SpinLock.Contention.brief);
    enum numThreads = 100;
    void[][numThreads] buf;
    size_t count = 0;
    shared SharedAscendingPageAllocator a = SharedAscendingPageAllocator(2 * pageSize * numThreads);

    void fun()
    {
        enum expand = 96;
        void[] b = a.allocate(pageSize - expand);
        assert(b.length == pageSize - expand);

        assert(a.expand(b, expand));
        assert(b.length == pageSize);

        a.expand(b, pageSize);
        assert(b.length == pageSize || b.length == pageSize * 2);

        lock.lock();
        buf[count] = b;
        count++;
        lock.unlock();
    }

    auto tg = new ThreadGroup;
    foreach (i; 0 .. numThreads)
    {
        tg.create(&fun);
    }
    tg.joinAll();

    sort!((a, b) => a.ptr < b.ptr)(buf[0 .. 100]);
    foreach (i; 0 .. numThreads - 1)
    {
        assert(buf[i].ptr + buf[i].length == buf[i + 1].ptr);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/bitmapped_block.d)
*/
module std.experimental.allocator.building_blocks.bitmapped_block;

import std.experimental.allocator.building_blocks.null_allocator;
import std.experimental.allocator.common;
import std.typecons : Flag, Yes, No;


// Common implementation for shared and non-shared versions of the BitmappedBlock
private mixin template BitmappedBlockImpl(bool isShared, bool multiBlock)
{
    import std.conv : text;
    import std.traits : hasMember;
    import std.typecons : Ternary;
    import std.typecons : tuple, Tuple;

    static if (isShared && multiBlock)
    import core.internal.spinlock : SpinLock;

    static assert(theBlockSize > 0 && theAlignment.isGoodStaticAlignment);
    static assert(theBlockSize == chooseAtRuntime ||
        theBlockSize % theAlignment == 0, "Block size must be a multiple of the alignment");

    static if (theBlockSize != chooseAtRuntime)
    {
        alias blockSize = theBlockSize;
    }
    else
    {
        // It is the caller's responsibilty to synchronize this with
        // allocate/deallocate in shared environments
        @property uint blockSize() { return _blockSize; }
        @property void blockSize(uint s)
        {
            static if (multiBlock)
            {
                assert((cast(BitVector) _control).length == 0 && s % alignment == 0);
            }
            else
            {
                assert(_control.length == 0 && s % alignment == 0);
            }
            _blockSize = s;
        }
        private uint _blockSize;
    }

    static if (is(ParentAllocator == NullAllocator))
    {
        private enum parentAlignment = platformAlignment;
    }
    else
    {
        private alias parentAlignment = ParentAllocator.alignment;
        static assert(parentAlignment >= ulong.alignof);
    }

    alias alignment = theAlignment;

    static if (stateSize!ParentAllocator)
    {
        ParentAllocator parent;
    }
    else
    {
        alias parent = ParentAllocator.instance;
    }

    private size_t _blocks;
    private void[] _payload;
    private size_t _startIdx;

    // For multiblock, '_control' is a BitVector, otherwise just a regular ulong[]
    static if (multiBlock)
    {
        // Keeps track of first block which has never been used in an allocation.
        // All blocks which are located right to the '_freshBit', should have never been
        // allocated
        private ulong _freshBit;
        private BitVector _control;
    }
    else
    {
        private ulong[] _control;
    }

    static if (multiBlock && isShared)
    {
        SpinLock lock = SpinLock(SpinLock.Contention.brief);
    }

    pure nothrow @safe @nogc
    private size_t totalAllocation(size_t capacity)
    {
        auto blocks = capacity.divideRoundUp(blockSize);
        auto leadingUlongs = blocks.divideRoundUp(64);
        import std.algorithm.comparison : min;
        immutable initialAlignment = min(parentAlignment,
            1U << min(31U, trailingZeros(leadingUlongs * 8)));
        auto maxSlack = alignment <= initialAlignment
            ? 0
            : alignment - initialAlignment;
        return leadingUlongs * 8 + maxSlack + blockSize * blocks;
    }

    this(ubyte[] data)
    {
        immutable a = data.ptr.effectiveAlignment;
        assert(a >= size_t.alignof || !data.ptr,
            "Data must be aligned properly");

        immutable ulong totalBits = data.length * 8;
        immutable ulong bitsPerBlock = blockSize * 8 + 1;
        _blocks = totalBits / bitsPerBlock;

        // Reality is a bit more complicated, iterate until a good number of
        // blocks found.
        size_t localBlocks;
        for (localBlocks = _blocks; localBlocks; --localBlocks)
        {
            immutable controlWords = localBlocks.divideRoundUp(64);
            auto payload = data[controlWords * 8 .. $].roundStartToMultipleOf(
                alignment);
            if (payload.length < localBlocks * blockSize)
            {
                // Overestimated
                continue;
            }

            // Need the casts for shared versions
            static if (multiBlock)
            {
                _control = cast(typeof(_control)) BitVector((cast(ulong*) data.ptr)[0 .. controlWords]);
                (cast(BitVector) _control)[] = 0;
            }
            else
            {
                _control = (cast(typeof(_control.ptr)) data.ptr)[0 .. controlWords];
                _control[] = 0;
            }

            _payload = cast(typeof(_payload)) payload;
            break;
        }

        _blocks = cast(typeof(_blocks)) localBlocks;
    }

    static if (chooseAtRuntime == theBlockSize)
    this(ubyte[] data, uint blockSize)
    {
        this._blockSize = blockSize;
        this(data);
    }

    static if (!is(ParentAllocator == NullAllocator) && !stateSize!ParentAllocator)
    this(size_t capacity)
    {
        size_t toAllocate = totalAllocation(capacity);
        auto data = cast(ubyte[])(parent.allocate(toAllocate));
        this(data);
        assert(_blocks * blockSize >= capacity);
    }

    static if (!is(ParentAllocator == NullAllocator) && stateSize!ParentAllocator)
    this(ParentAllocator parent, size_t capacity)
    {
        this.parent = parent;
        size_t toAllocate = totalAllocation(capacity);
        auto data = cast(ubyte[])(parent.allocate(toAllocate));
        this(data);
    }

    static if (!is(ParentAllocator == NullAllocator) &&
        chooseAtRuntime == theBlockSize &&
        !stateSize!ParentAllocator)
    this(size_t capacity, uint blockSize)
    {
        this._blockSize = blockSize;
        this(capacity);
    }

    static if (!is(ParentAllocator == NullAllocator) &&
        chooseAtRuntime == theBlockSize &&
        stateSize!ParentAllocator)
    this(ParentAllocator parent, size_t capacity, uint blockSize)
    {
        this._blockSize = blockSize;
        this(parent, capacity);
    }

    static if (!is(ParentAllocator == NullAllocator)
        && hasMember!(ParentAllocator, "deallocate"))
    ~this()
    {
        // multiblock bitmapped blocks use a BitVector
        static if (multiBlock)
        {
            void* start = cast(void*) _control.rep.ptr;
        }
        else
        {
            void* start = cast(void*) _control.ptr;
        }
        void* end = cast(void*) (_payload.ptr + _payload.length);
        parent.deallocate(start[0 .. end - start]);
    }

    pure nothrow @safe @nogc
    size_t goodAllocSize(size_t n)
    {
        return n.roundUpToMultipleOf(blockSize);
    }

    // Implementation of the 'multiBlock' BitmappedBlock
    // For the shared version, the methods are protected by a common lock
    static if (multiBlock)
    {
        /*
        Adjusts the memoized _startIdx to the leftmost control word that has at
        least one zero bit. Assumes all control words to the left of $(D
        _control[_startIdx]) are already occupied.
        */
        private void adjustStartIdx()
        {
            while (_startIdx < _control.rep.length && _control.rep[_startIdx] == ulong.max)
            {
                static if (isShared)
                {
                    // Shared demands atomic increment, however this is protected
                    // by a lock. Regular increment is fine
                    auto localStart = _startIdx + 1;
                    _startIdx = localStart;
                }
                else
                {
                    ++_startIdx;
                }
            }
        }

        /*
        Based on the latest allocated bit, 'newBit', it adjusts '_freshBit'
        */
        pure nothrow @safe @nogc
        private void adjustFreshBit(const ulong newBit)
        {
            import std.algorithm.comparison : max;
            static if (isShared)
            {
                auto localFreshBit = max(newBit, _freshBit);
                _freshBit = localFreshBit;
            }
            else
            {
                _freshBit = max(newBit, _freshBit);
            }
        }

        /*
        Returns the blocks corresponding to the control bits starting at word index
        wordIdx and bit index msbIdx (MSB=0) for a total of howManyBlocks.
        */
        @trusted
        private void[] blocksFor(this _)(size_t wordIdx, uint msbIdx, size_t howManyBlocks)
        {
            assert(msbIdx <= 63);
            const start = (wordIdx * 64 + msbIdx) * blockSize;
            const end = start + blockSize * howManyBlocks;
            if (start == end) return null;
            if (end <= _payload.length) return cast(void[]) _payload[start .. end];
            // This could happen if we have more control bits than available memory.
            // That's possible because the control bits are rounded up to fit in
            // 64-bit words.
            return null;
        }

        static if (isShared)
        nothrow @safe @nogc
        void[] allocate(const size_t s)
        {
            lock.lock();
            scope(exit) lock.unlock();

            return allocateImpl(s);
        }

        static if (!isShared)
        pure nothrow @safe @nogc
        void[] allocate(const size_t s)
        {
            return allocateImpl(s);
        }


        // If shared, this is protected by a lock inside 'allocate'
        pure nothrow @trusted @nogc
        private void[] allocateImpl(const size_t s)
        {
            const blocks = s.divideRoundUp(blockSize);
            void[] result;

        Lswitch:
            switch (blocks)
            {
            case 1:
                // inline code here for speed
                // find the next available block
                foreach (i; _startIdx .. _control.rep.length)
                {
                    const w = _control.rep[i];
                    if (w == ulong.max) continue;
                    uint j = leadingOnes(w);
                    assert(j < 64, "Invalid number of blocks");
                    assert((_control.rep[i] & ((1UL << 63) >> j)) == 0, "Corrupted bitmap");
                    static if (isShared)
                    {
                        // Need the cast because shared does not recognize the lock
                        *(cast(ulong*) &_control._rep[i]) |= (1UL << 63) >> j;
                    }
                    else
                    {
                        _control.rep[i] |= (1UL << 63) >> j;
                    }
                    if (i == _startIdx)
                    {
                        adjustStartIdx();
                    }
                    result = blocksFor(i, j, 1);
                    break Lswitch;
                }
                goto case 0; // fall through
            case 0:
                return null;
            case 2: .. case 64:
                result = smallAlloc(cast(uint) blocks);
                break;
            default:
                result = hugeAlloc(blocks);
                break;
            }
            if (result)
            {
                adjustFreshBit((result.ptr - _payload.ptr) / blockSize + blocks);
            }
            return result.ptr ? result.ptr[0 .. s] : null;
        }

        @trusted void[] allocateFresh(const size_t s)
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            const blocks = s.divideRoundUp(blockSize);

            void[] result = blocksFor(cast(size_t) (_freshBit / 64),
                cast(uint) (_freshBit % 64), blocks);
            if (result)
            {
                (cast(BitVector) _control)[_freshBit .. _freshBit + blocks] = 1;
                static if (isShared)
                {
                    ulong localFreshBit = _freshBit;
                    localFreshBit += blocks;
                    _freshBit = localFreshBit;
                }
                else
                {
                    _freshBit += blocks;
                }
            }
            return result;
        }

        void[] alignedAllocate(size_t n, uint a)
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            return alignedAllocateImpl(n, a);
        }

        // If shared, this is protected by a lock inside 'alignedAllocate'
        private void[] alignedAllocateImpl(size_t n, uint a)
        {
            import std.math.traits : isPowerOf2;
            assert(a.isPowerOf2);
            if (a <= alignment) return allocate(n);

            // Overallocate to make sure we can get an aligned block
            auto b = allocateImpl((n + a - alignment).roundUpToMultipleOf(blockSize));
            if (!b.ptr) return null;
            auto result = b.roundStartToMultipleOf(a);
            assert(result.length >= n);
            result = result.ptr[0 .. n]; // final result

            // Free any blocks that might be slack at the beginning
            auto slackHeadingBlocks = (result.ptr - b.ptr) / blockSize;
            if (slackHeadingBlocks)
            {
                deallocateImpl(b[0 .. slackHeadingBlocks * blockSize]);
            }

            // Free any blocks that might be slack at the end
            auto slackTrailingBlocks = ((b.ptr + b.length)
                - (result.ptr + result.length)) / blockSize;
            if (slackTrailingBlocks)
            {
                deallocateImpl(b[$ - slackTrailingBlocks * blockSize .. $]);
            }

            return result;
        }

        /*
        Tries to allocate "blocks" blocks at the exact position indicated by the
        position wordIdx/msbIdx (msbIdx counts from MSB, i.e. MSB has index 0). If
        it succeeds, fills "result" with the result and returns tuple(size_t.max,
        0). Otherwise, returns a tuple with the next position to search.
        */
        private Tuple!(size_t, uint) allocateAt(size_t wordIdx, uint msbIdx,
                size_t blocks, ref void[] result)
        {
            assert(blocks > 0);
            assert(wordIdx < _control.rep.length);
            assert(msbIdx <= 63);
            void[] tmpResult;
            result = null;
            if (msbIdx + blocks <= 64)
            {
                // Allocation should fit this control word
                static if (isShared)
                {
                    ulong localControl = _control.rep[wordIdx];
                    bool didSetBit = setBitsIfZero(localControl,
                        cast(uint) (64 - msbIdx - blocks), 63 - msbIdx);
                    _control.rep[wordIdx] = localControl;
                }
                else
                {
                    bool didSetBit = setBitsIfZero(_control.rep[wordIdx],
                        cast(uint) (64 - msbIdx - blocks), 63 - msbIdx);
                }
                if (didSetBit)
                {
                    tmpResult = blocksFor(wordIdx, msbIdx, blocks);
                    if (!tmpResult)
                    {
                        static if (isShared)
                        {
                            localControl = _control.rep[wordIdx];
                            resetBits(localControl,
                                cast(uint) (64 - msbIdx - blocks), 63 - msbIdx);
                            _control.rep[wordIdx] = localControl;
                        }
                        else
                        {
                            resetBits(_control.rep[wordIdx],
                                cast(uint) (64 - msbIdx - blocks), 63 - msbIdx);
                        }
                        return tuple(size_t.max - 1, 0u);
                    }
                    result = tmpResult;
                    tmpResult = null;
                    return tuple(size_t.max, 0u);
                }
                // Can't allocate, make a suggestion
                return msbIdx + blocks == 64
                    ? tuple(wordIdx + 1, 0u)
                    : tuple(wordIdx, cast(uint) (msbIdx + blocks));
            }
            // Allocation spans two control words or more
            immutable mask = ulong.max >> msbIdx;
            if (_control.rep[wordIdx] & mask)
            {
                // We can't allocate the rest of this control word,
                // return a suggestion.
                return tuple(wordIdx + 1, 0u);
            }
            // We can allocate the rest of this control word, but we first need to
            // make sure we can allocate the tail.
            if (wordIdx + 1 == _control.rep.length)
            {
                // No more memory
                return tuple(_control.rep.length, 0u);
            }
            auto hint = allocateAt(wordIdx + 1, 0, blocks - 64 + msbIdx, result);
            if (hint[0] == size_t.max)
            {
                tmpResult = blocksFor(wordIdx, msbIdx, blocks);
                if (!tmpResult)
                {
                    return tuple(size_t.max - 1, 0u);
                }
                static if (isShared)
                {
                    // Dont want atomics, because this is protected by 'lock'
                    ulong localControl = _control.rep[wordIdx];
                    localControl |= mask;
                    _control.rep[wordIdx] = localControl;
                }
                else
                {
                    _control.rep[wordIdx] |= mask;
                }
                result = tmpResult;
                tmpResult = null;
                return tuple(size_t.max, 0u);
            }
            // Failed, return a suggestion that skips this whole run.
            return hint;
        }

        /* Allocates as many blocks as possible at the end of the blocks indicated
        by wordIdx. Returns the number of blocks allocated. */
        private uint allocateAtTail(size_t wordIdx)
        {
            assert(wordIdx < _control.rep.length);
            const available = trailingZeros(_control.rep[wordIdx]);
            static if (isShared)
            {
                ulong localControl = _control.rep[wordIdx];
                localControl |= ulong.max >> available;
                _control.rep[wordIdx] = localControl;
            }
            else
            {
                _control.rep[wordIdx] |= ulong.max >> available;
            }
            return available;
        }

        pure nothrow @safe @nogc
        private void[] smallAlloc(uint blocks) return scope
        {
            assert(blocks >= 2 && blocks <= 64);
            void[] result;
            foreach (i; _startIdx .. _control.rep.length)
            {
                // Test within the current 64-bit word
                const v = _control.rep[i];
                if (v == ulong.max) continue;
                auto j = findContigOnes(~v, blocks);
                if (j < 64)
                {
                    // yay, found stuff
                    result = blocksFor(i, j, blocks);
                    if (result)
                    {
                        static if (isShared)
                        {
                            ulong localControl = _control.rep[i];
                            setBits(localControl, 64 - j - blocks, 63 - j);
                            _control.rep[i] = localControl;
                        }
                        else
                        {
                            setBits(_control.rep[i], 64 - j - blocks, 63 - j);
                        }
                    }
                    return result;
                }
                // Next, try allocations that cross a word
                auto available = trailingZeros(v);
                if (available == 0) continue;
                if (i + 1 >= _control.rep.length) break;
                assert(available < blocks); // otherwise we should have found it
                auto needed = blocks - available;
                assert(needed > 0 && needed < 64);
                result = blocksFor(i, 64 - available, blocks);
                if (result && allocateAtFront(i + 1, needed))
                {
                    static if (isShared)
                    {
                        ulong localControl = _control.rep[i];
                        localControl |= (1UL << available) - 1;
                        _control.rep[i] = localControl;
                    }
                    else
                    {
                        _control.rep[i] |= (1UL << available) - 1;
                    }
                    return result;
                }
            }
            return null;
        }

        pure nothrow @trusted @nogc
        private void[] hugeAlloc(size_t blocks) return scope
        {
            assert(blocks > 64);
            if (_startIdx == _control._rep.length)
            {
                assert((cast(BitVector) _control).allAre1);
                return null;
            }

            auto i = (cast(BitVector)_control).findZeros(blocks, _startIdx * 64);
            if (i == i.max || i + blocks > _blocks) return null;
            // Allocate those bits
            (cast(BitVector) _control)[i .. i + blocks] = 1;
            return cast(void[]) _payload[cast(size_t) (i * blockSize)
                .. cast(size_t) ((i + blocks) * blockSize)];
        }

        // Rounds sizeInBytes to a multiple of blockSize.
        private size_t bytes2blocks(size_t sizeInBytes)
        {
            return (sizeInBytes + blockSize - 1) / blockSize;
        }

        /* Allocates given blocks at the beginning blocks indicated by wordIdx.
        Returns true if allocation was possible, false otherwise. */
        private bool allocateAtFront(size_t wordIdx, uint blocks)
        {
            assert(wordIdx < _control.rep.length && blocks >= 1 && blocks <= 64);
            const mask = (1UL << (64 - blocks)) - 1;
            if (_control.rep[wordIdx] > mask) return false;
            static if (isShared)
            {
                ulong localControl = _control.rep[wordIdx];
                localControl |= ~mask;
                _control.rep[wordIdx] = localControl;
            }
            else
            {
                _control.rep[wordIdx] |= ~mask;
            }
            return true;
        }

        // Since the lock is not pure, only the single threaded 'expand' is pure
        static if (isShared)
        {
            nothrow @trusted @nogc
            bool expand(ref void[] b, immutable size_t delta)
            {
                lock.lock();
                scope(exit) lock.unlock();

                return expandImpl(b, delta);
            }
        }
        else
        {
            pure nothrow @trusted @nogc
            bool expand(ref void[] b, immutable size_t delta)
            {
                return expandImpl(b, delta);
            }
        }

        // If shared, this is protected by a lock inside 'expand'
        pure nothrow @trusted @nogc
        private bool expandImpl(ref void[] b, immutable size_t delta)
        {
            // Dispose with trivial corner cases
            if (b is null || delta == 0) return delta == 0;

            /* To simplify matters, refuse to expand buffers that don't start at a block start (this may be the case for blocks allocated with alignedAllocate).
            */
            if ((b.ptr - _payload.ptr) % blockSize) return false;

            const blocksOld = bytes2blocks(b.length);
            const blocksNew = bytes2blocks(b.length + delta);
            assert(blocksOld <= blocksNew);

            // Possibly we have enough slack at the end of the block!
            if (blocksOld == blocksNew)
            {
                b = b.ptr[0 .. b.length + delta];
                return true;
            }

            assert((b.ptr - _payload.ptr) % blockSize == 0);
            const blockIdx = (b.ptr - _payload.ptr) / blockSize;
            const blockIdxAfter = blockIdx + blocksOld;

            // Try the maximum
            const wordIdx = blockIdxAfter / 64,
                msbIdx = cast(uint) (blockIdxAfter % 64);
            void[] p;
            auto hint = allocateAt(wordIdx, msbIdx,  blocksNew - blocksOld, p);
            if (hint[0] != size_t.max)
            {
                return false;
            }
            // Expansion successful
            assert(p.ptr == b.ptr + blocksOld * blockSize);
            b = b.ptr[0 .. b.length + delta];
            adjustFreshBit(blockIdx + blocksNew);
            return true;
        }

        @system bool reallocate(ref void[] b, size_t newSize)
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            return reallocateImpl(b, newSize);
        }

        // If shared, this is protected by a lock inside 'reallocate'
        private @system bool reallocateImpl(ref void[] b, size_t newSize)
        {
            static bool slowReallocate(Allocator)(ref Allocator a, ref void[] b, size_t s)
            {
                if (b.length == s) return true;
                if (b.length <= s && a.expandImpl(b, s - b.length)) return true;
                auto newB = a.allocateImpl(s);
                if (newB.length != s) return false;
                if (newB.length <= b.length) newB[] = b[0 .. newB.length];
                else newB[0 .. b.length] = b[];
                a.deallocateImpl(b);
                b = newB;
                return true;
            }

            if (!b.ptr)
            {
                b = allocateImpl(newSize);
                return b.length == newSize;
            }
            if (newSize == 0)
            {
                deallocateImpl(b);
                b = null;
                return true;
            }
            if (newSize < b.length)
            {
                // Shrink. Will shrink in place by deallocating the trailing part.
                auto newCapacity = bytes2blocks(newSize) * blockSize;
                deallocateImpl(b[newCapacity .. $]);
                b = b[0 .. newSize];
                return true;
            }
            // Go the slow route
            return slowReallocate(this, b, newSize);
        }

        @system bool alignedReallocate(ref void[] b, size_t newSize, uint a)
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            return alignedReallocateImpl(b, newSize, a);
        }

        // If shared, this is protected by a lock inside 'alignedReallocate'
        private @system bool alignedReallocateImpl(ref void[] b, size_t newSize, uint a)
        {
            static bool slowAlignedReallocate(Allocator)(ref Allocator alloc,
                    ref void[] b, size_t s, uint a)
            {
                if (b.length <= s && b.ptr.alignedAt(a)
                    && alloc.expandImpl(b, s - b.length)) return true;

                auto newB = alloc.alignedAllocateImpl(s, a);
                if (newB.length != s) return false;
                if (newB.length <= b.length) newB[] = b[0 .. newB.length];
                else newB[0 .. b.length] = b[];
                alloc.deallocateImpl(b);
                b = newB;
                return true;
            }

            if (newSize == 0)
            {
                deallocateImpl(b);
                b = null;
                return true;
            }
            // Go the slow route
            return slowAlignedReallocate(this, b, newSize, a);
        }

        nothrow @nogc
        bool deallocate(void[] b)
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            return deallocateImpl(b);
        }

        // If shared, this is protected by a lock inside 'deallocate'
        nothrow @nogc
        private bool deallocateImpl(void[] b)
        {
            if (b is null) return true;

            // Locate position
            immutable pos = b.ptr - _payload.ptr;
            immutable blockIdx = pos / blockSize;

            // Adjust pointer, might be inside a block due to alignedAllocate
            void* begin = cast(void*) (_payload.ptr + blockIdx * blockSize),
                end = cast(void*) (b.ptr + b.length);
            b = begin[0 .. end - begin];
            // Round up size to multiple of block size
            auto blocks = b.length.divideRoundUp(blockSize);

            // Get into details
            auto wordIdx = blockIdx / 64, msbIdx = cast(uint) (blockIdx % 64);
            if (_startIdx > wordIdx) _startIdx = wordIdx;

            // Three stages: heading bits, full words, leftover bits
            if (msbIdx)
            {
                if (blocks + msbIdx <= 64)
                {
                    static if (isShared)
                    {
                        ulong localControl = _control.rep[wordIdx];
                        resetBits(localControl,
                            cast(uint) (64 - msbIdx - blocks),
                            63 - msbIdx);
                        _control.rep[wordIdx] = localControl;
                    }
                    else
                    {
                        resetBits(_control.rep[wordIdx],
                            cast(uint) (64 - msbIdx - blocks),
                            63 - msbIdx);
                    }
                    return true;
                }
                else
                {
                    static if (isShared)
                    {
                        ulong localControl = _control.rep[wordIdx];
                        localControl &= ulong.max << (64 - msbIdx);
                        _control.rep[wordIdx] = localControl;
                    }
                    else
                    {
                        _control.rep[wordIdx] &= ulong.max << (64 - msbIdx);
                    }
                    blocks -= 64 - msbIdx;
                    ++wordIdx;
                    msbIdx = 0;
                }
            }

            // Stage 2: reset one word at a time
            for (; blocks >= 64; blocks -= 64)
            {
                _control.rep[wordIdx++] = 0;
            }

            // Stage 3: deal with leftover bits, if any
            assert(wordIdx <= _control.rep.length);
            if (blocks)
            {
                static if (isShared)
                {
                    ulong localControl = _control.rep[wordIdx];
                    localControl &= ulong.max >> blocks;
                    _control.rep[wordIdx] = localControl;
                }
                else
                {
                    _control.rep[wordIdx] &= ulong.max >> blocks;
                }
            }
            return true;
        }

        // Since the lock is not pure, only the single threaded version is pure
        static if (isShared)
        {
            nothrow @nogc
            bool deallocateAll()
            {
                lock.lock();
                scope(exit) lock.unlock();

                (cast(BitVector) _control)[] = 0;
                _startIdx = 0;
                return true;
            }
        }
        else
        {
            pure nothrow @nogc
            bool deallocateAll()
            {
                _control[] = 0;
                _startIdx = 0;
                return true;
            }
        }

        // Since the lock is not pure, only the single threaded version is pure
        static if (isShared)
        {
            nothrow @safe @nogc
            Ternary empty()
            {
                lock.lock();
                scope(exit) lock.unlock();

                return emptyImpl();
            }
        }
        else
        {
            pure nothrow @safe @nogc
            Ternary empty()
            {
                return Ternary(_control.allAre0());
            }
        }

        pure nothrow @trusted @nogc
        private Ternary emptyImpl()
        {
            return Ternary((cast(BitVector) _control).allAre0());
        }

        // Debug helper
        debug(StdBitmapped)
        private void dump()
        {
            import std.stdio : writefln, writeln;

            ulong controlLen = (cast(BitVector) _control).length;
            writefln("%s @ %s {", typeid(this), cast(void*) (cast(BitVector) _control)._rep.ptr);
            scope(exit) writeln("}");
            assert(_payload.length >= blockSize * _blocks);
            assert(controlLen >= _blocks);
            writefln("  _startIdx=%s; blockSize=%s; blocks=%s",
                _startIdx, blockSize, _blocks);
            if (!controlLen) return;
            uint blockCount = 1;
            bool inAllocatedStore = (cast(BitVector) _control)[0];
            void* start = cast(void*) _payload.ptr;
            for (size_t i = 1;; ++i)
            {
                if (i >= _blocks || (cast(BitVector) _control)[i] != inAllocatedStore)
                {
                    writefln("  %s block at 0x%s, length: %s (%s*%s)",
                        inAllocatedStore ? "Busy" : "Free",
                        cast(void*) start,
                        blockCount * blockSize,
                        blockCount, blockSize);
                    if (i >= _blocks) break;
                    assert(i < controlLen);
                    inAllocatedStore = (cast(BitVector) _control)[i];
                    start = cast(void*) (_payload.ptr + blockCount * blockSize);
                    blockCount = 1;
                }
                else
                {
                    ++blockCount;
                }
            }
        }

        void[] allocateAll() return scope
        {
            static if (isShared)
            {
                lock.lock();
                scope(exit) lock.unlock();
            }

            if (emptyImpl != Ternary.yes) return null;
            (cast(BitVector) _control)[] = 1;
            return cast(void[]) _payload;
        }
    } // Finish Yes.multiblock implementation specifics
    else
    {
        static if (isShared)
        pure nothrow @trusted @nogc
        void[] allocate(const size_t s)
        {
            import core.atomic : cas, atomicLoad, atomicOp;
            import core.bitop : bsr;
            import std.range : iota;
            import std.algorithm.iteration : map;
            import std.array : array;

            if (s.divideRoundUp(blockSize) != 1)
                return null;

            // First zero bit position for all values in the 0 - 255 range
            // for fast lookup
            static immutable ubyte[255] firstZero = iota(255U).map!
                (x => (7 - (bsr((~x) & 0x000000ff)))).array;

            foreach (size_t i; 0 .. _control.length)
            {
                ulong controlVal, newControlVal, bitIndex;
                do
                {
                    bitIndex = 0;
                    newControlVal = 0;
                    controlVal = atomicLoad(_control[i]);

                    // skip all control words which have all bits set
                    if (controlVal == ulong.max)
                        break;

                    // fast lookup of first byte which has at least one zero bit
                    foreach (byteIndex; 0 .. 8)
                    {
                        ulong mask = (0xFFUL << (8 * (7 - byteIndex)));
                        if ((mask & controlVal) != mask)
                        {
                            ubyte byteVal = cast(ubyte) ((mask & controlVal) >> (8 * (7 - byteIndex)));
                            bitIndex += firstZero[byteVal];
                            newControlVal = controlVal | (1UL << (63 - bitIndex));
                            break;
                        }
                        bitIndex += 8;
                    }
                } while (!cas(&_control[i], controlVal, newControlVal));

                auto blockIndex = bitIndex + 64 * i;
                if (controlVal != ulong.max && blockIndex < _blocks)
                {
                    size_t payloadBlockStart = cast(size_t) blockIndex * blockSize;
                    return cast(void[]) _payload[payloadBlockStart .. payloadBlockStart + s];
                }
            }

            return null;
        }

        static if (!isShared)
        pure nothrow @trusted @nogc
        void[] allocate(const size_t s)
        {
            import core.bitop : bsr;
            import std.range : iota;
            import std.algorithm.iteration : map;
            import std.array : array;

            if (s.divideRoundUp(blockSize) != 1)
                return null;

            // First zero bit position for all values in the 0 - 255 range
            // for fast lookup
            static immutable ubyte[255] firstZero = iota(255U).map!
                (x => (7 - (bsr((~x) & 0x000000ff)))).array;

            _startIdx = (_startIdx + 1) % _control.length;
            foreach (size_t idx; 0 .. _control.length)
            {
                size_t i = (idx + _startIdx) % _control.length;
                size_t bitIndex = 0;
                // skip all control words which have all bits set
                if (_control[i] == ulong.max)
                    continue;

                // fast lookup of first byte which has at least one zero bit
                foreach (byteIndex; 0 .. 8)
                {
                    ulong mask = (0xFFUL << (8 * (7 - byteIndex)));
                    if ((mask & _control[i]) != mask)
                    {
                        ubyte byteVal = cast(ubyte) ((mask & _control[i]) >> (8 * (7 - byteIndex)));
                        bitIndex += firstZero[byteVal];
                        _control[i] |= (1UL << (63 - bitIndex));
                        break;
                    }
                    bitIndex += 8;
                }

                auto blockIndex = bitIndex + 64 * i;
                if (blockIndex < _blocks)
                {
                    size_t payloadBlockStart = cast(size_t) blockIndex * blockSize;
                    return cast(void[]) _payload[payloadBlockStart .. payloadBlockStart + s];
                }
            }

            return null;
        }

        nothrow @nogc
        bool deallocate(void[] b)
        {
            static if (isShared)
            import core.atomic : atomicOp;

            if (b is null)
                return true;

            auto blockIndex = (b.ptr - _payload.ptr) / blockSize;
            auto controlIndex = blockIndex / 64;
            auto bitIndex = blockIndex % 64;
            static if (isShared)
            {
                atomicOp!"&="(_control[controlIndex], ~(1UL << (63 - bitIndex)));
            }
            else
            {
                _control[controlIndex] &= ~(1UL << (63 - bitIndex));
            }

            return true;
        }

        pure nothrow @trusted @nogc
        bool expand(ref void[] b, immutable size_t delta)
        {
            if (delta == 0)
                return true;

            immutable newLength = delta + b.length;
            if (b is null || newLength > blockSize)
                return false;

            b = b.ptr[0 .. newLength];
            return true;
        }
    } // Finish No.multiblock implementation specifics

    pure nothrow @trusted @nogc
    Ternary owns(const void[] b) const
    {
        assert(b || b.length == 0, "Corrupt block.");
        return Ternary(b && _payload && (&b[0] >= &_payload[0])
               && (&b[0] + b.length) <= (&_payload[0] + _payload.length));
    }
}

/**
`BitmappedBlock` implements a simple heap consisting of one contiguous area
of memory organized in blocks, each of size `theBlockSize`. A block is a unit
of allocation. A bitmap serves as bookkeeping data, more precisely one bit per
block indicating whether that block is currently allocated or not.

Passing `NullAllocator` as `ParentAllocator` (the default) means user code
manages allocation of the memory block from the outside; in that case
`BitmappedBlock` must be constructed with a `ubyte[]` preallocated block and
has no responsibility regarding the lifetime of its support underlying storage.
If another allocator type is passed, `BitmappedBlock` defines a destructor that
uses the parent allocator to release the memory block. That makes the combination of `AllocatorList`,
`BitmappedBlock`, and a back-end allocator such as `MmapAllocator`
a simple and scalable solution for memory allocation.

There are advantages to storing bookkeeping data separated from the payload
(as opposed to e.g. using `AffixAllocator` to store metadata together with
each allocation). The layout is more compact (overhead is one bit per block),
searching for a free block during allocation enjoys better cache locality, and
deallocation does not touch memory around the payload being deallocated (which
is often cold).

Allocation requests are handled on a first-fit basis. Although linear in
complexity, allocation is in practice fast because of the compact bookkeeping
representation, use of simple and fast bitwise routines, and caching of the
first available block position. A known issue with this general approach is
fragmentation, partially mitigated by coalescing. Since `BitmappedBlock` does
not need to maintain the allocated size, freeing memory implicitly coalesces
free blocks together. Also, tuning `blockSize` has a considerable impact on
both internal and external fragmentation.

If the last template parameter is set to `No.multiblock`, the allocator will only serve
allocations which require at most `theBlockSize`. The `BitmappedBlock` has a specialized
implementation for single-block allocations which allows for greater performance,
at the cost of not being able to allocate more than one block at a time.

The size of each block can be selected either during compilation or at run
time. Statically-known block sizes are frequent in practice and yield slightly
better performance. To choose a block size statically, pass it as the `blockSize`
parameter as in `BitmappedBlock!(4096)`. To choose a block
size parameter, use `BitmappedBlock!(chooseAtRuntime)` and pass the
block size to the constructor.

Params:
    theBlockSize = the length of a block, which must be a multiple of `theAlignment`

    theAlignment = alignment of each block

    ParentAllocator = allocator from which the `BitmappedBlock` will draw memory.
        If set to `NullAllocator`, the storage must be passed via the constructor

    f = `Yes.multiblock` to support allocations spanning across multiple blocks and
        `No.multiblock` to support single block allocations.
        Although limited by single block allocations, `No.multiblock` will generally
        provide higher performance.
*/
struct BitmappedBlock(size_t theBlockSize, uint theAlignment = platformAlignment,
   ParentAllocator = NullAllocator, Flag!"multiblock" f = Yes.multiblock)
{
    version (StdDdoc)
    {
        /**
        Constructs a block allocator given a hunk of memory, or a desired capacity
        in bytes.
        $(UL
        $(LI If `ParentAllocator` is $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator),
        only the constructor taking `data` is defined and the user is responsible for freeing `data` if desired.)
        $(LI Otherwise, both constructors are defined. The `data`-based
        constructor assumes memory has been allocated with the parent allocator.
        The `capacity`-based constructor uses `ParentAllocator` to allocate
        an appropriate contiguous hunk of memory. Regardless of the constructor
        used, the destructor releases the memory by using `ParentAllocator.deallocate`.)
        )
        */
        this(ubyte[] data);

        /// Ditto
        this(ubyte[] data, uint blockSize);

        /// Ditto
        this(size_t capacity);

        /// Ditto
        this(ParentAllocator parent, size_t capacity);

        /// Ditto
        this(size_t capacity, uint blockSize);

        /// Ditto
        this(ParentAllocator parent, size_t capacity, uint blockSize);

        /**
        If `blockSize == chooseAtRuntime`, `BitmappedBlock` offers a read/write
        property `blockSize`. It must be set before any use of the allocator.
        Otherwise (i.e. `theBlockSize` is a legit constant), `blockSize` is
        an alias for `theBlockSize`. Whether constant or variable, must also be
        a multiple of `alignment`. This constraint is `assert`ed statically
        and dynamically.
        */
        alias blockSize = theBlockSize;

        /**
        The _alignment offered is user-configurable statically through parameter
        `theAlignment`, defaulted to `platformAlignment`.
        */
        alias alignment = theAlignment;

        /**
        The _parent allocator. Depending on whether `ParentAllocator` holds state
        or not, this is a member variable or an alias for
        `ParentAllocator.instance`.
        */
        ParentAllocator parent;

        /**
        Returns the actual bytes allocated when `n` bytes are requested, i.e.
        `n.roundUpToMultipleOf(blockSize)`.
        */
        pure nothrow @safe @nogc
        size_t goodAllocSize(size_t n);

        /**
        Returns `Ternary.yes` if `b` belongs to the `BitmappedBlock` object,
        `Ternary.no` otherwise. Never returns `Ternary.unkown`. (This
        method is somewhat tolerant in that accepts an interior slice.)
        */
        pure nothrow @trusted @nogc
        Ternary owns(const void[] b) const;

        /**
        Expands in place a buffer previously allocated by `BitmappedBlock`.
        If instantiated with `No.multiblock`, the expansion fails if the new length
        exceeds `theBlockSize`.
        */
        pure nothrow @trusted @nogc
        bool expand(ref void[] b, immutable size_t delta);

        /**
        Deallocates a block previously allocated with this allocator.
        */
        nothrow @nogc
        bool deallocate(void[] b);

        /**
        Allocates `s` bytes of memory and returns it, or `null` if memory
        could not be allocated.

        The following information might be of help with choosing the appropriate
        block size. Actual allocation occurs in sizes multiple of the block size.
        Allocating one block is the fastest because only one 0 bit needs to be
        found in the metadata. Allocating 2 through 64 blocks is the next cheapest
        because it affects a maximum of two `ulong` in the metadata.
        Allocations greater than 64 blocks require a multiword search through the
        metadata.

        If instantiated with `No.multiblock`, it performs a search for the first zero
        bit in the bitmap and sets it.
        */
        pure nothrow @trusted @nogc
        void[] allocate(const size_t s);

        /**
        Allocates s bytes of memory and returns it, or `null` if memory could not be allocated.
        `allocateFresh` behaves just like allocate, the only difference being that this always
        returns unused(fresh) memory. Although there may still be available space in the `BitmappedBlock`,
        `allocateFresh` could still return null, because all the available blocks have been previously deallocated.
        */
        @trusted void[] allocateFresh(const size_t s);

        /**
        If the `BitmappedBlock` object is empty (has no active allocation), allocates
        all memory within and returns a slice to it. Otherwise, returns `null`
        (i.e. no attempt is made to allocate the largest available block).
        */
        void[] allocateAll();

        /**
        Returns `Ternary.yes` if no memory is currently allocated with this
        allocator, otherwise `Ternary.no`. This method never returns
        `Ternary.unknown`.
        */
        pure nothrow @safe @nogc
        Ternary empty();

        /**
        Forcibly deallocates all memory allocated by this allocator, making it
        available for further allocations. Does not return memory to `ParentAllocator`.
        */
        pure nothrow @nogc
        bool deallocateAll();

        /**
        Reallocates a block previously allocated with `alignedAllocate`. Contractions do not occur in place.
        */
        @system bool alignedReallocate(ref void[] b, size_t newSize, uint a);

        /**
        Reallocates a previously-allocated block. Contractions occur in place.
        */
        @system bool reallocate(ref void[] b, size_t newSize);

        /**
        Allocates a block with specified alignment `a`. The alignment must be a
        power of 2. If `a <= alignment`, function forwards to `allocate`.
        Otherwise, it attempts to overallocate and then adjust the result for
        proper alignment. In the worst case the slack memory is around two blocks.
        */
        void[] alignedAllocate(size_t n, uint a);

        /**
        If `ParentAllocator` is not `NullAllocator` and defines `deallocate`,
        the destructor is defined to deallocate the block held.
        */
        ~this();
    }
    else
    {
        version (StdUnittest)
        @system unittest
        {
            import std.algorithm.comparison : max;
            import std.experimental.allocator.mallocator : AlignedMallocator;
            auto m = cast(ubyte[])(AlignedMallocator.instance.alignedAllocate(1024 * 64,
                                    max(theAlignment, cast(uint) size_t.sizeof)));
            scope(exit) () nothrow @nogc { AlignedMallocator.instance.deallocate(m); }();
            static if (theBlockSize == chooseAtRuntime)
            {
                testAllocator!(() => BitmappedBlock!(theBlockSize, theAlignment, NullAllocator)(m, 64));
            }
            else
            {
                testAllocator!(() => BitmappedBlock!(theBlockSize, theAlignment, NullAllocator)(m));
            }
        }
        mixin BitmappedBlockImpl!(false, f == Yes.multiblock);
    }
}

///
@system unittest
{
    // Create a block allocator on top of a 10KB stack region.
    import std.experimental.allocator.building_blocks.region : InSituRegion;
    import std.traits : hasMember;
    InSituRegion!(10_240, 64) r;
    auto a = BitmappedBlock!(64, 64)(cast(ubyte[])(r.allocateAll()));
    static assert(hasMember!(InSituRegion!(10_240, 64), "allocateAll"));
    const b = a.allocate(100);
    assert(b.length == 100);
}

///
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Flag, Yes;

    enum blockSize = 64;
    enum numBlocks = 10;

    // The 'BitmappedBlock' is implicitly instantiated with Yes.multiblock
    auto a = BitmappedBlock!(blockSize, 8, Mallocator, Yes.multiblock)(numBlocks * blockSize);

    // Instantiated with Yes.multiblock, can allocate more than one block at a time
    void[] buf = a.allocate(2 * blockSize);
    assert(buf.length == 2 * blockSize);
    assert(a.deallocate(buf));

    // Can also allocate less than one block
    buf = a.allocate(blockSize / 2);
    assert(buf.length == blockSize / 2);

    // Expands inside the same block
    assert(a.expand(buf, blockSize / 2));
    assert(buf.length == blockSize);

    // If Yes.multiblock, can expand past the size of a single block
    assert(a.expand(buf, 3 * blockSize));
    assert(buf.length == 4 * blockSize);
    assert(a.deallocate(buf));
}

///
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Flag, No;

    enum blockSize = 64;
    auto a = BitmappedBlock!(blockSize, 8, Mallocator, No.multiblock)(1024 * blockSize);

    // Since instantiated with No.multiblock, can only allocate at most the block size
    void[] buf = a.allocate(blockSize + 1);
    assert(buf is null);

    buf = a.allocate(blockSize);
    assert(buf.length == blockSize);
    assert(a.deallocate(buf));

    // This is also fine, because it's less than the block size
    buf = a.allocate(blockSize / 2);
    assert(buf.length == blockSize / 2);

    // Can expand the buffer until its length is at most 64
    assert(a.expand(buf, blockSize / 2));
    assert(buf.length == blockSize);

    // Cannot expand anymore
    assert(!a.expand(buf, 1));
    assert(a.deallocate(buf));
}

// Test instantiation with stateful allocators
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.building_blocks.region : Region;
    auto r = Region!Mallocator(1024 * 96);
    auto a = BitmappedBlock!(chooseAtRuntime, 8, Region!Mallocator*, No.multiblock)(&r, 1024 * 64, 1024);
}

/**
The threadsafe version of the $(LREF BitmappedBlock).
The semantics of the `SharedBitmappedBlock` are identical to the regular $(LREF BitmappedBlock).

Params:
    theBlockSize = the length of a block, which must be a multiple of `theAlignment`

    theAlignment = alignment of each block

    ParentAllocator = allocator from which the `BitmappedBlock` will draw memory.
        If set to `NullAllocator`, the storage must be passed via the constructor

    f = `Yes.multiblock` to support allocations spanning across multiple blocks and
        `No.multiblock` to support single block allocations.
        Although limited by single block allocations, `No.multiblock` will generally
        provide higher performance.
*/
shared struct SharedBitmappedBlock(size_t theBlockSize, uint theAlignment = platformAlignment,
   ParentAllocator = NullAllocator, Flag!"multiblock" f = Yes.multiblock)
{
    version (StdDdoc)
    {
        /**
        Constructs a block allocator given a hunk of memory, or a desired capacity
        in bytes.
        $(UL
        $(LI If `ParentAllocator` is $(REF_ALTTEXT `NullAllocator`, NullAllocator, std,experimental,allocator,building_blocks,null_allocator),
        only the constructor taking `data` is defined and the user is responsible for freeing `data` if desired.)
        $(LI Otherwise, both constructors are defined. The `data`-based
        constructor assumes memory has been allocated with the parent allocator.
        The `capacity`-based constructor uses `ParentAllocator` to allocate
        an appropriate contiguous hunk of memory. Regardless of the constructor
        used, the destructor releases the memory by using `ParentAllocator.deallocate`.)
        )
        */
        this(ubyte[] data);

        /// Ditto
        this(ubyte[] data, uint blockSize);

        /// Ditto
        this(size_t capacity);

        /// Ditto
        this(ParentAllocator parent, size_t capacity);

        /// Ditto
        this(size_t capacity, uint blockSize);

        /// Ditto
        this(ParentAllocator parent, size_t capacity, uint blockSize);

        /**
        If `blockSize == chooseAtRuntime`, `SharedBitmappedBlock` offers a read/write
        property `blockSize`. It must be set before any use of the allocator.
        Otherwise (i.e. `theBlockSize` is a legit constant), `blockSize` is
        an alias for `theBlockSize`. Whether constant or variable, must also be
        a multiple of `alignment`. This constraint is `assert`ed statically
        and dynamically.
        */
        alias blockSize = theBlockSize;

        /**
        The _alignment offered is user-configurable statically through parameter
        `theAlignment`, defaulted to `platformAlignment`.
        */
        alias alignment = theAlignment;

        /**
        The _parent allocator. Depending on whether `ParentAllocator` holds state
        or not, this is a member variable or an alias for
        `ParentAllocator.instance`.
        */
        ParentAllocator parent;

        /**
        Returns the actual bytes allocated when `n` bytes are requested, i.e.
        `n.roundUpToMultipleOf(blockSize)`.
        */
        pure nothrow @safe @nogc
        size_t goodAllocSize(size_t n);

        /**
        Returns `Ternary.yes` if `b` belongs to the `SharedBitmappedBlock` object,
        `Ternary.no` otherwise. Never returns `Ternary.unkown`. (This
        method is somewhat tolerant in that accepts an interior slice.)
        */
        pure nothrow @trusted @nogc
        Ternary owns(const void[] b) const;

        /**
        Expands in place a buffer previously allocated by `SharedBitmappedBlock`.
        Expansion fails if the new length exceeds the block size.
        */
        bool expand(ref void[] b, immutable size_t delta);

        /**
        Deallocates the given buffer `b`, by atomically setting the corresponding
        bit to `0`. `b` must be valid, and cannot contain multiple adjacent `blocks`.
        */
        nothrow @nogc
        bool deallocate(void[] b);

        /**
        Allocates `s` bytes of memory and returns it, or `null` if memory
        could not be allocated.

        The `SharedBitmappedBlock` cannot allocate more than the given block size.
        Allocations are satisfied by searching the first unset bit in the bitmap,
        and atomically setting it.
        In rare memory pressure scenarios, the allocation could fail.
        */
        nothrow @trusted @nogc
        void[] allocate(const size_t s);

        /**
        Allocates s bytes of memory and returns it, or `null` if memory could not be allocated.
        `allocateFresh` behaves just like allocate, the only difference being that this always
        returns unused(fresh) memory. Although there may still be available space in the `SharedBitmappedBlock`,
        `allocateFresh` could still return null, because all the available blocks have been previously deallocated.
        */
        @trusted void[] allocateFresh(const size_t s);

        /**
        If the `SharedBitmappedBlock` object is empty (has no active allocation), allocates
        all memory within and returns a slice to it. Otherwise, returns `null`
        (i.e. no attempt is made to allocate the largest available block).
        */
        void[] allocateAll();

        /**
        Returns `Ternary.yes` if no memory is currently allocated with this
        allocator, otherwise `Ternary.no`. This method never returns
        `Ternary.unknown`.
        */
        nothrow @safe @nogc
        Ternary empty();

        /**
        Forcibly deallocates all memory allocated by this allocator, making it
        available for further allocations. Does not return memory to `ParentAllocator`.
        */
        nothrow @nogc
        bool deallocateAll();

        /**
        Reallocates a block previously allocated with `alignedAllocate`. Contractions do not occur in place.
        */
        @system bool alignedReallocate(ref void[] b, size_t newSize, uint a);

        /**
        Reallocates a previously-allocated block. Contractions occur in place.
        */
        @system bool reallocate(ref void[] b, size_t newSize);

        /**
        Allocates a block with specified alignment `a`. The alignment must be a
        power of 2. If `a <= alignment`, function forwards to `allocate`.
        Otherwise, it attempts to overallocate and then adjust the result for
        proper alignment. In the worst case the slack memory is around two blocks.
        */
        void[] alignedAllocate(size_t n, uint a);

        /**
        If `ParentAllocator` is not `NullAllocator` and defines `deallocate`,
        the destructor is defined to deallocate the block held.
        */
        ~this();
    }
    else
    {
        version (StdUnittest)
        @system unittest
        {
            import std.algorithm.comparison : max;
            import std.experimental.allocator.mallocator : AlignedMallocator;
            auto m = cast(ubyte[])(AlignedMallocator.instance.alignedAllocate(1024 * 64,
                                    max(theAlignment, cast(uint) size_t.sizeof)));
            scope(exit) () nothrow @nogc { AlignedMallocator.instance.deallocate(m); }();
            static if (theBlockSize == chooseAtRuntime)
            {
                testAllocator!(() => SharedBitmappedBlock!(theBlockSize, theAlignment, NullAllocator)(m, 64));
            }
            else
            {
                testAllocator!(() => SharedBitmappedBlock!(theBlockSize, theAlignment, NullAllocator)(m));
            }
        }
        mixin BitmappedBlockImpl!(true, f == Yes.multiblock);
    }
}

///
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.common : platformAlignment;
    import std.typecons : Flag, Yes, No;

    // Create 'numThreads' threads, each allocating in parallel a chunk of memory
    static void testAlloc(Allocator)(ref Allocator a, size_t allocSize)
    {
        import core.thread : ThreadGroup;
        import std.algorithm.sorting : sort;
        import core.internal.spinlock : SpinLock;

        SpinLock lock = SpinLock(SpinLock.Contention.brief);
        enum numThreads = 10;
        void[][numThreads] buf;
        size_t count = 0;

        // Each threads allocates 'allocSize'
        void fun()
        {
            void[] b = a.allocate(allocSize);
            assert(b.length == allocSize);

            lock.lock();
            scope(exit) lock.unlock();

            buf[count] = b;
            count++;
        }

        auto tg = new ThreadGroup;
        foreach (i; 0 .. numThreads)
        {
            tg.create(&fun);
        }
        tg.joinAll();

        // Sorting the allocations made by each thread, we expect the buffers to be
        // adjacent inside the SharedBitmappedBlock
        sort!((a, b) => a.ptr < b.ptr)(buf[0 .. numThreads]);
        foreach (i; 0 .. numThreads - 1)
        {
            assert(buf[i].ptr + a.goodAllocSize(buf[i].length) <= buf[i + 1].ptr);
        }

        // Deallocate everything
        foreach (i; 0 .. numThreads)
        {
            assert(a.deallocate(buf[i]));
        }
    }

    enum blockSize = 64;
    auto alloc1 = SharedBitmappedBlock!(blockSize, platformAlignment, Mallocator, Yes.multiblock)(1024 * 1024);
    auto alloc2 = SharedBitmappedBlock!(blockSize, platformAlignment, Mallocator, No.multiblock)(1024 * 1024);
    testAlloc(alloc1, 2 * blockSize);
    testAlloc(alloc2, blockSize);
}

@system unittest
{
    // Test chooseAtRuntime
    // Create a block allocator on top of a 10KB stack region.
    import std.experimental.allocator.building_blocks.region : InSituRegion;
    import std.traits : hasMember;
    InSituRegion!(10_240, 64) r;
    uint blockSize = 64;
    auto a = BitmappedBlock!(chooseAtRuntime, 64)(cast(ubyte[])(r.allocateAll()), blockSize);
    static assert(hasMember!(InSituRegion!(10_240, 64), "allocateAll"));
    const b = (() pure nothrow @safe @nogc => a.allocate(100))();
    assert(b.length == 100);
}

pure @safe unittest
{
    import std.typecons : Ternary;

    auto a = (() @trusted => BitmappedBlock!(64, 64, NullAllocator, Yes.multiblock)(new ubyte[10_240]))();
    () nothrow @nogc {
        assert(a.empty == Ternary.yes);
        const b = a.allocate(100);
        assert(b.length == 100);
        assert(a.empty == Ternary.no);
    }();
}

@safe unittest
{
    import std.typecons : Ternary;

    auto a = (() @trusted => SharedBitmappedBlock!(64, 64, NullAllocator, Yes.multiblock)(new ubyte[10_240]))();
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    const b = a.allocate(100);
    assert(b.length == 100);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    testAllocator!(() => BitmappedBlock!(64, 8, GCAllocator)(1024 * 64));
}

version (StdUnittest)
@system unittest
{
    // Test chooseAtRuntime
    import std.experimental.allocator.gc_allocator : GCAllocator;
    uint blockSize = 64;
    testAllocator!(() => BitmappedBlock!(chooseAtRuntime, 8, GCAllocator, Yes.multiblock)(1024 * 64, blockSize));
    testAllocator!(() => BitmappedBlock!(chooseAtRuntime, 8, GCAllocator, No.multiblock)(1024 * 64, blockSize));
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    testAllocator!(() => SharedBitmappedBlock!(64, 8, Mallocator, Yes.multiblock)(1024 * 64));
    testAllocator!(() => SharedBitmappedBlock!(64, 8, Mallocator, No.multiblock)(1024 * 64));
}

version (StdUnittest)
@system unittest
{
    // Test chooseAtRuntime
    import std.experimental.allocator.mallocator : Mallocator;
    uint blockSize = 64;
    testAllocator!(() => SharedBitmappedBlock!(chooseAtRuntime, 8, Mallocator, Yes.multiblock)(1024 * 64, blockSize));
    testAllocator!(() => SharedBitmappedBlock!(chooseAtRuntime, 8, Mallocator, No.multiblock)(1024 * 64, blockSize));
}

@system unittest
{
    static void testAllocateAll(size_t bs, bool isShared = true)(size_t blocks, uint blocksAtATime)
    {
        template attribAllocate(string size)
        {
            static if (isShared)
            {
                const char[] attribAllocate = "(() nothrow @safe @nogc => a.allocate(" ~ size ~ "))()";
            }
            else
            {
                const char[] attribAllocate = "(() pure nothrow @safe @nogc => a.allocate(" ~ size ~ "))()";
            }
        }

        assert(bs);
        import std.typecons : Ternary;
        import std.algorithm.comparison : min;
        import std.experimental.allocator.gc_allocator : GCAllocator;

        static if (isShared)
        {
           // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/bucketizer.d)
*/
module std.experimental.allocator.building_blocks.bucketizer;

/**

A `Bucketizer` uses distinct allocators for handling allocations of sizes in
the intervals $(D [min, min + step - 1]), $(D [min + step, min + 2 * step - 1]),
$(D [min + 2 * step, min + 3 * step - 1]), `...`, $(D [max - step + 1, max]).

`Bucketizer` holds a fixed-size array of allocators and dispatches calls to
them appropriately. The size of the array is $(D (max + 1 - min) / step), which
must be an exact division.

Allocations for sizes smaller than `min` or larger than `max` are illegal
for `Bucketizer`. To handle them separately, `Segregator` may be of use.

*/
struct Bucketizer(Allocator, size_t min, size_t max, size_t step)
{
    import common = std.experimental.allocator.common : roundUpToMultipleOf,
           alignedAt;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    static assert((max - (min - 1)) % step == 0,
        "Invalid limits when instantiating " ~ Bucketizer.stringof);

    // state
    /**
    The array of allocators is publicly available for e.g. initialization and
    inspection.
    */
    Allocator[(max + 1 - min) / step] buckets;

    pure nothrow @safe @nogc
    private Allocator* allocatorFor(size_t n)
    {
        const i = (n - min) / step;
        return i < buckets.length ? &buckets[i] : null;
    }

    /**
    The alignment offered is the same as `Allocator.alignment`.
    */
    enum uint alignment = Allocator.alignment;

    /**
    Rounds up to the maximum size of the bucket in which `bytes` falls.
    */
    pure nothrow @safe @nogc
    size_t goodAllocSize(size_t bytes) const
    {
        // round up bytes such that bytes - min + 1 is a multiple of step
        assert(bytes >= min);
        const min_1 = min - 1;
        return min_1 + roundUpToMultipleOf(bytes - min_1, step);
    }

    /**
    Directs the call to either one of the `buckets` allocators.
    */
    void[] allocate(size_t bytes)
    {
        if (!bytes) return null;
        if (auto a = allocatorFor(bytes))
        {
            const actual = goodAllocSize(bytes);
            auto result = a.allocate(actual);
            return result.ptr ? result.ptr[0 .. bytes] : null;
        }
        return null;
    }

    static if (hasMember!(Allocator, "allocateZeroed"))
    package(std) void[] allocateZeroed()(size_t bytes)
    {
        if (!bytes) return null;
        if (auto a = allocatorFor(bytes))
        {
            const actual = goodAllocSize(bytes);
            auto result = a.allocateZeroed(actual);
            return result.ptr ? result.ptr[0 .. bytes] : null;
        }
        return null;
    }

    /**
    Allocates the requested `bytes` of memory with specified `alignment`.
    Directs the call to either one of the `buckets` allocators. Defined only
    if `Allocator` defines `alignedAllocate`.
    */
    static if (hasMember!(Allocator, "alignedAllocate"))
    void[] alignedAllocate(size_t bytes, uint alignment)
    {
        if (!bytes) return null;
        if (auto a = allocatorFor(bytes))
        {
            const actual = goodAllocSize(bytes);
            auto result = a.alignedAllocate(actual, alignment);
            return result !is null ? (() @trusted => (&result[0])[0 .. bytes])() : null;
        }
        return null;
    }

    /**
    This method allows expansion within the respective bucket range. It succeeds
    if both `b.length` and $(D b.length + delta) fall in a range of the form
    $(D [min + k * step, min + (k + 1) * step - 1]).
    */
    bool expand(ref void[] b, size_t delta)
    {
        if (!b || delta == 0) return delta == 0;
        assert(b.length >= min && b.length <= max);
        const available = goodAllocSize(b.length);
        const desired = b.length + delta;
        if (available < desired) return false;
        b = (() @trusted => b.ptr[0 .. desired])();
        return true;
    }

    /**
    This method allows reallocation within the respective bucket range. If both
    `b.length` and `size` fall in a range of the form $(D [min + k *
    step, min + (k + 1) * step - 1]), then reallocation is in place. Otherwise,
    reallocation with moving is attempted.
    */
    bool reallocate(ref void[] b, size_t size)
    {
        if (size == 0)
        {
            deallocate(b);
            b = null;
            return true;
        }
        if (size >= b.length && expand(b, size - b.length))
        {
            return true;
        }
        assert(b.length >= min && b.length <= max);
        if (goodAllocSize(size) == goodAllocSize(b.length))
        {
            b = b.ptr[0 .. size];
            return true;
        }
        // Move cross buckets
        return common.reallocate(this, b, size);
    }

    /**
    Similar to `reallocate`, with alignment. Defined only if `Allocator`
    defines `alignedReallocate`.
    */
    static if (hasMember!(Allocator, "alignedReallocate"))
    bool alignedReallocate(ref void[] b, size_t size, uint a)
    {
        if (size == 0)
        {
            deallocate(b);
            b = null;
            return true;
        }
        if (size >= b.length && b.ptr.alignedAt(a) && expand(b, size - b.length))
        {
            return true;
        }
        assert(b.length >= min && b.length <= max);
        if (goodAllocSize(size) == goodAllocSize(b.length) && b.ptr.alignedAt(a))
        {
            b = b.ptr[0 .. size];
            return true;
        }
        // Move cross buckets
        return common.alignedReallocate(this, b, size, a);
    }

    /**
    Defined only if `Allocator` defines `owns`. Finds the owner of `b` and forwards the call to it.
    */
    static if (hasMember!(Allocator, "owns"))
    Ternary owns(void[] b)
    {
        if (!b.ptr) return Ternary.no;
        if (auto a = allocatorFor(b.length))
        {
            const actual = goodAllocSize(b.length);
            return a.owns(b.ptr[0 .. actual]);
        }
        return Ternary.no;
    }

    /**
    This method is only defined if `Allocator` defines `deallocate`.
    */
    static if (hasMember!(Allocator, "deallocate"))
    bool deallocate(void[] b)
    {
        if (!b.ptr) return true;
        if (auto a = allocatorFor(b.length))
        {
            a.deallocate(b.ptr[0 .. goodAllocSize(b.length)]);
        }
        return true;
    }

    /**
    This method is only defined if all allocators involved define $(D
    deallocateAll), and calls it for each bucket in turn. Returns `true` if all
    allocators could deallocate all.
    */
    static if (hasMember!(Allocator, "deallocateAll"))
    bool deallocateAll()
    {
        bool result = true;
        foreach (ref a; buckets)
        {
            if (!a.deallocateAll()) result = false;
        }
        return result;
    }

    /**
    This method is only defined if all allocators involved define $(D
    resolveInternalPointer), and tries it for each bucket in turn.
    */
    static if (hasMember!(Allocator, "resolveInternalPointer"))
    Ternary resolveInternalPointer(const void* p, ref void[] result)
    {
        foreach (ref a; buckets)
        {
            Ternary r = a.resolveInternalPointer(p, result);
            if (r == Ternary.yes) return r;
        }
        return Ternary.no;
    }
}

///
@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list : AllocatorList;
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.common : unbounded;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    Bucketizer!(
        FreeList!(
            AllocatorList!(
                (size_t n) => Region!Mallocator(max(n, 1024 * 1024))),
            0, unbounded),
        65, 512, 64) a;
    auto b = a.allocate(400);
    assert(b.length == 400);
    assert(a.owns(b) == Ternary.yes);
    a.deallocate(b);
}

@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list : AllocatorList;
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.common : unbounded;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;

    Bucketizer!(
        FreeList!(
            AllocatorList!(
                (size_t n) => Region!Mallocator(max(n, 1024 * 1024)), Mallocator),
            0, unbounded),
        65, 512, 64) a;

    assert((() pure nothrow @safe @nogc => a.goodAllocSize(65))() == 128);

    auto b = a.allocate(100);
    assert(b.length == 100);
    // Make reallocate use extend
    assert((() nothrow @nogc => a.reallocate(b, 101))());
    assert(b.length == 101);
    // Move cross buckets
    assert((() nothrow @nogc => a.reallocate(b, 200))());
    assert(b.length == 200);
    // Free through realloc
    assert((() nothrow @nogc => a.reallocate(b, 0))());
    assert(b is null);
    // Ensure deallocate inherits from parent allocators
    assert((() nothrow @nogc => a.deallocate(b))());
    assert((() nothrow @nogc => a.deallocateAll())());
}

// Test alignedAllocate
@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.experimental.allocator.gc_allocator : GCAllocator;

    Bucketizer!(BitmappedBlock!(64, 8, GCAllocator), 65, 512, 64) a;
    foreach (ref bucket; a.buckets)
    {
        bucket = BitmappedBlock!(64, 8, GCAllocator)(new ubyte[1024]);
    }

    auto b = a.alignedAllocate(100, 16);
    assert(b.length == 100);
    assert(a.alignedAllocate(42, 16) is null);
    assert(a.alignedAllocate(0, 16) is null);
    assert((() pure nothrow @safe @nogc => a.expand(b, 0))());
    assert(b.length == 100);
    assert((() pure nothrow @safe @nogc => a.expand(b, 28))());
    assert(b.length == 128);
    assert((() pure nothrow @safe @nogc => !a.expand(b, 1))());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.experimental.allocator.gc_allocator : GCAllocator;

    Bucketizer!(BitmappedBlock!(64, 8, GCAllocator), 1, 512, 64) a;
    foreach (ref bucket; a.buckets)
    {
        bucket = BitmappedBlock!(64, 8, GCAllocator)(new ubyte[1024]);
    }

    auto b = a.alignedAllocate(1, 4);
    assert(b.length == 1);
    // Make reallocate use extend
    assert(a.alignedReallocate(b, 11, 4));
    assert(b.length == 11);
    // Make reallocate use use realloc because of alignment change
    assert(a.alignedReallocate(b, 21, 16));
    assert(b.length == 21);
    // Make reallocate use extend
    assert(a.alignedReallocate(b, 22, 16));
    assert(b.length == 22);
    // Move cross buckets
    assert(a.alignedReallocate(b, 101, 16));
    assert(b.length == 101);
    // Free through realloc
    assert(a.alignedReallocate(b, 0, 16));
    assert(b is null);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/fallback_allocator.d)
*/
module std.experimental.allocator.building_blocks.fallback_allocator;

import std.experimental.allocator.common;

/**
`FallbackAllocator` is the allocator equivalent of an "or" operator in
algebra. An allocation request is first attempted with the `Primary`
allocator. If that returns `null`, the request is forwarded to the $(D
Fallback) allocator. All other requests are dispatched appropriately to one of
the two allocators.

In order to work, `FallbackAllocator` requires that `Primary` defines the
`owns` method. This is needed in order to decide which allocator was
responsible for a given allocation.

`FallbackAllocator` is useful for fast, special-purpose allocators backed up
by general-purpose allocators. The example below features a stack region backed
up by the `GCAllocator`.
*/
struct FallbackAllocator(Primary, Fallback)
{
    import std.algorithm.comparison : min;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    // Need both allocators to be stateless
    // This is to avoid using default initialized stateful allocators
    static if (!stateSize!Primary && !stateSize!Fallback)
    version (StdUnittest)
    @system unittest
    {
        testAllocator!(() => FallbackAllocator());
    }

    /// The primary allocator.
    static if (stateSize!Primary) Primary primary;
    else alias primary = Primary.instance;

    /// The fallback allocator.
    static if (stateSize!Fallback) Fallback fallback;
    else alias fallback = Fallback.instance;

    /**
    If both `Primary` and `Fallback` are stateless, `FallbackAllocator`
    defines a static instance called `instance`.
    */
    static if (!stateSize!Primary && !stateSize!Fallback)
    {
        static FallbackAllocator instance;
    }

    /**
    The alignment offered is the minimum of the two allocators' alignment.
    */
    enum uint alignment = min(Primary.alignment, Fallback.alignment);

    /**
    Allocates memory trying the primary allocator first. If it returns $(D
    null), the fallback allocator is tried.
    */
    void[] allocate(size_t s)
    {
        auto result = primary.allocate(s);
        return result.length == s ? result : fallback.allocate(s);
    }

    static if (hasMember!(Primary, "allocateZeroed")
            || (hasMember!(Fallback, "allocateZeroed")))
    package(std) void[] allocateZeroed()(size_t s)
    {
        // Try to allocate with primary.
        static if (hasMember!(Primary, "allocateZeroed"))
        {
            void[] result = primary.allocateZeroed(s);
            if (result.length == s) return result;
        }
        else
        {
            void[] result = primary.allocate(s);
            if (result.length == s)
            {
                (() @trusted => (cast(ubyte[]) result)[] = 0)();
                return result;
            }
        }
        // Allocate with fallback.
        static if (hasMember!(Fallback, "allocateZeroed"))
        {
            return fallback.allocateZeroed(s);
        }
        else
        {
            result = fallback.allocate(s);
            (() @trusted => (cast(ubyte[]) result)[] = 0)(); // OK even if result is null.
            return result;
        }
    }

    /**
    `FallbackAllocator` offers `alignedAllocate` iff at least one of the
    allocators also offers it. It attempts to allocate using either or both.
    */
    static if (hasMember!(Primary, "alignedAllocate")
        || hasMember!(Fallback, "alignedAllocate"))
    void[] alignedAllocate(size_t s, uint a)
    {
        static if (hasMember!(Primary, "alignedAllocate"))
        {{
            auto result = primary.alignedAllocate(s, a);
            if (result.length == s) return result;
        }}
        static if (hasMember!(Fallback, "alignedAllocate"))
        {{
            auto result = fallback.alignedAllocate(s, a);
            if (result.length == s) return result;
        }}
        return null;
    }

    /**

    `expand` is defined if and only if at least one of the allocators
    defines `expand`. It works as follows. If `primary.owns(b)`, then the
    request is forwarded to `primary.expand` if it is defined, or fails
    (returning `false`) otherwise. If `primary` does not own `b`, then
    the request is forwarded to `fallback.expand` if it is defined, or fails
    (returning `false`) otherwise.

    */
    static if (hasMember!(Primary, "owns")
        && (hasMember!(Primary, "expand") || hasMember!(Fallback, "expand")))
    bool expand(ref void[] b, size_t delta)
    {
        if (!delta) return true;
        if (!b.ptr) return false;
        if (primary.owns(b) == Ternary.yes)
        {
            static if (hasMember!(Primary, "expand"))
                return primary.expand(b, delta);
            else
                return false;
        }
        static if (hasMember!(Fallback, "expand"))
            return fallback.expand(b, delta);
        else
            return false;
    }

    /**

    `reallocate` works as follows. If `primary.owns(b)`, then $(D
    primary.reallocate(b, newSize)) is attempted. If it fails, an attempt is
    made to move the allocation from `primary` to `fallback`.

    If `primary` does not own `b`, then $(D fallback.reallocate(b,
    newSize)) is attempted. If that fails, an attempt is made to move the
    allocation from `fallback` to `primary`.

    */
    static if (hasMember!(Primary, "owns"))
    bool reallocate(ref void[] b, size_t newSize)
    {
        bool crossAllocatorMove(From, To)(ref From from, ref To to)
        {
            auto b1 = to.allocate(newSize);
            if (b1.length != newSize) return false;
            if (b.length < newSize) b1[0 .. b.length] = b[];
            else b1[] = b[0 .. newSize];
            static if (hasMember!(From, "deallocate"))
                from.deallocate(b);
            b = b1;
            return true;
        }

        if (b is null || primary.owns(b) == Ternary.yes)
        {
            return primary.reallocate(b, newSize)
                // Move from primary to fallback
                || crossAllocatorMove(primary, fallback);
        }
        return fallback.reallocate(b, newSize)
            // Interesting. Move from fallback to primary.
            || crossAllocatorMove(fallback, primary);
    }

    static if (hasMember!(Primary, "owns")
        && (hasMember!(Primary, "alignedAllocate")
            || hasMember!(Fallback, "alignedAllocate")))
    bool alignedReallocate(ref void[] b, size_t newSize, uint a)
    {
        bool crossAllocatorMove(From, To)(ref From from, ref To to)
        {
            static if (!hasMember!(To, "alignedAllocate"))
            {
                return false;
            }
            else
            {
                auto b1 = to.alignedAllocate(newSize, a);
                if (b1.length != newSize) return false;
                if (b.length < newSize) b1[0 .. b.length] = b[];
                else b1[] = b[0 .. newSize];
                static if (hasMember!(From, "deallocate"))
                    from.deallocate(b);
                b = b1;
                return true;
            }
        }

        static if (hasMember!(Primary, "alignedAllocate"))
        {
            if (b is null || primary.owns(b) == Ternary.yes)
            {
                return primary.alignedReallocate(b, newSize, a)
                    || crossAllocatorMove(primary, fallback);
            }
        }
        static if (hasMember!(Fallback, "alignedAllocate"))
        {
            return fallback.alignedReallocate(b, newSize, a)
                || crossAllocatorMove(fallback, primary);
        }
        else
        {
            return false;
        }
    }

    /**
    `owns` is defined if and only if both allocators define `owns`.
    Returns $(D primary.owns(b) | fallback.owns(b)).
    */
    static if (hasMember!(Primary, "owns") && hasMember!(Fallback, "owns"))
    Ternary owns(void[] b)
    {
        return primary.owns(b) | fallback.owns(b);
    }

    /**
    `resolveInternalPointer` is defined if and only if both allocators
    define it.
    */
    static if (hasMember!(Primary, "resolveInternalPointer")
        && hasMember!(Fallback, "resolveInternalPointer"))
    Ternary resolveInternalPointer(const void* p, ref void[] result)
    {
        Ternary r = primary.resolveInternalPointer(p, result);
        return r == Ternary.no ? fallback.resolveInternalPointer(p, result) : r;
    }

    /**
    `deallocate` is defined if and only if at least one of the allocators
    define    `deallocate`. It works as follows. If `primary.owns(b)`,
    then the request is forwarded to `primary.deallocate` if it is defined,
    or is a no-op otherwise. If `primary` does not own `b`, then the
    request is forwarded to `fallback.deallocate` if it is defined, or is a
    no-op otherwise.
    */
    static if (hasMember!(Primary, "owns") &&
        (hasMember!(Primary, "deallocate")
            || hasMember!(Fallback, "deallocate")))
    bool deallocate(void[] b)
    {
        if (primary.owns(b) == Ternary.yes)
        {
            static if (hasMember!(Primary, "deallocate"))
                return primary.deallocate(b);
            else
                return false;
        }
        else
        {
            static if (hasMember!(Fallback, "deallocate"))
                return fallback.deallocate(b);
            else
                return false;
        }
    }

    /**
    `empty` is defined if both allocators also define it.

    Returns: $(D primary.empty & fallback.empty)
    */
    static if (hasMember!(Primary, "empty")
               && hasMember!(Fallback, "empty"))
    Ternary empty()
    {
        return primary.empty & fallback.empty;
    }
}

@system unittest
{
    import std.conv : text;
    import std.experimental.allocator.building_blocks.region : InSituRegion;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;
    FallbackAllocator!(InSituRegion!16_384, GCAllocator) a;
    // This allocation uses the stack
    auto b1 = a.allocate(1024);
    assert(b1.length == 1024, text(b1.length));
    assert((() pure nothrow @safe @nogc => a.primary.owns(b1))() == Ternary.yes);
    assert((() nothrow => a.reallocate(b1, 2048))());
    assert(b1.length == 2048, text(b1.length));
    assert((() pure nothrow @safe @nogc => a.primary.owns(b1))() == Ternary.yes);
    // This large allocation will go to the GCAllocator
    auto b2 = a.allocate(1024 * 1024);
    assert((() pure nothrow @safe @nogc => a.primary.owns(b2))() == Ternary.no);
    // Ensure deallocate inherits from parent allocators
    () nothrow @nogc { a.deallocate(b1); }();
    () nothrow @nogc { a.deallocate(b2); }();
}

@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlockWithInternalPointers;
    import std.typecons : Ternary;

    alias A =
        FallbackAllocator!(
            BitmappedBlockWithInternalPointers!(4096),
            BitmappedBlockWithInternalPointers!(4096)
        );

    A a = A(
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024]),
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024])
    );

    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    auto b = a.allocate(201);
    assert(b.length == 201);
    assert(a.reallocate(b, 202));
    assert(b.length == 202);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.typecons : Ternary;

    auto a = FallbackAllocator!(BorrowedRegion!(), BorrowedRegion!())(
                BorrowedRegion!()(new ubyte[4096 * 1024]),
                BorrowedRegion!()(new ubyte[4096 * 1024]));

    auto b = a.alignedAllocate(42, 8);
    assert(b.length == 42);
    assert((() nothrow @nogc => a.alignedReallocate(b, 100, 8))());
    assert(b.length == 100);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlockWithInternalPointers;
    import std.typecons : Ternary;

    alias A =
        FallbackAllocator!(
            BitmappedBlockWithInternalPointers!(4096),
            BitmappedBlockWithInternalPointers!(4096)
        );

    // Run testAllocator here since both allocators stateful
    testAllocator!(
        () => A(
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024]),
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024])
        )
    );
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;

    alias a = FallbackAllocator!(Mallocator, Mallocator).instance;

    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
}

/*
Forwards an argument from one function to another
*/
private auto ref forward(alias arg)()
{
    static if (__traits(isRef, arg))
    {
        return arg;
    }
    else
    {
        import std.algorithm.mutation : move;
        return move(arg);
    }
}

@safe unittest
{
    void fun(T)(auto ref T, string) { /* ... */ }
    void gun(T...)(auto ref T args)
    {
        fun(forward!(args[0]), forward!(args[1]));
    }
    gun(42, "hello");
    int x;
    gun(x, "hello");
}

@safe unittest
{
    static void checkByRef(T)(auto ref T value)
    {
        static assert(__traits(isRef, value));
    }

    static void checkByVal(T)(auto ref T value)
    {
        static assert(!__traits(isRef, value));
    }

    static void test1(ref int a) { checkByRef(forward!a); }
    static void test2(int a) { checkByVal(forward!a); }
    static void test3() { int a; checkByVal(forward!a); }
}

/**
Convenience function that uses type deduction to return the appropriate
`FallbackAllocator` instance. To initialize with allocators that don't have
state, use their `it` static member.
*/
FallbackAllocator!(Primary, Fallback)
fallbackAllocator(Primary, Fallback)(auto ref Primary p, auto ref Fallback f)
{
    alias R = FallbackAllocator!(Primary, Fallback);

    static if (stateSize!Primary)
        static if (stateSize!Fallback)
            return R(forward!p, forward!f);
        else
            return R(forward!p);
    else
        static if (stateSize!Fallback)
            return R(forward!f);
        else
            return R();
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;
    auto a = fallbackAllocator(Region!GCAllocator(1024), GCAllocator.instance);
    auto b1 = a.allocate(1020);
    assert(b1.length == 1020);
    assert(a.primary.owns(b1) == Ternary.yes);
    auto b2 = a.allocate(10);
    assert(b2.length == 10);
    assert(a.primary.owns(b2) == Ternary.no);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    testAllocator!(() => fallbackAllocator(Region!GCAllocator(1024), GCAllocator.instance));
}

// Ensure `owns` inherits function attributes
@system unittest
{
    import std.experimental.allocator.building_blocks.region : InSituRegion;
    import std.typecons : Ternary;

    FallbackAllocator!(InSituRegion!16_384, InSituRegion!16_384) a;
    auto buff = a.allocate(42);
    assert((() pure nothrow @safe @nogc => a.owns(buff))() == Ternary.yes);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;

    auto a = fallbackAllocator(GCAllocator.instance, GCAllocator.instance);
    auto b = a.allocate(1020);
    assert(b.length == 1020);

    void[] p;
    assert((() nothrow @safe @nogc => a.resolveInternalPointer(null, p))() == Ternary.no);
    assert((() nothrow @safe @nogc => a.resolveInternalPointer(&b[0], p))() == Ternary.yes);
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.typecons : Ternary;

    alias A = FallbackAllocator!(BorrowedRegion!(), BorrowedRegion!());
    auto a = A(BorrowedRegion!()(new ubyte[16_384]), BorrowedRegion!()(new ubyte[16_384]));

    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() nothrow @safe @nogc => a.expand(b, 58))());
    assert(b.length == 100);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/free_list.d)
*/
module std.experimental.allocator.building_blocks.free_list;

import std.experimental.allocator.common;
import std.typecons : Flag, Yes, No;

/**

$(HTTP en.wikipedia.org/wiki/Free_list, Free list allocator), stackable on top of
another allocator. Allocation requests between `min` and `max` bytes are
rounded up to `max` and served from a singly-linked list of buffers
deallocated in the past. All other allocations are directed to $(D
ParentAllocator). Due to the simplicity of free list management, allocations
from the free list are fast. If `adaptive` is set to `Yes.adaptive`,
the free list gradually reduces its size if allocations tend to use the parent
allocator much more than the lists' available nodes.

One instantiation is of particular interest: $(D FreeList!(0, unbounded)) puts
every deallocation in the freelist, and subsequently serves any allocation from
the freelist (if not empty). There is no checking of size matching, which would
be incorrect for a freestanding allocator but is both correct and fast when an
owning allocator on top of the free list allocator (such as `Segregator`) is
already in charge of handling size checking.

The following methods are defined if `ParentAllocator` defines them, and
forward to it: `expand`, `owns`, `reallocate`.

*/
struct FreeList(ParentAllocator,
    size_t minSize, size_t maxSize = minSize,
    Flag!"adaptive" adaptive = No.adaptive)
{
    import std.conv : text;
    import std.exception : enforce;
    import std.traits : hasMember;
    import std.typecons : Ternary;
    import std.experimental.allocator.building_blocks.null_allocator : NullAllocator;

    static assert(minSize != unbounded, "Use minSize = 0 for no low bound.");
    static assert(maxSize >= (void*).sizeof,
        "Maximum size must accommodate a pointer.");

    private enum unchecked = minSize == 0 && maxSize == unbounded;

    private enum hasTolerance = !unchecked && (minSize != maxSize
        || maxSize == chooseAtRuntime);

    static if (minSize == chooseAtRuntime)
    {
        /**
        Returns the smallest allocation size eligible for allocation from the
        freelist. (If $(D minSize != chooseAtRuntime), this is simply an alias
        for `minSize`.)
        */
        @property size_t min() const
        {
            assert(_min != chooseAtRuntime);
            return _min;
        }
        /**
        If `FreeList` has been instantiated with $(D minSize ==
        chooseAtRuntime), then the `min` property is writable. Setting it
        must precede any allocation.

        Params:
        low = new value for `min`

        Precondition: $(D low <= max), or $(D maxSize == chooseAtRuntime) and
        `max` has not yet been initialized. Also, no allocation has been
        yet done with this allocator.

        Postcondition: $(D min == low)
        */
        @property void min(size_t low)
        {
            assert(low <= max || max == chooseAtRuntime);
            minimize;
            _min = low;
        }
    }
    else
    {
        alias min = minSize;
    }

    static if (maxSize == chooseAtRuntime)
    {
        /**
        Returns the largest allocation size eligible for allocation from the
        freelist. (If $(D maxSize != chooseAtRuntime), this is simply an alias
        for `maxSize`.) All allocation requests for sizes greater than or
        equal to `min` and less than or equal to `max` are rounded to $(D
        max) and forwarded to the parent allocator. When the block fitting the
        same constraint gets deallocated, it is put in the freelist with the
        allocated size assumed to be `max`.
        */
        @property size_t max() const { return _max; }

        /**
        If `FreeList` has been instantiated with $(D maxSize ==
        chooseAtRuntime), then the `max` property is writable. Setting it
        must precede any allocation.

        Params:
        high = new value for `max`

        Precondition: $(D high >= min), or $(D minSize == chooseAtRuntime) and
        `min` has not yet been initialized. Also $(D high >= (void*).sizeof). Also, no allocation has been yet done with this allocator.

        Postcondition: $(D max == high)
        */
        @property void max(size_t high)
        {
            assert((high >= min || min == chooseAtRuntime)
                && high >= (void*).sizeof);
            minimize;
            _max = high;
        }

        @system unittest
        {
            import std.experimental.allocator.common : chooseAtRuntime;
            import std.experimental.allocator.mallocator : Mallocator;

            FreeList!(Mallocator, chooseAtRuntime, chooseAtRuntime) a;
            a.min = 64;
            a.max = 128;
            assert(a.min == 64);
            assert(a.max == 128);
        }
    }
    else
    {
        alias max = maxSize;
    }

    private bool tooSmall(size_t n) const
    {
        static if (minSize == 0) return false;
        else return n < min;
    }

    private bool tooLarge(size_t n) const
    {
        static if (maxSize == unbounded) return false;
        else return n > max;
    }

    private bool freeListEligible(size_t n) const
    {
        static if (unchecked)
        {
            return true;
        }
        else
        {
            static if (minSize == 0)
            {
                if (!n) return false;
            }
            static if (minSize == maxSize && minSize != chooseAtRuntime)
                return n == maxSize;
            else
                return !tooSmall(n) && !tooLarge(n);
        }
    }

    static if (!unchecked)
    private void[] blockFor(Node* p)
    {
        assert(p);
        return (cast(void*) p)[0 .. max];
    }

    // statistics
    static if (adaptive == Yes.adaptive)
    {
        private enum double windowLength = 1000.0;
        private enum double tooFewMisses = 0.01;
        private double probMiss = 1.0; // start with a high miss probability
        private uint accumSamples, accumMisses;

        void updateStats()
        {
            assert(accumSamples >= accumMisses);
            /*
            Given that for the past windowLength samples we saw misses with
            estimated probability probMiss, and assuming the new sample wasMiss or
            not, what's the new estimated probMiss?
            */
            probMiss = (probMiss * windowLength + accumMisses)
                / (windowLength + accumSamples);
            assert(probMiss <= 1.0);
            accumSamples = 0;
            accumMisses = 0;
            // If probability to miss is under x%, yank one off the freelist
            static if (!unchecked)
            {
                if (probMiss < tooFewMisses && _root)
                {
                    auto b = blockFor(_root);
                    _root = _root.next;
                    parent.deallocate(b);
                }
            }
        }
    }

    private struct Node { Node* next; }
    static assert(ParentAllocator.alignment >= Node.alignof);

    // state
    /**
    The parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator) ParentAllocator parent;
    else alias parent = ParentAllocator.instance;
    private Node* root;
    static if (minSize == chooseAtRuntime) private size_t _min = chooseAtRuntime;
    static if (maxSize == chooseAtRuntime) private size_t _max = chooseAtRuntime;

    /**
    Alignment offered.
    */
    alias alignment = ParentAllocator.alignment;

    /**
    If $(D maxSize == unbounded), returns  `parent.goodAllocSize(bytes)`.
    Otherwise, returns `max` for sizes in the interval $(D [min, max]), and
    `parent.goodAllocSize(bytes)` otherwise.

    Precondition:
    If set at runtime, `min` and/or `max` must be initialized
    appropriately.

    Postcondition:
    $(D result >= bytes)
    */
    size_t goodAllocSize(size_t bytes)
    {
        assert(minSize != chooseAtRuntime && maxSize != chooseAtRuntime);
        static if (maxSize != unbounded)
        {
            if (freeListEligible(bytes))
            {
                assert(parent.goodAllocSize(max) == max,
                    text("Wrongly configured freelist: maximum should be ",
                        parent.goodAllocSize(max), " instead of ", max));
                return max;
            }
        }
        return parent.goodAllocSize(bytes);
    }

    private void[] allocateEligible(string fillMode)(size_t bytes)
    if (fillMode == "void" || fillMode == "zero")
    {
        enum bool isFillZero = fillMode == "zero";
        assert(bytes);
        if (root)
        {
            // faster
            auto result = (cast(ubyte*) root)[0 .. bytes];
            root = root.next;
            static if (isFillZero) result[0 .. bytes] = 0;
            return result;
        }
        // slower
        static if (hasTolerance)
        {
            immutable toAllocate = max;
        }
        else
        {
            alias toAllocate = bytes;
        }
        assert(toAllocate == max || max == unbounded);
        static if (isFillZero)
            auto result = parent.allocateZeroed(toAllocate);
        else
            auto result = parent.allocate(toAllocate);
        static if (hasTolerance)
        {
            if (result) result = result.ptr[0 .. bytes];
        }
        static if (adaptive == Yes.adaptive)
        {
            ++accumMisses;
            updateStats;
        }
        return result;
    }

    /**
    Allocates memory either off of the free list or from the parent allocator.
    If `n` is within $(D [min, max]) or if the free list is unchecked
    ($(D minSize == 0 && maxSize == size_t.max)), then the free list is
    consulted first. If not empty (hit), the block at the front of the free
    list is removed from the list and returned. Otherwise (miss), a new block
    of `max` bytes is allocated, truncated to `n` bytes, and returned.

    Params:
    n = number of bytes to allocate

    Returns:
    The allocated block, or `null`.

    Precondition:
    If set at runtime, `min` and/or `max` must be initialized
    appropriately.

    Postcondition: $(D result.length == bytes || result is null)
    */
    void[] allocate(size_t n)
    {
        static if (adaptive == Yes.adaptive) ++accumSamples;
        assert(n < size_t.max / 2);
        // fast path
        if (freeListEligible(n))
        {
            return allocateEligible!"void"(n);
        }
        // slower
        static if (adaptive == Yes.adaptive)
        {
            updateStats;
        }
        return parent.allocate(n);
    }

    static if (hasMember!(ParentAllocator, "allocateZeroed"))
    package(std) void[] allocateZeroed()(size_t n)
    {
        static if (adaptive == Yes.adaptive) ++accumSamples;
        assert(n < size_t.max / 2);
        // fast path
        if (freeListEligible(n))
        {
            return allocateEligible!"zero"(n);
        }
        // slower
        static if (adaptive == Yes.adaptive)
        {
            updateStats;
        }
        return parent.allocateZeroed(n);
    }

    // Forwarding methods
    mixin(forwardToMember("parent",
        "expand", "owns", "reallocate"));

    /**
    If `block.length` is within $(D [min, max]) or if the free list is
    unchecked ($(D minSize == 0 && maxSize == size_t.max)), then inserts the
    block at the front of the free list. For all others, forwards to $(D
    parent.deallocate) if `Parent.deallocate` is defined.

    Params:
    block = Block to deallocate.

    Precondition:
    If set at runtime, `min` and/or `max` must be initialized
    appropriately. The block must have been allocated with this
    freelist, and no dynamic changing of `min` or `max` is allowed to
    occur between allocation and deallocation.
    */
    bool deallocate(void[] block)
    {
        if (freeListEligible(block.length))
        {
            if (min == 0)
            {
                // In this case a null pointer might have made it this far.
                if (block is null) return true;
            }
            auto t = root;
            root = cast(Node*) block.ptr;
            root.next = t;
            return true;
        }
        static if (hasMember!(ParentAllocator, "deallocate"))
            return parent.deallocate(block);
        else
            return false;
    }

    /**
    Defined only if `ParentAllocator` defines `deallocateAll`. If so,
    forwards to it and resets the freelist.
    */
    static if (hasMember!(ParentAllocator, "deallocateAll"))
    bool deallocateAll()
    {
        root = null;
        return parent.deallocateAll();
    }

    /**
    Nonstandard function that minimizes the memory usage of the freelist by
    freeing each element in turn. Defined only if `ParentAllocator` defines
    `deallocate`. $(D FreeList!(0, unbounded)) does not have this function.
    */
    static if (hasMember!(ParentAllocator, "deallocate") && !unchecked)
    void minimize()
    {
        while (root)
        {
            auto nuke = blockFor(root);
            root = root.next;
            parent.deallocate(nuke);
        }
    }

    /**
    If `ParentAllocator` defines `deallocate`, the list frees all nodes
    on destruction. $(D FreeList!(0, unbounded)) does not deallocate the memory
    on destruction.
    */
    static if (!is(ParentAllocator == NullAllocator) &&
        hasMember!(ParentAllocator, "deallocate") && !unchecked)
    ~this()
    {
        minimize();
    }
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.building_blocks.stats_collector
        : StatsCollector, Options;

    struct StatsCollectorWrapper {
        ~this()
        {
            // buf2 should still be around and buf1 deallocated
            assert(parent.numDeallocate == 1);
            assert(parent.bytesUsed == 16);
        }
        static StatsCollector!(Mallocator, Options.all) parent;
        alias parent this;
    }

    FreeList!(StatsCollectorWrapper, 16, 16) fl;
    auto buf1 = fl.allocate(16);
    auto buf2 = fl.allocate(16);
    assert(fl.parent.bytesUsed == 32);

    // After this, the list has 1 node, so no actual deallocation by Mallocator
    fl.deallocate(buf1);
    assert(fl.parent.bytesUsed == 32);

    // Destruction should only deallocate the node
    destroy(fl);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    FreeList!(GCAllocator, 0, 8) fl;
    assert(fl.root is null);
    auto b1 = fl.allocate(7);
    fl.allocate(8);
    assert(fl.root is null);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { fl.deallocate(b1); }();
    assert(fl.root !is null);
    fl.allocate(8);
    assert(fl.root is null);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    FreeList!(GCAllocator, 0, 16) fl;
    // Not @nogc because of std.conv.text
    assert((() nothrow @safe /*@nogc*/ => fl.goodAllocSize(1))() == 16);
}

// Test that deallocateAll infers from parent
@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    auto fl = FreeList!(BorrowedRegion!(), 0, 16)(BorrowedRegion!()(new ubyte[1024 * 64]));
    auto b = fl.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => fl.expand(b, 48))());
    assert(b.length == 90);
    assert((() nothrow @nogc => fl.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() nothrow @nogc => fl.deallocateAll())());
}

/**
Free list built on top of exactly one contiguous block of memory. The block is
assumed to have been allocated with `ParentAllocator`, and is released in
`ContiguousFreeList`'s destructor (unless `ParentAllocator` is $(D
NullAllocator)).

`ContiguousFreeList` has most advantages of `FreeList` but fewer
disadvantages. It has better cache locality because items are closer to one
another. It imposes less fragmentation on its parent allocator.

The disadvantages of `ContiguousFreeList` over `FreeList` are its pay
upfront model (as opposed to `FreeList`'s pay-as-you-go approach), and a
hard limit on the number of nodes in the list. Thus, a large number of long-
lived objects may occupy the entire block, making it unavailable for serving
allocations from the free list. However, an absolute cap on the free list size
may be beneficial.

The options $(D minSize == unbounded) and $(D maxSize == unbounded) are not
available for `ContiguousFreeList`.
*/
struct ContiguousFreeList(ParentAllocator,
     size_t minSize, size_t maxSize = minSize)
{
    import std.experimental.allocator.building_blocks.null_allocator
        : NullAllocator;
    import std.experimental.allocator.building_blocks.stats_collector
        : StatsCollector, Options;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    alias Impl = FreeList!(NullAllocator, minSize, maxSize);
    enum unchecked = minSize == 0 && maxSize == unbounded;
    alias Node = Impl.Node;

    alias SParent = StatsCollector!(ParentAllocator, Options.bytesUsed);

    // state
    /**
    The parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    SParent parent;
    FreeList!(NullAllocator, minSize, maxSize) fl;
    void[] support;
    size_t allocated;

    /// Alignment offered.
    enum uint alignment = (void*).alignof;

    private void initialize(ubyte[] buffer, size_t itemSize = fl.max)
    {
        assert(itemSize != unbounded && itemSize != chooseAtRuntime);
        assert(buffer.ptr.alignedAt(alignment));
        immutable available = buffer.length / itemSize;
        if (available == 0) return;
        support = buffer;
        fl.root = cast(Node*) buffer.ptr;
        auto past = cast(Node*) (buffer.ptr + available * itemSize);
        for (auto n = fl.root; ; )
        {
            auto next = cast(Node*) (cast(ubyte*) n + itemSize);
            if (next == past)
            {
                n.next = null;
                break;
            }
            assert(next < past);
            assert(n < next);
            n.next = next;
            n = next;
        }
    }

    /**
    Constructors setting up the memory structured as a free list.

    Params:
    buffer = Buffer to structure as a free list. If `ParentAllocator` is not
    `NullAllocator`, the buffer is assumed to be allocated by `parent`
    and will be freed in the destructor.
    parent = Parent allocator. For construction from stateless allocators, use
    their `instance` static member.
    bytes = Bytes (not items) to be allocated for the free list. Memory will be
    allocated during construction and deallocated in the destructor.
    max = Maximum size eligible for freelisting. Construction with this
    parameter is defined only if $(D maxSize == chooseAtRuntime) or $(D maxSize
    == unbounded).
    min = Minimum size eligible for freelisting. Construction with this
    parameter is defined only if $(D minSize == chooseAtRuntime). If this
    condition is met and no `min` parameter is present, `min` is
    initialized with `max`.
    */
    static if (!stateSize!ParentAllocator)
    this(ubyte[] buffer)
    {
        initialize(buffer);
    }

    /// ditto
    static if (stateSize!ParentAllocator)
    this(ParentAllocator parent, ubyte[] buffer)
    {
        initialize(buffer);
        this.parent = SParent(parent);
    }

    /// ditto
    static if (!stateSize!ParentAllocator)
    this(size_t bytes)
    {
        initialize(cast(ubyte[])(ParentAllocator.instance.allocate(bytes)));
    }

    /// ditto
    static if (stateSize!ParentAllocator)
    this(ParentAllocator parent, size_t bytes)
    {
        initialize(cast(ubyte[])(parent.allocate(bytes)));
        this.parent = SParent(parent);
    }

    /// ditto
    static if (!stateSize!ParentAllocator
        && (maxSize == chooseAtRuntime || maxSize == unbounded))
    this(size_t bytes, size_t max)
    {
        static if (maxSize == chooseAtRuntime) fl.max = max;
        static if (minSize == chooseAtRuntime) fl.min = max;
        initialize(cast(ubyte[])(parent.allocate(bytes)), max);
    }

    /// ditto
    static if (stateSize!ParentAllocator
        && (maxSize == chooseAtRuntime || maxSize == unbounded))
    this(ParentAllocator parent, size_t bytes, size_t max)
    {
        static if (maxSize == chooseAtRuntime) fl.max = max;
        static if (minSize == chooseAtRuntime) fl.min = max;
        initialize(cast(ubyte[])(parent.allocate(bytes)), max);
        this.parent = SParent(parent);
    }

    /// ditto
    static if (!stateSize!ParentAllocator
        && (maxSize == chooseAtRuntime || maxSize == unbounded)
        && minSize == chooseAtRuntime)
    this(size_t bytes, size_t min, size_t max)
    {
        static if (maxSize == chooseAtRuntime) fl.max = max;
        fl.min = min;
        initialize(cast(ubyte[])(parent.allocate(bytes)), max);
        static if (stateSize!ParentAllocator)
            this.parent = SParent(parent);
    }

    /// ditto
    static if (stateSize!ParentAllocator
        && (maxSize == chooseAtRuntime || maxSize == unbounded)
        && minSize == chooseAtRuntime)
    this(ParentAllocator parent, size_t bytes, size_t min, size_t max)
    {
        static if (maxSize == chooseAtRuntime) fl.max = max;
        fl.min = min;
        initialize(cast(ubyte[])(parent.allocate(bytes)), max);
        static if (stateSize!ParentAllocator)
            this.parent = SParent(parent);
    }

    /**
    If `n` is eligible for freelisting, returns `max`. Otherwise, returns
    `parent.goodAllocSize(n)`.

    Precondition:
    If set at runtime, `min` and/or `max` must be initialized
    appropriately.

    Postcondition:
    $(D result >= bytes)
    */
    size_t goodAllocSize(size_t n)
    {
        if (fl.freeListEligible(n)) return fl.max;
        return parent.goodAllocSize(n);
    }

    /**
    Allocate `n` bytes of memory. If `n` is eligible for freelist and the
    freelist is not empty, pops the memory off the free list. In all other
    cases, uses the parent allocator.
    */
    void[] allocate(size_t n)
    {
        auto result = fl.allocate(n);
        if (result)
        {
            // Only case we care about: eligible sizes allocated from us
            ++allocated;
            return result;
        }
        // All others, allocate from parent
        return parent.allocate(n);
    }

    /**
    Defined if `ParentAllocator` defines it. Checks whether the block
    belongs to this allocator.
    */
    static if (hasMember!(SParent, "owns") || unchecked)
    // Ternary owns(const void[] b) const ?
    Ternary owns(void[] b)
    {
        if ((() @trusted => support && b
                            && (&support[0] <= &b[0])
                            && (&b[0] < &support[0] + support.length)
            )())
            return Ternary.yes;
        static if (unchecked)
            return Ternary.no;
        else
            return parent.owns(b);
    }

    /**
    Deallocates `b`. If it's of eligible size, it's put on the free list.
    Otherwise, it's returned to `parent`.

    Precondition: `b` has been allocated with this allocator, or is $(D
    null).
    */
    bool deallocate(void[] b)
    {
        if (support.ptr <= b.ptr && b.ptr < support.ptr + support.length)
        {
            // we own this guy
            assert(fl.freeListEligible(b.length));
            assert(allocated);
            --allocated;
            // Put manually in the freelist
            auto t = fl.root;
            fl.root = cast(Node*) b.ptr;
            fl.root.next = t;
            return true;
        }
        return parent.deallocate(b);
    }

    /**
    Deallocates everything from the parent.
    */
    static if (hasMember!(ParentAllocator, "deallocateAll")
        && stateSize!ParentAllocator)
    bool deallocateAll()
    {
        bool result = fl.deallocateAll && parent.deallocateAll;
        allocated = 0;
        return result;
    }

    /**
    Returns `Ternary.yes` if no memory is currently allocated with this
    allocator, `Ternary.no` otherwise. This method never returns
    `Ternary.unknown`.
    */
    Ternary empty()
    {
        return Ternary(allocated == 0 && parent.bytesUsed == 0);
    }
}

///
@safe unittest
{
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.gc_allocator : GCAllocator;

    import std.experimental.allocator.common : unbounded;

    alias ScalableFreeList = AllocatorList!((n) =>
        ContiguousFreeList!(GCAllocator, 0, unbounded)(4096)
    );
}

@system unittest
{
    import std.experimental.allocator.building_blocks.null_allocator
        : NullAllocator;
    import std.typecons : Ternary;
    alias A = ContiguousFreeList!(NullAllocator, 0, 64);
    auto a = A(new ubyte[1024]);

    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);

    assert((() pure nothrow @safe @nogc => a.goodAllocSize(15))() == 64);
    assert((() pure nothrow @safe @nogc => a.goodAllocSize(65))()
            == (() nothrow @safe @nogc => NullAllocator.instance.goodAllocSize(65))());

    auto b = a.allocate(100);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    assert(b.length == 0);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(b); }();
    b = a.allocate(64);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
    assert(b.length == 64);
    assert((() nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() nothrow @safe @nogc => a.owns(null))() == Ternary.no);
    () nothrow @nogc { a.deallocate(b); }();
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;
    alias A = ContiguousFreeList!(Region!GCAllocator, 0, 64);
    auto a = A(Region!GCAllocator(1024 * 4), 1024);

    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);

    assert((() pure nothrow @safe @nogc => a.goodAllocSize(15))() == 64);
    assert((() pure nothrow @safe @nogc => a.goodAllocSize(65))()
            == (() pure nothrow @safe @nogc => a.parent.goodAllocSize(65))());

    auto b = a.allocate(100);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
    assert(a.allocated == 0);
    assert(b.length == 100);
    // Ensure deallocate inherits from parent
    assert((() nothrow @nogc => a.deallocate(b))());
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    b = a.allocate(64);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
    assert(b.length == 64);
    assert(a.reallocate(b, 100));
    assert(b.length == 100);
    assert((() nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() nothrow @safe @nogc => a.owns(null))() == Ternary.no);
    // Test deallocate infers from parent
    assert((() nothrow @nogc => a.deallocate(b))());
    assert((() nothrow @nogc => a.deallocateAll())());
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    alias A = ContiguousFreeList!(GCAllocator, 64, 64);
    auto a = A(1024);
    const b = a.allocate(100);
    assert(b.length == 100);
}

/**
FreeList shared across threads. Allocation and deallocation are lock-free. The
parameters have the same semantics as for `FreeList`.

`expand` is defined to forward to `ParentAllocator.expand`
(it must be also `shared`).
*/
struct SharedFreeList(ParentAllocator,
    size_t minSize, size_t maxSize = minSize, size_t approxMaxNodes = unbounded)
{
    import std.conv : text;
    import std.exception : enforce;
    import std.traits : hasMember;

    static if (hasMember!(ParentAllocator, "owns"))
    {
        import std.typecons : Ternary;
    }

    static assert(approxMaxNodes, "approxMaxNodes must not be null.");
    static assert(minSize != unbounded, "Use minSize = 0 for no low bound.");
    static assert(maxSize >= (void*).sizeof,
        "Maximum size must accommodate a pointer.");

    import core.atomic : atomicOp, cas;
    import core.internal.spinlock : SpinLock;

    private enum unchecked = minSize == 0 && maxSize == unbounded;

    static if (minSize != chooseAtRuntime)
    {
        alias min = minSize;
    }
    else
    {
        private shared size_t _min = chooseAtRuntime;
        @property size_t min() const shared
        {
            assert(_min != chooseAtRuntime);
            return _min;
        }
        @property void min(size_t x) shared
        {
            enforce(x <= max);
            enforce(cas(&_min, chooseAtRuntime, x),
                "SharedFreeList.min must be initialized exactly once.");
        }
        static if (maxSize == chooseAtRuntime)
        {
            // Both bounds can be set, provide one function for setting both in
            // one shot.
            void setBounds(size_t low, size_t high) shared
            {
                enforce(low <= high && high >= (void*).sizeof);
                enforce(cas(&_min, chooseAtRuntime, low),
                    "SharedFreeList.min must be initialized exactly once.");
                enforce(cas(&_max, chooseAtRuntime, high),
                    "SharedFreeList.max must be initialized exactly once.");
            }
        }
    }

    private bool tooSmall(size_t n) const shared
    {
        static if (minSize == 0) return false;
        else static if (minSize == chooseAtRuntime) return n < _min;
        else return n < minSize;
    }

    static if (maxSize != chooseAtRuntime)
    {
        alias max = maxSize;
    }
    else
    {
        private shared size_t _max = chooseAtRuntime;
        @property size_t max() const shared { return _max; }
        @property void max(size_t x) shared
        {
            enforce(x >= min && x >= (void*).sizeof);
            enforce(cas(&_max, chooseAtRuntime, x),
                "SharedFreeList.max must be initialized exactly once.");
        }
    }

    private bool tooLarge(size_t n) const shared
    {
        static if (maxSize == unbounded) return false;
        else static if (maxSize == chooseAtRuntime) return n > _max;
        else return n > maxSize;
    }

    private bool freeListEligible(size_t n) const shared
    {
        static if (minSize == maxSize && minSize != chooseAtRuntime)
            return n == maxSize;
        else return !tooSmall(n) && !tooLarge(n);
    }

    static if (approxMaxNodes != chooseAtRuntime)
    {
        alias approxMaxLength = approxMaxNodes;
    }
    else
    {
        private shared size_t _approxMaxLength = chooseAtRuntime;
        @property size_t approxMaxLength() const shared { return _approxMaxLength; }
        @property void approxMaxLength(size_t x) shared { _approxMaxLength = enforce(x); }
    }

    static if (approxMaxNodes != unbounded)
    {
        private shared size_t nodes;
        private void incNodes() shared
        {
            atomicOp!("+=")(nodes, 1);
        }
        private void decNodes() shared
        {
            assert(nodes);
            atomicOp!("-=")(nodes, 1);
        }
        private void resetNodes() shared
        {
            nodes = 0;
        }
        private bool nodesFull() shared
        {
            return nodes >= approxMaxLength;
        }
    }
    else
    {
        private static void incNodes() { }
        private static void decNodes() { }
        private static void resetNodes() { }
        private enum bool nodesFull = false;
    }

    version (StdDdoc)
    {
        /**
        Properties for getting (and possibly setting) the bounds. Setting bounds
        is allowed only once , and before any allocation takes place. Otherwise,
        the primitives have the same semantics as those of `FreeList`.
        */
        @property size_t min();
        /// Ditto
        @property void min(size_t newMinSize);
        /// Ditto
        @property size_t max();
        /// Ditto
        @property void max(size_t newMaxSize);
        /// Ditto
        void setBounds(size_t newMin, size_t newMax);

        /**
        Properties for getting (and possibly setting) the approximate maximum length of a shared freelist.
        */
        @property size_t approxMaxLength() const shared;
        /// ditto
        @property void approxMaxLength(size_t x) shared;
    }

    /**
    The parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator) shared ParentAllocator parent;
    else alias parent = ParentAllocator.instance;

    mixin(forwardToMember("parent", "expand"));

    private SpinLock lock;

    private struct Node { Node* next; }
    static assert(ParentAllocator.alignment >= Node.alignof);
    private Node* _root;

    /// Standard primitives.
    enum uint alignment = ParentAllocator.alignment;

    /// Ditto
    size_t goodAllocSize(size_t bytes) shared
    {
        if (freeListEligible(bytes)) return maxSize == unbounded ? bytes : max;
        return parent.goodAllocSize(bytes);
    }

    /// Ditto
    static if (hasMember!(ParentAllocator, "owns"))
    Ternary owns(const void[] b) shared const
    {
        return parent.owns(b);
    }

    /// Ditto
    static if (hasMember!(ParentAllocator, "reallocate"))
    bool reallocate(ref void[] b, size_t s) shared
    {
        return parent.reallocate(b, s);
    }

    /// Ditto
    void[] allocate(size_t bytes) shared
    {
        assert(bytes < size_t.max / 2);
        if (!freeListEligible(bytes)) return parent.allocate(bytes);
        if (maxSize != unbounded) bytes = max;

        // Try to pop off the freelist
        lock.lock();
        if (!_root)
        {
            lock.unlock();
            return allocateFresh(bytes);
        }
        else
        {
            auto oldRoot = _root;
            _root = _root.next;
            decNodes();
            lock.unlock();
            return (cast(ubyte*) oldRoot)[0 .. bytes];
        }
    }

    private void[] allocateFresh(const size_t bytes) shared
    {
        assert(bytes == max || max == unbounded);
        return parent.allocate(bytes);
    }

    /// Ditto
    bool deallocate(void[] b) shared
    {
        if (!nodesFull && freeListEligible(b.length))
        {
            auto newRoot = cast(shared Node*) b.ptr;
            lock.lock();
            newRoot.next = _root;
            _root = newRoot;
            incNodes();
            lock.unlock();
            return true;
        }
        static if (hasMember!(ParentAllocator, "deallocate"))
            return parent.deallocate(b);
        else
            return false;
    }

    /// Ditto
    bool deallocateAll() shared
    {
        bool result = false;
        lock.lock();
        scope(exit) lock.unlock();
        static if (hasMember!(ParentAllocator, "deallocateAll"))
        {
            result = parent.deallocateAll();
        }
        else static if (hasMember!(ParentAllocator, "deallocate"))
        {
            result = true;
            for (auto n = _root; n;)
            {
                auto tmp = n.next;
                if (!parent.deallocate((cast(ubyte*) n)[0 .. max]))
                    result = false;
                n = tmp;
            }
        }
        _root = null;
        resetNodes();
        return result;
    }

    /**
    Nonstandard function that minimizes the memory usage of the freelist by
    freeing each element in turn. Defined only if `ParentAllocator` defines
    `deallocate`.
    */
    static if (hasMember!(ParentAllocator, "deallocate") && !unchecked)
    void minimize() shared
    {
        lock.lock();
        scope(exit) lock.unlock();

        for (auto n = _root; n;)
        {
            auto tmp = n.next;
            parent.deallocate((cast(ubyte*) n)[0 .. max]);
            n = tmp;
        }

        _root = null;
        resetNodes();
    }
}

///
@safe unittest
{
    import std.experimental.allocator.common : chooseAtRuntime;
    import std.experimental.allocator.mallocator : Mallocator;

    shared SharedFreeList!(Mallocator, chooseAtRuntime, chooseAtRuntime) a;
    a.setBounds(64, 128);
    assert(a.max == 128);
    assert(a.min == 64);
}

///
@safe unittest
{
    import std.experimental.allocator.common : chooseAtRuntime;
    import std.experimental.allocator.mallocator : Mallocator;

    shared SharedFreeList!(Mallocator, 50, 50, chooseAtRuntime) a;
    // Set the maxSize first so setting the minSize doesn't throw
    a.approxMaxLength = 128;
    assert(a.approxMaxLength  == 128);
    a.approxMaxLength = 1024;
    assert(a.approxMaxLength  == 1024);
    a.approxMaxLength = 1;
    assert(a.approxMaxLength  == 1);
}

@system unittest
{
    import core.thread : ThreadGroup;
    import std.algorithm.comparison : equal;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.range : repeat;

    static shared SharedFreeList!(Mallocator, 64, 128, 10) a;

    assert((() nothrow @safe @nogc => a.goodAllocSize(1))() == platformAlignment);

    auto b = a.allocate(96);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(b); }();

    void fun()
    {
        auto b = cast(size_t[]) a.allocate(96);
        b[] = cast(size_t) &b;

        assert(b.equal(repeat(cast(size_t) &b, b.length)));
        () nothrow @nogc { a.deallocate(b); }();
    }

    auto tg = new ThreadGroup;
    foreach (i; 0 .. 20)
    {
        tg.create(&fun);
    }

    tg.joinAll();
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    static shared SharedFreeList!(Mallocator, 64, 128, 10) a;
    auto b = a.allocate(100);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(b); }();
    assert(a.nodes == 1);
    b = [];
    assert((() nothrow @nogc => a.deallocateAll())());
    assert(a.nodes == 0);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    static shared SharedFreeList!(Mallocator, 64, 128, 10) a;
    auto b = a.allocate(100);
    auto c = a.allocate(100);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(c); }();
    assert(a.nodes == 1);
    c = [];
    a.minimize();
    assert(a.nodes == 0);
    () nothrow @nogc { a.deallocate(b); }();
    assert(a.nodes == 1);
    b = [];
    a.minimize();
    assert(a.nodes == 0);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    static shared SharedFreeList!(Mallocator, 64, 128, 10) a;
    auto b = a.allocate(100);
    auto c = a.allocate(100);
    assert(a.nodes == 0);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(b); }();
    () nothrow @nogc { a.deallocate(c); }();
    assert(a.nodes == 2);
    b = [];
    c = [];
    a.minimize();
    assert(a.nodes == 0);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, chooseAtRuntime, chooseAtRuntime) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    auto c = a.allocate(64);
    assert((() nothrow @nogc => a.reallocate(c, 96))());
    assert(c.length == 96);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(c); }();
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, chooseAtRuntime, chooseAtRuntime, chooseAtRuntime) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    a.allocate(64);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, 30, 40) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    a.allocate(64);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, 30, 40, chooseAtRuntime) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    a.allocate(64);
}

@system unittest
{
    // Pull request #5556
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, 0, chooseAtRuntime) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    a.max = 64;
    a.allocate(64);
}

@system unittest
{
    // Pull request #5556
    import std.experimental.allocator.mallocator : Mallocator;
    shared SharedFreeList!(Mallocator, chooseAtRuntime, 64) a;
    scope(exit) assert((() nothrow @nogc => a.deallocateAll())());
    a.min = 32;
    a.allocate(64);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/_free_tree.d)
*/
module std.experimental.allocator.building_blocks.free_tree;

import std.experimental.allocator.common;

//debug = std_experimental_allocator_free_tree;

/**

The Free Tree allocator, stackable on top of any other allocator, bears
similarity with the free list allocator. Instead of a singly-linked list of
previously freed blocks, it maintains a binary search tree. This allows the
Free Tree allocator to manage blocks of arbitrary lengths and search them
efficiently.

Common uses of `FreeTree` include:

$(UL
$(LI Adding `deallocate` capability to an allocator that lacks it (such as simple regions).)
$(LI Getting the benefits of multiple adaptable freelists that do not need to
be tuned for one specific size but insted automatically adapts itself to
frequently used sizes.)
)

The free tree has special handling of duplicates (a singly-linked list per
node) in anticipation of large number of duplicates. Allocation time from the
free tree is expected to be $(BIGOH log n) where `n` is the number of
distinct sizes (not total nodes) kept in the free tree.

Allocation requests first search the tree for a buffer of suitable size
deallocated in the past. If a match is found, the node is removed from the tree
and the memory is returned. Otherwise, the allocation is directed to $(D
ParentAllocator). If at this point `ParentAllocator` also fails to allocate,
`FreeTree` frees everything and then tries the parent allocator again.

Upon deallocation, the deallocated block is inserted in the internally
maintained free tree (not returned to the parent). The free tree is not kept
balanced. Instead, it has a last-in-first-out flavor because newly inserted
blocks are rotated to the root of the tree. That way allocations are cache
friendly and also frequently used sizes are more likely to be found quickly,
whereas seldom used sizes migrate to the leaves of the tree.

`FreeTree` rounds up small allocations to at least $(D 4 * size_t.sizeof),
which on 64-bit system is one cache line size. If very small objects need to
be efficiently allocated, the `FreeTree` should be fronted with an
appropriate small object allocator.

The following methods are defined if `ParentAllocator` defines them, and forward to it: `allocateAll`, `expand`, `owns`, `reallocate`.
*/
struct FreeTree(ParentAllocator)
{
    static assert(ParentAllocator.alignment % size_t.alignof == 0,
        "FreeTree must be on top of a word-aligned allocator");

    import std.algorithm.comparison : min, max;
    import std.algorithm.mutation : swap;
    import std.traits : hasMember;

    // State
    static if (stateSize!ParentAllocator) private ParentAllocator parent;
    else private alias parent = ParentAllocator.instance;
    private Node* root; // that's the entire added state

    private struct Node
    {
        Node*[2] kid;
        Node* sibling;
        size_t size;
        ref Node* left() { return kid[0]; }
        ref Node* right() { return kid[1]; }
    }

    // Removes "which" from the tree, returns the memory it occupied
    private void[] remove(ref Node* which)
    {
        assert(which);
        assert(!which.sibling);
        auto result = (cast(ubyte*) which)[0 .. which.size];
        if (!which.right) which = which.left;
        else if (!which.left) which = which.right;
        else
        {
            // result has two kids
            static bool toggler;
            // Crude randomization: alternate left/right choices
            toggler = !toggler;
            auto newRoot = which.kid[toggler], orphan = which.kid[!toggler];
            which = newRoot;
            for (Node* n = void; (n = newRoot.kid[!toggler]) !is null; )
            {
                newRoot = n;
            }
            newRoot.kid[!toggler] = orphan;
        }
        return result;
    }

    private void[] findAndRemove(ref Node* n, size_t s)
    {
        if (!n) return null;
        if (s == n.size)
        {
            if (auto sis = n.sibling)
            {
                // Nice, give away one from the freelist
                auto result = (cast(ubyte*) sis)[0 .. sis.size];
                n.sibling = sis.sibling;
                return result;
            }
            return remove(n);
        }
        return findAndRemove(n.kid[s > n.size], s);
    }

    debug(std_experimental_allocator_free_tree)
    private void dump()
    {
        import std.stdio : writef, writefln, writeln;
        writeln(typeof(this).stringof, "@", &this, " {");
        scope(exit) writeln("}");

        if (!root) return;

        static void recurse(Node* n, uint indent = 4)
        {
            if (!n)
            {
                writefln("%*s(null)", indent, "");
                return;
            }
            for (auto sis = n; sis; sis = sis.sibling)
            {
                writef("%*s%x (%s bytes) ", indent, "",
                    cast(void*) n, n.size);
            }
            writeln;
            if (!n.left && !n.right) return;
            recurse(n.left, indent + 4);
            recurse(n.right, indent + 4);
        }
        recurse(root);
    }

    private string formatSizes()
    {
        string result = "(";
        void recurse(Node* n)
        {
            if (!n)
            {
                result ~= "_";
                return;
            }
            import std.conv : to;
            result ~= to!string(n.size);
            for (auto sis = n.sibling; sis; sis = sis.sibling)
            {
                result ~= "+moar";
            }
            if (n.left || n.right)
            {
                result ~= " (";
                recurse(n.left);
                result ~= ' ';
                recurse(n.right);
                result ~= ")";
            }
        }
        recurse(root);
        return result ~= ")";
    }

    private static void rotate(ref Node* parent, bool toRight)
    {
        assert(parent);
        auto opposing = parent.kid[!toRight];
        if (!opposing) return;
        parent.kid[!toRight] = opposing.kid[toRight];
        opposing.kid[toRight] = parent;
        parent = opposing;
    }

    // Inserts which into the tree, making it the new root
    private void insertAsRoot(Node* which)
    {
        assert(which);
        debug(std_experimental_allocator_free_tree)
        {
            assertValid;
            scope(exit) assertValid;
        }

        static void recurse(ref Node* where, Node* which)
        {
            if (!where)
            {
                where = which;
                which.left = null;
                which.right = null;
                which.sibling = null;
                return;
            }
            if (which.size == where.size)
            {
                // Special handling of duplicates
                which.sibling = where.sibling;
                where.sibling = which;
                which.left = null;
                which.right = null;
                return;
            }
            bool goRight = which.size > where.size;
            recurse(where.kid[goRight], which);
            rotate(where, !goRight);
        }
        recurse(root, which);
    }

    private void assertValid()
    {
        debug(std_experimental_allocator_free_tree)
        {
            static bool isBST(Node* n, size_t lb = 0, size_t ub = size_t.max)
            {
                if (!n) return true;
                for (auto sis = n.sibling; sis; sis = sis.sibling)
                {
                    assert(n.size == sis.size);
                    assert(sis.left is null);
                    assert(sis.right is null);
                }
                return lb < n.size && n.size <= ub
                    && isBST(n.left, lb, min(ub, n.size))
                    && isBST(n.right, max(lb, n.size), ub);
            }
            if (isBST(root)) return;
            dump;
            assert(0);
        }
    }

    /**
    The `FreeTree` is word aligned.
    */
    enum uint alignment = size_t.alignof;

    /**
    The `FreeTree` allocator is noncopyable.
    */
    this(this) @disable;

    /**
    The destructor of `FreeTree` releases all memory back to the parent
    allocator.
    */
    static if (hasMember!(ParentAllocator, "deallocate"))
    ~this()
    {
        clear;
    }

    /**
    Returns $(D parent.goodAllocSize(max(Node.sizeof, s))).
    */
    static if (stateSize!ParentAllocator)
        size_t goodAllocSize(size_t s)
        {
            return parent.goodAllocSize(max(Node.sizeof, s));
        }
    else
        static size_t goodAllocSize(size_t s)
        {
            return parent.goodAllocSize(max(Node.sizeof, s));
        }

    /**

    Allocates `n` bytes of memory. First consults the free tree, and returns
    from it if a suitably sized block is found. Otherwise, the parent allocator
    is tried. If allocation from the parent succeeds, the allocated block is
    returned. Otherwise, the free tree tries an alternate strategy: If $(D
    ParentAllocator) defines `deallocate`, `FreeTree` releases all of its
    contents and tries again.

    TODO: Splitting and coalescing should be implemented if `ParentAllocator` does not defined `deallocate`.

    */
    void[] allocate(size_t n)
    {
        assertValid;
        if (n == 0) return null;

        immutable s = goodAllocSize(n);

        // Consult the free tree.
        auto result = findAndRemove(root, s);
        if (result.ptr) return result.ptr[0 .. n];

        // No block found, try the parent allocator.
        result = parent.allocate(s);
        if (result.ptr) return result.ptr[0 .. n];

        // Parent ran out of juice, desperation mode on
        static if (hasMember!(ParentAllocator, "deallocate"))
        {
            clear;
            // Try parent allocator again.
            result = parent.allocate(s);
            if (result.ptr) return result.ptr[0 .. n];
            return null;
        }
        else
        {
            // TODO: get smart here
            return null;
        }
    }

    // Forwarding methods
    mixin(forwardToMember("parent",
        "allocateAll", "expand", "owns", "reallocate"));

    /** Places `b` into the free tree. */
    bool deallocate(void[] b)
    {
        if (!b.ptr) return true;
        auto which = cast(Node*) b.ptr;
        which.size = goodAllocSize(b.length);
        // deliberately don't initialize which.left and which.right
        assert(which.size >= Node.sizeof);
        insertAsRoot(which);
        return true;
    }

    @system unittest // test a few simple configurations
    {
        import std.experimental.allocator.gc_allocator;
        FreeTree!GCAllocator a;
        auto b1 = a.allocate(10000);
        auto b2 = a.allocate(20000);
        auto b3 = a.allocate(30000);
        assert(b1.ptr && b2.ptr && b3.ptr);
        () nothrow @nogc { a.deallocate(b1); }();
        () nothrow @nogc { a.deallocate(b3); }();
        () nothrow @nogc { a.deallocate(b2); }();
        assert(a.formatSizes == "(20480 (12288 32768))", a.formatSizes);

        b1 = a.allocate(10000);
        assert(a.formatSizes == "(20480 (_ 32768))", a.formatSizes);
        b1 = a.allocate(30000);
        assert(a.formatSizes == "(20480)", a.formatSizes);
        b1 = a.allocate(20000);
        assert(a.formatSizes == "(_)", a.formatSizes);
    }

    @system unittest // build a complex free tree
    {
        import std.experimental.allocator.gc_allocator, std.range;
        FreeTree!GCAllocator a;
        uint[] sizes = [3008,704,1856,576,1632,672,832,1856,1120,2656,1216,672,
            448,992,2400,1376,2688,2656,736,1440];
        void[][] allocs;
        foreach (s; sizes)
            allocs ~= a.allocate(s);
        foreach_reverse (b; allocs)
        {
            assert(b.ptr);
            () nothrow @nogc { a.deallocate(b); }();
        }
        a.assertValid;
        allocs = null;
        foreach (s; sizes)
            allocs ~= a.allocate(s);
        assert(a.root is null);
        a.assertValid;
    }

    /** Defined if `ParentAllocator.deallocate` exists, and returns to it
    all memory held in the free tree. */
    static if (hasMember!(ParentAllocator, "deallocate"))
    void clear()
    {
        void recurse(Node* n)
        {
            if (!n) return;
            recurse(n.left);
            recurse(n.right);
            parent.deallocate((cast(ubyte*) n)[0 .. n.size]);
        }
        recurse(root);
        root = null;
    }

    /**

    Defined if `ParentAllocator.deallocateAll` exists, and forwards to it.
    Also nullifies the free tree (it's assumed the parent frees all memory
    stil managed by the free tree).

    */
    static if (hasMember!(ParentAllocator, "deallocateAll"))
    bool deallocateAll()
    {
        // This is easy, just nuke the root and deallocate all from the
        // parent
        root = null;
        return parent.deallocateAll;
    }
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.gc_allocator;
    testAllocator!(() => FreeTree!GCAllocator());
}

// https://issues.dlang.org/show_bug.cgi?id=16506
@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mallocator : Mallocator;

    static void f(ParentAllocator)(size_t sz)
    {
        static FreeTree!ParentAllocator myAlloc;
        byte[] _payload = cast(byte[]) myAlloc.allocate(sz);
        assert(_payload, "_payload is null");
        _payload[] = 0;
        () nothrow @nogc { myAlloc.deallocate(_payload); }();
    }

    f!Mallocator(33);
    f!Mallocator(43);
    f!GCAllocator(1);
}

// https://issues.dlang.org/show_bug.cgi?id=16507
@system unittest
{
    static struct MyAllocator
    {
        byte dummy;
        static bool alive = true;
        void[] allocate(size_t s) { return new byte[](s); }
        bool deallocate(void[] ) { if (alive) assert(false); return true; }
        enum alignment = size_t.sizeof;
    }

    FreeTree!MyAllocator ft;
    void[] x = ft.allocate(1);
    () nothrow @nogc { ft.deallocate(x); }();
    ft.allocate(1000);
    MyAllocator.alive = false;
}

@system unittest // "desperation mode"
{
    uint myDeallocCounter = 0;

    struct MyAllocator
    {
        byte[] allocation;
        void[] allocate(size_t s)
        {
            if (allocation.ptr) return null;
            allocation = new byte[](s);
            return allocation;
        }
        bool deallocate(void[] )
        {
            ++myDeallocCounter;
            allocation = null;
            return true;
        }
        enum alignment = size_t.sizeof;
    }

    FreeTree!MyAllocator ft;
    void[] x = ft.allocate(1);
    () nothrow @nogc { ft.deallocate(x); }();
    assert(myDeallocCounter == 0);
    x = ft.allocate(1000); // Triggers "desperation mode".
    assert(myDeallocCounter == 1);
    assert(x.ptr);
    void[] y = ft.allocate(1000); /* Triggers "desperation mode" but there's
        nothing to deallocate so MyAllocator can't deliver. */
    assert(myDeallocCounter == 1);
    assert(y.ptr is null);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator;
    FreeTree!GCAllocator a;

    assert((() nothrow @safe @nogc => a.goodAllocSize(1))() == typeof(*a.root).sizeof);
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    auto a = FreeTree!(BorrowedRegion!())(BorrowedRegion!()(new ubyte[1024 * 64]));
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.expand(b, 22))());
    assert(b.length == 64);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() nothrow @nogc => a.deallocateAll())());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/kernighan_ritchie.d)
*/
module std.experimental.allocator.building_blocks.kernighan_ritchie;
import std.experimental.allocator.building_blocks.null_allocator :
    NullAllocator;

//debug = KRRegion;
debug(KRRegion) import std.stdio;

// KRRegion
/**
`KRRegion` draws inspiration from the $(MREF_ALTTEXT region allocation
strategy, std,experimental,allocator,building_blocks,region) and also the
$(HTTP stackoverflow.com/questions/13159564/explain-this-implementation-of-malloc-from-the-kr-book,
famed allocator) described by Brian Kernighan and Dennis Ritchie in section 8.7
of the book $(HTTP amazon.com/exec/obidos/ASIN/0131103628/classicempire, "The C
Programming Language"), Second Edition, Prentice Hall, 1988.

$(H4 `KRRegion` = `Region` + Kernighan-Ritchie Allocator)

Initially, `KRRegion` starts in "region" mode: allocations are served from
the memory chunk in a region fashion. Thus, as long as there is enough memory
left, `KRRegion.allocate` has the performance profile of a region allocator.
Deallocation inserts (in $(BIGOH 1) time) the deallocated blocks in an
unstructured freelist, which is not read in region mode.

Once the region cannot serve an `allocate` request, `KRRegion` switches
to "free list" mode. It sorts the list of previously deallocated blocks by
address and serves allocation requests off that free list. The allocation and
deallocation follow the pattern described by Kernighan and Ritchie.

The recommended use of `KRRegion` is as a $(I region with deallocation). If the
`KRRegion` is dimensioned appropriately, it could often not enter free list
mode during its lifetime. Thus it is as fast as a simple region, whilst
offering deallocation at a small cost. When the region memory is  exhausted,
the previously deallocated memory is still usable, at a performance  cost. If
the region is not excessively large and fragmented, the linear  allocation and
deallocation cost may still be compensated for by the good locality
characteristics.

If the chunk of memory managed is large, it may be desirable to switch
management to free list from the beginning. That way, memory may be used in a
more compact manner than region mode. To force free list mode, call $(D
switchToFreeList) shortly after construction or when deemed appropriate.

The smallest size that can be allocated is two words (16 bytes on 64-bit
systems, 8 bytes on 32-bit systems). This is because the free list management
needs two words (one for the length, the other for the next pointer in the
singly-linked list).

The `ParentAllocator` type parameter is the type of the allocator used to
allocate the memory chunk underlying the `KRRegion` object. Choosing the
default (`NullAllocator`) means the user is responsible for passing a buffer
at construction (and for deallocating it if necessary). Otherwise, `KRRegion`
automatically deallocates the buffer during destruction. For that reason, if
`ParentAllocator` is not `NullAllocator`, then `KRRegion` is not
copyable.

$(H4 Implementation Details)

In free list mode, `KRRegion` embeds a free blocks list onto the chunk of
memory. The free list is circular, coalesced, and sorted by address at all
times. Allocations and deallocations take time proportional to the number of
previously deallocated blocks. (In practice the cost may be lower, e.g. if
memory is deallocated in reverse order of allocation, all operations take
constant time.) Memory utilization is good (small control structure and no
per-allocation overhead). The disadvantages of freelist mode include proneness
to fragmentation, a minimum allocation size of two words, and linear worst-case
allocation and deallocation times.

Similarities of `KRRegion` (in free list mode) with the
Kernighan-Ritchie allocator:

$(UL
$(LI Free blocks have variable size and are linked in a singly-linked list.)
$(LI The freelist is maintained in increasing address order, which makes
coalescing easy.)
$(LI The strategy for finding the next available block is first fit.)
$(LI The free list is circular, with the last node pointing back to the first.)
$(LI Coalescing is carried during deallocation.)
)

Differences from the Kernighan-Ritchie allocator:

$(UL
$(LI Once the chunk is exhausted, the Kernighan-Ritchie allocator allocates
another chunk using operating system primitives. For better composability, $(D
KRRegion) just gets full (returns `null` on new allocation requests). The
decision to allocate more blocks is deferred to a higher-level entity. For an
example, see the example below using `AllocatorList` in conjunction with $(D
KRRegion).)
$(LI Allocated blocks do not hold a size prefix. This is because in D the size
information is available in client code at deallocation time.)
)

*/
struct KRRegion(ParentAllocator = NullAllocator)
{
    import std.experimental.allocator.common : stateSize, alignedAt;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    private static struct Node
    {
        import std.typecons : tuple, Tuple;

        Node* next;
        size_t size;

        this(this) @disable;

        void[] payload() inout
        {
            return (cast(ubyte*) &this)[0 .. size];
        }

        bool adjacent(in Node* right) const
        {
            assert(right);
            auto p = payload;
            return p.ptr < right && right < p.ptr + p.length + Node.sizeof;
        }

        bool coalesce(void* memoryEnd = null)
        {
            // Coalesce the last node before the memory end with any possible gap
            if (memoryEnd
                && memoryEnd < payload.ptr + payload.length + Node.sizeof)
            {
                size += memoryEnd - (payload.ptr + payload.length);
                return true;
            }

            if (!adjacent(next)) return false;
            size = (cast(ubyte*) next + next.size) - cast(ubyte*) &this;
            next = next.next;
            return true;
        }

        Tuple!(void[], Node*) allocateHere(size_t bytes)
        {
            assert(bytes >= Node.sizeof);
            assert(bytes % Node.alignof == 0);
            assert(next);
            assert(!adjacent(next));
            if (size < bytes) return typeof(return)();
            assert(size >= bytes);
            immutable leftover = size - bytes;

            if (leftover >= Node.sizeof)
            {
                // There's room for another node
                auto newNode = cast(Node*) ((cast(ubyte*) &this) + bytes);
                newNode.size = leftover;
                newNode.next = next == &this ? newNode : next;
                assert(next);
                return tuple(payload, newNode);
            }

            // No slack space, just return next node
            return tuple(payload, next == &this ? null : next);
        }
    }

    // state
    /**
    If `ParentAllocator` holds state, `parent` is a public member of type
    `KRRegion`. Otherwise, `parent` is an `alias` for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator) ParentAllocator parent;
    else alias parent = ParentAllocator.instance;
    private void[] payload;
    private Node* root;
    private bool regionMode() const { return bytesUsedRegionMode != size_t.max; }
    private void cancelRegionMode() { bytesUsedRegionMode = size_t.max; }
    private size_t bytesUsedRegionMode = 0;

    auto byNodePtr()
    {
        static struct Range
        {
            Node* start, current;
            @property bool empty() { return !current; }
            @property Node* front() { return current; }
            void popFront()
            {
                assert(current && current.next);
                current = current.next;
                if (current == start) current = null;
            }
            @property Range save() { return this; }
        }
        import std.range : isForwardRange;
        static assert(isForwardRange!Range);
        return Range(root, root);
    }

    string toString()
    {
        import std.format : format;
        string s = "KRRegion@";
        s ~= format("%s-%s(0x%s[%s] %s", &this, &this + 1,
            payload.ptr, payload.length,
            regionMode ? "(region)" : "(freelist)");

        Node* lastNode = null;
        if (!regionMode)
        {
            foreach (node; byNodePtr)
            {
                s ~= format(", %sfree(0x%s[%s])",
                    lastNode && lastNode.adjacent(node) ? "+" : "",
                    cast(void*) node, node.size);
                lastNode = node;
            }
        }
        else
        {
            for (auto node = root; node; node = node.next)
            {
                s ~= format(", %sfree(0x%s[%s])",
                    lastNode && lastNode.adjacent(node) ? "+" : "",
                    cast(void*) node, node.size);
                lastNode = node;
            }
        }

        s ~= ')';
        return s;
    }

    private void assertValid(string s)
    {
        assert(!regionMode);
        if (!payload.ptr)
        {
            assert(!root, s);
            return;
        }
        if (!root)
        {
            return;
        }
        assert(root >= payload.ptr, s);
        assert(root < payload.ptr + payload.length, s);

        // Check that the list terminates
        size_t n;
        foreach (node; byNodePtr)
        {
            assert(node.next);
            assert(!node.adjacent(node.next));
            assert(n++ < payload.length / Node.sizeof, s);
        }
    }

    private Node* sortFreelist(Node* root)
    {
        // Find a monotonic run
        auto last = root;
        for (;;)
        {
            if (!last.next) return root;
            if (last > last.next) break;
            assert(last < last.next);
            last = last.next;
        }
        auto tail = last.next;
        last.next = null;
        tail = sortFreelist(tail);
        return merge(root, tail);
    }

    private Node* merge(Node* left, Node* right)
    {
        assert(left != right);
        if (!left) return right;
        if (!right) return left;
        if (left < right)
        {
            auto result = left;
            result.next = merge(left.next, right);
            return result;
        }
        auto result = right;
        result.next = merge(left, right.next);
        return result;
    }

    private void coalesceAndMakeCircular()
    {
        for (auto n = root;;)
        {
            assert(!n.next || n < n.next);
            if (!n.next)
            {
                // Convert to circular
                n.next = root;
                break;
            }
            if (n.coalesce) continue; // possibly another coalesce
            n = n.next;
        }
    }

    /**
    Create a `KRRegion`. If `ParentAllocator` is not `NullAllocator`,
    `KRRegion`'s destructor will call `parent.deallocate`.

    Params:
    b = Block of memory to serve as support for the allocator. Memory must be
    larger than two words and word-aligned.
    n = Capacity desired. This constructor is defined only if $(D
    ParentAllocator) is not `NullAllocator`.
    */
    this(ubyte[] b)
    {
        if (b.length < Node.sizeof)
        {
            // Init as empty
            assert(root is null);
            assert(payload is null);
            return;
        }
        assert(b.length >= Node.sizeof);
        assert(b.ptr.alignedAt(Node.alignof));
        assert(b.length >= 2 * Node.sizeof);
        payload = b;
        root = cast(Node*) b.ptr;
        // Initialize the free list with all list
        assert(regionMode);
        root.next = null;
        root.size = b.length;
        debug(KRRegion) writefln("KRRegion@%s: init with %s[%s]", &this,
            b.ptr, b.length);
    }

    /// Ditto
    static if (!is(ParentAllocator == NullAllocator) && !stateSize!ParentAllocator)
    this(size_t n)
    {
        assert(n > Node.sizeof);
        this(cast(ubyte[])(parent.allocate(n)));
    }

    /// Ditto
    static if (!is(ParentAllocator == NullAllocator) && stateSize!ParentAllocator)
    this(ParentAllocator parent, size_t n)
    {
        assert(n > Node.sizeof);
        this.parent = parent;
        this(cast(ubyte[])(parent.allocate(n)));
    }

    /// Ditto
    static if (!is(ParentAllocator == NullAllocator)
        && hasMember!(ParentAllocator, "deallocate"))
    ~this()
    {
        parent.deallocate(payload);
    }

    /**
    Forces free list mode. If already in free list mode, does nothing.
    Otherwise, sorts the free list accumulated so far and switches strategy for
    future allocations to KR style.
    */
    void switchToFreeList()
    {
        if (!regionMode) return;
        cancelRegionMode;
        if (!root) return;
        root = sortFreelist(root);
        coalesceAndMakeCircular;
    }

    /*
    Noncopyable
    */
    @disable this(this);

    /**
    Word-level alignment.
    */
    enum alignment = Node.alignof;

    /**
    Allocates `n` bytes. Allocation searches the list of available blocks
    until a free block with `n` or more bytes is found (first fit strategy).
    The block is split (if larger) and returned.

    Params: n = number of bytes to _allocate

    Returns: A word-aligned buffer of `n` bytes, or `null`.
    */
    void[] allocate(size_t n)
    {
        if (!n || !root) return null;
        const actualBytes = goodAllocSize(n);

        // Try the region first
        if (regionMode)
        {
            // Only look at the head of the freelist
            if (root.size >= actualBytes)
            {
                // Enough room for allocation
                bytesUsedRegionMode += actualBytes;
                void* result = root;
                immutable balance = root.size - actualBytes;
                if (balance >= Node.sizeof)
                {
                    auto newRoot = cast(Node*) (result + actualBytes);
                    newRoot.next = root.next;
                    newRoot.size = balance;
                    root = newRoot;
                }
                else
                {
                    root = null;
                    switchToFreeList;
                }
                return result[0 .. n];
            }

            // Not enough memory, switch to freelist mode and fall through
            switchToFreeList;
        }

        // Try to allocate from next after the iterating node
        for (auto pnode = root;;)
        {
            assert(!pnode.adjacent(pnode.next));
            auto k = pnode.next.allocateHere(actualBytes);
            if (k[0] !is null)
            {
                // awes
                assert(k[0].length >= n);
                if (root == pnode.next) root = k[1];
                pnode.next = k[1];
                return k[0][0 .. n];
            }

            pnode = pnode.next;
            if (pnode == root) break;
        }
        return null;
    }

    /**
    Deallocates `b`, which is assumed to have been previously allocated with
    this allocator. Deallocation performs a linear search in the free list to
    preserve its sorting order. It follows that blocks with higher addresses in
    allocators with many free blocks are slower to deallocate.

    Params: b = block to be deallocated
    */
    nothrow @nogc
    bool deallocate(void[] b)
    {
        debug(KRRegion) writefln("KRRegion@%s: deallocate(%s[%s])", &this,
            b.ptr, b.length);
        if (!b.ptr) return true;
        assert(owns(b) == Ternary.yes);
        assert(b.ptr.alignedAt(Node.alignof));

        // Insert back in the freelist, keeping it sorted by address. Do not
        // coalesce at this time. Instead, do it lazily during allocation.
        auto n = cast(Node*) b.ptr;
        n.size = goodAllocSize(b.length);
        auto memoryEnd = payload.ptr + payload.length;

        if (regionMode)
        {
            assert(root);
            // Insert right after root
            bytesUsedRegionMode -= n.size;
            n.next = root.next;
            root.next = n;
            return true;
        }

        if (!root)
        {
            // What a sight for sore eyes
            root = n;
            root.next = root;

            // If the first block freed is the last one allocated,
            // maybe there's a gap after it.
            root.coalesce(memoryEnd);
            return true;
        }

        version (assert) foreach (test; byNodePtr)
        {
            assert(test != n);
        }
        // Linear search
        auto pnode = root;
        do
        {
            assert(pnode && pnode.next);
            assert(pnode != n);
            assert(pnode.next != n);

            if (pnode < pnode.next)
            {
                if (pnode > n || n > pnode.next) continue;
                // Insert in between pnode and pnode.next
                n.next = pnode.next;
                pnode.next = n;
                n.coalesce;
                pnode.coalesce;
                root = pnode;
                return true;
            }
            else if (pnode < n)
            {
                // Insert at the end of the list
                // Add any possible gap at the end of n to the length of n
                n.next = pnode.next;
                pnode.next = n;
                n.coalesce(memoryEnd);
                pnode.coalesce;
                root = pnode;
                return true;
            }
            else if (n < pnode.next)
            {
                // Insert at the front of the list
                n.next = pnode.next;
                pnode.next = n;
                n.coalesce;
                root = n;
                return true;
            }
        }
        while ((pnode = pnode.next) != root);
        assert(0, "Wrong parameter passed to deallocate");
    }

    /**
    Allocates all memory available to this allocator. If the allocator is empty,
    returns the entire available block of memory. Otherwise, it still performs
    a best-effort allocation: if there is no fragmentation (e.g. `allocate`
    has been used but not `deallocate`), allocates and returns the only
    available block of memory.

    The operation takes time proportional to the number of adjacent free blocks
    at the front of the free list. These blocks get coalesced, whether
    `allocateAll` succeeds or fails due to fragmentation.
    */
    void[] allocateAll()
    {
        if (regionMode) switchToFreeList;
        if (root && root.next == root)
            return allocate(root.size);
        return null;
    }

    ///
    @system unittest
    {
        import std.experimental.allocator.gc_allocator : GCAllocator;
        auto alloc = KRRegion!GCAllocator(1024 * 64);
        const b1 = alloc.allocate(2048);
        assert(b1.length == 2048);
        const b2 = alloc.allocateAll;
        assert(b2.length == 1024 * 62);
    }

    /**
    Deallocates all memory currently allocated, making the allocator ready for
    other allocations. This is a $(BIGOH 1) operation.
    */
    pure nothrow @nogc
    bool deallocateAll()
    {
        debug(KRRegion) assertValid("deallocateAll");
        debug(KRRegion) scope(exit) assertValid("deallocateAll");
        root = cast(Node*) payload.ptr;

        // Reset to regionMode
        bytesUsedRegionMode = 0;
        if (root)
        {
            root.next = null;
            root.size = payload.length;
        }
        return true;
    }

    /**
    Checks whether the allocator is responsible for the allocation of `b`.
    It does a simple $(BIGOH 1) range check. `b` should be a buffer either
    allocated with `this` or obtained through other means.
    */
    pure nothrow @trusted @nogc
    Ternary owns(void[] b)
    {
        debug(KRRegion) assertValid("owns");
        debug(KRRegion) scope(exit) assertValid("owns");
        return Ternary(b && payload && (&b[0] >= &payload[0])
                       && (&b[0] < &payload[0] + payload.length));
    }

    /**
    Adjusts `n` to a size suitable for allocation (two words or larger,
    word-aligned).
    */
    pure nothrow @safe @nogc
    static size_t goodAllocSize(size_t n)
    {
        import std.experimental.allocator.common : roundUpToMultipleOf;
        return n <= Node.sizeof
            ? Node.sizeof : n.roundUpToMultipleOf(alignment);
    }

    /**
    Returns: `Ternary.yes` if the allocator is empty, `Ternary.no` otherwise.
    Never returns `Ternary.unknown`.
    */
    pure nothrow @safe @nogc
    Ternary empty()
    {
        if (regionMode)
            return Ternary(bytesUsedRegionMode == 0);

        return Ternary(root && root.size == payload.length);
    }
}

/**
`KRRegion` is preferable to `Region` as a front for a general-purpose
allocator if `deallocate` is needed, yet the actual deallocation traffic is
relatively low. The example below shows a `KRRegion` using stack storage
fronting the GC allocator.
*/
@system unittest
{
    import std.experimental.allocator.building_blocks.fallback_allocator
        : fallbackAllocator;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;
    // KRRegion fronting a general-purpose allocator
    ubyte[1024 * 128] buf;
    auto alloc = fallbackAllocator(KRRegion!()(buf), GCAllocator.instance);
    auto b = alloc.allocate(100);
    assert(b.length == 100);
    assert((() pure nothrow @safe @nogc => alloc.primary.owns(b))() == Ternary.yes);
}

/**
The code below defines a scalable allocator consisting of 1 MB (or larger)
blocks fetched from the garbage-collected heap. Each block is organized as a
KR-style heap. More blocks are allocated and freed on a need basis.

This is the closest example to the allocator introduced in the K$(AMP)R book.
It should perform slightly better because instead of searching through one
large free list, it searches through several shorter lists in LRU order. Also,
it actually returns memory to the operating system when possible.
*/
@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.mmap_allocator : MmapAllocator;
    AllocatorList!(n => KRRegion!MmapAllocator(max(n * 16, 1024 * 1024))) alloc;
}

@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    /*
    Create a scalable allocator consisting of 1 MB (or larger) blocks fetched
    from the garbage-collected heap. Each block is organized as a KR-style
    heap. More blocks are allocated and freed on a need basis.
    */
    AllocatorList!(n => KRRegion!Mallocator(max(n * 16, 1024 * 1024)),
        NullAllocator) alloc;
    void[][50] array;
    foreach (i; 0 .. array.length)
    {
        auto length = i * 10_000 + 1;
        array[i] = alloc.allocate(length);
        assert(array[i].ptr);
        assert(array[i].length == length);
    }
    import std.random : randomShuffle;
    randomShuffle(array[]);
    foreach (i; 0 .. array.length)
    {
        assert(array[i].ptr);
        assert((() pure nothrow @safe @nogc => alloc.owns(array[i]))() == Ternary.yes);
        () nothrow @nogc { alloc.deallocate(array[i]); }();
    }
}

@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.mmap_allocator : MmapAllocator;
    import std.typecons : Ternary;
    /*
    Create a scalable allocator consisting of 1 MB (or larger) blocks fetched
    from the garbage-collected heap. Each block is organized as a KR-style
    heap. More blocks are allocated and freed on a need basis.
    */
    AllocatorList!((n) {
        auto result = KRRegion!MmapAllocator(max(n * 2, 1024 * 1024));
        return result;
    }) alloc;
    void[][99] array;
    foreach (i; 0 .. array.length)
    {
        auto length = i * 10_000 + 1;
        array[i] = alloc.allocate(length);
        assert(array[i].ptr);
        foreach (j; 0 .. i)
        {
            assert(array[i].ptr != array[j].ptr);
        }
        assert(array[i].length == length);
    }
    import std.random : randomShuffle;
    randomShuffle(array[]);
    foreach (i; 0 .. array.length)
    {
        assert((() pure nothrow @safe @nogc => alloc.owns(array[i]))() == Ternary.yes);
        () nothrow @nogc { alloc.deallocate(array[i]); }();
    }
}

version (StdUnittest)
@system unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.common : testAllocator;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    testAllocator!(() => AllocatorList!(
        n => KRRegion!GCAllocator(max(n * 16, 1024 * 1024)))());
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;

    auto alloc = KRRegion!GCAllocator(1024 * 1024);

    void[][] array;
    foreach (i; 1 .. 4)
    {
        array ~= alloc.allocate(i);
        assert(array[$ - 1].length == i);
    }
    () nothrow @nogc { alloc.deallocate(array[1]); }();
    () nothrow @nogc { alloc.deallocate(array[0]); }();
    () nothrow @nogc { alloc.deallocate(array[2]); }();
    assert(alloc.allocateAll().length == 1024 * 1024);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;
    auto alloc = KRRegion!()(
                    cast(ubyte[])(GCAllocator.instance.allocate(1024 * 1024)));
    const store = alloc.allocate(KRRegion!().sizeof);
    auto p = cast(KRRegion!()* ) store.ptr;
    import core.lifetime : emplace;
    import core.stdc.string : memcpy;
    import std.conv : text;

    memcpy(p, &alloc, alloc.sizeof);
    emplace(&alloc);

    void[][100] array;
    foreach (i; 0 .. array.length)
    {
        auto length = 100 * i + 1;
        array[i] = p.allocate(length);
        assert(array[i].length == length, text(array[i].length));
        assert((() pure nothrow @safe @nogc => p.owns(array[i]))() == Ternary.yes);
    }
    import std.random : randomShuffle;
    randomShuffle(array[]);
    foreach (i; 0 .. array.length)
    {
        assert((() pure nothrow @safe @nogc => p.owns(array[i]))() == Ternary.yes);
        () nothrow @nogc { p.deallocate(array[i]); }();
    }
    auto b = p.allocateAll();
    assert(b.length == 1024 * 1024 - KRRegion!().sizeof, text(b.length));
}

@system unittest
{
    import std.typecons : Ternary;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    auto alloc = KRRegion!()(
                    cast(ubyte[])(GCAllocator.instance.allocate(1024 * 1024)));
    auto p = alloc.allocateAll();
    assert(p.length == 1024 * 1024);
    assert((() nothrow @nogc => alloc.deallocateAll())());
    assert(alloc.empty() == Ternary.yes);
    p = alloc.allocateAll();
    assert(p.length == 1024 * 1024);
}

@system unittest
{
    import std.random : randomCover;
    import std.typecons : Ternary;

    // Both sequences must work on either system

    // A sequence of allocs which generates the error described in https://issues.dlang.org/show_bug.cgi?id=16564
    // that is a gap at the end of buf from the perspective of the allocator

    // for 64 bit systems (leftover balance = 8 bytes < 16)
    int[] sizes64 = [18904, 2008, 74904, 224, 111904, 1904, 52288, 8];

    // for 32 bit systems (leftover balance < 8)
    int[] sizes32 = [81412, 107068, 49892, 23768];


    void test(int[] sizes)
    {
        align(size_t.sizeof) ubyte[256 * 1024] buf;
        auto a = KRRegion!()(buf);

        void[][] bufs;

        foreach (size; sizes)
        {
            bufs ~= a.allocate(size);
        }

        foreach (b; bufs.randomCover)
        {
            () nothrow @nogc { a.deallocate(b); }();
        }

        assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
    }

    test(sizes64);
    test(sizes32);
}

@system unittest
{
    import std.typecons : Ternary;

    // For 64 bits, we allocate in multiples of 8, but the minimum alloc size is 16.
    // This can create gaps.
    // This test is an example of such a case. The gap is formed between the block
    // allocated for the second value in sizes and the third. There is also a gap
    // at the very end. (total lost 2 * word)

    int[] sizes64 = [2008, 18904, 74904, 224, 111904, 1904, 52288, 8];
    int[] sizes32 = [81412, 107068, 49892, 23768];

    int word64 = 8;
    int word32 = 4;

    void test(int[] sizes, int word)
    {
        align(size_t.sizeof) ubyte[256 * 1024] buf;
        auto a = KRRegion!()(buf);

        void[][] bufs;

        foreach (size; sizes)
        {
            bufs ~= a.allocate(size);
        }

        () nothrow @nogc { a.deallocate(bufs[1]); }();
        bufs ~= a.allocate(sizes[1] - word);

        () nothrow @nogc { a.deallocate(bufs[0]); }();
        foreach (i; 2 .. bufs.length)
        {
            () nothrow @nogc { a.deallocate(bufs[i]); }();
        }

        assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
    }

    test(sizes64, word64);
    test(sizes32, word32);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;

    auto a = KRRegion!GCAllocator(1024 * 1024);
    assert((() pure nothrow @safe @nogc => a.goodAllocSize(1))() == typeof(*a.root).sizeof);
}

@system unittest
{   import std.typecons : Ternary;

    ubyte[1024] b;
    auto alloc = KRRegion!()(b);

    auto k = alloc.allocate(128);
    assert(k.length == 128);
    assert(alloc.empty == Ternary.no);
    assert(alloc.deallocate(k));
    assert(alloc.empty == Ternary.yes);

    k = alloc.allocate(512);
    assert(k.length == 512);
    assert(alloc.empty == Ternary.no);
    assert(alloc.deallocate(k));
    assert(alloc.empty == Ternary.yes);

    k = alloc.allocate(1024);
    assert(k.length == 1024);
    assert(alloc.empty == Ternary.no);
    assert(alloc.deallocate(k));
    assert(alloc.empty == Ternary.yes);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/null_allocator.d)
*/
module std.experimental.allocator.building_blocks.null_allocator;

/**
`NullAllocator` is an emphatically empty implementation of the allocator
interface. Although it has no direct use, it is useful as a "terminator" in
composite allocators.
*/
struct NullAllocator
{
    import std.typecons : Ternary;

    nothrow @nogc pure @safe:
    /**
    `NullAllocator` advertises a relatively large _alignment equal to 64 KB.
    This is because `NullAllocator` never actually needs to honor this
    alignment and because composite allocators using `NullAllocator`
    shouldn't be unnecessarily constrained.
    */
    enum uint alignment = 64 * 1024;
    // /// Returns `n`.
    //size_t goodAllocSize(size_t n) shared const
    //{ return .goodAllocSize(this, n); }
    /// Always returns `null`.
    void[] allocate(size_t) shared { return null; }
    /// Always returns `null`.
    void[] alignedAllocate(size_t, uint) shared { return null; }
    /// Always returns `null`.
    void[] allocateAll() shared { return null; }
    /**
    These methods return `false`.
    Precondition: $(D b is null). This is because there is no other possible
    legitimate input.
    */
    bool expand(ref void[] b, size_t s) shared
    { assert(b is null); return s == 0; }
    /// Ditto
    bool reallocate(ref void[] b, size_t) shared
    { assert(b is null); return false; }
    /// Ditto
    bool alignedReallocate(ref void[] b, size_t, uint) shared
    { assert(b is null); return false; }
    /// Returns `Ternary.no`.
    Ternary owns(const void[]) shared const { return Ternary.no; }
    /**
    Returns `Ternary.no`.
    */
    Ternary resolveInternalPointer(const void*, ref void[]) shared const
    { return Ternary.no; }
    /**
    No-op.
    Precondition: $(D b is null)
    */
    bool deallocate(void[] b) shared { assert(b is null); return true; }
    /**
    No-op.
    */
    bool deallocateAll() shared { return true; }
    /**
    Returns `Ternary.yes`.
    */
    Ternary empty() shared const { return Ternary.yes; }
    /**
    Returns the `shared` global instance of the `NullAllocator`.
    */
    static shared NullAllocator instance;
}

nothrow @nogc pure @safe unittest
{
    alias a = NullAllocator.instance;

    assert(a.alignedAllocate(100, 0) is null);
    assert(a.allocateAll() is null);
    auto b = a.allocate(100);
    assert(b is null);
    assert(a.expand(b, 0));
    assert(!a.expand(b, 42));
    assert(!a.reallocate(b, 42));
    assert(!a.alignedReallocate(b, 42, 0));
    assert(a.deallocate(b));
    assert(a.deallocateAll());

    import std.typecons : Ternary;
    assert(a.empty == Ternary.yes);
    assert(a.owns(null) == Ternary.no);

    void[] p;
    assert(a.resolveInternalPointer(null, p) == Ternary.no);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // Written in the D programming language.
/**
$(H2 Assembling Your Own Allocator)

This package also implements
untyped composable memory allocators. They are $(I untyped) because they deal
exclusively in `void[]` and have no notion of what type the memory allocated
would be destined for. They are $(I composable) because the included allocators
are building blocks that can be assembled in complex nontrivial allocators.

$(P Unlike the allocators for the C and C++ programming languages, which manage
the allocated size internally, these allocators require that the client
maintains (or knows $(I a priori)) the allocation size for each piece of memory
allocated. Put simply, the client must pass the allocated size upon
deallocation. Storing the size in the _allocator has significant negative
performance implications, and is virtually always redundant because client code
needs knowledge of the allocated size in order to avoid buffer overruns. (See
more discussion in a $(HTTP open-
std.org/JTC1/SC22/WG21/docs/papers/2013/n3536.html, proposal) for sized
deallocation in C++.) For this reason, allocators herein traffic in `void[]`
as opposed to `void*`.)

$(P In order to be usable as an _allocator, a type should implement the
following methods with their respective semantics. Only `alignment` and  $(D
allocate) are required. If any of the other methods is missing, the _allocator
is assumed to not have that capability (for example some allocators do not offer
manual deallocation of memory). Allocators should NOT implement
unsupported methods to always fail. For example, an allocator that lacks the
capability to implement `alignedAllocate` should not define it at all (as
opposed to defining it to always return `null` or throw an exception). The
missing implementation statically informs other components about the
allocator's capabilities and allows them to make design decisions accordingly.)

$(BOOKTABLE ,
$(TR $(TH Method name) $(TH Semantics))

$(TR $(TDC uint alignment;, $(POST $(RES) > 0)) $(TD Returns the minimum
alignment of all data returned by the allocator. An allocator may implement $(D
alignment) as a statically-known `enum` value only. Applications that need
dynamically-chosen alignment values should use the `alignedAllocate` and $(D
alignedReallocate) APIs.))

$(TR $(TDC size_t goodAllocSize(size_t n);, $(POST $(RES) >= n)) $(TD Allocators
customarily allocate memory in discretely-sized chunks. Therefore, a request for
`n` bytes may result in a larger allocation. The extra memory allocated goes
unused and adds to the so-called $(HTTP goo.gl/YoKffF,internal fragmentation).
The function `goodAllocSize(n)` returns the actual number of bytes that would
be allocated upon a request for `n` bytes. This module defines a default
implementation that returns `n` rounded up to a multiple of the allocator's
alignment.))

$(TR $(TDC void[] allocate(size_t s);, $(POST $(RES) is null || $(RES).length ==
s)) $(TD If $(D s == 0), the call may return any empty slice (including $(D
null)). Otherwise, the call allocates `s` bytes of memory and returns the
allocated block, or `null` if the request could not be satisfied.))

$(TR $(TDC void[] alignedAllocate(size_t s, uint a);, $(POST $(RES) is null ||
$(RES).length == s)) $(TD Similar to `allocate`, with the additional
guarantee that the memory returned is aligned to at least `a` bytes. `a`
must be a power of 2.))

$(TR $(TDC void[] allocateAll();) $(TD Offers all of allocator's memory to the
caller, so it's usually defined by fixed-size allocators. If the allocator is
currently NOT managing any memory, then `allocateAll()` shall allocate and
return all memory available to the allocator, and subsequent calls to all
allocation primitives should not succeed (e.g. `allocate` shall return $(D
null) etc). Otherwise, `allocateAll` only works on a best-effort basis, and
the allocator is allowed to return `null` even if does have available memory.
Memory allocated with `allocateAll` is not otherwise special (e.g. can be
reallocated or deallocated with the usual primitives, if defined).))

$(TR $(TDC bool expand(ref void[] b, size_t delta);, $(POST !$(RES) || b.length
== $(I old)(b).length + delta)) $(TD Expands `b` by `delta` bytes. If $(D
delta == 0), succeeds without changing `b`. If $(D b is null), returns
`false` (the null pointer cannot be expanded in place). Otherwise, $(D
b) must be a buffer previously allocated with the same allocator. If expansion
was successful, `expand` changes `b`'s length to $(D b.length + delta) and
returns `true`. Upon failure, the call effects no change upon the allocator
object, leaves `b` unchanged, and returns `false`.))

$(TR $(TDC bool reallocate(ref void[] b, size_t s);, $(POST !$(RES) || b.length
== s)) $(TD Reallocates `b` to size `s`, possibly moving memory around.
`b` must be `null` or a buffer allocated with the same allocator. If
reallocation was successful, `reallocate` changes `b` appropriately and
returns `true`. Upon failure, the call effects no change upon the allocator
object, leaves `b` unchanged, and returns `false`. An allocator should
implement `reallocate` if it can derive some advantage from doing so;
otherwise, this module defines a `reallocate` free function implemented in
terms of `expand`, `allocate`, and `deallocate`.))

$(TR $(TDC bool alignedReallocate(ref void[] b,$(BR) size_t s, uint a);, $(POST
!$(RES) || b.length == s)) $(TD Similar to `reallocate`, but guarantees the
reallocated memory is aligned at `a` bytes. The buffer must have been
originated with a call to `alignedAllocate`. `a` must be a power of 2
greater than `(void*).sizeof`. An allocator should implement $(D
alignedReallocate) if it can derive some advantage from doing so; otherwise,
this module defines a `alignedReallocate` free function implemented in terms
of `expand`, `alignedAllocate`, and `deallocate`.))

$(TR $(TDC Ternary owns(void[] b);) $(TD Returns `Ternary.yes` if `b` has been
allocated with this allocator. An allocator should define this method only if it
can decide on ownership precisely and fast (in constant time, logarithmic time,
or linear time with a low multiplication factor). Traditional allocators such as
the C heap do not define such functionality. If $(D b is null), the allocator
shall return `Ternary.no`, i.e. no allocator owns the `null` slice.))

$(TR $(TDC Ternary resolveInternalPointer(void* p, ref void[] result);) $(TD If
`p` is a pointer somewhere inside a block allocated with this allocator,
`result` holds a pointer to the beginning of the allocated block and returns
`Ternary.yes`. Otherwise, `result` holds `null` and returns `Ternary.no`.
If the pointer points immediately after an allocated block, the result is
implementation defined.))

$(TR $(TDC bool deallocate(void[] b);) $(TD If $(D b is null), does
nothing and returns `true`. Otherwise, deallocates memory previously allocated
with this allocator and returns `true` if successful, `false` otherwise. An
implementation that would not support deallocation (i.e. would always return
`false` should not define this primitive at all.)))

$(TR $(TDC bool deallocateAll();, $(POST empty)) $(TD Deallocates all memory
allocated with this allocator. If an allocator implements this method, it must
specify whether its destructor calls it, too.))

$(TR $(TDC Ternary empty();) $(TD Returns `Ternary.yes` if and only if the
allocator holds no memory (i.e. no allocation has occurred, or all allocations
have been deallocated).))

$(TR $(TDC static Allocator instance;, $(POST instance $(I is a valid)
Allocator $(I object))) $(TD Some allocators are $(I monostate), i.e. have only
an instance and hold only global state. (Notable examples are C's own
`malloc`-based allocator and D's garbage-collected heap.) Such allocators must
define a static `instance` instance that serves as the symbolic placeholder
for the global instance of the allocator. An allocator should not hold state
and define `instance` simultaneously. Depending on whether the allocator is
thread-safe or not, this instance may be `shared`.))
)

$(H2 Sample Assembly)

The example below features an _allocator modeled after $(HTTP goo.gl/m7329l,
jemalloc), which uses a battery of free-list allocators spaced so as to keep
internal fragmentation to a minimum. The `FList` definitions specify no
bounds for the freelist because the `Segregator` does all size selection in
advance.

Sizes through 3584 bytes are handled via freelists of staggered sizes. Sizes
from 3585 bytes through 4072 KB are handled by a `BitmappedBlock` with a
block size of 4 KB. Sizes above that are passed direct to the `GCAllocator`.

$(RUNNABLE_EXAMPLE
    ----
    import std.experimental.allocator;
    import std.algorithm.comparison : max;

    alias FList = FreeList!(GCAllocator, 0, unbounded);
    alias A = Segregator!(
        8, FreeList!(GCAllocator, 0, 8),
        128, Bucketizer!(FList, 1, 128, 16),
        256, Bucketizer!(FList, 129, 256, 32),
        512, Bucketizer!(FList, 257, 512, 64),
        1024, Bucketizer!(FList, 513, 1024, 128),
        2048, Bucketizer!(FList, 1025, 2048, 256),
        3584, Bucketizer!(FList, 2049, 3584, 512),
        4072 * 1024, AllocatorList!(n => Region!GCAllocator(max(n, 1024 * 4096))),
        GCAllocator
    );
    A tuMalloc;
    auto b = tuMalloc.allocate(500);
    assert(b.length == 500);
    auto c = tuMalloc.allocate(113);
    assert(c.length == 113);
    assert(tuMalloc.expand(c, 14));
    tuMalloc.deallocate(b);
    tuMalloc.deallocate(c);
    ----
)

$(H2 Allocating memory for sharing across threads)

One allocation pattern used in multithreaded applications is to share memory
across threads, and to deallocate blocks in a different thread than the one that
allocated it.

All allocators in this module accept and return `void[]` (as opposed to
$(D shared void[])). This is because at the time of allocation, deallocation, or
reallocation, the memory is effectively not `shared` (if it were, it would
reveal a bug at the application level).

The issue remains of calling `a.deallocate(b)` from a different thread than
the one that allocated `b`. It follows that both threads must have access to
the same instance `a` of the respective allocator type. By definition of D,
this is possible only if `a` has the `shared` qualifier. It follows that
the allocator type must implement `allocate` and `deallocate` as $(D
shared) methods. That way, the allocator commits to allowing usable `shared`
instances.

Conversely, allocating memory with one non-`shared` allocator, passing it
across threads (by casting the obtained buffer to `shared`), and later
deallocating it in a different thread (either with a different allocator object
or with the same allocator object after casting it to `shared`) is illegal.

$(H2 Building Blocks)

$(P The table below gives a synopsis of predefined allocator building blocks,
with their respective modules. Either `import` the needed modules individually,
or `import` `std.experimental.building_blocks`, which imports them all
`public`ly. The building blocks can be assembled in unbounded ways and also
combined with your own. For a collection of typical and useful preassembled
allocators and for inspiration in defining more such assemblies, refer to
$(MREF std,experimental,allocator,showcase).)

$(BOOKTABLE,
$(TR $(TH Allocator$(BR)) $(TH Description))

$(TR $(TDC2 NullAllocator, null_allocator) $(TD Very good at doing absolutely nothing. A good
starting point for defining other allocators or for studying the API.))

$(TR $(TDC3 GCAllocator, gc_allocator) $(TD The system-provided garbage-collector allocator.
This should be the default fallback allocator tapping into system memory. It
offers manual `free` and dutifully collects litter.))

$(TR $(TDC3 Mallocator, mallocator) $(TD The C heap _allocator, a.k.a. $(D
malloc)/`realloc`/`free`. Use sparingly and only for code that is unlikely
to leak.))

$(TR $(TDC3 AlignedMallocator, mallocator) $(TD Interface to OS-specific _allocators that
support specifying alignment:
$(HTTP man7.org/linux/man-pages/man3/posix_memalign.3.html, `posix_memalign`)
on Posix and $(HTTP msdn.microsoft.com/en-us/library/fs9stz4e(v=vs.80).aspx,
`__aligned_xxx`) on Windows.))

$(TR $(TDC2 AlignedBlockList, aligned_block_list) $(TD A wrapper around a list of allocators
which allow for very fast deallocations.))

$(TR $(TDC2 AffixAllocator, affix_allocator) $(TD Allocator that allows and manages allocating
extra prefix and/or a suffix bytes for each block allocated.))

$(TR $(TDC2 BitmappedBlock, bitmapped_block) $(TD Organizes one contiguous chunk of memory in
equal-size blocks and tracks allocation status at the cost of one bit per
block.))

$(TR $(TDC2 FallbackAllocator, fallback_allocator) $(TD Allocator that combines two other
 allocators - primary and fallback. Allocation requests are first tried with primary, and
 upon failure are passed to the fallback. Useful for small and fast allocators
 fronting general-purpose ones.))

$(TR $(TDC2 FreeList, free_list) $(TD Allocator that implements a $(HTTP
wikipedia.org/wiki/Free_list, free list) on top of any other allocator. The
preferred size, tolerance, and maximum elements are configurable at compile- and
run time.))

$(TR $(TDC2 SharedFreeList, free_list) $(TD Same features as `FreeList`, but packaged as
a `shared` structure that is accessible to several threads.))

$(TR $(TDC2 FreeTree, free_tree) $(TD Allocator similar to `FreeList` that uses a
binary search tree to adaptively store not one, but many free lists.))

$(TR $(TDC2 Region, region) $(TD Region allocator organizes a chunk of memory as a
simple bump-the-pointer allocator.))

$(TR $(TDC2 InSituRegion, region) $(TD Region holding its own allocation, most often on
the stack. Has statically-determined size.))

$(TR $(TDC2 SbrkRegion, region) $(TD Region using $(D $(LINK2 https://en.wikipedia.org/wiki/Sbrk,
sbrk)) for allocating memory.))

$(TR $(TDC3 MmapAllocator, mmap_allocator) $(TD Allocator using
            $(D $(LINK2 https://en.wikipedia.org/wiki/Mmap, mmap)) directly.))

$(TR $(TDC2 StatsCollector, stats_collector) $(TD Collect statistics about any other
allocator.))

$(TR $(TDC2 Quantizer, quantizer) $(TD Allocates in coarse-grained quantas, thus
improving performance of reallocations by often reallocating in place. The drawback is higher memory consumption because of allocated and unused memory.))

$(TR $(TDC2 AllocatorList, allocator_list) $(TD Given an allocator factory, lazily creates as
many allocators as needed to satisfy allocation requests. The allocators are
stored in a linked list. Requests for allocation are satisfied by searching the
list in a linear manner.))

$(TR $(TDC2 Segregator, segregator) $(TD Segregates allocation requests by size
and dispatches them to distinct allocators.))

$(TR $(TDC2 Bucketizer, bucketizer) $(TD Divides allocation sizes in discrete buckets and
uses an array of allocators, one per bucket, to satisfy requests.))

$(TR $(TDC2 AscendingPageAllocator, ascending_page_allocator) $(TD A memory safe allocator
where sizes are rounded to a multiple of the page size and allocations are satisfied at increasing addresses.))

$(COMMENT $(TR $(TDC2 InternalPointersTree) $(TD Adds support for resolving internal
pointers on top of another allocator.)))
)

Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/package.d)

Macros:
MYREF2 = $(REF_SHORT $1, std,experimental,allocator,building_blocks,$2)
MYREF3 = $(REF_SHORT $1, std,experimental,allocator,$2)
TDC = $(TDNW `$1`$+)
TDC2 = $(TDNW $(D $(MYREF2 $1,$+))$(BR)$(SMALL
`std.experimental.allocator.building_blocks.$2`))
TDC3 = $(TDNW $(D $(MYREF3 $1,$+))$(BR)$(SMALL
`std.experimental.allocator.$2`))
RES = $(I result)
POST = $(BR)$(SMALL $(I Post:) $(BLUE `$0`))
*/

module std.experimental.allocator.building_blocks;

public import
    std.experimental.allocator.building_blocks.affix_allocator,
    std.experimental.allocator.building_blocks.aligned_block_list,
    std.experimental.allocator.building_blocks.allocator_list,
    std.experimental.allocator.building_blocks.ascending_page_allocator,
    std.experimental.allocator.building_blocks.bucketizer,
    std.experimental.allocator.building_blocks.fallback_allocator,
    std.experimental.allocator.building_blocks.free_list,
    std.experimental.allocator.building_blocks.free_tree,
    std.experimental.allocator.gc_allocator,
    std.experimental.allocator.building_blocks.bitmapped_block,
    std.experimental.allocator.building_blocks.kernighan_ritchie,
    std.experimental.allocator.mallocator,
    std.experimental.allocator.mmap_allocator,
    std.experimental.allocator.building_blocks.null_allocator,
    std.experimental.allocator.building_blocks.quantizer,
    std.experimental.allocator.building_blocks.region,
    std.experimental.allocator.building_blocks.segregator,
    std.experimental.allocator.building_blocks.stats_collector;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/quantizer.d)
*/
module std.experimental.allocator.building_blocks.quantizer;

import std.experimental.allocator.common;

/**
This allocator sits on top of `ParentAllocator` and quantizes allocation sizes,
usually from arbitrary positive numbers to a small set of round numbers (e.g.
powers of two, page sizes etc). This technique is commonly used to:

$(UL
$(LI Preallocate more memory than requested such that later on, when
reallocation is needed (e.g. to grow an array), expansion can be done quickly
in place. Reallocation to smaller sizes is also fast (in-place) when the new
size requested is within the same quantum as the existing size. Code that's
reallocation-heavy can therefore benefit from fronting a generic allocator with
a `Quantizer`. These advantages are present even if `ParentAllocator` does not
support reallocation at all.)
$(LI Improve behavior of allocators sensitive to allocation sizes, such as
`FreeList` and `FreeTree`. Rounding allocation requests up makes for smaller
free lists/trees at the cost of slack memory (internal fragmentation).)
)

The following methods are forwarded to the parent allocator if present:
`allocateAll`, `owns`, `deallocateAll`, `empty`.

Preconditions: `roundingFunction` must satisfy three constraints. These are
not enforced (save for the use of `assert`) for the sake of efficiency.
$(OL
$(LI $(D roundingFunction(n) >= n) for all `n` of type `size_t`;)
$(LI `roundingFunction` must be monotonically increasing, i.e. $(D
roundingFunction(n1) <= roundingFunction(n2)) for all $(D n1 < n2);)
$(LI `roundingFunction` must be `nothrow`, `@safe`, `@nogc` and `pure`, i.e.
always return the same value for a given `n`.)
)
*/
struct Quantizer(ParentAllocator, alias roundingFunction)
{
    import std.traits : hasMember;

    /**
    The parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator)
    {
        ParentAllocator parent;
    }
    else
    {
        alias parent = ParentAllocator.instance;
        __gshared Quantizer instance;
    }

    /**
    Returns `roundingFunction(n)`.
    */
    size_t goodAllocSize(size_t n)
    {
        auto result = roundingFunction(n);
        assert(result >= n);
        return result;
    }

    /**
    Alignment is identical to that of the parent.
    */
    enum alignment = ParentAllocator.alignment;

    /**
    Gets a larger buffer `buf` by calling
    `parent.allocate(goodAllocSize(n))`. If `buf` is `null`, returns
    `null`. Otherwise, returns $(D buf[0 .. n]).
    */
    void[] allocate(size_t n)
    {
        auto result = parent.allocate(goodAllocSize(n));
        return result.ptr ? result.ptr[0 .. n] : null;
    }

    static if (hasMember!(ParentAllocator, "allocateZeroed"))
    package(std) void[] allocateZeroed()(size_t n)
    {
        auto result = parent.allocateZeroed(goodAllocSize(n));
        return result.ptr ? result.ptr[0 .. n] : null;
    }

    /**
    Defined only if `parent.alignedAllocate` exists and works similarly to
    `allocate` by forwarding to
    $(D parent.alignedAllocate(goodAllocSize(n), a)).
    */
    static if (hasMember!(ParentAllocator, "alignedAllocate"))
    void[] alignedAllocate(size_t n, uint a)
    {
        auto result = parent.alignedAllocate(goodAllocSize(n), a);
        return result.ptr ? result.ptr[0 .. n] : null;
    }

    /**
    First checks whether there's enough slack memory preallocated for `b`
    by evaluating $(D b.length + delta <= goodAllocSize(b.length)). If that's
    the case, expands `b` in place. Otherwise, attempts to use
    `parent.expand` appropriately if present.
    */
    bool expand(ref void[] b, size_t delta)
    {
        if (!b || delta == 0) return delta == 0;
        immutable allocated = goodAllocSize(b.length),
            needed = b.length + delta,
            neededAllocation = goodAllocSize(needed);
        assert(b.length <= allocated);
        assert(needed <= neededAllocation);
        assert(allocated <= neededAllocation);
        // Second test needed because expand must work for null pointers, too.
        if (allocated == neededAllocation)
        {
            // Nice!
            b = (() @trusted => b.ptr[0 .. needed])();
            return true;
        }
        // Hail Mary
        static if (hasMember!(ParentAllocator, "expand"))
        {
            // Expand to the appropriate quantum
            auto original = (() @trusted => b.ptr[0 .. allocated])();
            assert(goodAllocSize(needed) >= allocated);
            if (!parent.expand(original, neededAllocation - allocated))
                return false;
            // Dial back the size
            b = (() @trusted => original.ptr[0 .. needed])();
            return true;
        }
        else
        {
            return false;
        }
    }

    /**
    Expands or shrinks allocated block to an allocated size of $(D
    goodAllocSize(s)). Expansion occurs in place under the conditions required
    by `expand`. Shrinking occurs in place if $(D goodAllocSize(b.length)
    == goodAllocSize(s)).
    */
    bool reallocate(ref void[] b, size_t s)
    {
        if (!b.ptr)
        {
            b = allocate(s);
            return b.length == s;
        }
        if (s >= b.length && expand(b, s - b.length)) return true;
        immutable toAllocate = goodAllocSize(s),
            allocated = goodAllocSize(b.length);
        // Are the lengths within the same quantum?
        if (allocated == toAllocate)
        {
            // Reallocation (whether up or down) will be done in place
            b = b.ptr[0 .. s];
            return true;
        }
        // Defer to parent (or global) with quantized size
        auto original = b.ptr[0 .. allocated];
        if (!parent.reallocate(original, toAllocate)) return false;
        b = original.ptr[0 .. s];
        return true;
    }

    /**
    Defined only if `ParentAllocator.alignedAllocate` exists. Expansion
    occurs in place under the conditions required by `expand`. Shrinking
    occurs in place if $(D goodAllocSize(b.length) == goodAllocSize(s)).
    */
    static if (hasMember!(ParentAllocator, "alignedAllocate"))
    bool alignedReallocate(ref void[] b, size_t s, uint a)
    {
        if (!b.ptr)
        {
            b = alignedAllocate(s, a);
            return b.length == s;
        }
        if (s >= b.length && b.ptr.alignedAt(a) && expand(b, s - b.length)) return true;
        immutable toAllocate = goodAllocSize(s),
            allocated = goodAllocSize(b.length);
        // Are the lengths within the same quantum?
        if (allocated == toAllocate && b.ptr.alignedAt(a))
        {
            assert(b.ptr); // code above must have caught this
            // Reallocation (whether up or down) will be done in place
            b = b.ptr[0 .. s];
            return true;
        }
        // Defer to parent (or global) with quantized size
        auto original = b.ptr[0 .. allocated];
        if (!parent.alignedReallocate(original, toAllocate, a)) return false;
        b = original.ptr[0 .. s];
        return true;
    }

    /**
    Defined if `ParentAllocator.deallocate` exists and forwards to
    $(D parent.deallocate(b.ptr[0 .. goodAllocSize(b.length)])).
    */
    static if (hasMember!(ParentAllocator, "deallocate"))
    bool deallocate(void[] b)
    {
        if (!b.ptr) return true;
        return parent.deallocate(b.ptr[0 .. goodAllocSize(b.length)]);
    }

    // Forwarding methods
    mixin(forwardToMember("parent",
        "allocateAll", "owns", "deallocateAll", "empty"));
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.free_tree : FreeTree;
    import std.experimental.allocator.gc_allocator : GCAllocator;

    size_t roundUpToMultipleOf(size_t s, uint base)
    {
        auto rem = s % base;
        return rem ? s + base - rem : s;
    }

    // Quantize small allocations to a multiple of cache line, large ones to a
    // multiple of page size
    alias MyAlloc = Quantizer!(
        FreeTree!GCAllocator,
        n => roundUpToMultipleOf(n, n <= 16_384 ? 64 : 4096));
    MyAlloc alloc;
    const buf = alloc.allocate(256);
    assert(buf.ptr);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    alias MyAlloc = Quantizer!(GCAllocator,
        (size_t n) => n.roundUpToMultipleOf(64));
    testAllocator!(() => MyAlloc());

    assert((() pure nothrow @safe @nogc => MyAlloc().goodAllocSize(1))() == 64);

    auto a = MyAlloc();
    auto b = a.allocate(42);
    assert(b.length == 42);
    // Inplace expand, since goodAllocSize is 64
    assert((() @safe => a.expand(b, 22))());
    //assert((() nothrow @safe => a.expand(b, 22))());
    assert(b.length == 64);
    // Trigger parent.expand, which may or may not succed
    //() nothrow @safe { a.expand(b, 1); }();
    () @safe { a.expand(b, 1); }();
    assert(a.reallocate(b, 100));
    assert(b.length == 100);
    // Ensure deallocate inherits from parent
    () nothrow @nogc { a.deallocate(b); }();
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;

    alias Alloc = Quantizer!(Region!(Mallocator),
            (size_t n) => n.roundUpToMultipleOf(64));
    auto a = Alloc(Region!Mallocator(1024 * 64));
    const b = a.allocate(42);
    assert(b.length == 42);
    // Check that owns inherits from parent, i.e. Region
    assert((() pure nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() pure nothrow @safe @nogc => a.owns(null))() == Ternary.no);

    auto c = a.allocate(42);
    assert(c.length == 42);
    assert((() pure nothrow @safe @nogc => a.owns(c))() == Ternary.yes);
    // Inplace expand, since goodAllocSize is 64
    assert((() nothrow @safe => a.expand(c, 22))());
    assert(c.length == 64);
    // Trigger parent.expand
    assert((() nothrow @safe => a.expand(c, 1))());
    assert(c.length == 65);
    // Check that reallocate inherits from parent
    assert((() nothrow @nogc => a.reallocate(c, 100))());
    assert(c.length == 100);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.mallocator : Mallocator;

    alias MyAlloc = Quantizer!(Region!(Mallocator),
            (size_t n) => n.roundUpToMultipleOf(64));
    testAllocator!(() => MyAlloc(Region!Mallocator(1024 * 64)));

    auto a = MyAlloc(Region!Mallocator(1024 * 64));
    void[] b;
    assert((() nothrow @nogc => a.alignedReallocate(b, 42, 16))());
    assert(b.length == 42);
    assert(alignedAt(&b[0], 16));
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.typecons : Ternary;

    alias MyAlloc = Quantizer!(BorrowedRegion!(),
        (size_t n) => n.roundUpToMultipleOf(64));
    testAllocator!(() => MyAlloc(BorrowedRegion!()(new ubyte[1024 * 64])));

    auto a = MyAlloc(BorrowedRegion!()(new ubyte[1024 * 64]));
    // Check that empty inherits from parent
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.no);
    // Check that deallocateAll inherits from parent
    assert((() nothrow @nogc => a.deallocateAll())());
    assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/region.d)
*/
module std.experimental.allocator.building_blocks.region;

import std.experimental.allocator.building_blocks.null_allocator;
import std.experimental.allocator.common;
import std.typecons : Flag, Yes, No;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

/**
A `Region` allocator allocates memory straight from one contiguous chunk.
There is no deallocation, and once the region is full, allocation requests
return `null`. Therefore, `Region`s are often used (a) in conjunction with
more sophisticated allocators; or (b) for batch-style very fast allocations
that deallocate everything at once.

The region only stores three pointers, corresponding to the current position in
the store and the limits. One allocation entails rounding up the allocation
size for alignment purposes, bumping the current pointer, and comparing it
against the limit.

`Region` deallocates the chunk of memory during destruction.

The `minAlign` parameter establishes alignment. If $(D minAlign > 1), the
sizes of all allocation requests are rounded up to a multiple of `minAlign`.
Applications aiming at maximum speed may want to choose $(D minAlign = 1) and
control alignment externally.

*/
struct Region(ParentAllocator,
    uint minAlign = platformAlignment,
    Flag!"growDownwards" growDownwards = No.growDownwards)
{
    static assert(minAlign.isGoodStaticAlignment);
    static assert(ParentAllocator.alignment >= minAlign);

    import std.traits : hasMember;
    import std.typecons : Ternary;

    // state
    /**
    The _parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator)
    {
        ParentAllocator parent;
    }
    else
    {
        alias parent = ParentAllocator.instance;
    }

    private BorrowedRegion!(minAlign, growDownwards) _impl;

    private void* roundedBegin() const pure nothrow @trusted @nogc
    {
        return _impl.roundedBegin;
    }

    private void* roundedEnd() const pure nothrow @trusted @nogc
    {
        return _impl.roundedEnd;
    }
    /**
    Constructs a region backed by a user-provided store.
    Assumes the memory was allocated with `ParentAllocator`.

    Params:
        store = User-provided store backing up the region. Assumed to have been
        allocated with `ParentAllocator`.
        n = Bytes to allocate using `ParentAllocator`. If `parent.allocate(n)`
        returns `null`, the region will be initialized as empty (correctly
        initialized but unable to allocate).
        */
    this(ubyte[] store) pure nothrow @nogc
    {
        _impl = store;
    }

    /// Ditto
    static if (!stateSize!ParentAllocator)
    this(size_t n)
    {
        this(cast(ubyte[]) (parent.allocate(n.roundUpToAlignment(alignment))));
    }

    /// Ditto
    static if (stateSize!ParentAllocator)
    this(ParentAllocator parent, size_t n)
    {
        this.parent = parent;
        this(cast(ubyte[]) (parent.allocate(n.roundUpToAlignment(alignment))));
    }

    /*
    TODO: The postblit of `BasicRegion` should be disabled because such objects
    should not be copied around naively.
    */

    /**
    If `ParentAllocator` defines `deallocate`, the region defines a destructor
    that uses `ParentAllocator.deallocate` to free the memory chunk.
    */
    static if (hasMember!(ParentAllocator, "deallocate"))
    ~this()
    {
        with (_impl) parent.deallocate(_begin[0 .. _end - _begin]);
    }

    /**
    Rounds the given size to a multiple of the `alignment`
    */
    size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc
    {
        return _impl.goodAllocSize(n);
    }

    /**
    Alignment offered.
    */
    alias alignment = minAlign;

    /**
    Allocates `n` bytes of memory. The shortest path involves an alignment
    adjustment (if $(D alignment > 1)), an increment, and a comparison.

    Params:
        n = number of bytes to allocate

    Returns:
        A properly-aligned buffer of size `n` or `null` if request could not
        be satisfied.
    */
    void[] allocate(size_t n) pure nothrow @trusted @nogc
    {
        return _impl.allocate(n);
    }

    /**
    Allocates `n` bytes of memory aligned at alignment `a`.

    Params:
        n = number of bytes to allocate
        a = alignment for the allocated block

    Returns:
        Either a suitable block of `n` bytes aligned at `a`, or `null`.
    */
    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc
    {
        return _impl.alignedAllocate(n, a);
    }

    /// Allocates and returns all memory available to this region.
    void[] allocateAll() pure nothrow @trusted @nogc
    {
        return _impl.allocateAll;
    }

    /**
    Expands an allocated block in place. Expansion will succeed only if the
    block is the last allocated. Defined only if `growDownwards` is
    `No.growDownwards`.
    */
    static if (growDownwards == No.growDownwards)
    bool expand(ref void[] b, size_t delta) pure nothrow @safe @nogc
    {
        return _impl.expand(b, delta);
    }

    /**
    Deallocates `b`. This works only if `b` was obtained as the last call
    to `allocate`; otherwise (i.e. another allocation has occurred since) it
    does nothing.

    Params:
        b = Block previously obtained by a call to `allocate` against this
        allocator (`null` is allowed).
    */
    bool deallocate(void[] b) pure nothrow @nogc
    {
        return _impl.deallocate(b);
    }

    /**
    Deallocates all memory allocated by this region, which can be subsequently
    reused for new allocations.
    */
    bool deallocateAll() pure nothrow @nogc
    {
        return _impl.deallocateAll;
    }

    /**
    Queries whether `b` has been allocated with this region.

    Params:
        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns
        `false`).

    Returns:
        `true` if `b` has been allocated with this region, `false` otherwise.
    */
    Ternary owns(const void[] b) const pure nothrow @trusted @nogc
    {
        return _impl.owns(b);
    }

    /**
    Returns `Ternary.yes` if no memory has been allocated in this region,
    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)
    */
    Ternary empty() const pure nothrow @safe @nogc
    {
        return _impl.empty;
    }

    /// Nonstandard property that returns bytes available for allocation.
    size_t available() const @safe pure nothrow @nogc
    {
        return _impl.available;
    }
}

///
@system nothrow unittest
{
    import std.algorithm.comparison : max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    // Create a scalable list of regions. Each gets at least 1MB at a time by
    // using malloc.
    auto batchAllocator = AllocatorList!(
        (size_t n) => Region!Mallocator(max(n, 1024 * 1024))
    )();
    assert(batchAllocator.empty ==  Ternary.yes);
    auto b = batchAllocator.allocate(101);
    assert(b.length == 101);
    assert(batchAllocator.empty ==  Ternary.no);
    // This will cause a second allocation
    b = batchAllocator.allocate(2 * 1024 * 1024);
    assert(b.length == 2 * 1024 * 1024);
    // Destructor will free the memory
}

@system nothrow @nogc unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;

    static void testAlloc(Allocator)(ref Allocator a)
    {
        assert((() pure nothrow @safe @nogc => a.empty)() ==  Ternary.yes);
        const b = a.allocate(101);
        assert(b.length == 101);
        assert((() nothrow @safe @nogc => a.owns(b))() == Ternary.yes);

        // Ensure deallocate inherits from parent allocators
        auto c = a.allocate(42);
        assert(c.length == 42);
        assert((() nothrow @nogc => a.deallocate(c))());
        assert((() pure nothrow @safe @nogc => a.empty)() ==  Ternary.no);
    }

    // Create a 64 KB region allocated with malloc
    auto reg = Region!(Mallocator, Mallocator.alignment,
        Yes.growDownwards)(1024 * 64);
    testAlloc(reg);

    // Create a 64 KB shared region allocated with malloc
    auto sharedReg = SharedRegion!(Mallocator, Mallocator.alignment,
        Yes.growDownwards)(1024 * 64);
    testAlloc(sharedReg);
}

@system nothrow @nogc unittest
{
    // test 'this(ubyte[] store)' constructed regions properly clean up
    // their inner storage after destruction
    import std.experimental.allocator.mallocator : Mallocator;

    static shared struct LocalAllocator
    {
    nothrow @nogc:
        enum alignment = Mallocator.alignment;
        void[] buf;
        bool deallocate(void[] b)
        {
            assert(buf.ptr == b.ptr && buf.length == b.length);
            return true;
        }

        void[] allocate(size_t n)
        {
            return null;
        }

    }

    enum bufLen = 10 * Mallocator.alignment;
    void[] tmp = Mallocator.instance.allocate(bufLen);

    LocalAllocator a;
    a.buf = cast(typeof(a.buf)) tmp[1 .. $];

    auto reg = Region!(LocalAllocator, Mallocator.alignment,
        Yes.growDownwards)(cast(ubyte[]) a.buf);
    auto sharedReg = SharedRegion!(LocalAllocator, Mallocator.alignment,
        Yes.growDownwards)(cast(ubyte[]) a.buf);
    reg.parent = a;
    sharedReg.parent = a;

    Mallocator.instance.deallocate(tmp);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    testAllocator!(() => Region!(Mallocator)(1024 * 64));
    testAllocator!(() => Region!(Mallocator, Mallocator.alignment, Yes.growDownwards)(1024 * 64));

    testAllocator!(() => SharedRegion!(Mallocator)(1024 * 64));
    testAllocator!(() => SharedRegion!(Mallocator, Mallocator.alignment, Yes.growDownwards)(1024 * 64));
}

@system nothrow @nogc unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    auto reg = Region!(Mallocator)(1024 * 64);
    auto b = reg.allocate(101);
    assert(b.length == 101);
    assert((() pure nothrow @safe @nogc => reg.expand(b, 20))());
    assert((() pure nothrow @safe @nogc => reg.expand(b, 73))());
    assert((() pure nothrow @safe @nogc => !reg.expand(b, 1024 * 64))());
    assert((() nothrow @nogc => reg.deallocateAll())());
}

/**
A `BorrowedRegion` allocates directly from a user-provided block of memory.

Unlike a `Region`, a `BorrowedRegion` does not own the memory it allocates from
and will not deallocate that memory upon destruction. Instead, it is the user's
responsibility to ensure that the memory is properly disposed of.

In all other respects, a `BorrowedRegion` behaves exactly like a `Region`.
*/
struct BorrowedRegion(uint minAlign = platformAlignment,
    Flag!"growDownwards" growDownwards = No.growDownwards)
{
    static assert(minAlign.isGoodStaticAlignment);

    import std.typecons : Ternary;

    // state
    private void* _current, _begin, _end;

    private void* roundedBegin() const pure nothrow @trusted @nogc
    {
        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);
    }

    private void* roundedEnd() const pure nothrow @trusted @nogc
    {
        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);
    }

    /**
    Constructs a region backed by a user-provided store.

    Params:
        store = User-provided store backing up the region.
    */
    this(ubyte[] store) pure nothrow @nogc
    {
        _begin = store.ptr;
        _end = store.ptr + store.length;
        static if (growDownwards)
            _current = roundedEnd();
        else
            _current = roundedBegin();
    }

    /*
    TODO: The postblit of `BorrowedRegion` should be disabled because such objects
    should not be copied around naively.
    */

    /**
    Rounds the given size to a multiple of the `alignment`
    */
    size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc
    {
        return n.roundUpToAlignment(alignment);
    }

    /**
    Alignment offered.
    */
    alias alignment = minAlign;

    /**
    Allocates `n` bytes of memory. The shortest path involves an alignment
    adjustment (if $(D alignment > 1)), an increment, and a comparison.

    Params:
        n = number of bytes to allocate

    Returns:
        A properly-aligned buffer of size `n` or `null` if request could not
        be satisfied.
    */
    void[] allocate(size_t n) pure nothrow @trusted @nogc
    {
        const rounded = goodAllocSize(n);
        if (n == 0 || rounded < n || available < rounded) return null;

        static if (growDownwards)
        {
            assert(available >= rounded);
            auto result = (_current - rounded)[0 .. n];
            assert(result.ptr >= _begin);
            _current = result.ptr;
            assert(owns(result) == Ternary.yes);
        }
        else
        {
            auto result = _current[0 .. n];
            _current += rounded;
        }

        return result;
    }

    /**
    Allocates `n` bytes of memory aligned at alignment `a`.

    Params:
        n = number of bytes to allocate
        a = alignment for the allocated block

    Returns:
        Either a suitable block of `n` bytes aligned at `a`, or `null`.
    */
    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc
    {
        import std.math.traits : isPowerOf2;
        assert(a.isPowerOf2);

        const rounded = goodAllocSize(n);
        if (n == 0 || rounded < n || available < rounded) return null;

        static if (growDownwards)
        {
            auto tmpCurrent = _current - rounded;
            auto result = tmpCurrent.alignDownTo(a);
            if (result <= tmpCurrent && result >= _begin)
            {
                _current = result;
                return cast(void[]) result[0 .. n];
            }
        }
        else
        {
            // Just bump the pointer to the next good allocation
            auto newCurrent = _current.alignUpTo(a);
            if (newCurrent < _current || newCurrent > _end)
                return null;

            auto save = _current;
            _current = newCurrent;
            auto result = allocate(n);
            if (result.ptr)
            {
                assert(result.length == n);
                return result;
            }
            // Failed, rollback
            _current = save;
        }
        return null;
    }

    /// Allocates and returns all memory available to this region.
    void[] allocateAll() pure nothrow @trusted @nogc
    {
        static if (growDownwards)
        {
            auto result = _begin[0 .. available];
            _current = _begin;
        }
        else
        {
            auto result = _current[0 .. available];
            _current = _end;
        }
        return result;
    }

    /**
    Expands an allocated block in place. Expansion will succeed only if the
    block is the last allocated. Defined only if `growDownwards` is
    `No.growDownwards`.
    */
    static if (growDownwards == No.growDownwards)
    bool expand(ref void[] b, size_t delta) pure nothrow @safe @nogc
    {
        assert(owns(b) == Ternary.yes || b is null);
        assert((() @trusted => b.ptr + b.length <= _current)() || b is null);
        if (b is null || delta == 0) return delta == 0;
        auto newLength = b.length + delta;
        if ((() @trusted => _current < b.ptr + b.length + alignment)())
        {
            immutable currentGoodSize = this.goodAllocSize(b.length);
            immutable newGoodSize = this.goodAllocSize(newLength);
            immutable goodDelta = newGoodSize - currentGoodSize;
            // This was the last allocation! Allocate some more and we're done.
            if (goodDelta == 0
                || (() @trusted => allocate(goodDelta).length == goodDelta)())
            {
                b = (() @trusted => b.ptr[0 .. newLength])();
                assert((() @trusted => _current < b.ptr + b.length + alignment)());
                return true;
            }
        }
        return false;
    }

    /**
    Deallocates `b`. This works only if `b` was obtained as the last call
    to `allocate`; otherwise (i.e. another allocation has occurred since) it
    does nothing.

    Params:
        b = Block previously obtained by a call to `allocate` against this
        allocator (`null` is allowed).
    */
    bool deallocate(void[] b) pure nothrow @nogc
    {
        assert(owns(b) == Ternary.yes || b.ptr is null);
        auto rounded = goodAllocSize(b.length);
        static if (growDownwards)
        {
            if (b.ptr == _current)
            {
                _current += rounded;
                return true;
            }
        }
        else
        {
            if (b.ptr + rounded == _current)
            {
                assert(b.ptr !is null || _current is null);
                _current = b.ptr;
                return true;
            }
        }
        return false;
    }

    /**
    Deallocates all memory allocated by this region, which can be subsequently
    reused for new allocations.
    */
    bool deallocateAll() pure nothrow @nogc
    {
        static if (growDownwards)
        {
            _current = roundedEnd();
        }
        else
        {
            _current = roundedBegin();
        }
        return true;
    }

    /**
    Queries whether `b` has been allocated with this region.

    Params:
        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns
        `false`).

    Returns:
        `true` if `b` has been allocated with this region, `false` otherwise.
    */
    Ternary owns(const void[] b) const pure nothrow @trusted @nogc
    {
        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));
    }

    /**
    Returns `Ternary.yes` if no memory has been allocated in this region,
    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)
    */
    Ternary empty() const pure nothrow @safe @nogc
    {
        static if (growDownwards)
            return Ternary(_current == roundedEnd());
        else
            return Ternary(_current == roundedBegin());
    }

    /// Nonstandard property that returns bytes available for allocation.
    size_t available() const @safe pure nothrow @nogc
    {
        static if (growDownwards)
        {
            return _current - _begin;
        }
        else
        {
            return _end - _current;
        }
    }
}

///
@system nothrow @nogc unittest
{
    import std.typecons : Ternary;

    ubyte[1024] store;
    auto myRegion = BorrowedRegion!(1)(store[]);

    assert(myRegion.empty == Ternary.yes);
    assert(myRegion.available == store.length);

    void[] b = myRegion.allocate(101);

    assert(b.length == 101);
    assert(myRegion.empty == Ternary.no);
    assert(myRegion.owns(b) == Ternary.yes);
    assert(myRegion.available == store.length - b.length);

    void[] b2 = myRegion.allocate(256);

    // Can only free the most recent allocation
    assert(myRegion.deallocate(b) == false);
    assert(myRegion.deallocate(b2) == true);

    myRegion.deallocateAll();

    assert(myRegion.empty == Ternary.yes);
}

@system nothrow @nogc unittest
{
    import std.experimental.allocator.mallocator : AlignedMallocator;
    import std.typecons : Ternary;

    ubyte[] buf = cast(ubyte[]) AlignedMallocator.instance.alignedAllocate(64, 64);
    auto reg = BorrowedRegion!(64, Yes.growDownwards)(buf);
    assert(reg.alignedAllocate(10, 32).length == 10);
    assert(!reg.available);
}

/**

`InSituRegion` is a convenient region that carries its storage within itself
(in the form of a statically-sized array).

The first template argument is the size of the region and the second is the
needed alignment. Depending on the alignment requested and platform details,
the actual available storage may be smaller than the compile-time parameter. To
make sure that at least `n` bytes are available in the region, use
$(D InSituRegion!(n + a - 1, a)).

Given that the most frequent use of `InSituRegion` is as a stack allocator, it
allocates starting at the end on systems where stack grows downwards, such that
hot memory is used first.

*/
struct InSituRegion(size_t size, size_t minAlign = platformAlignment)
{
    import std.algorithm.comparison : max;
    import std.conv : to;
    import std.traits : hasMember;
    import std.typecons : Ternary;
    import core.thread.types : isStackGrowingDown;

    static assert(minAlign.isGoodStaticAlignment);
    static assert(size >= minAlign);

    static if (isStackGrowingDown)
        enum growDownwards = Yes.growDownwards;
    else
        enum growDownwards = No.growDownwards;

    @disable this(this);

    // state {
    private BorrowedRegion!(minAlign, growDownwards) _impl;
    union
    {
        private ubyte[size] _store = void;
        private double _forAlignmentOnly1;
    }
    // }

    /**
    An alias for `minAlign`, which must be a valid alignment (nonzero power
    of 2). The start of the region and all allocation requests will be rounded
    up to a multiple of the alignment.

    ----
    InSituRegion!(4096) a1;
    assert(a1.alignment == platformAlignment);
    InSituRegion!(4096, 64) a2;
    assert(a2.alignment == 64);
    ----
    */
    alias alignment = minAlign;

    private void lazyInit()
    {
        assert(!_impl._current);
        _impl = typeof(_impl)(_store);
        assert(_impl._current.alignedAt(alignment));
    }

    /**
    Allocates `bytes` and returns them, or `null` if the region cannot
    accommodate the request. For efficiency reasons, if $(D bytes == 0) the
    function returns an empty non-null slice.
    */
    void[] allocate(size_t n)
    {
        // Fast path
    entry:
        auto result = _impl.allocate(n);
        if (result.length == n) return result;
        // Slow path
        if (_impl._current) return null; // no more room
        lazyInit;
        assert(_impl._current);
        goto entry;
    }

    /**
    As above, but the memory allocated is aligned at `a` bytes.
    */
    void[] alignedAllocate(size_t n, uint a)
    {
        // Fast path
    entry:
        auto result = _impl.alignedAllocate(n, a);
        if (result.length == n) return result;
        // Slow path
        if (_impl._current) return null; // no more room
        lazyInit;
        assert(_impl._current);
        goto entry;
    }

    /**
    Deallocates `b`. This works only if `b` was obtained as the last call
    to `allocate`; otherwise (i.e. another allocation has occurred since) it
    does nothing. This semantics is tricky and therefore `deallocate` is
    defined only if `Region` is instantiated with `Yes.defineDeallocate`
    as the third template argument.

    Params:
        b = Block previously obtained by a call to `allocate` against this
        allocator (`null` is allowed).
    */
    bool deallocate(void[] b)
    {
        if (!_impl._current) return b is null;
        return _impl.deallocate(b);
    }

    /**
    Returns `Ternary.yes` if `b` is the result of a previous allocation,
    `Ternary.no` otherwise.
    */
    Ternary owns(const void[] b) pure nothrow @safe @nogc
    {
        if (!_impl._current) return Ternary.no;
        return _impl.owns(b);
    }

    /**
    Expands an allocated block in place. Expansion will succeed only if the
    block is the last allocated.
    */
    static if (hasMember!(typeof(_impl), "expand"))
    bool expand(ref void[] b, size_t delta)
    {
        if (!_impl._current) lazyInit;
        return _impl.expand(b, delta);
    }

    /**
    Deallocates all memory allocated with this allocator.
    */
    bool deallocateAll()
    {
        // We don't care to lazily init the region
        return _impl.deallocateAll;
    }

    /**
    Allocates all memory available with this allocator.
    */
    void[] allocateAll()
    {
        if (!_impl._current) lazyInit;
        return _impl.allocateAll;
    }

    /**
    Nonstandard function that returns the bytes available for allocation.
    */
    size_t available()
    {
        if (!_impl._current) lazyInit;
        return _impl.available;
    }
}

///
@system unittest
{
    // 128KB region, allocated to x86's cache line
    InSituRegion!(128 * 1024, 16) r1;
    auto a1 = r1.allocate(101);
    assert(a1.length == 101);

    // 128KB region, with fallback to the garbage collector.
    import std.experimental.allocator.building_blocks.fallback_allocator
        : FallbackAllocator;
    import std.experimental.allocator.building_blocks.free_list
        : FreeList;
    import std.experimental.allocator.building_blocks.bitmapped_block
        : BitmappedBlock;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    FallbackAllocator!(InSituRegion!(128 * 1024), GCAllocator) r2;
    const a2 = r2.allocate(102);
    assert(a2.length == 102);

    // Reap with GC fallback.
    InSituRegion!(128 * 1024, 8) tmp3;
    FallbackAllocator!(BitmappedBlock!(64, 8), GCAllocator) r3;
    r3.primary = BitmappedBlock!(64, 8)(cast(ubyte[]) (tmp3.allocateAll()));
    const a3 = r3.allocate(103);
    assert(a3.length == 103);

    // Reap/GC with a freelist for small objects up to 16 bytes.
    InSituRegion!(128 * 1024, 64) tmp4;
    FreeList!(FallbackAllocator!(BitmappedBlock!(64, 64), GCAllocator), 0, 16) r4;
    r4.parent.primary = BitmappedBlock!(64, 64)(cast(ubyte[]) (tmp4.allocateAll()));
    const a4 = r4.allocate(104);
    assert(a4.length == 104);
}

@system pure nothrow unittest
{
    import std.typecons : Ternary;

    InSituRegion!(4096, 1) r1;
    auto a = r1.allocate(2001);
    assert(a.length == 2001);
    import std.conv : text;
    assert(r1.available == 2095, text(r1.available));
    // Ensure deallocate inherits from parent
    assert((() nothrow @nogc => r1.deallocate(a))());
    assert((() nothrow @nogc => r1.deallocateAll())());

    InSituRegion!(65_536, 1024*4) r2;
    assert(r2.available <= 65_536);
    a = r2.allocate(2001);
    assert(a.length == 2001);
    const void[] buff = r2.allocate(42);
    assert((() nothrow @safe @nogc => r2.owns(buff))() == Ternary.yes);
    assert((() nothrow @nogc => r2.deallocateAll())());
}

version (CRuntime_Musl)
{
    // sbrk and brk are disabled in Musl:
    // https://git.musl-libc.org/cgit/musl/commit/?id=7a995fe706e519a4f55399776ef0df9596101f93
    // https://git.musl-libc.org/cgit/musl/commit/?id=863d628d93ea341b6a32661a1654320ce69f6a07
}
version (DragonFlyBSD)
{
    // sbrk is deprecated in favor of mmap   (we could implement a mmap + MAP_NORESERVE + PROT_NONE version)
    // brk has been removed
    // https://www.dragonflydigest.com/2019/02/22/22586.html
    // http://gitweb.dragonflybsd.org/dragonfly.git/commitdiff/dc676eaefa61b0f47bbea1c53eab86fd5ccd78c6
    // http://gitweb.dragonflybsd.org/dragonfly.git/commitdiff/4b5665564ef37dc939a3a9ffbafaab9894c18885
    // http://gitweb.dragonflybsd.org/dragonfly.git/commitdiff/8618d94a0e2ff8303ad93c123a3fa598c26a116e
}
else
{
    private extern(C) void* sbrk(long) nothrow @nogc;
    private extern(C) int brk(shared void*) nothrow @nogc;
}

/**

Allocator backed by $(D $(LINK2 https://en.wikipedia.org/wiki/Sbrk, sbrk))
for Posix systems. Due to the fact that `sbrk` is not thread-safe
$(HTTP lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html, by design),
`SbrkRegion` uses a mutex internally. This implies
that uncontrolled calls to `brk` and `sbrk` may affect the workings of $(D
SbrkRegion) adversely.

*/
version (CRuntime_Musl) {} else
version (DragonFlyBSD) {} else
version (Posix) struct SbrkRegion(uint minAlign = platformAlignment)
{
    import core.sys.posix.pthread : pthread_mutex_init, pthread_mutex_destroy,
        pthread_mutex_t, pthread_mutex_lock, pthread_mutex_unlock,

    PTHREAD_MUTEX_INITIALIZER;
    private static shared pthread_mutex_t sbrkMutex = PTHREAD_MUTEX_INITIALIZER;
    import std.typecons : Ternary;

    static assert(minAlign.isGoodStaticAlignment);
    static assert(size_t.sizeof == (void*).sizeof);
    private shared void* _brkInitial, _brkCurrent;

    /**
    Instance shared by all callers.
    */
    static shared SbrkRegion instance;

    /**
    Standard allocator primitives.
    */
    enum uint alignment = minAlign;

    /**
    Rounds the given size to a multiple of thew `alignment`
    */
    size_t goodAllocSize(size_t n) shared const pure nothrow @safe @nogc
    {
        return n.roundUpToMultipleOf(alignment);
    }

    /// Ditto
    void[] allocate(size_t bytes) shared @trusted nothrow @nogc
    {
        // Take alignment rounding into account
        const rounded = goodAllocSize(bytes);

        pthread_mutex_lock(cast(pthread_mutex_t*) &sbrkMutex) == 0 || assert(0);
        scope(exit) pthread_mutex_unlock(cast(pthread_mutex_t*) &sbrkMutex) == 0
            || assert(0);
        // Assume sbrk returns the old break. Most online documentation confirms
        // that, except for http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf,
        // which claims the returned value is not portable.
        auto p = sbrk(rounded);
        if (p == cast(void*) -1)
        {
            return null;
        }
        if (!_brkInitial)
        {
            _brkInitial = cast(shared) p;
            assert(cast(size_t) _brkInitial % minAlign == 0,
                "Too large alignment chosen for " ~ typeof(this).stringof);
        }
        _brkCurrent = cast(shared) (p + rounded);
        return p[0 .. bytes];
    }

    /// Ditto
    void[] alignedAllocate(size_t bytes, uint a) shared @trusted nothrow @nogc
    {
        pthread_mutex_lock(cast(pthread_mutex_t*) &sbrkMutex) == 0 || assert(0);
        scope(exit) pthread_mutex_unlock(cast(pthread_mutex_t*) &sbrkMutex) == 0
            || assert(0);
        if (!_brkInitial)
        {
            // This is one extra call, but it'll happen only once.
            _brkInitial = cast(shared) sbrk(0);
            assert(cast(size_t) _brkInitial % minAlign == 0,
                "Too large alignment chosen for " ~ typeof(this).stringof);
            (_brkInitial != cast(void*) -1) || assert(0);
            _brkCurrent = _brkInitial;
        }
        immutable size_t delta = cast(shared void*) roundUpToMultipleOf(
            cast(size_t) _brkCurrent, a) - _brkCurrent;
        // Still must make sure the total size is aligned to the allocator's
        // alignment.
        immutable rounded = (bytes + delta).roundUpToMultipleOf(alignment);

        auto p = sbrk(rounded);
        if (p == cast(void*) -1)
        {
            return null;
        }
        _brkCurrent = cast(shared) (p + rounded);
        return p[delta .. delta + bytes];
    }

    /**

    The `expand` method may only succeed if the argument is the last block
    allocated. In that case, `expand` attempts to push the break pointer to
    the right.

    */
    bool expand(ref void[] b, size_t delta) shared nothrow @trusted @nogc
    {
        if (b is null || delta == 0) return delta == 0;
        assert(_brkInitial && _brkCurrent); // otherwise where did b come from?
        pthread_mutex_lock(cast(pthread_mutex_t*) &sbrkMutex) == 0 || assert(0);
        scope(exit) pthread_mutex_unlock(cast(pthread_mutex_t*) &sbrkMutex) == 0
            || assert(0);

        // Take alignment rounding into account
        const rounded = goodAllocSize(b.length);

        const slack = rounded - b.length;
        if (delta <= slack)
        {
            b = b.ptr[0 .. b.length + delta];
            return true;
        }

        if (_brkCurrent != b.ptr + rounded) return false;
        // Great, can expand the last block
        delta -= slack;

        const roundedDelta = goodAllocSize(delta);
        auto p = sbrk(roundedDelta);
        if (p == cast(void*) -1)
        {
            return false;
        }
        _brkCurrent = cast(shared) (p + roundedDelta);
        b = b.ptr[0 .. b.length + slack + delta];
        return true;
    }

    /// Ditto
    Ternary owns(const void[] b) shared pure nothrow @trusted @nogc
    {
        // No need to lock here.
        assert(!_brkCurrent || !b || &b[0] + b.length <= _brkCurrent);
        return Ternary(_brkInitial && b && (&b[0] >= _brkInitial));
    }

    /**

    The `deallocate` method only works (and returns `true`)  on systems
    that support reducing the  break address (i.e. accept calls to `sbrk`
    with negative offsets). OSX does not accept such. In addition the argument
    must be the last block allocated.

    */
    bool deallocate(void[] b) shared nothrow @nogc
    {
        // Take alignment rounding into account
        const rounded = goodAllocSize(b.length);
        pthread_mutex_lock(cast(pthread_mutex_t*) &sbrkMutex) == 0 || assert(0);
        scope(exit) pthread_mutex_unlock(cast(pthread_mutex_t*) &sbrkMutex) == 0
            || assert(0);
        if (_brkCurrent != b.ptr + rounded) return false;
        assert(b.ptr >= _brkInitial);
        if (sbrk(-rounded) == cast(void*) -1)
            return false;
        _brkCurrent = cast(shared) b.ptr;
        return true;
    }

    /**
    The `deallocateAll` method only works (and returns `true`) on systems
    that support reducing the  break address (i.e. accept calls to `sbrk`
    with negative offsets). OSX does not accept such.
    */
    nothrow @nogc
    bool deallocateAll() shared
    {
        pthread_mutex_lock(cast(pthread_mutex_t*) &sbrkMutex) == 0 || assert(0);
        scope(exit) pthread_mutex_unlock(cast(pthread_mutex_t*) &sbrkMutex) == 0
            || assert(0);
        return !_brkInitial || brk(_brkInitial) == 0;
    }

    /// Standard allocator API.
    Ternary empty() shared pure nothrow @safe @nogc
    {
        // Also works when they're both null.
        return Ternary(_brkCurrent == _brkInitial);
    }
}

version (CRuntime_Musl) {} else
version (DragonFlyBSD) {} else
version (Posix) @system nothrow @nogc unittest
{
    // Let's test the assumption that sbrk(n) returns the old address
    const p1 = sbrk(0);
    const p2 = sbrk(4096);
    assert(p1 == p2);
    const p3 = sbrk(0);
    assert(p3 == p2 + 4096);
    // Try to reset brk, but don't make a fuss if it doesn't work
    sbrk(-4096);
}

version (CRuntime_Musl) {} else
version (DragonFlyBSD) {} else
version (Posix) @system nothrow @nogc unittest
{
    import std.typecons : Ternary;
    import std.algorithm.comparison : min;
    alias alloc = SbrkRegion!(min(8, platformAlignment)).instance;
    assert((() nothrow @safe @nogc => alloc.empty)() == Ternary.yes);
    auto a = alloc.alignedAllocate(2001, 4096);
    assert(a.length == 2001);
    assert((() nothrow @safe @nogc => alloc.empty)() == Ternary.no);
    auto oldBrkCurr = alloc._brkCurrent;
    auto b = alloc.allocate(2001);
    assert(b.length == 2001);
    assert((() nothrow @safe @nogc => alloc.expand(b, 0))());
    assert(b.length == 2001);
    // Expand with a small size to fit the rounded slack due to alignment
    assert((() nothrow @safe @nogc => alloc.expand(b, 1))());
    assert(b.length == 2002);
    // Exceed the rounded slack due to alignment
    assert((() nothrow @safe @nogc => alloc.expand(b, 10))());
    assert(b.length == 2012);
    assert((() nothrow @safe @nogc => alloc.owns(a))() == Ternary.yes);
    assert((() nothrow @safe @nogc => alloc.owns(b))() == Ternary.yes);
    // reducing the brk does not work on OSX
    version (Darwin) {} else
    {
        assert((() nothrow @nogc => alloc.deallocate(b))());
        // Check that expand and deallocate work well
        assert(oldBrkCurr == alloc._brkCurrent);
        assert((() nothrow @nogc => alloc.deallocate(a))());
        assert((() nothrow @nogc => alloc.deallocateAll())());
    }
    const void[] c = alloc.allocate(2001);
    assert(c.length == 2001);
    assert((() nothrow @safe @nogc => alloc.owns(c))() == Ternary.yes);
    assert((() nothrow @safe @nogc => alloc.owns(null))() == Ternary.no);
}

/**
The threadsafe version of the `Region` allocator.
Allocations and deallocations are lock-free based using $(REF cas, core,atomic).
*/
shared struct SharedRegion(ParentAllocator,
    uint minAlign = platformAlignment,
    Flag!"growDownwards" growDownwards = No.growDownwards)
{
    static assert(minAlign.isGoodStaticAlignment);
    static assert(ParentAllocator.alignment >= minAlign);

    import std.traits : hasMember;
    import std.typecons : Ternary;

    // state
    /**
    The _parent allocator. Depending on whether `ParentAllocator` holds state
    or not, this is a member variable or an alias for
    `ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator)
    {
        ParentAllocator parent;
    }
    else
    {
        alias parent = ParentAllocator.instance;
    }
    private shared SharedBorrowedRegion!(minAlign, growDownwards) _impl;

    private void* roundedBegin() const pure nothrow @trusted @nogc
    {
        return _impl.roundedBegin;
    }

    private void* roundedEnd() const pure nothrow @trusted @nogc
    {
        return _impl.roundedEnd;
    }


    /**
    Constructs a region backed by a user-provided store.
    Assumes the memory was allocated with `ParentAllocator`.

    Params:
        store = User-provided store backing up the region. Assumed to have been
        allocated with `ParentAllocator`.
        n = Bytes to allocate using `ParentAllocator`. If `parent.allocate(n)`
        returns `null`, the region will be initialized as empty (correctly
        initialized but unable to allocate).
    */
    this(ubyte[] store) pure nothrow @nogc
    {
        _impl = store;
    }

    /// Ditto
    this(size_t n)
    {
        this(cast(ubyte[]) (parent.allocate(n.roundUpToAlignment(alignment))));
    }

    /**
    Rounds the given size to a multiple of the `alignment`
    */
    size_t goodAllocSize(size_t n) const pure nothrow @safe @nogc
    {
        return _impl.goodAllocSize(n);
    }

    /**
    Alignment offered.
    */
    alias alignment = minAlign;

    /**
    Allocates `n` bytes of memory. The allocation is served by atomically incrementing
    a pointer which keeps track of the current used space.

    Params:
        n = number of bytes to allocate

    Returns:
        A properly-aligned buffer of size `n`, or `null` if request could not
        be satisfied.
    */
    void[] allocate(size_t n) pure nothrow @trusted @nogc
    {
        return _impl.allocate(n);
    }

    /**
    Deallocates `b`. This works only if `b` was obtained as the last call
    to `allocate`; otherwise (i.e. another allocation has occurred since) it
    does nothing.

    Params:
        b = Block previously obtained by a call to `allocate` against this
        allocator (`null` is allowed).
    */
    bool deallocate(void[] b) pure nothrow @nogc
    {
        return _impl.deallocate(b);
    }

    /**
    Deallocates all memory allocated by this region, which can be subsequently
    reused for new allocations.
    */
    bool deallocateAll() pure nothrow @nogc
    {
        return _impl.deallocateAll;
    }

    /**
    Allocates `n` bytes of memory aligned at alignment `a`.
    Params:
        n = number of bytes to allocate
        a = alignment for the allocated block

    Returns:
        Either a suitable block of `n` bytes aligned at `a`, or `null`.
    */
    void[] alignedAllocate(size_t n, uint a) pure nothrow @trusted @nogc
    {
        return _impl.alignedAllocate(n, a);
    }

    /**
    Queries whether `b` has been allocated with this region.

    Params:
        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns
        `false`).

    Returns:
        `true` if `b` has been allocated with this region, `false` otherwise.
    */
    Ternary owns(const void[] b) const pure nothrow @trusted @nogc
    {
        return _impl.owns(b);
    }

    /**
    Returns `Ternary.yes` if no memory has been allocated in this region,
    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)
    */
    Ternary empty() const pure nothrow @safe @nogc
    {
        return _impl.empty;
    }

    /**
    If `ParentAllocator` defines `deallocate`, the region defines a destructor
    that uses `ParentAllocator.deallocate` to free the memory chunk.
    */
    static if (hasMember!(ParentAllocator, "deallocate"))
    ~this()
    {
        with (_impl) parent.deallocate(cast(void[]) _begin[0 .. _end - _begin]);
    }
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    static void testAlloc(Allocator)(ref Allocator a, bool growDownwards)
    {
        import core.thread : ThreadGroup;
        import std.algorithm.sorting : sort;
        import core.internal.spinlock : SpinLock;

        SpinLock lock = SpinLock(SpinLock.Contention.brief);
        enum numThreads = 100;
        void[][numThreads] buf;
        size_t count = 0;

        void fun()
        {
            void[] b = a.allocate(63);
            assert(b.length == 63);

            lock.lock();
            buf[count] = b;
            count++;
            lock.unlock();
        }

        auto tg = new ThreadGroup;
        foreach (i; 0 .. numThreads)
        {
            tg.create(&fun);
        }
        tg.joinAll();

        sort!((a, b) => a.ptr < b.ptr)(buf[0 .. numThreads]);
        foreach (i; 0 .. numThreads - 1)
        {
            assert(buf[i].ptr + a.goodAllocSize(buf[i].length) == buf[i + 1].ptr);
        }

        assert(!a.deallocate(buf[1]));

        foreach (i; 0 .. numThreads)
        {
            if (!growDownwards)
                assert(a.deallocate(buf[numThreads - 1 - i]));
            else
                assert(a.deallocate(buf[i]));
        }

        assert(a.deallocateAll());
        void[] b = a.allocate(63);
        assert(b.length == 63);
        assert(a.deallocate(b));
    }

    auto a1 = SharedRegion!(Mallocator, Mallocator.alignment,
        Yes.growDownwards)(1024 * 64);

    auto a2 = SharedRegion!(Mallocator, Mallocator.alignment,
        No.growDownwards)(1024 * 64);

    testAlloc(a1, true);
    testAlloc(a2, false);
}

@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    static void testAlloc(Allocator)(ref Allocator a, bool growDownwards)
    {
        import core.thread : ThreadGroup;
        import std.algorithm.sorting : sort;
        import core.internal.spinlock : SpinLock;

        SpinLock lock = SpinLock(SpinLock.Contention.brief);
        enum numThreads = 100;
        void[][2 * numThreads] buf;
        size_t count = 0;

        void fun()
        {
            void[] b = a.allocate(63);
            assert(b.length == 63);

            lock.lock();
            buf[count] = b;
            count++;
            lock.unlock();

            b = a.alignedAllocate(63, 32);
            assert(b.length == 63);
            assert(cast(size_t) b.ptr % 32 == 0);

            lock.lock();
            buf[count] = b;
            count++;
            lock.unlock();
        }

        auto tg = new ThreadGroup;
        foreach (i; 0 .. numThreads)
        {
            tg.create(&fun);
        }
        tg.joinAll();

        sort!((a, b) => a.ptr < b.ptr)(buf[0 .. 2 * numThreads]);
        foreach (i; 0 .. 2 * numThreads - 1)
        {
            assert(buf[i].ptr + buf[i].length <= buf[i + 1].ptr);
        }

        assert(!a.deallocate(buf[1]));
        assert(a.deallocateAll());

        void[] b = a.allocate(13);
        assert(b.length == 13);
        assert(a.deallocate(b));
    }

    auto a1 = SharedRegion!(Mallocator, Mallocator.alignment,
        Yes.growDownwards)(1024 * 64);

    auto a2 = SharedRegion!(Mallocator, Mallocator.alignment,
        No.growDownwards)(1024 * 64);

    testAlloc(a1, true);
    testAlloc(a2, false);
}

/**
A `SharedBorrowedRegion` allocates directly from a user-provided block of memory.

Unlike a `SharedRegion`, a `SharedBorrowedRegion` does not own the memory it
allocates from and will not deallocate that memory upon destruction. Instead,
it is the user's responsibility to ensure that the memory is properly disposed
of.

In all other respects, a `SharedBorrowedRegion` behaves exactly like a `SharedRegion`.
*/
shared struct SharedBorrowedRegion(uint minAlign = platformAlignment,
    Flag!"growDownwards" growDownwards = No.growDownwards)
{
    static assert(minAlign.isGoodStaticAlignment);

    import std.typecons : Ternary;

    // state
    private void* _current, _begin, _end;

    private void* roundedBegin() shared const pure nothrow @trusted @nogc
    {
        return cast(void*) roundUpToAlignment(cast(size_t) _begin, alignment);
    }

    private void* roundedEnd() shared const pure nothrow @trusted @nogc
    {
        return cast(void*) roundDownToAlignment(cast(size_t) _end, alignment);
    }

    /**
    Constructs a region backed by a user-provided store.

    Params:
        store = User-provided store backing up the region. Must not be aliased.
    */
    this(ubyte[] store) shared pure nothrow @nogc
    {
        _begin = cast(typeof(_begin)) store.ptr;
        _end = cast(typeof(_end)) (store.ptr + store.length);
        static if (growDownwards)
            _current = cast(typeof(_current)) roundedEnd();
        else
            _current = cast(typeof(_current)) roundedBegin();
    }

    /*
    TODO: The postblit of `SharedBorrowedRegion` should be disabled because
    such objects should not be copied around naively.
    */

    /**
    Rounds the given size to a multiple of the `alignment`
    */
    size_t goodAllocSize(size_t n) shared const pure nothrow @safe @nogc
    {
        return n.roundUpToAlignment(alignment);
    }

    /**
    Alignment offered.
    */
    alias alignment = minAlign;

    /**
    Allocates `n` bytes of memory. The allocation is served by atomically incrementing
    a pointer which keeps track of the current used space.

    Params:
        n = number of bytes to allocate

    Returns:
        A properly-aligned buffer of size `n`, or `null` if request could not
        be satisfied.
    */
    void[] allocate(size_t n) shared pure nothrow @trusted @nogc
    {
        import core.atomic : cas, atomicLoad;

        if (n == 0) return null;
        const rounded = goodAllocSize(n);

        shared void* localCurrent, localNewCurrent;
        static if (growDownwards)
        {
            do
            {
                localCurrent = atomicLoad(_current);
                localNewCurrent = localCurrent - rounded;
                if (localNewCurrent > localCurrent || localNewCurrent < _begin)
                    return null;
            } while (!cas(&_current, localCurrent, localNewCurrent));

            return cast(void[]) localNewCurrent[0 .. n];
        }
        else
        {
            do
            {
                localCurrent = atomicLoad(_current);
                localNewCurrent = localCurrent + rounded;
                if (localNewCurrent < localCurrent || localNewCurrent > _end)
                    return null;
            } while (!cas(&_current, localCurrent, localNewCurrent));

            return cast(void[]) localCurrent[0 .. n];
        }

        assert(0, "Unexpected error in SharedBorrowedRegion.allocate");
    }

    /**
    Allocates `n` bytes of memory aligned at alignment `a`.

    Params:
        n = number of bytes to allocate
        a = alignment for the allocated block

    Returns:
        Either a suitable block of `n` bytes aligned at `a`, or `null`.
    */
    void[] alignedAllocate(size_t n, uint a) shared pure nothrow @trusted @nogc
    {
        import core.atomic : cas, atomicLoad;
        import std.math.traits : isPowerOf2;

        assert(a.isPowerOf2);
        if (n == 0) return null;

        const rounded = goodAllocSize(n);
        shared void* localCurrent, localNewCurrent;

        static if (growDownwards)
        {
            do
            {
                localCurrent = atomicLoad(_current);
                auto alignedCurrent = cast(void*)(localCurrent - rounded);
                localNewCurrent = cast(shared(void*)) alignedCurrent.alignDownTo(a);
                if (alignedCurrent > localCurrent || localNewCurrent > alignedCurrent ||
                    localNewCurrent < _begin)
                    return null;
            } while (!cas(&_current, localCurrent, localNewCurrent));

            return cast(void[]) localNewCurrent[0 .. n];
        }
        else
        {
            do
            {
                localCurrent = atomicLoad(_current);
                auto alignedCurrent = alignUpTo(cast(void*) localCurrent, a);
                localNewCurrent = cast(shared(void*)) (alignedCurrent + rounded);
                if (alignedCurrent < localCurrent || localNewCurrent < alignedCurrent ||
                    localNewCurrent > _end)
                    return null;
            } while (!cas(&_current, localCurrent, localNewCurrent));

            return cast(void[]) (localNewCurrent - rounded)[0 .. n];
        }

        assert(0, "Unexpected error in SharedBorrowedRegion.alignedAllocate");
    }

    /**
    Deallocates `b`. This works only if `b` was obtained as the last call
    to `allocate`; otherwise (i.e. another allocation has occurred since) it
    does nothing.

    Params:
        b = Block previously obtained by a call to `allocate` against this
        allocator (`null` is allowed).
    */
    bool deallocate(void[] b) shared pure nothrow @nogc
    {
        import core.atomic : cas, atomicLoad;

        const rounded = goodAllocSize(b.length);
        shared void* localCurrent, localNewCurrent;

        // The cas is done only once, because only the last allocation can be reverted
        localCurrent = atomicLoad(_current);
        static if (growDownwards)
        {
            localNewCurrent = localCurrent + rounded;
            if (b.ptr == localCurrent)
                return cas(&_current, localCurrent, localNewCurrent);
        }
        else
        {
            localNewCurrent = localCurrent - rounded;
            if (b.ptr == localNewCurrent)
                return cas(&_current, localCurrent, localNewCurrent);
        }

        return false;
    }

    /**
    Deallocates all memory allocated by this region, which can be subsequently
    reused for new allocations.
    */
    bool deallocateAll() shared pure nothrow @nogc
    {
        import core.atomic : atomicStore;
        static if (growDownwards)
        {
            atomicStore(_current, cast(shared(void*)) roundedEnd());
        }
        else
        {
            atomicStore(_current, cast(shared(void*)) roundedBegin());
        }
        return true;
    }

    /**
    Queries whether `b` has been allocated with this region.

    Params:
        b = Arbitrary block of memory (`null` is allowed; `owns(null)` returns
        `false`).

    Returns:
        `true` if `b` has been allocated with this region, `false` otherwise.
    */
    Ternary owns(const void[] b) shared const pure nothrow @trusted @nogc
    {
        return Ternary(b && (&b[0] >= _begin) && (&b[0] + b.length <= _end));
    }

    /**
    Returns `Ternary.yes` if no memory has been allocated in this region,
    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)
    */
    Ternary empty() shared const pure nothrow @safe @nogc
    {
        import core.atomic : atomicLoad;

        auto localCurrent = atomicLoad(_current);
        static if (growDownwards)
            return Ternary(localCurrent == roundedEnd());
        else
            return Ternary(localCurrent == roundedBegin());
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/scoped_allocator.d)
*/
module std.experimental.allocator.building_blocks.scoped_allocator;

import std.experimental.allocator.common;

/**

`ScopedAllocator` delegates all allocation requests to `ParentAllocator`.
When destroyed, the `ScopedAllocator` object automatically calls $(D
deallocate) for all memory allocated through its lifetime. (The $(D
deallocateAll) function is also implemented with the same semantics.)

`deallocate` is also supported, which is where most implementation effort
and overhead of `ScopedAllocator` go. If `deallocate` is not needed, a
simpler design combining `AllocatorList` with `Region` is recommended.

*/
struct ScopedAllocator(ParentAllocator)
{
    static if (!stateSize!ParentAllocator)
    {
        // This test is available only for stateless allocators
        version (StdUnittest)
        @system unittest
        {
            testAllocator!(() => ScopedAllocator());
        }
    }

    import std.experimental.allocator.building_blocks.affix_allocator
        : AffixAllocator;
    import std.traits : hasMember;
    import std.typecons : Ternary;

    private struct Node
    {
        Node* prev;
        Node* next;
        size_t length;
    }

    alias Allocator = AffixAllocator!(ParentAllocator, Node);

    // state
    /**
    If `ParentAllocator` is stateful, `parent` is a property giving access
    to an `AffixAllocator!ParentAllocator`. Otherwise, `parent` is an alias for `AffixAllocator!ParentAllocator.instance`.
    */
    static if (stateSize!ParentAllocator)
    {
        Allocator parent;
    }
    else
    {
        alias parent = Allocator.instance;
    }
    private Node* root;

    /**
    `ScopedAllocator` is not copyable.
    */
    @disable this(this);

    /**
    `ScopedAllocator`'s destructor releases all memory allocated during its
    lifetime.
    */
    ~this()
    {
        deallocateAll;
    }

    /// Alignment offered
    enum alignment = Allocator.alignment;

    /**
    Forwards to `parent.goodAllocSize` (which accounts for the management
    overhead).
    */
    size_t goodAllocSize(size_t n)
    {
        return parent.goodAllocSize(n);
    }

    // Common code shared between allocate and allocateZeroed.
    private enum _processAndReturnAllocateResult =
    q{
       if (!b.ptr) return b;
        Node* toInsert = & parent.prefix(b);
        toInsert.prev = null;
        toInsert.next = root;
        toInsert.length = n;
        assert(!root || !root.prev);
        if (root) root.prev = toInsert;
        root = toInsert;
        return b;
    };

    /**
    Allocates memory. For management it actually allocates extra memory from
    the parent.
    */
    void[] allocate(size_t n)
    {
        auto b = parent.allocate(n);
        mixin(_processAndReturnAllocateResult);
    }

    static if (hasMember!(Allocator, "allocateZeroed"))
    package(std) void[] allocateZeroed()(size_t n)
    {
        auto b = parent.allocateZeroed(n);
        mixin(_processAndReturnAllocateResult);
    }

    /**
    Forwards to $(D parent.expand(b, delta)).
    */
    static if (hasMember!(Allocator, "expand"))
    bool expand(ref void[] b, size_t delta)
    {
        auto result = parent.expand(b, delta);
        if (result && b)
        {
            () @trusted { parent.prefix(b).length = b.length; }();
        }
        return result;
    }

    /**
    Reallocates `b` to new size `s`.
    */
    bool reallocate(ref void[] b, size_t s)
    {
        // Remove from list
        if (b.ptr)
        {
            Node* n = & parent.prefix(b);
            if (n.prev) n.prev.next = n.next;
            else root = n.next;
            if (n.next) n.next.prev = n.prev;
        }
        auto result = parent.reallocate(b, s);
        // Add back to list
        if (b.ptr)
        {
            Node* n = & parent.prefix(b);
            n.prev = null;
            n.next = root;
            n.length = s;
            if (root) root.prev = n;
            root = n;
        }
        return result;
    }

    /**
    Forwards to `parent.owns(b)`.
    */
    static if (hasMember!(Allocator, "owns"))
    Ternary owns(void[] b)
    {
        return parent.owns(b);
    }

    /**
    Deallocates `b`.
    */
    static if (hasMember!(Allocator, "deallocate"))
    bool deallocate(void[] b)
    {
        // Remove from list
        if (b.ptr)
        {
            Node* n = & parent.prefix(b);
            if (n.prev) n.prev.next = n.next;
            else root = n.next;
            if (n.next) n.next.prev = n.prev;
        }
        return parent.deallocate(b);
    }

    /**
    Deallocates all memory allocated.
    */
    bool deallocateAll()
    {
        bool result = true;
        for (auto n = root; n; )
        {
            void* p = n + 1;
            auto length = n.length;
            n = n.next;
            if (!parent.deallocate(p[0 .. length]))
                result = false;
        }
        root = null;
        return result;
    }

    /**
    Returns `Ternary.yes` if this allocator is not responsible for any memory,
    `Ternary.no` otherwise. (Never returns `Ternary.unknown`.)
    */
    pure nothrow @safe @nogc
    Ternary empty() const
    {
        return Ternary(root is null);
    }
}

///
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    ScopedAllocator!Mallocator alloc;
    assert(alloc.empty == Ternary.yes);
    const b = alloc.allocate(10);
    assert(b.length == 10);
    assert(alloc.empty == Ternary.no);
}

version (StdUnittest)
@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    testAllocator!(() => ScopedAllocator!GCAllocator());
}

@system unittest // https://issues.dlang.org/show_bug.cgi?id=16046
{
    import std.exception;
    import std.experimental.allocator;
    import std.experimental.allocator.mallocator;
    ScopedAllocator!Mallocator alloc;
    auto foo = alloc.make!int(1).enforce;
    auto bar = alloc.make!int(2).enforce;
    alloc.dispose(foo);
    alloc.dispose(bar); // segfault here
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    ScopedAllocator!GCAllocator a;

    assert(__traits(compiles, (() nothrow @safe @nogc => a.goodAllocSize(0))()));

    // Ensure deallocate inherits from parent allocators
    auto b = a.allocate(42);
    assert(b.length == 42);
    () nothrow @nogc { a.deallocate(b); }();
}

// Test that deallocateAll infers from parent
@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    ScopedAllocator!(BorrowedRegion!()) a;
    a.parent.parent = BorrowedRegion!()(new ubyte[1024 * 64]);
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.expand(b, 22))());
    assert(b.length == 64);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() nothrow @nogc => a.deallocateAll())());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : Region;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;

    auto a = Region!(Mallocator)(1024 * 64);
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.expand(b, 22))());
    assert(b.length == 64);
    assert((() pure nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() pure nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() pure nothrow @safe @nogc => a.owns(null))() == Ternary.no);
}

// Test empty
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.typecons : Ternary;
    ScopedAllocator!Mallocator alloc;

    assert((() pure nothrow @safe @nogc => alloc.empty)() == Ternary.yes);
    const b = alloc.allocate(10);
    assert((() pure nothrow @safe @nogc => alloc.empty)() == Ternary.no);
}
                                        // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/segregator.d)
*/
module std.experimental.allocator.building_blocks.segregator;

import std.experimental.allocator.common;

/**
Dispatches allocations (and deallocations) between two allocators ($(D
SmallAllocator) and `LargeAllocator`) depending on the size allocated, as
follows. All allocations smaller than or equal to `threshold` will be
dispatched to `SmallAllocator`. The others will go to `LargeAllocator`.

If both allocators are `shared`, the `Segregator` will also offer $(D
shared) methods.
*/
struct Segregator(size_t threshold, SmallAllocator, LargeAllocator)
{
    import std.algorithm.comparison : min;
    import std.traits : hasMember, ReturnType;
    import std.typecons : Ternary;

    static if (stateSize!SmallAllocator) private SmallAllocator _small;
    else private alias _small = SmallAllocator.instance;
    static if (stateSize!LargeAllocator) private LargeAllocator _large;
    else private alias _large = LargeAllocator.instance;

    version (StdDdoc)
    {
        /**
        The alignment offered is the minimum of the two allocators' alignment.
        */
        enum uint alignment;
        /**
        This method is defined only if at least one of the allocators defines
        it. The good allocation size is obtained from `SmallAllocator` if $(D
        s <= threshold), or `LargeAllocator` otherwise. (If one of the
        allocators does not define `goodAllocSize`, the default
        implementation in this module applies.)
        */
        static size_t goodAllocSize(size_t s);
        /**
        The memory is obtained from `SmallAllocator` if $(D s <= threshold),
        or `LargeAllocator` otherwise.
        */
        void[] allocate(size_t);
        /**
        This method is defined if both allocators define it, and forwards to
        `SmallAllocator` or `LargeAllocator` appropriately.
        */
        void[] alignedAllocate(size_t, uint);
        /**
        This method is defined only if at least one of the allocators defines
        it. If `SmallAllocator` defines `expand` and $(D b.length +
        delta <= threshold), the call is forwarded to `SmallAllocator`. If $(D
        LargeAllocator) defines `expand` and $(D b.length > threshold), the
        call is forwarded to `LargeAllocator`. Otherwise, the call returns
        `false`.
        */
        bool expand(ref void[] b, size_t delta);
        /**
        This method is defined only if at least one of the allocators defines
        it. If `SmallAllocator` defines `reallocate` and $(D b.length <=
        threshold && s <= threshold), the call is forwarded to $(D
        SmallAllocator). If `LargeAllocator` defines `expand` and $(D
        b.length > threshold && s > threshold), the call is forwarded to $(D
        LargeAllocator). Otherwise, the call returns `false`.
        */
        bool reallocate(ref void[] b, size_t s);
        /**
        This method is defined only if at least one of the allocators defines
        it, and work similarly to `reallocate`.
        */
        bool alignedReallocate(ref void[] b, size_t s, uint a);
        /**
        This method is defined only if both allocators define it. The call is
        forwarded to `SmallAllocator` if $(D b.length <= threshold), or $(D
        LargeAllocator) otherwise.
        */
        Ternary owns(void[] b);
        /**
        This function is defined only if both allocators define it, and forwards
        appropriately depending on `b.length`.
        */
        bool deallocate(void[] b);
        /**
        This function is defined only if both allocators define it, and calls
        `deallocateAll` for them in turn.
        */
        bool deallocateAll();
        /**
        This function is defined only if both allocators define it, and returns
        the conjunction of `empty` calls for the two.
        */
        Ternary empty();
    }

    /**
    Composite allocators involving nested instantiations of `Segregator` make
    it difficult to access individual sub-allocators stored within. $(D
    allocatorForSize) simplifies the task by supplying the allocator nested
    inside a `Segregator` that is responsible for a specific size `s`.

    Example:
    ----
    alias A = Segregator!(300,
        Segregator!(200, A1, A2),
        A3);
    A a;
    static assert(typeof(a.allocatorForSize!10) == A1);
    static assert(typeof(a.allocatorForSize!250) == A2);
    static assert(typeof(a.allocatorForSize!301) == A3);
    ----
    */
    ref auto allocatorForSize(size_t s)()
    {
        static if (s <= threshold)
            static if (is(SmallAllocator == Segregator!(Args), Args...))
                return _small.allocatorForSize!s;
            else return _small;
        else
            static if (is(LargeAllocator == Segregator!(Args), Args...))
                return _large.allocatorForSize!s;
            else return _large;
    }

    enum uint alignment = min(SmallAllocator.alignment,
        LargeAllocator.alignment);

    private template Impl()
    {
        size_t goodAllocSize(size_t s)
        {
            return s <= threshold
                ? _small.goodAllocSize(s)
                : _large.goodAllocSize(s);
        }

        void[] allocate(size_t s)
        {
            return s <= threshold ? _small.allocate(s) : _large.allocate(s);
        }

        static if (hasMember!(SmallAllocator, "alignedAllocate")
                && hasMember!(LargeAllocator, "alignedAllocate"))
        void[] alignedAllocate(size_t s, uint a)
        {
            return s <= threshold
                ? _small.alignedAllocate(s, a)
                : _large.alignedAllocate(s, a);
        }

        static if (hasMember!(SmallAllocator, "expand")
                || hasMember!(LargeAllocator, "expand"))
        bool expand(ref void[] b, size_t delta)
        {
            if (!delta) return true;
            if (b.length + delta <= threshold)
            {
                // Old and new allocations handled by _small
                static if (hasMember!(SmallAllocator, "expand"))
                    return _small.expand(b, delta);
                else
                    return false;
            }
            if (b.length > threshold)
            {
                // Old and new allocations handled by _large
                static if (hasMember!(LargeAllocator, "expand"))
                    return _large.expand(b, delta);
                else
                    return false;
            }
            // Oops, cross-allocator transgression
            return false;
        }

        static if (hasMember!(SmallAllocator, "reallocate")
                || hasMember!(LargeAllocator, "reallocate"))
        bool reallocate(ref void[] b, size_t s)
        {
            static if (hasMember!(SmallAllocator, "reallocate"))
                if (b.length <= threshold && s <= threshold)
                {
                    // Old and new allocations handled by _small
                    return _small.reallocate(b, s);
                }
            static if (hasMember!(LargeAllocator, "reallocate"))
                if (b.length > threshold && s > threshold)
                {
                    // Old and new allocations handled by _large
                    return _large.reallocate(b, s);
                }
            // Cross-allocator transgression
            return .reallocate(this, b, s);
        }

        static if (hasMember!(SmallAllocator, "alignedReallocate")
                || hasMember!(LargeAllocator, "alignedReallocate"))
        bool alignedReallocate(ref void[] b, size_t s, uint a)
        {
            static if (hasMember!(SmallAllocator, "alignedReallocate"))
                if (b.length <= threshold && s <= threshold)
                {
                    // Old and new allocations handled by _small
                    return _small.alignedReallocate(b, s, a);
                }
            static if (hasMember!(LargeAllocator, "alignedReallocate"))
                if (b.length > threshold && s > threshold)
                {
                    // Old and new allocations handled by _large
                    return _large.alignedReallocate(b, s, a);
                }
            // Cross-allocator transgression
            return .alignedReallocate(this, b, s, a);
        }

        static if (hasMember!(SmallAllocator, "allocateZeroed")
                || hasMember!(LargeAllocator, "allocateZeroed"))
        package(std) void[] allocateZeroed()(size_t s)
        {
            if (s <= threshold)
            {
                static if (hasMember!(SmallAllocator, "allocateZeroed"))
                    return _small.allocateZeroed(s);
                else
                {
                    auto b = _small.allocate(s);
                    (() @trusted => (cast(ubyte[]) b)[] = 0)(); // OK even if b is null.
                    return b;
                }
            }
            else
            {
                static if (hasMember!(LargeAllocator, "allocateZeroed"))
                    return _large.allocateZeroed(s);
                else
                {
                    auto b = _large.allocate(s);
                    (() @trusted => (cast(ubyte[]) b)[] = 0)(); // OK even if b is null.
                    return b;
                }
            }
        }

        static if (hasMember!(SmallAllocator, "owns")
                && hasMember!(LargeAllocator, "owns"))
        Ternary owns(void[] b)
        {
            return Ternary(b.length <= threshold
                ? _small.owns(b) : _large.owns(b));
        }

        static if (hasMember!(SmallAllocator, "deallocate")
                && hasMember!(LargeAllocator, "deallocate"))
        bool deallocate(void[] data)
        {
            return data.length <= threshold
                ? _small.deallocate(data)
                : _large.deallocate(data);
        }

        static if (hasMember!(SmallAllocator, "deallocateAll")
                && hasMember!(LargeAllocator, "deallocateAll"))
        bool deallocateAll()
        {
            // Use & insted of && to evaluate both
            return _small.deallocateAll() & _large.deallocateAll();
        }

        static if (hasMember!(SmallAllocator, "empty")
                && hasMember!(LargeAllocator, "empty"))
        Ternary empty()
        {
            return _small.empty & _large.empty;
        }

        static if (hasMember!(SmallAllocator, "resolveInternalPointer")
                && hasMember!(LargeAllocator, "resolveInternalPointer"))
        Ternary resolveInternalPointer(const void* p, ref void[] result)
        {
            Ternary r = _small.resolveInternalPointer(p, result);
            return r == Ternary.no ? _large.resolveInternalPointer(p, result) : r;
        }
    }

    private enum sharedMethods =
        !stateSize!SmallAllocator
        && !stateSize!LargeAllocator
        && is(typeof(SmallAllocator.instance) == shared)
        && is(typeof(LargeAllocator.instance) == shared);

    static if (sharedMethods)
    {
        static shared Segregator instance;
        shared { mixin Impl!(); }
    }
    else
    {
        static if (!stateSize!SmallAllocator && !stateSize!LargeAllocator)
            __gshared Segregator instance;
        mixin Impl!();
    }
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    alias A =
        Segregator!(
            1024 * 4,
            Segregator!(
                128, FreeList!(Mallocator, 0, 128),
                GCAllocator),
            Segregator!(
                1024 * 1024, Mallocator,
                GCAllocator)
            );
    A a;
    auto b = a.allocate(200);
    assert(b.length == 200);
    a.deallocate(b);
}

/**
A `Segregator` with more than three arguments expands to a composition of
elemental `Segregator`s, as illustrated by the following example:

----
alias A =
    Segregator!(
        n1, A1,
        n2, A2,
        n3, A3,
        A4
    );
----

With this definition, allocation requests for `n1` bytes or less are directed
to `A1`; requests between $(D n1 + 1) and `n2` bytes (inclusive) are
directed to `A2`; requests between $(D n2 + 1) and `n3` bytes (inclusive)
are directed to `A3`; and requests for more than `n3` bytes are directed
to `A4`. If some particular range should not be handled, `NullAllocator`
may be used appropriately.

*/
template Segregator(Args...)
if (Args.length > 3)
{
    // Binary search
    private enum cutPoint = ((Args.length - 2) / 4) * 2;
    static if (cutPoint >= 2)
    {
        alias Segregator = .Segregator!(
            Args[cutPoint],
            .Segregator!(Args[0 .. cutPoint], Args[cutPoint + 1]),
            .Segregator!(Args[cutPoint + 2 .. $])
        );
    }
    else
    {
        // Favor small sizes
        alias Segregator = .Segregator!(
            Args[0],
            Args[1],
            .Segregator!(Args[2 .. $])
        );
    }
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    alias A =
        Segregator!(
            128, FreeList!(Mallocator, 0, 128),
            1024 * 4, GCAllocator,
            1024 * 1024, Mallocator,
            GCAllocator
        );
    A a;
    auto b = a.allocate(201);
    assert(b.length == 201);
    a.deallocate(b);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.building_blocks.kernighan_ritchie : KRRegion;
    Segregator!(128, GCAllocator, KRRegion!GCAllocator) alloc;
    assert((() nothrow @safe @nogc => alloc.goodAllocSize(1))()
            == GCAllocator.instance.goodAllocSize(1));

    // Note: we infer `shared` from GCAllocator.goodAllocSize so we need a
    // shared object in order to be able to use the function
    shared Segregator!(128, GCAllocator, GCAllocator) sharedAlloc;
    assert((() nothrow @safe @nogc => sharedAlloc.goodAllocSize(1))()
            == GCAllocator.instance.goodAllocSize(1));
}

@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlock;
    import std.typecons : Ternary;

    alias A =
        Segregator!(
            128, BitmappedBlock!(4096),
            BitmappedBlock!(4096)
        );

    A a = A(
            BitmappedBlock!(4096)(new ubyte[4096 * 1024]),
            BitmappedBlock!(4096)(new ubyte[4096 * 1024])
    );

    assert(a.empty == Ternary.yes);
    auto b = a.allocate(42);
    assert(b.length == 42);
    assert(a.empty == Ternary.no);
    assert(a.alignedReallocate(b, 256, 512));
    assert(b.length == 256);
    assert(a.alignedReallocate(b, 42, 512));
    assert(b.length == 42);
    assert((() pure nothrow @safe @nogc => a.owns(b))() == Ternary.yes);
    assert((() pure nothrow @safe @nogc => a.owns(null))() == Ternary.no);
    // Ensure deallocate inherits from parent allocators
    assert((() nothrow @nogc => a.deallocate(b))());
    assert(a.empty == Ternary.yes);

    // Test that deallocateAll inherits from parents
    auto c = a.allocate(42);
    assert(c.length == 42);
    assert((() pure nothrow @safe @nogc => a.expand(c, 58))());
    assert(c.length == 100);
    assert(a.empty == Ternary.no);
    assert((() nothrow @nogc => a.deallocateAll())());
    assert(a.empty == Ternary.yes);
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.typecons : Ternary;

    shared Segregator!(1024 * 4, GCAllocator, GCAllocator) a;

    auto b = a.allocate(201);
    assert(b.length == 201);

    void[] p;
    assert((() nothrow @safe @nogc => a.resolveInternalPointer(&b[0], p))() == Ternary.yes);
    assert((() nothrow @safe @nogc => a.resolveInternalPointer(null, p))() == Ternary.no);

    // Ensure deallocate inherits from parent allocators
    assert((() nothrow @nogc => a.deallocate(b))());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.bitmapped_block : BitmappedBlockWithInternalPointers;
    import std.typecons : Ternary;

    alias A =
        Segregator!(
            10_240, BitmappedBlockWithInternalPointers!(4096),
            BitmappedBlockWithInternalPointers!(4096)
        );

    A a = A(
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024]),
            BitmappedBlockWithInternalPointers!(4096)(new ubyte[4096 * 1024])
    );

    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    auto b = a.allocate(201);
    assert(b.length == 201);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
    assert((() nothrow @nogc => a.deallocate(b))());
}

// Test that reallocate infers from parent
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    alias a = Segregator!(10_240, Mallocator, Mallocator).instance;

    auto b = a.allocate(42);
    assert(b.length == 42);
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    assert((() nothrow @nogc => a.deallocate(b))());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.typecons : Ternary;

    auto a = Segregator!(10_240, BorrowedRegion!(), BorrowedRegion!())(
                BorrowedRegion!()(new ubyte[4096 * 1024]),
                BorrowedRegion!()(new ubyte[4096 * 1024]));

    assert((() nothrow @safe @nogc => a.empty)() == Ternary.yes);
    auto b = a.alignedAllocate(42, 8);
    assert(b.length == 42);
    assert((() nothrow @nogc => a.alignedReallocate(b, 100, 8))());
    assert(b.length == 100);
    assert((() nothrow @safe @nogc => a.empty)() == Ternary.no);
    assert((() nothrow @nogc => a.deallocate(b))());
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // Written in the D programming language.
/**
Allocator that collects useful statistics about allocations, both global and per
calling point. The statistics collected can be configured statically by choosing
combinations of `Options` appropriately.

Source: $(PHOBOSSRC std/experimental/allocator/building_blocks/stats_collector.d)
*/
module std.experimental.allocator.building_blocks.stats_collector;

///
@safe unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    alias Allocator = StatsCollector!(GCAllocator, Options.bytesUsed);
}

import std.experimental.allocator.common;

/**
_Options for `StatsCollector` defined below. Each enables during
compilation one specific counter, statistic, or other piece of information.
*/
enum Options : ulong
{
    /**
    Counts the number of calls to `owns`.
    */
    numOwns = 1u << 0,
    /**
    Counts the number of calls to `allocate`. All calls are counted,
    including requests for zero bytes or failed requests.
    */
    numAllocate = 1u << 1,
    /**
    Counts the number of calls to `allocate` that succeeded, i.e. they
    returned a block as large as requested. (N.B. requests for zero bytes count
    as successful.)
    */
    numAllocateOK = 1u << 2,
    /**
    Counts the number of calls to `expand`, regardless of arguments or
    result.
    */
    numExpand = 1u << 3,
    /**
    Counts the number of calls to `expand` that resulted in a successful
    expansion.
    */
    numExpandOK = 1u << 4,
    /**
    Counts the number of calls to `reallocate`, regardless of arguments or
    result.
    */
    numReallocate = 1u << 5,
    /**
    Counts the number of calls to `reallocate` that succeeded.
    (Reallocations to zero bytes count as successful.)
    */
    numReallocateOK = 1u << 6,
    /**
    Counts the number of calls to `reallocate` that resulted in an in-place
    reallocation (no memory moved). If this number is close to the total number
    of reallocations, that indicates the allocator finds room at the current
    block's end in a large fraction of the cases, but also that internal
    fragmentation may be high (the size of the unit of allocation is large
    compared to the typical allocation size of the application).
    */
    numReallocateInPlace = 1u << 7,
    /**
    Counts the number of calls to `deallocate`.
    */
    numDeallocate = 1u << 8,
    /**
    Counts the number of calls to `deallocateAll`.
    */
    numDeallocateAll = 1u << 9,
    /**
    Counts the number of calls to `alignedAllocate`. All calls are counted,
    including requests for zero bytes or failed requests.
    */
    numAlignedAllocate = 1u << 10,
    /**
    Counts the number of calls to `alignedAllocate` that succeeded, i.e. they
    returned a block as large as requested. (N.B. requests for zero bytes count
    as successful.)
    */
    numAlignedAllocateOk = 1u << 11,
    /**
    Chooses all `numXxx` flags.
    */
    numAll = (1u << 12) - 1,
    /**
    Tracks bytes currently allocated by this allocator. This number goes up
    and down as memory is allocated and deallocated, and is zero if the
    allocator currently has no active allocation.
    */
    bytesUsed = 1u << 12,
    /**
    Tracks total cumulative bytes allocated by means of `allocate`,
    `expand`, and `reallocate` (when resulting in an expansion). This
    number always grows and indicates allocation traffic. To compute bytes
    deallocated cumulatively, subtract `bytesUsed` from `bytesAllocated`.
    */
    bytesAllocated = 1u << 13,
    /**
    Tracks the sum of all `delta` values in calls of the form
    $(D expand(b, delta)) that succeed (return `true`).
    */
    bytesExpanded = 1u << 14,
    /**
    Tracks the sum of all $(D b.length - s) with $(D b.length > s) in calls of
    the form $(D realloc(b, s)) that succeed (return `true`). In per-call
    statistics, also unambiguously counts the bytes deallocated with
    `deallocate`.
    */
    bytesContracted = 1u << 15,
    /**
    Tracks the sum of all bytes moved as a result of calls to `realloc` that
    were unable to reallocate in place. A large number (relative to $(D
    bytesAllocated)) indicates that the application should use larger
    preallocations.
    */
    bytesMoved = 1u << 16,
    /**
    Tracks the sum of all bytes NOT moved as result of calls to `realloc`
    that managed to reallocate in place. A large number (relative to $(D
    bytesAllocated)) indicates that the application is expansion-intensive and
    is saving a good amount of moves. However, if this number is relatively
    small and `bytesSlack` is high, it means the application is
    overallocating for little benefit.
    */
    bytesNotMoved = 1u << 17,
    /**
    Measures the sum of extra bytes allocated beyond the bytes requested, i.e.
    the $(HTTP goo.gl/YoKffF, internal fragmentation). This is the current
    effective number of slack bytes, and it goes up and down with time.
    */
    bytesSlack = 1u << 18,
    /**
    Measures the maximum bytes allocated over the time. This is useful for
    dimensioning allocators.
    */
    bytesHighTide = 1u << 19,
    /**
    Chooses all `byteXxx` flags.
    */
    bytesAll = ((1u << 20) - 1) & ~numAll,
    /**
    Combines all flags above.
    */
    all = (1u << 20) - 1
}

/**

Allocator that collects extra data about allocations. Since each piece of
information adds size and time overhead, statistics can be individually enabled
or disabled through compile-time `flags`.

All stats of the form `numXxx` record counts of events occurring, such as
calls to functions and specific results. The stats of the form `bytesXxx`
collect cumulative sizes.

In addition, the data `callerSize`, `callerModule`, `callerFile`, $(D
callerLine), and `callerTime` is associated with each specific allocation.
This data prefixes each allocation.

*/
struct StatsCollector(Allocator, ulong flags = Options.all,
    ulong perCallFlags = 0)
{
private:
    import std.traits : hasMember, Signed;
    import std.typecons : Ternary;

    static string define(string type, string[] names...)
    {
        string result;
        foreach (v; names)
            result ~= "static if (flags & Options."~v~") {"
                ~ "private "~type~" _"~v~";"
                ~ "public const("~type~") "~v~"() const { return _"~v~"; }"
                ~ "}";
        return result;
    }

    void add(string counter)(Signed!size_t n)
    {
        mixin("static if (flags & Options." ~ counter
            ~ ") _" ~ counter ~ " += n;");
        static if (counter == "bytesUsed" && (flags & Options.bytesHighTide))
        {
            if (bytesHighTide < bytesUsed ) _bytesHighTide = bytesUsed;
        }
    }

    void up(string counter)() { add!counter(1); }
    void down(string counter)() { add!counter(-1); }

    version (StdDdoc)
    {
        /**
        Read-only properties enabled by the homonym `flags` chosen by the
        user.

        Example:
        ----
        StatsCollector!(Mallocator,
            Options.bytesUsed | Options.bytesAllocated) a;
        auto d1 = a.allocate(10);
        auto d2 = a.allocate(11);
        a.deallocate(d1);
        assert(a.bytesAllocated == 21);
        assert(a.bytesUsed == 11);
        a.deallocate(d2);
        assert(a.bytesAllocated == 21);
        assert(a.bytesUsed == 0);
        ----
        */
        @property ulong numOwns() const;
        /// Ditto
        @property ulong numAllocate() const;
        /// Ditto
        @property ulong numAllocateOK() const;
        /// Ditto
        @property ulong numExpand() const;
        /// Ditto
        @property ulong numExpandOK() const;
        /// Ditto
        @property ulong numReallocate() const;
        /// Ditto
        @property ulong numReallocateOK() const;
        /// Ditto
        @property ulong numReallocateInPlace() const;
        /// Ditto
        @property ulong numDeallocate() const;
        /// Ditto
        @property ulong numDeallocateAll() const;
        /// Ditto
        @property ulong numAlignedAllocate() const;
        /// Ditto
        @property ulong numAlignedAllocateOk() const;
        /// Ditto
        @property ulong bytesUsed() const;
        /// Ditto
        @property ulong bytesAllocated() const;
        /// Ditto
        @property ulong bytesExpanded() const;
        /// Ditto
        @property ulong bytesContracted() const;
        /// Ditto
        @property ulong bytesMoved() const;
        /// Ditto
        @property ulong bytesNotMoved() const;
        /// Ditto
        @property ulong bytesSlack() const;
        /// Ditto
        @property ulong bytesHighTide() const;
    }

public:
    /**
    The parent allocator is publicly accessible either as a direct member if it
    holds state, or as an alias to `Allocator.instance` otherwise. One may use
    it for making calls that won't count toward statistics collection.
    */
    static if (stateSize!Allocator) Allocator parent;
    else alias parent = Allocator.instance;

private:
    // Per-allocator state
    mixin(define("ulong",
        "numOwns",
        "numAllocate",
        "numAllocateOK",
        "numExpand",
        "numExpandOK",
        "numReallocate",
        "numReallocateOK",
        "numReallocateInPlace",
        "numDeallocate",
        "numDeallocateAll",
        "numAlignedAllocate",
        "numAlignedAllocateOk",
        "bytesUsed",
        "bytesAllocated",
        "bytesExpanded",
        "bytesContracted",
        "bytesMoved",
        "bytesNotMoved",
        "bytesSlack",
        "bytesHighTide",
    ));

public:

    /// Alignment offered is equal to `Allocator.alignment`.
    alias alignment = Allocator.alignment;

    /**
    Increments `numOwns` (per instance and and per call) and forwards to $(D
    parent.owns(b)).
    */
    static if (hasMember!(Allocator, "owns"))
    {
        static if ((perCallFlags & Options.numOwns) == 0)
        Ternary owns(void[] b)
        { return ownsImpl(b); }
        else
        Ternary owns(string f = __FILE__, uint n = __LINE__)(void[] b)
        { return ownsImpl!(f, n)(b); }
    }

    private Ternary ownsImpl(string f = null, uint n = 0)(void[] b)
    {
        up!"numOwns";
        addPerCall!(f, n, "numOwns")(1);
        return parent.owns(b);
    }

    /**
    Forwards to `parent.allocate`. Affects per instance: `numAllocate`,
    `bytesUsed`, `bytesAllocated`, `bytesSlack`, `numAllocateOK`,
    and `bytesHighTide`. Affects per call: `numAllocate`, $(D
    numAllocateOK), and `bytesAllocated`.
    */
    static if (!(perCallFlags
        & (Options.numAllocate | Options.numAllocateOK
            | Options.bytesAllocated)))
    {
        void[] allocate(size_t n)
        { return allocateImpl(n); }
    }
    else
    {
        void[] allocate(string f = __FILE__, ulong n = __LINE__)
            (size_t bytes)
        { return allocateImpl!(f, n)(bytes); }
    }

    // Common code currently shared between allocateImpl and allocateZeroedImpl.
    private enum _updateStatsForAllocateResult =
    q{
        add!"bytesUsed"(result.length);
        add!"bytesAllocated"(result.length);
        immutable slack = this.goodAllocSize(result.length) - result.length;
        add!"bytesSlack"(slack);
        up!"numAllocate";
        add!"numAllocateOK"(result.length == bytes); // allocating 0 bytes is OK
        addPerCall!(f, n, "numAllocate", "numAllocateOK", "bytesAllocated")
            (1, result.length == bytes, result.length);
    };

    private void[] allocateImpl(string f = null, ulong n = 0)(size_t bytes)
    {
        auto result = parent.allocate(bytes);
        mixin(_updateStatsForAllocateResult);
        return result;
    }

    static if (hasMember!(Allocator, "allocateZeroed"))
    {
        static if (!(perCallFlags
            & (Options.numAllocate | Options.numAllocateOK
                | Options.bytesAllocated)))
        {
            package(std) void[] allocateZeroed()(size_t n)
            { return allocateZeroedImpl(n); }
        }
        else
        {
            package(std) void[] allocateZeroed(string f = __FILE__, ulong n = __LINE__)
                (size_t bytes)
            { return allocateZeroedImpl!(f, n)(bytes); }
        }

        private void[] allocateZeroedImpl(string f = null, ulong n = 0)(size_t bytes)
        {
            auto result = parent.allocateZeroed(bytes);
            // Note: calls to `allocateZeroed` are counted for statistical purposes
            // as if they were calls to `allocate`. If/when `allocateZeroed` is made
            // public it might be of interest to count such calls separately.
            mixin(_updateStatsForAllocateResult);
            return result;
        }
    }

    /**
    Forwards to `parent.alignedAllocate`. Affects per instance: `numAlignedAllocate`,
    `bytesUsed`, `bytesAllocated`, `bytesSlack`, `numAlignedAllocateOk`,
    and `bytesHighTide`. Affects per call: `numAlignedAllocate`, `numAlignedAllocateOk`,
    and `bytesAllocated`.
    */
    static if (!(perCallFlags
        & (Options.numAlignedAllocate | Options.numAlignedAllocateOk
            | Options.bytesAllocated)))
    {
        void[] alignedAllocate(size_t n, uint a)
        { return alignedAllocateImpl(n, a); }
    }
    else
    {
        void[] alignedAllocate(string f = __FILE__, ulong n = __LINE__)
            (size_t bytes, uint a)
        { return alignedAllocateImpl!(f, n)(bytes, a); }
    }

    private void[] alignedAllocateImpl(string f = null, ulong n = 0)(size_t bytes, uint a)
    {
        up!"numAlignedAllocate";
        static if (!hasMember!(Allocator, "alignedAllocate"))
        {
            if (bytes == 0)
                up!"numAlignedAllocateOk";
            void[] result = null;
        }
        else
        {
            auto result = parent.alignedAllocate(bytes, a);
            add!"bytesUsed"(result.length);
            add!"bytesAllocated"(result.length);
            immutable slack = this.goodAllocSize(result.length) - result.length;
            add!"bytesSlack"(slack);
            add!"numAlignedAllocateOk"(result.length == bytes); // allocating 0 bytes is OK
        }
        addPerCall!(f, n, "numAlignedAllocate", "numAlignedAllocateOk", "bytesAllocated")
            (1, result.length == bytes, result.length);

        return result;
    }

    /**
    Defined whether or not `Allocator.expand` is defined. Affects
    per instance: `numExpand`, `numExpandOK`, `bytesExpanded`,
    `bytesSlack`, `bytesAllocated`, and `bytesUsed`. Affects per call:
    `numExpand`, `numExpandOK`, `bytesExpanded`, and
    `bytesAllocated`.
    */
    static if (!(perCallFlags
        & (Options.numExpand | Options.numExpandOK | Options.bytesExpanded)))
    {
        bool expand(ref void[] b, size_t delta)
        { return expandImpl(b, delta); }
    }
    else
    {
        bool expand(string f = __FILE__, uint n = __LINE__)
            (ref void[] b, size_t delta)
        { return expandImpl!(f, n)(b, delta); }
    }

    private bool expandImpl(string f = null, uint n = 0)(ref void[] b, size_t s)
    {
        up!"numExpand";
        Signed!size_t slack = 0;
        static if (!hasMember!(Allocator, "expand"))
        {
            auto result = s == 0;
        }
        else
        {
            immutable bytesSlackB4 = this.goodAllocSize(b.length) - b.length;
            auto result = parent.expand(b, s);
            if (result)
            {
                up!"numExpandOK";
                add!"bytesUsed"(s);
                add!"bytesAllocated"(s);
                add!"bytesExpanded"(s);
                slack = Signed!size_t(this.goodAllocSize(b.length) - b.length
                    - bytesSlackB4);
                add!"bytesSlack"(slack);
            }
        }
        immutable xtra = result ? s : 0;
        addPerCall!(f, n, "numExpand", "numExpandOK", "bytesExpanded",
            "bytesAllocated")
            (1, result, xtra, xtra);
        return result;
    }

    /**
    Defined whether or not `Allocator.reallocate` is defined. Affects
    per instance: `numReallocate`, `numReallocateOK`, $(D
    numReallocateInPlace), `bytesNotMoved`, `bytesAllocated`, $(D
    bytesSlack), `bytesExpanded`, and `bytesContracted`. Affects per call:
    `numReallocate`, `numReallocateOK`, `numReallocateInPlace`,
    `bytesNotMoved`, `bytesExpanded`, `bytesContracted`, and
    `bytesMoved`.
    */
    static if (!(perCallFlags
        & (Options.numReallocate | Options.numReallocateOK
            | Options.numReallocateInPlace | Options.bytesNotMoved
            | Options.bytesExpanded | Options.bytesContracted
            | Options.bytesMoved)))
    {
        bool reallocate(ref void[] b, size_t s)
        { return reallocateImpl(b, s); }
    }
    else
    {
        bool reallocate(string f = __FILE__, ulong n = __LINE__)
            (ref void[] b, size_t s)
        { return reallocateImpl!(f, n)(b, s); }
    }

    private bool reallocateImpl(string f = null, uint n = 0)
        (ref void[] b, size_t s)
    {
        up!"numReallocate";
        const bytesSlackB4 = this.goodAllocSize(b.length) - b.length;
        const oldB = b.ptr;
        const oldLength = b.length;

        const result = parent.reallocate(b, s);

        Signed!size_t slack = 0;
        bool wasInPlace = false;
        Signed!size_t delta = 0;

        if (result)
        {
            up!"numReallocateOK";
            slack = (this.goodAllocSize(b.length) - b.length) - bytesSlackB4;
            add!"bytesSlack"(slack);
            add!"bytesUsed"(Signed!size_t(b.length - oldLength));
            if (oldB == b.ptr)
            {
                // This was an in-place reallocation, yay
                wasInPlace = true;
                up!"numReallocateInPlace";
                add!"bytesNotMoved"(oldLength);
                delta = b.length - oldLength;
                if (delta >= 0)
                {
                    // Expansion
                    add!"bytesAllocated"(delta);
                    add!"bytesExpanded"(delta);
                }
                else
                {
                    // Contraction
                    add!"bytesContracted"(-delta);
                }
            }
            else
            {
                // This was a allocate-move-deallocate cycle
                add!"bytesAllocated"(b.length);
                add!"bytesMoved"(oldLength);
            }
        }
        addPerCall!(f, n, "numReallocate", "numReallocateOK",
            "numReallocateInPlace", "bytesNotMoved",
            "bytesExpanded", "bytesContracted", "bytesMoved")
            (1, result, wasInPlace, wasInPlace ? oldLength : 0,
                delta >= 0 ? delta : 0, delta < 0 ? -delta : 0,
                wasInPlace ? 0 : oldLength);
        return result;
    }

    /**
    Defined whether or not `Allocator.deallocate` is defined. Affects
    per instance: `numDeallocate`, `bytesUsed`, and `bytesSlack`.
    Affects per call: `numDeallocate` and `bytesContracted`.
    */
    static if (!(perCallFlags &
            (Options.numDeallocate | Options.bytesContracted)))
        bool deallocate(void[] b)
        { return deallocateImpl(b); }
    else
        bool deallocate(string f = __FILE__, uint n = __LINE__)(void[] b)
        { return deallocateImpl!(f, n)(b); }

    private bool deallocateImpl(string f = null, uint n = 0)(void[] b)
    {
        up!"numDeallocate";
        add!"bytesUsed"(-Signed!size_t(b.length));
        add!"bytesSlack"(-(this.goodAllocSize(b.length) - b.length));
        addPerCall!(f, n, "numDeallocate", "bytesContracted")(1, b.length);
        static if (hasMember!(Allocator, "deallocate"))
            return parent.deallocate(b);
        else
            return false;
    }

    static if (hasMember!(Allocator, "deallocateAll"))
    {
        /**
        Defined only if `Allocator.deallocateAll` is defined. Affects
        per instance and per call `numDeallocateAll`.
        */
        static if (!(perCallFlags & Options.numDeallocateAll))
            bool deallocateAll()
            { return deallocateAllImpl(); }
        else
            bool deallocateAll(string f = __FILE__, uint n = __LINE__)()
            { return deallocateAllImpl!(f, n)(); }

        private bool deallocateAllImpl(string f = null, uint n = 0)()
        {
            up!"numDeallocateAll";
            addPerCall!(f, n, "numDeallocateAll")(1);
            static if ((flags & Options.bytesUsed))
                _bytesUsed = 0;
            return parent.deallocateAll();
        }
    }

    /**
    Defined only if `Options.bytesUsed` is defined. Returns $(D bytesUsed ==
    0).
    */
    static if (flags & Options.bytesUsed)
    pure nothrow @safe @nogc
    Ternary empty()
    {
        return Ternary(_bytesUsed == 0);
    }

    /**
    Reports per instance statistics to `output` (e.g. `stdout`). The
    format is simple: one kind and value per line, separated by a colon, e.g.
    `bytesAllocated:7395404`
    */
    void reportStatistics(R)(auto ref R output)
    {
        import std.conv : to;
        import std.traits : EnumMembers;
        foreach (e; EnumMembers!Options)
        {
            static if ((flags & e) && e != Options.numAll
                    && e != Options.bytesAll && e != Options.all)
                output.write(e.to!string, ":", mixin(e.to!string), '\n');
        }
    }

    static if (perCallFlags)
    {
        /**
        Defined if `perCallFlags` is nonzero.
        */
        struct PerCallStatistics
        {
            /// The file and line of the call.
            string file;
            /// Ditto
            uint line;
            /// The options corresponding to the statistics collected.
            Options[] opts;
            /// The values of the statistics. Has the same length as `opts`.
            ulong[] values;
            // Next in the chain.
            private PerCallStatistics* next;

            /**
            Format to a string such as:
            $(D mymodule.d(655): [numAllocate:21, numAllocateOK:21, bytesAllocated:324202]).
            */
            string toString() const
            {
                import std.conv : text, to;
                auto result = text(file, "(", line, "): [");
                foreach (i, opt; opts)
                {
                    if (i) result ~= ", ";
                    result ~= opt.to!string;
                    result ~= ':';
                    result ~= values[i].to!string;
                }
                return result ~= "]";
            }
        }
        private static PerCallStatistics* root;

        /**
        Defined if `perCallFlags` is nonzero. Iterates all monitored
        file/line instances. The order of iteration is not meaningful (items
        are inserted at the front of a list upon the first call), so
        preprocessing the statistics after collection might be appropriate.
        */
        static auto byFileLine()
        {
            static struct Voldemort
            {
                PerCallStatistics* current;
                bool empty() { return !current; }
                ref PerCallStatistics front() { return *current; }
                void popFront() { current = current.next; }
                auto save() { return this; }
            }
            return Voldemort(root);
        }

        /**
        Defined if `perCallFlags` is nonzero. Outputs (e.g. to a `File`)
        a simple report of the collected per-call statistics.
        */
        static void reportPerCallStatistics(R)(auto ref R output)
        {
            output.write("Stats for: ", StatsCollector.stringof, '\n');
            foreach (ref stat; byFileLine)
            {
                output.write(stat, '\n');
            }
        }

        private PerCallStatistics* statsAt(string f, uint n, opts...)()
        {
            import std.array : array;
            import std.range : repeat;

            static PerCallStatistics s = { f, n, [ opts ],
                repeat(0UL, opts.length).array };
            static bool inserted;

            if (!inserted)
            {
                // Insert as root
                s.next = root;
                root = &s;
                inserted = true;
            }
            return &s;
        }

        private void addPerCall(string f, uint n, names...)(ulong[] values...)
        {
            import std.array : join;
            enum ulong mask = mixin("Options."~[names].join("|Options."));
            static if (perCallFlags & mask)
            {
                // Per allocation info
                auto ps = mixin("statsAt!(f, n,"
                    ~ "Options."~[names].join(", Options.")
                ~")");
                foreach (i; 0 .. names.length)
                {
                    ps.values[i] += values[i];
                }
            }
        }
    }
    else
    {
        private void addPerCall(string f, uint n, names...)(ulong[]...)
        {
        }
    }
}

///
@system unittest
{
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    alias Allocator = StatsCollector!(GCAllocator, Options.all, Options.all);

    Allocator alloc;
    auto b = alloc.allocate(10);
    alloc.reallocate(b, 20);
    alloc.deallocate(b);

    import std.file : deleteme, remove;
    import std.range : walkLength;
    import std.stdio : File;

    auto f = deleteme ~ "-dlang.std.experimental.allocator.stats_collector.txt";
    scope(exit) remove(f);
    Allocator.reportPerCallStatistics(File(f, "w"));
    alloc.reportStatistics(File(f, "a"));
    assert(File(f).byLine.walkLength == 24);
}

@system unittest
{
    void test(Allocator)()
    {
        import std.range : walkLength;
        import std.typecons : Ternary;

        Allocator a;
        assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.yes);
        auto b1 = a.allocate(100);
        assert(a.numAllocate == 1);
        assert((() nothrow @safe => a.expand(b1, 0))());
        assert(a.reallocate(b1, b1.length + 1));
        auto b2 = a.allocate(101);
        assert(a.numAllocate == 2);
        assert(a.bytesAllocated == 202);
        assert(a.bytesUsed == 202);
        auto b3 = a.allocate(202);
        assert(a.numAllocate == 3);
        assert(a.bytesAllocated == 404);
        assert((() pure nothrow @safe @nogc => a.empty)() == Ternary.no);

        () nothrow @nogc { a.deallocate(b2); }();
        assert(a.numDeallocate == 1);
        () nothrow @nogc { a.deallocate(b1); }();
        assert(a.numDeallocate == 2);
        () nothrow @nogc { a.deallocate(b3); }();
        assert(a.numDeallocate == 3);
        assert(a.numAllocate == a.numDeallocate);
        assert(a.bytesUsed == 0);
     }

    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    test!(StatsCollector!(GCAllocator, Options.all, Options.all));
    test!(StatsCollector!(FreeList!(GCAllocator, 128), Options.all,
        Options.all));
}

@system unittest
{
    void test(Allocator)()
    {
        import std.range : walkLength;
        Allocator a;
        auto b1 = a.allocate(100);
        assert((() nothrow @safe => a.expand(b1, 0))());
        assert(a.reallocate(b1, b1.length + 1));
        auto b2 = a.allocate(101);
        auto b3 = a.allocate(202);

        () nothrow @nogc { a.deallocate(b2); }();
        () nothrow @nogc { a.deallocate(b1); }();
        () nothrow @nogc { a.deallocate(b3); }();
    }
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    test!(StatsCollector!(GCAllocator, 0, 0));
}

@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    StatsCollector!(GCAllocator, 0, 0) a;

    // calls std.experimental.allocator.common.goodAllocSize
    assert((() pure nothrow @safe @nogc => a.goodAllocSize(1))());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    auto a = StatsCollector!(BorrowedRegion!(), Options.all, Options.all)(BorrowedRegion!()(new ubyte[1024 * 64]));
    auto b = a.allocate(42);
    assert(b.length == 42);
    // Test that reallocate infers from parent
    assert((() nothrow @nogc => a.reallocate(b, 100))());
    assert(b.length == 100);
    // Test that deallocateAll infers from parent
    assert((() nothrow @nogc => a.deallocateAll())());
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;

    auto a = StatsCollector!(BorrowedRegion!(), Options.all)(BorrowedRegion!()(new ubyte[1024 * 64]));
    auto b = a.alignedAllocate(42, 128);
    assert(b.length == 42);
    assert(b.ptr.alignedAt(128));
    assert(a.numAlignedAllocate == 1);
    assert(a.numAlignedAllocateOk == 1);
    assert(a.bytesUsed == 42);

    b = a.alignedAllocate(23, 256);
    assert(b.length == 23);
    assert(b.ptr.alignedAt(256));
    assert(a.numAlignedAllocate == 2);
    assert(a.numAlignedAllocateOk == 2);
    assert(a.bytesUsed == 65);

    b = a.alignedAllocate(0, 512);
    assert(b.length == 0);
    assert(a.numAlignedAllocate == 3);
    assert(a.numAlignedAllocateOk == 3);
    assert(a.bytesUsed == 65);

    b = a.alignedAllocate(1024 * 1024, 512);
    assert(b is null);
    assert(a.numAlignedAllocate == 4);
    assert(a.numAlignedAllocateOk == 3);
    assert(a.bytesUsed == 65);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.
/**
Utility and ancillary artifacts of `std.experimental.allocator`. This module
shouldn't be used directly; its functionality will be migrated into more
appropriate parts of `std`.

Authors: $(HTTP erdani.com, Andrei Alexandrescu), Timon Gehr (`Ternary`)

Source: $(PHOBOSSRC std/experimental/allocator/common.d)
*/
module std.experimental.allocator.common;
import std.algorithm.comparison, std.traits;

/**
Is `true` iff `A` is an allocator.
 */
enum isAllocator(A) = (is(typeof(A.allocate(size_t.init)) == void[]) && is(typeof(A.alignment) : size_t));

///
@safe @nogc nothrow pure
unittest
{
    import std.experimental.allocator.building_blocks.null_allocator : NullAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mmap_allocator : MmapAllocator;
    static assert(isAllocator!NullAllocator);
    static assert(isAllocator!Mallocator);
    static assert(isAllocator!GCAllocator);
    static assert(isAllocator!MmapAllocator);
    static assert(!isAllocator!int);
}

/**
Returns the size in bytes of the state that needs to be allocated to hold an
object of type `T`. `stateSize!T` is zero for `struct`s that are not
nested and have no nonstatic member variables.
 */
template stateSize(T)
{
    static if (is(T == class) || is(T == interface))
        enum stateSize = __traits(classInstanceSize, T);
    else static if (is(T == struct) || is(T == union))
        enum stateSize = Fields!T.length || isNested!T ? T.sizeof : 0;
    else static if (is(T == void))
        enum size_t stateSize = 0;
    else
        enum stateSize = T.sizeof;
}

@safe @nogc nothrow pure
unittest
{
    static assert(stateSize!void == 0);
    struct A {}
    static assert(stateSize!A == 0);
    struct B { int x; }
    static assert(stateSize!B == 4);
    interface I1 {}
    //static assert(stateSize!I1 == 2 * size_t.sizeof);
    class C1 {}
    static assert(stateSize!C1 == 3 * size_t.sizeof);
    class C2 { char c; }
    static assert(stateSize!C2 == 4 * size_t.sizeof);
    static class C3 { char c; }
    static assert(stateSize!C3 == 2 * size_t.sizeof + char.sizeof);
}

/**
Returns `true` if the `Allocator` has the alignment known at compile time;
otherwise it returns `false`.
 */
template hasStaticallyKnownAlignment(Allocator)
{
    enum hasStaticallyKnownAlignment = __traits(compiles,
                                                {enum x = Allocator.alignment;});
}

/**
`chooseAtRuntime` is a compile-time constant of type `size_t` that several
parameterized structures in this module recognize to mean deferral to runtime of
the exact value. For example, $(D BitmappedBlock!(Allocator, 4096)) (described in
detail below) defines a block allocator with block size of 4096 bytes, whereas
$(D BitmappedBlock!(Allocator, chooseAtRuntime)) defines a block allocator that has a
field storing the block size, initialized by the user.
*/
enum chooseAtRuntime = size_t.max - 1;

/**
`unbounded` is a compile-time constant of type `size_t` that several
parameterized structures in this module recognize to mean "infinite" bounds for
the parameter. For example, `Freelist` (described in detail below) accepts a
`maxNodes` parameter limiting the number of freelist items. If `unbounded`
is passed for `maxNodes`, then there is no limit and no checking for the
number of nodes.
*/
enum unbounded = size_t.max;

/**
The alignment that is guaranteed to accommodate any D object allocation on the
current platform.
*/
enum uint platformAlignment = std.algorithm.comparison.max(double.alignof, real.alignof);

/**
The default good size allocation is deduced as `n` rounded up to the
allocator's alignment.
*/
size_t goodAllocSize(A)(auto ref A a, size_t n)
{
    return n.roundUpToMultipleOf(a.alignment);
}

/*
Returns s rounded up to a multiple of base.
*/
@safe @nogc nothrow pure
package size_t roundUpToMultipleOf(size_t s, uint base)
{
    assert(base);
    auto rem = s % base;
    return rem ? s + base - rem : s;
}

@safe @nogc nothrow pure
unittest
{
    assert(10.roundUpToMultipleOf(11) == 11);
    assert(11.roundUpToMultipleOf(11) == 11);
    assert(12.roundUpToMultipleOf(11) == 22);
    assert(118.roundUpToMultipleOf(11) == 121);
}

/*
Returns `n` rounded up to a multiple of alignment, which must be a power of 2.
*/
@safe @nogc nothrow pure
package size_t roundUpToAlignment(size_t n, uint alignment)
{
    import std.math.traits : isPowerOf2;
    assert(alignment.isPowerOf2);
    immutable uint slack = cast(uint) n & (alignment - 1);
    const result = slack
        ? n + alignment - slack
        : n;
    assert(result >= n);
    return result;
}

@safe @nogc nothrow pure
unittest
{
    assert(10.roundUpToAlignment(4) == 12);
    assert(11.roundUpToAlignment(2) == 12);
    assert(12.roundUpToAlignment(8) == 16);
    assert(118.roundUpToAlignment(64) == 128);
}

/*
Returns `n` rounded down to a multiple of alignment, which must be a power of 2.
*/
@safe @nogc nothrow pure
package size_t roundDownToAlignment(size_t n, uint alignment)
{
    import std.math.traits : isPowerOf2;
    assert(alignment.isPowerOf2);
    return n & ~size_t(alignment - 1);
}

@safe @nogc nothrow pure
unittest
{
    assert(10.roundDownToAlignment(4) == 8);
    assert(11.roundDownToAlignment(2) == 10);
    assert(12.roundDownToAlignment(8) == 8);
    assert(63.roundDownToAlignment(64) == 0);
}

/*
Advances the beginning of `b` to start at alignment `a`. The resulting buffer
may therefore be shorter. Returns the adjusted buffer, or null if obtaining a
non-empty buffer is impossible.
*/
@nogc nothrow pure
package void[] roundUpToAlignment(void[] b, uint a)
{
    auto e = b.ptr + b.length;
    auto p = cast(void*) roundUpToAlignment(cast(size_t) b.ptr, a);
    if (e <= p) return null;
    return p[0 .. e - p];
}

@nogc nothrow pure
@system unittest
{
    void[] empty;
    assert(roundUpToAlignment(empty, 4) == null);
    char[128] buf;
    // At least one pointer inside buf is 128-aligned
    assert(roundUpToAlignment(buf, 128) !is null);
}

/*
Like `a / b` but rounds the result up, not down.
*/
@safe @nogc nothrow pure
package size_t divideRoundUp(size_t a, size_t b)
{
    assert(b);
    return (a + b - 1) / b;
}

/*
Returns `s` rounded up to a multiple of `base`.
*/
@nogc nothrow pure
package void[] roundStartToMultipleOf(void[] s, uint base)
{
    assert(base);
    auto p = cast(void*) roundUpToMultipleOf(
        cast(size_t) s.ptr, base);
    auto end = s.ptr + s.length;
    return p[0 .. end - p];
}

nothrow pure
@system unittest
{
    void[] p;
    assert(roundStartToMultipleOf(p, 16) is null);
    p = new ulong[10];
    assert(roundStartToMultipleOf(p, 16) is p);
}

/*
Returns `s` rounded up to the nearest power of 2.
*/
@safe @nogc nothrow pure
package size_t roundUpToPowerOf2(size_t s)
{
    import std.meta : AliasSeq;
    assert(s <= (size_t.max >> 1) + 1);
    --s;
    static if (size_t.sizeof == 4)
        alias Shifts = AliasSeq!(1, 2, 4, 8, 16);
    else
        alias Shifts = AliasSeq!(1, 2, 4, 8, 16, 32);
    foreach (i; Shifts)
    {
        s |= s >> i;
    }
    return s + 1;
}

@safe @nogc nothrow pure
unittest
{
    assert(0.roundUpToPowerOf2 == 0);
    assert(1.roundUpToPowerOf2 == 1);
    assert(2.roundUpToPowerOf2 == 2);
    assert(3.roundUpToPowerOf2 == 4);
    assert(7.roundUpToPowerOf2 == 8);
    assert(8.roundUpToPowerOf2 == 8);
    assert(10.roundUpToPowerOf2 == 16);
    assert(11.roundUpToPowerOf2 == 16);
    assert(12.roundUpToPowerOf2 == 16);
    assert(118.roundUpToPowerOf2 == 128);
    assert((size_t.max >> 1).roundUpToPowerOf2 == (size_t.max >> 1) + 1);
    assert(((size_t.max >> 1) + 1).roundUpToPowerOf2 == (size_t.max >> 1) + 1);
}

/*
Returns the number of trailing zeros of `x`.
*/
@safe @nogc nothrow pure
package uint trailingZeros(ulong x)
{
    import core.bitop : bsf;
    return x == 0 ? 64 : bsf(x);
}

@safe @nogc nothrow pure
unittest
{
    assert(trailingZeros(0) == 64);
    assert(trailingZeros(1) == 0);
    assert(trailingZeros(2) == 1);
    assert(trailingZeros(3) == 0);
    assert(trailingZeros(4) == 2);
}

/*
Returns `true` if `ptr` is aligned at `alignment`.
*/
@nogc nothrow pure
package bool alignedAt(T)(T* ptr, uint alignment)
{
    return cast(size_t) ptr % alignment == 0;
}

/*
Returns the effective alignment of `ptr`, i.e. the largest power of two that is
a divisor of `ptr`.
*/
@nogc nothrow pure
package size_t effectiveAlignment(void* ptr)
{
    return (cast(size_t) 1) << trailingZeros(cast(size_t) ptr);
}

@nogc nothrow pure
@system unittest
{
    int x;
    assert(effectiveAlignment(&x) >= int.alignof);

    const max = (cast(size_t) 1) << (size_t.sizeof * 8 - 1);
    assert(effectiveAlignment(cast(void*) max) == max);
}

/*
Aligns a pointer down to a specified alignment. The resulting pointer is less
than or equal to the given pointer.
*/
@nogc nothrow pure
package void* alignDownTo(return scope void* ptr, uint alignment)
{
    import std.math.traits : isPowerOf2;
    assert(alignment.isPowerOf2);
    return cast(void*) (cast(size_t) ptr & ~(alignment - 1UL));
}

/*
Aligns a pointer up to a specified alignment. The resulting pointer is greater
than or equal to the given pointer.
*/
@nogc nothrow pure
package void* alignUpTo(return scope void* ptr, uint alignment)
{
    import std.math.traits : isPowerOf2;
    assert(alignment.isPowerOf2);
    immutable uint slack = cast(size_t) ptr & (alignment - 1U);
    return slack ? ptr + alignment - slack : ptr;
}

@safe @nogc nothrow pure
package bool isGoodStaticAlignment(uint x)
{
    import std.math.traits : isPowerOf2;
    return x.isPowerOf2;
}

@safe @nogc nothrow pure
package bool isGoodDynamicAlignment(uint x)
{
    import std.math.traits : isPowerOf2;
    return x.isPowerOf2 && x >= (void*).sizeof;
}

/**
The default `reallocate` function first attempts to use `expand`. If $(D
Allocator.expand) is not defined or returns `false`, `reallocate`
allocates a new block of memory of appropriate size and copies data from the old
block to the new block. Finally, if `Allocator` defines `deallocate`, $(D
reallocate) uses it to free the old memory block.

`reallocate` does not attempt to use `Allocator.reallocate` even if
defined. This is deliberate so allocators may use it internally within their own
implementation of `reallocate`.

*/
bool reallocate(Allocator)(ref Allocator a, ref void[] b, size_t s)
{
    if (b.length == s) return true;
    static if (hasMember!(Allocator, "expand"))
    {
        if (b.length <= s && a.expand(b, s - b.length)) return true;
    }
    auto newB = a.allocate(s);
    if (newB.length != s) return false;
    if (newB.length <= b.length) newB[] = b[0 .. newB.length];
    else newB[0 .. b.length] = b[];
    static if (hasMember!(Allocator, "deallocate"))
        a.deallocate(b);
    b = newB;
    return true;
}

/**

The default `alignedReallocate` function first attempts to use `expand`.
If `Allocator.expand` is not defined or returns `false`,  $(D
alignedReallocate) allocates a new block of memory of appropriate size and
copies data from the old block to the new block. Finally, if `Allocator`
defines `deallocate`, `alignedReallocate` uses it to free the old memory
block.

`alignedReallocate` does not attempt to use `Allocator.reallocate` even if
defined. This is deliberate so allocators may use it internally within their own
implementation of `reallocate`.

*/
bool alignedReallocate(Allocator)(ref Allocator alloc,
        ref void[] b, size_t s, uint a)
if (hasMember!(Allocator, "alignedAllocate"))
{
    static if (hasMember!(Allocator, "expand"))
    {
        if (b.length <= s && b.ptr.alignedAt(a)
            && alloc.expand(b, s - b.length)) return true;
    }
    else
    {
        if (b.length == s && b.ptr.alignedAt(a)) return true;
    }
    auto newB = alloc.alignedAllocate(s, a);
    if (newB.length != s) return false;
    if (newB.length <= b.length) newB[] = b[0 .. newB.length];
    else newB[0 .. b.length] = b[];
    static if (hasMember!(Allocator, "deallocate"))
        alloc.deallocate(b);
    b = newB;
    return true;
}

@system unittest
{
    bool called = false;
    struct DummyAllocator
    {
        void[] alignedAllocate(size_t size, uint alignment)
        {
            called = true;
            return null;
        }
    }

    struct DummyAllocatorExpand
    {
        void[] alignedAllocate(size_t size, uint alignment)
        {
            return null;
        }

        bool expand(ref void[] b, size_t length)
        {
            called = true;
            return true;
        }
    }

    char[128] buf;
    uint alignment = 32;
    auto alignedPtr = roundUpToMultipleOf(cast(size_t) buf.ptr, alignment);
    auto diff = alignedPtr - cast(size_t) buf.ptr;

    // Align the buffer to 'alignment'
    void[] b = cast(void[]) (buf.ptr + diff)[0 .. buf.length - diff];

    DummyAllocator a1;
    // Ask for same length and alignment, should not call 'alignedAllocate'
    assert(alignedReallocate(a1, b, b.length, alignment));
    assert(!called);

    // Ask for same length, different alignment
    // should call 'alignedAllocate' if not aligned to new value
    alignedReallocate(a1, b, b.length, alignment + 1);
    assert(b.ptr.alignedAt(alignment + 1) || called);
    called = false;

    DummyAllocatorExpand a2;
    // Ask for bigger length, same alignment, should call 'expand'
    assert(alignedReallocate(a2, b, b.length + 1, alignment));
    assert(called);
    called = false;

    // Ask for bigger length, different alignment
    // should call 'alignedAllocate' if not aligned to new value
    alignedReallocate(a2, b, b.length + 1, alignment + 1);
    assert(b.ptr.alignedAt(alignment + 1) || !called);
}

/**
Forwards each of the methods in `funs` (if defined) to `member`.
*/
/*package*/ string forwardToMember(string member, string[] funs...)
{
    string result = "    import std.traits : hasMember, Parameters;\n";
    foreach (fun; funs)
    {
        result ~= "
    static if (hasMember!(typeof("~member~"), `"~fun~"`))
    auto ref "~fun~"(Parameters!(typeof("~member~"."~fun~")) args)
    {
        return "~member~"."~fun~"(args);
    }\n";
    }
    return result;
}

version (StdUnittest)
{

    package void testAllocator(alias make)()
    {
        import std.conv : text;
        import std.math.traits : isPowerOf2;
        import std.stdio : writeln, stderr;
        import std.typecons : Ternary;
        alias A = typeof(make());
        scope(failure) stderr.writeln("testAllocator failed for ", A.stringof);

        auto a = make();

        // Test alignment
        static assert(A.alignment.isPowerOf2);

        // Test goodAllocSize
        assert(a.goodAllocSize(1) >= A.alignment,
                text(a.goodAllocSize(1), " < ", A.alignment));
        assert(a.goodAllocSize(11) >= 11.roundUpToMultipleOf(A.alignment));
        assert(a.goodAllocSize(111) >= 111.roundUpToMultipleOf(A.alignment));

        // Test allocate
        assert(a.allocate(0) is null);

        auto b1 = a.allocate(1);
        assert(b1.length == 1);
        auto b2 = a.allocate(2);
        assert(b2.length == 2);
        assert(b2.ptr + b2.length <= b1.ptr || b1.ptr + b1.length <= b2.ptr);

        // Test allocateZeroed
        static if (hasMember!(A, "allocateZeroed"))
        {{
            auto b3 = a.allocateZeroed(8);
            if (b3 !is null)
            {
                assert(b3.length == 8);
                foreach (e; cast(ubyte[]) b3)
                    assert(e == 0);
            }
        }}

        // Test alignedAllocate
        static if (hasMember!(A, "alignedAllocate"))
        {{
             auto b3 = a.alignedAllocate(1, 256);
             assert(b3.length <= 1);
             assert(b3.ptr.alignedAt(256));
             assert(a.alignedReallocate(b3, 2, 512));
             assert(b3.ptr.alignedAt(512));
             static if (hasMember!(A, "alignedDeallocate"))
             {
                 a.alignedDeallocate(b3);
             }
         }}
        else
        {
            static assert(!hasMember!(A, "alignedDeallocate"));
            // This seems to be a bug in the compiler:
            //static assert(!hasMember!(A, "alignedReallocate"), A.stringof);
        }

        static if (hasMember!(A, "allocateAll"))
        {{
             auto aa = make();
             if (aa.allocateAll().ptr)
             {
                 // Can't get any more memory
                 assert(!aa.allocate(1).ptr);
             }
             auto ab = make();
             const b4 = ab.allocateAll();
             assert(b4.length);
             // Can't get any more memory
             assert(!ab.allocate(1).ptr);
         }}

        static if (hasMember!(A, "expand"))
        {{
             assert(a.expand(b1, 0));
             auto len = b1.length;
             if (a.expand(b1, 102))
             {
                 assert(b1.length == len + 102, text(b1.length, " != ", len + 102));
             }
             auto aa = make();
             void[] b5 = null;
             assert(aa.expand(b5, 0));
             assert(b5 is null);
             assert(!aa.expand(b5, 1));
             assert(b5.length == 0);
         }}

        void[] b6 = null;
        assert(a.reallocate(b6, 0));
        assert(b6.length == 0);
        assert(a.reallocate(b6, 1));
        assert(b6.length == 1, text(b6.length));
        assert(a.reallocate(b6, 2));
        assert(b6.length == 2);

        // Test owns
        static if (hasMember!(A, "owns"))
        {{
             assert(a.owns(null) == Ternary.no);
             assert(a.owns(b1) == Ternary.yes);
             assert(a.owns(b2) == Ternary.yes);
             assert(a.owns(b6) == Ternary.yes);
         }}

        static if (hasMember!(A, "resolveInternalPointer"))
        {{
             void[] p;
             assert(a.resolveInternalPointer(null, p) == Ternary.no);
             Ternary r = a.resolveInternalPointer(b1.ptr, p);
             assert(p.ptr is b1.ptr && p.length >= b1.length);
             r = a.resolveInternalPointer(b1.ptr + b1.length / 2, p);
             assert(p.ptr is b1.ptr && p.length >= b1.length);
             r = a.resolveInternalPointer(b2.ptr, p);
             assert(p.ptr is b2.ptr && p.length >= b2.length);
             r = a.resolveInternalPointer(b2.ptr + b2.length / 2, p);
             assert(p.ptr is b2.ptr && p.length >= b2.length);
             r = a.resolveInternalPointer(b6.ptr, p);
             assert(p.ptr is b6.ptr && p.length >= b6.length);
             r = a.resolveInternalPointer(b6.ptr + b6.length / 2, p);
             assert(p.ptr is b6.ptr && p.length >= b6.length);
             static int[10] b7 = [ 1, 2, 3 ];
             assert(a.resolveInternalPointer(b7.ptr, p) == Ternary.no);
             assert(a.resolveInternalPointer(b7.ptr + b7.length / 2, p) == Ternary.no);
             assert(a.resolveInternalPointer(b7.ptr + b7.length, p) == Ternary.no);
             int[3] b8 = [ 1, 2, 3 ];
             assert(a.resolveInternalPointer(b8.ptr, p) == Ternary.no);
             assert(a.resolveInternalPointer(b8.ptr + b8.length / 2, p) == Ternary.no);
             assert(a.resolveInternalPointer(b8.ptr + b8.length, p) == Ternary.no);
         }}
    }

    package void testAllocatorObject(RCAllocInterface)(RCAllocInterface a)
    {
        // this used to be a template constraint, but moving it inside prevents
        // unnecessary import of std.experimental.allocator
        import std.experimental.allocator : RCIAllocator, RCISharedAllocator;
        static assert(is(RCAllocInterface == RCIAllocator)
            || is (RCAllocInterface == RCISharedAllocator));

        import std.conv : text;
        import std.math.traits : isPowerOf2;
        import std.stdio : writeln, stderr;
        import std.typecons : Ternary;
        scope(failure) stderr.writeln("testAllocatorObject failed for ",
                RCAllocInterface.stringof);

        assert(!a.isNull);

        // Test alignment
        assert(a.alignment.isPowerOf2);

        // Test goodAllocSize
        assert(a.goodAllocSize(1) >= a.alignment,
                text(a.goodAllocSize(1), " < ", a.alignment));
        assert(a.goodAllocSize(11) >= 11.roundUpToMultipleOf(a.alignment));
        assert(a.goodAllocSize(111) >= 111.roundUpToMultipleOf(a.alignment));

        // Test empty
        assert(a.empty != Ternary.no);

        // Test allocate
        assert(a.allocate(0) is null);

        auto b1 = a.allocate(1);
        assert(b1.length == 1);
        auto b2 = a.allocate(2);
        assert(b2.length == 2);
        assert(b2.ptr + b2.length <= b1.ptr || b1.ptr + b1.length <= b2.ptr);

        // Test alignedAllocate
        {
            // If not implemented it will return null, so those should pass
            auto b3 = a.alignedAllocate(1, 256);
            assert(b3.length <= 1);
            assert(b3.ptr.alignedAt(256));
            if (a.alignedReallocate(b3, 1, 256))
            {
                // If it is false, then the wrapped allocator did not implement
                // this
                assert(a.alignedReallocate(b3, 2, 512));
                assert(b3.ptr.alignedAt(512));
            }
        }

        // Test allocateAll
        {
            auto aa = a.allocateAll();
            if (aa.ptr)
            {
                // Can't get any more memory
                assert(!a.allocate(1).ptr);
                a.deallocate(aa);
            }
            const b4 = a.allocateAll();
            if (b4.ptr)
            {
                // Can't get any more memory
                assert(!a.allocate(1).ptr);
            }
        }

        // Test expand
        {
            assert(a.expand(b1, 0));
            auto len = b1.length;
            if (a.expand(b1, 102))
            {
                assert(b1.length == len + 102, text(b1.length, " != ", len + 102));
            }
        }

        void[] b6 = null;
        assert(a.reallocate(b6, 0));
        assert(b6.length == 0);
        assert(a.reallocate(b6, 1));
        assert(b6.length == 1, text(b6.length));
        assert(a.reallocate(b6, 2));
        assert(b6.length == 2);

        // Test owns
        {
            if (a.owns(null) != Ternary.unknown)
            {
                assert(a.owns(null) == Ternary.no);
                assert(a.owns(b1) == Ternary.yes);
                assert(a.owns(b2) == Ternary.yes);
                assert(a.owns(b6) == Ternary.yes);
            }
        }

        // Test resolveInternalPointer
        {
            void[] p;
            if (a.resolveInternalPointer(null, p) != Ternary.unknown)
            {
                assert(a.resolveInternalPointer(null, p) == Ternary.no);
                Ternary r = a.resolveInternalPointer(b1.ptr, p);
                assert(p.ptr is b1.ptr && p.length >= b1.length);
                r = a.resolveInternalPointer(b1.ptr + b1.length / 2, p);
                assert(p.ptr is b1.ptr && p.length >= b1.length);
                r = a.resolveInternalPointer(b2.ptr, p);
                assert(p.ptr is b2.ptr && p.length >= b2.length);
                r = a.resolveInternalPointer(b2.ptr + b2.length / 2, p);
                assert(p.ptr is b2.ptr && p.length >= b2.length);
                r = a.resolveInternalPointer(b6.ptr, p);
                assert(p.ptr is b6.ptr && p.length >= b6.length);
                r = a.resolveInternalPointer(b6.ptr + b6.length / 2, p);
                assert(p.ptr is b6.ptr && p.length >= b6.length);
                static int[10] b7 = [ 1, 2, 3 ];
                assert(a.resolveInternalPointer(b7.ptr, p) == Ternary.no);
                assert(a.resolveInternalPointer(b7.ptr + b7.length / 2, p) == Ternary.no);
                assert(a.resolveInternalPointer(b7.ptr + b7.length, p) == Ternary.no);
                int[3] b8 = [ 1, 2, 3 ];
                assert(a.resolveInternalPointer(b8.ptr, p) == Ternary.no);
                assert(a.resolveInternalPointer(b8.ptr + b8.length / 2, p) == Ternary.no);
                assert(a.resolveInternalPointer(b8.ptr + b8.length, p) == Ternary.no);
            }
        }

        // Test deallocateAll
        {
            if (a.deallocateAll())
            {
                if (a.empty != Ternary.unknown)
                {
                    assert(a.empty == Ternary.yes);
                }
            }
        }
    }
}
                                                                                                            // Written in the D programming language.
/**
D's built-in garbage-collected allocator.

Source: $(PHOBOSSRC std/experimental/allocator/_gc_allocator.d)
*/
module std.experimental.allocator.gc_allocator;
import std.experimental.allocator.common;

/**
D's built-in garbage-collected allocator.
*/
struct GCAllocator
{
    import core.memory : GC;
    import std.typecons : Ternary;
    version (StdUnittest) @system unittest { testAllocator!(() => GCAllocator.instance); }

    /**
    The alignment is a static constant equal to `platformAlignment`, which
    ensures proper alignment for any D data type.
    */
    enum uint alignment = platformAlignment;

    /**
    Standard allocator methods per the semantics defined above. The $(D
    deallocate) and `reallocate` methods are `@system` because they may
    move memory around, leaving dangling pointers in user code.
    */
    pure nothrow @trusted void[] allocate(size_t bytes) shared const
    {
        if (!bytes) return null;
        auto p = GC.malloc(bytes);
        return p ? p[0 .. bytes] : null;
    }

    /// Ditto
    pure nothrow @trusted bool expand(ref void[] b, size_t delta) shared const
    {
        if (delta == 0) return true;
        if (b is null) return false;
        immutable curLength = GC.sizeOf(b.ptr);
        assert(curLength != 0); // we have a valid GC pointer here
        immutable desired = b.length + delta;
        if (desired > curLength) // check to see if the current block can't hold the data
        {
            immutable sizeRequest = desired - curLength;
            immutable newSize = GC.extend(b.ptr, sizeRequest, sizeRequest);
            if (newSize == 0)
            {
                // expansion unsuccessful
                return false;
            }
            assert(newSize >= desired);
        }
        b = b.ptr[0 .. desired];
        return true;
    }

    /// Ditto
    pure nothrow @system bool reallocate(ref void[] b, size_t newSize) shared const
    {
        import core.exception : OutOfMemoryError;
        try
        {
            auto p = cast(ubyte*) GC.realloc(b.ptr, newSize);
            b = p[0 .. newSize];
        }
        catch (OutOfMemoryError)
        {
            // leave the block in place, tell caller
            return false;
        }
        return true;
    }

    /// Ditto
    pure nothrow @trusted @nogc
    Ternary resolveInternalPointer(const void* p, ref void[] result) shared const
    {
        auto r = GC.addrOf(cast(void*) p);
        if (!r) return Ternary.no;
        result = r[0 .. GC.sizeOf(r)];
        return Ternary.yes;
    }

    /// Ditto
    pure nothrow @system @nogc
    bool deallocate(void[] b) shared const
    {
        GC.free(b.ptr);
        return true;
    }

    /// Ditto
    pure nothrow @safe @nogc
    size_t goodAllocSize(size_t n) shared const
    {
        if (n == 0)
            return 0;
        if (n <= 16)
            return 16;

        import core.bitop : bsr;

        auto largestBit = bsr(n-1) + 1;
        if (largestBit <= 12) // 4096 or less
            return size_t(1) << largestBit;

        // larger, we use a multiple of 4096.
        return ((n + 4095) / 4096) * 4096;
    }

    package pure nothrow @trusted void[] allocateZeroed()(size_t bytes) shared const
    {
        if (!bytes) return null;
        auto p = GC.calloc(bytes);
        return p ? p[0 .. bytes] : null;
    }

    /**
    Returns the global instance of this allocator type. The garbage collected
    allocator is thread-safe, therefore all of its methods and `instance` itself
    are `shared`.
    */

    static shared const GCAllocator instance;

    // Leave it undocummented for now.
    nothrow @trusted void collect() shared const
    {
        GC.collect();
    }
}

///
pure @system unittest
{
    auto buffer = GCAllocator.instance.allocate(1024 * 1024 * 4);
    // deallocate upon scope's end (alternatively: leave it to collection)
    scope(exit) GCAllocator.instance.deallocate(buffer);
    //...
}

pure @safe unittest
{
    auto b = GCAllocator.instance.allocate(10_000);
    assert(GCAllocator.instance.expand(b, 1));
}

pure @system unittest
{
    import core.memory : GC;
    import std.typecons : Ternary;

    // test allocation sizes
    assert((() nothrow @safe @nogc => GCAllocator.instance.goodAllocSize(1))() == 16);
    for (size_t s = 16; s <= 8192; s *= 2)
    {
        assert((() nothrow @safe @nogc => GCAllocator.instance.goodAllocSize(s))() == s);
        assert((() nothrow @safe @nogc => GCAllocator.instance.goodAllocSize(s - (s / 2) + 1))() == s);

        auto buffer = GCAllocator.instance.allocate(s);
        scope(exit) () nothrow @nogc { GCAllocator.instance.deallocate(buffer); }();

        void[] p;
        assert((() nothrow @safe => GCAllocator.instance.resolveInternalPointer(null, p))() == Ternary.no);
        assert((() nothrow @safe => GCAllocator.instance.resolveInternalPointer(&buffer[0], p))() == Ternary.yes);
        assert(p.ptr is buffer.ptr && p.length >= buffer.length);

        assert(GC.sizeOf(buffer.ptr) == s);

        // the GC should provide power of 2 as "good" sizes, but other sizes are allowed, too
        version (none)
        {
            auto buffer2 = GCAllocator.instance.allocate(s - (s / 2) + 1);
            scope(exit) () nothrow @nogc { GCAllocator.instance.deallocate(buffer2); }();

            assert(GC.sizeOf(buffer2.ptr) == s);
        }
    }

    // anything above a page is simply rounded up to next page
    assert((() nothrow @safe @nogc => GCAllocator.instance.goodAllocSize(4096 * 4 + 1))() == 4096 * 5);
}

pure nothrow @safe unittest
{
    import std.typecons : Ternary;

    void[] buffer = GCAllocator.instance.allocate(42);
    void[] result;
    Ternary found = GCAllocator.instance.resolveInternalPointer(&buffer[0], result);

    assert(found == Ternary.yes && &result[0] == &buffer[0] && result.length >= buffer.length);
    assert(GCAllocator.instance.resolveInternalPointer(null, result) == Ternary.no);
    void *badPtr = (() @trusted => cast(void*)(0xdeadbeef))();
    assert(GCAllocator.instance.resolveInternalPointer(badPtr, result) == Ternary.no);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Written in the D programming language.
/**
The C heap allocator.

Source: $(PHOBOSSRC std/experimental/allocator/mallocator.d)
*/
module std.experimental.allocator.mallocator;
import std.experimental.allocator.common;

/**
   The C heap allocator.
 */
struct Mallocator
{
    version (StdUnittest) @system unittest { testAllocator!(() => Mallocator.instance); }

    /**
    The alignment is a static constant equal to `platformAlignment`, which
    ensures proper alignment for any D data type.
    */
    enum uint alignment = platformAlignment;

    /**
    Standard allocator methods per the semantics defined above. The
    `deallocate` and `reallocate` methods are `@system` because they
    may move memory around, leaving dangling pointers in user code. Somewhat
    paradoxically, `malloc` is `@safe` but that's only useful to safe
    programs that can afford to leak memory allocated.
    */
    @trusted @nogc nothrow pure
    void[] allocate(size_t bytes) shared const
    {
        import core.memory : pureMalloc;
        if (!bytes) return null;
        auto p = pureMalloc(bytes);
        return p ? p[0 .. bytes] : null;
    }

    /// Ditto
    @system @nogc nothrow pure
    bool deallocate(void[] b) shared const
    {
        import core.memory : pureFree;
        pureFree(b.ptr);
        return true;
    }

    /// Ditto
    @system @nogc nothrow pure
    bool reallocate(ref void[] b, size_t s) shared const
    {
        import core.memory : pureRealloc;
        if (!s)
        {
            // fuzzy area in the C standard, see http://goo.gl/ZpWeSE
            // so just deallocate and nullify the pointer
            deallocate(b);
            b = null;
            return true;
        }
        auto p = cast(ubyte*) pureRealloc(b.ptr, s);
        if (!p) return false;
        b = p[0 .. s];
        return true;
    }

    @trusted @nogc nothrow pure
    package void[] allocateZeroed()(size_t bytes) shared const
    {
        import core.memory : pureCalloc;
        if (!bytes) return null;
        auto p = pureCalloc(1, bytes);
        return p ? p[0 .. bytes] : null;
    }

    /**
    Returns the global instance of this allocator type. The C heap allocator is
    thread-safe, therefore all of its methods and `it` itself are
    `shared`.
    */
    static shared Mallocator instance;
}

///
@nogc @system nothrow unittest
{
    auto buffer = Mallocator.instance.allocate(1024 * 1024 * 4);
    scope(exit) Mallocator.instance.deallocate(buffer);
    //...
}

@nogc @system nothrow pure unittest
{
    @nogc nothrow pure
    static void test(A)()
    {
        int* p = null;
        p = cast(int*) A.instance.allocate(int.sizeof);
        scope(exit) () nothrow @nogc { A.instance.deallocate(p[0 .. int.sizeof]); }();
        *p = 42;
        assert(*p == 42);
    }
    test!Mallocator();
}

@nogc @system nothrow pure unittest
{
    static void test(A)()
    {
        import std.experimental.allocator : make;
        Object p = null;
        p = A.instance.make!Object();
        assert(p !is null);
    }

    test!Mallocator();
}

version (Windows)
{
    // DMD Win 32 bit, DigitalMars C standard library misses the _aligned_xxx
    // functions family (snn.lib)
    version (CRuntime_DigitalMars)
    {
        // Helper to cast the infos written before the aligned pointer
        // this header keeps track of the size (required to realloc) and of
        // the base ptr (required to free).
        private struct AlignInfo
        {
            void* basePtr;
            size_t size;

            @nogc nothrow
            static AlignInfo* opCall(void* ptr)
            {
                return cast(AlignInfo*) (ptr - AlignInfo.sizeof);
            }
        }

        @nogc nothrow
        private void* _aligned_malloc(size_t size, size_t alignment)
        {
            import core.stdc.stdlib : malloc;
            size_t offset = alignment + size_t.sizeof * 2 - 1;

            // unaligned chunk
            void* basePtr = malloc(size + offset);
            if (!basePtr) return null;

            // get aligned location within the chunk
            void* alignedPtr = cast(void**)((cast(size_t)(basePtr) + offset)
                & ~(alignment - 1));

            // write the header before the aligned pointer
            AlignInfo* head = AlignInfo(alignedPtr);
            head.basePtr = basePtr;
            head.size = size;

            return alignedPtr;
        }

        @nogc nothrow
        private void* _aligned_realloc(void* ptr, size_t size, size_t alignment)
        {
            import core.stdc.stdlib : free;
            import core.stdc.string : memcpy;

            if (!ptr) return _aligned_malloc(size, alignment);

            // gets the header from the exising pointer
            AlignInfo* head = AlignInfo(ptr);

            // gets a new aligned pointer
            void* alignedPtr = _aligned_malloc(size, alignment);
            if (!alignedPtr)
            {
                //to https://msdn.microsoft.com/en-us/library/ms235462.aspx
                //see Return value: in this case the original block is unchanged
                return null;
            }

            // copy exising data
            memcpy(alignedPtr, ptr, head.size);
            free(head.basePtr);

            return alignedPtr;
        }

        @nogc nothrow
        private void _aligned_free(void *ptr)
        {
            import core.stdc.stdlib : free;
            if (!ptr) return;
            AlignInfo* head = AlignInfo(ptr);
            free(head.basePtr);
        }

    }
    // DMD Win 64 bit, uses microsoft standard C library which implements them
    else
    {
        @nogc nothrow private extern(C) void* _aligned_malloc(size_t, size_t);
        @nogc nothrow private extern(C) void _aligned_free(void *memblock);
        @nogc nothrow private extern(C) void* _aligned_realloc(void *, size_t, size_t);
    }
}

/**
   Aligned allocator using OS-specific primitives, under a uniform API.
 */
struct AlignedMallocator
{
    version (StdUnittest) @system unittest { testAllocator!(() => typeof(this).instance); }

    /**
    The default alignment is `platformAlignment`.
    */
    enum uint alignment = platformAlignment;

    /**
    Forwards to $(D alignedAllocate(bytes, platformAlignment)).
    */
    @trusted @nogc nothrow
    void[] allocate(size_t bytes) shared
    {
        if (!bytes) return null;
        return alignedAllocate(bytes, alignment);
    }

    /**
    Uses $(HTTP man7.org/linux/man-pages/man3/posix_memalign.3.html,
    `posix_memalign`) on Posix and
    $(HTTP msdn.microsoft.com/en-us/library/8z34s9c6(v=vs.80).aspx,
    `__aligned_malloc`) on Windows.
    */
    version (Posix)
    @trusted @nogc nothrow
    void[] alignedAllocate(size_t bytes, uint a) shared
    {
        import core.stdc.errno : ENOMEM, EINVAL;
        import core.sys.posix.stdlib : posix_memalign;
        assert(a.isGoodDynamicAlignment);
        void* result;
        auto code = posix_memalign(&result, a, bytes);

version (OSX)
version (LDC_AddressSanitizer)
{
        // The return value with AddressSanitizer may be -1 instead of ENOMEM
        // or EINVAL. See https://bugs.llvm.org/show_bug.cgi?id=36510
        if (code == -1)
            return null;
}
        if (code == ENOMEM)
            return null;

        else if (code == EINVAL)
        {
            assert(0, "AlignedMallocator.alignment is not a power of two "
                ~"multiple of (void*).sizeof, according to posix_memalign!");
        }
        else if (code != 0)
            assert(0, "posix_memalign returned an unknown code!");

        else
            return result[0 .. bytes];
    }
    else version (Windows)
    @trusted @nogc nothrow
    void[] alignedAllocate(size_t bytes, uint a) shared
    {
        auto result = _aligned_malloc(bytes, a);
        return result ? result[0 .. bytes] : null;
    }
    else static assert(0);

    /**
    Calls `free(b.ptr)` on Posix and
    $(HTTP msdn.microsoft.com/en-US/library/17b5h8td(v=vs.80).aspx,
    `__aligned_free(b.ptr)`) on Windows.
    */
    version (Posix)
    @system @nogc nothrow
    bool deallocate(void[] b) shared
    {
        import core.stdc.stdlib : free;
        free(b.ptr);
        return true;
    }
    else version (Windows)
    @system @nogc nothrow
    bool deallocate(void[] b) shared
    {
        _aligned_free(b.ptr);
        return true;
    }
    else static assert(0);

    /**
    Forwards to $(D alignedReallocate(b, newSize, platformAlignment)).
    Should be used with blocks obtained with `allocate` otherwise the custom
    alignment passed with `alignedAllocate` can be lost.
    */
    @system @nogc nothrow
    bool reallocate(ref void[] b, size_t newSize) shared
    {
        return alignedReallocate(b, newSize, alignment);
    }

    /**
    On Posix there is no `realloc` for aligned memory, so `alignedReallocate` emulates
    the needed behavior by using `alignedAllocate` to get a new block. The existing
    block is copied to the new block and then freed.
    On Windows, calls $(HTTPS msdn.microsoft.com/en-us/library/y69db7sx.aspx,
    $(D __aligned_realloc(b.ptr, newSize, a))).
    */
    version (Windows)
    @system @nogc nothrow
    bool alignedReallocate(ref void[] b, size_t s, uint a) shared
    {
        if (!s)
        {
            deallocate(b);
            b = null;
            return true;
        }
        auto p = cast(ubyte*) _aligned_realloc(b.ptr, s, a);
        if (!p) return false;
        b = p[0 .. s];
        return true;
    }

    /// ditto
    version (Posix)
    @system @nogc nothrow
    bool alignedReallocate(ref void[] b, size_t s, uint a) shared
    {
        if (!s)
        {
            deallocate(b);
            b = null;
            return true;
        }
        auto p = alignedAllocate(s, a);
        if (!p.ptr)
        {
            return false;
        }
        import std.algorithm.comparison : min;
        const upTo = min(s, b.length);
        p[0 .. upTo] = b[0 .. upTo];
        deallocate(b);
        b = p;
        return true;
    }

    /**
    Returns the global instance of this allocator type. The C heap allocator is
    thread-safe, therefore all of its methods and `instance` itself are
    `shared`.
    */
    static shared AlignedMallocator instance;
}

///
@nogc @system nothrow unittest
{
    auto buffer = AlignedMallocator.instance.alignedAllocate(1024 * 1024 * 4,
        128);
    scope(exit) AlignedMallocator.instance.deallocate(buffer);
    //...
}

version (Posix)
@nogc @system nothrow unittest
{
    // https://issues.dlang.org/show_bug.cgi?id=16398
    // test the "pseudo" alignedReallocate for Posix
    void[] b = AlignedMallocator.instance.alignedAllocate(16, 32);
    (cast(ubyte[]) b)[] = ubyte(1);
    AlignedMallocator.instance.alignedReallocate(b, 32, 32);
    ubyte[16] o;
    o[] = 1;
    assert((cast(ubyte[]) b)[0 .. 16] == o);
    AlignedMallocator.instance.alignedReallocate(b, 4, 32);
    assert((cast(ubyte[]) b)[0 .. 3] == o[0 .. 3]);
    AlignedMallocator.instance.alignedReallocate(b, 128, 32);
    assert((cast(ubyte[]) b)[0 .. 3] == o[0 .. 3]);
    AlignedMallocator.instance.deallocate(b);

    void[] c;
    AlignedMallocator.instance.alignedReallocate(c, 32, 32);
    assert(c.ptr);

    version (LDC_AddressSanitizer) {} else // AddressSanitizer does not support such large memory allocations (0x10000000000 max)
    version (DragonFlyBSD) {} else    /* FIXME: Malloc on DragonFly does not return NULL when allocating more than UINTPTR_MAX
                                       * $(LINK: https://bugs.dragonflybsd.org/issues/3114, dragonfly bug report)
                                       * $(LINK: https://github.com/dlang/druntime/pull/1999#discussion_r157536030, PR Discussion) */
    assert(!AlignedMallocator.instance.alignedReallocate(c, size_t.max, 4096));
    AlignedMallocator.instance.deallocate(c);
}

version (CRuntime_DigitalMars)
@nogc @system nothrow unittest
{
    void* m;

    size_t m_addr() { return cast(size_t) m; }

    m = _aligned_malloc(16, 0x10);
    if (m)
    {
        assert((m_addr & 0xF) == 0);
        _aligned_free(m);
    }

    m = _aligned_malloc(16, 0x100);
    if (m)
    {
        assert((m_addr & 0xFF) == 0);
        _aligned_free(m);
    }

    m = _aligned_malloc(16, 0x1000);
    if (m)
    {
        assert((m_addr & 0xFFF) == 0);
        _aligned_free(m);
    }

    m = _aligned_malloc(16, 0x10);
    if (m)
    {
        assert((cast(size_t) m & 0xF) == 0);
        m = _aligned_realloc(m, 32, 0x10000);
        if (m) assert((m_addr & 0xFFFF) == 0);
        _aligned_free(m);
    }

    m = _aligned_malloc(8, 0x10);
    if (m)
    {
        *cast(ulong*) m = 0X01234567_89ABCDEF;
        m = _aligned_realloc(m, 0x800, 0x1000);
        if (m) assert(*cast(ulong*) m == 0X01234567_89ABCDEF);
        _aligned_free(m);
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // Written in the D programming language.
/**
Source: $(PHOBOSSRC std/experimental/allocator/_mmap_allocator.d)
*/
module std.experimental.allocator.mmap_allocator;

/**
Allocator (currently defined only for Posix and Windows) using
$(D $(LINK2 https://en.wikipedia.org/wiki/Mmap, mmap))
and $(D $(LUCKY munmap)) directly (or their Windows equivalents). There is no
additional structure: each call to `allocate(s)` issues a call to
$(D mmap(null, s, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)),
and each call to `deallocate(b)` issues $(D munmap(b.ptr, b.length)).
So `MmapAllocator` is usually intended for allocating large chunks to be
managed by fine-granular allocators.
*/
struct MmapAllocator
{
    /// The one shared instance.
    static shared const MmapAllocator instance;

    /**
    Alignment is page-size and hardcoded to 4096 (even though on certain systems
    it could be larger).
    */
    enum size_t alignment = 4096;

    version (Posix)
    {
        /// Allocator API.
        pure nothrow @nogc @safe
        void[] allocate(size_t bytes) shared const
        {
            import core.sys.posix.sys.mman : MAP_ANON, PROT_READ,
                PROT_WRITE, MAP_PRIVATE, MAP_FAILED;
            if (!bytes) return null;
            const errnosave = (() @trusted => fakePureErrno())(); // For purity revert changes to errno.
            auto p = (() @trusted => fakePureMmap(null, bytes, PROT_READ | PROT_WRITE,
                MAP_PRIVATE | MAP_ANON, -1, 0))();
            if (p is MAP_FAILED)
            {
                (() @trusted => fakePureErrno() = errnosave)(); // errno only changed on MAP_FAILED.
                return null;
            }
            return (() @trusted => p[0 .. bytes])();
        }

        /// Ditto
        pure nothrow @nogc
        bool deallocate(void[] b) shared const
        {
            // Because we assert(0) on error we don't need to reset errno for purity.
            if (b.ptr) fakePureMunmap(b.ptr, b.length) == 0 || assert(0);
            return true;
        }

        // Anonymous mmap might be zero-filled on all Posix systems but
        // not all commit to this in the documentation.
        version (linux)
            // http://man7.org/linux/man-pages/man2/mmap.2.html
            package alias allocateZeroed = allocate;
        else version (NetBSD)
            // http://netbsd.gw.com/cgi-bin/man-cgi?mmap+2+NetBSD-current
            package alias allocateZeroed = allocate;
        else version (Solaris)
            // https://docs.oracle.com/cd/E88353_01/html/E37841/mmap-2.html
            package alias allocateZeroed = allocate;
        else version (AIX)
            // https://www.ibm.com/support/knowledgecenter/en/ssw_aix_71/com.ibm.aix.basetrf1/mmap.htm
            package alias allocateZeroed = allocate;
    }
    else version (Windows)
    {
        import core.sys.windows.winnt : MEM_COMMIT, PAGE_READWRITE, MEM_RELEASE;

        /// Allocator API.
        pure nothrow @nogc @safe
        void[] allocate(size_t bytes) shared const
        {
            if (!bytes) return null;
            // For purity ensure last-error does not visibly change.
            const lastErrorSave = (() @trusted => GetLastError())();
            auto p = (() @trusted => VirtualAlloc(null, bytes, MEM_COMMIT, PAGE_READWRITE))();
            if (p == null)
            {
                // Last-error only changed if allocation failed.
                (() @trusted => SetLastError(lastErrorSave))();
                return null;
            }
            return (() @trusted => p[0 .. bytes])();
        }

        /// Ditto
        pure nothrow @nogc
        bool deallocate(void[] b) shared const
        {
            const lastErrorSave = GetLastError(); // For purity ensure last-error does not visibly change.
            scope(exit) SetLastError(lastErrorSave);
            return b.ptr is null || VirtualFree(b.ptr, 0, MEM_RELEASE) != 0;
        }

        package alias allocateZeroed = allocate;
    }
}

// pure wrappers around `mmap` and `munmap` because they are used here locally
// solely to perform allocation and deallocation which in this case is `pure`
version (Posix)
extern (C) private pure @system @nogc nothrow
{
    import core.sys.posix.sys.types : off_t;
    pragma(mangle, "fakePureErrnoImpl") ref int fakePureErrno();
    pragma(mangle, "mmap") void* fakePureMmap(void*, size_t, int, int, int, off_t);
    pragma(mangle, "munmap") int fakePureMunmap(void*, size_t);
}

// Pure wrappers around VirtualAlloc/VirtualFree for use here only. Their use is sound
// because when we call them we ensure that last-error is not visibly changed.
version (Windows)
extern (Windows) private pure @system @nogc nothrow
{
    import core.sys.windows.basetsd : SIZE_T;
    import core.sys.windows.windef : BOOL, DWORD;
    import core.sys.windows.winnt : LPVOID, PVOID;

    DWORD GetLastError();
    void SetLastError(DWORD);
    PVOID VirtualAlloc(PVOID, SIZE_T, DWORD, DWORD);
    BOOL VirtualFree(PVOID, SIZE_T, DWORD);
}

pure nothrow @safe @nogc unittest
{
    alias alloc = MmapAllocator.instance;
    auto p = alloc.allocate(100);
    assert(p.length == 100);
    () @trusted { alloc.deallocate(p); p = null; }();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // Written in the D programming language.
/**

High-level interface for allocators. Implements bundled allocation/creation
and destruction/deallocation of data including `struct`s and `class`es,
and also array primitives related to allocation. This module is the entry point
for both making use of allocators and for their documentation.

$(SCRIPT inhibitQuickIndex = 1;)
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD Make) $(TD
    $(LREF make)
    $(LREF makeArray)
    $(LREF makeMultidimensionalArray)
))
$(TR $(TD Dispose) $(TD
    $(LREF dispose)
    $(LREF disposeMultidimensionalArray)
))
$(TR $(TD Modify) $(TD
    $(LREF expandArray)
    $(LREF shrinkArray)
))
$(TR $(TD Global) $(TD
    $(LREF processAllocator)
    $(LREF theAllocator)
))
$(TR $(TD Class interface) $(TD
    $(LREF CAllocatorImpl)
    $(LREF CSharedAllocatorImpl)
    $(LREF IAllocator)
    $(LREF ISharedAllocator)
))
$(TR $(TD Structs) $(TD
    $(LREF allocatorObject)
    $(LREF RCIAllocator)
    $(LREF RCISharedAllocator)
    $(LREF sharedAllocatorObject)
    $(LREF ThreadLocal)
))
)

Synopsis:
$(RUNNABLE_EXAMPLE
---
// Allocate an int, initialize it with 42
int* p = theAllocator.make!int(42);
assert(*p == 42);
// Destroy and deallocate it
theAllocator.dispose(p);

// Allocate using the global process allocator
p = processAllocator.make!int(100);
assert(*p == 100);
// Destroy and deallocate
processAllocator.dispose(p);
---
)
$(RUNNABLE_EXAMPLE
---
// Create an array of 50 doubles initialized to -1.0
double[] arr = theAllocator.makeArray!double(50, -1.0);
// Append two zeros to it
theAllocator.expandArray(arr, 2, 0.0);
// On second thought, take that back
theAllocator.shrinkArray(arr, 2);
// Destroy and deallocate
theAllocator.dispose(arr);
---
)

$(H2 Layered Structure)

D's allocators have a layered structure in both implementation and documentation:

$(OL
$(LI A high-level, dynamically-typed layer (described further down in this
module). It consists of an interface called $(LREF IAllocator), which concrete
allocators need to implement. The interface primitives themselves are oblivious
to the type of the objects being allocated; they only deal in `void[]`, by
necessity of the interface being dynamic (as opposed to type-parameterized).
Each thread has a current allocator it uses by default, which is a thread-local
variable $(LREF theAllocator) of type $(LREF IAllocator). The process has a
global allocator called $(LREF processAllocator), also of type $(LREF
IAllocator). When a new thread is created, $(LREF processAllocator) is copied
into $(LREF theAllocator). An application can change the objects to which these
references point. By default, at application startup, $(LREF processAllocator)
refers to an object that uses D's garbage collected heap. This layer also
include high-level functions such as $(LREF make) and $(LREF dispose) that
comfortably allocate/create and respectively destroy/deallocate objects. This
layer is all needed for most casual uses of allocation primitives.)

$(LI A mid-level, statically-typed layer for assembling several allocators into
one. It uses properties of the type of the objects being created to route
allocation requests to possibly specialized allocators. This layer is relatively
thin and implemented and documented in the $(MREF
std,experimental,allocator,typed) module. It allows an interested user to e.g.
use different allocators for arrays versus fixed-sized objects, to the end of
better overall performance.)

$(LI A low-level collection of highly generic $(I heap building blocks)$(MDASH)
Lego-like pieces that can be used to assemble application-specific allocators.
The real allocation smarts are occurring at this level. This layer is of
interest to advanced applications that want to configure their own allocators.
A good illustration of typical uses of these building blocks is module $(MREF
std,experimental,allocator,showcase) which defines a collection of frequently-
used preassembled allocator objects. The implementation and documentation entry
point is $(MREF std,experimental,allocator,building_blocks). By design, the
primitives of the static interface have the same signatures as the $(LREF
IAllocator) primitives but are for the most part optional and driven by static
introspection. The parameterized class $(LREF CAllocatorImpl) offers an
immediate and useful means to package a static low-level allocator into an
implementation of $(LREF IAllocator).)

$(LI Core allocator objects that interface with D's garbage collected heap
($(MREF std,experimental,allocator,gc_allocator)), the C `malloc` family
($(MREF std,experimental,allocator,mallocator)), and the OS ($(MREF
std,experimental,allocator,mmap_allocator)). Most custom allocators would
ultimately obtain memory from one of these core allocators.)
)

$(H2 Idiomatic Use of `std.experimental.allocator`)

As of this time, `std.experimental.allocator` is not integrated with D's
built-in operators that allocate memory, such as `new`, array literals, or
array concatenation operators. That means `std.experimental.allocator` is
opt-in$(MDASH)applications need to make explicit use of it.

For casual creation and disposal of dynamically-allocated objects, use $(LREF
make), $(LREF dispose), and the array-specific functions $(LREF makeArray),
$(LREF expandArray), and $(LREF shrinkArray). These use by default D's garbage
collected heap, but open the application to better configuration options. These
primitives work either with `theAllocator` but also with any allocator obtained
by combining heap building blocks. For example:

----
void fun(size_t n)
{
    // Use the current allocator
    int[] a1 = theAllocator.makeArray!int(n);
    scope(exit) theAllocator.dispose(a1);
    ...
}
----

To experiment with alternative allocators, set $(LREF theAllocator) for the
current thread. For example, consider an application that allocates many 8-byte
objects. These are not well supported by the default allocator, so a
$(MREF_ALTTEXT free list allocator,
std,experimental,allocator,building_blocks,free_list) would be recommended.
To install one in `main`, the application would use:

----
void main()
{
    import std.experimental.allocator.building_blocks.free_list
        : FreeList;
    theAllocator = allocatorObject(FreeList!8());
    ...
}
----

$(H3 Saving the `IAllocator` Reference For Later Use)

As with any global resource, setting `theAllocator` and `processAllocator`
should not be done often and casually. In particular, allocating memory with
one allocator and deallocating with another causes undefined behavior.
Typically, these variables are set during application initialization phase and
last through the application.

To avoid this, long-lived objects that need to perform allocations,
reallocations, and deallocations relatively often may want to store a reference
to the allocator object they use throughout their lifetime. Then, instead of
using `theAllocator` for internal allocation-related tasks, they'd use the
internally held reference. For example, consider a user-defined hash table:

----
struct HashTable
{
    private IAllocator allocator;
    this(size_t buckets, IAllocator allocator = theAllocator) {
        this.allocator = allocator;
        ...
    }
    // Getter and setter
    IAllocator allocator() { return allocator; }
    void allocator(IAllocator a) { assert(empty); allocator = a; }
}
----

Following initialization, the `HashTable` object would consistently use its
`allocator` object for acquiring memory. Furthermore, setting
`HashTable.allocator` to point to a different allocator should be legal but
only if the object is empty; otherwise, the object wouldn't be able to
deallocate its existing state.

$(H3 Using Allocators without `IAllocator`)

Allocators assembled from the heap building blocks don't need to go through
`IAllocator` to be usable. They have the same primitives as `IAllocator` and
they work with $(LREF make), $(LREF makeArray), $(LREF dispose) etc. So it
suffice to create allocator objects wherever fit and use them appropriately:

----
void fun(size_t n)
{
    // Use a stack-installed allocator for up to 64KB
    StackFront!65536 myAllocator;
    int[] a2 = myAllocator.makeArray!int(n);
    scope(exit) myAllocator.dispose(a2);
    ...
}
----

In this case, `myAllocator` does not obey the `IAllocator` interface, but
implements its primitives so it can work with `makeArray` by means of duck
typing.

One important thing to note about this setup is that statically-typed assembled
allocators are almost always faster than allocators that go through
`IAllocator`. An important rule of thumb is: "assemble allocator first, adapt
to `IAllocator` after". A good allocator implements intricate logic by means of
template assembly, and gets wrapped with `IAllocator` (usually by means of
$(LREF allocatorObject)) only once, at client level.

Copyright: Andrei Alexandrescu 2013-.

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: $(HTTP erdani.com, Andrei Alexandrescu)

Source: $(PHOBOSSRC std/experimental/allocator)

*/

module std.experimental.allocator;

public import std.experimental.allocator.common,
    std.experimental.allocator.typed;

// Fix https://issues.dlang.org/show_bug.cgi?id=17806
// this should always be the first unittest in this module in order to ensure
// that we use the `processAllocator` setter before the getter
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    auto newAlloc = sharedAllocatorObject(Mallocator.instance);
    processAllocator = newAlloc;
    assert(processAllocator is newAlloc);
    processAllocator = sharedAllocatorObject(GCAllocator.instance);
}

// Example in the synopsis above
@system unittest
{
    import std.algorithm.comparison : min, max;
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.building_blocks.bitmapped_block
        : BitmappedBlock;
    import std.experimental.allocator.building_blocks.bucketizer : Bucketizer;
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.building_blocks.segregator : Segregator;
    import std.experimental.allocator.gc_allocator : GCAllocator;

    alias FList = FreeList!(GCAllocator, 0, unbounded);
    alias A = Segregator!(
        8, FreeList!(GCAllocator, 0, 8),
        128, Bucketizer!(FList, 1, 128, 16),
        256, Bucketizer!(FList, 129, 256, 32),
        512, Bucketizer!(FList, 257, 512, 64),
        1024, Bucketizer!(FList, 513, 1024, 128),
        2048, Bucketizer!(FList, 1025, 2048, 256),
        3584, Bucketizer!(FList, 2049, 3584, 512),
        4072 * 1024, AllocatorList!(
            (n) => BitmappedBlock!(4096)(
                    cast(ubyte[])(GCAllocator.instance.allocate(
                        max(n, 4072 * 1024))))),
        GCAllocator
    );
    A tuMalloc;
    auto b = tuMalloc.allocate(500);
    assert(b.length == 500);
    auto c = tuMalloc.allocate(113);
    assert(c.length == 113);
    assert(tuMalloc.expand(c, 14));
    tuMalloc.deallocate(b);
    tuMalloc.deallocate(c);
}

import std.range.primitives;
import std.traits;
import std.typecons;

/**
Dynamic allocator interface. Code that defines allocators ultimately implements
this interface. This should be used wherever a uniform type is required for
encapsulating various allocator implementations.

Composition of allocators is not recommended at this level due to
inflexibility of dynamic interfaces and inefficiencies caused by cascaded
multiple calls. Instead, compose allocators using the static interface defined
in $(MREF std,experimental,allocator,building_blocks),
then adapt the composed
allocator to `IAllocator` (possibly by using $(LREF CAllocatorImpl) below).

Methods returning `Ternary` return `Ternary.yes` upon success,
`Ternary.no` upon failure, and `Ternary.unknown` if the primitive is not
implemented by the allocator instance.
*/
interface IAllocator
{
nothrow:
    /**
    Returns the alignment offered.
    */
    @property uint alignment();

    /**
    Returns the good allocation size that guarantees zero internal
    fragmentation.
    */
    size_t goodAllocSize(size_t s);

    /**
    Allocates `n` bytes of memory.
    */
    void[] allocate(size_t, TypeInfo ti = null);

    /**
    Allocates `n` bytes of memory with specified alignment `a`. Implementations
    that do not support this primitive should always return `null`.
    */
    void[] alignedAllocate(size_t n, uint a);

    /**
    Allocates and returns all memory available to this allocator.
    Implementations that do not support this primitive should always return
    `null`.
    */
    void[] allocateAll();

    /**
    Expands a memory block in place and returns `true` if successful.
    Implementations that don't support this primitive should always return
    `false`.
    */
    bool expand(ref void[], size_t);

    /// Reallocates a memory block.
    bool reallocate(ref void[], size_t);

    /// Reallocates a memory block with specified alignment.
    bool alignedReallocate(ref void[] b, size_t size, uint alignment);

    /**
    Returns `Ternary.yes` if the allocator owns `b`, `Ternary.no` if
    the allocator doesn't own `b`, and `Ternary.unknown` if ownership
    cannot be determined. Implementations that don't support this primitive
    should always return `Ternary.unknown`.
    */
    Ternary owns(void[] b);

    /**
    Resolves an internal pointer to the full block allocated. Implementations
    that don't support this primitive should always return `Ternary.unknown`.
    */
    Ternary resolveInternalPointer(const void* p, ref void[] result);

    /**
    Deallocates a memory block. Implementations that don't support this
    primitive should always return `false`. A simple way to check that an
    allocator supports deallocation is to call `deallocate(null)`.
    */
    bool deallocate(void[] b);

    /**
    Deallocates all memory. Implementations that don't support this primitive
    should always return `false`.
    */
    bool deallocateAll();

    /**
    Returns `Ternary.yes` if no memory is currently allocated from this
    allocator, `Ternary.no` if some allocations are currently active, or
    `Ternary.unknown` if not supported.
    */
    Ternary empty();

    /**
    Increases the reference count of the concrete class that implements this
    interface.

    For stateless allocators, this does nothing.
    */
    @safe @nogc pure
    void incRef();

    /**
    Decreases the reference count of the concrete class that implements this
    interface.
    When the reference count is `0`, the object self-destructs.

    Returns: `true` if the reference count is greater than `0` and `false` when
    it hits `0`. For stateless allocators, it always returns `true`.
    */
    @safe @nogc pure
    bool decRef();
}

/**
A reference counted struct that wraps the dynamic allocator interface.
This should be used wherever a uniform type is required for encapsulating
various allocator implementations.

Code that defines allocators ultimately implements the $(LREF IAllocator)
interface, possibly by using $(LREF CAllocatorImpl) below, and then build a
`RCIAllocator` out of this.

Composition of allocators is not recommended at this level due to
inflexibility of dynamic interfaces and inefficiencies caused by cascaded
multiple calls. Instead, compose allocators using the static interface defined
in $(A std_experimental_allocator_building_blocks.html,
`std.experimental.allocator.building_blocks`), then adapt the composed
allocator to `RCIAllocator` (possibly by using $(LREF allocatorObject) below).
*/
struct RCIAllocator
{
    private IAllocator _alloc;

nothrow:
    private @nogc pure @safe
    this(this _)(IAllocator alloc)
    {
        assert(alloc);
        _alloc = alloc;
    }

    @nogc pure @safe
    this(this)
    {
        if (_alloc !is null)
        {
            _alloc.incRef();
        }
    }

    @nogc pure @safe
    ~this()
    {
        if (_alloc !is null)
        {
            bool isLast = !_alloc.decRef();
            if (isLast) _alloc = null;
        }
    }

    @nogc pure @safe
    auto ref opAssign()(typeof(this) rhs)
    {
        if (_alloc is rhs._alloc)
        {
            return this;
        }
        // incRef was allready called by rhs posblit, so we're just moving
        // calling dtor is the equivalent of decRef
        __dtor();
        _alloc = rhs._alloc;
        // move
        rhs._alloc = null;
        return this;
    }

    @nogc pure @safe
    bool isNull(this _)()
    {
        return _alloc is null;
    }

    @property uint alignment()
    {
        assert(_alloc);
        return _alloc.alignment();
    }

    size_t goodAllocSize(size_t s)
    {
        assert(_alloc);
        return _alloc.goodAllocSize(s);
    }

    void[] allocate(size_t n, TypeInfo ti = null)
    {
        assert(_alloc);
        return _alloc.allocate(n, ti);
    }

    void[] alignedAllocate(size_t n, uint a)
    {
        assert(_alloc);
        return _alloc.alignedAllocate(n, a);
    }

    void[] allocateAll()
    {
        assert(_alloc);
        return _alloc.allocateAll();
    }

    bool expand(ref void[] b, size_t size)
    {
        assert(_alloc);
        return _alloc.expand(b, size);
    }

    bool reallocate(ref void[] b, size_t size)
    {
        assert(_alloc);
        return _alloc.reallocate(b, size);
    }

    bool alignedReallocate(ref void[] b, size_t size, uint alignment)
    {
        assert(_alloc);
        return _alloc.alignedReallocate(b, size, alignment);
    }

    Ternary owns(void[] b)
    {
        assert(_alloc);
        return _alloc.owns(b);
    }

    Ternary resolveInternalPointer(const void* p, ref void[] result)
    {
        assert(_alloc);
        return _alloc.resolveInternalPointer(p, result);
    }

    bool deallocate(void[] b)
    {
        assert(_alloc);
        return _alloc.deallocate(b);
    }

    bool deallocateAll()
    {
        assert(_alloc);
        return _alloc.deallocateAll();
    }

    Ternary empty()
    {
        assert(_alloc);
        return _alloc.empty();
    }
}

@system unittest
{
    import std.experimental.allocator.building_blocks.region : BorrowedRegion;
    import std.conv : emplace;

    auto reg = BorrowedRegion!()(new ubyte[1024]);
    auto state = reg.allocate(stateSize!(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect)));
    auto regObj = emplace!(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(state, &reg);

    auto rcalloc = RCIAllocator(regObj);
    auto b = rcalloc.allocate(10);
    assert(b.length == 10);

    // The reference counting is zero based
    assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 1);
    {
        auto rca2 = rcalloc;
        assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 2);
    }
    assert((cast(CAllocatorImpl!(BorrowedRegion!(), Yes.indirect))(rcalloc._alloc)).rc == 1);
}

@system unittest
{
    import std.conv;
    import std.experimental.allocator.mallocator;
    import std.experimental.allocator.building_blocks.stats_collector;

    alias SCAlloc = StatsCollector!(Mallocator, Options.bytesUsed);
    SCAlloc statsCollectorAlloc;

    ulong bytesUsed = statsCollectorAlloc.bytesUsed;
    assert(bytesUsed == 0);

    {
        auto _allocator = allocatorObject(&statsCollectorAlloc);
        bytesUsed = statsCollectorAlloc.bytesUsed;
        assert(bytesUsed == stateSize!(CAllocatorImpl!(SCAlloc, Yes.indirect)));
    }

    bytesUsed = statsCollectorAlloc.bytesUsed;
    assert(bytesUsed == 0, "RCIAllocator leaks memory; leaked "
            ~ to!string(bytesUsed) ~ " bytes");
}

@system unittest
{
    import std.conv;
    import std.experimental.allocator.mallocator;
    import std.experimental.allocator.building_blocks.stats_collector;

    alias SCAlloc = StatsCollector!(Mallocator, Options.bytesUsed);
    SCAlloc statsCollectorAlloc;

    ulong bytesUsed = statsCollectorAlloc.bytesUsed;
    assert(bytesUsed == 0);

    {
        auto _allocator = allocatorObject(statsCollectorAlloc);

        // Ensure that the allocator was passed through in CAllocatorImpl
        // This allocator was used to allocate the chunk that holds the
        // CAllocatorImpl object; which is it's own wrapper
        bytesUsed = (cast(CAllocatorImpl!(SCAlloc))(_allocator._alloc)).impl.bytesUsed;
        assert(bytesUsed == stateSize!(CAllocatorImpl!(SCAlloc)),
               "RCIAllocator leaks memory; leaked " ~ to!string(bytesUsed) ~ " bytes");
        _allocator.allocate(1);
        bytesUsed = (cast(CAllocatorImpl!(SCAlloc))(_allocator._alloc)).impl.bytesUsed;
        assert(bytesUsed == stateSize!(CAllocatorImpl!(SCAlloc)) + 1,
               "RCIAllocator leaks memory; leaked " ~ to!string(bytesUsed) ~ " bytes");
    }

    bytesUsed = statsCollectorAlloc.bytesUsed;
    assert(bytesUsed == stateSize!(CAllocatorImpl!(SCAlloc)),
            "RCIAllocator leaks memory; leaked "
            ~ to!string(bytesUsed) ~ " bytes");
}

/**
Dynamic shared allocator interface. Code that defines allocators shareable
across threads ultimately implements this interface. This should be used
wherever a uniform type is required for encapsulating various allocator
implementations.

Composition of allocators is not recommended at this level due to
inflexibility of dynamic interfaces and inefficiencies caused by cascaded
multiple calls. Instead, compose allocators using the static interface defined
in $(MREF std,experimental,allocator,building_blocks),
then adapt the composed
allocator to `ISharedAllocator` (possibly by using $(LREF CSharedAllocatorImpl) below).

Methods returning `Ternary` return `Ternary.yes` upon success,
`Ternary.no` upon failure, and `Ternary.unknown` if the primitive is not
implemented by the allocator instance.
*/
interface ISharedAllocator
{
nothrow:
    /**
    Returns the alignment offered.
    */
    @property uint alignment() shared;

    /**
    Returns the good allocation size that guarantees zero internal
    fragmentation.
    */
    size_t goodAllocSize(size_t s) shared;

    /**
    Allocates `n` bytes of memory.
    */
    void[] allocate(size_t, TypeInfo ti = null) shared;

    /**
    Allocates `n` bytes of memory with specified alignment `a`. Implementations
    that do not support this primitive should always return `null`.
    */
    void[] alignedAllocate(size_t n, uint a) shared;

    /**
    Allocates and returns all memory available to this allocator.
    Implementations that do not support this primitive should always return
    `null`.
    */
    void[] allocateAll() shared;

    /**
    Expands a memory block in place and returns `true` if successful.
    Implementations that don't support this primitive should always return
    `false`.
    */
    bool expand(ref void[], size_t) shared;

    /// Reallocates a memory block.
    bool reallocate(ref void[], size_t) shared;

    /// Reallocates a memory block with specified alignment.
    bool alignedReallocate(ref void[] b, size_t size, uint alignment) shared;

    /**
    Returns `Ternary.yes` if the allocator owns `b`, `Ternary.no` if
    the allocator doesn't own `b`, and `Ternary.unknown` if ownership
    cannot be determined. Implementations that don't support this primitive
    should always return `Ternary.unknown`.
    */
    Ternary owns(void[] b) shared;

    /**
    Resolves an internal pointer to the full block allocated. Implementations
    that don't support this primitive should always return `Ternary.unknown`.
    */
    Ternary resolveInternalPointer(const void* p, ref void[] result) shared;

    /**
    Deallocates a memory block. Implementations that don't support this
    primitive should always return `false`. A simple way to check that an
    allocator supports deallocation is to call `deallocate(null)`.
    */
    bool deallocate(void[] b) shared;

    /**
    Deallocates all memory. Implementations that don't support this primitive
    should always return `false`.
    */
    bool deallocateAll() shared;

    /**
    Returns `Ternary.yes` if no memory is currently allocated from this
    allocator, `Ternary.no` if some allocations are currently active, or
    `Ternary.unknown` if not supported.
    */
    Ternary empty() shared;

    /**
    Increases the reference count of the concrete class that implements this
    interface.

    For stateless allocators, this does nothing.
    */
    @safe @nogc pure
    void incRef() shared;

    /**
    Decreases the reference count of the concrete class that implements this
    interface.
    When the reference count is `0`, the object self-destructs.

    For stateless allocators, this does nothing.

    Returns: `true` if the reference count is greater than `0` and `false` when
    it hits `0`. For stateless allocators, it always returns `true`.
    */
    @safe @nogc pure
    bool decRef() shared;
}

/**
A reference counted struct that wraps the dynamic shared allocator interface.
This should be used wherever a uniform type is required for encapsulating
various allocator implementations.

Code that defines allocators shareable across threads ultimately implements the
$(LREF ISharedAllocator) interface, possibly by using
$(LREF CSharedAllocatorImpl) below, and then build a `RCISharedAllocator` out
of this.

Composition of allocators is not recommended at this level due to
inflexibility of dynamic interfaces and inefficiencies caused by cascaded
multiple calls. Instead, compose allocators using the static interface defined
in $(A std_experimental_allocator_building_blocks.html,
`std.experimental.allocator.building_blocks`), then adapt the composed allocator
to `RCISharedAllocator` (possibly by using $(LREF sharedAllocatorObject) below).
*/
shared struct RCISharedAllocator
{
    private ISharedAllocator _alloc;

nothrow:
    private @nogc pure @safe
    this(shared ISharedAllocator alloc)
    {
        assert(alloc);
        _alloc = alloc;
    }

    @nogc pure @safe
    this(this)
    {
        if (_alloc !is null)
        {
            _alloc.incRef();
        }
    }

    @nogc pure @safe
    ~this()
    {
        if (_alloc !is null)
        {
            bool isLast = !_alloc.decRef();
            if (isLast) _alloc = null;
        }
    }

    @nogc pure @safe
    auto ref opAssign()(RCISharedAllocator rhs)
    {
        if (_alloc is rhs._alloc)
        {
            return this;
        }
        // incRef was allready called by rhs posblit, so we're just moving
        if (_alloc !is null)
        {
            _alloc.decRef();
        }
        _alloc = rhs._alloc;
        // move
        rhs._alloc = null;
        return this;
    }

    @nogc pure @safe
    bool isNull(this _)()
    {
        return _alloc is null;
    }

    @property uint alignment()
    {
        assert(_alloc);
        return _alloc.alignment();
    }

    size_t goodAllocSize(size_t s)
    {
        assert(_alloc);
        return _alloc.goodAllocSize(s);
    }

    void[] allocate(size_t n, TypeInfo ti = null)
    {
        assert(_alloc);
        return _alloc.allocate(n, ti);
    }

    void[] alignedAllocate(size_t n, uint a)
    {
        assert(_alloc);
        return _alloc.alignedAllocate(n, a);
    }

    void[] allocateAll()
    {
        assert(_alloc);
        return _alloc.allocateAll();
    }

    bool expand(ref void[] b, size_t size)
    {
        assert(_alloc);
        return _alloc.expand(b, size);
    }

    bool reallocate(ref void[] b, size_t size)
    {
        assert(_alloc);
        return _alloc.reallocate(b, size);
    }

    bool alignedReallocate(ref void[] b, size_t size, uint alignment)
    {
        assert(_alloc);
        return _alloc.alignedReallocate(b, size, alignment);
    }

    Ternary owns(void[] b)
    {
        assert(_alloc);
        return _alloc.owns(b);
    }

    Ternary resolveInternalPointer(const void* p, ref void[] result)
    {
        assert(_alloc);
        return _alloc.resolveInternalPointer(p, result);
    }

    bool deallocate(void[] b)
    {
        assert(_alloc);
        return _alloc.deallocate(b);
    }

    bool deallocateAll()
    {
        assert(_alloc);
        return _alloc.deallocateAll();
    }

    Ternary empty()
    {
        assert(_alloc);
        return _alloc.empty();
    }
}

private RCISharedAllocator _processAllocator;
private RCIAllocator _threadAllocator;

@nogc nothrow @safe
private ref RCIAllocator setupThreadAllocator()
{
    /*
    Forwards the `_threadAllocator` calls to the `processAllocator`
    */
    static class ThreadAllocator : IAllocator
    {
    nothrow:
        private RCISharedAllocator _allocator;

        @nogc @safe
        this(ref RCISharedAllocator procAlloc)
        {
            _allocator = procAlloc;
        }

        override @property uint alignment()
        {
            return _allocator.alignment();
        }

        override size_t goodAllocSize(size_t s)
        {
            return _allocator.goodAllocSize(s);
        }

        override void[] allocate(size_t n, TypeInfo ti = null)
        {
            return _allocator.allocate(n, ti);
        }

        override void[] alignedAllocate(size_t n, uint a)
        {
            return _allocator.alignedAllocate(n, a);
        }

        override void[] allocateAll()
        {
            return _allocator.allocateAll();
        }

        override bool expand(ref void[] b, size_t size)
        {
            return _allocator.expand(b, size);
        }

        override bool reallocate(ref void[] b, size_t size)
        {
            return _allocator.reallocate(b, size);
        }

        override bool alignedReallocate(ref void[] b, size_t size, uint alignment)
        {
            return _allocator.alignedReallocate(b, size, alignment);
        }

        override Ternary owns(void[] b)
        {
            return _allocator.owns(b);
        }

        override Ternary resolveInternalPointer(const void* p, ref void[] result)
        {
            return _allocator.resolveInternalPointer(p, result);
        }

        override bool deallocate(void[] b)
        {
            return _allocator.deallocate(b);
        }

        override bool deallocateAll()
        {
            return _allocator.deallocateAll();
        }

        override Ternary empty()
        {
            return _allocator.empty();
        }

        @nogc pure @safe
        override void incRef()
        {
            _allocator._alloc.incRef();
        }

        @nogc pure @safe
        override bool decRef()
        {
            return _allocator._alloc.decRef();
        }
    }

    assert(_threadAllocator.isNull);
    import core.lifetime : emplace;
    static ulong[stateSize!(ThreadAllocator).divideRoundUp(ulong.sizeof)] _threadAllocatorState;
    () @trusted {
        _threadAllocator = RCIAllocator(emplace!(ThreadAllocator)(_threadAllocatorState[], processAllocator()));
    }();
    return _threadAllocator;
}

// Fix threadAllocator bug: the threadAllocator should hold an internal reference
// to the processAllocator that it's using
@system unittest
{
    import std.experimental.allocator.mallocator : Mallocator;

    auto a = sharedAllocatorObject(Mallocator.instance);
    auto buf = theAllocator.allocate(42);
    processAllocator = a;
    theAllocator.deallocate(buf);
}

/**
Gets/sets the allocator for the current thread. This is the default allocator
that should be used for allocating thread-local memory. For allocating memory
to be shared across threads, use `processAllocator` (below). By default,
`theAllocator` ultimately fetches memory from `processAllocator`, which
in turn uses the garbage collected heap.
*/
@nogc nothrow @safe
@property ref RCIAllocator theAllocator()
{
    alias p = _threadAllocator;
    return !p.isNull() ? p : setupThreadAllocator();
}

/// Ditto
nothrow @system @nogc
@property void theAllocator(RCIAllocator a)
{
    assert(!a.isNull);
    _threadAllocator = a;
}

///
@system unittest
{
    // Install a new allocator that is faster for 128-byte allocations.
    import std.experimental.allocator.building_blocks.free_list : FreeList;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    auto oldAllocator = theAllocator;
    scope(exit) theAllocator = oldAllocator;
    theAllocator = allocatorObject(FreeList!(GCAllocator, 128)());
    // Use the now changed allocator to allocate an array
    const ubyte[] arr = theAllocator.makeArray!ubyte(128);
    assert(arr.ptr);
    //...
}

/**
Gets/sets the allocator for the current process. This allocator must be used
for allocating memory shared across threads. Objects created using this
allocator can be cast to `shared`.
*/
@nogc nothrow @trusted
@property ref RCISharedAllocator processAllocator()
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.concurrency : initOnce;

    static RCISharedAllocator* forceAttributes()
    {
        return &initOnce!_processAllocator(
                sharedAllocatorObject(GCAllocator.instance));
    }

    return *(cast(RCISharedAllocator* function() @nogc nothrow)(&forceAttributes))();
}

/// Ditto
@nogc nothrow @system
@property void processAllocator(ref RCISharedAllocator a)
{
    assert(!a.isNull);
    processAllocator() = a;
}

@system unittest
{
    import core.exception : AssertError;
    import std.exception : assertThrown;
    import std.experimental.allocator.building_blocks.free_list : SharedFreeList;
    import std.experimental.allocator.mallocator : Mallocator;

    assert(!processAllocator.isNull);
    assert(!theAllocator.isNull);

    testAllocatorObject(processAllocator);
    testAllocatorObject(theAllocator);

    shared SharedFreeList!(Mallocator, chooseAtRuntime, chooseAtRuntime) sharedFL;
    RCISharedAllocator sharedFLObj = sharedAllocatorObject(sharedFL);
    alias SharedAllocT = CSharedAllocatorImpl!(
            shared SharedFreeList!(
                Mallocator, chooseAtRuntime, chooseAtRuntime));

    assert((cast(SharedAllocT)(sharedFLObj._alloc)).rc == 1);
    assert(!sharedFLObj.isNull);
    testAllocatorObject(sharedFLObj);

    // Test processAllocator setter
    RCISharedAllocator oldProcessAllocator = processAllocator;
    processAllocator = sharedFLObj;
    assert((cast(SharedAllocT)(sharedFLObj._alloc)).rc == 2);
    assert(processAllocator._alloc is sharedFLObj._alloc);

    testAllocatorObject(processAllocator);
    testAllocatorObject(theAllocator);
    assertThrown!AssertError(processAllocator = RCISharedAllocator(null));

    // Restore initial processAllocator state
    processAllocator = oldProcessAllocator;
    assert((cast(SharedAllocT)(sharedFLObj._alloc)).rc == 1);
    assert(processAllocator is oldProcessAllocator);

    RCISharedAllocator indirectShFLObj = sharedAllocatorObject(&sharedFL);
    testAllocatorObject(indirectShFLObj);
    alias IndirectSharedAllocT = CSharedAllocatorImpl!(
            shared SharedFreeList!(
                Mallocator, chooseAtRuntime, chooseAtRuntime)
            , Yes.indirect);

    assert((cast(IndirectSharedAllocT)(indirectShFLObj._alloc)).rc == 1);

    RCIAllocator indirectMallocator = allocatorObject(&Mallocator.instance);
    testAllocatorObject(indirectMallocator);
}

/**
Dynamically allocates (using `alloc`) and then creates in the memory
allocated an object of type `T`, using `args` (if any) for its
initialization. Initialization occurs in the memory allocated and is otherwise
semantically the same as `T(args)`.
(Note that using `alloc.make!(T[])` creates a pointer to an (empty) array
of `T`s, not an array. To use an allocator to allocate and initialize an
array, use `alloc.makeArray!T` described below.)

Params:
T = Type of the object being created.
alloc = The allocator used for getting the needed memory. It may be an object
implementing the static interface for allocators, or an `IAllocator`
reference.
args = Optional arguments used for initializing the created object. If not
present, the object is default constructed.

Returns: If `T` is a class type, returns a reference to the created `T`
object. Otherwise, returns a `T*` pointing to the created object. In all
cases, returns `null` if allocation failed.

Throws: If `T`'s constructor throws, deallocates the allocated memory and
propagates the exception.
*/
auto make(T, Allocator, A...)(auto ref Allocator alloc, auto ref A args)
{
    import std.algorithm.comparison : max;
    static if (!is(T == class) && !is(T == interface) && A.length == 0
        && __traits(compiles, {T t;}) && __traits(isZeroInit, T)
        && is(typeof(alloc.allocateZeroed(size_t.max))))
    {
        auto m = alloc.allocateZeroed(max(T.sizeof, 1));
        return (() @trusted => cast(T*) m.ptr)();
    }
    else
    {
        import core.internal.lifetime : emplaceRef;
        import core.lifetime : emplace;

        auto m = alloc.allocate(max(stateSize!T, 1));
        if (!m.ptr) return null;

        // make can only be @safe if emplace or emplaceRef is `pure`
        auto construct()
        {
            static if (is(T == class)) return emplace!T(m, args);
            else
            {
                // Assume cast is safe as allocation succeeded for `stateSize!T`
                auto p = () @trusted { return cast(T*) m.ptr; }();
                emplaceRef!T(*p, args);
                return p;
            }
        }

        scope(failure)
        {
            static if (is(typeof(() pure { return construct(); })))
            {
                // Assume deallocation is safe because:
                // 1) in case of failure, `m` is the only reference to this memory
                // 2) `m` is known to originate from `alloc`
                () @trusted { alloc.deallocate(m); }();
            }
            else
            {
                alloc.deallocate(m);
            }
        }

        return construct();
    }
}

///
@system unittest
{
    // Dynamically allocate one integer
    const int* p1 = theAllocator.make!int;
    // It's implicitly initialized with its .init value
    assert(*p1 == 0);
    // Dynamically allocate one double, initialize to 42.5
    const double* p2 = theAllocator.make!double(42.5);
    assert(*p2 == 42.5);

    // Dynamically allocate a struct
    static struct Point
    {
        int x, y, z;
    }
    // Use the generated constructor taking field values in order
    const Point* p = theAllocator.make!Point(1, 2);
    assert(p.x == 1 && p.y == 2 && p.z == 0);

    // Dynamically allocate a class object
    static class Customer
    {
        uint id = uint.max;
        this() {}
        this(uint id) { this.id = id; }
        // ...
    }
    Customer cust = theAllocator.make!Customer;
    assert(cust.id == uint.max); // default initialized
    cust = theAllocator.make!Customer(42);
    assert(cust.id == 42);

    // explicit passing of outer pointer
    static class Outer
    {
        int x = 3;
        class Inner
        {
            auto getX() { return x; }
        }
    }
    auto outer = theAllocator.make!Outer();
    auto inner = theAllocator.make!(Outer.Inner)(outer);
    assert(outer.x == inner.getX);
}

// https://issues.dlang.org/show_bug.cgi?id=15639
// https://issues.dlang.org/show_bug.cgi?id=15772
@system unittest
{
    abstract class Foo {}
    class Bar: Foo {}
    static assert(!is(typeof(theAllocator.make!Foo)));
    static assert( is(typeof(theAllocator.make!Bar)));
}

@system unittest
{
    void test(Allocator)(auto ref Allocator alloc)
    {
        const int* a = alloc.make!int(10);
        assert(*a == 10);

        struct A
        {
            int x;
            string y;
            double z;
        }

        A* b = alloc.make!A(42);
        assert(b.x == 42);
        assert(b.y is null);
        import std.math.traits : isNaN;
        assert(b.z.isNaN);

        b = alloc.make!A(43, "44", 45);
        assert(b.x == 43);
        assert(b.y == "44");
        assert(b.z == 45);

        static class B
        {
            int x;
            string y;
            double z;
            this(int _x, string _y = null, double _z = double.init)
            {
                x = _x;
                y = _y;
                z = _z;
            }
        }

        B c = alloc.make!B(42);
        assert(c.x == 42);
        assert(c.y is null);
        assert(c.z.isNaN);

        c = alloc.make!B(43, "44", 45);
        assert(c.x == 43);
        assert(c.y == "44");
        assert(c.z == 45);

        const parray = alloc.make!(int[]);
        assert((*parray).empty);
    }

    import std.experimental.allocator.gc_allocator : GCAllocator;
    test(GCAllocator.instance);
    test(theAllocator);
}

// Attribute propagation
nothrow @safe @nogc unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    alias alloc = Mallocator.instance;

    void test(T, Args...)(auto ref Args args)
    {
        auto k = alloc.make!T(args);
        () @trusted { alloc.dispose(k); }();
    }

    test!int;
    test!(int*);
    test!int(0);
    test!(int*)(null);
}

// should be pure with the GCAllocator
/*pure nothrow*/ @safe unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;

    alias alloc = GCAllocator.instance;

    void test(T, Args...)(auto ref Args args)
    {
        auto k = alloc.make!T(args);
        (a) @trusted { a.dispose(k); }(alloc);
    }

    test!int();
    test!(int*);
    test!int(0);
    test!(int*)(null);
}

// Verify that making an object by calling an impure constructor is not @safe
nothrow @safe @nogc unittest
{
    import std.experimental.allocator.mallocator : Mallocator;
    static struct Pure { this(int) pure nothrow @nogc @safe {} }

    cast(void) Mallocator.instance.make!Pure(0);

    static int g = 0;
    static struct Impure { this(int) nothrow @nogc @safe {
        g++;
    } }
    static assert(!__traits(compiles, cast(void) Mallocator.instance.make!Impure(0)));
}

// test failure with a pure, failing struct
@safe unittest
{
    import std.exception : assertThrown, enforce;

    // this struct can't be initialized
    struct InvalidStruct
    {
        this(int b)
        {
            enforce(1 == 2);
        }
    }
    import std.experimental.allocator.mallocator : Mallocator;
    assertThrown(make!InvalidStruct(Mallocator.instance, 42));
}

// test failure with an impure, failing struct
@system unittest
{
    import std.exception : assertThrown, enforce;
    static int g;
    struct InvalidImpureStruct
    {
        this(int b)
        {
            g++;
            enforce(1 == 2);
        }
    }
    import std.experimental.allocator.mallocator : Mallocator;
    assertThrown(make!InvalidImpureStruct(Mallocator.instance, 42));
}

// Don't allow zero-ctor-args `make` for structs with `@disable this();`
@system unittest
{
    struct NoDefaultCtor
    {
        int i;
        @disable this();
    }
    import std.experimental.allocator.mallocator : Mallocator;
    static assert(!__traits(compiles, make!NoDefaultCtor(Mallocator.instance)),
        "Don't allow zero-ctor-args `make` for structs with `@disable this();`");
}

// https://issues.dlang.org/show_bug.cgi?id=18937
@safe unittest
{
    static struct S
    {
        ubyte[16 * 1024] data;
    }

    static struct SomeAllocator
    {
        ubyte[] allocate(size_t) { return []; }
        void deallocate(void[]) {}
    }

    auto x = SomeAllocator().make!S();
}

private void fillWithMemcpy(T)(scope void[] array, auto ref T filler) nothrow
if (T.sizeof == 1)
{
    import core.stdc.string : memset;
    import std.traits : CopyConstness;
    if (!array.length) return;
    memset(array.ptr, *cast(CopyConstness!(T*, ubyte*)) &filler, array.length);
}

private void fillWithMemcpy(T)(scope void[] array, auto ref T filler) nothrow
if (T.sizeof != 1)
{
    import core.stdc.string : memcpy;
    import std.algorithm.comparison : min;
    if (!array.length) return;
    memcpy(array.ptr, &filler, T.sizeof);
    // Fill the array from the initialized portion of itself exponentially.
    for (size_t offset = T.sizeof; offset < array.length; )
    {
        size_t extent = min(offset, array.length - offset);
        memcpy(array.ptr + offset, array.ptr, extent);
        offset += extent;
    }
}

@system unittest
{
    // Test T.sizeof == 1 path of fillWithMemcpy.
    ubyte[] a;
    fillWithMemcpy(a, ubyte(42));
    assert(a.length == 0);
    a = [ 1, 2, 3, 4, 5 ];
    fillWithMemcpy(a, ubyte(42));
    assert(a == [ 42, 42, 42, 42, 42]);
}

@system unittest
{
    int[] a;
    fillWithMemcpy(a, 42);
    assert(a.length == 0);
    a = [ 1, 2, 3, 4, 5 ];
    fillWithMemcpy(a, 42);
    assert(a == [ 42, 42, 42, 42, 42]);
}

//Make shared object
@system unittest
{
    import core.atomic : atomicLoad;
    auto psi = theAllocator.make!(shared(int))(10);
    assert(10 == (*psi).atomicLoad());
}

private T[] uninitializedFillDefault(T)(T[] array) nothrow
{
    static if (__traits(isZeroInit, T))
    {
        import core.stdc.string : memset;
        if (array !is null)
            memset(array.ptr, 0, T.sizeof * array.length);
        return array;
    }
    else static if (is(immutable T == immutable char) || is(immutable T == immutable wchar))
    {
        import core.stdc.string : memset;
        if (array !is null)
            memset(array.ptr, 0xff, T.sizeof * array.length);
        return array;
    }
    else
    {
        T t = T.init;
        fillWithMemcpy(array, t);
        return array;
    }
}

pure nothrow @nogc
@system unittest
{
    static struct S { int x = 42; @disable this(this); }

    int[5] expected = [42, 42, 42, 42, 42];
    S[5] arr = void;
    uninitializedFillDefault(arr);
    assert((cast(int*) arr.ptr)[0 .. arr.length] == expected);
}

@system unittest
{
    int[] a = [1, 2, 4];
    uninitializedFillDefault(a);
    assert(a == [0, 0, 0]);

    char[] b = [1, 2, 4];
    uninitializedFillDefault(b);
    assert(b == [0xff, 0xff, 0xff]);

    wchar[] c = [1, 2, 4];
    uninitializedFillDefault(c);
    assert(c == [0xffff, 0xffff, 0xffff]);
}

@system unittest
{
    static struct P { float x = 0; float y = 0; }

    static assert(__traits(isZeroInit, P));
    P[] a = [P(10, 11), P(20, 21), P(40, 41)];
    uninitializedFillDefault(a);
    assert(a == [P.init, P.init, P.init]);
}

/**
Create an array of `T` with `length` elements using `alloc`. The array is either default-initialized, filled with copies of `init`, or initialized with values fetched from `range`.

Params:
T = element type of the array being created
alloc = the allocator used for getting memory
length = length of the newly created array
init = element used for filling the array
range = range used for initializing the array elements

Returns:
The newly-created array, or `null` if either `length` was `0` or
allocation failed.

Throws:
The first two overloads throw only if `alloc`'s primitives do. The
overloads that involve copy initialization deallocate memory and propagate the
exception if the copy operation throws.
*/
T[] makeArray(T, Allocator)(auto ref Allocator alloc, size_t length)
{
    if (!length) return null;
    static if (T.sizeof <= 1)
    {
        const nAlloc = length * T.sizeof;
    }
    else
    {
        import core.checkedint : mulu;
        bool overflow;
        const nAlloc = mulu(length, T.sizeof, overflow);
        if (overflow) return null;
    }

    static if (__traits(isZeroInit, T) && hasMember!(Allocator, "allocateZeroed"))
    {
        auto m = alloc.allocateZeroed(nAlloc);
        return (() @trusted => cast(T[]) m)();
    }
    else
    {
        auto m = alloc.allocate(nAlloc);
        if (!m.ptr) return null;
        alias U = Unqual!T;
        return () @trusted { return cast(T[]) uninitializedFillDefault(cast(U[]) m); }();
    }
}

@system unittest
{
    void test1(A)(auto ref A alloc)
    {
        int[] a = alloc.makeArray!int(0);
        assert(a.length == 0 && a.ptr is null);
        a = alloc.makeArray!int(5);
        assert(a.length == 5);
        static immutable cheatsheet = [0, 0, 0, 0, 0];
        assert(a == cheatsheet);
    }

    void test2(A)(auto ref A alloc)
    {
        static struct S { int x = 42; @disable this(this); }
        S[] arr = alloc.makeArray!S(5);
        assert(arr.length == 5);
        int[] arrInt = () @trusted { return (cast(int*) arr.ptr)[0 .. 5]; }();
        static immutable res = [42, 42, 42, 42, 42];
        assert(arrInt == res);
    }

    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    (alloc) /*pure nothrow*/ @safe { test1(alloc); test2(alloc);} (GCAllocator.instance);
    (alloc) nothrow @safe @nogc { test1(alloc); test2(alloc);} (Mallocator.instance);
    test2(theAllocator);
}

@system unittest
{
    import std.algorithm.comparison : equal;
    auto a = theAllocator.makeArray!(shared int)(5);
    static assert(is(typeof(a) == shared(int)[]));
    assert(a.length == 5);
    assert(a.equal([0, 0, 0, 0, 0]));

    auto b = theAllocator.makeArray!(const int)(5);
    static assert(is(typeof(b) == const(int)[]));
    assert(b.length == 5);
    assert(b.equal([0, 0, 0, 0, 0]));

    auto c = theAllocator.makeArray!(immutable int)(5);
    static assert(is(typeof(c) == immutable(int)[]));
    assert(c.length == 5);
    assert(c.equal([0, 0, 0, 0, 0]));
}

// https://issues.dlang.org/show_bug.cgi?id=19085 - makeArray with void
@system unittest
{
    auto b = theAllocator.makeArray!void(5);
    scope(exit) theAllocator.dispose(b);
    auto c = cast(ubyte[]) b;
    assert(c.length == 5);
    assert(c == [0, 0, 0, 0, 0]); // default initialization
}

private enum hasPurePostblit(T) = !hasElaborateCopyConstructor!T ||
    is(typeof(() pure { T.init.__xpostblit(); }));

private enum hasPureDtor(T) = !hasElaborateDestructor!T ||
    is(typeof(() pure { T.init.__xdtor(); }));

// `true` when postblit and destructor of T cannot escape references to itself
private enum canSafelyDeallocPostRewind(T) = hasPurePostblit!T && hasPureDtor!T;

/// Ditto
T[] makeArray(T, Allocator)(auto ref Allocator alloc, size_t length, T init)
{
    if (!length) return null;
    auto m = alloc.allocate(T.sizeof * length);
    if (!m.ptr) return null;
    auto result = () @trusted { return cast(T[]) m; } ();
    import std.traits : hasElaborateCopyConstructor;
    static if (hasElaborateCopyConstructor!T)
    {
        scope(failure)
        {
            static if (canSafelyDeallocPostRewind!T)
                () @trusted { alloc.deallocate(m); } ();
            else
                alloc.deallocate(m);
        }

        size_t i = 0;
        static if (hasElaborateDestructor!T)
        {
            scope (failure)
            {
                foreach (j; 0 .. i)
                {
                    destroy(result[j]);
                }
            }
        }
        import core.lifetime : emplace;
        for (; i < length; ++i)
        {
            emplace!T(&result[i], init);
        }
    }
    else
    {
        alias U = Unqual!T;
        () @trusted { fillWithMemcpy(cast(U[]) result, *(cast(U*) &init)); }();
    }
    return result;
}

///
@system unittest
{
    import std.algorithm.comparison : equal;
    static void test(T)()
    {
        T[] a = theAllocator.makeArray!T(2);
        assert(a.equal([0, 0]));
        a = theAllocator.makeArray!T(3, 42);
        assert(a.equal([42, 42, 42]));
        import std.range : only;
        a = theAllocator.makeArray!T(only(42, 43, 44));
        assert(a.equal([42, 43, 44]));
    }
    test!int();
    test!(shared int)();
    test!(const int)();
    test!(immutable int)();
}

@system unittest
{
    void test(T)(in T initialValue)
    {
        auto t = theAllocator.makeArray!T(100, initialValue);
        //auto t = theAllocator.makeArray(100, initialValue); // works well with the old code
    }

    const int init = 3;
    test(init);
}

@system unittest
{
    void test(A)(auto ref A alloc)
    {
        long[] a = alloc.makeArray!long(0, 42);
        assert(a.length == 0 && a.ptr is null);
        a = alloc.makeArray!long(5, 42);
        assert(a.length == 5);
        assert(a == [ 42, 42, 42, 42, 42 ]);
    }
    import std.experimental.allocator.gc_allocator : GCAllocator;
    (alloc) /*pure nothrow*/ @safe { test(alloc); } (GCAllocator.instance);
    test(theAllocator);
}

// test failure with a pure, failing struct
@safe unittest
{
    import std.exception : assertThrown, enforce;

    struct NoCopy
    {
        @disable this();

        this(int b){}

        // can't be copied
        this(this)
        {
            enforce(1 == 2);
        }
    }
    import std.experimental.allocator.mallocator : Mallocator;
    assertThrown(makeArray!NoCopy(Mallocator.instance, 10, NoCopy(42)));
}

// test failure with an impure, failing struct
@system unittest
{
    import std.exception : assertThrown, enforce;

    static int i = 0;
    struct Singleton
    {
        @disable this();

        this(int b){}

        // can't be copied
        this(this)
        {
            enforce(i++ == 0);
        }

        ~this()
        {
            i--;
        }
    }
    import std.experimental.allocator.mallocator : Mallocator;
    assertThrown(makeArray!Singleton(Mallocator.instance, 10, Singleton(42)));
}

/// Ditto
Unqual!(ElementEncodingType!R)[] makeArray(Allocator, R)(auto ref Allocator alloc, R range)
if (isInputRange!R && !isInfinite!R)
{
    alias T = Unqual!(ElementEncodingType!R);
    return makeArray!(T, Allocator, R)(alloc, range);
}

/// Ditto
T[] makeArray(T, Allocator, R)(auto ref Allocator alloc, R range)
if (isInputRange!R && !isInfinite!R)
{
    static if (isForwardRange!R || hasLength!R)
    {
        static if (hasLength!R || isNarrowString!R)
            immutable length = range.length;
        else
            immutable length = range.save.walkLength;

        if (!length) return null;
        auto m = alloc.allocate(T.sizeof * length);
        if (!m.ptr) return null;
        auto result = () @trusted { return cast(T[]) m; } ();

        size_t i = 0;
        scope (failure)
        {
            foreach (j; 0 .. i)
            {
                auto p = () @trusted { return cast(Unqual!T*) &result[j]; }();
                destroy(p);
            }

            static if (canSafelyDeallocPostRewind!T)
                () @trusted { alloc.deallocate(m); } ();
            else
                alloc.deallocate(m);
        }

        import core.internal.lifetime : emplaceRef;
        static if (isNarrowString!R || isRandomAccessRange!R)
        {
            foreach (j; 0 .. range.length)
            {
                emplaceRef!T(result[i++], range[j]);
            }
        }
        else
        {
            for (; !range.empty; range.popFront, ++i)
            {
                emplaceRef!T(result[i], range.front);
            }
        }

        return result;
    }
    else
    {
        // Estimated size
        size_t estimated = 8;
        auto m = alloc.allocate(T.sizeof * estimated);
        if (!m.ptr) return null;
        auto result = () @trusted { return cast(T[]) m; } ();

        size_t initialized = 0;
        void bailout()
        {
            foreach (i; 0 .. initialized + 1)
            {
                destroy(result[i]);
            }

            static if (canSafelyDeallocPostRewind!T)
                () @trusted { alloc.deallocate(m); } ();
            else
                alloc.deallocate(m);
        }
        scope (failure) bailout;

        for (; !range.empty; range.popFront, ++initialized)
        {
            if (initialized == estimated)
            {
                // Need to reallocate
                static if (hasPurePostblit!T)
                    auto success = () @trusted { return alloc.reallocate(m, T.sizeof * (estimated *= 2)); } ();
                else
                    auto success = alloc.reallocate(m, T.sizeof * (estimated *= 2));
                if (!success)
                {
                    bailout;
                    return null;
                }
                result = () @trusted { return cast(T[]) m; } ();
            }
            import core.internal.lifetime : emplaceRef;
            emplaceRef(result[initialized], range.front);
        }

        if (initialized < estimated)
        {
            // Try to shrink memory, no harm if not possible
            static if (hasPurePostblit!T)
                auto success = () @trusted { return alloc.reallocate(m, T.sizeof * initialized); } ();
            else
                auto success = alloc.reallocate(m, T.sizeof * initialized);
            if (success)
                result = () @trusted { return cast(T[]) m; } ();
        }

        return result[0 .. initialized];
    }
}

@system unittest
{
    void test(A)(auto ref A alloc)
    {
        long[] a = alloc.makeArray!long((int[]).init);
        assert(a.length == 0 && a.ptr is null);
        a = alloc.makeArray!long([5, 42]);
        assert(a.length == 2);
        assert(a == [ 5, 42]);

        // we can also infer the type
        auto b = alloc.makeArray([4.0, 2.0]);
        static assert(is(typeof(b) == double[]));
        assert(b == [4.0, 2.0]);
    }
    import std.experimental.allocator.gc_allocator : GCAllocator;
    (alloc) pure nothrow @safe { test(alloc); } (GCAllocator.instance);
    test(theAllocator);
}

// infer types for strings
@system unittest
{
    void test(A)(auto ref A alloc)
    {
        auto c = alloc.makeArray("fooπ😜");
        static assert(is(typeof(c) == char[]));
        assert(c == "fooπ😜");

        auto d = alloc.makeArray("fooπ😜"d);
        static assert(is(typeof(d) == dchar[]));
        assert(d == "fooπ😜");

        auto w = alloc.makeArray("fooπ😜"w);
        static assert(is(typeof(w) == wchar[]));
        assert(w == "fooπ😜");
    }

    import std.experimental.allocator.gc_allocator : GCAllocator;
    (alloc) pure nothrow @safe { test(alloc); } (GCAllocator.instance);
    test(theAllocator);
}

/*pure*/ nothrow @safe unittest
{
    import std.algorithm.comparison : equal;
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.internal.test.dummyrange;
    import std.range : iota;
    foreach (DummyType; AllDummyRanges)
    {
        (alloc) pure nothrow @safe
        {
            DummyType d;
            auto arr = alloc.makeArray(d);
            assert(arr.length == 10);
            assert(arr.equal(iota(1, 11)));
        } (GCAllocator.instance);
    }
}

// test failure with a pure, failing struct
@safe unittest
{
    import std.exception : assertThrown, enforce;

    struct NoCopy
    {
        int b;

        @disable this();

        this(int b)
        {
            this.b = b;
        }

        // can't be copied
        this(this)
        {
            enforce(b < 3, "there can only be three elements");
        }
    }
    import std.experimental.allocator.mallocator : Mallocator;
    auto arr = [NoCopy(1), NoCopy(2), NoCopy(3)];
    assertThrown(makeArray!NoCopy(Mallocator.instance, arr));

    struct NoCopyRange
    {
        static j = 0;
        bool empty()
        {
            return j > 5;
        }

        auto front()
        {
            return NoCopy(j);
        }

        void popFront()
        {
            j++;
        }
    }
    makeArray!NoCopy(Mallocator.instance, NoCopyRange()); // rvalue elements are forwarded/moved
}

// test failure with an impure, failing struct
@system unittest
{
    import std.exception : assertThrown, enforce;

    static i = 0;
    static maxElements = 2;
    struct NoCopy
    {
        int val;
        @disable this();

        this(int b){
            this.val = i++;
        }

        // can't be copied
        this(this)
        {
            enforce(i++ < maxElements, "there can only be four elements");
        }
    }

    import std.experimental.allocator.mallocator : Mallocator;
    auto arr = [NoCopy(1), NoCopy(2)];
    assertThrown(makeArray!NoCopy(Mallocator.instance, arr));

    i = 0;
    maxElements = 0; // disallow any postblit
    static j = 0;

    struct NoCopyRange
    {
        bool empty()
        {
            return j > 100;
        }

        auto front()
        {
            return NoCopy(1);
        }

        void popFront()
        {
            j++;
        }
    }

    auto arr2 = makeArray!NoCopy(Mallocator.instance, NoCopyRange());
    assert(i == j && i == 101); // all 101 rvalue elements forwarded/moved
}

version (StdUnittest)
{
    private struct ForcedInputRange(T)
    {
        T[]* array;
        pure nothrow @safe @nogc:
        bool empty() { return !array || (*array).empty; }
        ref T front() { return (*array)[0]; }
        void popFront() { *array = (*array)[1 .. $]; }
    }
}

@system unittest
{
    import std.array : array;
    import std.range : iota;
    int[] arr = iota(10).array;

    void test(A)(auto ref A alloc)
    {
        ForcedInputRange!int r;
        long[] a = alloc.makeArray!long(r);
        assert(a.length == 0 && a.ptr is null);
        auto arr2 = arr;
        r.array = () @trusted { return &arr2; } ();
        a = alloc.makeArray!long(r);
        assert(a.length == 10);
        assert(a == iota(10).array);
    }
    import std.experimental.allocator.gc_allocator : GCAllocator;
    (alloc) pure nothrow @safe { test(alloc); } (GCAllocator.instance);
    test(theAllocator);
}

/**
Grows `array` by appending `delta` more elements. The needed memory is
allocated using `alloc`. The extra elements added are either default-
initialized, filled with copies of `init`, or initialized with values
fetched from `range`.

Params:
T = element type of the array being created
alloc = the allocator used for getting memory
array = a reference to the array being grown
delta = number of elements to add (upon success the new length of `array` is
$(D array.length + delta))
init = element used for filling the array
range = range used for initializing the array elements

Returns:
`true` upon success, `false` if memory could not be allocated. In the
latter case `array` is left unaffected.

Throws:
The first two overloads throw only if `alloc`'s primitives do. The
overloads that involve copy initialization deallocate memory and propagate the
exception if the copy operation throws.
*/
bool expandArray(T, Allocator)(auto ref Allocator alloc, ref T[] array,
        size_t delta)
{
    if (!delta) return true;
    if (array is null) return false;
    immutable oldLength = array.length;
    void[] buf = array;
    if (!alloc.reallocate(buf, buf.length + T.sizeof * delta)) return false;
    array = cast(T[]) buf;
    array[oldLength .. $].uninitializedFillDefault;
    return true;
}

@system unittest
{
    void test(A)(auto ref A alloc)
    {
        auto arr = alloc.makeArray!int([1, 2, 3]);
        assert(alloc.expandArray(arr, 3));
        assert(arr == [1, 2, 3, 0, 0, 0]);
    }
    import std.experimental.allocator.gc_allocator : GCAllocator;
    test(GCAllocator.instance);
    test(theAllocator);
}

/// Ditto
bool expandArray(T, Allocator)(auto ref Allocator alloc, ref T[] array,
    size_t delta, auto ref T init)
{
    if (!delta) return true;
    if (array is null) return false;
    void[] buf = array;
    if (!alloc.reallocate(buf, buf.length + T.sizeof * delta)) return false;
    immutable oldLength = array.length;
    array = cast(T[]) buf;
    scope(failure) array[oldLength .. $].uninitializedFillDefault;
    import std.algorithm.mutation : uninitializedFill;
    array[oldLength .. $].uninitializedFill(init);
    return true;
}

@system unittest
{
    void test(A)(auto ref A alloc)
    {
        auto arr = alloc.makeArray!int([1, 2, 3]);
        assert(alloc.expandArray(arr, 3, 1));
        assert(arr == [1, 2, 3, 1, 1, 1]);
    }
    import std.experimental.allocator.gc_allocator : GCAllocator;
    test(GCAllocator.instance);
    test(theAllocator);
}

/// Ditto
bool expandArray(T, Allocator, R)(auto ref Allocator alloc, ref T[] array,
        R range)
if (isInputRange!R)
{
    if (array is null) return false;
    static if (isForwardRange!R)
    {
        immutable delta = walkLength(range.save);
        if (!delta) return true;
        immutable oldLength = array.length;

        // Reallocate support memory
        void[] buf = array;
        if (!alloc.reallocate(buf, buf.length + T.sizeof * delta))
        {
            return false;
        }
        array = cast(T[]) buf;
        // At this point we're committed to the new length.

        auto toFill = array[oldLength .. $];
        scope (failure)
        {
            // Fill the remainder with default-constructed data
            toFill.uninitializedFillDefault;
        }

        for (; !range.empty; range.popFront, toFill = toFill[1 .. $])
        {
            assert(toFill.length > 0);
            import core.lifetime : emplace;
            emplace!T(&toFill[0], range.front);
        }
        assert(toFill.length == 0);
    }
    else
    {
        scope(failure)
        {
            // The last element didn't make it, fill with default
            array[$ - 1 .. $].uninitializedFillDefault;
        }
        void[] buf = array;
        for (; !range.empty; range.popFront)
        {
            if (!alloc.reallocate(buf, buf.length + T.sizeof))
            {
            // Written in the D programming language.
/**
Collection of typical and useful prebuilt allocators using the given
components. User code would typically import this module and use its
facilities, or import individual heap building blocks and assemble them.

Source: $(PHOBOSSRC std/experimental/allocator/_showcase.d)
*/
module std.experimental.allocator.showcase;

import std.experimental.allocator.building_blocks.fallback_allocator,
    std.experimental.allocator.gc_allocator,
    std.experimental.allocator.building_blocks.region;
import std.traits : hasMember;

/**

Allocator that uses stack allocation for up to `stackSize` bytes and
then falls back to `Allocator`. Defined as:

----
alias StackFront(size_t stackSize, Allocator) =
    FallbackAllocator!(
        InSituRegion!(stackSize, Allocator.alignment,
            hasMember!(Allocator, "deallocate")
                ? Yes.defineDeallocate
                : No.defineDeallocate),
        Allocator);
----

Choosing `stackSize` is as always a compromise. Too small a size exhausts the
stack storage after a few allocations, after which there are no gains over the
backup allocator. Too large a size increases the stack consumed by the thread
and may end up worse off because it explores cold portions of the stack.

*/
alias StackFront(size_t stackSize, Allocator = GCAllocator) =
    FallbackAllocator!(
        InSituRegion!(stackSize, Allocator.alignment),
        Allocator);

///
@system unittest
{
    StackFront!4096 a;
    auto b = a.allocate(4000);
    assert(b.length == 4000);
    auto c = a.allocate(4000);
    assert(c.length == 4000);
    a.deallocate(b);
    a.deallocate(c);
}

/**
Creates a scalable `AllocatorList` of `Regions`, each having at least
`bytesPerRegion` bytes. Allocation is very fast. This allocator does not offer
`deallocate` but does free all regions in its destructor. It is recommended for
short-lived batch applications that count on never running out of memory.
*/
auto mmapRegionList(size_t bytesPerRegion)
{
    static struct Factory
    {
        size_t bytesPerRegion;
        import std.algorithm.comparison : max;
        import std.experimental.allocator.building_blocks.region
            : Region;
        import std.experimental.allocator.mmap_allocator
            : MmapAllocator;
        this(size_t n)
        {
            bytesPerRegion = n;
        }
        auto opCall(size_t n)
        {
            return Region!MmapAllocator(max(n, bytesPerRegion));
        }
    }
    import std.experimental.allocator.building_blocks.allocator_list
        : AllocatorList;
    import std.experimental.allocator.building_blocks.null_allocator
        : NullAllocator;
    auto shop = Factory(bytesPerRegion);
    return AllocatorList!(Factory, NullAllocator)(shop);
}

///
@system unittest
{
    auto alloc = mmapRegionList(1024 * 1024);
    const b = alloc.allocate(100);
    assert(b.length == 100);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // Written in the D programming language.
/**
This module defines `TypedAllocator`, a statically-typed allocator that
aggregates multiple untyped allocators and uses them depending on the static
properties of the types allocated. For example, distinct allocators may be used
for thread-local vs. thread-shared data, or for fixed-size data (`struct`,
`class` objects) vs. resizable data (arrays).

Source: $(PHOBOSSRC std/experimental/allocator/typed.d)

Macros:
T2=$(TR <td style="text-align:left">`$1`</td> $(TD $(ARGS $+)))
*/

module std.experimental.allocator.typed;

import std.experimental.allocator;
import std.experimental.allocator.common;
import std.range : isInputRange, isForwardRange, walkLength, save, empty,
    front, popFront;
import std.traits : isPointer, hasElaborateDestructor;
import std.typecons : Flag, Yes, No;

/**
Allocation-related flags dictated by type characteristics. `TypedAllocator`
deduces these flags from the type being allocated and uses the appropriate
allocator accordingly.
*/
enum AllocFlag : uint
{
    _init = 0,
    /**
    Fixed-size allocation (unlikely to get reallocated later). Examples: `int`,
    `double`, any `struct` or `class` type. By default it is assumed that the
    allocation is variable-size, i.e. susceptible to later reallocation
    (for example all array types). This flag is advisory, i.e. in-place resizing
    may be attempted for `fixedSize` allocations and may succeed. The flag is
    just a hint to the compiler it may use allocation strategies that work well
    with objects of fixed size.
    */
    fixedSize = 1,
    /**
    The type being allocated embeds no pointers. Examples: `int`, `int[]`, $(D
    Tuple!(int, float)). The implicit conservative assumption is that the type
    has members with indirections so it needs to be scanned if garbage
    collected. Example of types with pointers: `int*[]`, $(D Tuple!(int,
    string)).
    */
    hasNoIndirections = 4,
    /**
    By default it is conservatively assumed that allocated memory may be `cast`
    to `shared`, passed across threads, and deallocated in a different thread
    than the one that allocated it. If that's not the case, there are two
    options. First, `immutableShared` means the memory is allocated for
    `immutable` data and will be deallocated in the same thread it was
    allocated in. Second, `threadLocal` means the memory is not to be shared
    across threads at all. The two flags cannot be simultaneously present.
    */
    immutableShared = 8,
    /// ditto
    threadLocal = 16,
}

/**
`TypedAllocator` acts like a chassis on which several specialized allocators
can be assembled. To let the system make a choice about a particular kind of
allocation, use `Default` for the respective parameters.

There is a hierarchy of allocation kinds. When an allocator is implemented for
a given combination of flags, it is used. Otherwise, the next down the list is
chosen.

$(BOOKTABLE ,

$(TR $(TH `AllocFlag` combination) $(TH Description))

$(T2 AllocFlag.threadLocal |$(NBSP)AllocFlag.hasNoIndirections
|$(NBSP)AllocFlag.fixedSize,
This is the most specific allocation policy: the memory being allocated is
thread local, has no indirections at all, and will not be reallocated. Examples
of types fitting this description: `int`, `double`, $(D Tuple!(int, long)), but
not $(D Tuple!(int, string)), which contains an indirection.)

$(T2 AllocFlag.threadLocal |$(NBSP)AllocFlag.hasNoIndirections,
As above, but may be reallocated later. Examples of types fitting this
description are `int[]`, `double[]`, $(D Tuple!(int, long)[]), but not
$(D Tuple!(int, string)[]), which contains an indirection.)

$(T2 AllocFlag.threadLocal,
As above, but may embed indirections. Examples of types fitting this
description are `int*[]`, `Object[]`, $(D Tuple!(int, string)[]).)

$(T2 AllocFlag.immutableShared |$(NBSP)AllocFlag.hasNoIndirections
|$(NBSP)AllocFlag.fixedSize,
The type being allocated is `immutable` and has no pointers. The thread that
allocated it must also deallocate it. Example: `immutable(int)`.)

$(T2 AllocFlag.immutableShared |$(NBSP)AllocFlag.hasNoIndirections,
As above, but the type may be appended to in the future. Example: `string`.)

$(T2 AllocFlag.immutableShared,
As above, but the type may embed references. Example: `immutable(Object)[]`.)

$(T2 AllocFlag.hasNoIndirections |$(NBSP)AllocFlag.fixedSize,
The type being allocated may be shared across threads, embeds no indirections,
and has fixed size.)

$(T2 AllocFlag.hasNoIndirections,
The type being allocated may be shared across threads, may embed indirections,
and has variable size.)

$(T2 AllocFlag.fixedSize,
The type being allocated may be shared across threads, may embed indirections,
and has fixed size.)

$(T2 0, The most conservative/general allocation: memory may be shared,
deallocated in a different thread, may or may not be resized, and may embed
references.)
)

Params:
PrimaryAllocator = The default allocator.
Policies = Zero or more pairs consisting of an `AllocFlag` and an allocator
type.
*/
struct TypedAllocator(PrimaryAllocator, Policies...)
{
    import std.algorithm.sorting : isSorted;
    import std.meta : AliasSeq;
    import std.typecons : Tuple;

    static assert(Policies.length == 0 || isSorted([Stride2!Policies]));

    private template Stride2(T...)
    {
        static if (T.length >= 2)
        {
            alias Stride2 = AliasSeq!(T[0], Stride2!(T[2 .. $]));
        }
        else
        {
            alias Stride2 = AliasSeq!(T[0 .. $]);
        }
    }

    // state
    static if (stateSize!PrimaryAllocator) private PrimaryAllocator primary;
    else alias primary = PrimaryAllocator.instance;
    static if (Policies.length > 0)
        private Tuple!(Stride2!(Policies[1 .. $])) extras;

    private static bool match(uint have, uint want)
    {
        enum uint maskAway =
            ~(AllocFlag.immutableShared | AllocFlag.threadLocal);
        // Do we offer thread local?
        if (have & AllocFlag.threadLocal)
        {
            if (want & AllocFlag.threadLocal)
                return match(have & maskAway, want & maskAway);
            return false;
        }
        if (have & AllocFlag.immutableShared)
        {
            // Okay to ask for either thread local or immutable shared
            if (want & (AllocFlag.threadLocal
                    | AllocFlag.immutableShared))
                return match(have & maskAway, want & maskAway);
            return false;
        }
        // From here on we have full-blown thread sharing.
        if (have & AllocFlag.hasNoIndirections)
        {
            if (want & AllocFlag.hasNoIndirections)
                return match(have & ~AllocFlag.hasNoIndirections,
                    want & ~AllocFlag.hasNoIndirections);
            return false;
        }
        // Fixed size or variable size both match.
        return true;
    }

    /**
    Given `flags` as a combination of `AllocFlag` values, or a type `T`, returns
    the allocator that's a closest fit in capabilities.
    */
    auto ref allocatorFor(uint flags)()
    {
        static if (Policies.length == 0 || !match(Policies[0], flags))
        {
            return primary;
        }
        else static if (Policies.length && match(Policies[$ - 2], flags))
        {
            return extras[$ - 1];
        }
        else
        {
            foreach (i, choice; Stride2!Policies)
            {
                static if (!match(choice, flags))
                {
                    return extras[i - 1];
                }
            }
            assert(0);
        }
    }

    /// ditto
    auto ref allocatorFor(T)()
    {
        static if (is(T == void[]))
        {
            return primary;
        }
        else
        {
            return allocatorFor!(type2flags!T)();
        }
    }

    /**
    Given a type `T`, returns its allocation-related flags as a combination of
    `AllocFlag` values.
    */
    static uint type2flags(T)()
    {
        uint result;
        static if (is(T == immutable))
            result |= AllocFlag.immutableShared;
        else static if (is(T == shared))
            result |= AllocFlag.forSharing;
        static if (!is(T == U[], U))
            result |= AllocFlag.fixedSize;
        import std.traits : hasIndirections;
        static if (!hasIndirections!T)
            result |= AllocFlag.hasNoIndirections;
        return result;
    }

    /**
    Dynamically allocates (using the appropriate allocator chosen with
    `allocatorFor!T`) and then creates in the memory allocated an object of
    type `T`, using `args` (if any) for its initialization. Initialization
    occurs in the memory allocated and is otherwise semantically the same as
    `T(args)`. (Note that using `make!(T[])` creates a pointer to an
    (empty) array of `T`s, not an array. To allocate and initialize an
    array, use `makeArray!T` described below.)

    Params:
    T = Type of the object being created.
    args = Optional arguments used for initializing the created object. If not
    present, the object is default constructed.

    Returns: If `T` is a class type, returns a reference to the created `T`
    object. Otherwise, returns a `T*` pointing to the created object. In all
    cases, returns `null` if allocation failed.

    Throws: If `T`'s constructor throws, deallocates the allocated memory and
    propagates the exception.
    */
    auto make(T, A...)(auto ref A args)
    {
        return .make!T(allocatorFor!T, args);
    }

    /**
    Create an array of `T` with `length` elements. The array is either
    default-initialized, filled with copies of `init`, or initialized with
    values fetched from `range`.

    Params:
    T = element type of the array being created
    length = length of the newly created array
    init = element used for filling the array
    range = range used for initializing the array elements

    Returns:
    The newly-created array, or `null` if either `length` was `0` or
    allocation failed.

    Throws:
    The first two overloads throw only if the used allocator's primitives do.
    The overloads that involve copy initialization deallocate memory and propagate the exception if the copy operation throws.
    */
    T[] makeArray(T)(size_t length)
    {
        return .makeArray!T(allocatorFor!(T[]), length);
    }

    /// Ditto
    T[] makeArray(T)(size_t length, auto ref T init)
    {
        return .makeArray!T(allocatorFor!(T[]), init, length);
    }

    /// Ditto
    T[] makeArray(T, R)(R range)
    if (isInputRange!R)
    {
        return .makeArray!T(allocatorFor!(T[]), range);
    }

    /**
    Grows `array` by appending `delta` more elements. The needed memory is
    allocated using the same allocator that was used for the array type. The
    extra elements added are either default-initialized, filled with copies of
    `init`, or initialized with values fetched from `range`.

    Params:
    T = element type of the array being created
    array = a reference to the array being grown
    delta = number of elements to add (upon success the new length of `array`
    is $(D array.length + delta))
    init = element used for filling the array
    range = range used for initializing the array elements

    Returns:
    `true` upon success, `false` if memory could not be allocated. In the
    latter case `array` is left unaffected.

    Throws:
    The first two overloads throw only if the used allocator's primitives do.
    The overloads that involve copy initialization deallocate memory and
    propagate the exception if the copy operation throws.
    */
    bool expandArray(T)(ref T[] array, size_t delta)
    {
        return .expandArray(allocatorFor!(T[]), array, delta);
    }
    /// Ditto
    bool expandArray(T)(T[] array, size_t delta, auto ref T init)
    {
        return .expandArray(allocatorFor!(T[]), array, delta, init);
    }
    /// Ditto
    bool expandArray(T, R)(ref T[] array, R range)
    if (isInputRange!R)
    {
        return .expandArray(allocatorFor!(T[]), array, range);
    }

    /**
    Shrinks an array by `delta` elements using `allocatorFor!(T[])`.

    If $(D arr.length < delta), does nothing and returns `false`. Otherwise,
    destroys the last $(D arr.length - delta) elements in the array and then
    reallocates the array's buffer. If reallocation fails, fills the array with
    default-initialized data.

    Params:
    T = element type of the array being created
    arr = a reference to the array being shrunk
    delta = number of elements to remove (upon success the new length of
    `arr` is $(D arr.length - delta))

    Returns:
    `true` upon success, `false` if memory could not be reallocated. In the
    latter case $(D arr[$ - delta .. $]) is left with default-initialized
    elements.

    Throws:
    The first two overloads throw only if the used allocator's primitives do.
    The overloads that involve copy initialization deallocate memory and
    propagate the exception if the copy operation throws.
    */
    bool shrinkArray(T)(ref T[] arr, size_t delta)
    {
        return .shrinkArray(allocatorFor!(T[]), arr, delta);
    }

    /**
    Destroys and then deallocates (using `allocatorFor!T`) the object pointed
    to by a pointer, the class object referred to by a `class` or `interface`
    reference, or an entire array. It is assumed the respective entities had
    been allocated with the same allocator.
    */
    void dispose(T)(T* p)
    {
        return .dispose(allocatorFor!T, p);
    }
    /// Ditto
    void dispose(T)(T p)
    if (is(T == class) || is(T == interface))
    {
        return .dispose(allocatorFor!T, p);
    }
    /// Ditto
    void dispose(T)(T[] array)
    {
        return .dispose(allocatorFor!(T[]), array);
    }
}

///
@system unittest
{
    import std.experimental.allocator.gc_allocator : GCAllocator;
    import std.experimental.allocator.mallocator : Mallocator;
    import std.experimental.allocator.mmap_allocator : MmapAllocator;
    alias MyAllocator = TypedAllocator!(GCAllocator,
        AllocFlag.fixedSize | AllocFlag.threadLocal, Mallocator,
        AllocFlag.fixedSize | AllocFlag.threadLocal
                | AllocFlag.hasNoIndirections,
            MmapAllocator,
    );

    MyAllocator a;
    auto b = &a.allocatorFor!0();
    static assert(is(typeof(*b) == shared const(GCAllocator)));
    enum f1 = AllocFlag.fixedSize | AllocFlag.threadLocal;
    auto c = &a.allocatorFor!f1();
    static assert(is(typeof(*c) == Mallocator));
    enum f2 = AllocFlag.fixedSize | AllocFlag.threadLocal;
    static assert(is(typeof(a.allocatorFor!f2()) == Mallocator));
    // Partial match
    enum f3 = AllocFlag.threadLocal;
    static assert(is(typeof(a.allocatorFor!f3()) == Mallocator));

    int* p = a.make!int;
    scope(exit) a.dispose(p);
    int[] arr = a.makeArray!int(42);
    scope(exit) a.dispose(arr);
    assert(a.expandArray(arr, 3));
    assert(a.shrinkArray(arr, 4));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
/**
 * This module is now deprecated, use $(MREF std, checkedint)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/checkedint.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
deprecated module std.experimental.checkedint;
public import std.checkedint;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
 * This module is now deprecated, use $(MREF std, logger, core)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/logger/core.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
module std.experimental.logger.core;
public import std.logger.core;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /**
 * This module is now deprecated, use $(MREF std, logger, filelogger)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/logger/filelogger.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
module std.experimental.logger.filelogger;
public import std.logger.filelogger;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * This module is now deprecated, use $(MREF std, logger, multilogger)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/logger/multilogger.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
module std.experimental.logger.multilogger;
public import std.logger.multilogger;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /**
 * This module is now deprecated, use $(MREF std, logger, nulllogger)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/logger/nulllogger.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
module std.experimental.logger.nulllogger;
public import std.logger.nulllogger;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
 * This module is now deprecated, use $(MREF std, logger)
 * instead.
 *
 * Copyright: Copyright The D Language Foundation 2005 - 2015.
 * License: $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors:
 * Source:    $(PHOBOSSRC std/experimental/logger/package.d)
 *
 * $(SCRIPT inhibitQuickIndex = 1;)
 */
module std.experimental.logger;

public import std.logger.core;
public import std.logger.filelogger;
public import std.logger.multilogger;
public import std.logger.nulllogger;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // Written in the D programming language.

/**
Utilities for manipulating files and scanning directories. Functions
in this module handle files as a unit, e.g., read or write one file
at a time. For opening files and manipulating them via handles refer
to module $(MREF std, stdio).

$(SCRIPT inhibitQuickIndex = 1;)
$(DIVC quickindex,
$(BOOKTABLE,
$(TR $(TH Category) $(TH Functions))
$(TR $(TD General) $(TD
          $(LREF exists)
          $(LREF isDir)
          $(LREF isFile)
          $(LREF isSymlink)
          $(LREF rename)
          $(LREF thisExePath)
))
$(TR $(TD Directories) $(TD
          $(LREF chdir)
          $(LREF dirEntries)
          $(LREF getcwd)
          $(LREF mkdir)
          $(LREF mkdirRecurse)
          $(LREF rmdir)
          $(LREF rmdirRecurse)
          $(LREF tempDir)
))
$(TR $(TD Files) $(TD
          $(LREF append)
          $(LREF copy)
          $(LREF read)
          $(LREF readText)
          $(LREF remove)
          $(LREF slurp)
          $(LREF write)
))
$(TR $(TD Symlinks) $(TD
          $(LREF symlink)
          $(LREF readLink)
))
$(TR $(TD Attributes) $(TD
          $(LREF attrIsDir)
          $(LREF attrIsFile)
          $(LREF attrIsSymlink)
          $(LREF getAttributes)
          $(LREF getLinkAttributes)
          $(LREF getSize)
          $(LREF setAttributes)
))
$(TR $(TD Timestamp) $(TD
          $(LREF getTimes)
          $(LREF getTimesWin)
          $(LREF setTimes)
          $(LREF timeLastModified)
          $(LREF timeLastAccessed)
          $(LREF timeStatusChanged)
))
$(TR $(TD Other) $(TD
          $(LREF DirEntry)
          $(LREF FileException)
          $(LREF PreserveAttributes)
          $(LREF SpanMode)
          $(LREF getAvailableDiskSpace)
))
))


Copyright: Copyright The D Language Foundation 2007 - 2011.
See_Also:  The $(HTTP ddili.org/ders/d.en/files.html, official tutorial) for an
introduction to working with files in D, module
$(MREF std, stdio) for opening files and manipulating them via handles,
and module $(MREF std, path) for manipulating path strings.

License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
Authors:   $(HTTP digitalmars.com, Walter Bright),
           $(HTTP erdani.org, Andrei Alexandrescu),
           $(HTTP jmdavisprog.com, Jonathan M Davis)
Source:    $(PHOBOSSRC std/file.d)
 */
module std.file;

import core.stdc.errno, core.stdc.stdlib, core.stdc.string;
import core.time : abs, dur, hnsecs, seconds;

import std.datetime.date : DateTime;
import std.datetime.systime : Clock, SysTime, unixTimeToStdTime;
import std.internal.cstring;
import std.meta;
import std.range;
import std.traits;
import std.typecons;

version (OSX)
    version = Darwin;
else version (iOS)
    version = Darwin;
else version (TVOS)
    version = Darwin;
else version (WatchOS)
    version = Darwin;

version (Windows)
{
    import core.sys.windows.winbase, core.sys.windows.winnt, std.windows.syserror;
}
else version (Posix)
{
    import core.sys.posix.dirent, core.sys.posix.fcntl, core.sys.posix.sys.stat,
        core.sys.posix.sys.time, core.sys.posix.unistd, core.sys.posix.utime;
}
else
    static assert(false, "Module " ~ .stringof ~ " not implemented for this OS.");

// Character type used for operating system filesystem APIs
version (Windows)
{
    private alias FSChar = WCHAR;       // WCHAR can be aliased to wchar or wchar_t
}
else version (Posix)
{
    private alias FSChar = char;
}
else
    static assert(0);

// Purposefully not documented. Use at your own risk
@property string deleteme() @safe
{
    import std.conv : text;
    import std.path : buildPath;
    import std.process : thisProcessID;

    enum base = "deleteme.dmd.unittest.pid";
    static string fileName;

    if (!fileName)
        fileName = text(buildPath(tempDir(), base), thisProcessID);
    return fileName;
}

version (StdUnittest) private struct TestAliasedString
{
    string get() @safe @nogc pure nothrow return scope { return _s; }
    alias get this;
    @disable this(this);
    string _s;
}

version (Android)
{
    package enum system_directory = "/system/etc";
    package enum system_file      = "/system/etc/hosts";
}
else version (Posix)
{
    package enum system_directory = "/usr/include";
    package enum system_file      = "/usr/include/assert.h";
}


/++
    Exception thrown for file I/O errors.
 +/
class FileException : Exception
{
    import std.conv : text, to;

    /++
        OS error code.
     +/
    immutable uint errno;

    private this(scope const(char)[] name, scope const(char)[] msg, string file, size_t line, uint errno) @safe pure
    {
        if (msg.empty)
            super(name is null ? "(null)" : name.idup, file, line);
        else
            super(text(name is null ? "(null)" : name, ": ", msg), file, line);

        this.errno = errno;
    }

    /++
        Constructor which takes an error message.

        Params:
            name = Name of file for which the error occurred.
            msg  = Message describing the error.
            file = The file where the error occurred.
            line = The _line where the error occurred.
     +/
    this(scope const(char)[] name, scope const(char)[] msg, string file = __FILE__, size_t line = __LINE__) @safe pure
    {
        this(name, msg, file, line, 0);
    }

    /++
        Constructor which takes the error number ($(LUCKY GetLastError)
        in Windows, $(D_PARAM errno) in POSIX).

        Params:
            name  = Name of file for which the error occurred.
            errno = The error number.
            file  = The file where the error occurred.
                    Defaults to `__FILE__`.
            line  = The _line where the error occurred.
                    Defaults to `__LINE__`.
     +/
    version (Windows) this(scope const(char)[] name,
                          uint errno = .GetLastError(),
                          string file = __FILE__,
                          size_t line = __LINE__) @safe
    {
        this(name, generateSysErrorMsg(errno), file, line, errno);
    }
    else version (Posix) this(scope const(char)[] name,
                             uint errno = .errno,
                             string file = __FILE__,
                             size_t line = __LINE__) @trusted
    {
        import std.exception : errnoString;
        this(name, errnoString(errno), file, line, errno);
    }
}

///
@safe unittest
{
    import std.exception : assertThrown;

    assertThrown!FileException("non.existing.file.".readText);
}

private T cenforce(T)(T condition, lazy scope const(char)[] name, string file = __FILE__, size_t line = __LINE__)
{
    if (condition)
        return condition;
    version (Windows)
    {
        throw new FileException(name, .GetLastError(), file, line);
    }
    else version (Posix)
    {
        throw new FileException(name, .errno, file, line);
    }
}

version (Windows)
@trusted
private T cenforce(T)(T condition, scope const(char)[] name, scope const(FSChar)* namez,
    string file = __FILE__, size_t line = __LINE__)
{
    if (condition)
        return condition;
    if (!name)
    {
        import core.stdc.wchar_ : wcslen;
        import std.conv : to;

        auto len = namez ? wcslen(namez) : 0;
        name = to!string(namez[0 .. len]);
    }
    throw new FileException(name, .GetLastError(), file, line);
}

version (Posix)
@trusted
private T cenforce(T)(T condition, scope const(char)[] name, scope const(FSChar)* namez,
    string file = __FILE__, size_t line = __LINE__)
{
    if (condition)
        return condition;
    if (!name)
    {
        import core.stdc.string : strlen;

        auto len = namez ? strlen(namez) : 0;
        name = namez[0 .. len].idup;
    }
    throw new FileException(name, .errno, file, line);
}

// https://issues.dlang.org/show_bug.cgi?id=17102
@safe unittest
{
    try
    {
        cenforce(false, null, null,
                __FILE__, __LINE__);
    }
    catch (FileException) {}
}

/* **********************************
 * Basic File operations.
 */

/********************************************
Read entire contents of file `name` and returns it as an untyped
array. If the file size is larger than `upTo`, only `upTo`
bytes are _read.

Params:
    name = string or range of characters representing the file _name
    upTo = if present, the maximum number of bytes to _read

Returns: Untyped array of bytes _read.

Throws: $(LREF FileException) on error.

See_Also: $(REF readText, std,file) for reading and validating a text file.
 */

void[] read(R)(R name, size_t upTo = size_t.max)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
        return readImpl(name, name.tempCString!FSChar(), upTo);
    else
        return readImpl(null, name.tempCString!FSChar(), upTo);
}

///
@safe unittest
{
    import std.utf : byChar;
    scope(exit)
    {
        assert(exists(deleteme));
        remove(deleteme);
    }

    std.file.write(deleteme, "1234"); // deleteme is the name of a temporary file
    assert(read(deleteme, 2) == "12");
    assert(read(deleteme.byChar) == "1234");
    assert((cast(const(ubyte)[])read(deleteme)).length == 4);
}

/// ditto
void[] read(R)(auto ref R name, size_t upTo = size_t.max)
if (isConvertibleToString!R)
{
    return read!(StringTypeOf!R)(name, upTo);
}

@safe unittest
{
    static assert(__traits(compiles, read(TestAliasedString(null))));
}

version (Posix) private void[] readImpl(scope const(char)[] name, scope const(FSChar)* namez,
                                        size_t upTo = size_t.max) @trusted
{
    import core.memory : GC;
    import std.algorithm.comparison : min;
    import std.conv : to;
    import std.checkedint : checked;

    // A few internal configuration parameters {
    enum size_t
        minInitialAlloc = 1024 * 4,
        maxInitialAlloc = size_t.max / 2,
        sizeIncrement = 1024 * 16,
        maxSlackMemoryAllowed = 1024;
    // }

    immutable fd = core.sys.posix.fcntl.open(namez,
            core.sys.posix.fcntl.O_RDONLY);
    cenforce(fd != -1, name);
    scope(exit) core.sys.posix.unistd.close(fd);

    stat_t statbuf = void;
    cenforce(fstat(fd, &statbuf) == 0, name, namez);

    immutable initialAlloc = min(upTo, to!size_t(statbuf.st_size
        ? min(statbuf.st_size + 1, maxInitialAlloc)
        : minInitialAlloc));
    void[] result = GC.malloc(initialAlloc, GC.BlkAttr.NO_SCAN)[0 .. initialAlloc];
    scope(failure) GC.free(result.ptr);

    auto size = checked(size_t(0));

    for (;;)
    {
        immutable actual = core.sys.posix.unistd.read(fd, result.ptr + size.get,
                (min(result.length, upTo) - size).get);
        cenforce(actual != -1, name, namez);
        if (actual == 0) break;
        size += actual;
        if (size >= upTo) break;
        if (size < result.length) continue;
        immutable newAlloc = size + sizeIncrement;
        result = GC.realloc(result.ptr, newAlloc.get, GC.BlkAttr.NO_SCAN)[0 .. newAlloc.get];
    }

    return result.length - size >= maxSlackMemoryAllowed
        ? GC.realloc(result.ptr, size.get, GC.BlkAttr.NO_SCAN)[0 .. size.get]
        : result[0 .. size.get];
}

version (Windows)
private extern (Windows) @nogc nothrow
{
    pragma(mangle, CreateFileW.mangleof)
    HANDLE trustedCreateFileW(scope const(wchar)* namez, DWORD dwDesiredAccess,
        DWORD dwShareMode, SECURITY_ATTRIBUTES* lpSecurityAttributes,
        DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile)  @trusted;

    pragma(mangle, CloseHandle.mangleof) BOOL trustedCloseHandle(HANDLE) @trusted;
}

version (Windows) private void[] readImpl(scope const(char)[] name, scope const(FSChar)* namez,
                                          size_t upTo = size_t.max) @trusted
{
    import core.memory : GC;
    import std.algorithm.comparison : min;
    static trustedGetFileSize(HANDLE hFile, out ulong fileSize)
    {
        DWORD sizeHigh;
        DWORD sizeLow = GetFileSize(hFile, &sizeHigh);
        const bool result = sizeLow != INVALID_FILE_SIZE;
        if (result)
            fileSize = makeUlong(sizeLow, sizeHigh);
        return result;
    }
    static trustedReadFile(HANDLE hFile, void *lpBuffer, size_t nNumberOfBytesToRead)
    {
        // Read by chunks of size < 4GB (Windows API limit)
        size_t totalNumRead = 0;
        while (totalNumRead != nNumberOfBytesToRead)
        {
            const uint chunkSize = min(nNumberOfBytesToRead - totalNumRead, 0xffff_0000);
            DWORD numRead = void;
            const result = ReadFile(hFile, lpBuffer + totalNumRead, chunkSize, &numRead, null);
            if (result == 0 || numRead != chunkSize)
                return false;
            totalNumRead += chunkSize;
        }
        return true;
    }

    alias defaults =
        AliasSeq!(GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, (SECURITY_ATTRIBUTES*).init,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            HANDLE.init);
    auto h = trustedCreateFileW(namez, defaults);

    cenforce(h != INVALID_HANDLE_VALUE, name, namez);
    scope(exit) cenforce(trustedCloseHandle(h), name, namez);
    ulong fileSize = void;
    cenforce(trustedGetFileSize(h, fileSize), name, namez);
    size_t size = min(upTo, fileSize);
    auto buf = () { return GC.malloc(size, GC.BlkAttr.NO_SCAN)[0 .. size]; } ();

    scope(failure)
    {
        () { GC.free(buf.ptr); } ();
    }

    if (size)
        cenforce(trustedReadFile(h, &buf[0], size), name, namez);
    return buf[0 .. size];
}

version (linux) @safe unittest
{
    // A file with "zero" length that doesn't have 0 length at all
    auto s = std.file.readText("/proc/cpuinfo");
    assert(s.length > 0);
    //writefln("'%s'", s);
}

@safe unittest
{
    scope(exit) if (exists(deleteme)) remove(deleteme);
    import std.stdio;
    auto f = File(deleteme, "w");
    f.write("abcd"); f.flush();
    assert(read(deleteme) == "abcd");
}

/++
    Reads and validates (using $(REF validate, std, utf)) a text file. S can be
    an array of any character type. However, no width or endian conversions are
    performed. So, if the width or endianness of the characters in the given
    file differ from the width or endianness of the element type of S, then
    validation will fail.

    Params:
        S = the string type of the file
        name = string or range of characters representing the file _name

    Returns: Array of characters read.

    Throws: $(LREF FileException) if there is an error reading the file,
            $(REF UTFException, std, utf) on UTF decoding error.

    See_Also: $(REF read, std,file) for reading a binary file.
+/
S readText(S = string, R)(auto ref R name)
if (isSomeString!S && (isSomeFiniteCharInputRange!R || is(StringTypeOf!R)))
{
    import std.algorithm.searching : startsWith;
    import std.encoding : getBOM, BOM;
    import std.exception : enforce;
    import std.format : format;
    import std.utf : UTFException, validate;

    static if (is(StringTypeOf!R))
        StringTypeOf!R filename = name;
    else
        auto filename = name;

    static auto trustedCast(T)(void[] buf) @trusted { return cast(T) buf; }
    auto data = trustedCast!(ubyte[])(read(filename));

    immutable bomSeq = getBOM(data);
    immutable bom = bomSeq.schema;

    static if (is(immutable ElementEncodingType!S == immutable char))
    {
        with(BOM) switch (bom)
        {
            case utf16be:
            case utf16le: throw new UTFException("UTF-8 requested. BOM is for UTF-16");
            case utf32be:
            case utf32le: throw new UTFException("UTF-8 requested. BOM is for UTF-32");
            default: break;
        }
    }
    else static if (is(immutable ElementEncodingType!S == immutable wchar))
    {
        with(BOM) switch (bom)
        {
            case utf8: throw new UTFException("UTF-16 requested. BOM is for UTF-8");
            case utf16be:
            {
                version (BigEndian)
                    break;
                else
                    throw new UTFException("BOM is for UTF-16 LE on Big Endian machine");
            }
            case utf16le:
            {
                version (BigEndian)
                    throw new UTFException("BOM is for UTF-16 BE on Little Endian machine");
                else
                    break;
            }
            case utf32be:
            case utf32le: throw new UTFException("UTF-8 requested. BOM is for UTF-32");
            default: break;
        }
    }
    else
    {
        with(BOM) switch (bom)
        {
            case utf8: throw new UTFException("UTF-16 requested. BOM is for UTF-8");
            case utf16be:
            case utf16le: throw new UTFException("UTF-8 requested. BOM is for UTF-16");
            case utf32be:
            {
                version (BigEndian)
                    break;
                else
                    throw new UTFException("BOM is for UTF-32 LE on Big Endian machine");
            }
            case utf32le:
            {
                version (BigEndian)
                    throw new UTFException("BOM is for UTF-32 BE on Little Endian machine");
                else
                    break;
            }
            default: break;
        }
    }

    if (data.length % ElementEncodingType!S.sizeof != 0)
        throw new UTFException(format!"The content of %s is not UTF-%s"(filename, ElementEncodingType!S.sizeof * 8));

    auto result = trustedCast!S(data);
    validate(result);
    return result;
}

/// Read file with UTF-8 text.
@safe unittest
{
    write(deleteme, "abc"); // deleteme is the name of a temporary file
    scope(exit) remove(deleteme);
    string content = readText(deleteme);
    assert(content == "abc");
}

// Read file with UTF-8 text but try to read it as UTF-16.
@safe unittest
{
    import std.exception : assertThrown;
    import std.utf : UTFException;

    write(deleteme, "abc");
    scope(exit) remove(deleteme);
    // Throws because the file is not valid UTF-16.
    assertThrown!UTFException(readText!wstring(deleteme));
}

// Read file with UTF-16 text.
@safe unittest
{
    import std.algorithm.searching : skipOver;

    write(deleteme, "\uFEFFabc"w); // With BOM
    scope(exit) remove(deleteme);
    auto content = readText!wstring(deleteme);
    assert(content == "\uFEFFabc"w);
    // Strips BOM if present.
    content.skipOver('\uFEFF');
    assert(content == "abc"w);
}

@safe unittest
{
    static assert(__traits(compiles, readText(TestAliasedString(null))));
}

@safe unittest
{
    import std.array : appender;
    import std.bitmanip : append, Endian;
    import std.exception : assertThrown;
    import std.path : buildPath;
    import std.string : representation;
    import std.utf : UTFException;

    mkdir(deleteme);
    scope(exit) rmdirRecurse(deleteme);

    immutable none8 = buildPath(deleteme, "none8");
    immutable none16 = buildPath(deleteme, "none16");
    immutable utf8 = buildPath(deleteme, "utf8");
    immutable utf16be = buildPath(deleteme, "utf16be");
    immutable utf16le = buildPath(deleteme, "utf16le");
    immutable utf32be = buildPath(deleteme, "utf32be");
    immutable utf32le = buildPath(deleteme, "utf32le");
    immutable utf7 = buildPath(deleteme, "utf7");

    write(none8, "京都市");
    write(none16, "京都市"w);
    write(utf8, (cast(char[])[0xEF, 0xBB, 0xBF]) ~ "京都市");
    {
        auto str = "\uFEFF京都市"w;
        auto arr = appender!(ubyte[])();
        foreach (c; str)
            arr.append(c);
        write(utf16be, arr.data);
    }
    {
        auto str = "\uFEFF京都市"w;
        auto arr = appender!(ubyte[])();
        foreach (c; str)
            arr.append!(ushort, Endian.littleEndian)(c);
        write(utf16le, arr.data);
    }
    {
        auto str = "\U0000FEFF京都市"d;
        auto arr = appender!(ubyte[])();
        foreach (c; str)
            arr.append(c);
        write(utf32be, arr.data);
    }
    {
        auto str = "\U0000FEFF京都市"d;
        auto arr = appender!(ubyte[])();
        foreach (c; str)
            arr.append!(uint, Endian.littleEndian)(c);
        write(utf32le, arr.data);
    }
    write(utf7, (cast(ubyte[])[0x2B, 0x2F, 0x76, 0x38, 0x2D]) ~ "foobar".representation);

    assertThrown!UTFException(readText(none16));
    assert(readText(utf8) == (cast(char[])[0xEF, 0xBB, 0xBF]) ~ "京都市");
    assertThrown!UTFException(readText(utf16be));
    assertThrown!UTFException(readText(utf16le));
    assertThrown!UTFException(readText(utf32be));
    assertThrown!UTFException(readText(utf32le));
    assert(readText(utf7) == (cast(char[])[0x2B, 0x2F, 0x76, 0x38, 0x2D]) ~ "foobar");

    assertThrown!UTFException(readText!wstring(none8));
    assert(readText!wstring(none16) == "京都市"w);
    assertThrown!UTFException(readText!wstring(utf8));
    version (BigEndian)
    {
        assert(readText!wstring(utf16be) == "\uFEFF京都市"w);
        assertThrown!UTFException(readText!wstring(utf16le));
    }
    else
    {
        assertThrown!UTFException(readText!wstring(utf16be));
        assert(readText!wstring(utf16le) == "\uFEFF京都市"w);
    }
    assertThrown!UTFException(readText!wstring(utf32be));
    assertThrown!UTFException(readText!wstring(utf32le));
    assertThrown!UTFException(readText!wstring(utf7));

    assertThrown!UTFException(readText!dstring(utf8));
    assertThrown!UTFException(readText!dstring(utf16be));
    assertThrown!UTFException(readText!dstring(utf16le));
    version (BigEndian)
    {
       assert(readText!dstring(utf32be) == "\U0000FEFF京都市"d);
       assertThrown!UTFException(readText!dstring(utf32le));
    }
    else
    {
       assertThrown!UTFException(readText!dstring(utf32be));
       assert(readText!dstring(utf32le) == "\U0000FEFF京都市"d);
    }
    assertThrown!UTFException(readText!dstring(utf7));
}

/*********************************************
Write `buffer` to file `name`.

Creates the file if it does not already exist.

Params:
    name = string or range of characters representing the file _name
    buffer = data to be written to file

Throws: $(LREF FileException) on error.

See_also: $(REF toFile, std,stdio)
 */
void write(R)(R name, const void[] buffer)
if ((isSomeFiniteCharInputRange!R || isSomeString!R) && !isConvertibleToString!R)
{
    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
        writeImpl(name, name.tempCString!FSChar(), buffer, false);
    else
        writeImpl(null, name.tempCString!FSChar(), buffer, false);
}

///
@safe unittest
{
   scope(exit)
   {
       assert(exists(deleteme));
       remove(deleteme);
   }

   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];
   write(deleteme, a); // deleteme is the name of a temporary file
   const bytes = read(deleteme);
   const fileInts = () @trusted { return cast(int[]) bytes; }();
   assert(fileInts == a);
}

/// ditto
void write(R)(auto ref R name, const void[] buffer)
if (isConvertibleToString!R)
{
    write!(StringTypeOf!R)(name, buffer);
}

@safe unittest
{
    static assert(__traits(compiles, write(TestAliasedString(null), null)));
}

/*********************************************
Appends `buffer` to file `name`.

Creates the file if it does not already exist.

Params:
    name = string or range of characters representing the file _name
    buffer = data to be appended to file

Throws: $(LREF FileException) on error.
 */
void append(R)(R name, const void[] buffer)
if ((isSomeFiniteCharInputRange!R || isSomeString!R) && !isConvertibleToString!R)
{
    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
        writeImpl(name, name.tempCString!FSChar(), buffer, true);
    else
        writeImpl(null, name.tempCString!FSChar(), buffer, true);
}

///
@safe unittest
{
   scope(exit)
   {
       assert(exists(deleteme));
       remove(deleteme);
   }

   int[] a = [ 0, 1, 1, 2, 3, 5, 8 ];
   write(deleteme, a); // deleteme is the name of a temporary file
   int[] b = [ 13, 21 ];
   append(deleteme, b);
   const bytes = read(deleteme);
   const fileInts = () @trusted { return cast(int[]) bytes; }();
   assert(fileInts == a ~ b);
}

/// ditto
void append(R)(auto ref R name, const void[] buffer)
if (isConvertibleToString!R)
{
    append!(StringTypeOf!R)(name, buffer);
}

@safe unittest
{
    static assert(__traits(compiles, append(TestAliasedString("foo"), [0, 1, 2, 3])));
}

// POSIX implementation helper for write and append

version (Posix) private void writeImpl(scope const(char)[] name, scope const(FSChar)* namez,
        scope const(void)[] buffer, bool append) @trusted
{
    import std.conv : octal;

    // append or write
    auto mode = append ? O_CREAT | O_WRONLY | O_APPEND
                       : O_CREAT | O_WRONLY | O_TRUNC;

    immutable fd = core.sys.posix.fcntl.open(namez, mode, octal!666);
    cenforce(fd != -1, name, namez);
    {
        scope(failure) core.sys.posix.unistd.close(fd);

        immutable size = buffer.length;
        size_t sum, cnt = void;
        while (sum != size)
        {
            cnt = (size - sum < 2^^30) ? (size - sum) : 2^^30;
            const numwritten = core.sys.posix.unistd.write(fd, buffer.ptr + sum, cnt);
            if (numwritten != cnt)
                break;
            sum += numwritten;
        }
        cenforce(sum == size, name, namez);
    }
    cenforce(core.sys.posix.unistd.close(fd) == 0, name, namez);
}

// Windows implementation helper for write and append

version (Windows) private void writeImpl(scope const(char)[] name, scope const(FSChar)* namez,
        scope const(void)[] buffer, bool append) @trusted
{
    HANDLE h;
    if (append)
    {
        alias defaults =
            AliasSeq!(GENERIC_WRITE, 0, null, OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                HANDLE.init);

        h = CreateFileW(namez, defaults);
        cenforce(h != INVALID_HANDLE_VALUE, name, namez);
        cenforce(SetFilePointer(h, 0, null, FILE_END) != INVALID_SET_FILE_POINTER,
            name, namez);
    }
    else // write
    {
        alias defaults =
            AliasSeq!(GENERIC_WRITE, 0, null, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                HANDLE.init);

        h = CreateFileW(namez, defaults);
        cenforce(h != INVALID_HANDLE_VALUE, name, namez);
    }
    immutable size = buffer.length;
    size_t sum, cnt = void;
    DWORD numwritten = void;
    while (sum != size)
    {
        cnt = (size - sum < 2^^30) ? (size - sum) : 2^^30;
        WriteFile(h, buffer.ptr + sum, cast(uint) cnt, &numwritten, null);
        if (numwritten != cnt)
            break;
        sum += numwritten;
    }
    cenforce(sum == size && CloseHandle(h), name, namez);
}

/***************************************************
 * Rename file `from` _to `to`, moving it between directories if required.
 * If the target file exists, it is overwritten.
 *
 * It is not possible to rename a file across different mount points
 * or drives. On POSIX, the operation is atomic. That means, if `to`
 * already exists there will be no time period during the operation
 * where `to` is missing. See
 * $(HTTP man7.org/linux/man-pages/man2/rename.2.html, manpage for rename)
 * for more details.
 *
 * Params:
 *    from = string or range of characters representing the existing file name
 *    to = string or range of characters representing the target file name
 *
 * Throws: $(LREF FileException) on error.
 */
void rename(RF, RT)(RF from, RT to)
if ((isSomeFiniteCharInputRange!RF || isSomeString!RF) && !isConvertibleToString!RF &&
    (isSomeFiniteCharInputRange!RT || isSomeString!RT) && !isConvertibleToString!RT)
{
    // Place outside of @trusted block
    auto fromz = from.tempCString!FSChar();
    auto toz = to.tempCString!FSChar();

    static if (isNarrowString!RF && is(immutable ElementEncodingType!RF == immutable char))
        alias f = from;
    else
        enum string f = null;

    static if (isNarrowString!RT && is(immutable ElementEncodingType!RT == immutable char))
        alias t = to;
    else
        enum string t = null;

    renameImpl(f, t, fromz, toz);
}

/// ditto
void rename(RF, RT)(auto ref RF from, auto ref RT to)
if (isConvertibleToString!RF || isConvertibleToString!RT)
{
    import std.meta : staticMap;
    alias Types = staticMap!(convertToString, RF, RT);
    rename!Types(from, to);
}

@safe unittest
{
    static assert(__traits(compiles, rename(TestAliasedString(null), TestAliasedString(null))));
    static assert(__traits(compiles, rename("", TestAliasedString(null))));
    static assert(__traits(compiles, rename(TestAliasedString(null), "")));
    import std.utf : byChar;
    static assert(__traits(compiles, rename(TestAliasedString(null), "".byChar)));
}

///
@safe unittest
{
    auto t1 = deleteme, t2 = deleteme~"2";
    scope(exit) foreach (t; [t1, t2]) if (t.exists) t.remove();

    t1.write("1");
    t1.rename(t2);
    assert(t2.readText == "1");

    t1.write("2");
    t1.rename(t2);
    assert(t2.readText == "2");
}

private void renameImpl(scope const(char)[] f, scope const(char)[] t,
                        scope const(FSChar)* fromz, scope const(FSChar)* toz) @trusted
{
    version (Windows)
    {
        import std.exception : enforce;

        const result = MoveFileExW(fromz, toz, MOVEFILE_REPLACE_EXISTING);
        if (!result)
        {
            import core.stdc.wchar_ : wcslen;
            import std.conv : to, text;

            if (!f)
                f = to!(typeof(f))(fromz[0 .. wcslen(fromz)]);

            if (!t)
                t = to!(typeof(t))(toz[0 .. wcslen(toz)]);

            enforce(false,
                new FileException(
                    text("Attempting to rename file ", f, " to ", t)));
        }
    }
    else version (Posix)
    {
        static import core.stdc.stdio;

        cenforce(core.stdc.stdio.rename(fromz, toz) == 0, t, toz);
    }
}

@safe unittest
{
    import std.utf : byWchar;

    auto t1 = deleteme, t2 = deleteme~"2";
    scope(exit) foreach (t; [t1, t2]) if (t.exists) t.remove();

    write(t1, "1");
    rename(t1, t2);
    assert(readText(t2) == "1");

    write(t1, "2");
    rename(t1, t2.byWchar);
    assert(readText(t2) == "2");
}

/***************************************************
Delete file `name`.

Params:
    name = string or range of characters representing the file _name

Throws: $(LREF FileException) on error.
 */
void remove(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
        removeImpl(name, name.tempCString!FSChar());
    else
        removeImpl(null, name.tempCString!FSChar());
}

/// ditto
void remove(R)(auto ref R name)
if (isConvertibleToString!R)
{
    remove!(StringTypeOf!R)(name);
}

///
@safe unittest
{
    import std.exception : assertThrown;

    deleteme.write("Hello");
    assert(deleteme.readText == "Hello");

    deleteme.remove;
    assertThrown!FileException(deleteme.readText);
}

@safe unittest
{
    static assert(__traits(compiles, remove(TestAliasedString("foo"))));
}

private void removeImpl(scope const(char)[] name, scope const(FSChar)* namez) @trusted
{
    version (Windows)
    {
        cenforce(DeleteFileW(namez), name, namez);
    }
    else version (Posix)
    {
        static import core.stdc.stdio;

        if (!name)
        {
            import core.stdc.string : strlen;

            auto len = namez ? strlen(namez) : 0;
            name = namez[0 .. len];
        }
        cenforce(core.stdc.stdio.remove(namez) == 0,
            "Failed to remove file " ~ (name is null ? "(null)" : name));
    }
}

@safe unittest
{
    import std.exception : collectExceptionMsg, assertThrown;

    string filename = null; // e.g. as returned by File.tmpfile.name

    version (linux)
    {
        // exact exception message is OS-dependent
        auto msg = filename.remove.collectExceptionMsg!FileException;
        assert("Failed to remove file (null): Bad address" == msg, msg);
    }
    else version (Windows)
    {
        import std.algorithm.searching : startsWith;

        // don't test exact message on windows, it's language dependent
        auto msg = filename.remove.collectExceptionMsg!FileException;
        assert(msg.startsWith("(null):"), msg);
    }
    else
    {
        assertThrown!FileException(filename.remove);
    }
}

version (Windows) private WIN32_FILE_ATTRIBUTE_DATA getFileAttributesWin(R)(R name)
if (isSomeFiniteCharInputRange!R)
{
    auto namez = name.tempCString!FSChar();

    WIN32_FILE_ATTRIBUTE_DATA fad = void;

    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
    {
        static void getFA(scope const(char)[] name, scope const(FSChar)* namez,
                          out WIN32_FILE_ATTRIBUTE_DATA fad) @trusted
        {
            import std.exception : enforce;
            enforce(GetFileAttributesExW(namez, GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard, &fad),
                new FileException(name.idup));
        }
        getFA(name, namez, fad);
    }
    else
    {
        static void getFA(scope const(FSChar)* namez, out WIN32_FILE_ATTRIBUTE_DATA fad) @trusted
        {
            import core.stdc.wchar_ : wcslen;
            import std.conv : to;
            import std.exception : enforce;

            enforce(GetFileAttributesExW(namez, GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard, &fad),
                new FileException(namez[0 .. wcslen(namez)].to!string));
        }
        getFA(namez, fad);
    }
    return fad;
}

version (Windows) private ulong makeUlong(DWORD dwLow, DWORD dwHigh) @safe pure nothrow @nogc
{
    ULARGE_INTEGER li;
    li.LowPart  = dwLow;
    li.HighPart = dwHigh;
    return li.QuadPart;
}

version (Posix) private extern (C) pragma(mangle, stat.mangleof)
int trustedStat(scope const(FSChar)* namez, ref stat_t buf) @nogc nothrow @trusted;

/**
Get size of file `name` in bytes.

Params:
    name = string or range of characters representing the file _name
Returns:
    The size of file in bytes.
Throws:
    $(LREF FileException) on error (e.g., file not found).
 */
ulong getSize(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        with (getFileAttributesWin(name))
            return makeUlong(nFileSizeLow, nFileSizeHigh);
    }
    else version (Posix)
    {
        auto namez = name.tempCString();

        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        stat_t statbuf = void;
        cenforce(trustedStat(namez, statbuf) == 0, names, namez);
        return statbuf.st_size;
    }
}

/// ditto
ulong getSize(R)(auto ref R name)
if (isConvertibleToString!R)
{
    return getSize!(StringTypeOf!R)(name);
}

@safe unittest
{
    static assert(__traits(compiles, getSize(TestAliasedString("foo"))));
}

///
@safe unittest
{
    scope(exit) deleteme.remove;

    // create a file of size 1
    write(deleteme, "a");
    assert(getSize(deleteme) == 1);

    // create a file of size 3
    write(deleteme, "abc");
    assert(getSize(deleteme) == 3);
}

@safe unittest
{
    // create a file of size 1
    write(deleteme, "a");
    scope(exit) deleteme.exists && deleteme.remove;
    assert(getSize(deleteme) == 1);
    // create a file of size 3
    write(deleteme, "abc");
    import std.utf : byChar;
    assert(getSize(deleteme.byChar) == 3);
}

// Reads a time field from a stat_t with full precision.
version (Posix)
private SysTime statTimeToStdTime(char which)(ref const stat_t statbuf)
{
    auto unixTime = mixin(`statbuf.st_` ~ which ~ `time`);
    long stdTime = unixTimeToStdTime(unixTime);

    static if (is(typeof(mixin(`statbuf.st_` ~ which ~ `tim`))))
        stdTime += mixin(`statbuf.st_` ~ which ~ `tim.tv_nsec`) / 100;
    else
    static if (is(typeof(mixin(`statbuf.st_` ~ which ~ `timensec`))))
        stdTime += mixin(`statbuf.st_` ~ which ~ `timensec`) / 100;
    else
    static if (is(typeof(mixin(`statbuf.st_` ~ which ~ `time_nsec`))))
        stdTime += mixin(`statbuf.st_` ~ which ~ `time_nsec`) / 100;
    else
    static if (is(typeof(mixin(`statbuf.__st_` ~ which ~ `timensec`))))
        stdTime += mixin(`statbuf.__st_` ~ which ~ `timensec`) / 100;

    return SysTime(stdTime);
}

/++
    Get the access and modified times of file or folder `name`.

    Params:
        name             = File/Folder _name to get times for.
        accessTime       = Time the file/folder was last accessed.
        modificationTime = Time the file/folder was last modified.

    Throws:
        $(LREF FileException) on error.
 +/
void getTimes(R)(R name,
              out SysTime accessTime,
              out SysTime modificationTime)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        import std.datetime.systime : FILETIMEToSysTime;

        with (getFileAttributesWin(name))
        {
            accessTime = FILETIMEToSysTime(&ftLastAccessTime);
            modificationTime = FILETIMEToSysTime(&ftLastWriteTime);
        }
    }
    else version (Posix)
    {
        auto namez = name.tempCString();

        stat_t statbuf = void;

        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(trustedStat(namez, statbuf) == 0, names, namez);

        accessTime = statTimeToStdTime!'a'(statbuf);
        modificationTime = statTimeToStdTime!'m'(statbuf);
    }
}

/// ditto
void getTimes(R)(auto ref R name,
              out SysTime accessTime,
              out SysTime modificationTime)
if (isConvertibleToString!R)
{
    return getTimes!(StringTypeOf!R)(name, accessTime, modificationTime);
}

///
@safe unittest
{
    import std.datetime : abs, SysTime;

    scope(exit) deleteme.remove;
    write(deleteme, "a");

    SysTime accessTime, modificationTime;

    getTimes(deleteme, accessTime, modificationTime);

    import std.datetime : Clock, seconds;
    auto currTime = Clock.currTime();
    enum leeway = 5.seconds;

    auto diffAccess = accessTime - currTime;
    auto diffModification = modificationTime - currTime;
    assert(abs(diffAccess) <= leeway);
    assert(abs(diffModification) <= leeway);
}

@safe unittest
{
    SysTime atime, mtime;
    static assert(__traits(compiles, getTimes(TestAliasedString("foo"), atime, mtime)));
}

@safe unittest
{
    import std.stdio : writefln;

    auto currTime = Clock.currTime();

    write(deleteme, "a");
    scope(exit) assert(deleteme.exists), deleteme.remove;

    SysTime accessTime1;
    SysTime modificationTime1;

    getTimes(deleteme, accessTime1, modificationTime1);

    enum leeway = 5.seconds;

    {
        auto diffa = accessTime1 - currTime;
        auto diffm = modificationTime1 - currTime;
        scope(failure) writefln("[%s] [%s] [%s] [%s] [%s]", accessTime1, modificationTime1, currTime, diffa, diffm);

        assert(abs(diffa) <= leeway);
        assert(abs(diffm) <= leeway);
    }

    version (fullFileTests)
    {
        import core.thread;
        enum sleepTime = dur!"seconds"(2);
        Thread.sleep(sleepTime);

        currTime = Clock.currTime();
        write(deleteme, "b");

        SysTime accessTime2 = void;
        SysTime modificationTime2 = void;

        getTimes(deleteme, accessTime2, modificationTime2);

        {
            auto diffa = accessTime2 - currTime;
            auto diffm = modificationTime2 - currTime;
            scope(failure) writefln("[%s] [%s] [%s] [%s] [%s]", accessTime2, modificationTime2, currTime, diffa, diffm);

            //There is no guarantee that the access time will be updated.
            assert(abs(diffa) <= leeway + sleepTime);
            assert(abs(diffm) <= leeway);
        }

        assert(accessTime1 <= accessTime2);
        assert(modificationTime1 <= modificationTime2);
    }
}


version (StdDdoc)
{
    /++
     $(BLUE This function is Windows-Only.)

     Get creation/access/modified times of file `name`.

     This is the same as `getTimes` except that it also gives you the file
     creation time - which isn't possible on POSIX systems.

     Params:
     name                 = File _name to get times for.
     fileCreationTime     = Time the file was created.
     fileAccessTime       = Time the file was last accessed.
     fileModificationTime = Time the file was last modified.

     Throws:
     $(LREF FileException) on error.
     +/
    void getTimesWin(R)(R name,
                        out SysTime fileCreationTime,
                        out SysTime fileAccessTime,
                        out SysTime fileModificationTime)
    if (isSomeFiniteCharInputRange!R || isConvertibleToString!R);
    // above line contains both constraints for docs
    // (so users know how it can be called)
}
else version (Windows)
{
    void getTimesWin(R)(R name,
                        out SysTime fileCreationTime,
                        out SysTime fileAccessTime,
                        out SysTime fileModificationTime)
    if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
    {
        import std.datetime.systime : FILETIMEToSysTime;

        with (getFileAttributesWin(name))
        {
            fileCreationTime = FILETIMEToSysTime(&ftCreationTime);
            fileAccessTime = FILETIMEToSysTime(&ftLastAccessTime);
            fileModificationTime = FILETIMEToSysTime(&ftLastWriteTime);
        }
    }

    void getTimesWin(R)(auto ref R name,
                        out SysTime fileCreationTime,
                        out SysTime fileAccessTime,
                        out SysTime fileModificationTime)
    if (isConvertibleToString!R)
    {
        getTimesWin!(StringTypeOf!R)(name, fileCreationTime, fileAccessTime, fileModificationTime);
    }
}

version (Windows) @system unittest
{
    import std.stdio : writefln;
    auto currTime = Clock.currTime();

    write(deleteme, "a");
    scope(exit) { assert(exists(deleteme)); remove(deleteme); }

    SysTime creationTime1 = void;
    SysTime accessTime1 = void;
    SysTime modificationTime1 = void;

    getTimesWin(deleteme, creationTime1, accessTime1, modificationTime1);

    enum leeway = dur!"seconds"(5);

    {
        auto diffc = creationTime1 - currTime;
        auto diffa = accessTime1 - currTime;
        auto diffm = modificationTime1 - currTime;
        scope(failure)
        {
            writefln("[%s] [%s] [%s] [%s] [%s] [%s] [%s]",
                     creationTime1, accessTime1, modificationTime1, currTime, diffc, diffa, diffm);
        }

        // Deleting and recreating a file doesn't seem to always reset the "file creation time"
        //assert(abs(diffc) <= leeway);
        assert(abs(diffa) <= leeway);
        assert(abs(diffm) <= leeway);
    }

    version (fullFileTests)
    {
        import core.thread;
        Thread.sleep(dur!"seconds"(2));

        currTime = Clock.currTime();
        write(deleteme, "b");

        SysTime creationTime2 = void;
        SysTime accessTime2 = void;
        SysTime modificationTime2 = void;

        getTimesWin(deleteme, creationTime2, accessTime2, modificationTime2);

        {
            auto diffa = accessTime2 - currTime;
            auto diffm = modificationTime2 - currTime;
            scope(failure)
            {
                writefln("[%s] [%s] [%s] [%s] [%s]",
                         accessTime2, modificationTime2, currTime, diffa, diffm);
            }

            assert(abs(diffa) <= leeway);
            assert(abs(diffm) <= leeway);
        }

        assert(creationTime1 == creationTime2);
        assert(accessTime1 <= accessTime2);
        assert(modificationTime1 <= modificationTime2);
    }

    {
        SysTime ctime, atime, mtime;
        static assert(__traits(compiles, getTimesWin(TestAliasedString("foo"), ctime, atime, mtime)));
    }
}

version (Darwin)
private
{
    import core.stdc.config : c_ulong;
    enum ATTR_CMN_MODTIME  = 0x00000400, ATTR_CMN_ACCTIME  = 0x00001000;
    alias attrgroup_t = uint;
    static struct attrlist
    {
        ushort bitmapcount, reserved;
        attrgroup_t commonattr, volattr, dirattr, fileattr, forkattr;
    }
    extern(C) int setattrlist(scope const(char)* path, scope ref attrlist attrs,
        scope void* attrbuf, size_t attrBufSize, c_ulong options) nothrow @nogc @system;
}

/++
    Set access/modified times of file or folder `name`.

    Params:
        name             = File/Folder _name to get times for.
        accessTime       = Time the file/folder was last accessed.
        modificationTime = Time the file/folder was last modified.

    Throws:
        $(LREF FileException) on error.
 +/
void setTimes(R)(R name,
              SysTime accessTime,
              SysTime modificationTime)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    auto namez = name.tempCString!FSChar();
    static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
        alias names = name;
    else
        string names = null;
    setTimesImpl(names, namez, accessTime, modificationTime);
}

///
@safe unittest
{
    import std.datetime : DateTime, hnsecs, SysTime;

    scope(exit) deleteme.remove;
    write(deleteme, "a");

    SysTime accessTime = SysTime(DateTime(2010, 10, 4, 0, 0, 30));
    SysTime modificationTime = SysTime(DateTime(2018, 10, 4, 0, 0, 30));
    setTimes(deleteme, accessTime, modificationTime);

    SysTime accessTimeResolved, modificationTimeResolved;
    getTimes(deleteme, accessTimeResolved, modificationTimeResolved);

    assert(accessTime == accessTimeResolved);
    assert(modificationTime == modificationTimeResolved);
}

/// ditto
void setTimes(R)(auto ref R name,
              SysTime accessTime,
              SysTime modificationTime)
if (isConvertibleToString!R)
{
    setTimes!(StringTypeOf!R)(name, accessTime, modificationTime);
}

private void setTimesImpl(scope const(char)[] names, scope const(FSChar)* namez,
    SysTime accessTime, SysTime modificationTime) @trusted
{
    version (Windows)
    {
        import std.datetime.systime : SysTimeToFILETIME;
        const ta = SysTimeToFILETIME(accessTime);
        const tm = SysTimeToFILETIME(modificationTime);
        alias defaults =
            AliasSeq!(FILE_WRITE_ATTRIBUTES,
                      0,
                      null,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL |
                      FILE_ATTRIBUTE_DIRECTORY |
                      FILE_FLAG_BACKUP_SEMANTICS,
                      HANDLE.init);
        auto h = CreateFileW(namez, defaults);

        cenforce(h != INVALID_HANDLE_VALUE, names, namez);

        scope(exit)
            cenforce(CloseHandle(h), names, namez);

        cenforce(SetFileTime(h, null, &ta, &tm), names, namez);
    }
    else
    {
        static if (is(typeof(&utimensat)))
        {
            timespec[2] t = void;
            t[0] = accessTime.toTimeSpec();
            t[1] = modificationTime.toTimeSpec();
            cenforce(utimensat(AT_FDCWD, namez, t, 0) == 0, names, namez);
        }
        else
        {
            version (Darwin)
            {
                // Set modification & access times with setattrlist to avoid precision loss.
                attrlist attrs = { bitmapcount: 5, reserved: 0,
                        commonattr: ATTR_CMN_MODTIME | ATTR_CMN_ACCTIME,
                        volattr: 0, dirattr: 0, fileattr: 0, forkattr: 0 };
                timespec[2] attrbuf = [modificationTime.toTimeSpec(), accessTime.toTimeSpec()];
                if (0 == setattrlist(namez, attrs, &attrbuf, attrbuf.sizeof, 0))
                    return;
                if (.errno != ENOTSUP)
                    cenforce(false, names, namez);
                // Not all volumes support setattrlist. In such cases
                // fall through to the utimes implementation.
            }
            timeval[2] t = void;
            t[0] = accessTime.toTimeVal();
            t[1] = modificationTime.toTimeVal();
            cenforce(utimes(namez, t) == 0, names, namez);
        }
    }
}

@safe unittest
{
    if (false) // Test instatiation
        setTimes(TestAliasedString("foo"), SysTime.init, SysTime.init);
}

@safe unittest
{
    import std.stdio : File;
    string newdir = deleteme ~ r".dir";
    string dir = newdir ~ r"/a/b/c";
    string file = dir ~ "/file";

    if (!exists(dir)) mkdirRecurse(dir);
    { auto f = File(file, "w"); }

    void testTimes(int hnsecValue)
    {
        foreach (path; [file, dir])  // test file and dir
        {
            SysTime atime = SysTime(DateTime(2010, 10, 4, 0, 0, 30), hnsecs(hnsecValue));
            SysTime mtime = SysTime(DateTime(2011, 10, 4, 0, 0, 30), hnsecs(hnsecValue));
            setTimes(path, atime, mtime);

            SysTime atime_res;
            SysTime mtime_res;
            getTimes(path, atime_res, mtime_res);
            assert(atime == atime_res);
            assert(mtime == mtime_res);
        }
    }

    testTimes(0);
    version (linux)
        testTimes(123_456_7);

    rmdirRecurse(newdir);
}

// https://issues.dlang.org/show_bug.cgi?id=23683
@safe unittest
{
    scope(exit) deleteme.remove;
    import std.stdio : File;
    auto f = File(deleteme, "wb");
    SysTime time = SysTime(DateTime(2018, 10, 4, 0, 0, 30));
    setTimes(deleteme, time, time);
}

/++
    Returns the time that the given file was last modified.

    Params:
        name = the name of the file to check
    Returns:
        A $(REF SysTime,std,datetime,systime).
    Throws:
        $(LREF FileException) if the given file does not exist.
+/
SysTime timeLastModified(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        SysTime dummy;
        SysTime ftm;

        getTimesWin(name, dummy, dummy, ftm);

        return ftm;
    }
    else version (Posix)
    {
        auto namez = name.tempCString!FSChar();
        stat_t statbuf = void;

        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(trustedStat(namez, statbuf) == 0, names, namez);

        return statTimeToStdTime!'m'(statbuf);
    }
}

/// ditto
SysTime timeLastModified(R)(auto ref R name)
if (isConvertibleToString!R)
{
    return timeLastModified!(StringTypeOf!R)(name);
}

///
@safe unittest
{
    import std.datetime : abs, DateTime, hnsecs, SysTime;
    scope(exit) deleteme.remove;

    import std.datetime : Clock, seconds;
    auto currTime = Clock.currTime();
    enum leeway = 5.seconds;
    deleteme.write("bb");
    assert(abs(deleteme.timeLastModified - currTime) <= leeway);
}

@safe unittest
{
    static assert(__traits(compiles, timeLastModified(TestAliasedString("foo"))));
}

/++
    Returns the time that the given file was last modified. If the
    file does not exist, returns `returnIfMissing`.

    A frequent usage pattern occurs in build automation tools such as
    $(HTTP gnu.org/software/make, make) or $(HTTP
    en.wikipedia.org/wiki/Apache_Ant, ant). To check whether file $(D
    target) must be rebuilt from file `source` (i.e., `target` is
    older than `source` or does not exist), use the comparison
    below. The code throws a $(LREF FileException) if `source` does not
    exist (as it should). On the other hand, the `SysTime.min` default
    makes a non-existing `target` seem infinitely old so the test
    correctly prompts building it.

    Params:
        name = The name of the file to get the modification time for.
        returnIfMissing = The time to return if the given file does not exist.
    Returns:
        A $(REF SysTime,std,datetime,systime).

Example:
--------------------
if (source.timeLastModified >= target.timeLastModified(SysTime.min))
{
    // must (re)build
}
else
{
    // target is up-to-date
}
--------------------
+/
SysTime timeLastModified(R)(R name, SysTime returnIfMissing)
if (isSomeFiniteCharInputRange!R)
{
    version (Windows)
    {
        if (!exists(name))
            return returnIfMissing;

        SysTime dummy;
        SysTime ftm;

        getTimesWin(name, dummy, dummy, ftm);

        return ftm;
    }
    else version (Posix)
    {
        auto namez = name.tempCString!FSChar();
        stat_t statbuf = void;

        return trustedStat(namez, statbuf) != 0 ?
               returnIfMissing :
               statTimeToStdTime!'m'(statbuf);
    }
}

///
@safe unittest
{
    import std.datetime : SysTime;

    assert("file.does.not.exist".timeLastModified(SysTime.min) == SysTime.min);

    auto source = deleteme ~ "source";
    auto target = deleteme ~ "target";
    scope(exit) source.remove, target.remove;

    source.write(".");
    assert(target.timeLastModified(SysTime.min) < source.timeLastModified);
    target.write(".");
    assert(target.timeLastModified(SysTime.min) >= source.timeLastModified);
}

version (StdDdoc)
{
    /++
     $(BLUE This function is POSIX-Only.)

     Returns the time that the given file was last modified.
     Params:
        statbuf = stat_t retrieved from file.
     +/
    SysTime timeLastModified()(auto ref stat_t statbuf) pure nothrow {assert(false);}
    /++
     $(BLUE This function is POSIX-Only.)

     Returns the time that the given file was last accessed.
     Params:
        statbuf = stat_t retrieved from file.
     +/
    SysTime timeLastAccessed()(auto ref stat_t statbuf) pure nothrow {assert(false);}
    /++
     $(BLUE This function is POSIX-Only.)

     Returns the time that the given file was last changed.
     Params:
        statbuf = stat_t retrieved from file.
     +/
    SysTime timeStatusChanged()(auto ref stat_t statbuf) pure nothrow {assert(false);}
}
else version (Posix)
{
    SysTime timeLastModified()(auto ref stat_t statbuf) pure nothrow
    {
        return statTimeToStdTime!'m'(statbuf);
    }
    SysTime timeLastAccessed()(auto ref stat_t statbuf) pure nothrow
    {
        return statTimeToStdTime!'a'(statbuf);
    }
    SysTime timeStatusChanged()(auto ref stat_t statbuf) pure nothrow
    {
        return statTimeToStdTime!'c'(statbuf);
    }

    @safe unittest
    {
        stat_t statbuf;
        // check that both lvalues and rvalues work
        timeLastAccessed(statbuf);
        cast(void) timeLastAccessed(stat_t.init);
    }
}

@safe unittest
{
    //std.process.executeShell("echo a > deleteme");
    if (exists(deleteme))
        remove(deleteme);

    write(deleteme, "a\n");

    scope(exit)
    {
        assert(exists(deleteme));
        remove(deleteme);
    }

    // assert(lastModified("deleteme") >
    //         lastModified("this file does not exist", SysTime.min));
    //assert(lastModified("deleteme") > lastModified(__FILE__));
}


// Tests sub-second precision of querying file times.
// Should pass on most modern systems running on modern filesystems.
// Exceptions:
// - FreeBSD, where one would need to first set the
//   vfs.timestamp_precision sysctl to a value greater than zero.
// - OS X, where the native filesystem (HFS+) stores filesystem
//   timestamps with 1-second precision.
//
// Note: on linux systems, although in theory a change to a file date
// can be tracked with precision of 4 msecs, this test waits 20 msecs
// to prevent possible problems relative to the CI services the dlang uses,
// as they may have the HZ setting that controls the software clock set to 100
// (instead of the more common 250).
// see https://man7.org/linux/man-pages/man7/time.7.html
//     https://stackoverflow.com/a/14393315,
//     https://issues.dlang.org/show_bug.cgi?id=21148
version (FreeBSD) {} else
version (DragonFlyBSD) {} else
version (OSX) {} else
@safe unittest
{
    import core.thread;

    if (exists(deleteme))
        remove(deleteme);

    SysTime lastTime;
    foreach (n; 0 .. 3)
    {
        write(deleteme, "a");
        auto time = timeLastModified(deleteme);
        remove(deleteme);
        assert(time != lastTime);
        lastTime = time;
        () @trusted { Thread.sleep(20.msecs); }();
    }
}


/**
 * Determine whether the given file (or directory) _exists.
 * Params:
 *    name = string or range of characters representing the file _name
 * Returns:
 *    true if the file _name specified as input _exists
 */
bool exists(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    return existsImpl(name.tempCString!FSChar());
}

/// ditto
bool exists(R)(auto ref R name)
if (isConvertibleToString!R)
{
    return exists!(StringTypeOf!R)(name);
}

///
@safe unittest
{
    auto f = deleteme ~ "does.not.exist";
    assert(!f.exists);

    f.write("hello");
    assert(f.exists);

    f.remove;
    assert(!f.exists);
}

private bool existsImpl(scope const(FSChar)* namez) @trusted nothrow @nogc
{
    version (Windows)
    {
        // http://msdn.microsoft.com/library/default.asp?url=/library/en-us/
        // fileio/base/getfileattributes.asp
        return GetFileAttributesW(namez) != 0xFFFFFFFF;
    }
    else version (Posix)
    {
        /*
            The reason why we use stat (and not access) here is
            the quirky behavior of access for SUID programs: if
            we used access, a file may not appear to "exist",
            despite that the program would be able to open it
            just fine. The behavior in question is described as
            follows in the access man page:

            > The check is done using the calling process's real
            > UID and GID, rather than the effective IDs as is
            > done when actually attempting an operation (e.g.,
            > open(2)) on the file. This allows set-user-ID
            > programs to easily determine the invoking user's
            > authority.

            While various operating systems provide eaccess or
            euidaccess functions, these are not part of POSIX -
            so it's safer to use stat instead.
        */

        stat_t statbuf = void;
        return lstat(namez, &statbuf) == 0;
    }
    else
        static assert(0);
}

///
@safe unittest
{
    assert(".".exists);
    assert(!"this file does not exist".exists);
    deleteme.write("a\n");
    scope(exit) deleteme.remove;
    assert(deleteme.exists);
}

// https://issues.dlang.org/show_bug.cgi?id=16573
@safe unittest
{
    enum S : string { foo = "foo" }
    assert(__traits(compiles, S.foo.exists));
}

/++
 Returns the attributes of the given file.

 Note that the file attributes on Windows and POSIX systems are
 completely different. On Windows, they're what is returned by
 $(HTTP msdn.microsoft.com/en-us/library/aa364944(v=vs.85).aspx,
 GetFileAttributes), whereas on POSIX systems, they're the
 `st_mode` value which is part of the $(D stat struct) gotten by
 calling the $(HTTP en.wikipedia.org/wiki/Stat_%28Unix%29, `stat`)
 function.

 On POSIX systems, if the given file is a symbolic link, then
 attributes are the attributes of the file pointed to by the symbolic
 link.

 Params:
    name = The file to get the attributes of.
 Returns:
    The attributes of the file as a `uint`.
 Throws: $(LREF FileException) on error.
  +/
uint getAttributes(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        auto namez = name.tempCString!FSChar();
        static auto trustedGetFileAttributesW(scope const(FSChar)* namez) @trusted
        {
            return GetFileAttributesW(namez);
        }
        immutable result = trustedGetFileAttributesW(namez);

        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(result != INVALID_FILE_ATTRIBUTES, names, namez);

        return result;
    }
    else version (Posix)
    {
        auto namez = name.tempCString!FSChar();
        stat_t statbuf = void;

        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(trustedStat(namez, statbuf) == 0, names, namez);

        return statbuf.st_mode;
    }
}

/// ditto
uint getAttributes(R)(auto ref R name)
if (isConvertibleToString!R)
{
    return getAttributes!(StringTypeOf!R)(name);
}

/// getAttributes with a file
@safe unittest
{
    import std.exception : assertThrown;

    auto f = deleteme ~ "file";
    scope(exit) f.remove;

    assert(!f.exists);
    assertThrown!FileException(f.getAttributes);

    f.write(".");
    auto attributes = f.getAttributes;
    assert(!attributes.attrIsDir);
    assert(attributes.attrIsFile);
}

/// getAttributes with a directory
@safe unittest
{
    import std.exception : assertThrown;

    auto dir = deleteme ~ "dir";
    scope(exit) dir.rmdir;

    assert(!dir.exists);
    assertThrown!FileException(dir.getAttributes);

    dir.mkdir;
    auto attributes = dir.getAttributes;
    assert(attributes.attrIsDir);
    assert(!attributes.attrIsFile);
}

@safe unittest
{
    static assert(__traits(compiles, getAttributes(TestAliasedString(null))));
}

/++
    If the given file is a symbolic link, then this returns the attributes of the
    symbolic link itself rather than file that it points to. If the given file
    is $(I not) a symbolic link, then this function returns the same result
    as getAttributes.

    On Windows, getLinkAttributes is identical to getAttributes. It exists on
    Windows so that you don't have to special-case code for Windows when dealing
    with symbolic links.

    Params:
        name = The file to get the symbolic link attributes of.

    Returns:
        the attributes

    Throws:
        $(LREF FileException) on error.
 +/
uint getLinkAttributes(R)(R name)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        return getAttributes(name);
    }
    else version (Posix)
    {
        auto namez = name.tempCString!FSChar();
        static auto trustedLstat(const(FSChar)* namez, ref stat_t buf) @trusted
        {
            return lstat(namez, &buf);
        }
        stat_t lstatbuf = void;
        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(trustedLstat(namez, lstatbuf) == 0, names, namez);
        return lstatbuf.st_mode;
    }
}

/// ditto
uint getLinkAttributes(R)(auto ref R name)
if (isConvertibleToString!R)
{
    return getLinkAttributes!(StringTypeOf!R)(name);
}

///
@safe unittest
{
    import std.exception : assertThrown;

    auto source = deleteme ~ "source";
    auto target = deleteme ~ "target";

    assert(!source.exists);
    assertThrown!FileException(source.getLinkAttributes);

    // symlinking isn't available on Windows
    version (Posix)
    {
        scope(exit) source.remove, target.remove;

        target.write("target");
        target.symlink(source);
        assert(source.readText == "target");
        assert(source.isSymlink);
        assert(source.getLinkAttributes.attrIsSymlink);
    }
}

/// if the file is no symlink, getLinkAttributes behaves like getAttributes
@safe unittest
{
    import std.exception : assertThrown;

    auto f = deleteme ~ "file";
    scope(exit) f.remove;

    assert(!f.exists);
    assertThrown!FileException(f.getLinkAttributes);

    f.write(".");
    auto attributes = f.getLinkAttributes;
    assert(!attributes.attrIsDir);
    assert(attributes.attrIsFile);
}

/// if the file is no symlink, getLinkAttributes behaves like getAttributes
@safe unittest
{
    import std.exception : assertThrown;

    auto dir = deleteme ~ "dir";
    scope(exit) dir.rmdir;

    assert(!dir.exists);
    assertThrown!FileException(dir.getLinkAttributes);

    dir.mkdir;
    auto attributes = dir.getLinkAttributes;
    assert(attributes.attrIsDir);
    assert(!attributes.attrIsFile);
}

@safe unittest
{
    static assert(__traits(compiles, getLinkAttributes(TestAliasedString(null))));
}

/++
    Set the _attributes of the given file.

    For example, a programmatic equivalent of Unix's `chmod +x name`
    to make a file executable is
    `name.setAttributes(name.getAttributes | octal!700)`.

    Params:
        name = the file _name
        attributes = the _attributes to set the file to

    Throws:
        $(LREF FileException) if the given file does not exist.
 +/
void setAttributes(R)(R name, uint attributes)
if (isSomeFiniteCharInputRange!R && !isConvertibleToString!R)
{
    version (Windows)
    {
        auto namez = name.tempCString!FSChar();
        static auto trustedSetFileAttributesW(scope const(FSChar)* namez, uint dwFileAttributes) @trusted
        {
            return SetFileAttributesW(namez, dwFileAttributes);
        }
        static if (isNarrowString!R && is(immutable ElementEncodingType!R == immutable char))
            alias names = name;
        else
            string names = null;
        cenforce(trustedSetFileAttributesW(namez, attributes), names, namez);
    }
    else version (Posix)
    {
        auto namez = name.tempC// Written in the D programming language.

/*
   Helper functions for formatting floating point numbers.

   Copyright: Copyright The D Language Foundation 2019 -

   License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

   Authors: Bernhard Seckinger

   Source: $(PHOBOSSRC std/format/internal/floats.d)
 */

module std.format.internal.floats;

import std.format.spec : FormatSpec;

// wrapper for unittests
private auto printFloat(T, Char)(const(T) val, FormatSpec!Char f)
if (is(T == float) || is(T == double)
    || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
{
    import std.array : appender;
    auto w = appender!string();

    printFloat(w, val, f);
    return w.data;
}

/// Returns: whether `c` is a supported format specifier for floats
package(std.format) bool isFloatSpec(char c) nothrow @nogc pure @safe
{
    return c == 'a' || c == 'A'
           || c == 'e' || c == 'E'
           || c == 'f' || c == 'F'
           || c == 'g' || c == 'G';
}

package(std.format) void printFloat(Writer, T, Char)(auto ref Writer w, const(T) val, FormatSpec!Char f)
if (is(T == float) || is(T == double)
    || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
{
    import std.math.operations : extractBitpattern, FloatingPointBitpattern;

    auto bp = extractBitpattern(val);

    ulong mnt = bp.mantissa;
    int exp = bp.exponent;
    string sgn = bp.negative ? "-" : "";

    if (sgn == "" && f.flPlus) sgn = "+";
    if (sgn == "" && f.flSpace) sgn = " ";

    assert(isFloatSpec(f.spec), "unsupported format specifier");
    bool is_upper = f.spec == 'A' || f.spec == 'E' || f.spec=='F' || f.spec=='G';

    // special treatment for nan and inf
    if (exp == T.max_exp)
    {
        import std.format.internal.write : writeAligned;

        f.flZero = false;
        writeAligned(w, sgn, "", (mnt == 0) ? ( is_upper ? "INF" : "inf" ) : ( is_upper ? "NAN" : "nan" ), f);
        return;
    }

    final switch (f.spec)
    {
        case 'a': case 'A':
            printFloatA(w, val, f, sgn, exp, mnt, is_upper);
            break;
        case 'e': case 'E':
            printFloatE!false(w, val, f, sgn, exp, mnt, is_upper);
            break;
        case 'f': case 'F':
            printFloatF!false(w, val, f, sgn, exp, mnt, is_upper);
            break;
        case 'g': case 'G':
            printFloatG(w, val, f, sgn, exp, mnt, is_upper);
            break;
    }
}

private void printFloatA(Writer, T, Char)(auto ref Writer w, const(T) val,
    FormatSpec!Char f, string sgn, int exp, ulong mnt, bool is_upper)
if (is(T == float) || is(T == double)
    || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
{
    import std.algorithm.comparison : max;
    import std.format.internal.write : writeAligned, PrecisionType;

    char[3] prefix;
    if (sgn != "") prefix[0] = sgn[0];
    prefix[1] = '0';
    prefix[2] = is_upper ? 'X' : 'x';

    // print exponent
    if (mnt == 0)
    {
        if (f.precision == f.UNSPECIFIED)
            f.precision = 0;
        writeAligned(w, prefix[1 - sgn.length .. $], "0", ".", is_upper ? "P+0" : "p+0",
                     f, PrecisionType.fractionalDigits);
        return;
    }

    // save integer part
    char first = '0' + ((mnt >> (T.mant_dig - 1)) & 1);
    mnt &= (1L << (T.mant_dig - 1)) - 1;

    static if (is(T == float) || (is(T == real) && T.mant_dig == 64))
    {
        mnt <<= 1; // make mnt dividable by 4
        enum mant_len = T.mant_dig;
    }
    else
        enum mant_len = T.mant_dig - 1;
    static assert(mant_len % 4 == 0, "mantissa with wrong length");

    // print full mantissa
    char[(mant_len - 1) / 4 + 3] hex_mant;
    size_t hex_mant_pos = 2;
    size_t pos = mant_len;

    auto gap = 39 - 32 * is_upper;
    while (pos >= 4 && (mnt & (((1L << (pos - 1)) - 1) << 1) + 1) != 0)
    {
        pos -= 4;
        size_t tmp = (mnt >> pos) & 15;
        // For speed reasons the better readable
        // ... = tmp < 10 ? ('0' + tmp) : ((is_upper ? 'A' : 'a') + tmp - 10))
        // has been replaced with an expression without branches, doing the same
        hex_mant[hex_mant_pos++] = cast(char) (tmp + gap * ((tmp + 6) >> 4) + '0');
    }
    hex_mant[0] = first;
    hex_mant[1] = '.';

    if (f.precision == f.UNSPECIFIED)
        f.precision = cast(int) hex_mant_pos - 2;

    auto exp_sgn = exp >= 0 ? '+' : '-';
    if (exp < 0) exp = -exp;

    static if (is(T == real) && real.mant_dig == 64)
        enum max_exp_digits = 8;
    else static if (is(T == float))
        enum max_exp_digits = 5;
    else
        enum max_exp_digits = 6;

    char[max_exp_digits] exp_str;
    size_t exp_pos = max_exp_digits;

    do
    {
        exp_str[--exp_pos] = '0' + exp % 10;
        exp /= 10;
    } while (exp > 0);

    exp_str[--exp_pos] = exp_sgn;
    exp_str[--exp_pos] = is_upper ? 'P' : 'p';

    if (f.precision < hex_mant_pos - 2)
    {
        import std.format.internal.write : RoundingClass, round;

        RoundingClass rc;

        if (hex_mant[f.precision + 2] == '0')
            rc = RoundingClass.ZERO;
        else if (hex_mant[f.precision + 2] < '8')
            rc = RoundingClass.LOWER;
        else if (hex_mant[f.precision + 2] > '8')
            rc = RoundingClass.UPPER;
        else
            rc = RoundingClass.FIVE;

        if (rc == RoundingClass.ZERO || rc == RoundingClass.FIVE)
        {
            foreach (i;f.precision + 3 .. hex_mant_pos)
            {
                if (hex_mant[i] > '0')
                {
                    rc = rc == RoundingClass.ZERO ? RoundingClass.LOWER : RoundingClass.UPPER;
                    break;
                }
            }
        }

        hex_mant_pos = f.precision + 2;

        round(hex_mant, 0, hex_mant_pos, rc, sgn == "-", is_upper ? 'F' : 'f');
    }

    writeAligned(w, prefix[1 - sgn.length .. $], hex_mant[0 .. 1], hex_mant[1 .. hex_mant_pos],
                 exp_str[exp_pos .. $], f, PrecisionType.fractionalDigits);
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    assert(printFloat(float.nan, f) == "nan");
    assert(printFloat(-float.nan, f) == "-nan");
    assert(printFloat(float.infinity, f) == "inf");
    assert(printFloat(-float.infinity, f) == "-inf");
    assert(printFloat(0.0f, f) == "0x0p+0");
    assert(printFloat(-0.0f, f) == "-0x0p+0");

    assert(printFloat(double.nan, f) == "nan");
    assert(printFloat(-double.nan, f) == "-nan");
    assert(printFloat(double.infinity, f) == "inf");
    assert(printFloat(-double.infinity, f) == "-inf");
    assert(printFloat(0.0, f) == "0x0p+0");
    assert(printFloat(-0.0, f) == "-0x0p+0");

    static if (real.mant_dig > 64)
    {
        pragma(msg, "printFloat tests disabled because of unsupported `real` format");
    }
    else
    {
        assert(printFloat(real.nan, f) == "nan");
        assert(printFloat(-real.nan, f) == "-nan");
        assert(printFloat(real.infinity, f) == "inf");
        assert(printFloat(-real.infinity, f) == "-inf");
        assert(printFloat(0.0L, f) == "0x0p+0");
        assert(printFloat(-0.0L, f) == "-0x0p+0");
    }

    import std.math.operations : nextUp;

    assert(printFloat(nextUp(0.0f), f) == "0x0.000002p-126");
    assert(printFloat(float.epsilon, f) == "0x1p-23");
    assert(printFloat(float.min_normal, f) == "0x1p-126");
    assert(printFloat(float.max, f) == "0x1.fffffep+127");

    assert(printFloat(nextUp(0.0), f) == "0x0.0000000000001p-1022");
    assert(printFloat(double.epsilon, f) == "0x1p-52");
    assert(printFloat(double.min_normal, f) == "0x1p-1022");
    assert(printFloat(double.max, f) == "0x1.fffffffffffffp+1023");

    static if (real.mant_dig == 64)
    {
        assert(printFloat(nextUp(0.0L), f) == "0x0.0000000000000002p-16382");
        assert(printFloat(real.epsilon, f) == "0x1p-63");
        assert(printFloat(real.min_normal, f) == "0x1p-16382");
        assert(printFloat(real.max, f) == "0x1.fffffffffffffffep+16383");
    }

    import std.math.constants : E, PI, PI_2, PI_4, M_1_PI, M_2_PI, M_2_SQRTPI,
                                LN10, LN2, LOG2, LOG2E, LOG2T, LOG10E, SQRT2, SQRT1_2;

    assert(printFloat(cast(float) E, f) == "0x1.5bf0a8p+1");
    assert(printFloat(cast(float) PI, f) == "0x1.921fb6p+1");
    assert(printFloat(cast(float) PI_2, f) == "0x1.921fb6p+0");
    assert(printFloat(cast(float) PI_4, f) == "0x1.921fb6p-1");
    assert(printFloat(cast(float) M_1_PI, f) == "0x1.45f306p-2");
    assert(printFloat(cast(float) M_2_PI, f) == "0x1.45f306p-1");
    assert(printFloat(cast(float) M_2_SQRTPI, f) == "0x1.20dd76p+0");
    assert(printFloat(cast(float) LN10, f) == "0x1.26bb1cp+1");
    assert(printFloat(cast(float) LN2, f) == "0x1.62e43p-1");
    assert(printFloat(cast(float) LOG2, f) == "0x1.344136p-2");
    assert(printFloat(cast(float) LOG2E, f) == "0x1.715476p+0");
    assert(printFloat(cast(float) LOG2T, f) == "0x1.a934fp+1");
    assert(printFloat(cast(float) LOG10E, f) == "0x1.bcb7b2p-2");
    assert(printFloat(cast(float) SQRT2, f) == "0x1.6a09e6p+0");
    assert(printFloat(cast(float) SQRT1_2, f) == "0x1.6a09e6p-1");

    assert(printFloat(cast(double) E, f) == "0x1.5bf0a8b145769p+1");
    assert(printFloat(cast(double) PI, f) == "0x1.921fb54442d18p+1");
    assert(printFloat(cast(double) PI_2, f) == "0x1.921fb54442d18p+0");
    assert(printFloat(cast(double) PI_4, f) == "0x1.921fb54442d18p-1");
    assert(printFloat(cast(double) M_1_PI, f) == "0x1.45f306dc9c883p-2");
    assert(printFloat(cast(double) M_2_PI, f) == "0x1.45f306dc9c883p-1");
    assert(printFloat(cast(double) M_2_SQRTPI, f) == "0x1.20dd750429b6dp+0");
    assert(printFloat(cast(double) LN10, f) == "0x1.26bb1bbb55516p+1");
    assert(printFloat(cast(double) LN2, f) == "0x1.62e42fefa39efp-1");
    assert(printFloat(cast(double) LOG2, f) == "0x1.34413509f79ffp-2");
    assert(printFloat(cast(double) LOG2E, f) == "0x1.71547652b82fep+0");
    assert(printFloat(cast(double) LOG2T, f) == "0x1.a934f0979a371p+1");
    assert(printFloat(cast(double) LOG10E, f) == "0x1.bcb7b1526e50ep-2");
    assert(printFloat(cast(double) SQRT2, f) == "0x1.6a09e667f3bcdp+0");
    assert(printFloat(cast(double) SQRT1_2, f) == "0x1.6a09e667f3bcdp-1");

    static if (real.mant_dig == 64)
    {
        assert(printFloat(E, f) == "0x1.5bf0a8b145769536p+1");
        assert(printFloat(PI, f) == "0x1.921fb54442d1846ap+1");
        assert(printFloat(PI_2, f) == "0x1.921fb54442d1846ap+0");
        assert(printFloat(PI_4, f) == "0x1.921fb54442d1846ap-1");
        assert(printFloat(M_1_PI, f) == "0x1.45f306dc9c882a54p-2");
        assert(printFloat(M_2_PI, f) == "0x1.45f306dc9c882a54p-1");
        assert(printFloat(M_2_SQRTPI, f) == "0x1.20dd750429b6d11ap+0");
        assert(printFloat(LN10, f) == "0x1.26bb1bbb5551582ep+1");
        assert(printFloat(LN2, f) == "0x1.62e42fefa39ef358p-1");
        assert(printFloat(LOG2, f) == "0x1.34413509f79fef32p-2");
        assert(printFloat(LOG2E, f) == "0x1.71547652b82fe178p+0");
        assert(printFloat(LOG2T, f) == "0x1.a934f0979a3715fcp+1");
        assert(printFloat(LOG10E, f) == "0x1.bcb7b1526e50e32ap-2");
        assert(printFloat(SQRT2, f) == "0x1.6a09e667f3bcc908p+0");
        assert(printFloat(SQRT1_2, f) == "0x1.6a09e667f3bcc908p-1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.precision = 3;

    assert(printFloat(1.0f, f) == "0x1.000p+0");
    assert(printFloat(3.3f, f) == "0x1.a66p+1");
    assert(printFloat(2.9f, f) == "0x1.733p+1");

    assert(printFloat(1.0, f) == "0x1.000p+0");
    assert(printFloat(3.3, f) == "0x1.a66p+1");
    assert(printFloat(2.9, f) == "0x1.733p+1");

    static if (real.mant_dig == 64)
    {
        assert(printFloat(1.0L, f) == "0x1.000p+0");
        assert(printFloat(3.3L, f) == "0x1.a66p+1");
        assert(printFloat(2.9L, f) == "0x1.733p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.precision = 0;

    assert(printFloat(1.0f, f) == "0x1p+0");
    assert(printFloat(3.3f, f) == "0x2p+1");
    assert(printFloat(2.9f, f) == "0x1p+1");

    assert(printFloat(1.0, f) == "0x1p+0");
    assert(printFloat(3.3, f) == "0x2p+1");
    assert(printFloat(2.9, f) == "0x1p+1");

    static if (real.mant_dig == 64)
    {
        assert(printFloat(1.0L, f) == "0x1p+0");
        assert(printFloat(3.3L, f) == "0x2p+1");
        assert(printFloat(2.9L, f) == "0x1p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.precision = 0;
    f.flHash = true;

    assert(printFloat(1.0f, f) == "0x1.p+0");
    assert(printFloat(3.3f, f) == "0x2.p+1");
    assert(printFloat(2.9f, f) == "0x1.p+1");

    assert(printFloat(1.0, f) == "0x1.p+0");
    assert(printFloat(3.3, f) == "0x2.p+1");
    assert(printFloat(2.9, f) == "0x1.p+1");

    static if (real.mant_dig == 64)
    {
        assert(printFloat(1.0L, f) == "0x1.p+0");
        assert(printFloat(3.3L, f) == "0x2.p+1");
        assert(printFloat(2.9L, f) == "0x1.p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.width = 22;

    assert(printFloat(1.0f, f) == "                0x1p+0");
    assert(printFloat(3.3f, f) == "         0x1.a66666p+1");
    assert(printFloat(2.9f, f) == "         0x1.733334p+1");

    assert(printFloat(1.0, f) == "                0x1p+0");
    assert(printFloat(3.3, f) == "  0x1.a666666666666p+1");
    assert(printFloat(2.9, f) == "  0x1.7333333333333p+1");

    static if (real.mant_dig == 64)
    {
        f.width = 25;
        assert(printFloat(1.0L, f) == "                   0x1p+0");
        assert(printFloat(3.3L, f) == "  0x1.a666666666666666p+1");
        assert(printFloat(2.9L, f) == "  0x1.7333333333333334p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.width = 22;
    f.flDash = true;

    assert(printFloat(1.0f, f) == "0x1p+0                ");
    assert(printFloat(3.3f, f) == "0x1.a66666p+1         ");
    assert(printFloat(2.9f, f) == "0x1.733334p+1         ");

    assert(printFloat(1.0, f) == "0x1p+0                ");
    assert(printFloat(3.3, f) == "0x1.a666666666666p+1  ");
    assert(printFloat(2.9, f) == "0x1.7333333333333p+1  ");

    static if (real.mant_dig == 64)
    {
        f.width = 25;
        assert(printFloat(1.0L, f) == "0x1p+0                   ");
        assert(printFloat(3.3L, f) == "0x1.a666666666666666p+1  ");
        assert(printFloat(2.9L, f) == "0x1.7333333333333334p+1  ");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.width = 22;
    f.flZero = true;

    assert(printFloat(1.0f, f) == "0x00000000000000001p+0");
    assert(printFloat(3.3f, f) == "0x0000000001.a66666p+1");
    assert(printFloat(2.9f, f) == "0x0000000001.733334p+1");

    assert(printFloat(1.0, f) == "0x00000000000000001p+0");
    assert(printFloat(3.3, f) == "0x001.a666666666666p+1");
    assert(printFloat(2.9, f) == "0x001.7333333333333p+1");

    static if (real.mant_dig == 64)
    {
        f.width = 25;
        assert(printFloat(1.0L, f) == "0x00000000000000000001p+0");
        assert(printFloat(3.3L, f) == "0x001.a666666666666666p+1");
        assert(printFloat(2.9L, f) == "0x001.7333333333333334p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.width = 22;
    f.flPlus = true;

    assert(printFloat(1.0f, f) == "               +0x1p+0");
    assert(printFloat(3.3f, f) == "        +0x1.a66666p+1");
    assert(printFloat(2.9f, f) == "        +0x1.733334p+1");

    assert(printFloat(1.0, f) == "               +0x1p+0");
    assert(printFloat(3.3, f) == " +0x1.a666666666666p+1");
    assert(printFloat(2.9, f) == " +0x1.7333333333333p+1");

    static if (real.mant_dig == 64)
    {
        f.width = 25;
        assert(printFloat(1.0L, f) == "                  +0x1p+0");
        assert(printFloat(3.3L, f) == " +0x1.a666666666666666p+1");
        assert(printFloat(2.9L, f) == " +0x1.7333333333333334p+1");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.width = 22;
    f.flDash = true;
    f.flSpace = true;

    assert(printFloat(1.0f, f) == " 0x1p+0               ");
    assert(printFloat(3.3f, f) == " 0x1.a66666p+1        ");
    assert(printFloat(2.9f, f) == " 0x1.733334p+1        ");

    assert(printFloat(1.0, f) == " 0x1p+0               ");
    assert(printFloat(3.3, f) == " 0x1.a666666666666p+1 ");
    assert(printFloat(2.9, f) == " 0x1.7333333333333p+1 ");

    static if (real.mant_dig == 64)
    {
        f.width = 25;
        assert(printFloat(1.0L, f) == " 0x1p+0                  ");
        assert(printFloat(3.3L, f) == " 0x1.a666666666666666p+1 ");
        assert(printFloat(2.9L, f) == " 0x1.7333333333333334p+1 ");
    }
}

@safe unittest
{
    import std.math.hardware; // cannot be selective, because FloatingPointControl might not be defined

    // std.math's FloatingPointControl isn't available on all target platforms
    static if (is(FloatingPointControl))
    {
        FloatingPointControl fpctrl;

        auto f = FormatSpec!dchar("");
        f.spec = 'a';
        f.precision = 1;

        fpctrl.rounding = FloatingPointControl.roundToNearest;

        /* tiesAwayFromZero currently not supported
         assert(printFloat(0x1.18p0,  f) == "0x1.2p+0");
         assert(printFloat(0x1.28p0,  f) == "0x1.3p+0");
         assert(printFloat(0x1.1ap0,  f) == "0x1.2p+0");
         assert(printFloat(0x1.16p0,  f) == "0x1.1p+0");
         assert(printFloat(0x1.10p0,  f) == "0x1.1p+0");
         assert(printFloat(-0x1.18p0, f) == "-0x1.2p+0");
         assert(printFloat(-0x1.28p0, f) == "-0x1.3p+0");
         assert(printFloat(-0x1.1ap0, f) == "-0x1.2p+0");
         assert(printFloat(-0x1.16p0, f) == "-0x1.1p+0");
         assert(printFloat(-0x1.10p0, f) == "-0x1.1p+0");
         */

        assert(printFloat(0x1.18p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.28p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.1ap0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.16p0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.10p0,  f) == "0x1.1p+0");
        assert(printFloat(-0x1.18p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.28p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.1ap0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.16p0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.10p0, f) == "-0x1.1p+0");

        fpctrl.rounding = FloatingPointControl.roundToZero;

        assert(printFloat(0x1.18p0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.28p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.1ap0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.16p0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.10p0,  f) == "0x1.1p+0");
        assert(printFloat(-0x1.18p0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.28p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.1ap0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.16p0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.10p0, f) == "-0x1.1p+0");

        fpctrl.rounding = FloatingPointControl.roundUp;

        assert(printFloat(0x1.18p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.28p0,  f) == "0x1.3p+0");
        assert(printFloat(0x1.1ap0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.16p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.10p0,  f) == "0x1.1p+0");
        assert(printFloat(-0x1.18p0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.28p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.1ap0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.16p0, f) == "-0x1.1p+0");
        assert(printFloat(-0x1.10p0, f) == "-0x1.1p+0");

        fpctrl.rounding = FloatingPointControl.roundDown;

        assert(printFloat(0x1.18p0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.28p0,  f) == "0x1.2p+0");
        assert(printFloat(0x1.1ap0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.16p0,  f) == "0x1.1p+0");
        assert(printFloat(0x1.10p0,  f) == "0x1.1p+0");
        assert(printFloat(-0x1.18p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.28p0, f) == "-0x1.3p+0");
        assert(printFloat(-0x1.1ap0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.16p0, f) == "-0x1.2p+0");
        assert(printFloat(-0x1.10p0, f) == "-0x1.1p+0");
    }
}

// for 100% coverage
@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'a';
    f.precision = 3;

    assert(printFloat(0x1.19f81p0, f) == "0x1.1a0p+0");
    assert(printFloat(0x1.19f01p0, f) == "0x1.19fp+0");
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'A';
    f.precision = 3;

    assert(printFloat(0x1.19f81p0, f) == "0X1.1A0P+0");
    assert(printFloat(0x1.19f01p0, f) == "0X1.19FP+0");
}

private void printFloatE(bool g, Writer, T, Char)(auto ref Writer w, const(T) val,
    FormatSpec!Char f, string sgn, int exp, ulong mnt, bool is_upper)
if (is(T == float) || is(T == double)
    || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
{
    import std.format.internal.write : writeAligned, PrecisionType, RoundingClass, round;

    static if (!g)
    {
        if (f.precision == f.UNSPECIFIED)
            f.precision = 6;
    }

    // special treatment for 0.0
    if (mnt == 0)
    {
        static if (g)
            writeAligned(w, sgn, "0", ".", "", f, PrecisionType.allDigits);
        else
            writeAligned(w, sgn, "0", ".", is_upper ? "E+00" : "e+00", f, PrecisionType.fractionalDigits);
        return;
    }

    char[T.mant_dig + T.max_exp] dec_buf;
    char[T.max_10_exp.stringof.length + 2] exp_buf;

    int final_exp = 0;

    RoundingClass rc;

    // Depending on exp, we will use one of three algorithms:
    //
    // Algorithm A: For large exponents (exp >= T.mant_dig)
    // Algorithm B: For small exponents (exp < T.mant_dig - 61)
    // Algorithm C: For exponents close to 0.
    //
    // Algorithm A:
    //   The number to print looks like this: mantissa followed by several zeros.
    //
    //   We know, that there is no fractional part, so we can just use integer division,
    //   consecutivly dividing by 10 and writing down the remainder from right to left.
    //   Unfortunately the integer is too large to fit in an ulong, so we use something
    //   like BigInt: An array of ulongs. We only use 60 bits of that ulongs, because
    //   this simplifies (and speeds up) the division to come.
    //
    //   For the division we use integer division with reminder for each ulong and put
    //   the reminder of each step in the first 4 bits of ulong of the next step (think of
    //   long division for the rationale behind this). The final reminder is the next
    //   digit (from right to left).
    //
    //   This results in the output we would have for the %f specifier. We now adjust this
    //   for %e: First we calculate the place, where the exponent should be printed, filling
    //   up with zeros if needed and second we move the leftmost digit one to the left
    //   and inserting a dot.
    //
    //   After that we decide on the rounding type, using the digits right of the position,
    //   where the exponent will be printed (currently they are still there, but will be
    //   overwritten later).
    //
    // Algorithm B:
    //   The number to print looks like this: zero dot several zeros followed by the mantissa
    //
    //   We know, that the number has no integer part. The algorithm consecutivly multiplies
    //   by 10. The integer part (rounded down) after the multiplication is the next digit
    //   (from left to right). This integer part is removed after each step.
    //   Again, the number is represented as an array of ulongs, with only 60 bits used of
    //   every ulong.
    //
    //   For the multiplication we use normal integer multiplication, which can result in digits
    //   in the uppermost 4 bits. These 4 digits are the carry which is added to the result
    //   of the next multiplication and finally the last carry is the next digit.
    //
    //   Other than for the %f specifier, this multiplication is splitted into two almost
    //   identical parts. The first part lasts as long as we find zeros. We need to do this
    //   to calculate the correct exponent.
    //
    //   The second part will stop, when only zeros remain or when we've got enough digits
    //   for the requested precision. In the second case, we have to find out, which rounding
    //   we have. Aside from special cases we do this by calculating one more digit.
    //
    // Algorithm C:
    //   This time, we know, that the integral part and the fractional part each fit into a
    //   ulong. The mantissa might be partially in both parts or completely in the fractional
    //   part.
    //
    //   We first calculate the integral part by consecutive division by 10. Depending on the
    //   precision this might result in more digits, than we need. In that case we calculate
    //   the position of the exponent and the rounding type.
    //
    //   If there is no integral part, we need to find the first non zero digit. We do this by
    //   consecutive multiplication by 10, saving the first non zero digit followed by a dot.
    //
    //   In either case, we continue filling up with the fractional part until we have enough
    //   digits. If still necessary, we decide the rounding type, mainly by looking at the
    //   next digit.

    size_t right = 1;
    size_t start = 1;
    size_t left = 1;

    static if (is(T == real) && real.mant_dig == 64)
    {
        enum small_bound = 0;
        enum max_buf = 275;
    }
    else
    {
        enum small_bound = T.mant_dig - 61;
        static if (is(T == float))
            enum max_buf = 4;
        else
            enum max_buf = 18;
    }

    ulong[max_buf] bigbuf;
    if (exp >= T.mant_dig)
    {
        start = left = right = dec_buf.length;

        // large number without fractional digits
        //
        // As this number does not fit in a ulong, we use an array of ulongs. We only use 60 of the 64 bits,
        // because this makes it much more easy to implement the division by 10.
        int count = exp / 60 + 1;

        // only the first few ulongs contain the mantiassa. The rest are zeros.
        int lower = 60 - (exp - T.mant_dig + 1) % 60;

        static if (is(T == real) && real.mant_dig == 64)
        {
            // for x87 reals, the lowest ulong may contain more than 60 bits,
            // because the mantissa is 63 (>60) bits long
            // therefore we need one ulong less
            if (lower <= 3) count--;
        }

        // saved in big endian format
        ulong[] mybig = bigbuf[0 .. count];

        if (lower < T.mant_dig)
        {
            mybig[0] = mnt >> lower;
            mybig[1] = (mnt & ((1L << lower) - 1)) << 60 - lower;
        }
        else
            mybig[0] = (mnt & ((1L << lower) - 1)) << 60 - lower;

        // Generation of digits by consecutive division with reminder by 10.
        int msu = 0; // Most significant ulong; when it get's zero, we can ignore it further on
        while (msu < count - 1 || mybig[$ - 1] != 0)
        {
            ulong mod = 0;
            foreach (i;msu .. count)
            {
                mybig[i] |= mod << 60;
                mod = mybig[i] % 10;
                mybig[i] /= 10;
            }
            if (mybig[msu] == 0)
                ++msu;

            dec_buf[--left] = cast(byte) ('0' + mod);
            ++final_exp;
        }
        --final_exp;

        static if (g)
            start = left + f.precision;
        else
            start = left + f.precision + 1;

        // move leftmost digit one more left and add dot between
        dec_buf[left - 1] = dec_buf[left];
        dec_buf[left] = '.';
        --left;

        // rounding type
        if (start >= right)
            rc = RoundingClass.ZERO;
        else if (dec_buf[start] != '0' && dec_buf[start] != '5')
            rc = dec_buf[start] > '5' ? RoundingClass.UPPER : RoundingClass.LOWER;
        else
        {
            rc = dec_buf[start] == '5' ? RoundingClass.FIVE : RoundingClass.ZERO;
            foreach (i; start + 1 .. right)
                if (dec_buf[i] > '0')
                {
                    rc = rc == RoundingClass.FIVE ? RoundingClass.UPPER : RoundingClass.LOWER;
                    break;
                }
        }

        if (start < right) right = start;
    }
    else if (exp < small_bound)
    {
        // small number without integer digits
        //
        // Again this number does not fit in a ulong and we use an array of ulongs. And again we
        // only use 60 bits, because this simplifies the multiplication by 10.
        int count = (T.mant_dig - exp - 2) / 60 + 1;

        // saved in little endian format
        ulong[] mybig = bigbuf[0 .. count];

        // only the last few ulongs contain the mantiassa. Because of little endian
        // format these are the ulongs at index 0 and 1 (and 2 in case of x87 reals).
        // The rest are zeros.
        int upper = 60 - (-exp - 1) % 60;

        static if (is(T == real) && real.mant_dig == 64)
        {
            if (upper < 4)
            {
                mybig[0] = (mnt & ((1L << (4 - upper)) - 1)) << 56 + upper;
                mybig[1] = (mnt >> (4 - upper)) & ((1L << 60) - 1);
                mybig[2] = mnt >> 64 - upper;
            }
            else
            {
                mybig[0] = (mnt & ((1L << (T.mant_dig - upper)) - 1)) << 60 - (T.mant_dig - upper);
                mybig[1] = mnt >> (T.mant_dig - upper);
            }
        }
        else
        {
            if (upper < T.mant_dig)
            {
                mybig[0] = (mnt & ((1L << (T.mant_dig - upper)) - 1)) << 60 - (T.mant_dig - upper);
                mybig[1] = mnt >> (T.mant_dig - upper);
            }
            else
                mybig[0] = mnt << (upper - T.mant_dig);
        }

        int lsu = 0; // Least significant ulong; when it get's zero, we can ignore it further on

        // adding zeros, until we reach first nonzero
        while (lsu < count - 1 || mybig[$ - 1]!=0)
        {
            ulong over = 0;
            foreach (i; lsu .. count)
            {
                mybig[i] = mybig[i] * 10 + over;
                over = mybig[i] >> 60;
                mybig[i] &= (1L << 60) - 1;
            }
            if (mybig[lsu] == 0)
                ++lsu;
            --final_exp;

            if (over != 0)
            {
                dec_buf[right++] = cast(byte) ('0' + over);
                dec_buf[right++] = '.';
                break;
            }
        }

        // adding more digits
        static if (g)
            start = right - 1;
        else
            start = right;
        while ((lsu < count - 1 || mybig[$ - 1] != 0) && right - start < f.precision)
        {
            ulong over = 0;
            foreach (i;lsu .. count)
            {
                mybig[i] = mybig[i] * 10 + over;
                over = mybig[i] >> 60;
                mybig[i] &= (1L << 60) - 1;
            }
            if (mybig[lsu] == 0)
                ++lsu;

            dec_buf[right++] = cast(byte) ('0' + over);
        }

        // rounding type
        if (lsu >= count - 1 && mybig[count - 1] == 0)
            rc = RoundingClass.ZERO;
        else if (lsu == count - 1 && mybig[lsu] == 1L << 59)
            rc = RoundingClass.FIVE;
        else
        {
            ulong over = 0;
            foreach (i;lsu .. count)
            {
                mybig[i] = mybig[i] * 10 + over;
                over = mybig[i] >> 60;
                mybig[i] &= (1L << 60) - 1;
            }
            rc = over >= 5 ? RoundingClass.UPPER : RoundingClass.LOWER;
        }
    }
    else
    {
        // medium sized number, probably with integer and fractional digits
        // this is fastest, because both parts fit into a ulong each
        ulong int_part = mnt >> (T.mant_dig - 1 - exp);
        ulong frac_part = mnt & ((1L << (T.mant_dig - 1 - exp)) - 1);

        // for x87 reals the mantiassa might be up to 3 bits too long
        // we need to save these bits as a tail and handle this separately
        static if (is(T == real) && real.mant_dig == 64)
        {
            ulong tail = 0;
            ulong tail_length = 0;
            if (exp < 3)
            {
                tail = frac_part & ((1L << (3 - exp)) - 1);
                tail_length = 3 - exp;
                frac_part >>= 3 - exp;
                exp = 3;
            }
        }

        start = 0;

        // could we already decide on the rounding mode in the integer part?
        bool found = false;

        if (int_part > 0)
        {
            import core.bitop : bsr;
            left = right = int_part.bsr * 100 / 332 + 4;

            // integer part, if there is something to print
            while (int_part >= 10)
            {
                dec_buf[--left] = '0' + (int_part % 10);
                int_part /= 10;
                ++final_exp;
                ++start;
            }

            dec_buf[--left] = '.';
            dec_buf[--left] = cast(byte) ('0' + int_part);

            static if (g)
                auto limit = f.precision + 1;
            else
                auto limit = f.precision + 2;

            if (right - left > limit)
            {
                auto old_right = right;
                right = left + limit;

                if (dec_buf[right] == '5' || dec_buf[right] == '0')
                {
                    rc = dec_buf[right] == '5' ? RoundingClass.FIVE : RoundingClass.ZERO;
                    if (frac_part != 0)
                        rc = rc == RoundingClass.FIVE ? RoundingClass.UPPER : RoundingClass.LOWER;
                    else
                        foreach (i;right + 1 .. old_right)
                            if (dec_buf[i] > '0')
                            {
                                rc = rc == RoundingClass.FIVE ? RoundingClass.UPPER : RoundingClass.LOWER;
                                break;
                            }
                }
                else
                    rc = dec_buf[right] > '5' ? RoundingClass.UPPER : RoundingClass.LOWER;
                found = true;
            }
        }
        else
        {
            // fractional part, skipping leading zeros
            while (frac_part != 0)
            {
                --final_exp;
                frac_part *= 10;
                static if (is(T == real) && real.mant_dig == 64)
                {
                    if (tail_length > 0)
                    {
                        // together this is *= 10;
                        tail *= 5;
                        tail_length--;

                        frac_part += tail >> tail_length;
                        if (tail_length > 0)
                            tail &= (1L << tail_length) - 1;
                    }
                }
                auto tmp = frac_part >> (T.mant_dig - 1 - exp);
                frac_part &= ((1L << (T.mant_dig - 1 - exp)) - 1);
                if (tmp > 0)
                {
                    dec_buf[right++] = cast(byte) ('0' + tmp);
                    dec_buf[right++] = '.';
                    break;
                }
            }

            rc = RoundingClass.ZERO;
        }

        static if (g)
            size_t limit = f.precision - 1;
        else
            size_t limit = f.precision;

        // the fractional part after the zeros
        while (frac_part != 0 && start < limit)
        {
            frac_part *= 10;
            static if (is(T == real) && real.mant_dig == 64)
            {
                if (tail_length > 0)
                {
                    // together this is *= 10;
                    tail *= 5;
                    tail_length--;

                    frac_part += tail >> tail_length;
                    if (tail_length > 0)
                        tail &= (1L << tail_length) - 1;
                }
            }
            dec_buf[right++] = cast(byte) ('0' + (frac_part >> (T.mant_dig - 1 - exp)));
            frac_part &= ((1L << (T.mant_dig - 1 - exp)) - 1);
            ++start;
        }

        static if (g)
            limit = right - left - 1;
        else
            limit = start;

        // rounding mode, if not allready known
        if (frac_part != 0 && !found)
        {
            frac_part *= 10;
            auto nextDigit = frac_part >> (T.mant_dig - 1 - exp);
            frac_part &= ((1L << (T.mant_dig - 1 - exp)) - 1);

            if (nextDigit == 5 && frac_part == 0)
                rc = RoundingClass.FIVE;
            else if (nextDigit >= 5)
                rc = RoundingClass.UPPER;
            else
                rc = RoundingClass.LOWER;
        }
    }

    if (round(dec_buf, left, right, rc, sgn == "-"))
    {
        left--;
        right--;
        dec_buf[left + 2] = dec_buf[left + 1];
        dec_buf[left + 1] = '.';
        final_exp++;
    }

    // printing exponent
    auto neg = final_exp < 0;
    if (neg) final_exp = -final_exp;

    size_t exp_pos = exp_buf.length;

    do
    {
        exp_buf[--exp_pos] = '0' + final_exp%10;
        final_exp /= 10;
    } while (final_exp > 0);
    if (exp_buf.length - exp_pos == 1)
        exp_buf[--exp_pos] = '0';
    exp_buf[--exp_pos] = neg ? '-' : '+';
    exp_buf[--exp_pos] = is_upper ? 'E' : 'e';

    while (right > left + 1 && dec_buf[right - 1] == '0') right--;

    if (right == left + 1)
        dec_buf[right++] = '.';

    static if (g)
        writeAligned(w, sgn, dec_buf[left .. left + 1], dec_buf[left + 1 .. right],
                     exp_buf[exp_pos .. $], f, PrecisionType.allDigits);
    else
        writeAligned(w, sgn, dec_buf[left .. left + 1], dec_buf[left + 1 .. right],
                     exp_buf[exp_pos .. $], f, PrecisionType.fractionalDigits);
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    assert(printFloat(float.nan, f) == "nan");
    assert(printFloat(-float.nan, f) == "-nan");
    assert(printFloat(float.infinity, f) == "inf");
    assert(printFloat(-float.infinity, f) == "-inf");
    assert(printFloat(0.0f, f) == "0.000000e+00");
    assert(printFloat(-0.0f, f) == "-0.000000e+00");
    // cast needed due to https://issues.dlang.org/show_bug.cgi?id=20361
    assert(printFloat(cast(float) 1e-40, f) == "9.999946e-41");
    assert(printFloat(cast(float) -1e-40, f) == "-9.999946e-41");
    assert(printFloat(1e-30f, f) == "1.000000e-30");
    assert(printFloat(-1e-30f, f) == "-1.000000e-30");
    assert(printFloat(1e-10f, f) == "1.000000e-10");
    assert(printFloat(-1e-10f, f) == "-1.000000e-10");
    assert(printFloat(0.1f, f) == "1.000000e-01");
    assert(printFloat(-0.1f, f) == "-1.000000e-01");
    assert(printFloat(10.0f, f) == "1.000000e+01");
    assert(printFloat(-10.0f, f) == "-1.000000e+01");
    assert(printFloat(1e30f, f) == "1.000000e+30");
    assert(printFloat(-1e30f, f) == "-1.000000e+30");

    import std.math.operations : nextUp, nextDown;
    assert(printFloat(nextUp(0.0f), f) == "1.401298e-45");
    assert(printFloat(nextDown(-0.0f), f) == "-1.401298e-45");
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    f.width = 20;
    f.precision = 10;

    assert(printFloat(float.nan, f) == "                 nan");
    assert(printFloat(-float.nan, f) == "                -nan");
    assert(printFloat(float.infinity, f) == "                 inf");
    assert(printFloat(-float.infinity, f) == "                -inf");
    assert(printFloat(0.0f, f) == "    0.0000000000e+00");
    assert(printFloat(-0.0f, f) == "   -0.0000000000e+00");
    // cast needed due to https://issues.dlang.org/show_bug.cgi?id=20361
    assert(printFloat(cast(float) 1e-40, f) == "    9.9999461011e-41");
    assert(printFloat(cast(float) -1e-40, f) == "   -9.9999461011e-41");
    assert(printFloat(1e-30f, f) == "    1.0000000032e-30");
    assert(printFloat(-1e-30f, f) == "   -1.0000000032e-30");
    assert(printFloat(1e-10f, f) == "    1.0000000134e-10");
    assert(printFloat(-1e-10f, f) == "   -1.0000000134e-10");
    assert(printFloat(0.1f, f) == "    1.0000000149e-01");
    assert(printFloat(-0.1f, f) == "   -1.0000000149e-01");
    assert(printFloat(10.0f, f) == "    1.0000000000e+01");
    assert(printFloat(-10.0f, f) == "   -1.0000000000e+01");
    assert(printFloat(1e30f, f) == "    1.0000000150e+30");
    assert(printFloat(-1e30f, f) == "   -1.0000000150e+30");

    import std.math.operations : nextUp, nextDown;
    assert(printFloat(nextUp(0.0f), f) == "    1.4012984643e-45");
    assert(printFloat(nextDown(-0.0f), f) == "   -1.4012984643e-45");
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    f.width = 20;
    f.precision = 10;
    f.flDash = true;

    assert(printFloat(float.nan, f) == "nan                 ");
    assert(printFloat(-float.nan, f) == "-nan                ");
    assert(printFloat(float.infinity, f) == "inf                 ");
    assert(printFloat(-float.infinity, f) == "-inf                ");
    assert(printFloat(0.0f, f) == "0.0000000000e+00    ");
    assert(printFloat(-0.0f, f) == "-0.0000000000e+00   ");
    // cast needed due to https://issues.dlang.org/show_bug.cgi?id=20361
    assert(printFloat(cast(float) 1e-40, f) == "9.9999461011e-41    ");
    assert(printFloat(cast(float) -1e-40, f) == "-9.9999461011e-41   ");
    assert(printFloat(1e-30f, f) == "1.0000000032e-30    ");
    assert(printFloat(-1e-30f, f) == "-1.0000000032e-30   ");
    assert(printFloat(1e-10f, f) == "1.0000000134e-10    ");
    assert(printFloat(-1e-10f, f) == "-1.0000000134e-10   ");
    assert(printFloat(0.1f, f) == "1.0000000149e-01    ");
    assert(printFloat(-0.1f, f) == "-1.0000000149e-01   ");
    assert(printFloat(10.0f, f) == "1.0000000000e+01    ");
    assert(printFloat(-10.0f, f) == "-1.0000000000e+01   ");
    assert(printFloat(1e30f, f) == "1.0000000150e+30    ");
    assert(printFloat(-1e30f, f) == "-1.0000000150e+30   ");

    import std.math.operations : nextUp, nextDown;
    assert(printFloat(nextUp(0.0f), f) == "1.4012984643e-45    ");
    assert(printFloat(nextDown(-0.0f), f) == "-1.4012984643e-45   ");
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    f.width = 20;
    f.precision = 10;
    f.flZero = true;

    assert(printFloat(float.nan, f) == "                 nan");
    assert(printFloat(-float.nan, f) == "                -nan");
    assert(printFloat(float.infinity, f) == "                 inf");
    assert(printFloat(-float.infinity, f) == "                -inf");
    assert(printFloat(0.0f, f) == "00000.0000000000e+00");
    assert(printFloat(-0.0f, f) == "-0000.0000000000e+00");
    // cast needed due to https://issues.dlang.org/show_bug.cgi?id=20361
    assert(printFloat(cast(float) 1e-40, f) == "00009.9999461011e-41");
    assert(printFloat(cast(float) -1e-40, f) == "-0009.9999461011e-41");
    assert(printFloat(1e-30f, f) == "00001.0000000032e-30");
    assert(printFloat(-1e-30f, f) == "-0001.0000000032e-30");
    assert(printFloat(1e-10f, f) == "00001.0000000134e-10");
    assert(printFloat(-1e-10f, f) == "-0001.0000000134e-10");
    assert(printFloat(0.1f, f) == "00001.0000000149e-01");
    assert(printFloat(-0.1f, f) == "-0001.0000000149e-01");
    assert(printFloat(10.0f, f) == "00001.0000000000e+01");
    assert(printFloat(-10.0f, f) == "-0001.0000000000e+01");
    assert(printFloat(1e30f, f) == "00001.0000000150e+30");
    assert(printFloat(-1e30f, f) == "-0001.0000000150e+30");

    import std.math.operations : nextUp, nextDown;
    assert(printFloat(nextUp(0.0f), f) == "00001.4012984643e-45");
    assert(printFloat(nextDown(-0.0f), f) == "-0001.4012984643e-45");
}

@safe unittest
{
    import std.math.hardware; // cannot be selective, because FloatingPointControl might not be defined

    // std.math's FloatingPointControl isn't available on all target platforms
    static if (is(FloatingPointControl))
    {
        FloatingPointControl fpctrl;

        auto f = FormatSpec!dchar("");
        f.spec = 'e';
        f.precision = 1;

        fpctrl.rounding = FloatingPointControl.roundToNearest;

        /*
        assert(printFloat(11.5f, f) == "1.2e+01");
        assert(printFloat(12.5f, f) == "1.3e+01");
        assert(printFloat(11.7f, f) == "1.2e+01");
        assert(printFloat(11.3f, f) == "1.1e+01");
        assert(printFloat(11.0f, f) == "1.1e+01");
        assert(printFloat(-11.5f, f) == "-1.2e+01");
        assert(printFloat(-12.5f, f) == "-1.3e+01");
        assert(printFloat(-11.7f, f) == "-1.2e+01");
        assert(printFloat(-11.3f, f) == "-1.1e+01");
        assert(printFloat(-11.0f, f) == "-1.1e+01");
         */

        assert(printFloat(11.5f, f) == "1.2e+01");
        assert(printFloat(12.5f, f) == "1.2e+01");
        assert(printFloat(11.7f, f) == "1.2e+01");
        assert(printFloat(11.3f, f) == "1.1e+01");
        assert(printFloat(11.0f, f) == "1.1e+01");
        assert(printFloat(-11.5f, f) == "-1.2e+01");
        assert(printFloat(-12.5f, f) == "-1.2e+01");
        assert(printFloat(-11.7f, f) == "-1.2e+01");
        assert(printFloat(-11.3f, f) == "-1.1e+01");
        assert(printFloat(-11.0f, f) == "-1.1e+01");

        fpctrl.rounding = FloatingPointControl.roundToZero;

        assert(printFloat(11.5f, f) == "1.1e+01");
        assert(printFloat(12.5f, f) == "1.2e+01");
        assert(printFloat(11.7f, f) == "1.1e+01");
        assert(printFloat(11.3f, f) == "1.1e+01");
        assert(printFloat(11.0f, f) == "1.1e+01");
        assert(printFloat(-11.5f, f) == "-1.1e+01");
        assert(printFloat(-12.5f, f) == "-1.2e+01");
        assert(printFloat(-11.7f, f) == "-1.1e+01");
        assert(printFloat(-11.3f, f) == "-1.1e+01");
        assert(printFloat(-11.0f, f) == "-1.1e+01");

        fpctrl.rounding = FloatingPointControl.roundUp;

        assert(printFloat(11.5f, f) == "1.2e+01");
        assert(printFloat(12.5f, f) == "1.3e+01");
        assert(printFloat(11.7f, f) == "1.2e+01");
        assert(printFloat(11.3f, f) == "1.2e+01");
        assert(printFloat(11.0f, f) == "1.1e+01");
        assert(printFloat(-11.5f, f) == "-1.1e+01");
        assert(printFloat(-12.5f, f) == "-1.2e+01");
        assert(printFloat(-11.7f, f) == "-1.1e+01");
        assert(printFloat(-11.3f, f) == "-1.1e+01");
        assert(printFloat(-11.0f, f) == "-1.1e+01");

        fpctrl.rounding = FloatingPointControl.roundDown;

        assert(printFloat(11.5f, f) == "1.1e+01");
        assert(printFloat(12.5f, f) == "1.2e+01");
        assert(printFloat(11.7f, f) == "1.1e+01");
        assert(printFloat(11.3f, f) == "1.1e+01");
        assert(printFloat(11.0f, f) == "1.1e+01");
        assert(printFloat(-11.5f, f) == "-1.2e+01");
        assert(printFloat(-12.5f, f) == "-1.3e+01");
        assert(printFloat(-11.7f, f) == "-1.2e+01");
        assert(printFloat(-11.3f, f) == "-1.2e+01");
        assert(printFloat(-11.0f, f) == "-1.1e+01");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    assert(printFloat(double.nan, f) == "nan");
    assert(printFloat(-double.nan, f) == "-nan");
    assert(printFloat(double.infinity, f) == "inf");
    assert(printFloat(-double.infinity, f) == "-inf");
    assert(printFloat(0.0, f) == "0.000000e+00");
    assert(printFloat(-0.0, f) == "-0.000000e+00");
    // / 1000 needed due to https://issues.dlang.org/show_bug.cgi?id=20361
    assert(printFloat(1e-307 / 1000, f) == "1.000000e-310");
    assert(printFloat(-1e-307 / 1000, f) == "-1.000000e-310");
    assert(printFloat(1e-30, f) == "1.000000e-30");
    assert(printFloat(-1e-30, f) == "-1.000000e-30");
    assert(printFloat(1e-10, f) == "1.000000e-10");
    assert(printFloat(-1e-10, f) == "-1.000000e-10");
    assert(printFloat(0.1, f) == "1.000000e-01");
    assert(printFloat(-0.1, f) == "-1.000000e-01");
    assert(printFloat(10.0, f) == "1.000000e+01");
    assert(printFloat(-10.0, f) == "-1.000000e+01");
    assert(printFloat(1e300, f) == "1.000000e+300");
    assert(printFloat(-1e300, f) == "-1.000000e+300");

    import std.math.operations : nextUp, nextDown;
    assert(printFloat(nextUp(0.0), f) == "4.940656e-324");
    assert(printFloat(nextDown(-0.0), f) == "-4.940656e-324");
}

@safe unittest
{
    static if (real.mant_dig > 64)
    {
        pragma(msg, "printFloat tests disabled because of unsupported `real` format");
    }
    else
    {
        auto f = FormatSpec!dchar("");
        f.spec = 'e';
        assert(printFloat(real.nan, f) == "nan");
        assert(printFloat(-real.nan, f) == "-nan");
        assert(printFloat(real.infinity, f) == "inf");
        assert(printFloat(-real.infinity, f) == "-inf");
    }
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';

    import std.math.operations : nextUp;

    double eps = nextUp(0.0);
    f.precision = 1000;
    assert(printFloat(eps, f) ==
           "4.9406564584124654417656879286822137236505980261432476442558568250067550727020875186529983636163599"
           ~"23797965646954457177309266567103559397963987747960107818781263007131903114045278458171678489821036"
           ~"88718636056998730723050006387409153564984387312473397273169615140031715385398074126238565591171026"
           ~"65855668676818703956031062493194527159149245532930545654440112748012970999954193198940908041656332"
           ~"45247571478690147267801593552386115501348035264934720193790268107107491703332226844753335720832431"
           ~"93609238289345836806010601150616980975307834227731832924790498252473077637592724787465608477820373"
           ~"44696995336470179726777175851256605511991315048911014510378627381672509558373897335989936648099411"
           ~"64205702637090279242767544565229087538682506419718265533447265625000000000000000000000000000000000"
           ~"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
           ~"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
           ~"000000000000000000000e-324");

    f.precision = 50;
    assert(printFloat(double.max, f) ==
           "1.79769313486231570814527423731704356798070567525845e+308");
    assert(printFloat(double.epsilon, f) ==
           "2.22044604925031308084726333618164062500000000000000e-16");

    f.precision = 10;
    assert(printFloat(1.0/3.0, f) == "3.3333333333e-01");
    assert(printFloat(1.0/7.0, f) == "1.4285714286e-01");
    assert(printFloat(1.0/9.0, f) == "1.1111111111e-01");
}

@safe unittest
{
    auto f = FormatSpec!dchar("");
    f.spec = 'e';
    f.precision = 15;

    import std.math.constants : E, PI, PI_2, PI_4, M_1_PI, M_2_PI, M_2_SQRTPI,
                                LN10, LN2, LOG2, LOG2E, LOG2T, LOG10E, SQRT2, SQRT1_2;

    assert(printFloat(cast(double) E, f) == "2.718281828459045e+00");
    assert(printFloat(cast(double) PI, f) == "3.141592653589793e+00");
    assert(printFloat(cast(double) PI_2, f) == "1.570796326794897e+00");
    assert(printFloat(cast(double) PI_4, f) == "7.853981633974483e-01");
    assert(printFloat(cast(double) M_1_PI, f) == "3.183098861837907e-01");
    assert(printFloat(cast(double) M_2_PI, f) == "6.366197723675814e-01");
    assert(printFloat(cast(double) M_2_SQRTPI, f) == "1.128379167095513e+00");
    assert(printFloat(cast(double) LN10, f) == "2.302585092994046e+00");
    assert(printFloat(cast(double) LN2, f) == "6.931471805599453e-01");
    assert(printFloat(cast(double) LOG2, f) == "3.010299956639812e-01");
    assert(printFloat(cast(double) LOG2E, f) == "1.442695040888963e+00");
    assert(printFloat(cast(double) LOG2T, f) == "3.321928094887362e+00");
    assert(printFloat(cast(double) LOG10E, f) == "4.342944819032518e-01");
    assert(printFloat(cast(double) SQRT2, f) == "1.414213562373095e+00");
    assert(printFloat(cast(double) SQRT1_2, f) == "7.071067811865476e-01");
}

// for 100% coverage
@safe unittest
{
    import std.math.hardware; // cannot be selective, because FloatingPointControl might not be defined

    auto f = FormatSpec!dchar("");
    f.spec = 'E';
    f.precision = 80;
    assert(printFloat(5.62776e+12f, f) ==
           "5.62775982080000000000000000000000000000000000000000000000000000000000000000000000E+12");

    f.precision = 49;
    assert(printFloat(2.5997869e-12f, f) ==
           "2.5997869221999758693186777236405760049819946289062E-12");

    f.precision = 6;
    assert(printFloat(-1.1418613e+07f, f) == "-1.141861E+07");
    assert(printFloat(-1.368281e+07f, f) == "-1.368281E+07");

    f.precision = 1;
    assert(printFloat(-245.666f, f) == "-2.5E+02");

    static if (is(FloatingPointControl))
    {
        FloatingPointControl fpctrl;

        fpctrl.rounding = FloatingPointControl.roundUp;

        f.precision = 0;
        assert(printFloat(709422.0f, f) == "8E+05");
    }
}

@safe unittest
{
    static if (real.mant_dig > 64)
    {
        pragma(msg, "printFloat tests disabled because of unsupported `real` format");
    }
    else
    {
        auto f = FormatSpec!dchar("");
        f.spec = 'e';
        assert(printFloat(real.nan, f) == "nan");
        assert(printFloat(-real.nan, f) == "-nan");
        assert(printFloat(real.infinity, f) == "inf");
        assert(printFloat(-real.infinity, f) == "-inf");
        assert(printFloat(0.0L, f) == "0.000000e+00");
        assert(printFloat(-0.0L, f) == "-0.000000e+00");
    }

    static if (real.mant_dig == 64)
    {
        assert(printFloat(1e-4940L, f) == "1.000000e-4940");
        assert(printFloat(-1e-4940L, f) == "-1.000000e-4940");
        assert(printFloat(1e-30L, f) == "1.000000e-30");
        assert(printFloat(-1e-30L, f) == "-1.000000e-30");
        assert(printFloat(1e-10L, f) == "1.000000e-10");
        assert(printFloat(-1e-10L, f) == "-1.000000e-10");
        assert(printFloat(0.1L, f) == "1.000000e-01");
        assert(printFloat(-0.1L, f) == "-1.000000e-01");
        assert(printFloat(10.0L, f) == "1.000000e+01");
        assert(printFloat(-10.0L, f) == "-1.000000e+01");
        version (Windows) {} // https://issues.dlang.org/show_bug.cgi?id=20972
        else
        {
            assert(printFloat(1e4000L, f) == "1.000000e+4000");
            assert(printFloat(-1e4000L, f) == "-1.000000e+4000");
        }

        import std.math.operations : nextUp, nextDown;
        assert(printFloat(nextUp(0.0L), f) == "3.645200e-4951");
        assert(printFloat(nextDown(-0.0L), f) == "-3.645200e-4951");
    }
}

@safe unittest
{
    import std.exception : assertCTFEable;
    import std.math.exponential : log2;
    import std.math.operations : nextDown;

    assertCTFEable!(
    {
        // log2 is broken for x87-reals on some computers in CTFE
        // the following tests excludes these computers from the tests
        // (https://issues.dlang.org/show_bug.cgi?id=21757)
        enum test = cast(int) log2(3.05e2312L);
        static if (real.mant_dig == 64 && test == 7681)
        {
            auto f = FormatSpec!dchar("");
            f.spec = 'e';
            assert(printFloat(real.infinity, f) == "inf");
            assert(printFloat(10.0L, f) == "1.000000e+01");
            assert(printFloat(2.6080L, f) == "2.608000e+00");
            assert(printFloat(3.05e2312L, f) == "3.050000e+2312");

            f.precision = 60;
            assert(printFloat(2.65e-54L, f) ==
                   "2.650000000000000000059009987400547013941028940935296547599415e-54");

            /*
             commented out, because CTFE is currently too slow for 5000 digits with extreme values

            f.precision = 5000;
            auto result2 = printFloat(1.2119e-4822L, f);
            assert(result2.length == 5008);
            assert(result2[$ - 20 .. $] == "60729486595339e-4822");
            auto result3 = printFloat(real.min_normal, f);
            assert(result3.length == 5008);
            assert(result3[$ - 20 .. $] == "20781410082267e-4932");
            auto result4 = printFloat(real.min_normal.nextDown, f);
            assert(result4.length == 5008);
            assert(result4[$ - 20 .. $] == "81413263331006e-4932");
             */
        }
    });
}

private void printFloatF(bool g, Writer, T, Char)(auto ref Writer w, const(T) val,
    FormatSpec!Char f, string sgn, int exp, ulong mnt, bool is_upper)
if (is(T == float) || is(T == double)
    || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
{
    import std.format.internal.write : writeAligned, PrecisionType, RoundingClass, round;

    static if (!g)
    {
        if (f.precision == f.UNSPECIFIED)
            f.precision = 6;
    }

    // special treatment for 0.0
    if (exp == 0 && mnt == 0)
    {
        writeAligned(w, sgn, "0", ".", "", f, PrecisionType.fractionalDigits);
        return;
    }

    char[T.max_exp + T.mant_dig + 1] dec_buf;

    RoundingClass rc;

    // Depending on exp, we will use one of three algorithms:
    //
    // Algorithm A: For large exponents (exp >= T.mant_dig)
    // Algorithm B: For small exponents (exp < T.mant_dig - 61)
    // Algorithm C: For exponents close to 0.
    //
    // Algorithm A:
    //   The number to print looks like this: mantissa followed by several zeros.
    //
    //   We know, that there is no fractional part, so we can just use integer division,
    //   consecutivly dividing by 10 and writing down the remainder from right to left.
    //   Unfortunately the integer is too large to fit in an ulong, so we use something
    //   like BigInt: An array of ulongs. We only use 60 bits of that ulongs, because
    //   this simplifies (and speeds up) the division to come.
    //
    //   For the division we use integer division with reminder for each ulong and put
    //   the reminder of each step in the first 4 bits of ulong of the next step (think of
    //   long division for the rationale behind this). The final reminder is the next
    //   digit (from right to left).
    //
    // Algorithm B:
    //   The number to print looks like this: zero dot several zeros followed by the mantissa
    //
    //   We know, that the number has no integer part. The algorithm consecutivly multiplies
    //   by 10. The integer part (rounded down) after the multiplication is the next digit
    //   (from left to right). This integer part is removed after each step.
    //   Again, the number is represented as an array of ulongs, with only 60 bits used of
    //   every ulong.
    //
    //   For the multiplication we use normal integer multiplication, which can result in digits
    //   in the uppermost 4 bits. These 4 digits are the carry which is added to the result
    //   of the next multiplication and finally the last carry is the next digit.
    //
    //   The calculation will stop, when only zeros remain or when we've got enough digits
    //   for the requested precision. In the second case, we have to find out, which rounding
    //   we have. Aside from special cases we do this by calculating one more digit.
    //
    // Algorithm C:
    //   This time, we know, that the integral part and the fractional part each fit into a
    //   ulong. The mantissa might be partially in both parts or completely in the fractional
    //   part.
    //
    //   We first calculate the integral part by consecutive division by 10. Then we calculate
    //   the fractional part by consecutive multiplication by 10. Again only until we have enough
    //   digits. Finally, we decide the rounding type, mainly by looking at the next digit.

    static if (is(T == real) && real.mant_dig == 64)
    {
        enum small_bound = 0;
        enum max_buf = 275;
    }
    else
    {
        enum small_bound = T.mant_dig - 61;
        static if (is(T == float))
            enum max_buf = 4;
        else
            enum max_buf = 18;
    }

    size_t start = 2;
    size_t left = 2;
    size_t right = 2;

    ulong[max_buf] bigbuf;
    if (exp >= T.mant_dig)
    {
        left = start = dec_buf.length - 1;
        right = dec_buf.length;
        dec_buf[start] = '.';

        // large number without fractional digits
        //
        // As this number does not fit in a ulong, we use an array of ulongs. We only use 60 of the 64 bits,
        // because this makes it much more easy to implement the division by 10.
        int count = exp / 60 + 1;

        // only the first few ulongs contain the mantiassa. The rest are zeros.
        int lower = 60 - (exp - T.mant_dig + 1) % 60;

        static if (is(T == real) && real.mant_dig == 64)
        {
            // for x87 reals, the lowest ulong may contain more than 60 bits,
            // because the mantissa is 63 (>60) bits long
            // therefore we need one ulong less
            if (lower <= 3) count--;
        }

        // saved in big endian format
        ulong[] mybig = bigbuf[0 .. count];

        if (lower < T.mant_dig)
        {
            mybig[0] = mnt >> lower;
            mybig[1] = (mnt & ((1L << lower) - 1)) << 60 - lower;
        }
        else
            mybig[0] = (mnt & ((1L << lower) - 1)) << 60 - lower;

        // Generation of digits by consecutive division with reminder by 10.
        int msu = 0; // Most significant ulong; when it get's zero, we can ignore it furtheron
        while (msu < count - 1 || mybig[$ - 1] != 0)
        {
            ulong mod = 0;
            foreach (i;msu .. count)
            {
                mybig[i] |= mod << 60;
                mod = mybig[i] % 10;
                mybig[i] /= 10;
            }
            if (mybig[msu] == 0)
                ++msu;

            dec_buf[--left] = cast(byte) ('0' + mod);
        }

        rc = RoundingClass.ZERO;
    }
    else if (exp < small_bound)
    {
        // small number without integer digits
        //
        // Again this number does not fit in a ulong and we use an array of ulongs. And again we
        // only use 60 bits, because this simplifies the multiplication by 10.
        int count = (T.mant_dig - exp - 2) / 60 + 1;

        // saved in little endian format
        ulong[] mybig = bigbuf[0 .. count];

        // only the last few ulongs contain the mantiassa. Because of little endian
        // format these are the ulongs at index 0 and 1 (and 2 in case of x87 reals).
        // The rest are zeros.
        int upper = 60 - (-exp - 1) % 60;

        static if (is(T == real) && real.mant_dig == 64)
        {
            if (upper < 4)
            {
                mybig[0] = (mnt & ((1L << (4 - upper)) - 1)) << 56 + upper;
                mybig[1] = (mnt >> (4 - upper)) & ((1L << 60) - 1);
                mybig[2] = mnt >> 64 - upper;
            }
            else
            {
                mybig[0] = (mnt & ((1L << (T.mant_dig - upper)) - 1)) << 60 - (T.mant_dig - upper);
                mybig[1] = mnt >> (T.mant_dig - upper);
            }
        }
        else
        {
            if (upper < T.mant_dig)
            {
                mybig[0] = (mnt & ((1L << (T.mant_dig - upper)) - 1)) << 60 - (T.mant_dig - upper);
                mybig[1] = mnt >> (T.mant_dig - upper);
            }
            else
                mybig[0] = mnt << (upper - T.mant_dig);
        }

        dec_buf[--left] = '0'; // 0 left of the dot
        dec_buf[right++] = '.';

        static if (g)
        {
            // precision starts at first non zero, so we move start
            // to the right, until we found first non zero, thus avoiding
            // a premature break of the loop
            bool found = false;
            start = left + 1;
        }

        // Generation of digits by consecutive multiplication by 10.
        int lsu = 0; // Least significant ulong; when it get's zero, we can ignore it furtheron
        while ((lsu < count - 1 || mybig[$ - 1] != 0) && right - start - 1 < f.precision)
        {
            ulong over = 0;
            foreach (i;lsu .. count)
            {
                mybig[i] = mybig[i] * 10 + over;
                over = mybig[i] >> 60;
                mybig[i] &= (1L << 60) - 1;
            }
            if (mybig[lsu] == 0)
                ++lsu;

            dec_buf[right++] = cast(byte) ('0' + over);

            static if (g)
            {
                if (dec_buf[right - 1] != '0')
                    found = true;
                else if (!found)
                    start++;
            }
        }

        static if (g) start = 2;

        if (lsu >= count - 1 && mybig[count - 1] == 0)
            rc = RoundingClass.ZERO;
        else if (lsu == count - 1 && mybig[lsu] == 1L << 59)
            rc = RoundingClass.FIVE;
        else
        {
            ulong over = 0;
            foreach (i;lsu .. count)
            {
                mybig[i] = mybig[i] * 10 + over;
                over = mybig[i] >> 60;
                mybig[i] &= (1L << 60) - 1;
            }
            rc = over >= 5 ? RoundingClass.UPPER : RoundingClass.LOWER;
        }
    }
    else
    {
        // medium sized number, probably with integer and fractional digits
        // this is fastest, because both parts fit into a ulong each
        ulong int_part = mnt >> (T.mant_dig - 1 - exp);
        ulong frac_part = mnt & ((1L << (T.mant_dig - 1 - exp)) - 1);

        // for x87 reals the mantiassa might be up to 3 bits too long
        // we need to save these bits as a tail and handle this separately
        static if (is(T == real) && real.mant_dig == 64)
        {
            ulong tai// Written in the D programming language.

/*
   Copyright: Copyright The D Language Foundation 2000-2013.

   License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

   Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
   Andrei Alexandrescu), and Kenji Hara

   Source: $(PHOBOSSRC std/format/internal/read.d)
 */
module std.format.internal.read;

import std.range.primitives : ElementEncodingType, ElementType, isInputRange;

import std.traits : isAggregateType, isArray, isAssociativeArray,
    isDynamicArray, isFloatingPoint, isIntegral, isSomeChar, isSomeString,
    isStaticArray, StringTypeOf;

import std.format.spec : FormatSpec;

package(std.format):

void skipData(Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
{
    import std.ascii : isDigit;
    import std.conv : text;
    import std.range.primitives : empty, front, popFront;

    switch (spec.spec)
    {
        case 'c': input.popFront(); break;
        case 'd':
            if (input.front == '+' || input.front == '-') input.popFront();
            goto case 'u';
        case 'u':
            while (!input.empty && isDigit(input.front)) input.popFront();
            break;
        default:
            assert(false,
                   text("Format specifier not understood: %", spec.spec));
    }
}

private template acceptedSpecs(T)
{
    static if (isIntegral!T)
        enum acceptedSpecs = "bdosuxX";
    else static if (isFloatingPoint!T)
        enum acceptedSpecs = "seEfgG";
    else static if (isSomeChar!T)
        enum acceptedSpecs = "bcdosuxX";    // integral + 'c'
    else
        enum acceptedSpecs = "";
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range && is(immutable T == immutable bool))
{
    import std.algorithm.searching : find;
    import std.conv : parse, text;
    import std.format : enforceFmt, unformatValue;

    if (spec.spec == 's') return parse!T(input);

    enforceFmt(find(acceptedSpecs!long, spec.spec).length,
               text("Wrong unformat specifier '%", spec.spec , "' for ", T.stringof));

    return unformatValue!long(input, spec) != 0;
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range && is(T == typeof(null)))
{
    import std.conv : parse, text;
    import std.format : enforceFmt;

    enforceFmt(spec.spec == 's',
               text("Wrong unformat specifier '%", spec.spec , "' for ", T.stringof));

    return parse!T(input);
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range && isIntegral!T && !is(T == enum) && isSomeChar!(ElementType!Range))
{
    import std.algorithm.searching : find;
    import std.conv : parse, text;
    import std.format : enforceFmt, FormatException;

    if (spec.spec == 'r')
    {
        static if (is(immutable ElementEncodingType!Range == immutable char)
                || is(immutable ElementEncodingType!Range == immutable byte)
                || is(immutable ElementEncodingType!Range == immutable ubyte))
            return rawRead!T(input);
        else
            throw new FormatException(
                "The raw read specifier %r may only be used with narrow strings and ranges of bytes."
            );
    }

    enforceFmt(find(acceptedSpecs!T, spec.spec).length,
               text("Wrong unformat specifier '%", spec.spec , "' for ", T.stringof));

    enforceFmt(spec.width == 0, "Parsing integers with a width specification is not implemented");   // TODO

    immutable uint base =
        spec.spec == 'x' || spec.spec == 'X' ? 16 :
        spec.spec == 'o' ? 8 :
        spec.spec == 'b' ? 2 :
        spec.spec == 's' || spec.spec == 'd' || spec.spec == 'u' ? 10 : 0;
    assert(base != 0, "base must be not equal to zero");

    return parse!T(input, base);

}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isFloatingPoint!T && !is(T == enum) && isInputRange!Range
    && isSomeChar!(ElementType!Range)&& !is(Range == enum))
{
    import std.algorithm.searching : find;
    import std.conv : parse, text;
    import std.format : enforceFmt, FormatException;

    if (spec.spec == 'r')
    {
        static if (is(immutable ElementEncodingType!Range == immutable char)
                || is(immutable ElementEncodingType!Range == immutable byte)
                || is(immutable ElementEncodingType!Range == immutable ubyte))
            return rawRead!T(input);
        else
            throw new FormatException(
                "The raw read specifier %r may only be used with narrow strings and ranges of bytes."
            );
    }

    enforceFmt(find(acceptedSpecs!T, spec.spec).length,
               text("Wrong unformat specifier '%", spec.spec , "' for ", T.stringof));

    return parse!T(input);
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range && isSomeChar!T && !is(T == enum) && isSomeChar!(ElementType!Range))
{
    import std.algorithm.searching : find;
    import std.conv : to, text;
    import std.range.primitives : empty, front, popFront;
    import std.format : enforceFmt, unformatValue;

    if (spec.spec == 's' || spec.spec == 'c')
    {
        auto result = to!T(input.front);
        input.popFront();
        return result;
    }

    enforceFmt(find(acceptedSpecs!T, spec.spec).length,
               text("Wrong unformat specifier '%", spec.spec , "' for ", T.stringof));

    static if (T.sizeof == 1)
        return unformatValue!ubyte(input, spec);
    else static if (T.sizeof == 2)
        return unformatValue!ushort(input, spec);
    else static if (T.sizeof == 4)
        return unformatValue!uint(input, spec);
    else
        static assert(false, T.stringof ~ ".sizeof must be 1, 2, or 4 not " ~
                      to!string(T.sizeof));
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char fmt)
if (isInputRange!Range && is(StringTypeOf!T) && !isAggregateType!T && !is(T == enum))
{
    import std.conv : text;
    import std.range.primitives : empty, front, popFront, put;
    import std.format : enforceFmt;

    const spec = fmt.spec;
    if (spec == '(')
    {
        return unformatRange!T(input, fmt);
    }
    enforceFmt(spec == 's',
               text("Wrong unformat specifier '%", spec , "' for ", T.stringof));

    static if (isStaticArray!T)
    {
        T result;
        auto app = result[];
    }
    else
    {
        import std.array : appender;
        auto app = appender!T();
    }
    if (fmt.trailing.empty)
    {
        for (; !input.empty; input.popFront())
        {
            static if (isStaticArray!T)
                if (app.empty)
                    break;
            app.put(input.front);
        }
    }
    else
    {
        immutable end = fmt.trailing.front;
        for (; !input.empty && input.front != end; input.popFront())
        {
            static if (isStaticArray!T)
                if (app.empty)
                    break;
            app.put(input.front);
        }
    }
    static if (isStaticArray!T)
    {
        enforceFmt(app.empty, "need more input");
        return result;
    }
    else
        return app.data;
}

T unformatValueImpl(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char fmt)
if (isInputRange!Range && !is(StringTypeOf!T) && !isAggregateType!T
    && (isArray!T || isAssociativeArray!T || is(T == enum)))
{
    import std.conv : parse, text;
    import std.format : enforceFmt;

    const spec = fmt.spec;
    if (spec == '(')
    {
        return unformatRange!T(input, fmt);
    }

    enforceFmt(spec == 's',
               text("Wrong unformat specifier '%", spec , "' for ", T.stringof));

    return parse!T(input);
}

/*
 * Function that performs raw reading. Used by unformatValue
 * for integral and float types.
 */
private T rawRead(T, Range)(ref Range input)
if (is(immutable ElementEncodingType!Range == immutable char)
    || is(immutable ElementEncodingType!Range == immutable byte)
    || is(immutable ElementEncodingType!Range == immutable ubyte))
{
    import std.range.primitives : popFront;

    union X
    {
        ubyte[T.sizeof] raw;
        T typed;
    }
    X x;
    foreach (i; 0 .. T.sizeof)
    {
        static if (isSomeString!Range)
        {
            x.raw[i] = input[0];
            input = input[1 .. $];
        }
        else
        {
            // TODO: recheck this
            x.raw[i] = input.front;
            input.popFront();
        }
    }
    return x.typed;
}

private T unformatRange(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
in (spec.spec == '(', "spec.spec must be '(' not " ~ spec.spec)
{
    import std.range.primitives : empty, front, popFront;
    import std.format : enforceFmt, format;

    T result;
    static if (isStaticArray!T)
    {
        size_t i;
    }

    const(Char)[] cont = spec.trailing;
    for (size_t j = 0; j < spec.trailing.length; ++j)
    {
        if (spec.trailing[j] == '%')
        {
            cont = spec.trailing[0 .. j];
            break;
        }
    }

    bool checkEnd()
    {
        return input.empty || !cont.empty && input.front == cont.front;
    }

    if (!checkEnd())
    {
        for (;;)
        {
            auto fmt = FormatSpec!Char(spec.nested);
            fmt.readUpToNextSpec(input);
            enforceFmt(!input.empty, "Unexpected end of input when parsing range");

            static if (isStaticArray!T)
            {
                result[i++] = unformatElement!(typeof(T.init[0]))(input, fmt);
            }
            else static if (isDynamicArray!T)
            {
                import std.conv : WideElementType;
                result ~= unformatElement!(WideElementType!T)(input, fmt);
            }
            else static if (isAssociativeArray!T)
            {
                auto key = unformatElement!(typeof(T.init.keys[0]))(input, fmt);
                fmt.readUpToNextSpec(input);        // eat key separator

                result[key] = unformatElement!(typeof(T.init.values[0]))(input, fmt);
            }

            static if (isStaticArray!T)
            {
                enforceFmt(i <= T.length,
                           "Too many format specifiers for static array of length %d".format(T.length));
            }

            if (spec.sep !is null)
                fmt.readUpToNextSpec(input);
            auto sep = spec.sep !is null ? spec.sep : fmt.trailing;

            if (checkEnd())
                break;

            if (!sep.empty && input.front == sep.front)
            {
                while (!sep.empty)
                {
                    enforceFmt(!input.empty,
                               "Unexpected end of input when parsing range separator");
                    enforceFmt(input.front == sep.front,
                               "Unexpected character when parsing range separator");
                    input.popFront();
                    sep.popFront();
                }
            }
        }
    }
    static if (isStaticArray!T)
    {
        enforceFmt(i == T.length,
                   "Too few (%d) format specifiers for static array of length %d".format(i, T.length));
    }
    return result;
}

T unformatElement(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range)
{
    import std.conv : parseElement;
    import std.format.read : unformatValue;

    static if (isSomeString!T)
    {
        if (spec.spec == 's')
        {
            return parseElement!T(input);
        }
    }
    else static if (isSomeChar!T)
    {
        if (spec.spec == 's')
        {
            return parseElement!T(input);
        }
    }

    return unformatValue!T(input, spec);
}
                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.

/*
   Copyright: Copyright The D Language Foundation 2000-2013.

   License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

   Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
   Andrei Alexandrescu), and Kenji Hara

   Source: $(PHOBOSSRC std/format/internal/write.d)
 */
module std.format.internal.write;

import std.format.spec : FormatSpec;
import std.range.primitives : isInputRange;
import std.traits;

version (StdUnittest)
{
    import std.exception : assertCTFEable;
    import std.format : format;
}

package(std.format):

/*
    `bool`s are formatted as `"true"` or `"false"` with `%s` and as `1` or
    `0` with integral-specific format specs.
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(BooleanTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    BooleanTypeOf!T val = obj;

    if (f.spec == 's')
        writeAligned(w, val ? "true" : "false", f);
    else
        formatValueImpl(w, cast(byte) val, f);
}

@safe pure unittest
{
    assertCTFEable!(
    {
        formatTest(false, "false");
        formatTest(true,  "true");
    });
}

@safe unittest
{
    struct S1
    {
        bool val;
        alias val this;
    }

    struct S2
    {
        bool val;
        alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S1(false), "false");
    formatTest(S1(true),  "true");
    formatTest(S2(false), "S");
    formatTest(S2(true),  "S");
}

@safe pure unittest
{
    string t1 = format("[%6s] [%6s] [%-6s]", true, false, true);
    assert(t1 == "[  true] [ false] [true  ]");

    string t2 = format("[%3s] [%-2s]", true, false);
    assert(t2 == "[true] [false]");
}

// https://issues.dlang.org/show_bug.cgi?id=20534
@safe pure unittest
{
    assert(format("%r",false) == "\0");
}

@safe pure unittest
{
    assert(format("%07s",true) == "   true");
}

@safe pure unittest
{
    assert(format("%=8s",true)    == "  true  ");
    assert(format("%=9s",false)   == "  false  ");
    assert(format("%=9s",true)    == "   true  ");
    assert(format("%-=9s",true)   == "  true   ");
    assert(format("%=10s",false)  == "   false  ");
    assert(format("%-=10s",false) == "  false   ");
}

/*
    `null` literal is formatted as `"null"`
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(immutable T == immutable typeof(null)) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.format : enforceFmt;

    const spec = f.spec;
    enforceFmt(spec == 's', "null literal cannot match %" ~ spec);

    writeAligned(w, "null", f);
}

@safe pure unittest
{
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;
    import std.range.primitives : back;

    assert(collectExceptionMsg!FormatException(format("%p", null)).back == 'p');

    assertCTFEable!(
    {
        formatTest(null, "null");
    });
}

@safe pure unittest
{
    string t = format("[%6s] [%-6s]", null, null);
    assert(t == "[  null] [null  ]");
}

/*
    Integrals are formatted like $(REF printf, core, stdc, stdio).
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(IntegralTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    alias U = IntegralTypeOf!T;
    U val = obj;    // Extracting alias this may be impure/system/may-throw

    if (f.spec == 'r')
    {
        // raw write, skip all else and write the thing
        auto raw = (ref val) @trusted {
            return (cast(const char*) &val)[0 .. val.sizeof];
        }(val);
        import std.range.primitives : put;
        if (needToSwapEndianess(f))
            foreach_reverse (c; raw)
                put(w, c);
        else
            foreach (c; raw)
                put(w, c);
        return;
    }

    static if (isSigned!U)
    {
        const negative = val < 0 && f.spec != 'x' && f.spec != 'X' && f.spec != 'b' && f.spec != 'o' && f.spec != 'u';
        ulong arg = negative ? -cast(ulong) val : val;
    }
    else
    {
        const negative = false;
        ulong arg = val;
    }
    arg &= Unsigned!U.max;

    formatValueImplUlong!(Writer, Char)(w, arg, negative, f);
}

// Helper function for `formatValueImpl` that avoids template bloat
private void formatValueImplUlong(Writer, Char)(auto ref Writer w, ulong arg, in bool negative,
                                                scope const ref FormatSpec!Char f)
{
    immutable uint base = baseOfSpec(f.spec);

    const bool zero = arg == 0;
    char[64] digits = void;
    size_t pos = digits.length - 1;
    do
    {
        /* `cast(char)` is needed because value range propagation (VRP) cannot
         * analyze `base` because it’s computed in a separate function
         * (`baseOfSpec`). */
        digits[pos--] = cast(char) ('0' + arg % base);
        if (base > 10 && digits[pos + 1] > '9')
            digits[pos + 1] += ((f.spec == 'x' || f.spec == 'a') ? 'a' : 'A') - '0' - 10;
        arg /= base;
    } while (arg > 0);

    char[3] prefix = void;
    size_t left = 2;
    size_t right = 2;

    // add sign
    if (f.spec != 'x' && f.spec != 'X' && f.spec != 'b' && f.spec != 'o' && f.spec != 'u')
    {
        if (negative)
            prefix[right++] = '-';
        else if (f.flPlus)
            prefix[right++] = '+';
        else if (f.flSpace)
            prefix[right++] = ' ';
    }

    // not a floating point like spec
    if (f.spec == 'x' || f.spec == 'X' || f.spec == 'b' || f.spec == 'o' || f.spec == 'u'
        || f.spec == 'd' || f.spec == 's')
    {
        if (f.flHash && (base == 16) && !zero)
        {
            prefix[--left] = f.spec;
            prefix[--left] = '0';
        }
        if (f.flHash && (base == 8) && !zero
            && (digits.length - (pos + 1) >= f.precision || f.precision == f.UNSPECIFIED))
            prefix[--left] = '0';

        writeAligned(w, prefix[left .. right], digits[pos + 1 .. $], "", f, true);
        return;
    }

    FormatSpec!Char fs = f;
    if (f.precision == f.UNSPECIFIED)
        fs.precision = cast(typeof(fs.precision)) (digits.length - pos - 2);

    // %f like output
    if (f.spec == 'f' || f.spec == 'F'
        || ((f.spec == 'g' || f.spec == 'G') && (fs.precision >= digits.length - pos - 2)))
    {
        if (f.precision == f.UNSPECIFIED)
            fs.precision = 0;

        writeAligned(w, prefix[left .. right], digits[pos + 1 .. $], ".", "", fs,
                     (f.spec == 'g' || f.spec == 'G') ? PrecisionType.allDigits : PrecisionType.fractionalDigits);

        return;
    }

    import std.algorithm.searching : all;

    // at least one digit for %g
    if ((f.spec == 'g' || f.spec == 'G') && fs.precision == 0)
        fs.precision = 1;

    // rounding
    size_t digit_end = pos + fs.precision + ((f.spec == 'g' || f.spec == 'G') ? 1 : 2);
    if (digit_end <= digits.length)
    {
        RoundingClass rt = RoundingClass.ZERO;
        if (digit_end < digits.length)
        {
            auto tie = (f.spec == 'a' || f.spec == 'A') ? '8' : '5';
            if (digits[digit_end] >= tie)
            {
                rt = RoundingClass.UPPER;
                if (digits[digit_end] == tie && digits[digit_end + 1 .. $].all!(a => a == '0'))
                    rt = RoundingClass.FIVE;
            }
            else
            {
                rt = RoundingClass.LOWER;
                if (digits[digit_end .. $].all!(a => a == '0'))
                    rt = RoundingClass.ZERO;
            }
        }

        if (round(digits, pos + 1, digit_end, rt, negative,
                  f.spec == 'a' ? 'f' : (f.spec == 'A' ? 'F' : '9')))
        {
            pos--;
            digit_end--;
        }
    }

    // convert to scientific notation
    char[1] int_digit = void;
    int_digit[0] = digits[pos + 1];
    digits[pos + 1] = '.';

    char[4] suffix = void;

    if (f.spec == 'e' || f.spec == 'E' || f.spec == 'g' || f.spec == 'G')
    {
        suffix[0] = (f.spec == 'e' || f.spec == 'g') ? 'e' : 'E';
        suffix[1] = '+';
        suffix[2] = cast(char) ('0' + (digits.length - pos - 2) / 10);
        suffix[3] = cast(char) ('0' + (digits.length - pos - 2) % 10);
    }
    else
    {
        if (right == 3)
            prefix[0] = prefix[2];
        prefix[1] = '0';
        prefix[2] = f.spec == 'a' ? 'x' : 'X';

        left = right == 3 ? 0 : 1;
        right = 3;

        suffix[0] = f.spec == 'a' ? 'p' : 'P';
        suffix[1] = '+';
        suffix[2] = cast(char) ('0' + ((digits.length - pos - 2) * 4) / 10);
        suffix[3] = cast(char) ('0' + ((digits.length - pos - 2) * 4) % 10);
    }

    import std.algorithm.comparison : min;

    // remove trailing zeros
    if ((f.spec == 'g' || f.spec == 'G') && !f.flHash)
    {
        digit_end = min(digit_end, digits.length);
        while (digit_end > pos + 1 &&
               (digits[digit_end - 1] == '0' || digits[digit_end - 1] == '.'))
            digit_end--;
    }

    writeAligned(w, prefix[left .. right], int_digit[0 .. $],
                 digits[pos + 1 .. min(digit_end, $)],
                 suffix[0 .. $], fs,
                 (f.spec == 'g' || f.spec == 'G') ? PrecisionType.allDigits : PrecisionType.fractionalDigits);
}

private uint baseOfSpec(in char spec) @safe pure
{
    typeof(return) base =
        spec == 'x' || spec == 'X' || spec == 'a' || spec == 'A' ? 16 :
        spec == 'o' ? 8 :
        spec == 'b' ? 2 :
        spec == 's' || spec == 'd' || spec == 'u'
        || spec == 'e' || spec == 'E' || spec == 'f' || spec == 'F'
        || spec == 'g' || spec == 'G' ? 10 :
        0;

    import std.format : enforceFmt;
    enforceFmt(base > 0,
        "incompatible format character for integral argument: %" ~ spec);

    return base;
}

@safe pure unittest
{
    assertCTFEable!(
    {
        formatTest(byte.min, "-128");
        formatTest(byte.max, "127");
        formatTest(short.min, "-32768");
        formatTest(short.max, "32767");
        formatTest(int.min, "-2147483648");
        formatTest(int.max, "2147483647");
        formatTest(long.min, "-9223372036854775808");
        formatTest(long.max, "9223372036854775807");

        formatTest(ubyte.min, "0");
        formatTest(ubyte.max, "255");
        formatTest(ushort.min, "0");
        formatTest(ushort.max, "65535");
        formatTest(uint.min, "0");
        formatTest(uint.max, "4294967295");
        formatTest(ulong.min, "0");
        formatTest(ulong.max, "18446744073709551615");
    });
}

// https://issues.dlang.org/show_bug.cgi?id=18838
@safe pure unittest
{
    assert("%12,d".format(0) == "           0");
}

@safe pure unittest
{
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;
    import std.range.primitives : back;

    assert(collectExceptionMsg!FormatException(format("%c", 5)).back == 'c');

    assertCTFEable!(
    {
        formatTest(9, "9");
        formatTest(10, "10");
    });
}

@safe unittest
{
    struct S1
    {
        long val;
        alias val this;
    }

    struct S2
    {
        long val;
        alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S1(10), "10");
    formatTest(S2(10), "S");
}

// https://issues.dlang.org/show_bug.cgi?id=20064
@safe unittest
{
    assert(format( "%03,d",  1234) ==              "1,234");
    assert(format( "%04,d",  1234) ==              "1,234");
    assert(format( "%05,d",  1234) ==              "1,234");
    assert(format( "%06,d",  1234) ==             "01,234");
    assert(format( "%07,d",  1234) ==            "001,234");
    assert(format( "%08,d",  1234) ==          "0,001,234");
    assert(format( "%09,d",  1234) ==          "0,001,234");
    assert(format("%010,d",  1234) ==         "00,001,234");
    assert(format("%011,d",  1234) ==        "000,001,234");
    assert(format("%012,d",  1234) ==      "0,000,001,234");
    assert(format("%013,d",  1234) ==      "0,000,001,234");
    assert(format("%014,d",  1234) ==     "00,000,001,234");
    assert(format("%015,d",  1234) ==    "000,000,001,234");
    assert(format("%016,d",  1234) ==  "0,000,000,001,234");
    assert(format("%017,d",  1234) ==  "0,000,000,001,234");

    assert(format( "%03,d", -1234) ==             "-1,234");
    assert(format( "%04,d", -1234) ==             "-1,234");
    assert(format( "%05,d", -1234) ==             "-1,234");
    assert(format( "%06,d", -1234) ==             "-1,234");
    assert(format( "%07,d", -1234) ==            "-01,234");
    assert(format( "%08,d", -1234) ==           "-001,234");
    assert(format( "%09,d", -1234) ==         "-0,001,234");
    assert(format("%010,d", -1234) ==         "-0,001,234");
    assert(format("%011,d", -1234) ==        "-00,001,234");
    assert(format("%012,d", -1234) ==       "-000,001,234");
    assert(format("%013,d", -1234) ==     "-0,000,001,234");
    assert(format("%014,d", -1234) ==     "-0,000,001,234");
    assert(format("%015,d", -1234) ==    "-00,000,001,234");
    assert(format("%016,d", -1234) ==   "-000,000,001,234");
    assert(format("%017,d", -1234) == "-0,000,000,001,234");
}

@safe pure unittest
{
    string t1 = format("[%6s] [%-6s]", 123, 123);
    assert(t1 == "[   123] [123   ]");

    string t2 = format("[%6s] [%-6s]", -123, -123);
    assert(t2 == "[  -123] [-123  ]");
}

@safe pure unittest
{
    formatTest(byte.min, "-128");
    formatTest(short.min, "-32768");
    formatTest(int.min, "-2147483648");
    formatTest(long.min, "-9223372036854775808");
}

// https://issues.dlang.org/show_bug.cgi?id=21777
@safe pure unittest
{
    assert(format!"%20.5,d"(cast(short) 120) == "              00,120");
    assert(format!"%20.5,o"(cast(short) 120) == "              00,170");
    assert(format!"%20.5,x"(cast(short) 120) == "              00,078");
    assert(format!"%20.5,2d"(cast(short) 120) == "             0,01,20");
    assert(format!"%20.5,2o"(cast(short) 120) == "             0,01,70");
    assert(format!"%20.5,4d"(cast(short) 120) == "              0,0120");
    assert(format!"%20.5,4o"(cast(short) 120) == "              0,0170");
    assert(format!"%20.5,4x"(cast(short) 120) == "              0,0078");
    assert(format!"%20.5,2x"(3000) == "             0,0b,b8");
    assert(format!"%20.5,4d"(3000) == "              0,3000");
    assert(format!"%20.5,4o"(3000) == "              0,5670");
    assert(format!"%20.5,4x"(3000) == "              0,0bb8");
    assert(format!"%20.5,d"(-400) == "             -00,400");
    assert(format!"%20.30d"(-400) == "-000000000000000000000000000400");
    assert(format!"%20.5,4d"(0) == "              0,0000");
    assert(format!"%0#.8,2s"(12345) == "00,01,23,45");
    assert(format!"%0#.9,3x"(55) == "0x000,000,037");
}

// https://issues.dlang.org/show_bug.cgi?id=21814
@safe pure unittest
{
    assert(format("%,0d",1000) == "1000");
}

// https://issues.dlang.org/show_bug.cgi?id=21817
@safe pure unittest
{
    assert(format!"%u"(-5) == "4294967291");
}

// https://issues.dlang.org/show_bug.cgi?id=21820
@safe pure unittest
{
    assert(format!"%#.0o"(0) == "0");
}

@safe pure unittest
{
    assert(format!"%e"(10000) == "1.0000e+04");
    assert(format!"%.2e"(10000) == "1.00e+04");
    assert(format!"%.10e"(10000) == "1.0000000000e+04");

    assert(format!"%e"(9999) == "9.999e+03");
    assert(format!"%.2e"(9999) == "1.00e+04");
    assert(format!"%.10e"(9999) == "9.9990000000e+03");

    assert(format!"%f"(10000) == "10000");
    assert(format!"%.2f"(10000) == "10000.00");

    assert(format!"%g"(10000) == "10000");
    assert(format!"%.2g"(10000) == "1e+04");
    assert(format!"%.10g"(10000) == "10000");

    assert(format!"%#g"(10000) == "10000.");
    assert(format!"%#.2g"(10000) == "1.0e+04");
    assert(format!"%#.10g"(10000) == "10000.00000");

    assert(format!"%g"(9999) == "9999");
    assert(format!"%.2g"(9999) == "1e+04");
    assert(format!"%.10g"(9999) == "9999");

    assert(format!"%a"(0x10000) == "0x1.0000p+16");
    assert(format!"%.2a"(0x10000) == "0x1.00p+16");
    assert(format!"%.10a"(0x10000) == "0x1.0000000000p+16");

    assert(format!"%a"(0xffff) == "0xf.fffp+12");
    assert(format!"%.2a"(0xffff) == "0x1.00p+16");
    assert(format!"%.10a"(0xffff) == "0xf.fff0000000p+12");
}

@safe pure unittest
{
    assert(format!"%.3e"(ulong.max) == "1.845e+19");
    assert(format!"%.3f"(ulong.max) == "18446744073709551615.000");
    assert(format!"%.3g"(ulong.max) == "1.84e+19");
    assert(format!"%.3a"(ulong.max) == "0x1.000p+64");

    assert(format!"%.3e"(long.min) == "-9.223e+18");
    assert(format!"%.3f"(long.min) == "-9223372036854775808.000");
    assert(format!"%.3g"(long.min) == "-9.22e+18");
    assert(format!"%.3a"(long.min) == "-0x8.000p+60");

    assert(format!"%e"(0) == "0e+00");
    assert(format!"%f"(0) == "0");
    assert(format!"%g"(0) == "0");
    assert(format!"%a"(0) == "0x0p+00");
}

@safe pure unittest
{
    assert(format!"%.0g"(1500) == "2e+03");
}

// https://issues.dlang.org/show_bug.cgi?id=21900#
@safe pure unittest
{
    assert(format!"%.1a"(472) == "0x1.ep+08");
}

/*
    Floating-point values are formatted like $(REF printf, core, stdc, stdio)
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj,
                                      scope const ref FormatSpec!Char f)
if (is(FloatingPointTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.format : enforceFmt;
    import std.range.primitives : put;
    import std.format.internal.floats : printFloat, isFloatSpec;

    FloatingPointTypeOf!T val = obj;
    const char spec = f.spec;

    if (spec == 'r')
    {
        // raw write, skip all else and write the thing
        auto raw = (ref val) @trusted {
            return (cast(const char*) &val)[0 .. val.sizeof];
        }(val);

        if (needToSwapEndianess(f))
        {
            foreach_reverse (c; raw)
                put(w, c);
        }
        else
        {
            foreach (c; raw)
                put(w, c);
        }
        return;
    }

    FormatSpec!Char fs = f; // fs is copy for change its values.
    fs.spec = spec == 's' ? 'g' : spec;
    enforceFmt(isFloatSpec(fs.spec), "incompatible format character for floating point argument: %" ~ spec);

    static if (is(T == float) || is(T == double)
               || (is(T == real) && (T.mant_dig == double.mant_dig || T.mant_dig == 64)))
    {
        alias tval = val;
    }
    else
    {
        import std.math.traits : isInfinity;
        import std.math.operations : nextUp;

        // reals that are not supported by printFloat are cast to double.
        double tval = val;

        // Numbers greater than double.max are converted to double.max:
        if (val > double.max && !isInfinity(val))
            tval = double.max;
        if (val < -double.max && !isInfinity(val))
            tval = -double.max;

        // Numbers between the smallest representable double subnormal and 0.0
        // are converted to the smallest representable double subnormal:
        enum doubleLowest = nextUp(0.0);
        if (val > 0 && val < doubleLowest)
            tval = doubleLowest;
        if (val < 0 && val > -doubleLowest)
            tval = -doubleLowest;
    }

    printFloat(w, tval, fs);
}

@safe unittest
{
    assert(format("%.1f", 1337.7) == "1337.7");
    assert(format("%,3.2f", 1331.982) == "1,331.98");
    assert(format("%,3.0f", 1303.1982) == "1,303");
    assert(format("%#,3.4f", 1303.1982) == "1,303.1982");
    assert(format("%#,3.0f", 1303.1982) == "1,303.");
}

@safe pure unittest
{
    import std.conv : to;
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;
    import std.meta : AliasSeq;
    import std.range.primitives : back;

    assert(collectExceptionMsg!FormatException(format("%d", 5.1)).back == 'd');

    static foreach (T; AliasSeq!(float, double, real))
    {
        formatTest(to!(          T)(5.5), "5.5");
        formatTest(to!(    const T)(5.5), "5.5");
        formatTest(to!(immutable T)(5.5), "5.5");

        formatTest(T.nan, "nan");
    }
}

@safe unittest
{
    formatTest(2.25, "2.25");

    struct S1
    {
        double val;
        alias val this;
    }
    struct S2
    {
        double val;
        alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S1(2.25), "2.25");
    formatTest(S2(2.25), "S");
}

// https://issues.dlang.org/show_bug.cgi?id=19939
@safe unittest
{
    assert(format("^%13,3.2f$",          1.00) == "^         1.00$");
    assert(format("^%13,3.2f$",         10.00) == "^        10.00$");
    assert(format("^%13,3.2f$",        100.00) == "^       100.00$");
    assert(format("^%13,3.2f$",      1_000.00) == "^     1,000.00$");
    assert(format("^%13,3.2f$",     10_000.00) == "^    10,000.00$");
    assert(format("^%13,3.2f$",    100_000.00) == "^   100,000.00$");
    assert(format("^%13,3.2f$",  1_000_000.00) == "^ 1,000,000.00$");
    assert(format("^%13,3.2f$", 10_000_000.00) == "^10,000,000.00$");
}

// https://issues.dlang.org/show_bug.cgi?id=20069
@safe unittest
{
    assert(format("%012,f",   -1234.0) ==    "-1,234.000000");
    assert(format("%013,f",   -1234.0) ==    "-1,234.000000");
    assert(format("%014,f",   -1234.0) ==   "-01,234.000000");
    assert(format("%011,f",    1234.0) ==     "1,234.000000");
    assert(format("%012,f",    1234.0) ==     "1,234.000000");
    assert(format("%013,f",    1234.0) ==    "01,234.000000");
    assert(format("%014,f",    1234.0) ==   "001,234.000000");
    assert(format("%015,f",    1234.0) == "0,001,234.000000");
    assert(format("%016,f",    1234.0) == "0,001,234.000000");

    assert(format( "%08,.2f", -1234.0) ==        "-1,234.00");
    assert(format( "%09,.2f", -1234.0) ==        "-1,234.00");
    assert(format("%010,.2f", -1234.0) ==       "-01,234.00");
    assert(format("%011,.2f", -1234.0) ==      "-001,234.00");
    assert(format("%012,.2f", -1234.0) ==    "-0,001,234.00");
    assert(format("%013,.2f", -1234.0) ==    "-0,001,234.00");
    assert(format("%014,.2f", -1234.0) ==   "-00,001,234.00");
    assert(format( "%08,.2f",  1234.0) ==         "1,234.00");
    assert(format( "%09,.2f",  1234.0) ==        "01,234.00");
    assert(format("%010,.2f",  1234.0) ==       "001,234.00");
    assert(format("%011,.2f",  1234.0) ==     "0,001,234.00");
    assert(format("%012,.2f",  1234.0) ==     "0,001,234.00");
    assert(format("%013,.2f",  1234.0) ==    "00,001,234.00");
    assert(format("%014,.2f",  1234.0) ==   "000,001,234.00");
    assert(format("%015,.2f",  1234.0) == "0,000,001,234.00");
    assert(format("%016,.2f",  1234.0) == "0,000,001,234.00");
}

@safe unittest
{
    import std.math.hardware; // cannot be selective, because FloatingPointControl might not be defined

    // std.math's FloatingPointControl isn't available on all target platforms
    static if (is(FloatingPointControl))
    {
        assert(FloatingPointControl.rounding == FloatingPointControl.roundToNearest);
    }

    // https://issues.dlang.org/show_bug.cgi?id=20320
    real a = 0.16;
    real b = 0.016;
    assert(format("%.1f", a) == "0.2");
    assert(format("%.2f", b) == "0.02");

    double a1 = 0.16;
    double b1 = 0.016;
    assert(format("%.1f", a1) == "0.2");
    assert(format("%.2f", b1) == "0.02");

    // https://issues.dlang.org/show_bug.cgi?id=9889
    assert(format("%.1f", 0.09) == "0.1");
    assert(format("%.1f", -0.09) == "-0.1");
    assert(format("%.1f", 0.095) == "0.1");
    assert(format("%.1f", -0.095) == "-0.1");
    assert(format("%.1f", 0.094) == "0.1");
    assert(format("%.1f", -0.094) == "-0.1");
}

@safe unittest
{
    double a = 123.456;
    double b = -123.456;
    double c = 123.0;

    assert(format("%10.4f",a)  == "  123.4560");
    assert(format("%-10.4f",a) == "123.4560  ");
    assert(format("%+10.4f",a) == " +123.4560");
    assert(format("% 10.4f",a) == "  123.4560");
    assert(format("%010.4f",a) == "00123.4560");
    assert(format("%#10.4f",a) == "  123.4560");

    assert(format("%10.4f",b)  == " -123.4560");
    assert(format("%-10.4f",b) == "-123.4560 ");
    assert(format("%+10.4f",b) == " -123.4560");
    assert(format("% 10.4f",b) == " -123.4560");
    assert(format("%010.4f",b) == "-0123.4560");
    assert(format("%#10.4f",b) == " -123.4560");

    assert(format("%10.0f",c)  == "       123");
    assert(format("%-10.0f",c) == "123       ");
    assert(format("%+10.0f",c) == "      +123");
    assert(format("% 10.0f",c) == "       123");
    assert(format("%010.0f",c) == "0000000123");
    assert(format("%#10.0f",c) == "      123.");

    assert(format("%+010.4f",a) == "+0123.4560");
    assert(format("% 010.4f",a) == " 0123.4560");
    assert(format("% +010.4f",a) == "+0123.4560");
}

@safe unittest
{
    string t1 = format("[%6s] [%-6s]", 12.3, 12.3);
    assert(t1 == "[  12.3] [12.3  ]");

    string t2 = format("[%6s] [%-6s]", -12.3, -12.3);
    assert(t2 == "[ -12.3] [-12.3 ]");
}

// https://issues.dlang.org/show_bug.cgi?id=20396
@safe unittest
{
    import std.math.operations : nextUp;

    assert(format!"%a"(nextUp(0.0f)) == "0x0.000002p-126");
    assert(format!"%a"(nextUp(0.0)) == "0x0.0000000000001p-1022");
}

// https://issues.dlang.org/show_bug.cgi?id=20371
@safe unittest
{
    assert(format!"%.1000a"(1.0).length == 1007);
    assert(format!"%.600f"(0.1).length == 602);
    assert(format!"%.600e"(0.1L).length == 606);
}

@safe unittest
{
    import std.math.hardware; // cannot be selective, because FloatingPointControl might not be defined

    // std.math's FloatingPointControl isn't available on all target platforms
    static if (is(FloatingPointControl))
    {
        FloatingPointControl fpctrl;

        fpctrl.rounding = FloatingPointControl.roundUp;
        assert(format!"%.0e"(3.5) == "4e+00");
        assert(format!"%.0e"(4.5) == "5e+00");
        assert(format!"%.0e"(-3.5) == "-3e+00");
        assert(format!"%.0e"(-4.5) == "-4e+00");

        fpctrl.rounding = FloatingPointControl.roundDown;
        assert(format!"%.0e"(3.5) == "3e+00");
        assert(format!"%.0e"(4.5) == "4e+00");
        assert(format!"%.0e"(-3.5) == "-4e+00");
        assert(format!"%.0e"(-4.5) == "-5e+00");

        fpctrl.rounding = FloatingPointControl.roundToZero;
        assert(format!"%.0e"(3.5) == "3e+00");
        assert(format!"%.0e"(4.5) == "4e+00");
        assert(format!"%.0e"(-3.5) == "-3e+00");
        assert(format!"%.0e"(-4.5) == "-4e+00");

        fpctrl.rounding = FloatingPointControl.roundToNearest;
        assert(format!"%.0e"(3.5) == "4e+00");
        assert(format!"%.0e"(4.5) == "4e+00");
        assert(format!"%.0e"(-3.5) == "-4e+00");
        assert(format!"%.0e"(-4.5) == "-4e+00");
    }
}

@safe pure unittest
{
    static assert(format("%e",1.0) == "1.000000e+00");
    static assert(format("%e",-1.234e156) == "-1.234000e+156");
    static assert(format("%a",1.0) == "0x1p+0");
    static assert(format("%a",-1.234e156) == "-0x1.7024c96ca3ce4p+518");
    static assert(format("%f",1.0) == "1.000000");
    static assert(format("%f",-1.234e156) ==
                  "-123399999999999990477495546305353609103201879173427886566531" ~
                  "0740685826234179310516880117527217443004051984432279880308552" ~
                  "009640198043032289366552939010719744.000000");
    static assert(format("%g",1.0) == "1");
    static assert(format("%g",-1.234e156) == "-1.234e+156");

    static assert(format("%e",1.0f) == "1.000000e+00");
    static assert(format("%e",-1.234e23f) == "-1.234000e+23");
    static assert(format("%a",1.0f) == "0x1p+0");
    static assert(format("%a",-1.234e23f) == "-0x1.a2187p+76");
    static assert(format("%f",1.0f) == "1.000000");
    static assert(format("%f",-1.234e23f) == "-123399998884238311030784.000000");
    static assert(format("%g",1.0f) == "1");
    static assert(format("%g",-1.234e23f) == "-1.234e+23");
}

// https://issues.dlang.org/show_bug.cgi?id=21641
@safe unittest
{
    float a = -999999.8125;
    assert(format("%#.5g",a) == "-1.0000e+06");
    assert(format("%#.6g",a) == "-1.00000e+06");
}

// https://issues.dlang.org/show_bug.cgi?id=8424
@safe pure unittest
{
    static assert(format("%s", 0.6f) == "0.6");
    static assert(format("%s", 0.6) == "0.6");
    static assert(format("%s", 0.6L) == "0.6");
}

// https://issues.dlang.org/show_bug.cgi?id=9297
@safe pure unittest
{
    static if (real.mant_dig == 64) // 80 bit reals
    {
        assert(format("%.25f", 1.6180339887_4989484820_4586834365L) == "1.6180339887498948482072100");
    }
}

// https://issues.dlang.org/show_bug.cgi?id=21853
@safe pure unittest
{
    import std.math.exponential : log2;

    // log2 is broken for x87-reals on some computers in CTFE
    // the following test excludes these computers from the test
    // (https://issues.dlang.org/show_bug.cgi?id=21757)
    enum test = cast(int) log2(3.05e2312L);
    static if (real.mant_dig == 64 && test == 7681) // 80 bit reals
    {
        static assert(format!"%e"(real.max) == "1.189731e+4932");
    }
}

// https://issues.dlang.org/show_bug.cgi?id=21842
@safe pure unittest
{
    assert(format!"%-+05,g"(1.0) == "+1   ");
}

// https://issues.dlang.org/show_bug.cgi?id=20536
@safe pure unittest
{
    real r = .00000095367431640625L;
    assert(format("%a", r) == "0x1p-20");
}

// https://issues.dlang.org/show_bug.cgi?id=21840
@safe pure unittest
{
    assert(format!"% 0,e"(0.0) == " 0.000000e+00");
}

// https://issues.dlang.org/show_bug.cgi?id=21841
@safe pure unittest
{
    assert(format!"%0.0,e"(0.0) == "0e+00");
}

// https://issues.dlang.org/show_bug.cgi?id=21836
@safe pure unittest
{
    assert(format!"%-5,1g"(0.0) == "0    ");
}

// https://issues.dlang.org/show_bug.cgi?id=21838
@safe pure unittest
{
    assert(format!"%#,a"(0.0) == "0x0.p+0");
}

/*
    Formatting a `creal` is deprecated but still kept around for a while.
 */
deprecated("Use of complex types is deprecated. Use std.complex")
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(immutable T : immutable creal) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.range.primitives : put;

    immutable creal val = obj;

    formatValueImpl(w, val.re, f);
    if (val.im >= 0)
    {
        put(w, '+');
    }
    formatValueImpl(w, val.im, f);
    put(w, 'i');
}

/*
    Formatting an `ireal` is deprecated but still kept around for a while.
 */
deprecated("Use of imaginary types is deprecated. Use std.complex")
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(immutable T : immutable ireal) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.range.primitives : put;

    immutable ireal val = obj;

    formatValueImpl(w, val.im, f);
    put(w, 'i');
}

/*
    Individual characters are formatted as Unicode characters with `%s`
    and as integers with integral-specific format specs
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, const(T) obj, scope const ref FormatSpec!Char f)
if (is(CharTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.meta : AliasSeq;

    CharTypeOf!T[1] val = obj;

    if (f.spec == 's' || f.spec == 'c')
        writeAligned(w, val[], f);
    else
    {
        alias U = AliasSeq!(ubyte, ushort, uint)[CharTypeOf!T.sizeof/2];
        formatValueImpl(w, cast(U) val[0], f);
    }
}

@safe pure unittest
{
    assertCTFEable!(
    {
        formatTest('c', "c");
    });
}

@safe unittest
{
    struct S1
    {
        char val;
        alias val this;
    }

    struct S2
    {
        char val;
        alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S1('c'), "c");
    formatTest(S2('c'), "S");
}

@safe unittest
{
    //Little Endian
    formatTest("%-r", cast( char)'c', ['c'         ]);
    formatTest("%-r", cast(wchar)'c', ['c', 0      ]);
    formatTest("%-r", cast(dchar)'c', ['c', 0, 0, 0]);
    formatTest("%-r", '本', ['\x2c', '\x67'] );

    //Big Endian
    formatTest("%+r", cast( char)'c', [         'c']);
    formatTest("%+r", cast(wchar)'c', [0,       'c']);
    formatTest("%+r", cast(dchar)'c', [0, 0, 0, 'c']);
    formatTest("%+r", '本', ['\x67', '\x2c']);
}


@safe pure unittest
{
    string t1 = format("[%6s] [%-6s]", 'A', 'A');
    assert(t1 == "[     A] [A     ]");
    string t2 = format("[%6s] [%-6s]", '本', '本');
    assert(t2 == "[     本] [本     ]");
}

/*
    Strings are formatted like $(REF printf, core, stdc, stdio)
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, scope const(T) obj,
    scope const ref FormatSpec!Char f)
if (is(StringTypeOf!T) && !is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    Unqual!(const(StringTypeOf!T)) val = obj;  // for `alias this`, see bug5371
    formatRange(w, val, f);
}

@safe unittest
{
    formatTest("abc", "abc");
}

@safe pure unittest
{
    import std.exception : collectExceptionMsg;
    import std.range.primitives : back;

    assert(collectExceptionMsg(format("%d", "hi")).back == 'd');
}

@safe unittest
{
    // Test for bug 5371 for structs
    struct S1
    {
        const string var;
        alias var this;
    }

    struct S2
    {
        string var;
        alias var this;
    }

    formatTest(S1("s1"), "s1");
    formatTest(S2("s2"), "s2");
}

@safe unittest
{
    struct S3
    {
        string val; alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S3("s3"), "S");
}

@safe pure unittest
{
    //Little Endian
    formatTest("%-r", "ab"c, ['a'         , 'b'         ]);
    formatTest("%-r", "ab"w, ['a', 0      , 'b', 0      ]);
    formatTest("%-r", "ab"d, ['a', 0, 0, 0, 'b', 0, 0, 0]);
    formatTest("%-r", "日本語"c, ['\xe6', '\x97', '\xa5', '\xe6', '\x9c', '\xac',
                                  '\xe8', '\xaa', '\x9e']);
    formatTest("%-r", "日本語"w, ['\xe5', '\x65', '\x2c', '\x67', '\x9e', '\x8a']);
    formatTest("%-r", "日本語"d, ['\xe5', '\x65', '\x00', '\x00', '\x2c', '\x67',
                                  '\x00', '\x00', '\x9e', '\x8a', '\x00', '\x00']);

    //Big Endian
    formatTest("%+r", "ab"c, [         'a',          'b']);
    formatTest("%+r", "ab"w, [      0, 'a',       0, 'b']);
    formatTest("%+r", "ab"d, [0, 0, 0, 'a', 0, 0, 0, 'b']);
    formatTest("%+r", "日本語"c, ['\xe6', '\x97', '\xa5', '\xe6', '\x9c', '\xac',
                                  '\xe8', '\xaa', '\x9e']);
    formatTest("%+r", "日本語"w, ['\x65', '\xe5', '\x67', '\x2c', '\x8a', '\x9e']);
    formatTest("%+r", "日本語"d, ['\x00', '\x00', '\x65', '\xe5', '\x00', '\x00',
                                  '\x67', '\x2c', '\x00', '\x00', '\x8a', '\x9e']);
}

@safe pure unittest
{
    string t1 = format("[%6s] [%-6s]", "AB", "AB");
    assert(t1 == "[    AB] [AB    ]");
    string t2 = format("[%6s] [%-6s]", "本Ä", "本Ä");
    assert(t2 == "[    本Ä] [本Ä    ]");
}

// https://issues.dlang.org/show_bug.cgi?id=6640
@safe unittest
{
    import std.range.primitives : front, popFront;

    struct Range
    {
        @safe:

        string value;
        @property bool empty() const { return !value.length; }
        @property dchar front() const { return value.front; }
        void popFront() { value.popFront(); }

        @property size_t length() const { return value.length; }
    }
    immutable table =
    [
        ["[%s]", "[string]"],
        ["[%10s]", "[    string]"],
        ["[%-10s]", "[string    ]"],
        ["[%(%02x %)]", "[73 74 72 69 6e 67]"],
        ["[%(%c %)]", "[s t r i n g]"],
    ];
    foreach (e; table)
    {
        formatTest(e[0], "string", e[1]);
        formatTest(e[0], Range("string"), e[1]);
    }
}

@safe unittest
{
    import std.meta : AliasSeq;

    // string literal from valid UTF sequence is encoding free.
    static foreach (StrType; AliasSeq!(string, wstring, dstring))
    {
        // Valid and printable (ASCII)
        formatTest([cast(StrType)"hello"],
                   `["hello"]`);

        // 1 character escape sequences (' is not escaped in strings)
        formatTest([cast(StrType)"\"'\0\\\a\b\f\n\r\t\v"],
                   `["\"'\0\\\a\b\f\n\r\t\v"]`);

        // 1 character optional escape sequences
        formatTest([cast(StrType)"\'\?"],
                   `["'?"]`);

        // Valid and non-printable code point (<= U+FF)
        formatTest([cast(StrType)"\x10\x1F\x20test"],
                   `["\x10\x1F test"]`);

        // Valid and non-printable code point (<= U+FFFF)
        formatTest([cast(StrType)"\u200B..\u200F"],
                   `["\u200B..\u200F"]`);

        // Valid and non-printable code point (<= U+10FFFF)
        formatTest([cast(StrType)"\U000E0020..\U000E007F"],
                   `["\U000E0020..\U000E007F"]`);
    }

    // invalid UTF sequence needs hex-string literal postfix (c/w/d)
    () @trusted
    {
        // U+FFFF with UTF-8 (Invalid code point for interchange)
        formatTest([cast(string)[0xEF, 0xBF, 0xBF]],
                   `[[cast(char) 0xEF, cast(char) 0xBF, cast(char) 0xBF]]`);

        // U+FFFF with UTF-16 (Invalid code point for interchange)
        formatTest([cast(wstring)[0xFFFF]],
                   `[[cast(wchar) 0xFFFF]]`);

        // U+FFFF with UTF-32 (Invalid code point for interchange)
        formatTest([cast(dstring)[0xFFFF]],
                   `[[cast(dchar) 0xFFFF]]`);
    } ();
}

/*
    Static-size arrays are formatted as dynamic arrays.
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, auto ref T obj,
    scope const ref FormatSpec!Char f)
if (is(StaticArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    formatValueImpl(w, obj[], f);
}

// Test for https://issues.dlang.org/show_bug.cgi?id=8310
@safe unittest
{
    import std.array : appender;
    import std.format : formatValue;

    FormatSpec!char f;
    auto w = appender!string();

    char[2] two = ['a', 'b'];
    formatValue(w, two, f);

    char[2] getTwo() { return two; }
    formatValue(w, getTwo(), f);
}

// https://issues.dlang.org/show_bug.cgi?id=18205
@safe pure unittest
{
    assert("|%8s|".format("abc")       == "|     abc|");
    assert("|%8s|".format("αβγ")       == "|     αβγ|");
    assert("|%8s|".format("   ")       == "|        |");
    assert("|%8s|".format("été"d)      == "|     été|");
    assert("|%8s|".format("été 2018"w) == "|été 2018|");

    assert("%2s".format("e\u0301"w) == " e\u0301");
    assert("%2s".format("a\u0310\u0337"d) == " a\u0310\u0337");
}

/*
    Dynamic arrays are formatted as input ranges.
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, T obj, scope const ref FormatSpec!Char f)
if (is(DynamicArrayTypeOf!T) && !is(StringTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    static if (is(immutable(ArrayTypeOf!T) == immutable(void[])))
    {
        formatValueImpl(w, cast(const ubyte[]) obj, f);
    }
    else static if (!isInputRange!T)
    {
        alias U = Unqual!(ArrayTypeOf!T);
        static assert(isInputRange!U, U.stringof ~ " must be an InputRange");
        U val = obj;
        formatValueImpl(w, val, f);
    }
    else
    {
        formatRange(w, obj, f);
    }
}

// https://issues.dlang.org/show_bug.cgi?id=20848
@safe unittest
{
    class C
    {
        immutable(void)[] data;
    }

    import std.typecons : Nullable;
    Nullable!C c;
}

// alias this, input range I/F, and toString()
@safe unittest
{
    struct S(int flags)
    {
        int[] arr;
        static if (flags & 1)
            alias arr this;

        static if (flags & 2)
        {
            @property bool empty() const { return arr.length == 0; }
            @property int front() const { return arr[0] * 2; }
            void popFront() { arr = arr[1 .. $]; }
        }

        static if (flags & 4)
            string toString() const { return "S"; }
    }

    formatTest(S!0b000([0, 1, 2]), "S!0([0, 1, 2])");
    formatTest(S!0b001([0, 1, 2]), "[0, 1, 2]");        // Test for bug 7628
    formatTest(S!0b010([0, 1, 2]), "[0, 2, 4]");
    formatTest(S!0b011([0, 1, 2]), "[0, 2, 4]");
    formatTest(S!0b100([0, 1, 2]), "S");
    formatTest(S!0b101([0, 1, 2]), "S");                // Test for bug 7628
    formatTest(S!0b110([0, 1, 2]), "S");
    formatTest(S!0b111([0, 1, 2]), "S");
}

@safe unittest
{
    // void[]
    void[] val0;
    formatTest(val0, "[]");

    void[] val = cast(void[]) cast(ubyte[])[1, 2, 3];
    formatTest(val, "[1, 2, 3]");

    void[0] sval0 = [];
    formatTest(sval0, "[]");

    void[3] sval = () @trusted { return cast(void[3]) cast(ubyte[3])[1, 2, 3]; } ();
    formatTest(sval, "[1, 2, 3]");
}

@safe unittest
{
    // const(T[]) -> const(T)[]
    const short[] a = [1, 2, 3];
    formatTest(a, "[1, 2, 3]");

    struct S
    {
        const(int[]) arr;
        alias arr this;
    }

    auto s = S([1,2,3]);
    formatTest(s, "[1, 2, 3]");
}

@safe unittest
{
    // nested range formatting with array of string
    formatTest("%({%(%02x %)}%| %)", ["test", "msg"],
               `{74 65 73 74} {6d 73 67}`);
}

@safe unittest
{
    // stop auto escaping inside range formatting
    auto arr = ["hello", "world"];
    formatTest("%(%s, %)",  arr, `"hello", "world"`);
    formatTest("%-(%s, %)", arr, `hello, world`);

    auto aa1 = [1:"hello", 2:"world"];
    formatTest("%(%s:%s, %)",  aa1, [`1:"hello", 2:"world"`, `2:"world", 1:"hello"`]);
    formatTest("%-(%s:%s, %)", aa1, [`1:hello, 2:world`, `2:world, 1:hello`]);

    auto aa2 = [1:["ab", "cd"], 2:["ef", "gh"]];
    formatTest("%-(%s:%s, %)",        aa2, [`1:["ab", "cd"], 2:["ef", "gh"]`, `2:["ef", "gh"], 1:["ab", "cd"]`]);
    formatTest("%-(%s:%(%s%), %)",    aa2, [`1:"ab""cd", 2:"ef""gh"`, `2:"ef""gh", 1:"ab""cd"`]);
    formatTest("%-(%s:%-(%s%)%|, %)", aa2, [`1:abcd, 2:efgh`, `2:efgh, 1:abcd`]);
}

// https://issues.dlang.org/show_bug.cgi?id=18778
@safe pure unittest
{
    assert(format("%-(%1$s - %1$s, %)", ["A", "B", "C"]) == "A - A, B - B, C - C");
}

@safe pure unittest
{
    int[] a = [ 1, 3, 2 ];
    formatTest("testing %(%s & %) embedded", a,
               "testing 1 & 3 & 2 embedded");
    formatTest("testing %((%s) %)) wyda3", a,
               "testing (1) (3) (2) wyda3");

    int[0] empt = [];
    formatTest("(%s)", empt, "([])");
}

// input range formatting
private void formatRange(Writer, T, Char)(ref Writer w, ref T val, scope const ref FormatSpec!Char f)
if (isInputRange!T)
{
    import std.conv : text;
    import std.format : FormatException, formatValue, NoOpSink;
    import std.range.primitives : ElementType, empty, front, hasLength,
        walkLength, isForwardRange, isInfinite, popFront, put;

    // in this mode, we just want to do a representative print to discover
    // if the format spec is valid
    enum formatTestMode = is(Writer == NoOpSink);

    // Formatting character ranges like string
    if (f.spec == 's')
    {
        alias E = ElementType!T;

        static if (!is(E == enum) && is(CharTypeOf!E))
        {
            static if (is(StringTypeOf!T))
                writeAligned(w, val[0 .. f.precision < $ ? f.precision : $], f);
            else
            {
                if (!f.flDash)
                {
                    static if (hasLength!T)
                    {
                        // right align
                        auto len = val.length;
                    }
                    else static if (isForwardRange!T && !isInfinite!T)
                    {
                        auto len = walkLength(val.save);
                    }
                    else
                    {
                        import std.format : enforceFmt;
                        enforceFmt(f.width == 0, "Cannot right-align a range without length");
                        size_t len = 0;
                    }
                    if (f.precision != f.UNSPECIFIED && len > f.precision)
                        len = f.precision;

                    if (f.width > len)
                        foreach (i ; 0 .. f.width - len)
                            put(w, ' ');
                    if (f.precision == f.UNSPECIFIED)
                        put(w, val);
                    else
                    {
                        size_t printed = 0;
                        for (; !val.empty && printed < f.precision; val.popFront(), ++printed)
                            put(w, val.front);
                    }
                }
                else
                {
                    size_t printed = void;

                    // left align
                    if (f.precision == f.UNSPECIFIED)
                    {
                        static if (hasLength!T)
                        {
                            printed = val.length;
                            put(w, val);
                        }
                        else
                        {
                            printed = 0;
                            for (; !val.empty; val.popFront(), ++printed)
                            {
                                put(w, val.front);
                                static if (formatTestMode) break; // one is enough to test
                            }
                        }
                    }
                    else
                    {
                        printed = 0;
                        for (; !val.empty && printed < f.precision; val.popFront(), ++printed)
                            put(w, val.front);
                    }

                    if (f.width > printed)
                        foreach (i ; 0 .. f.width - printed)
                            put(w, ' ');
                }
            }
        }
        else
        {
            put(w, f.seqBefore);
            if (!val.empty)
            {
                formatElement(w, val.front, f);
                val.popFront();
                for (size_t i; !val.empty; val.popFront(), ++i)
                {
                    put(w, f.seqSeparator);
                    formatElement(w, val.front, f);
                    static if (formatTestMode) break; // one is enough to test
                }
            }
            static if (!isInfinite!T) put(w, f.seqAfter);
        }
    }
    else if (f.spec == 'r')
    {
        static if (is(DynamicArrayTypeOf!T))
        {
            alias ARR = DynamicArrayTypeOf!T;
            scope a = cast(ARR) val;
            foreach (e ; a)
            {
                formatValue(w, e, f);
                static if (formatTestMode) break; // one is enough to test
            }
        }
        else
        {
            for (size_t i; !val.empty; val.popFront(), ++i)
            {
                formatValue(w, val.front, f);
                static if (formatTestMode) break; // one is enough to test
            }
        }
    }
    else if (f.spec == '(')
    {
        if (val.empty)
            return;
        // Nested specifier is to be used
        for (;;)
        {
            auto fmt = FormatSpec!Char(f.nested);
            w: while (true)
            {
                immutable r = fmt.writeUpToNextSpec(w);
                // There was no format specifier, so break
                if (!r)
                    break;
                if (f.flDash)
                    formatValue(w, val.front, fmt);
                else
                    formatElement(w, val.front, fmt);
                // Check if there will be a format specifier farther on in the
                // string. If so, continue the loop, otherwise break. This
                // prevents extra copies of the `sep` from showing up.
                foreach (size_t i; 0 .. fmt.trailing.length)
                    if (fmt.trailing[i] == '%')
                        continue w;
                break w;
            }
            static if (formatTestMode)
            {
                break; // one is enough to test
            }
            else
            {
                if (f.sep !is null)
                {
                    put(w, fmt.trailing);
                    val.popFront();
                    if (val.empty)
                        break;
                    put(w, f.sep);
                }
                else
                {
                    val.popFront();
                    if (val.empty)
                        break;
                    put(w, fmt.trailing);
                }
            }
        }
    }
    else
        throw new FormatException(text("Incorrect format specifier for range: %", f.spec));
}

// https://issues.dlang.org/show_bug.cgi?id=20218
@safe pure unittest
{
    void notCalled()
    {
        import std.range : repeat;

        auto value = 1.repeat;

        // test that range is not evaluated to completion at compiletime
        format!"%s"(value);
    }
}

// character formatting with ecaping
void formatChar(Writer)(ref Writer w, in dchar c, in char quote)
{
    import std.format : formattedWrite;
    import std.range.primitives : put;
    import std.uni : isGraphical;

    string fmt;
    if (isGraphical(c))
    {
        if (c == quote || c == '\\')
            put(w, '\\');
        put(w, c);
        return;
    }
    else if (c <= 0xFF)
    {
        if (c < 0x20)
        {
            foreach (i, k; "\n\r\t\a\b\f\v\0")
            {
                if (c == k)
                {
                    put(w, '\\');
                    put(w, "nrtabfv0"[i]);
                    return;
                }
            }
        }
        fmt = "\\x%02X";
    }
    else if (c <= 0xFFFF)
        fmt = "\\u%04X";
    else
        fmt = "\\U%08X";

    formattedWrite(w, fmt, cast(uint) c);
}

/*
    Associative arrays are formatted by using `':'` and $(D ", ") as
    separators, and enclosed by `'['` and `']'`.
 */
void formatValueImpl(Writer, T, Char)(auto ref Writer w, T obj, scope const ref FormatSpec!Char f)
if (is(AssocArrayTypeOf!T) && !is(T == enum) && !hasToString!(T, Char))
{
    import std.format : enforceFmt, formatValue;
    import std.range.primitives : put;

    AssocArrayTypeOf!T val = obj;
    const spec = f.spec;

    enforceFmt(spec == 's' || spec == '(',
        "incompatible format character for associative array argument: %" ~ spec);

    enum const(Char)[] defSpec = "%s" ~ f.keySeparator ~ "%s" ~ f.seqSeparator;
    auto fmtSpec = spec == '(' ? f.nested : defSpec;

    auto key_first = true;

    // testing correct nested format spec
    import std.format : NoOpSink;
    auto noop = NoOpSink();
    auto test = FormatSpec!Char(fmtSpec);
    enforceFmt(test.writeUpToNextSpec(noop),
        "nested format string for associative array contains no format specifier");
    enforceFmt(test.indexStart <= 2,
        "positional parameter in nested format string for associative array may only be 1 or 2");
    if (test.indexStart == 2)
        key_first = false;

    enforceFmt(test.writeUpToNextSpec(noop),
        "nested format string for associative array contains only one format specifier");
    enforceFmt(test.indexStart <= 2,
        "positional parameter in nested format string for associative array may only be 1 or 2");
    enforceFmt(test.indexStart == 0 || ((test.indexStart == 2) == key_first),
        "wrong combination of positional parameters in nested format string");

    enforceFmt(!test.writeUpToNextSpec(noop),
        "nested format string for associative array contains more than two format specifiers");

    size_t i = 0;
    immutable end = val.length;

    if (spec == 's')
        put(w, f.seqBefore);
    foreach (k, ref v; val)
    {
        auto fmt = FormatSpec!Char(fmtSpec);

        foreach (pos; 1 .. 3)
        {
            fmt.writeUpToNextSpec(w);

            if (key_first == (pos == 1))
            {
                if (f.flDash)
                    formatValue(w, k, fmt);
                else
                    formatElement(w, k, fmt);
            }
            else
            {
                if (f.flDash)
                    formatValue(w, v, fmt);
                else
                    formatElement(w, v, fmt);
            }
        }

        if (f.sep !is null)
        {
            fmt.writeUpToNextSpec(w);
            if (++i != end)
                put(w, f.sep);
        }
        else
        {
            if (++i != end)
                fmt.writeUpToNextSpec(w);
        }
    }
    if (spec == 's')
        put(w, f.seqAfter);
}

@safe unittest
{
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;
    import std.range.primitives : back;

    assert(collectExceptionMsg!FormatException(format("%d", [0:1])).back == 'd');

    int[string] aa0;
    formatTest(aa0, `[]`);

    // elements escaping
    formatTest(["aaa":1, "bbb":2],
               [`["aaa":1, "bbb":2]`, `["bbb":2, "aaa":1]`]);
    formatTest(['c':"str"],
               `['c':"str"]`);
    formatTest(['"':"\"", '\'':"'"],
               [`['"':"\"", '\'':"'"]`, `['\'':"'", '"':"\""]`]);

    // range formatting for AA
    auto aa3 = [1:"hello", 2:"world"];
    // escape
    formatTest("{%(%s:%s $ %)}", aa3,
               [`{1:"hello" $ 2:"world"}`, `{2:"world" $ 1:"hello"}`]);
    // use range formatting for key and value, and use %|
    formatTest("{%([%04d->%(%c.%)]%| $ %)}", aa3,
               [`{[0001->h.e.l.l.o] $ [0002->w.o.r.l.d]}`,
                `{[0002->w.o.r.l.d] $ [0001->h.e.l.l.o]}`]);

    // https://issues.dlang.org/show_bug.cgi?id=12135
    formatTest("%(%s:<%s>%|,%)", [1:2], "1:<2>");
    formatTest("%(%s:<%s>%|%)" , [1:2], "1:<2>");
}

@safe unittest
{
    struct S1
    {
        int[char] val;
        alias val this;
    }

    struct S2
    {
        int[char] val;
        alias val this;
        string toString() const { return "S"; }
    }

    formatTest(S1(['c':1, 'd':2]), [`['c':1, 'd':2]`, `['d':2, 'c':1]`]);
    formatTest(S2(['c':1, 'd':2]), "S");
}

// https://issues.dlang.org/show_bug.cgi?id=21875
@safe unittest
{
    import std.exception : assertThrown;
    import std.format : FormatException;

    auto aa = [ 1 : "x", 2 : "y", 3 : "z" ];

    assertThrown!FormatException(format("%(%)", aa));
    assertThrown!FormatException(format("%(%s%)", aa));
    assertThrown!FormatException(format("%(%s%s%s%)", aa));
}

@safe unittest
{
    import std.exception : assertThrown;
    import std.format : FormatException;

    auto aa = [ 1 : "x", 2 : "y", 3 : "z" ];

    assertThrown!FormatException(format("%(%3$s%s%)", aa));
    assertThrown!FormatException(format("%(%s%3$s%)", aa));
    assertThrown!FormatException(format("%(%1$s%1$s%)", aa));
    assertThrown!FormatException(format("%(%2$s%2$s%)", aa));
    assertThrown!FormatException(format("%(%s%1$s%)", aa));
}

// https://issues.dlang.org/show_bug.cgi?id=21808
@safe unittest
{
    auto spelled = [ 1 : "one" ];
    assert(format("%-(%2$s (%1$s)%|, %)", spelled) == "one (1)");

    spelled[2] = "two";
    auto result = format("%-(%2$s (%1$s)%|, %)", spelled);
    assert(result == "one (1), two (2)" || result == "two (2), one (1)");
}

enum HasToStringResult
{
    none,
    hasSomeToString,
    inCharSink,
    inCharSinkFormatString,
    inCharSinkFormatSpec,
    constCharSink,
    constCharSinkFormatString,
    constCharSinkFormatSpec,
    customPutWriter,
    customPutWriterFormatSpec,
}

private alias DScannerBug895 = int[256];
private immutable bool hasPreviewIn = ((in DScannerBug895 a) { return __traits(isRef, a); })(DScannerBug895.init);

template hasToString(T, Char)
{
    static if (isPointer!T)
    {
        // X* does not have toString, even if X is aggregate type has toString.
        enum hasToString = HasToStringResult.none;
    }
    else static if (is(typeof(
        (T val) {
            const FormatSpec!Char f;
            static struct S {void put(scope Char s){}}
            S s;
            val.toString(s, f);
            static assert(!__traits(compiles, val.toString(s, FormatSpec!Char())),
                          "force toString to take parameters by ref");
            static assert(!__traits(compiles, val.toString(S(), f)),
                          "force toString to take parameters by ref");
        })))
    {
        enum hasToString = HasToStringResult.customPutWriterFormatSpec;
    }
    else static if (is(typeof(
        (T val) {
            static struct S {void put(scope Char s){}}
            S s;
            val.toString(s);
            static assert(!__traits(compiles, val.toString(S())),
                          "force toString to take parameters by ref");
        })))
    {
        enum hasToString = HasToStringResult.customPutWriter;
    }
    else static if (is(typeof((T val) { FormatSpec!Char f; val.toString((scope const(char)[] s){}, f); })))
    {
        enum hasToString = HasToStringResult.constCharSinkFormatSpec;
    }
    else static if (is(typeof((T val) { val.toString((scope const(char)[] s){}, "%s"); })))
    {
        enum hasToString = HasToStringResult.constCharSinkFormatString;
    }
    else static if (is(typeof((T val) { val.toString((scope const(char)[] s){}); })))
    {
        enum hasToString = HasToStringResult.constCharSink;
    }

    else static if (hasPreviewIn &&
                    is(typeof((T val) { FormatSpec!Char f; val.toString((in char[] s){}, f); })))
    {
        enum hasToString = HasToStringResult.inCharSinkFormatSpec;
    }
    else static if (hasPreviewIn &&
                    is(typeof((T val) { val.toString((in char[] s){}, "%s"); })))
    {
        enum hasToString = HasToStringResult.inCharSinkFormatString;
    }
    else static if (hasPreviewIn &&
                    is(typeof((T val) { val.toString((in char[] s){}); })))
    {
        enum hasToString = HasToStringResult.inCharSink;
    }

    else static if (is(ReturnType!((T val) { return val.toString(); }) S) && isSomeString!S)
    {
        enum hasToString = HasToStringResult.hasSomeToString;
    }
    else
    {
        enum hasToString = HasToStringResult.none;
    }
}

@safe unittest
{
    import std.range.primitives : isOutputRange;

    static struct A
    {
        void toString(Writer)(ref Writer w)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct B
    {
        void toString(scope void delegate(scope const(char)[]) sink, scope FormatSpec!char fmt) {}
    }
    static struct C
    {
        void toString(scope void delegate(scope const(char)[]) sink, string fmt) {}
    }
    static struct D
    {
        void toString(scope void delegate(scope const(char)[]) sink) {}
    }
    static struct E
    {
        string toString() {return "";}
    }
    static struct F
    {
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct G
    {
        string toString() {return "";}
        void toString(Writer)(ref Writer w) if (isOutputRange!(Writer, string)) {}
    }
    static struct H
    {
        string toString() {return "";}
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct I
    {
        void toString(Writer)(ref Writer w) if (isOutputRange!(Writer, string)) {}
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct J
    {
        string toString() {return "";}
        void toString(Writer)(ref Writer w, scope ref FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct K
    {
        void toString(Writer)(Writer w, scope const ref FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct L
    {
        void toString(Writer)(ref Writer w, scope const FormatSpec!char fmt)
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct M
    {
        void toString(scope void delegate(in char[]) sink, in FormatSpec!char fmt) {}
    }
    static struct N
    {
        void toString(scope void delegate(in char[]) sink, string fmt) {}
    }
    static struct O
    {
        void toString(scope void delegate(in char[]) sink) {}
    }

    with(HasToStringResult)
    {
        static assert(hasToString!(A, char) == customPutWriter);
        static assert(hasToString!(B, char) == constCharSinkFormatSpec);
        static assert(hasToString!(C, char) == constCharSinkFormatString);
        static assert(hasToString!(D, char) == constCharSink);
        static assert(hasToString!(E, char) == hasSomeToString);
        static assert(hasToString!(F, char) == customPutWriterFormatSpec);
        static assert(hasToString!(G, char) == customPutWriter);
        static assert(hasToString!(H, char) == customPutWriterFormatSpec);
        static assert(hasToString!(I, char) == customPutWriterFormatSpec);
        static assert(hasToString!(J, char) == hasSomeToString);
        static assert(hasToString!(K, char) == constCharSinkFormatSpec);
        static assert(hasToString!(L, char) == none);
        static if (hasPreviewIn)
        {
            static assert(hasToString!(M, char) == inCharSinkFormatSpec);
            static assert(hasToString!(N, char) == inCharSinkFormatString);
            static assert(hasToString!(O, char) == inCharSink);
        }
    }
}

// const toString methods
@safe unittest
{
    import std.range.primitives : isOutputRange;

    static struct A
    {
        void toString(Writer)(ref Writer w) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct B
    {
        void toString(scope void delegate(scope const(char)[]) sink, scope FormatSpec!char fmt) const {}
    }
    static struct C
    {
        void toString(scope void delegate(scope const(char)[]) sink, string fmt) const {}
    }
    static struct D
    {
        void toString(scope void delegate(scope const(char)[]) sink) const {}
    }
    static struct E
    {
        string toString() const {return "";}
    }
    static struct F
    {
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct G
    {
        string toString() const {return "";}
        void toString(Writer)(ref Writer w) const if (isOutputRange!(Writer, string)) {}
    }
    static struct H
    {
        string toString() const {return "";}
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct I
    {
        void toString(Writer)(ref Writer w) const if (isOutputRange!(Writer, string)) {}
        void toString(Writer)(ref Writer w, scope const ref FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct J
    {
        string toString() const {return "";}
        void toString(Writer)(ref Writer w, scope ref FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct K
    {
        void toString(Writer)(Writer w, scope const ref FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct L
    {
        void toString(Writer)(ref Writer w, scope const FormatSpec!char fmt) const
        if (isOutputRange!(Writer, string))
        {}
    }
    static struct M
    {
        void toString(scope void delegate(in char[]) sink, in FormatSpec!char fmt) const {}
    }
    static struct N
    {
        void toString(scope void delegate(in char[]) sink, string fmt) const {}
    }
    static struct O
    {
        void toString(scope void delegate(in char[]) sink) const {}
    }

    with(HasToStringResult)
    {
        static assert(hasToString!(A, char) == customPutWriter);
        static assert(hasToString!(B, char) == constCharSinkFormatSpec);
        static assert(hasToString!(C, char) == constCharSinkFormatString);
        static assert(hasToString!(D, char) == constCharSink);
        static assert(hasToString!(E, char) == hasSomeToString);
        static assert(hasToString!(F, char) == customPutWriterFormatSpec);
        static assert(hasToString!(G, char) == customPutWriter);
        static assert(hasToString!(H, char) == customPutWriterFormatSpec);
        static assert(hasToString!(I, char) == customPutWriterFormatSpec);
        static assert(hasToString!(J, char) == hasSomeToString);
        static assert(hasToString!(K, char) == constCharSinkFormatSpec);
        static assert(hasToString!(L, char) == none);
        static if (hasPreviewIn)
        {
            static assert(hasToString!(M, char) == inCharSinkFormatSpec);
            static assert(hasToString!(N, char) == inCharSinkFormatString);
            static assert(hasToString!(O, char) == inCharSink);
        }

        // https://issues.dlang.org/show_bug.cgi?id=22873
        static assert(hasToString!(inout(A), char) == customPutWriter);
        static assert(hasToString!(inout(B), char) == constCharSinkFormatSpec);
        static assert(hasToString!(inout(C), char) == constCharSinkFormatString);
        static assert(hasToString!(inout(D), char) == constCharSink);
        static assert(hasToString!(inout(E), char) == hasSomeToString);
        static assert(hasToString!(inout(F), char) == customPutWriterFormatSpec);
        static assert(hasToString!(inout(G), ch// Written in the D programming language.

/**
This package provides string formatting functionality using
`printf` style format strings.

$(BOOKTABLE ,
$(TR $(TH Submodule) $(TH Function Name) $(TH Description))
$(TR
    $(TD $(I package))
    $(TD $(LREF format))
    $(TD Converts its arguments according to a format string into a string.)
)
$(TR
    $(TD $(I package))
    $(TD $(LREF sformat))
    $(TD Converts its arguments according to a format string into a buffer.)
)
$(TR
    $(TD $(I package))
    $(TD $(LREF FormatException))
    $(TD Signals a problem while formatting.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D write), std, format, write))
    $(TD $(REF_ALTTEXT $(D formattedWrite), formattedWrite, std, format, write))
    $(TD Converts its arguments according to a format string and writes
         the result to an output range.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D write), std, format, write))
    $(TD $(REF_ALTTEXT $(D formatValue), formatValue, std, format, write))
    $(TD Formats a value of any type according to a format specifier and
         writes the result to an output range.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D read), std, format, read))
    $(TD $(REF_ALTTEXT $(D formattedRead), formattedRead, std, format, read))
    $(TD Reads an input range according to a format string and stores the read
         values into its arguments.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D read), std, format, read))
    $(TD $(REF_ALTTEXT $(D unformatValue), unformatValue, std, format, read))
    $(TD Reads a value from the given input range and converts it according to
         a format specifier.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D spec), std, format, spec))
    $(TD $(REF_ALTTEXT $(D FormatSpec), FormatSpec, std, format, spec))
    $(TD A general handler for format strings.)
)
$(TR
    $(TD $(MREF_ALTTEXT $(D spec), std, format, spec))
    $(TD $(REF_ALTTEXT $(D singleSpec), singleSpec, std, format, spec))
    $(TD Helper function that returns a `FormatSpec` for a single format specifier.)
))

Limitation: This package does not support localization, but
    adheres to the rounding mode of the floating point unit, if
    available.

$(SECTION3 Format Strings)

The functions contained in this package use $(I format strings). A
format string describes the layout of another string for reading or
writing purposes. A format string is composed of normal text
interspersed with $(I format specifiers). A format specifier starts
with a percentage sign $(B '%'), optionally followed by one or more
$(I parameters) and ends with a $(I format indicator). A format
indicator may be a simple $(I format character) or a $(I compound
indicator).

$(I Format strings) are composed according to the following grammar:

$(PRE
$(I FormatString):
    $(I FormatStringItem) $(I FormatString)
$(I FormatStringItem):
    $(I Character)
    $(I FormatSpecifier)
$(I FormatSpecifier):
    $(B '%') $(I Parameters) $(I FormatIndicator)

$(I FormatIndicator):
    $(I FormatCharacter)
    $(I CompoundIndicator)
$(I FormatCharacter):
    $(I see remark below)
$(I CompoundIndicator):
    $(B '$(LPAREN)') $(I FormatString) $(B '%$(RPAREN)')
    $(B '$(LPAREN)') $(I FormatString) $(B '%|') $(I Delimiter) $(B '%$(RPAREN)')
$(I Delimiter)
    $(I empty)
    $(I Character) $(I Delimiter)

$(I Parameters):
    $(I Position) $(I Flags) $(I Width) $(I Precision) $(I Separator)
$(I Position):
    $(I empty)
    $(I Integer) $(B '$')
    $(I Integer) $(B ':') $(I Integer) $(B '$')
    $(I Integer) $(B ':') $(B '$')
$(I Flags):
    $(I empty)
    $(I Flag) $(I Flags)
$(I Flag):
    $(B '-')|$(B '+')|$(B '&nbsp;')|$(B '0')|$(B '#')|$(B '=')
$(I Width):
    $(I OptionalPositionalInteger)
$(I Precision):
    $(I empty)
    $(B '.') $(I OptionalPositionalInteger)
$(I Separator):
    $(I empty)
    $(B ',') $(I OptionalInteger)
    $(B ',') $(I OptionalInteger) $(B '?')
$(I OptionalInteger):
    $(I empty)
    $(I Integer)
    $(B '*')
$(I OptionalPositionalInteger):
    $(I OptionalInteger)
    $(B '*') $(I Integer) $(B '$')

$(I Character)
    $(B '%%')
    $(I AnyCharacterExceptPercent)
$(I Integer):
    $(I NonZeroDigit) $(I Digits)
$(I Digits):
    $(I empty)
    $(I Digit) $(I Digits)
$(I NonZeroDigit):
    $(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')
$(I Digit):
    $(B '0')|$(B '1')|$(B '2')|$(B '3')|$(B '4')|$(B '5')|$(B '6')|$(B '7')|$(B '8')|$(B '9')
)

Note: $(I FormatCharacter) is unspecified. It can be any character
that has no other purpose in this grammar, but it is
recommended to assign (lower- and uppercase) letters.

Note: The $(I Parameters) of a $(I CompoundIndicator) are currently
limited to a $(B '-') flag.

$(SECTION4 Format Indicator)

The $(I format indicator) can either be a single character or an
expression surrounded by $(B %\() and $(B %\)). It specifies the
basic manner in which a value will be formatted and is the minimum
requirement to format a value.

The following characters can be used as $(I format characters):

$(BOOKTABLE ,
   $(TR $(TH FormatCharacter) $(TH Semantics))
   $(TR $(TD $(B 's'))
        $(TD To be formatted in a human readable format.
             Can be used with all types.))
   $(TR $(TD $(B 'c'))
        $(TD To be formatted as a character.))
   $(TR $(TD $(B 'd'))
        $(TD To be formatted as a signed decimal integer.))
   $(TR $(TD $(B 'u'))
        $(TD To be formatted as a decimal image of the underlying bit representation.))
   $(TR $(TD $(B 'b'))
        $(TD To be formatted as a binary image of the underlying bit representation.))
   $(TR $(TD $(B 'o'))
        $(TD To be formatted as an octal image of the underlying bit representation.))
   $(TR $(TD $(B 'x') / $(B 'X'))
        $(TD To be formatted as a hexadecimal image of the underlying bit representation.))
   $(TR $(TD $(B 'e') / $(B 'E'))
        $(TD To be formatted as a real number in decimal scientific notation.))
   $(TR $(TD $(B 'f') / $(B 'F'))
        $(TD To be formatted as a real number in decimal natural notation.))
   $(TR $(TD $(B 'g') / $(B 'G'))
        $(TD To be formatted as a real number in decimal short notation.
             Depending on the number, a scientific notation or
             a natural notation is used.))
   $(TR $(TD $(B 'a') / $(B 'A'))
        $(TD To be formatted as a real number in hexadecimal scientific notation.))
   $(TR $(TD $(B 'r'))
        $(TD To be formatted as raw bytes.
             The output may not be printable and depends on endianness.))
)

The $(I compound indicator) can be used to describe compound types
like arrays or structs in more detail. A compound type is enclosed
within $(B '%\(') and $(B '%\)'). The enclosed sub-format string is
applied to individual elements. The trailing portion of the
sub-format string following the specifier for the element is
interpreted as the delimiter, and is therefore omitted following the
last element. The $(B '%|') specifier may be used to explicitly
indicate the start of the delimiter, so that the preceding portion of
the string will be included following the last element.

The $(I format string) inside of the $(I compound indicator) should
contain exactly one $(I format specifier) (two in case of associative
arrays), which specifies the formatting mode of the elements of the
compound type. This $(I format specifier) can be a $(I compound
indicator) itself.

Note: Inside a $(I compound indicator), strings and characters are
escaped automatically. To avoid this behavior, use `"%-$(LPAREN)"`
instead of `"%$(LPAREN)"`.

$(SECTION4 Flags)

There are several flags that affect the outcome of the formatting.

$(BOOKTABLE ,
   $(TR $(TH Flag) $(TH Semantics))
   $(TR $(TD $(B '-'))
        $(TD When the formatted result is shorter than the value
             given by the width parameter, the output is left
             justified. Without the $(B '-') flag, the output remains
             right justified.

             There are two exceptions where the $(B '-') flag has a
             different meaning: (1) with $(B 'r') it denotes to use little
             endian and (2) in case of a compound indicator it means that
             no special handling of the members is applied.))
   $(TR $(TD $(B '='))
        $(TD When the formatted result is shorter than the value
             given by the width parameter, the output is centered.
             If the central position is not possible it is moved slightly
             to the right. In this case, if $(B '-') flag is present in
             addition to the $(B '=') flag, it is moved slightly to the left.))
   $(TR $(TD $(B '+')&nbsp;/&nbsp;$(B '&nbsp;'))
        $(TD Applies to numerical values. By default, positive numbers are not
             formatted to include the `+` sign. With one of these two flags present,
             positive numbers are preceded by a plus sign or a space.
             When both flags are present, a plus sign is used.

             In case of $(B 'r'), a big endian format is used.))
   $(TR $(TD $(B '0'))
        $(TD Is applied to numerical values that are printed right justified.
             If the zero flag is present, the space left to the number is
             filled with zeros instead of spaces.))
   $(TR $(TD $(B '#'))
        $(TD Denotes that an alternative output must be used. This depends on the type
             to be formatted and the $(I format character) used. See the
             sections below for more information.))
)

$(SECTION4 Width$(COMMA) Precision and Separator)

The $(I width) parameter specifies the minimum width of the result.

The meaning of $(I precision) depends on the format indicator. For
integers it denotes the minimum number of digits printed, for
real numbers it denotes the number of fractional digits and for
strings and compound types it denotes the maximum number of elements
that are included in the output.

A $(I separator) is used for formatting numbers. If it is specified,
the output is divided into chunks of three digits, separated by a $(B
','). The number of digits in a chunk can be given explicitly by
providing a number or a $(B '*') after the $(B ',').

In all three cases the number of digits can be replaced by a $(B
'*'). In this scenario, the next argument is used as the number of
digits. If the argument is a negative number, the $(I precision) and
$(I separator) parameters are considered unspecified. For $(I width),
the absolute value is used and the $(B '-') flag is set.

The $(I separator) can also be followed by a $(B '?'). In that case,
an additional argument is used to specify the symbol that should be
used to separate the chunks.

$(SECTION4 Position)

By default, the arguments are processed in the provided order. With
the $(I position) parameter it is possible to address arguments
directly. It is also possible to denote a series of arguments with
two numbers separated by $(B ':'), that are all processed in the same
way. The second number can be omitted. In that case the series ends
with the last argument.

It's also possible to use positional arguments for $(I width), $(I
precision) and $(I separator) by adding a number and a $(B
'$(DOLLAR)') after the $(B '*').

$(SECTION4 Types)

This section describes the result of combining types with format
characters. It is organized in 2 subsections: a list of general
information regarding the formatting of types in the presence of
format characters and a table that contains details for every
available combination of type and format character.

When formatting types, the following rules apply:

$(UL
  $(LI If the format character is upper case, the resulting string will
       be formatted using upper case letters.)
  $(LI The default precision for floating point numbers is 6 digits.)
  $(LI Rounding of floating point numbers adheres to the rounding mode
       of the floating point unit, if available.)
  $(LI The floating point values `NaN` and `Infinity` are formatted as
       `nan` and `inf`, possibly preceded by $(B '+') or $(B '-') sign.)
  $(LI Formatting reals is only supported for 64 bit reals and 80 bit reals.
       All other reals are cast to double before they are formatted. This will
       cause the result to be `inf` for very large numbers.)
  $(LI Characters and strings formatted with the $(B 's') format character
       inside of compound types are surrounded by single and double quotes
       and unprintable characters are escaped. To avoid this, a $(B '-')
       flag can be specified for the compound specifier
       $(LPAREN)e.g. `"%-$(LPAREN)%s%$(RPAREN)"` instead of `"%$(LPAREN)%s%$(RPAREN)"` $(RPAREN).)
  $(LI Structs, unions, classes and interfaces are formatted by calling a
       `toString` method if available.
       See $(MREF_ALTTEXT $(D module std.format.write), std, format, write) for more
       details.)
  $(LI Only part of these combinations can be used for reading. See
       $(MREF_ALTTEXT $(D module std.format.read), std, format, read) for more
       detailed information.)
)

This table contains descriptions for every possible combination of
type and format character:

$(BOOKTABLE ,
   $(TR $(THMINWIDTH Type) $(THMINWIDTH Format Character) $(TH Formatted as...))
   $(TR $(MULTIROW_CELL 1, `null`)
        $(TD $(B 's'))
            $(TD `null`)
   )
   $(TR $(MULTIROW_CELL 3, `bool`)
        $(TD $(B 's'))
            $(TD `false` or `true`)
   )
   $(TR $(TD $(B 'b'), $(B 'd'), $(B 'o'), $(B 'u'), $(B 'x'), $(B 'X'))
            $(TD As the integrals 0 or 1 with the same format character.

            $(I Please note, that $(B 'o') and $(B 'x') with $(B '#') flag
            might produce unexpected results due to special handling of
            the value 0.))
   )
   $(TR $(TD $(B 'r'))
            $(TD `\0` or `\1`)
   )
   $(TR $(MULTIROW_CELL 4, $(I Integral))
        $(TD $(B 's'), $(B 'd'))
            $(TD A signed decimal number. The $(B '#') flag is ignored.)
   )
   $(TR $(TD $(B 'b'), $(B 'o'), $(B 'u'), $(B 'x'), $(B 'X'))
            $(TD An unsigned binary, decimal, octal or hexadecimal number.

                 In case of $(B 'o') and $(B 'x'), the $(B '#') flag
                 denotes that the number must be preceded by `0` and `0x`, with
                 the exception of the value 0, where this does not apply. For
                 $(B 'b') and $(B 'u') the $(B '#') flag has no effect.)
   )
   $(TR $(TD $(B 'e'), $(B 'E'), $(B 'f'), $(B 'F'), $(B 'g'), $(B 'G'), $(B 'a'), $(B 'A'))
            $(TD As a floating point value with the same specifier.

                 Default precision is large enough to add all digits
                 of the integral value.

                 In case of ($B 'a') and $(B 'A'), the integral digit can be
                 any hexadecimal digit.
               )
   )
   $(TR $(TD $(B 'r'))
            $(TD Characters taken directly from the binary representation.)
   )
   $(TR $(MULTIROW_CELL 5, $(I Floating Point))
        $(TD $(B 'e'), $(B 'E'))
            $(TD Scientific notation: Exactly one integral digit followed by a dot
                 and fractional digits, followed by the exponent.
                 The exponent is formatted as $(B 'e') followed by
                 a $(B '+') or $(B '-') sign, followed by at least
                 two digits.

                 When there are no fractional digits and the $(B '#') flag
                 is $(I not) present, the dot is omitted.)
   )
   $(TR $(TD $(B 'f'), $(B 'F'))
            $(TD Natural notation: Integral digits followed by a dot and
                 fractional digits.

                 When there are no fractional digits and the $(B '#') flag
                 is $(I not) present, the dot is omitted.

                 $(I Please note: the difference between $(B 'f') and $(B 'F')
                 is only visible for `NaN` and `Infinity`.))
   )
   $(TR $(TD $(B 's'), $(B 'g'), $(B 'G'))
            $(TD Short notation: If the absolute value is larger than `10 ^^ precision`
                 or smaller than `0.0001`, the scientific notation is used.
                 If not, the natural notation is applied.

                 In both cases $(I precision) denotes the count of all digits, including
                 the integral digits. Trailing zeros (including a trailing dot) are removed.

                 If $(B '#') flag is present, trailing zeros are not removed.)
   )
   $(TR $(TD $(B 'a'), $(B 'A'))
            $(TD Hexadecimal scientific notation: `0x` followed by `1`
                 (or `0` in case of value zero or denormalized number)
                 followed by a dot, fractional digits in hexadecimal
                 notation and an exponent. The exponent is build by `p`,
                 followed by a sign and the exponent in $(I decimal) notation.

                 When there are no fractional digits and the $(B '#') flag
                 is $(I not) present, the dot is omitted.)
   )
   $(TR $(TD $(B 'r'))
            $(TD Characters taken directly from the binary representation.)
   )
   $(TR $(MULTIROW_CELL 3, $(I Character))
        $(TD $(B 's'), $(B 'c'))
            $(TD As the character.

                 Inside of a compound indicator $(B 's') is treated differently: The
                 character is surrounded by single quotes and non printable
                 characters are escaped. This can be avoided by preceding
                 the compound indicator with a $(B '-') flag
                 $(LPAREN)e.g. `"%-$(LPAREN)%s%$(RPAREN)"`$(RPAREN).)
   )
   $(TR $(TD $(B 'b'), $(B 'd'), $(B 'o'), $(B 'u'), $(B 'x'), $(B 'X'))
            $(TD As the integral that represents the character.)
   )
   $(TR $(TD $(B 'r'))
            $(TD Characters taken directly from the binary representation.)
   )
   $(TR $(MULTIROW_CELL 3, $(I String))
        $(TD $(B 's'))
            $(TD The sequence of characters that form the string.

                 Inside of a compound indicator the string is surrounded by double quotes
                 and non printable characters are escaped. This can be avoided
                 by preceding the compound indicator with a $(B '-') flag
                 $(LPAREN)e.g. `"%-$(LPAREN)%s%$(RPAREN)"`$(RPAREN).)
   )
   $(TR $(TD $(B 'r'))
            $(TD The sequence of characters, each formatted with $(B 'r').)
   )
   $(TR $(TD compound)
            $(TD As an array of characters.)
   )
   $(TR $(MULTIROW_CELL 3, $(I Array))
        $(TD $(B 's'))
            $(TD When the elements are characters, the array is formatted as
                 a string. In all other cases the array is surrounded by square brackets
                 and the elements are separated by a comma and a space. If the elements
                 are strings, they are surrounded by double quotes and non
                 printable characters are escaped.)
   )
   $(TR $(TD $(B 'r'))
            $(TD The sequence of the elements, each formatted with $(B 'r').)
   )
   $(TR $(TD compound)
            $(TD The sequence of the elements, each formatted according to the specifications
                 given inside of the compound specifier.)
   )
   $(TR $(MULTIROW_CELL 2, $(I Associative Array))
        $(TD $(B 's'))
            $(TD As a sequence of the elements in unpredictable order. The output is
                 surrounded by square brackets. The elements are separated by a
                 comma and a space. The elements are formatted as `key:value`.)
   )
   $(TR $(TD compound)
            $(TD As a sequence of the elements in unpredictable order. Each element
                 is formatted according to the specifications given inside of the
                 compound specifier. The first specifier is used for formatting
                 the key and the second specifier is used for formatting the value.
                 The order can be changed with positional arguments. For example
                 `"%(%2$s (%1$s), %)"` will write the value, followed by the key in
                 parenthesis.)
   )
   $(TR $(MULTIROW_CELL 2, $(I Enum))
        $(TD $(B 's'))
            $(TD The name of the value. If the name is not available, the base value
                 is used, preceeded by a cast.)
   )
   $(TR $(TD All, but $(B 's'))
            $(TD Enums can be formatted with all format characters that can be used
                 with the base value. In that case they are formatted like the base value.)
   )
   $(TR $(MULTIROW_CELL 3, $(I Input Range))
        $(TD $(B 's'))
            $(TD When the elements of the range are characters, they are written like a string.
                 In all other cases, the elements are enclosed by square brackets and separated
                 by a comma and a space.)
   )
   $(TR $(TD $(B 'r'))
            $(TD The sequence of the elements, each formatted with $(B 'r').)
   )
   $(TR $(TD compound)
            $(TD The sequence of the elements, each formatted according to the specifications
                 given inside of the compound specifier.)
   )
   $(TR $(MULTIROW_CELL 1, $(I Struct))
        $(TD $(B 's'))
            $(TD When the struct has neither an applicable `toString`
                 nor is an input range, it is formatted as follows:
                 `StructType(field1, field2, ...)`.)
   )
   $(TR $(MULTIROW_CELL 1, $(I Class))
        $(TD $(B 's'))
            $(TD When the class has neither an applicable `toString`
                 nor is an input range, it is formatted as the
                 fully qualified name of the class.)
   )
   $(TR $(MULTIROW_CELL 1, $(I Union))
        $(TD $(B 's'))
            $(TD When the union has neither an applicable `toString`
                 nor is an input range, it is formatted as its base name.)
   )
   $(TR $(MULTIROW_CELL 2, $(I Pointer))
        $(TD $(B 's'))
            $(TD A null pointer is formatted as 'null'. All other pointers are
                 formatted as hexadecimal numbers with the format character $(B 'X').)
   )
   $(TR $(TD $(B 'x'), $(B 'X'))
            $(TD Formatted as a hexadecimal number.)
   )
   $(TR $(MULTIROW_CELL 3, $(I SIMD vector))
        $(TD $(B 's'))
            $(TD The array is surrounded by square brackets
                 and the elements are separated by a comma and a space.)
   )
   $(TR $(TD $(B 'r'))
            $(TD The sequence of the elements, each formatted with $(B 'r').)
   )
   $(TR $(TD compound)
            $(TD The sequence of the elements, each formatted according to the specifications
                 given inside of the compound specifier.)
   )
   $(TR $(MULTIROW_CELL 1, $(I Delegate))
        $(TD $(B 's'), $(B 'r'), compound)
            $(TD As the `.stringof` of this delegate treated as a string.

                 $(I Please note: The implementation is currently buggy
                 and its use is discouraged.))
   )
)

Copyright: Copyright The D Language Foundation 2000-2021.

Macros:
SUBREF = $(REF_ALTTEXT $2, $2, std, format, $1)$(NBSP)
MULTIROW_CELL = <td rowspan="$1">$+</td>
THMINWIDTH = <th scope="col" width="20%">$0</th>

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
Andrei Alexandrescu), and Kenji Hara

Source: $(PHOBOSSRC std/format/package.d)
 */
module std.format;

/// Simple use:
@safe unittest
{
    // Easiest way is to use `%s` everywhere:
    assert(format("I got %s %s for %s euros.", 30, "eggs", 5.27) == "I got 30 eggs for 5.27 euros.");

    // Other format characters provide more control:
    assert(format("I got %b %(%X%) for %f euros.", 30, "eggs", 5.27) == "I got 11110 65676773 for 5.270000 euros.");
}

/// Compound specifiers allow formatting arrays and other compound types:
@safe unittest
{
/*
The trailing end of the sub-format string following the specifier for
each item is interpreted as the array delimiter, and is therefore
omitted following the last array item:
 */
    assert(format("My items are %(%s %).", [1,2,3]) == "My items are 1 2 3.");
    assert(format("My items are %(%s, %).", [1,2,3]) == "My items are 1, 2, 3.");

/*
The "%|" delimiter specifier may be used to indicate where the
delimiter begins, so that the portion of the format string prior to
it will be retained in the last array element:
 */
    assert(format("My items are %(-%s-%|, %).", [1,2,3]) == "My items are -1-, -2-, -3-.");

/*
These compound format specifiers may be nested in the case of a
nested array argument:
 */
    auto mat = [[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]];

    assert(format("%(%(%d %) - %)", mat), "1 2 3 - 4 5 6 - 7 8 9");
    assert(format("[%(%(%d %) - %)]", mat), "[1 2 3 - 4 5 6 - 7 8 9]");
    assert(format("[%([%(%d %)]%| - %)]", mat), "[1 2 3] - [4 5 6] - [7 8 9]");

/*
Strings and characters are escaped automatically inside compound
format specifiers. To avoid this behavior, use "%-(" instead of "%(":
 */
    assert(format("My friends are %s.", ["John", "Nancy"]) == `My friends are ["John", "Nancy"].`);
    assert(format("My friends are %(%s, %).", ["John", "Nancy"]) == `My friends are "John", "Nancy".`);
    assert(format("My friends are %-(%s, %).", ["John", "Nancy"]) == `My friends are John, Nancy.`);
}

/// Using parameters:
@safe unittest
{
    // Flags can be used to influence to outcome:
    assert(format("%g != %+#g", 3.14, 3.14) == "3.14 != +3.14000");

    // Width and precision help to arrange the formatted result:
    assert(format(">%10.2f<", 1234.56789) == ">   1234.57<");

    // Numbers can be grouped:
    assert(format("%,4d", int.max) == "21,4748,3647");

    // It's possible to specify the position of an argument:
    assert(format("%3$s %1$s", 3, 17, 5) == "5 3");
}

/// Providing parameters as arguments:
@safe unittest
{
    // Width as argument
    assert(format(">%*s<", 10, "abc") == ">       abc<");

    // Precision as argument
    assert(format(">%.*f<", 5, 123.2) == ">123.20000<");

    // Grouping as argument
    assert(format("%,*d", 1, int.max) == "2,1,4,7,4,8,3,6,4,7");

    // Grouping separator as argument
    assert(format("%,3?d", '_', int.max) == "2_147_483_647");

    // All at once
    assert(format("%*.*,*?d", 20, 15, 6, '/', int.max) == "   000/002147/483647");
}

public import std.format.read;
public import std.format.spec;
public import std.format.write;

import std.exception : enforce;
import std.range.primitives : isInputRange;
import std.traits : CharTypeOf, isSomeChar, isSomeString, StringTypeOf;
import std.format.internal.write : hasToString;

/**
Signals an issue encountered while formatting.
 */
class FormatException : Exception
{
    /// Generic constructor.
    @safe @nogc pure nothrow
    this()
    {
        super("format error");
    }

    /**
       Creates a new instance of `FormatException`.

       Params:
           msg = message of the exception
           fn = file name of the file where the exception was created (optional)
           ln = line number of the file where the exception was created (optional)
           next = for internal use, should always be null (optional)
     */
    @safe @nogc pure nothrow
    this(string msg, string fn = __FILE__, size_t ln = __LINE__, Throwable next = null)
    {
        super(msg, fn, ln, next);
    }
}

///
@safe unittest
{
    import std.exception : assertThrown;

    assertThrown!FormatException(format("%d", "foo"));
}

package alias enforceFmt = enforce!FormatException;

// @@@DEPRECATED_[2.107.0]@@@
deprecated("formatElement was accidentally made public and will be removed in 2.107.0")
void formatElement(Writer, T, Char)(auto ref Writer w, T val, scope const ref FormatSpec!Char f)
if (is(StringTypeOf!T) && !hasToString!(T, Char) && !is(T == enum))
{
    import std.format.internal.write : fe = formatElement;

    fe(w, val, f);
}

// @@@DEPRECATED_[2.107.0]@@@
deprecated("formatElement was accidentally made public and will be removed in 2.107.0")
void formatElement(Writer, T, Char)(auto ref Writer w, T val, scope const ref FormatSpec!Char f)
if (is(CharTypeOf!T) && !is(T == enum))
{
    import std.format.internal.write : fe = formatElement;

    fe(w, val, f);
}

// @@@DEPRECATED_[2.107.0]@@@
deprecated("formatElement was accidentally made public and will be removed in 2.107.0")
void formatElement(Writer, T, Char)(auto ref Writer w, auto ref T val, scope const ref FormatSpec!Char f)
if ((!is(StringTypeOf!T) || hasToString!(T, Char)) && !is(CharTypeOf!T) || is(T == enum))
{
    import std.format.internal.write : fe = formatElement;

    fe(w, val, f);
}

// Like NullSink, but toString() isn't even called at all. Used to test the format string.
package struct NoOpSink
{
    void put(E)(scope const E) pure @safe @nogc nothrow {}
}

// @@@DEPRECATED_[2.107.0]@@@
deprecated("unformatElement was accidentally made public and will be removed in 2.107.0")
T unformatElement(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
if (isInputRange!Range)
{
    import std.format.internal.read : ue = unformatElement;

    return ue(input, spec);
}

// Used to check format strings are compatible with argument types
package(std) enum checkFormatException(alias fmt, Args...) =
{
    import std.conv : text;

    try
    {
        auto n = .formattedWrite(NoOpSink(), fmt, Args.init);

        enforceFmt(n == Args.length, text("Orphan format arguments: args[", n, "..", Args.length, "]"));
    }
    catch (Exception e)
        return e.msg;
    return null;
}();

/**
Converts its arguments according to a format string into a string.

The second version of `format` takes the format string as template
argument. In this case, it is checked for consistency at
compile-time and produces slightly faster code, because the length of
the output buffer can be estimated in advance.

Params:
    fmt = a $(MREF_ALTTEXT format string, std,format)
    args = a variadic list of arguments to be formatted
    Char = character type of `fmt`
    Args = a variadic list of types of the arguments

Returns:
    The formatted string.

Throws:
    A $(LREF FormatException) if formatting did not succeed.

See_Also:
    $(LREF sformat) for a variant, that tries to avoid garbage collection.
 */
immutable(Char)[] format(Char, Args...)(in Char[] fmt, Args args)
if (isSomeChar!Char)
{
    import std.array : appender;

    auto w = appender!(immutable(Char)[]);
    auto n = formattedWrite(w, fmt, args);
    version (all)
    {
        // In the future, this check will be removed to increase consistency
        // with formattedWrite
        import std.conv : text;
        enforceFmt(n == args.length, text("Orphan format arguments: args[", n, "..", args.length, "]"));
    }
    return w.data;
}

///
@safe pure unittest
{
    assert(format("Here are %d %s.", 3, "apples") == "Here are 3 apples.");

    assert("Increase: %7.2f %%".format(17.4285) == "Increase:   17.43 %");
}

@safe pure unittest
{
    import std.exception : assertCTFEable, assertThrown;

    assertCTFEable!(
    {
        assert(format("foo") == "foo");
        assert(format("foo%%") == "foo%");
        assert(format("foo%s", 'C') == "fooC");
        assert(format("%s foo", "bar") == "bar foo");
        assert(format("%s foo %s", "bar", "abc") == "bar foo abc");
        assert(format("foo %d", -123) == "foo -123");
        assert(format("foo %d", 123) == "foo 123");

        assertThrown!FormatException(format("foo %s"));
        assertThrown!FormatException(format("foo %s", 123, 456));

        assert(format("hel%slo%s%s%s", "world", -138, 'c', true) == "helworldlo-138ctrue");
    });

    assert(is(typeof(format("happy")) == string));
    assert(is(typeof(format("happy"w)) == wstring));
    assert(is(typeof(format("happy"d)) == dstring));
}

// https://issues.dlang.org/show_bug.cgi?id=16661
@safe pure unittest
{
    assert(format("%.2f"d, 0.4) == "0.40");
    assert("%02d"d.format(1) == "01"d);
}

@safe unittest
{
    int i;
    string s;

    s = format("hello world! %s %s %s%s%s", true, 57, 1_000_000_000, 'x', " foo");
    assert(s == "hello world! true 57 1000000000x foo");

    s = format("%s %A %s", 1.67, -1.28, float.nan);
    assert(s == "1.67 -0X1.47AE147AE147BP+0 nan", s);

    s = format("%x %X", 0x1234AF, 0xAFAFAFAF);
    assert(s == "1234af AFAFAFAF");

    s = format("%b %o", 0x1234AF, 0xAFAFAFAF);
    assert(s == "100100011010010101111 25753727657");

    s = format("%d %s", 0x1234AF, 0xAFAFAFAF);
    assert(s == "1193135 2947526575");
}

@safe unittest
{
    import std.conv : octal;

    string s;
    int i;

    s = format("%#06.*f", 2, 12.345);
    assert(s == "012.35");

    s = format("%#0*.*f", 6, 2, 12.345);
    assert(s == "012.35");

    s = format("%7.4g:", 12.678);
    assert(s == "  12.68:");

    s = format("%7.4g:", 12.678L);
    assert(s == "  12.68:");

    s = format("%04f|%05d|%#05x|%#5x", -4.0, -10, 1, 1);
    assert(s == "-4.000000|-0010|0x001|  0x1");

    i = -10;
    s = format("%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(s == "-10|-10|-10|-10|-10.0000");

    i = -5;
    s = format("%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(s == "-5| -5|-05|-5|-5.0000");

    i = 0;
    s = format("%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(s == "0|  0|000|0|0.0000");

    i = 5;
    s = format("%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(s == "5|  5|005|5|5.0000");

    i = 10;
    s = format("%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(s == "10| 10|010|10|10.0000");

    s = format("%.0d", 0);
    assert(s == "0");

    s = format("%.g", .34);
    assert(s == "0.3");

    s = format("%.0g", .34);
    assert(s == "0.3");

    s = format("%.2g", .34);
    assert(s == "0.34");

    s = format("%0.0008f", 1e-08);
    assert(s == "0.00000001");

    s = format("%0.0008f", 1e-05);
    assert(s == "0.00001000");

    s = "helloworld";
    string r;
    r = format("%.2s", s[0 .. 5]);
    assert(r == "he");
    r = format("%.20s", s[0 .. 5]);
    assert(r == "hello");
    r = format("%8s", s[0 .. 5]);
    assert(r == "   hello");

    byte[] arrbyte = new byte[4];
    arrbyte[0] = 100;
    arrbyte[1] = -99;
    arrbyte[3] = 0;
    r = format("%s", arrbyte);
    assert(r == "[100, -99, 0, 0]");

    ubyte[] arrubyte = new ubyte[4];
    arrubyte[0] = 100;
    arrubyte[1] = 200;
    arrubyte[3] = 0;
    r = format("%s", arrubyte);
    assert(r == "[100, 200, 0, 0]");

    short[] arrshort = new short[4];
    arrshort[0] = 100;
    arrshort[1] = -999;
    arrshort[3] = 0;
    r = format("%s", arrshort);
    assert(r == "[100, -999, 0, 0]");

    ushort[] arrushort = new ushort[4];
    arrushort[0] = 100;
    arrushort[1] = 20_000;
    arrushort[3] = 0;
    r = format("%s", arrushort);
    assert(r == "[100, 20000, 0, 0]");

    int[] arrint = new int[4];
    arrint[0] = 100;
    arrint[1] = -999;
    arrint[3] = 0;
    r = format("%s", arrint);
    assert(r == "[100, -999, 0, 0]");

    long[] arrlong = new long[4];
    arrlong[0] = 100;
    arrlong[1] = -999;
    arrlong[3] = 0;
    r = format("%s", arrlong);
    assert(r == "[100, -999, 0, 0]");

    ulong[] arrulong = new ulong[4];
    arrulong[0] = 100;
    arrulong[1] = 999;
    arrulong[3] = 0;
    r = format("%s", arrulong);
    assert(r == "[100, 999, 0, 0]");

    string[] arr2 = new string[4];
    arr2[0] = "hello";
    arr2[1] = "world";
    arr2[3] = "foo";
    r = format("%s", arr2);
    assert(r == `["hello", "world", "", "foo"]`);

    r = format("%.8d", 7);
    assert(r == "00000007");
    r = format("%.8x", 10);
    assert(r == "0000000a");

    r = format("%-3d", 7);
    assert(r == "7  ");

    r = format("%-1*d", 4, 3);
    assert(r == "3   ");

    r = format("%*d", -3, 7);
    assert(r == "7  ");

    r = format("%.*d", -3, 7);
    assert(r == "7");

    r = format("%-1.*f", 2, 3.1415);
    assert(r == "3.14");

    r = format("abc"c);
    assert(r == "abc");

    //format() returns the same type as inputted.
    wstring wr;
    wr = format("def"w);
    assert(wr == "def"w);

    dstring dr;
    dr = format("ghi"d);
    assert(dr == "ghi"d);

    // Empty static character arrays work as well
    const char[0] cempty;
    assert(format("test%spath", cempty) == "testpath");
    const wchar[0] wempty;
    assert(format("test%spath", wempty) == "testpath");
    const dchar[0] dempty;
    assert(format("test%spath", dempty) == "testpath");

    void* p = () @trusted { return cast(void*) 0xDEADBEEF; } ();
    r = format("%s", p);
    assert(r == "DEADBEEF");

    r = format("%#x", 0xabcd);
    assert(r == "0xabcd");
    r = format("%#X", 0xABCD);
    assert(r == "0XABCD");

    r = format("%#o", octal!12345);
    assert(r == "012345");
    r = format("%o", 9);
    assert(r == "11");
    r = format("%#o", 0);   // https://issues.dlang.org/show_bug.cgi?id=15663
    assert(r == "0");

    r = format("%+d", 123);
    assert(r == "+123");
    r = format("%+d", -123);
    assert(r == "-123");
    r = format("% d", 123);
    assert(r == " 123");
    r = format("% d", -123);
    assert(r == "-123");

    r = format("%%");
    assert(r == "%");

    r = format("%d", true);
    assert(r == "1");
    r = format("%d", false);
    assert(r == "0");

    r = format("%d", 'a');
    assert(r == "97");
    wchar wc = 'a';
    r = format("%d", wc);
    assert(r == "97");
    dchar dc = 'a';
    r = format("%d", dc);
    assert(r == "97");

    byte b = byte.max;
    r = format("%x", b);
    assert(r == "7f");
    r = format("%x", ++b);
    assert(r == "80");
    r = format("%x", ++b);
    assert(r == "81");

    short sh = short.max;
    r = format("%x", sh);
    assert(r == "7fff");
    r = format("%x", ++sh);
    assert(r == "8000");
    r = format("%x", ++sh);
    assert(r == "8001");

    i = int.max;
    r = format("%x", i);
    assert(r == "7fffffff");
    r = format("%x", ++i);
    assert(r == "80000000");
    r = format("%x", ++i);
    assert(r == "80000001");

    r = format("%x", 10);
    assert(r == "a");
    r = format("%X", 10);
    assert(r == "A");
    r = format("%x", 15);
    assert(r == "f");
    r = format("%X", 15);
    assert(r == "F");

    Object c = null;
    r = () @trusted { return format("%s", c); } ();
    assert(r == "null");

    enum TestEnum
    {
        Value1, Value2
    }
    r = format("%s", TestEnum.Value2);
    assert(r == "Value2");

    immutable(char[5])[int] aa = ([3:"hello", 4:"betty"]);
    r = () @trusted { return format("%s", aa.values); } ();
    assert(r == `["hello", "betty"]` || r == `["betty", "hello"]`);
    r = format("%s", aa);
    assert(r == `[3:"hello", 4:"betty"]` || r == `[4:"betty", 3:"hello"]`);

    static const dchar[] ds = ['a','b'];
    for (int j = 0; j < ds.length; ++j)
    {
        r = format(" %d", ds[j]);
        if (j == 0)
            assert(r == " 97");
        else
            assert(r == " 98");
    }

    r = format(">%14d<, %s", 15, [1,2,3]);
    assert(r == ">            15<, [1, 2, 3]");

    assert(format("%8s", "bar") == "     bar");
    assert(format("%8s", "b\u00e9ll\u00f4") == "   b\u00e9ll\u00f4");
}

@safe unittest
{
    import std.exception : assertCTFEable;

    assertCTFEable!(
    {
        auto tmp = format("%,d", 1000);
        assert(tmp == "1,000", "'" ~ tmp ~ "'");

        tmp = format("%,?d", 'z', 1234567);
        assert(tmp == "1z234z567", "'" ~ tmp ~ "'");

        tmp = format("%10,?d", 'z', 1234567);
        assert(tmp == " 1z234z567", "'" ~ tmp ~ "'");

        tmp = format("%11,2?d", 'z', 1234567);
        assert(tmp == " 1z23z45z67", "'" ~ tmp ~ "'");

        tmp = format("%11,*?d", 2, 'z', 1234567);
        assert(tmp == " 1z23z45z67", "'" ~ tmp ~ "'");

        tmp = format("%11,*d", 2, 1234567);
        assert(tmp == " 1,23,45,67", "'" ~ tmp ~ "'");

        tmp = format("%11,2d", 1234567);
        assert(tmp == " 1,23,45,67", "'" ~ tmp ~ "'");
    });
}

@safe unittest
{
    auto tmp = format("%,f", 1000.0);
    assert(tmp == "1,000.000000", "'" ~ tmp ~ "'");

    tmp = format("%,f", 1234567.891011);
    assert(tmp == "1,234,567.891011", "'" ~ tmp ~ "'");

    tmp = format("%,f", -1234567.891011);
    assert(tmp == "-1,234,567.891011", "'" ~ tmp ~ "'");

    tmp = format("%,2f", 1234567.891011);
    assert(tmp == "1,23,45,67.891011", "'" ~ tmp ~ "'");

    tmp = format("%18,f", 1234567.891011);
    assert(tmp == "  1,234,567.891011", "'" ~ tmp ~ "'");

    tmp = format("%18,?f", '.', 1234567.891011);
    assert(tmp == "  1.234.567.891011", "'" ~ tmp ~ "'");

    tmp = format("%,?.3f", 'ä', 1234567.891011);
    assert(tmp == "1ä234ä567.891", "'" ~ tmp ~ "'");

    tmp = format("%,*?.3f", 1, 'ä', 1234567.891011);
    assert(tmp == "1ä2ä3ä4ä5ä6ä7.891", "'" ~ tmp ~ "'");

    tmp = format("%,4?.3f", '_', 1234567.891011);
    assert(tmp == "123_4567.891", "'" ~ tmp ~ "'");

    tmp = format("%12,3.3f", 1234.5678);
    assert(tmp == "   1,234.568", "'" ~ tmp ~ "'");

    tmp = format("%,e", 3.141592653589793238462);
    assert(tmp == "3.141593e+00", "'" ~ tmp ~ "'");

    tmp = format("%15,e", 3.141592653589793238462);
    assert(tmp == "   3.141593e+00", "'" ~ tmp ~ "'");

    tmp = format("%15,e", -3.141592653589793238462);
    assert(tmp == "  -3.141593e+00", "'" ~ tmp ~ "'");

    tmp = format("%.4,*e", 2, 3.141592653589793238462);
    assert(tmp == "3.1416e+00", "'" ~ tmp ~ "'");

    tmp = format("%13.4,*e", 2, 3.141592653589793238462);
    assert(tmp == "   3.1416e+00", "'" ~ tmp ~ "'");

    tmp = format("%,.0f", 3.14);
    assert(tmp == "3", "'" ~ tmp ~ "'");

    tmp = format("%3,g", 1_000_000.123456);
    assert(tmp == "1e+06", "'" ~ tmp ~ "'");

    tmp = format("%19,?f", '.', -1234567.891011);
    assert(tmp == "  -1.234.567.891011", "'" ~ tmp ~ "'");
}

// Test for multiple indexes
@safe unittest
{
    auto tmp = format("%2:5$s", 1, 2, 3, 4, 5);
    assert(tmp == "2345", tmp);
}

// https://issues.dlang.org/show_bug.cgi?id=18047
@safe unittest
{
    auto cmp = "     123,456";
    assert(cmp.length == 12, format("%d", cmp.length));
    auto tmp = format("%12,d", 123456);
    assert(tmp.length == 12, format("%d", tmp.length));

    assert(tmp == cmp, "'" ~ tmp ~ "'");
}

// https://issues.dlang.org/show_bug.cgi?id=17459
@safe unittest
{
    auto cmp = "100";
    auto tmp  = format("%0d", 100);
    assert(tmp == cmp, tmp);

    cmp = "0100";
    tmp  = format("%04d", 100);
    assert(tmp == cmp, tmp);

    cmp = "0,000,000,100";
    tmp  = format("%012,3d", 100);
    assert(tmp == cmp, tmp);

    cmp = "0,000,001,000";
    tmp = format("%012,3d", 1_000);
    assert(tmp == cmp, tmp);

    cmp = "0,000,100,000";
    tmp = format("%012,3d", 100_000);
    assert(tmp == cmp, tmp);

    cmp = "0,001,000,000";
    tmp = format("%012,3d", 1_000_000);
    assert(tmp == cmp, tmp);

    cmp = "0,100,000,000";
    tmp = format("%012,3d", 100_000_000);
    assert(tmp == cmp, tmp);
}

// https://issues.dlang.org/show_bug.cgi?id=17459
@safe unittest
{
    auto cmp = "100,000";
    auto tmp  = format("%06,d", 100_000);
    assert(tmp == cmp, tmp);

    cmp = "100,000";
    tmp  = format("%07,d", 100_000);
    assert(tmp == cmp, tmp);

    cmp = "0,100,000";
    tmp  = format("%08,d", 100_000);
    assert(tmp == cmp, tmp);
}

// https://issues.dlang.org/show_bug.cgi?id=20288
@safe unittest
{
    string s = format("%,.2f", double.nan);
    assert(s == "nan", s);

    s = format("%,.2F", double.nan);
    assert(s == "NAN", s);

    s = format("%,.2f", -double.nan);
    assert(s == "-nan", s);

    s = format("%,.2F", -double.nan);
    assert(s == "-NAN", s);

    string g = format("^%13s$", "nan");
    string h = "^          nan$";
    assert(g == h, "\ngot:" ~ g ~ "\nexp:" ~ h);
    string a = format("^%13,3.2f$", double.nan);
    string b = format("^%13,3.2F$", double.nan);
    string c = format("^%13,3.2f$", -double.nan);
    string d = format("^%13,3.2F$", -double.nan);
    assert(a == "^          nan$", "\ngot:'"~ a ~ "'\nexp:'^          nan$'");
    assert(b == "^          NAN$", "\ngot:'"~ b ~ "'\nexp:'^          NAN$'");
    assert(c == "^         -nan$", "\ngot:'"~ c ~ "'\nexp:'^         -nan$'");
    assert(d == "^         -NAN$", "\ngot:'"~ d ~ "'\nexp:'^         -NAN$'");

    a = format("^%-13,3.2f$", double.nan);
    b = format("^%-13,3.2F$", double.nan);
    c = format("^%-13,3.2f$", -double.nan);
    d = format("^%-13,3.2F$", -double.nan);
    assert(a == "^nan          $", "\ngot:'"~ a ~ "'\nexp:'^nan          $'");
    assert(b == "^NAN          $", "\ngot:'"~ b ~ "'\nexp:'^NAN          $'");
    assert(c == "^-nan         $", "\ngot:'"~ c ~ "'\nexp:'^-nan         $'");
    assert(d == "^-NAN         $", "\ngot:'"~ d ~ "'\nexp:'^-NAN         $'");

    a = format("^%+13,3.2f$", double.nan);
    b = format("^%+13,3.2F$", double.nan);
    c = format("^%+13,3.2f$", -double.nan);
    d = format("^%+13,3.2F$", -double.nan);
    assert(a == "^         +nan$", "\ngot:'"~ a ~ "'\nexp:'^         +nan$'");
    assert(b == "^         +NAN$", "\ngot:'"~ b ~ "'\nexp:'^         +NAN$'");
    assert(c == "^         -nan$", "\ngot:'"~ c ~ "'\nexp:'^         -nan$'");
    assert(d == "^         -NAN$", "\ngot:'"~ d ~ "'\nexp:'^         -NAN$'");

    a = format("^%-+13,3.2f$", double.nan);
    b = format("^%-+13,3.2F$", double.nan);
    c = format("^%-+13,3.2f$", -double.nan);
    d = format("^%-+13,3.2F$", -double.nan);
    assert(a == "^+nan         $", "\ngot:'"~ a ~ "'\nexp:'^+nan         $'");
    assert(b == "^+NAN         $", "\ngot:'"~ b ~ "'\nexp:'^+NAN         $'");
    assert(c == "^-nan         $", "\ngot:'"~ c ~ "'\nexp:'^-nan         $'");
    assert(d == "^-NAN         $", "\ngot:'"~ d ~ "'\nexp:'^-NAN         $'");

    a = format("^%- 13,3.2f$", double.nan);
    b = format("^%- 13,3.2F$", double.nan);
    c = format("^%- 13,3.2f$", -double.nan);
    d = format("^%- 13,3.2F$", -double.nan);
    assert(a == "^ nan         $", "\ngot:'"~ a ~ "'\nexp:'^ nan         $'");
    assert(b == "^ NAN         $", "\ngot:'"~ b ~ "'\nexp:'^ NAN         $'");
    assert(c == "^-nan         $", "\ngot:'"~ c ~ "'\nexp:'^-nan         $'");
    assert(d == "^-NAN         $", "\ngot:'"~ d ~ "'\nexp:'^-NAN         $'");
}

@safe unittest
{
    struct S
    {
        int a;

        void toString(void delegate(const(char)[]) sink, string fmt)
        {
            auto spec = singleSpec(fmt);
            sink.formatValue(a, spec);
        }
    }

    S s = S(1);
    auto result = () @trusted { return format!"%5,3d"(s); } ();
    assert(result == "    1");
}

// https://issues.dlang.org/show_bug.cgi?id=23245
@safe unittest
{
    static struct S
    {
        string toString() { return "S"; }
    }

    S[1] s;
    assert(format("%s", s) == "[S]");
}

// https://issues.dlang.org/show_bug.cgi?id=23246
@safe unittest
{
    static struct S
    {
        string toString() { return "S"; }
    }

    S[int] s = [0 : S()];
    assert(format("%s", s) == "[0:S]");
}

/// ditto
typeof(fmt) format(alias fmt, Args...)(Args args)
if (isSomeString!(typeof(fmt)))
{
    import std.array : appender;
    import std.range.primitives : ElementEncodingType;
    import std.traits : Unqual;

    alias e = checkFormatException!(fmt, Args);
    alias Char = Unqual!(ElementEncodingType!(typeof(fmt)));

    static assert(!e, e);
    auto w = appender!(immutable(Char)[]);

    // no need to traverse the string twice during compile time
    if (!__ctfe)
    {
        enum len = guessLength!Char(fmt);
        w.reserve(len);
    }
    else
    {
        w.reserve(fmt.length);
    }

    formattedWrite(w, fmt, args);
    return w.data;
}

/// The format string can be checked at compile-time:
@safe pure unittest
{
    auto s = format!"%s is %s"("Pi", 3.14);
    assert(s == "Pi is 3.14");

    // This line doesn't compile, because 3.14 cannot be formatted with %d:
    // s = format!"%s is %d"("Pi", 3.14);
}

@safe pure unittest
{
    string s;
    static assert(!__traits(compiles, {s = format!"%l"();}));     // missing arg
    static assert(!__traits(compiles, {s = format!""(404);}));    // surplus arg
    static assert(!__traits(compiles, {s = format!"%d"(4.03);})); // incompatible arg
}

// https://issues.dlang.org/show_bug.cgi?id=17381
@safe pure unittest
{
    static assert(!__traits(compiles, format!"%s"(1.5, 2)));
    static assert(!__traits(compiles, format!"%f"(1.5, 2)));
    static assert(!__traits(compiles, format!"%s"(1.5L, 2)));
    static assert(!__traits(compiles, format!"%f"(1.5L, 2)));
}

// called during compilation to guess the length of the
// result of format
private size_t guessLength(Char, S)(S fmtString)
{
    import std.array : appender;

    size_t len;
    auto output = appender!(immutable(Char)[])();
    auto spec = FormatSpec!Char(fmtString);
    while (spec.writeUpToNextSpec(output))
    {
        // take a guess
        if (spec.width == 0 && (spec.precision == spec.UNSPECIFIED || spec.precision == spec.DYNAMIC))
        {
            switch (spec.spec)
            {
                case 'c':
                    ++len;
                    break;
                case 'd':
                case 'x':
                case 'X':
                    len += 3;
                    break;
                case 'b':
                    len += 8;
                    break;
                case 'f':
                case 'F':
                    len += 10;
                    break;
                case 's':
                case 'e':
                case 'E':
                case 'g':
                case 'G':
                    len += 12;
                    break;
                default: break;
            }

            continue;
        }

        if ((spec.spec == 'e' || spec.spec == 'E' || spec.spec == 'g' ||
             spec.spec == 'G' || spec.spec == 'f' || spec.spec == 'F') &&
            spec.precision != spec.UNSPECIFIED && spec.precision != spec.DYNAMIC &&
            spec.width == 0
        )
        {
            len += spec.precision + 5;
            continue;
        }

        if (spec.width == spec.precision)
            len += spec.width;
        else if (spec.width > 0 && spec.width != spec.DYNAMIC &&
                 (spec.precision == spec.UNSPECIFIED || spec.width > spec.precision))
        {
            len += spec.width;
        }
        else if (spec.precision != spec.UNSPECIFIED && spec.precision > spec.width)
            len += spec.precision;
    }
    len += output.data.length;
    return len;
}

@safe pure
unittest
{
    assert(guessLength!char("%c") == 1);
    assert(guessLength!char("%d") == 3);
    assert(guessLength!char("%x") == 3);
    assert(guessLength!char("%b") == 8);
    assert(guessLength!char("%f") == 10);
    assert(guessLength!char("%s") == 12);
    assert(guessLength!char("%02d") == 2);
    assert(guessLength!char("%02d") == 2);
    assert(guessLength!char("%4.4d") == 4);
    assert(guessLength!char("%2.4f") == 4);
    assert(guessLength!char("%02d:%02d:%02d") == 8);
    assert(guessLength!char("%0.2f") == 7);
    assert(guessLength!char("%0*d") == 0);
}

/**
Converts its arguments according to a format string into a buffer.
The buffer has to be large enough to hold the formatted string.

The second version of `sformat` takes the format string as a template
argument. In this case, it is checked for consistency at
compile-time.

Params:
    buf = the buffer where the formatted string should go
    fmt = a $(MREF_ALTTEXT format string, std,format)
    args = a variadic list of arguments to be formatted
    Char = character type of `fmt`
    Args = a variadic list of types of the arguments

Returns:
    A slice of `buf` containing the formatted string.

Throws:
    A $(REF_ALTTEXT RangeError, RangeError, core, exception) if `buf`
    isn't large enough to hold the formatted string
    and a $(LREF FormatException) if formatting did not succeed.

Note:
    In theory this function should be `@nogc`. But with the current
    implementation there are some cases where allocations occur:

    $(UL
    $(LI An exception is thrown.)
    $(LI A custom `toString` function of a compound type allocates.))
 */
char[] sformat(Char, Args...)(return scope char[] buf, scope const(Char)[] fmt, Args args)
{
    import core.exception : RangeError;
    import std.range.primitives;
    import std.utf : encode;

    static struct Sink
    {
        char[] buf;
        size_t i;
        void put(char c)
        {
            if (buf.length <= i)
                throw new RangeError(__FILE__, __LINE__);

            buf[i] = c;
            i += 1;
        }
        void put(dchar c)
        {
            char[4] enc;
            auto n = encode(enc, c);

            if (buf.length < i + n)
                throw new RangeError(__FILE__, __LINE__);

            buf[i .. i + n] = enc[0 .. n];
            i += n;
        }
        void put(scope const(char)[] s)
        {
            if (buf.length < i + s.length)
                throw new RangeError(__FILE__, __LINE__);

            buf[i .. i + s.length] = s[];
            i += s.length;
        }
        void put(scope const(wchar)[] s)
        {
            for (; !s.empty; s.popFront())
                put(s.front);
        }
        void put(scope const(dchar)[] s)
        {
            for (; !s.empty; s.popFront())
                put(s.front);
        }
    }
    auto sink = Sink(buf);
    auto n = formattedWrite(sink, fmt, args);
    version (all)
    {
        // In the future, this check will be removed to increase consistency
        // with formattedWrite
        import std.conv : text;
        enforceFmt(
            n == args.length,
            text("Orphan format arguments: args[", n, " .. ", args.length, "]")
        );
    }
    return buf[0 .. sink.i];
}

/// ditto
char[] sformat(alias fmt, Args...)(char[] buf, Args args)
if (isSomeString!(typeof(fmt)))
{
    alias e = checkFormatException!(fmt, Args);
    static assert(!e, e);
    return .sformat(buf, fmt, args);
}

///
@safe pure unittest
{
    char[20] buf;
    assert(sformat(buf[], "Here are %d %s.", 3, "apples") == "Here are 3 apples.");

    assert(buf[].sformat("Increase: %7.2f %%", 17.4285) == "Increase:   17.43 %");
}

/// The format string can be checked at compile-time:
@safe pure unittest
{
    char[20] buf;

    assert(sformat!"Here are %d %s."(buf[], 3, "apples") == "Here are 3 apples.");

    // This line doesn't compile, because 3.14 cannot be formatted with %d:
    // writeln(sformat!"Here are %d %s."(buf[], 3.14, "apples"));
}

// checking, what is implicitly and explicitly stated in the public unittest
@safe unittest
{
    import std.exception : assertThrown;

    char[20] buf;
    assertThrown!FormatException(sformat(buf[], "Here are %d %s.", 3.14, "apples"));
    assert(!__traits(compiles, sformat!"Here are %d %s."(buf[], 3.14, "apples")));
}

@safe unittest
{
    import core.exception : RangeError;
    import std.exception : assertCTFEable, assertThrown;

    assertCTFEable!(
    {
        char[10] buf;

        assert(sformat(buf[], "foo") == "foo");
        assert(sformat(buf[], "foo%%") == "foo%");
        assert(sformat(buf[], "foo%s", 'C') == "fooC");
        assert(sformat(buf[], "%s foo", "bar") == "bar foo");
        () @trusted {
            assertThrown!RangeError(sformat(buf[], "%s foo %s", "bar", "abc"));
        } ();
        assert(sformat(buf[], "foo %d", -123) == "foo -123");
        assert(sformat(buf[], "foo %d", 123) == "foo 123");

        assertThrown!FormatException(sformat(buf[], "foo %s"));
        assertThrown!FormatException(sformat(buf[], "foo %s", 123, 456));

        assert(sformat(buf[], "%s %s %s", "c"c, "w"w, "d"d) == "c w d");
    });
}

@safe unittest // ensure that sformat avoids the GC
{
    import core.memory : GC;

    const a = ["foo", "bar"];
    const u = () @trusted { return GC.stats().usedSize; } ();
    char[20] buf;
    sformat(buf, "%d", 123);
    sformat(buf, "%s", a);
    sformat(buf, "%s", 'c');
    const v = () @trusted { return GC.stats().usedSize; } ();
    assert(u == v);
}

@safe unittest // https://issues.dlang.org/show_bug.cgi?id=23488
{
    static struct R
    {
        string s = "Ü";
        bool empty() { return s.length == 0; }
        char front() { return s[0]; }
        void popFront() { s = s[1 .. $]; }
    }
    char[2] buf;
    assert(sformat(buf, "%s", R()) == "Ü");
}

version (StdUnittest)
private void formatReflectTest(T)(ref T val, string fmt, string formatted, string fn = __FILE__, size_t ln = __LINE__)
{
    formatReflectTest(val, fmt, [formatted], fn, ln);
}

version (StdUnittest)
private void formatReflectTest(T)(ref T val, string fmt, string[] formatted, string fn = __FILE__, size_t ln = __LINE__)
{
    import core.exception : AssertError;
    import std.algorithm.searching : canFind;
    import std.array : appender;
    import std.math.operations : isClose;
    import std.traits : FloatingPointTypeOf;

    auto w = appender!string();
    formattedWrite(w, fmt, val);

    auto input = w.data;
    enforce!AssertError(formatted.canFind(input), input, fn, ln);

    T val2;
    formattedRead(input, fmt, val2);

    static if (is(FloatingPointTypeOf!T))
        enforce!AssertError(isClose(val, val2), input, fn, ln);
    else
        enforce!AssertError(val == val2, input, fn, ln);
}

@safe unittest
{
    void booleanTest()
    {
        auto b = true;
        formatReflectTest(b, "%s", `true`);
        formatReflectTest(b, "%b", `1`);
        formatReflectTest(b, "%o", `1`);
        formatReflectTest(b, "%d", `1`);
        formatReflectTest(b, "%u", `1`);
        formatReflectTest(b, "%x", `1`);
    }

    void integerTest()
    {
        auto n = 127;
        formatReflectTest(n, "%s", `127`);
        formatReflectTest(n, "%b", `1111111`);
        formatReflectTest(n, "%o", `177`);
        formatReflectTest(n, "%d", `127`);
        formatReflectTest(n, "%u", `127`);
        formatReflectTest(n, "%x", `7f`);
    }

    void floatingTest()
    {
        auto f = 3.14;
        formatReflectTest(f, "%s", `3.14`);
        formatReflectTest(f, "%e", `3.140000e+00`);
        formatReflectTest(f, "%f", `3.140000`);
        formatReflectTest(f, "%g", `3.14`);
    }

    void charTest()
    {
        auto c = 'a';
        formatReflectTest(c, "%s", `a`);
        formatReflectTest(c, "%c", `a`);
        formatReflectTest(c, "%b", `1100001`);
        formatReflectTest(c, "%o", `141`);
        formatReflectTest(c, "%d", `97`);
        formatReflectTest(c, "%u", `97`);
        formatReflectTest(c, "%x", `61`);
    }

    void strTest()
    {
        auto s = "hello";
        formatReflectTest(s, "%s",              `hello`);
        formatReflectTest(s, "%(%c,%)",         `h,e,l,l,o`);
        formatReflectTest(s, "%(%s,%)",         `'h','e','l','l','o'`);
        formatReflectTest(s, "[%(<%c>%| $ %)]", `[<h> $ <e> $ <l> $ <l> $ <o>]`);
    }

    void daTest()
    {
        auto a = [1,2,3,4];
        formatReflectTest(a, "%s",              `[1, 2, 3, 4]`);
        formatReflectTest(a, "[%(%s; %)]",      `[1; 2; 3; 4]`);
        formatReflectTest(a, "[%(<%s>%| $ %)]", `[<1> $ <2> $ <3> $ <4>]`);
    }

    void saTest()
    {
        int[4] sa = [1,2,3,4];
        formatReflectTest(sa, "%s",              `[1, 2, 3, 4]`);
        formatReflectTest(sa, "[%(%s; %)]",      `[1; 2; 3; 4]`);
        formatReflectTest(sa, "[%(<%s>%| $ %)]", `[<1> $ <2> $ <3> $ <4>]`);
    }

    void aaTest()
    {
        auto aa = [1:"hello", 2:"world"];
        formatReflectTest(aa, "%s",                    [`[1:"hello", 2:"world"]`, `[2:"world", 1:"hello"]`]);
        formatReflectTest(aa, "[%(%s->%s, %)]",        [`[1->"hello", 2->"world"]`, `[2->"world", 1->"hello"]`]);
        formatReflectTest(aa, "{%([%s=%(%c%)]%|; %)}", [`{[1=hello]; [2=world]}`, `{[2=world]; [1=hello]}`]);
    }

    import std.exception : assertCTFEable;

    assertCTFEable!(
    {
        booleanTest();
        integerTest();
        floatingTest();
        charTest();
        strTest();
        daTest();
        saTest();
        aaTest();
    });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // Written in the D programming language.

/**
This is a submodule of $(MREF std, format).

It provides two functions for reading formatted input: $(LREF
unformatValue) and $(LREF formattedRead). The former reads a single
value. The latter reads several values at once and matches the
characters found between format specifiers.

Parameters are ignored, except for the ones consisting of a single
$(B '*'). See $(LREF formattedRead) for more information.

A space outside of a format specifier has a special meaning: it
matches any sequence of whitespace characters, not just a single
space.

The following combinations of format characters and types are
available:

$(BOOKTABLE ,
$(TR $(TH) $(TH s) $(TH c) $(TH d, u, b, o, x, X) $(TH e, E, f, g, G) $(TH r) $(TH compound))
$(TR $(TD `bool`) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)))
$(TR $(TD `null`) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)))
$(TR $(TD $(I integer)) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)))
$(TR $(TD $(I floating point)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes) $(TD $(MDASH)))
$(TR $(TD $(I character)) $(TD yes) $(TD yes) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)))
$(TR $(TD $(I string)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes))
$(TR $(TD $(I array)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes))
$(TR $(TD $(I associative array)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes))
)

Below are highlighted examples on how these combinations are used
with $(LREF unformatValue), however, they apply for $(LREF
formattedRead) also

Copyright: Copyright The D Language Foundation 2000-2013.

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
Andrei Alexandrescu), and Kenji Hara

Source: $(PHOBOSSRC std/format/read.d)
 */
module std.format.read;

/// Booleans
@safe pure unittest
{
    import std.format.spec : singleSpec;

    auto str = "false";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!bool(spec) == false);

    str = "1";
    spec = singleSpec("%d");
    assert(str.unformatValue!bool(spec) == true);
}

/// Null values
@safe pure unittest
{
    import std.format.spec : singleSpec;

    auto str = "null";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!(typeof(null))(spec) == null);
}

/// Integrals
@safe pure unittest
{
    import std.format.spec : singleSpec;

    // signed decimal values
    auto str = "123";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!int(spec) == 123);

    // hexadecimal values
    str = "ABC";
    spec = singleSpec("%X");
    assert(str.unformatValue!int(spec) == 2748);

    // octal values
    str = "11610";
    spec = singleSpec("%o");
    assert(str.unformatValue!int(spec) == 5000);

    // raw read, depends on endianess
    str = "\x75\x01";
    spec = singleSpec("%r");
    auto result = str.unformatValue!short(spec);
    assert(result == 373 /* little endian */ || result == 29953 /* big endian */ );
}

/// Floating point numbers
@safe pure unittest
{
    import std.format.spec : singleSpec;
    import std.math.operations : isClose;

    // natural notation
    auto str = "123.456";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!double(spec).isClose(123.456));

    // scientific notation
    str = "1e17";
    spec = singleSpec("%e");
    assert(str.unformatValue!double(spec).isClose(1e17));

    // raw read, depends on endianess
    str = "\x40\x00\x00\xBF";
    spec = singleSpec("%r");
    auto result = str.unformatValue!float(spec);
    assert(isClose(result, -0.5) /* little endian */ || isClose(result, 2.0) /* big endian */ );
}

/// Characters
@safe pure unittest
{
    import std.format.spec : singleSpec;

    // only the first character is read
    auto str = "abc";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!char(spec) == 'a');

    // using a numerical format character treats the read number as unicode code point
    str = "65";
    spec = singleSpec("%d");
    assert(str.unformatValue!char(spec) == 'A');

    str = "41";
    spec = singleSpec("%x");
    assert(str.unformatValue!char(spec) == 'A');

    str = "10003";
    spec = singleSpec("%d");
    assert(str.unformatValue!dchar(spec) == '✓');
}

/// Arrays
@safe pure unittest
{
    import std.format.spec : singleSpec;

    // string value
    string str = "aaa";
    auto spec = singleSpec("%s");
    assert(str.unformatValue!(dchar[])(spec) == "aaa"d);

    // fixed size array with characters
    str = "aaa";
    spec = singleSpec("%s");
    dchar[3] ret = ['a', 'a', 'a'];
    assert(str.unformatValue!(dchar[3])(spec) == ret);

    // dynamic array
    str = "[1, 2, 3, 4]";
    spec = singleSpec("%s");
    assert(str.unformatValue!(int[])(spec) == [1, 2, 3, 4]);

    // fixed size array with integers
    str = "[1, 2, 3, 4]";
    spec = singleSpec("%s");
    int[4] ret2 = [1, 2, 3, 4];
    assert(str.unformatValue!(int[4])(spec) == ret2);

    // compound specifiers can be used for more control
    str = "1,2,3";
    spec = singleSpec("%(%s,%)");
    assert(str.unformatValue!(int[])(spec) == [1, 2, 3]);

    str = "cool";
    spec = singleSpec("%(%c%)");
    assert(str.unformatValue!(char[])(spec) == ['c', 'o', 'o', 'l']);
}

/// Associative arrays
@safe pure unittest
{
    import std.format.spec : singleSpec;

    // as single value
    auto str = `["one": 1, "two": 2]`;
    auto spec = singleSpec("%s");
    assert(str.unformatValue!(int[string])(spec) == ["one": 1, "two": 2]);

    // with compound specifier for more control
    str = "1/1, 2/4, 3/9";
    spec = singleSpec("%(%d/%d%|, %)");
    assert(str.unformatValue!(int[int])(spec) == [1: 1, 2: 4, 3: 9]);
}

import std.format.spec : FormatSpec;
import std.format.internal.read;
import std.traits : isSomeString;

/**
Reads an input range according to a format string and stores the read
values into its arguments.

Format specifiers with format character $(B 'd'), $(B 'u') and $(B
'c') can take a $(B '*') parameter for skipping values.

The second version of `formattedRead` takes the format string as
template argument. In this case, it is checked for consistency at
compile-time.

Params:
    r = an $(REF_ALTTEXT input range, isInputRange, std, range, primitives),
        where the formatted input is read from
    fmt = a $(MREF_ALTTEXT format string, std,format)
    args = a variadic list of arguments where the read values are stored
    Range = the type of the input range `r`
    Char = the character type used for `fmt`
    Args = a variadic list of types of the arguments

Returns:
    The number of variables filled. If the input range `r` ends early,
    this number will be less than the number of variables provided.

Throws:
    A $(REF_ALTTEXT FormatException, FormatException, std, format)
    if reading did not succeed.

Note:
    For backward compatibility the arguments `args` can be given as pointers
    to that variable, but it is not recommended to do so, because this
    option might be removed in the future.
 */
uint formattedRead(Range, Char, Args...)(auto ref Range r, const(Char)[] fmt, auto ref Args args)
{
    import std.format : enforceFmt;
    import std.range.primitives : empty;
    import std.traits : isPointer;
    import std.typecons : isTuple;

    auto spec = FormatSpec!Char(fmt);
    static if (!Args.length)
    {
        spec.readUpToNextSpec(r);
        enforceFmt(spec.trailing.empty, "Trailing characters in formattedRead format string");
        return 0;
    }
    else
    {
        enum hasPointer = isPointer!(typeof(args[0]));

        // The function below accounts for '*' == fields meant to be
        // read and skipped
        void skipUnstoredFields()
        {
            for (;;)
            {
                spec.readUpToNextSpec(r);
                if (spec.width != spec.DYNAMIC) break;
                // must skip this field
                skipData(r, spec);
            }
        }

        skipUnstoredFields();
        if (r.empty)
        {
            // Input is empty, nothing to read
            return 0;
        }

        static if (hasPointer)
            alias A = typeof(*args[0]);
        else
            alias A = typeof(args[0]);

        static if (isTuple!A)
        {
            foreach (i, T; A.Types)
            {
                static if (hasPointer)
                    (*args[0])[i] = unformatValue!(T)(r, spec);
                else
                    args[0][i] = unformatValue!(T)(r, spec);
                skipUnstoredFields();
            }
        }
        else
        {
            static if (hasPointer)
                *args[0] = unformatValue!(A)(r, spec);
            else
                args[0] = unformatValue!(A)(r, spec);
        }
        return 1 + formattedRead(r, spec.trailing, args[1 .. $]);
    }
}

/// ditto
uint formattedRead(alias fmt, Range, Args...)(auto ref Range r, auto ref Args args)
if (isSomeString!(typeof(fmt)))
{
    import std.format : checkFormatException;
    import std.meta : staticMap;
    import std.typecons : Tuple;


    // formattedRead supports std.typecons.Tuple
    // however, checkFormatException does not
    // this means that all std.typecons.Tuple's types in Args must be unwrapped
    // and passed to checkFormatException
    template Flatten(T)
    {
        static if (is(T : Tuple!Args, Args...))
            alias Flatten = Args;
        else
            alias Flatten = T;
    }

    alias e = checkFormatException!(fmt, staticMap!(Flatten, Args));
    static assert(!e, e);
    return .formattedRead(r, fmt, args);
}

///
@safe pure unittest
{
    string object;
    char cmp;
    int value;

    assert(formattedRead("angle < 36", "%s %c %d", object, cmp, value) == 3);
    assert(object == "angle");
    assert(cmp == '<');
    assert(value == 36);

    // reading may end early:
    assert(formattedRead("length >", "%s %c %d", object, cmp, value) == 2);
    assert(object == "length");
    assert(cmp == '>');
    // value is not changed:
    assert(value == 36);
}

/// The format string can be checked at compile-time:
@safe pure unittest
{
    string a;
    int b;
    double c;

    assert("hello!124:34.5".formattedRead!"%s!%s:%s"(a, b, c) == 3);
    assert(a == "hello");
    assert(b == 124);
    assert(c == 34.5);
}

/// Skipping values
@safe pure unittest
{
    string item;
    double amount;

    assert("orange: (12%) 15.25".formattedRead("%s: (%*d%%) %f", item, amount) == 2);
    assert(item == "orange");
    assert(amount == 15.25);

    // can also be used with tuples
    import std.typecons : Tuple;

    Tuple!(int, float) t;
    char[] line = "1 7643 2.125".dup;
    formattedRead(line, "%s %*u %s", t);
    assert(t[0] == 1 && t[1] == 2.125);
}

// https://issues.dlang.org/show_bug.cgi?id=23600
@safe pure unittest
{
    import std.typecons : Tuple, tuple;

    string h, w;
    Tuple!(int, float) t;

    assert("hello 1 2.34 world".formattedRead!"%s %d %f %s"(h, t, w) == 3);
    assert(h == "hello");
    assert(t == tuple(1, 2.34f));
    assert(w == "world");
}

@safe unittest
{
    import std.math.operations : isClose;
    import std.math.traits : isNaN;
    import std.range.primitives : empty;

    string s = " 1.2 3.4 ";
    double x, y, z;
    assert(formattedRead(s, " %s %s %s ", x, y, z) == 2);
    assert(s.empty);
    assert(isClose(x, 1.2));
    assert(isClose(y, 3.4));
    assert(isNaN(z));
}

// for backwards compatibility
@safe pure unittest
{
    string s = "hello!124:34.5";
    string a;
    int b;
    double c;
    formattedRead(s, "%s!%s:%s", &a, &b, &c);
    assert(a == "hello" && b == 124 && c == 34.5);

    // mix pointers and auto-ref
    s = "world!200:42.25";
    formattedRead(s, "%s!%s:%s", a, &b, &c);
    assert(a == "world" && b == 200 && c == 42.25);

    s = "world1!201:42.5";
    formattedRead(s, "%s!%s:%s", &a, &b, c);
    assert(a == "world1" && b == 201 && c == 42.5);

    s = "world2!202:42.75";
    formattedRead(s, "%s!%s:%s", a, b, &c);
    assert(a == "world2" && b == 202 && c == 42.75);
}

// for backwards compatibility
@safe pure unittest
{
    import std.math.operations : isClose;
    import std.math.traits : isNaN;
    import std.range.primitives : empty;

    string s = " 1.2 3.4 ";
    double x, y, z;
    assert(formattedRead(s, " %s %s %s ", &x, &y, &z) == 2);
    assert(s.empty);
    assert(isClose(x, 1.2));
    assert(isClose(y, 3.4));
    assert(isNaN(z));
}

@safe unittest
{
    string s = "hello!124:34.5";
    string a;
    int b;
    double c;
    formattedRead(s, "%s!%s:%s", &a, &b, &c);
    assert(a == "hello" && b == 124 && c == 34.5);
}

@safe pure unittest
{
    string line;

    bool f1;

    line = "true";
    formattedRead(line, "%s", &f1);
    assert(f1);

    line = "TrUE";
    formattedRead(line, "%s", &f1);
    assert(f1);

    line = "false";
    formattedRead(line, "%s", &f1);
    assert(!f1);

    line = "fALsE";
    formattedRead(line, "%s", &f1);
    assert(!f1);

    line = "1";
    formattedRead(line, "%d", &f1);
    assert(f1);

    line = "-1";
    formattedRead(line, "%d", &f1);
    assert(f1);

    line = "0";
    formattedRead(line, "%d", &f1);
    assert(!f1);

    line = "-0";
    formattedRead(line, "%d", &f1);
    assert(!f1);
}

@safe pure unittest
{
    union B
    {
        char[int.sizeof] untyped;
        int typed;
    }

    B b;
    b.typed = 5;
    char[] input = b.untyped[];
    int witness;
    formattedRead(input, "%r", &witness);
    assert(witness == b.typed);
}

@safe pure unittest
{
    union A
    {
        char[float.sizeof] untyped;
        float typed;
    }

    A a;
    a.typed = 5.5;
    char[] input = a.untyped[];
    float witness;
    formattedRead(input, "%r", &witness);
    assert(witness == a.typed);
}

@safe pure unittest
{
    import std.typecons : Tuple;

    char[] line = "1 2".dup;
    int a, b;
    formattedRead(line, "%s %s", &a, &b);
    assert(a == 1 && b == 2);

    line = "10 2 3".dup;
    formattedRead(line, "%d ", &a);
    assert(a == 10);
    assert(line == "2 3");

    Tuple!(int, float) t;
    line = "1 2.125".dup;
    formattedRead(line, "%d %g", &t);
    assert(t[0] == 1 && t[1] == 2.125);

    line = "1 7643 2.125".dup;
    formattedRead(line, "%s %*u %s", &t);
    assert(t[0] == 1 && t[1] == 2.125);
}

@safe pure unittest
{
    string line;

    char c1, c2;

    line = "abc";
    formattedRead(line, "%s%c", &c1, &c2);
    assert(c1 == 'a' && c2 == 'b');
    assert(line == "c");
}

@safe pure unittest
{
    string line;

    line = "[1,2,3]";
    int[] s1;
    formattedRead(line, "%s", &s1);
    assert(s1 == [1,2,3]);
}

@safe pure unittest
{
    string line;

    line = "[1,2,3]";
    int[] s1;
    formattedRead(line, "[%(%s,%)]", &s1);
    assert(s1 == [1,2,3]);

    line = `["hello", "world"]`;
    string[] s2;
    formattedRead(line, "[%(%s, %)]", &s2);
    assert(s2 == ["hello", "world"]);

    line = "123 456";
    int[] s3;
    formattedRead(line, "%(%s %)", &s3);
    assert(s3 == [123, 456]);

    line = "h,e,l,l,o; w,o,r,l,d";
    string[] s4;
    formattedRead(line, "%(%(%c,%); %)", &s4);
    assert(s4 == ["hello", "world"]);
}

@safe pure unittest
{
    import std.exception : assertThrown;

    string line;

    int[4] sa1;
    line = `[1,2,3,4]`;
    formattedRead(line, "%s", &sa1);
    assert(sa1 == [1,2,3,4]);

    int[4] sa2;
    line = `[1,2,3]`;
    assertThrown(formattedRead(line, "%s", &sa2));

    int[4] sa3;
    line = `[1,2,3,4,5]`;
    assertThrown(formattedRead(line, "%s", &sa3));
}

@safe pure unittest
{
    import std.exception : assertThrown;
    import std.format : FormatException;

    string input;

    int[4] sa1;
    input = `[1,2,3,4]`;
    formattedRead(input, "[%(%s,%)]", &sa1);
    assert(sa1 == [1,2,3,4]);

    int[4] sa2;
    input = `[1,2,3]`;
    assertThrown!FormatException(formattedRead(input, "[%(%s,%)]", &sa2));
}

@safe pure unittest
{
    string line;

    string s1, s2;

    line = "hello, world";
    formattedRead(line, "%s", &s1);
    assert(s1 == "hello, world", s1);

    line = "hello, world;yah";
    formattedRead(line, "%s;%s", &s1, &s2);
    assert(s1 == "hello, world", s1);
    assert(s2 == "yah", s2);

    line = `['h','e','l','l','o']`;
    string s3;
    formattedRead(line, "[%(%s,%)]", &s3);
    assert(s3 == "hello");

    line = `"hello"`;
    string s4;
    formattedRead(line, "\"%(%c%)\"", &s4);
    assert(s4 == "hello");
}

@safe pure unittest
{
    string line;

    string[int] aa1;
    line = `[1:"hello", 2:"world"]`;
    formattedRead(line, "%s", &aa1);
    assert(aa1 == [1:"hello", 2:"world"]);

    int[string] aa2;
    line = `{"hello"=1; "world"=2}`;
    formattedRead(line, "{%(%s=%s; %)}", &aa2);
    assert(aa2 == ["hello":1, "world":2]);

    int[string] aa3;
    line = `{[hello=1]; [world=2]}`;
    formattedRead(line, "{%([%(%c%)=%s]%|; %)}", &aa3);
    assert(aa3 == ["hello":1, "world":2]);
}

// test rvalue using
@safe pure unittest
{
    string[int] aa1;
    formattedRead!("%s")(`[1:"hello", 2:"world"]`, aa1);
    assert(aa1 == [1:"hello", 2:"world"]);

    int[string] aa2;
    formattedRead(`{"hello"=1; "world"=2}`, "{%(%s=%s; %)}", aa2);
    assert(aa2 == ["hello":1, "world":2]);
}

/**
Reads a value from the given _input range and converts it according to a
format specifier.

Params:
    input = the $(REF_ALTTEXT input range, isInputRange, std, range, primitives),
            to read from
    spec = a $(MREF_ALTTEXT format string, std,format)
    T = type to return
    Range = the type of the input range `input`
    Char = the character type used for `spec`

Returns:
    A value from `input` of type `T`.

Throws:
    A $(REF_ALTTEXT FormatException, FormatException, std, format)
    if reading did not succeed.

See_Also:
    $(REF parse, std, conv) and $(REF to, std, conv)
 */
T unformatValue(T, Range, Char)(ref Range input, scope const ref FormatSpec!Char spec)
{
    return unformatValueImpl!T(input, spec);
}

///
@safe pure unittest
{
    import std.format.spec : singleSpec;

    string s = "42";
    auto spec = singleSpec("%s");
    assert(unformatValue!int(s, spec) == 42);
}

// https://issues.dlang.org/show_bug.cgi?id=7241
@safe pure unittest
{
    string input = "a";
    auto spec = FormatSpec!char("%s");
    spec.readUpToNextSpec(input);
    auto result = unformatValue!(dchar[1])(input, spec);
    assert(result[0] == 'a');
}

// https://issues.dlang.org/show_bug.cgi?id=20393
@safe pure unittest
{
    import std.exception : assertThrown;
    string str = "foo 12a-buzz";
    string a, c;
    int b;
    assertThrown(formattedRead(str, "%s %d-%s", &a, &b, &c));
}

// https://issues.dlang.org/show_bug.cgi?id=18051
@safe pure unittest
{
    import std.format : format;

    enum Op { lt, gt, eq }

    auto s = format!"%s"(Op.lt);
    Op op;
    assert(formattedRead!"%s"(s, op) == 1);
    assert(op == Op.lt);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               // Written in the D programming language.

/**
This is a submodule of $(MREF std, format).

It centers around a struct called $(LREF FormatSpec), which takes a
$(MREF_ALTTEXT format string, std,format) and provides tools for
parsing this string. Additionally this module contains a function
$(LREF singleSpec) which helps treating a single format specifier.

Copyright: Copyright The D Language Foundation 2000-2013.

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
Andrei Alexandrescu), and Kenji Hara

Source: $(PHOBOSSRC std/format/spec.d)
 */
module std.format.spec;

import std.traits : Unqual;

template FormatSpec(Char)
if (!is(Unqual!Char == Char))
{
    alias FormatSpec = FormatSpec!(Unqual!Char);
}

/**
A general handler for format strings.

This handler centers around the function $(LREF writeUpToNextSpec),
which parses the $(MREF_ALTTEXT format string, std,format) until the
next format specifier is found. After the call, it provides
information about this format specifier in its numerous variables.

Params:
    Char = the character type of the format string
 */
struct FormatSpec(Char)
if (is(Unqual!Char == Char))
{
    import std.algorithm.searching : startsWith;
    import std.ascii : isDigit;
    import std.conv : parse, text, to;
    import std.range.primitives;

    /**
       Minimum width.

       _Default: `0`.
     */
    int width = 0;

    /**
       Precision. Its semantic depends on the format character.

       See $(MREF_ALTTEXT format string, std,format) for more details.
       _Default: `UNSPECIFIED`.
     */
    int precision = UNSPECIFIED;

    /**
       Number of elements between separators.

       _Default: `UNSPECIFIED`.
     */
    int separators = UNSPECIFIED;

    /**
       The separator charactar is supplied at runtime.

       _Default: false.
     */
    bool dynamicSeparatorChar = false;

    /**
       Set to `DYNAMIC` when the separator character is supplied at runtime.

       _Default: `UNSPECIFIED`.

       $(RED Warning:
           `separatorCharPos` is deprecated. It will be removed in 2.107.0.
           Please use `dynamicSeparatorChar` instead.)
     */
    // @@@DEPRECATED_[2.107.0]@@@
    deprecated("separatorCharPos will be removed in 2.107.0. Please use dynamicSeparatorChar instead.")
    int separatorCharPos() { return dynamicSeparatorChar ? DYNAMIC : UNSPECIFIED; }

    /// ditto
    // @@@DEPRECATED_[2.107.0]@@@
    deprecated("separatorCharPos will be removed in 2.107.0. Please use dynamicSeparatorChar instead.")
    void separatorCharPos(int value) { dynamicSeparatorChar = value == DYNAMIC; }

    /**
       Character to use as separator.

       _Default: `','`.
     */
    dchar separatorChar = ',';

    /**
       Special value for `width`, `precision` and `separators`.

       It flags that these values will be passed at runtime through
       variadic arguments.
     */
    enum int DYNAMIC = int.max;

    /**
       Special value for `precision` and `separators`.

       It flags that these values have not been specified.
     */
    enum int UNSPECIFIED = DYNAMIC - 1;

    /**
       The format character.

       _Default: `'s'`.
     */
    char spec = 's';

    /**
       Index of the argument for positional parameters.

       Counting starts with `1`. Set to `0` if not used. Default: `0`.
     */
    ubyte indexStart;

    /**
       Index of the last argument for positional parameter ranges.

       Counting starts with `1`. Set to `0` if not used. Default: `0`.
    */
    ubyte indexEnd;

    version (StdDdoc)
    {
        /// The format specifier contained a `'-'`.
        bool flDash;

        /// The format specifier contained a `'0'`.
        bool flZero;

        /// The format specifier contained a space.
        bool flSpace;

        /// The format specifier contained a `'+'`.
        bool flPlus;

        /// The format specifier contained a `'#'`.
        bool flHash;

        /// The format specifier contained a `'='`.
        bool flEqual;

        /// The format specifier contained a `','`.
        bool flSeparator;

        // Fake field to allow compilation
        ubyte allFlags;
    }
    else
    {
        union
        {
            import std.bitmanip : bitfields;
            mixin(bitfields!(
                        bool, "flDash", 1,
                        bool, "flZero", 1,
                        bool, "flSpace", 1,
                        bool, "flPlus", 1,
                        bool, "flHash", 1,
                        bool, "flEqual", 1,
                        bool, "flSeparator", 1,
                        ubyte, "", 1));
            ubyte allFlags;
        }
    }

    /// The inner format string of a nested format specifier.
    const(Char)[] nested;

    /**
       The separator of a nested format specifier.

       `null` means, there is no separator. `empty`, but not `null`,
       means zero length separator.
     */
    const(Char)[] sep;

    /// Contains the part of the format string, that has not yet been parsed.
    const(Char)[] trailing;

    /// Sequence `"["` inserted before each range or range like structure.
    enum immutable(Char)[] seqBefore = "[";

    /// Sequence `"]"` inserted after each range or range like structure.
    enum immutable(Char)[] seqAfter = "]";

    /**
       Sequence `":"` inserted between element key and element value of
       an associative array.
     */
    enum immutable(Char)[] keySeparator = ":";

    /**
       Sequence `", "` inserted between elements of a range, a range like
       structure or the elements of an associative array.
     */
    enum immutable(Char)[] seqSeparator = ", ";

    /**
       Creates a new `FormatSpec`.

       The string is lazily evaluated. That means, nothing is done,
       until $(LREF writeUpToNextSpec) is called.

       Params:
           fmt = a $(MREF_ALTTEXT format string, std,format)
     */
    this(in Char[] fmt) @safe pure
    {
        trailing = fmt;
    }

    /**
       Writes the format string to an output range until the next format
       specifier is found and parse that format specifier.

       See the $(MREF_ALTTEXT description of format strings, std,format) for more
       details about the format specifier.

       Params:
           writer = an $(REF_ALTTEXT output range, isOutputRange, std, range, primitives),
                    where the format string is written to
           OutputRange = type of the output range

       Returns:
           True, if a format specifier is found and false, if the end of the
           format string has been reached.

       Throws:
           A $(REF_ALTTEXT FormatException, FormatException, std,format)
           when parsing the format specifier did not succeed.
     */
    bool writeUpToNextSpec(OutputRange)(ref OutputRange writer) scope
    {
        import std.format : enforceFmt;

        if (trailing.empty)
            return false;
        for (size_t i = 0; i < trailing.length; ++i)
        {
            if (trailing[i] != '%') continue;
            put(writer, trailing[0 .. i]);
            trailing = trailing[i .. $];
            enforceFmt(trailing.length >= 2, `Unterminated format specifier: "%"`);
            trailing = trailing[1 .. $];

            if (trailing[0] != '%')
            {
                // Spec found. Fill up the spec, and bailout
                fillUp();
                return true;
            }
            // Doubled! Reset and Keep going
            i = 0;
        }
        // no format spec found
        put(writer, trailing);
        trailing = null;
        return false;
    }

    private void fillUp() scope
    {
        import std.format : enforceFmt, FormatException;

        // Reset content
        if (__ctfe)
        {
            flDash = false;
            flZero = false;
            flSpace = false;
            flPlus = false;
            flEqual = false;
            flHash = false;
            flSeparator = false;
        }
        else
        {
            allFlags = 0;
        }

        width = 0;
        precision = UNSPECIFIED;
        nested = null;
        // Parse the spec (we assume we're past '%' already)
        for (size_t i = 0; i < trailing.length; )
        {
            switch (trailing[i])
            {
            case '(':
                // Embedded format specifier.
                auto j = i + 1;
                // Get the matching balanced paren
                for (uint innerParens;;)
                {
                    enforceFmt(j + 1 < trailing.length,
                        text("Incorrect format specifier: %", trailing[i .. $]));
                    if (trailing[j++] != '%')
                    {
                        // skip, we're waiting for %( and %)
                        continue;
                    }
                    if (trailing[j] == '-') // for %-(
                    {
                        ++j;    // skip
                        enforceFmt(j < trailing.length,
                            text("Incorrect format specifier: %", trailing[i .. $]));
                    }
                    if (trailing[j] == ')')
                    {
                        if (innerParens-- == 0) break;
                    }
                    else if (trailing[j] == '|')
                    {
                        if (innerParens == 0) break;
                    }
                    else if (trailing[j] == '(')
                    {
                        ++innerParens;
                    }
                }
                if (trailing[j] == '|')
                {
                    auto k = j;
                    for (++j;;)
                    {
                        if (trailing[j++] != '%')
                            continue;
                        if (trailing[j] == '%')
                            ++j;
                        else if (trailing[j] == ')')
                            break;
                        else
                            throw new FormatException(
                                text("Incorrect format specifier: %",
                                        trailing[j .. $]));
                    }
                    nested = trailing[i + 1 .. k - 1];
                    sep = trailing[k + 1 .. j - 1];
                }
                else
                {
                    nested = trailing[i + 1 .. j - 1];
                    sep = null; // no separator
                }
                //this = FormatSpec(innerTrailingSpec);
                spec = '(';
                // We practically found the format specifier
                trailing = trailing[j + 1 .. $];
                return;
            case '-': flDash = true; ++i; break;
            case '+': flPlus = true; ++i; break;
            case '=': flEqual = true; ++i; break;
            case '#': flHash = true; ++i; break;
            case '0': flZero = true; ++i; break;
            case ' ': flSpace = true; ++i; break;
            case '*':
                if (isDigit(trailing[++i]))
                {
                    // a '*' followed by digits and '$' is a
                    // positional format
                    trailing = trailing[1 .. $];
                    width = -parse!(typeof(width))(trailing);
                    i = 0;
                    enforceFmt(trailing[i++] == '$',
                        text("$ expected after '*", -width, "' in format string"));
                }
                else
                {
                    // read result
                    width = DYNAMIC;
                }
                break;
            case '1': .. case '9':
                auto tmp = trailing[i .. $];
                const widthOrArgIndex = parse!uint(tmp);
                enforceFmt(tmp.length,
                    text("Incorrect format specifier %", trailing[i .. $]));
                i = trailing.length - tmp.length;
                if (tmp.startsWith('$'))
                {
                    // index of the form %n$
                    indexEnd = indexStart = to!ubyte(widthOrArgIndex);
                    ++i;
                }
                else if (tmp.startsWith(':'))
                {
                    // two indexes of the form %m:n$, or one index of the form %m:$
                    indexStart = to!ubyte(widthOrArgIndex);
                    tmp = tmp[1 .. $];
                    if (tmp.startsWith('$'))
                    {
                        indexEnd = indexEnd.max;
                    }
                    else
                    {
                        indexEnd = parse!(typeof(indexEnd))(tmp);
                    }
                    i = trailing.length - tmp.length;
                    enforceFmt(trailing[i++] == '$',
                        "$ expected");
                }
                else
                {
                    // width
                    width = to!int(widthOrArgIndex);
                }
                break;
            case ',':
                // Precision
                ++i;
                flSeparator = true;

                if (trailing[i] == '*')
                {
                    ++i;
                    // read result
                    separators = DYNAMIC;
                }
                else if (isDigit(trailing[i]))
                {
                    auto tmp = trailing[i .. $];
                    separators = parse!int(tmp);
                    i = trailing.length - tmp.length;
                }
                else
                {
                    // "," was specified, but nothing after it
                    separators = 3;
                }

                if (trailing[i] == '?')
                {
                    dynamicSeparatorChar = true;
                    ++i;
                }

                break;
            case '.':
                // Precision
                if (trailing[++i] == '*')
                {
                    if (isDigit(trailing[++i]))
                    {
                        // a '.*' followed by digits and '$' is a
                        // positional precision
                        trailing = trailing[i .. $];
                        i = 0;
                        precision = -parse!int(trailing);
                        enforceFmt(trailing[i++] == '$',
                            "$ expected");
                    }
                    else
                    {
                        // read result
                        precision = DYNAMIC;
                    }
                }
                else if (trailing[i] == '-')
                {
                    // negative precision, as good as 0
                    precision = 0;
                    auto tmp = trailing[i .. $];
                    parse!int(tmp); // skip digits
                    i = trailing.length - tmp.length;
                }
                else if (isDigit(trailing[i]))
                {
                    auto tmp = trailing[i .. $];
                    precision = parse!int(tmp);
                    i = trailing.length - tmp.length;
                }
                else
                {
                    // "." was specified, but nothing after it
                    precision = 0;
                }
                break;
            default:
                // this is the format char
                spec = cast(char) trailing[i++];
                trailing = trailing[i .. $];
                return;
            } // end switch
        } // end for
        throw new FormatException(text("Incorrect format specifier: ", trailing));
    }

    //--------------------------------------------------------------------------
    package bool readUpToNextSpec(R)(ref R r) scope
    {
        import std.ascii : isLower, isWhite;
        import std.format : enforceFmt;
        import std.utf : stride;

        // Reset content
        if (__ctfe)
        {
            flDash = false;
            flZero = false;
            flSpace = false;
            flPlus = false;
            flHash = false;
            flEqual = false;
            flSeparator = false;
        }
        else
        {
            allFlags = 0;
        }
        width = 0;
        precision = UNSPECIFIED;
        nested = null;
        // Parse the spec
        while (trailing.length)
        {
            const c = trailing[0];
            if (c == '%' && trailing.length > 1)
            {
                const c2 = trailing[1];
                if (c2 == '%')
                {
                    assert(!r.empty, "Required at least one more input");
                    // Require a '%'
                    enforceFmt (r.front == '%',
                        text("parseToFormatSpec: Cannot find character '",
                             c2, "' in the input string."));
                    trailing = trailing[2 .. $];
                    r.popFront();
                }
                else
                {
                    enforceFmt(isLower(c2) || c2 == '*' || c2 == '(',
                        text("'%", c2, "' not supported with formatted read"));
                    trailing = trailing[1 .. $];
                    fillUp();
                    return true;
                }
            }
            else
            {
                if (c == ' ')
                {
                    while (!r.empty && isWhite(r.front)) r.popFront();
                    //r = std.algorithm.find!(not!(isWhite))(r);
                }
                else
                {
                    enforceFmt(!r.empty && r.front == trailing.front,
                        text("parseToFormatSpec: Cannot find character '",
                             c, "' in the input string."));
                    r.popFront();
                }
                trailing = trailing[stride(trailing, 0) .. $];
            }
        }
        return false;
    }

    package string getCurFmtStr() const
    {
        import std.array : appender;
        import std.format.write : formatValue;

        auto w = appender!string();
        auto f = FormatSpec!Char("%s"); // for stringnize

        put(w, '%');
        if (indexStart != 0)
        {
            formatValue(w, indexStart, f);
            put(w, '$');
        }
        if (flDash) put(w, '-');
        if (flZero) put(w, '0');
        if (flSpace) put(w, ' ');
        if (flPlus) put(w, '+');
        if (flEqual) put(w, '=');
        if (flHash) put(w, '#');
        if (width != 0)
            formatValue(w, width, f);
        if (precision != FormatSpec!Char.UNSPECIFIED)
        {
            put(w, '.');
            formatValue(w, precision, f);
        }
        if (flSeparator) put(w, ',');
        if (separators != FormatSpec!Char.UNSPECIFIED)
            formatValue(w, separators, f);
        put(w, spec);
        return w.data;
    }

    /**
       Provides a string representation.

       Returns:
           The string representation.
     */
    string toString() const @safe pure
    {
        import std.array : appender;

        auto app = appender!string();
        app.reserve(200 + trailing.length);
        toString(app);
        return app.data;
    }

    /**
       Writes a string representation to an output range.

       Params:
           writer = an $(REF_ALTTEXT output range, isOutputRange, std, range, primitives),
                    where the representation is written to
           OutputRange = type of the output range
     */
    void toString(OutputRange)(ref OutputRange writer) const
    if (isOutputRange!(OutputRange, char))
    {
        import std.format.write : formatValue;

        auto s = singleSpec("%s");

        put(writer, "address = ");
        formatValue(writer, &this, s);
        put(writer, "\nwidth = ");
        formatValue(writer, width, s);
        put(writer, "\nprecision = ");
        formatValue(writer, precision, s);
        put(writer, "\nspec = ");
        formatValue(writer, spec, s);
        put(writer, "\nindexStart = ");
        formatValue(writer, indexStart, s);
        put(writer, "\nindexEnd = ");
        formatValue(writer, indexEnd, s);
        put(writer, "\nflDash = ");
        formatValue(writer, flDash, s);
        put(writer, "\nflZero = ");
        formatValue(writer, flZero, s);
        put(writer, "\nflSpace = ");
        formatValue(writer, flSpace, s);
        put(writer, "\nflPlus = ");
        formatValue(writer, flPlus, s);
        put(writer, "\nflEqual = ");
        formatValue(writer, flEqual, s);
        put(writer, "\nflHash = ");
        formatValue(writer, flHash, s);
        put(writer, "\nflSeparator = ");
        formatValue(writer, flSeparator, s);
        put(writer, "\nnested = ");
        formatValue(writer, nested, s);
        put(writer, "\ntrailing = ");
        formatValue(writer, trailing, s);
        put(writer, '\n');
    }
}

///
@safe pure unittest
{
    import std.array : appender;

    auto a = appender!(string)();
    auto fmt = "Number: %6.4e\nString: %s";
    auto f = FormatSpec!char(fmt);

    assert(f.writeUpToNextSpec(a) == true);

    assert(a.data == "Number: ");
    assert(f.trailing == "\nString: %s");
    assert(f.spec == 'e');
    assert(f.width == 6);
    assert(f.precision == 4);

    assert(f.writeUpToNextSpec(a) == true);

    assert(a.data == "Number: \nString: ");
    assert(f.trailing == "");
    assert(f.spec == 's');

    assert(f.writeUpToNextSpec(a) == false);

    assert(a.data == "Number: \nString: ");
}

@safe unittest
{
    import std.array : appender;
    import std.conv : text;
    import std.exception : assertThrown;
    import std.format : FormatException;

    auto w = appender!(char[])();
    auto f = FormatSpec!char("abc%sdef%sghi");
    f.writeUpToNextSpec(w);
    assert(w.data == "abc", w.data);
    assert(f.trailing == "def%sghi", text(f.trailing));
    f.writeUpToNextSpec(w);
    assert(w.data == "abcdef", w.data);
    assert(f.trailing == "ghi");
    // test with embedded %%s
    f = FormatSpec!char("ab%%cd%%ef%sg%%h%sij");
    w.clear();
    f.writeUpToNextSpec(w);
    assert(w.data == "ab%cd%ef" && f.trailing == "g%%h%sij", w.data);
    f.writeUpToNextSpec(w);
    assert(w.data == "ab%cd%efg%h" && f.trailing == "ij");
    // https://issues.dlang.org/show_bug.cgi?id=4775
    f = FormatSpec!char("%%%s");
    w.clear();
    f.writeUpToNextSpec(w);
    assert(w.data == "%" && f.trailing == "");
    f = FormatSpec!char("%%%%%s%%");
    w.clear();
    while (f.writeUpToNextSpec(w)) continue;
    assert(w.data == "%%%");

    f = FormatSpec!char("a%%b%%c%");
    w.clear();
    assertThrown!FormatException(f.writeUpToNextSpec(w));
    assert(w.data == "a%b%c" && f.trailing == "%");
}

// https://issues.dlang.org/show_bug.cgi?id=5237
@safe unittest
{
    import std.array : appender;

    auto w = appender!string();
    auto f = FormatSpec!char("%.16f");
    f.writeUpToNextSpec(w); // dummy eating
    assert(f.spec == 'f');
    auto fmt = f.getCurFmtStr();
    assert(fmt == "%.16f");
}

// https://issues.dlang.org/show_bug.cgi?id=14059
@safe unittest
{
    import std.array : appender;
    import std.exception : assertThrown;
    import std.format : FormatException;

    auto a = appender!(string)();

    auto f = FormatSpec!char("%-(%s%"); // %)")
    assertThrown!FormatException(f.writeUpToNextSpec(a));

    f = FormatSpec!char("%(%-"); // %)")
    assertThrown!FormatException(f.writeUpToNextSpec(a));
}

@safe unittest
{
    import std.array : appender;
    import std.format : format;

    auto a = appender!(string)();

    auto f = FormatSpec!char("%,d");
    f.writeUpToNextSpec(a);

    assert(f.spec == 'd', format("%s", f.spec));
    assert(f.precision == FormatSpec!char.UNSPECIFIED);
    assert(f.separators == 3);

    f = FormatSpec!char("%5,10f");
    f.writeUpToNextSpec(a);
    assert(f.spec == 'f', format("%s", f.spec));
    assert(f.separators == 10);
    assert(f.width == 5);

    f = FormatSpec!char("%5,10.4f");
    f.writeUpToNextSpec(a);
    assert(f.spec == 'f', format("%s", f.spec));
    assert(f.separators == 10);
    assert(f.width == 5);
    assert(f.precision == 4);
}

@safe pure unittest
{
    import std.algorithm.searching : canFind, findSplitBefore;

    auto expected = "width = 2" ~
        "\nprecision = 5" ~
        "\nspec = f" ~
        "\nindexStart = 0" ~
        "\nindexEnd = 0" ~
        "\nflDash = false" ~
        "\nflZero = false" ~
        "\nflSpace = false" ~
        "\nflPlus = false" ~
        "\nflEqual = false" ~
        "\nflHash = false" ~
        "\nflSeparator = false" ~
        "\nnested = " ~
        "\ntrailing = \n";
    auto spec = singleSpec("%2.5f");
    auto res = spec.toString();
    // make sure the address exists, then skip it
    assert(res.canFind("address"));
    assert(res.findSplitBefore("width")[1] == expected);
}

// https://issues.dlang.org/show_bug.cgi?id=15348
@safe pure unittest
{
    import std.array : appender;
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;

    auto w = appender!(char[])();
    auto f = FormatSpec!char("%*10d");

    assert(collectExceptionMsg!FormatException(f.writeUpToNextSpec(w))
           == "$ expected after '*10' in format string");
}

/**
Helper function that returns a `FormatSpec` for a single format specifier.

Params:
    fmt = a $(MREF_ALTTEXT format string, std,format)
          containing a single format specifier
    Char = character type of `fmt`

Returns:
    A $(LREF FormatSpec) with the format specifier parsed.

Throws:
    A $(REF_ALTTEXT FormatException, FormatException, std,format) when the
    format string contains no format specifier or more than a single format
    specifier or when the format specifier is malformed.
  */
FormatSpec!Char singleSpec(Char)(Char[] fmt)
{
    import std.conv : text;
    import std.format : enforceFmt;
    import std.range.primitives : empty, front;

    enforceFmt(fmt.length >= 2, "fmt must be at least 2 characters long");
    enforceFmt(fmt.front == '%', "fmt must start with a '%' character");
    enforceFmt(fmt[1] != '%', "'%%' is not a permissible format specifier");

    static struct DummyOutputRange
    {
        void put(C)(scope const C[] buf) {} // eat elements
    }
    auto a = DummyOutputRange();
    auto spec = FormatSpec!Char(fmt);
    //dummy write
    spec.writeUpToNextSpec(a);

    enforceFmt(spec.trailing.empty,
        text("Trailing characters in fmt string: '", spec.trailing));

    return spec;
}

///
@safe pure unittest
{
    import std.array : appender;
    import std.format.write : formatValue;

    auto spec = singleSpec("%10.3e");
    auto writer = appender!string();
    writer.formatValue(42.0, spec);

    assert(writer.data == " 4.200e+01");
}

@safe pure unittest
{
    import std.exception : assertThrown;
    import std.format : FormatException;

    auto spec = singleSpec("%2.3e");

    assert(spec.trailing == "");
    assert(spec.spec == 'e');
    assert(spec.width == 2);
    assert(spec.precision == 3);

    assertThrown!FormatException(singleSpec(""));
    assertThrown!FormatException(singleSpec("%"));
    assertThrown!FormatException(singleSpec("%2.3"));
    assertThrown!FormatException(singleSpec("2.3e"));
    assertThrown!FormatException(singleSpec("Test%2.3e"));
    assertThrown!FormatException(singleSpec("%2.3eTest"));
    assertThrown!FormatException(singleSpec("%%"));
}

// @@@DEPRECATED_[2.107.0]@@@
deprecated("enforceValidFormatSpec was accidentally made public and will be removed in 2.107.0")
void enforceValidFormatSpec(T, Char)(scope const ref FormatSpec!Char f)
{
    import std.format.internal.write : evfs = enforceValidFormatSpec;

    evfs!T(f);
}

@safe unittest
{
    import std.exception : collectExceptionMsg;
    import std.format : format, FormatException;

    // width/precision
    assert(collectExceptionMsg!FormatException(format("%*.d", 5.1, 2))
        == "integer width expected, not double for argument #1");
    assert(collectExceptionMsg!FormatException(format("%-1*.d", 5.1, 2))
        == "integer width expected, not double for argument #1");

    assert(collectExceptionMsg!FormatException(format("%.*d", '5', 2))
        == "integer precision expected, not char for argument #1");
    assert(collectExceptionMsg!FormatException(format("%-1.*d", 4.7, 3))
        == "integer precision expected, not double for argument #1");
    assert(collectExceptionMsg!FormatException(format("%.*d", 5))
        == "Orphan format specifier: %d");
    assert(collectExceptionMsg!FormatException(format("%*.*d", 5))
        == "Missing integer precision argument");

    // dynamicSeparatorChar
    assert(collectExceptionMsg!FormatException(format("%,?d", 5))
        == "separator character expected, not int for argument #1");
    assert(collectExceptionMsg!FormatException(format("%,?d", '?'))
        == "Orphan format specifier: %d");
    assert(collectExceptionMsg!FormatException(format("%.*,*?d", 5))
        == "Missing separator digit width argument");
}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // Written in the D programming language.

/**
This is a submodule of $(MREF std, format).

It provides two functions for writing formatted output: $(LREF
formatValue) and $(LREF formattedWrite). The former writes a single
value. The latter writes several values at once, interspersed with
unformatted text.

The following combinations of format characters and types are
available:

$(BOOKTABLE ,
$(TR $(TH) $(TH s) $(TH c) $(TH d, u, b, o) $(TH x, X) $(TH e, E, f, F, g, G, a, A) $(TH r) $(TH compound))
$(TR $(TD `bool`) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)))
$(TR $(TD `null`) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)))
$(TR $(TD $(I integer)) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD yes) $(TD yes) $(TD yes) $(TD $(MDASH)))
$(TR $(TD $(I floating point)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes) $(TD $(MDASH)))
$(TR $(TD $(I character)) $(TD yes) $(TD yes) $(TD yes) $(TD yes) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)))
$(TR $(TD $(I string)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes))
$(TR $(TD $(I array)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes))
$(TR $(TD $(I associative array)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes))
$(TR $(TD $(I pointer)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)))
$(TR $(TD $(I SIMD vectors)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes))
$(TR $(TD $(I delegates)) $(TD yes) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD $(MDASH)) $(TD yes) $(TD yes))
)

Enums can be used with all format characters of the base type.

$(SECTION3 Structs$(COMMA) Unions$(COMMA) Classes$(COMMA) and Interfaces)

Aggregate types can define various `toString` functions. If this
function takes a $(REF_ALTTEXT FormatSpec, FormatSpec, std, format,
spec) or a $(I format string) as argument, the function decides
which format characters are accepted. If no `toString` is defined and
the aggregate is an $(REF_ALTTEXT input range, isInputRange, std,
range, primitives), it is treated like a range, that is $(B 's'), $(B
'r') and a compound specifier are accepted. In all other cases
aggregate types only accept $(B 's').

`toString` should have one of the following signatures:

---
void toString(Writer, Char)(ref Writer w, const ref FormatSpec!Char fmt)
void toString(Writer)(ref Writer w)
string toString();
---

Where `Writer` is an $(REF_ALTTEXT output range, isOutputRange,
std,range,primitives) which accepts characters $(LPAREN)of type
`Char` in the first version$(RPAREN). The template type does not have
to be called `Writer`.

Sometimes it's not possible to use a template, for example when
`toString` overrides `Object.toString`. In this case, the following
$(LPAREN)slower and less flexible$(RPAREN) functions can be used:

---
void toString(void delegate(const(char)[]) sink, const ref FormatSpec!char fmt);
void toString(void delegate(const(char)[]) sink, string fmt);
void toString(void delegate(const(char)[]) sink);
---

When several of the above `toString` versions are available, the
versions with `Writer` take precedence over the versions with a
`sink`. `string toString()` has the lowest priority.

If none of the above mentioned `toString` versions are available, the
aggregates will be formatted by other means, in the following
order:

If an aggregate is an $(REF_ALTTEXT input range, isInputRange, std,
range, primitives), it is formatted like an input range.

If an aggregate is a builtin type (using `alias this`), it is formatted
like the builtin type.

If all else fails, structs are formatted like `Type(field1, field2, ...)`,
classes and interfaces are formatted with their fully qualified name
and unions with their base name.

Copyright: Copyright The D Language Foundation 2000-2013.

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: $(HTTP walterbright.com, Walter Bright), $(HTTP erdani.com,
Andrei Alexandrescu), and Kenji Hara

Source: $(PHOBOSSRC std/format/write.d)
 */
module std.format.write;

/**
`bool`s are formatted as `"true"` or `"false"` with `%s` and like the
`byte`s 1 and 0 with all other format characters.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    formatValue(w1, true, spec1);

    assert(w1.data == "true");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%#x");
    formatValue(w2, true, spec2);

    assert(w2.data == "0x1");
}

/// The `null` literal is formatted as `"null"`.
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w = appender!string();
    auto spec = singleSpec("%s");
    formatValue(w, null, spec);

    assert(w.data == "null");
}

/**
Integrals are formatted in (signed) every day notation with `%s` and
`%d` and as an (unsigned) image of the underlying bit representation
with `%b` (binary), `%u` (decimal), `%o` (octal), and `%x` (hexadecimal).
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%d");
    formatValue(w1, -1337, spec1);

    assert(w1.data == "-1337");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%x");
    formatValue(w2, -1337, spec2);

    assert(w2.data == "fffffac7");
}

/**
Floating-point values are formatted in natural notation with `%f`, in
scientific notation with `%e`, in short notation with `%g`, and in
hexadecimal scientific notation with `%a`. If a rounding mode is
available, they are rounded according to this rounding mode, otherwise
they are rounded to the nearest value, ties to even.
 */
@safe unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%.3f");
    formatValue(w1, 1337.7779, spec1);

    assert(w1.data == "1337.778");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%.3e");
    formatValue(w2, 1337.7779, spec2);

    assert(w2.data == "1.338e+03");

    auto w3 = appender!string();
    auto spec3 = singleSpec("%.3g");
    formatValue(w3, 1337.7779, spec3);

    assert(w3.data == "1.34e+03");

    auto w4 = appender!string();
    auto spec4 = singleSpec("%.3a");
    formatValue(w4, 1337.7779, spec4);

    assert(w4.data == "0x1.4e7p+10");
}

/**
Individual characters (`char`, `wchar`, or `dchar`) are formatted as
Unicode characters with `%s` and `%c` and as integers (`ubyte`,
`ushort`, `uint`) with all other format characters. With
$(MREF_ALTTEXT compound specifiers, std,format) characters are
treated differently.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%c");
    formatValue(w1, 'ì', spec1);

    assert(w1.data == "ì");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%#x");
    formatValue(w2, 'ì', spec2);

    assert(w2.data == "0xec");
}

/**
Strings are formatted as a sequence of characters with `%s`.
Non-printable characters are not escaped. With a compound specifier
the string is treated like a range of characters. With $(MREF_ALTTEXT
compound specifiers, std,format) strings are treated differently.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    formatValue(w1, "hello", spec1);

    assert(w1.data == "hello");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%(%#x%|/%)");
    formatValue(w2, "hello", spec2);

    assert(w2.data == "0x68/0x65/0x6c/0x6c/0x6f");
}

/// Static arrays are formatted as dynamic arrays.
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w = appender!string();
    auto spec = singleSpec("%s");
    int[2] two = [1, 2];
    formatValue(w, two, spec);

    assert(w.data == "[1, 2]");
}

/**
Dynamic arrays are formatted as input ranges.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    auto two = [1, 2];
    formatValue(w1, two, spec1);

    assert(w1.data == "[1, 2]");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%(%g%|, %)");
    auto consts = [3.1415926, 299792458, 6.67430e-11];
    formatValue(w2, consts, spec2);

    assert(w2.data == "3.14159, 2.99792e+08, 6.6743e-11");

    // void[] is treated like ubyte[]
    auto w3 = appender!string();
    auto spec3 = singleSpec("%s");
    void[] val = cast(void[]) cast(ubyte[])[1, 2, 3];
    formatValue(w3, val, spec3);

    assert(w3.data == "[1, 2, 3]");
}

/**
Associative arrays are formatted by using `':'` and `", "` as
separators, enclosed by `'['` and `']'` when used with `%s`. It's
also possible to use a compound specifier for better control.

Please note, that the order of the elements is not defined, therefore
the result of this function might differ.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto aa = [10:17.5, 20:9.99];

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    formatValue(w1, aa, spec1);

    assert(w1.data == "[10:17.5, 20:9.99]" || w1.data == "[20:9.99, 10:17.5]");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%(%x = %.0e%| # %)");
    formatValue(w2, aa, spec2);

    assert(w2.data == "a = 2e+01 # 14 = 1e+01" || w2.data == "14 = 1e+01 # a = 2e+01");
}

/**
`enum`s are formatted as their name when used with `%s` and like
their base value else.
 */
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    enum A { first, second, third }

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    formatValue(w1, A.second, spec1);

    assert(w1.data == "second");

    auto w2 = appender!string();
    auto spec2 = singleSpec("%d");
    formatValue(w2, A.second, spec2);

    assert(w2.data == "1");

    // values of an enum that have no name are formatted with %s using a cast
    A a = A.third;
    a++;

    auto w3 = appender!string();
    auto spec3 = singleSpec("%s");
    formatValue(w3, a, spec3);

    assert(w3.data == "cast(A)3");
}

/**
`structs`, `unions`, `classes` and `interfaces` can be formatted in
several different ways. The following example highlights `struct`
formatting, however, it applies to other aggregates as well.
 */
@safe unittest
{
    import std.array : appender;
    import std.format.spec : FormatSpec, singleSpec;

    // Using a `toString` with a writer
    static struct Point1
    {
        import std.range.primitives : isOutputRange, put;

        int x, y;

        void toString(W)(ref W writer, scope const ref FormatSpec!char f)
        if (isOutputRange!(W, char))
        {
            put(writer, "(");
            formatValue(writer, x, f);
            put(writer, ",");
            formatValue(writer, y, f);
            put(writer, ")");
        }
    }

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    auto p1 = Point1(16, 11);

    formatValue(w1, p1, spec1);
    assert(w1.data == "(16,11)");

    // Using a `toString` with a sink
    static struct Point2
    {
        int x, y;

        void toString(scope void delegate(scope const(char)[]) @safe sink,
                      scope const FormatSpec!char fmt) const
        {
            sink("(");
            sink.formatValue(x, fmt);
            sink(",");
            sink.formatValue(y, fmt);
            sink(")");
        }
    }

    auto w2 = appender!string();
    auto spec2 = singleSpec("%03d");
    auto p2 = Point2(16,11);

    formatValue(w2, p2, spec2);
    assert(w2.data == "(016,011)");

    // Using `string toString()`
    static struct Point3
    {
        int x, y;

        string toString()
        {
            import std.conv : to;

            return "(" ~ to!string(x) ~ "," ~ to!string(y) ~ ")";
        }
    }

    auto w3 = appender!string();
    auto spec3 = singleSpec("%s"); // has to be %s
    auto p3 = Point3(16,11);

    formatValue(w3, p3, spec3);
    assert(w3.data == "(16,11)");

    // without `toString`
    static struct Point4
    {
        int x, y;
    }

    auto w4 = appender!string();
    auto spec4 = singleSpec("%s"); // has to be %s
    auto p4 = Point4(16,11);

    formatValue(w4, p4, spec3);
    assert(w4.data == "Point4(16, 11)");
}

/// Pointers are formatted as hexadecimal integers.
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w1 = appender!string();
    auto spec1 = singleSpec("%s");
    auto p1 = () @trusted { return cast(void*) 0xFFEECCAA; } ();
    formatValue(w1, p1, spec1);

    assert(w1.data == "FFEECCAA");

    // null pointers are printed as `"null"` when used with `%s` and as hexadecimal integer else
    auto w2 = appender!string();
    auto spec2 = singleSpec("%s");
    auto p2 = () @trusted { return cast(void*) 0x00000000; } ();
    formatValue(w2, p2, spec2);

    assert(w2.data == "null");

    auto w3 = appender!string();
    auto spec3 = singleSpec("%x");
    formatValue(w3, p2, spec3);

    assert(w3.data == "0");
}

/// SIMD vectors are formatted as arrays.
@safe unittest
{
    import core.simd; // cannot be selective, because float4 might not be defined
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto w = appender!string();
    auto spec = singleSpec("%s");

    static if (is(float4))
    {
        version (X86) {}
        else
        {
            float4 f4;
            f4.array[0] = 1;
            f4.array[1] = 2;
            f4.array[2] = 3;
            f4.array[3] = 4;

            formatValue(w, f4, spec);
            assert(w.data == "[1, 2, 3, 4]");
        }
    }
}

import std.format.internal.write;

import std.format.spec : FormatSpec;
import std.traits : isSomeString;

/**
Converts its arguments according to a format string and writes
the result to an output range.

The second version of `formattedWrite` takes the format string as a
template argument. In this case, it is checked for consistency at
compile-time.

Params:
    w = an $(REF_ALTTEXT output range, isOutputRange, std, range, primitives),
        where the formatted result is written to
    fmt = a $(MREF_ALTTEXT format string, std,format)
    args = a variadic list of arguments to be formatted
    Writer = the type of the writer `w`
    Char = character type of `fmt`
    Args = a variadic list of types of the arguments

Returns:
    The index of the last argument that was formatted. If no positional
    arguments are used, this is the number of arguments that where formatted.

Throws:
    A $(REF_ALTTEXT FormatException, FormatException, std, format)
    if formatting did not succeed.

Note:
    In theory this function should be `@nogc`. But with the current
    implementation there are some cases where allocations occur.
    See $(REF_ALTTEXT $(D sformat), sformat, std, format) for more details.
 */
uint formattedWrite(Writer, Char, Args...)(auto ref Writer w, const scope Char[] fmt, Args args)
{
    import std.conv : text;
    import std.format : enforceFmt, FormatException;
    import std.traits : isSomeChar;

    auto spec = FormatSpec!Char(fmt);

    // Are we already done with formats? Then just dump each parameter in turn
    uint currentArg = 0;
    while (spec.writeUpToNextSpec(w))
    {
        if (currentArg == Args.length && !spec.indexStart)
        {
            // leftover spec?
            enforceFmt(fmt.length == 0,
                text("Orphan format specifier: %", spec.spec));
            break;
        }

        if (spec.width == spec.DYNAMIC)
        {
            auto width = getNthInt!"integer width"(currentArg, args);
            if (width < 0)
            {
                spec.flDash = true;
                width = -width;
            }
            spec.width = width;
            ++currentArg;
        }
        else if (spec.width < 0)
        {
            // means: get width as a positional parameter
            auto index = cast(uint) -spec.width;
            assert(index > 0, "The index must be greater than zero");
            auto width = getNthInt!"integer width"(index - 1, args);
            if (currentArg < index) currentArg = index;
            if (width < 0)
            {
                spec.flDash = true;
                width = -width;
            }
            spec.width = width;
        }

        if (spec.precision == spec.DYNAMIC)
        {
            auto precision = getNthInt!"integer precision"(currentArg, args);
            if (precision >= 0) spec.precision = precision;
            // else negative precision is same as no precision
            else spec.precision = spec.UNSPECIFIED;
            ++currentArg;
        }
        else if (spec.precision < 0)
        {
            // means: get precision as a positional parameter
            auto index = cast(uint) -spec.precision;
            assert(index > 0, "The precision must be greater than zero");
            auto precision = getNthInt!"integer precision"(index- 1, args);
            if (currentArg < index) currentArg = index;
            if (precision >= 0) spec.precision = precision;
            // else negative precision is same as no precision
            else spec.precision = spec.UNSPECIFIED;
        }

        if (spec.separators == spec.DYNAMIC)
        {
            auto separators = getNthInt!"separator digit width"(currentArg, args);
            spec.separators = separators;
            ++currentArg;
        }

        if (spec.dynamicSeparatorChar)
        {
            auto separatorChar =
                getNth!("separator character", isSomeChar, dchar)(currentArg, args);
            spec.separatorChar = separatorChar;
            spec.dynamicSeparatorChar = false;
            ++currentArg;
        }

        if (currentArg == Args.length && !spec.indexStart)
        {
            // leftover spec?
            enforceFmt(fmt.length == 0,
                text("Orphan format specifier: %", spec.spec));
            break;
        }

        // Format an argument
        // This switch uses a static foreach to generate a jump table.
        // Currently `spec.indexStart` use the special value '0' to signal
        // we should use the current argument. An enhancement would be to
        // always store the index.
        size_t index = currentArg;
        if (spec.indexStart != 0)
            index = spec.indexStart - 1;
        else
            ++currentArg;
    SWITCH: switch (index)
        {
            foreach (i, Tunused; Args)
            {
            case i:
                formatValue(w, args[i], spec);
                if (currentArg < spec.indexEnd)
                    currentArg = spec.indexEnd;
                // A little know feature of format is to format a range
                // of arguments, e.g. `%1:3$` will format the first 3
                // arguments. Since they have to be consecutive we can
                // just use explicit fallthrough to cover that case.
                if (i + 1 < spec.indexEnd)
                {
                    // You cannot goto case if the next case is the default
                    static if (i + 1 < Args.length)
                        goto case;
                    else
                        goto default;
                }
                else
                    break SWITCH;
            }
        default:
            throw new FormatException(
                text("Positional specifier %", spec.indexStart, '$', spec.spec,
                     " index exceeds ", Args.length));
        }
    }
    return currentArg;
}

///
@safe pure unittest
{
    import std.array : appender;

    auto writer1 = appender!string();
    formattedWrite(writer1, "%s is the ultimate %s.", 42, "answer");
    assert(writer1[] == "42 is the ultimate answer.");

    auto writer2 = appender!string();
    formattedWrite(writer2, "Increase: %7.2f %%", 17.4285);
    assert(writer2[] == "Increase:   17.43 %");
}

/// ditto
uint formattedWrite(alias fmt, Writer, Args...)(auto ref Writer w, Args args)
if (isSomeString!(typeof(fmt)))
{
    import std.format : checkFormatException;

    alias e = checkFormatException!(fmt, Args);
    static assert(!e, e);
    return .formattedWrite(w, fmt, args);
}

/// The format string can be checked at compile-time:
@safe pure unittest
{
    import std.array : appender;

    auto writer = appender!string();
    writer.formattedWrite!"%d is the ultimate %s."(42, "answer");
    assert(writer[] == "42 is the ultimate answer.");

    // This line doesn't compile, because 3.14 cannot be formatted with %d:
    // writer.formattedWrite!"%d is the ultimate %s."(3.14, "answer");
}

@safe pure unittest
{
    import std.array : appender;

    auto stream = appender!string();
    formattedWrite(stream, "%s", 1.1);
    assert(stream.data == "1.1", stream.data);
}

@safe pure unittest
{
    import std.array;

    auto w = appender!string();
    formattedWrite(w, "%s %d", "@safe/pure", 42);
    assert(w.data == "@safe/pure 42");
}

@safe pure unittest
{
    char[20] buf;
    auto w = buf[];
    formattedWrite(w, "%s %d", "@safe/pure", 42);
    assert(buf[0 .. $ - w.length] == "@safe/pure 42");
}

@safe pure unittest
{
    import std.algorithm.iteration : map;
    import std.array : appender;

    auto stream = appender!string();
    formattedWrite(stream, "%s", map!"a*a"([2, 3, 5]));
    assert(stream.data == "[4, 9, 25]", stream.data);

    // Test shared data.
    stream = appender!string();
    shared int s = 6;
    formattedWrite(stream, "%s", s);
    assert(stream.data == "6");
}

@safe pure unittest
{
    // testing positional parameters
    import std.array : appender;
    import std.exception : collectExceptionMsg;
    import std.format : FormatException;

    auto w = appender!(char[])();
    formattedWrite(w,
            "Numbers %2$s and %1$s are reversed and %1$s%2$s repeated",
            42, 0);
    assert(w.data == "Numbers 0 and 42 are reversed and 420 repeated",
            w.data);
    assert(collectExceptionMsg!FormatException(formattedWrite(w, "%1$s, %3$s", 1, 2))
        == "Positional specifier %3$s index exceeds 2");

    w.clear();
    formattedWrite(w, "asd%s", 23);
    assert(w.data == "asd23", w.data);
    w.clear();
    formattedWrite(w, "%s%s", 23, 45);
    assert(w.data == "2345", w.data);
}

// https://issues.dlang.org/show_bug.cgi?id=3479
@safe unittest
{
    import std.array : appender;

    auto stream = appender!(char[])();
    formattedWrite(stream, "%2$.*1$d", 12, 10);
    assert(stream.data == "000000000010", stream.data);
}

// https://issues.dlang.org/show_bug.cgi?id=6893
@safe unittest
{
    import std.array : appender;

    enum E : ulong { A, B, C }
    auto stream = appender!(char[])();
    formattedWrite(stream, "%s", E.C);
    assert(stream.data == "C");
}

@safe pure unittest
{
    import std.array : appender;

    auto stream = appender!string();
    formattedWrite(stream, "%u", 42);
    assert(stream.data == "42", stream.data);
}

@safe pure unittest
{
    // testing raw writes
    import std.array : appender;

    auto w = appender!(char[])();
    uint a = 0x02030405;
    formattedWrite(w, "%+r", a);
    assert(w.data.length == 4 && w.data[0] == 2 && w.data[1] == 3
        && w.data[2] == 4 && w.data[3] == 5);

    w.clear();
    formattedWrite(w, "%-r", a);
    assert(w.data.length == 4 && w.data[0] == 5 && w.data[1] == 4
        && w.data[2] == 3 && w.data[3] == 2);
}

@safe unittest
{
    import std.array : appender;
    import std.conv : text, octal;

    auto stream = appender!(char[])();

    formattedWrite(stream, "hello world! %s %s ", true, 57, 1_000_000_000, 'x', " foo");
    assert(stream.data == "hello world! true 57 ", stream.data);
    stream.clear();

    formattedWrite(stream, "%g %A %s", 1.67, -1.28, float.nan);
    assert(stream.data == "1.67 -0X1.47AE147AE147BP+0 nan", stream.data);
    stream.clear();

    formattedWrite(stream, "%x %X", 0x1234AF, 0xAFAFAFAF);
    assert(stream.data == "1234af AFAFAFAF");
    stream.clear();

    formattedWrite(stream, "%b %o", 0x1234AF, 0xAFAFAFAF);
    assert(stream.data == "100100011010010101111 25753727657");
    stream.clear();

    formattedWrite(stream, "%d %s", 0x1234AF, 0xAFAFAFAF);
    assert(stream.data == "1193135 2947526575");
    stream.clear();

    formattedWrite(stream, "%a %A", 1.32, 6.78f);
    assert(stream.data == "0x1.51eb851eb851fp+0 0X1.B1EB86P+2");
    stream.clear();

    formattedWrite(stream, "%#06.*f", 2, 12.345);
    assert(stream.data == "012.35");
    stream.clear();

    formattedWrite(stream, "%#0*.*f", 6, 2, 12.345);
    assert(stream.data == "012.35");
    stream.clear();

    const real constreal = 1;
    formattedWrite(stream, "%g",constreal);
    assert(stream.data == "1");
    stream.clear();

    formattedWrite(stream, "%7.4g:", 12.678);
    assert(stream.data == "  12.68:");
    stream.clear();

    formattedWrite(stream, "%7.4g:", 12.678L);
    assert(stream.data == "  12.68:");
    stream.clear();

    formattedWrite(stream, "%04f|%05d|%#05x|%#5x", -4.0, -10, 1, 1);
    assert(stream.data == "-4.000000|-0010|0x001|  0x1", stream.data);
    stream.clear();

    int i;
    string s;

    i = -10;
    formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(stream.data == "-10|-10|-10|-10|-10.0000");
    stream.clear();

    i = -5;
    formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(stream.data == "-5| -5|-05|-5|-5.0000");
    stream.clear();

    i = 0;
    formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(stream.data == "0|  0|000|0|0.0000");
    stream.clear();

    i = 5;
    formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(stream.data == "5|  5|005|5|5.0000");
    stream.clear();

    i = 10;
    formattedWrite(stream, "%d|%3d|%03d|%1d|%01.4f", i, i, i, i, cast(double) i);
    assert(stream.data == "10| 10|010|10|10.0000");
    stream.clear();

    formattedWrite(stream, "%.0d", 0);
    assert(stream.data == "0");
    stream.clear();

    formattedWrite(stream, "%.g", .34);
    assert(stream.data == "0.3");
    stream.clear();

    stream.clear();
    formattedWrite(stream, "%.0g", .34);
    assert(stream.data == "0.3");

    stream.clear();
    formattedWrite(stream, "%.2g", .34);
    assert(stream.data == "0.34");

    stream.clear();
    formattedWrite(stream, "%0.0008f", 1e-08);
    assert(stream.data == "0.00000001");

    stream.clear();
    formattedWrite(stream, "%0.0008f", 1e-05);
    assert(stream.data == "0.00001000");

    s = "helloworld";
    string r;
    stream.clear();
    formattedWrite(stream, "%.2s", s[0 .. 5]);
    assert(stream.data == "he");
    stream.clear();
    formattedWrite(stream, "%.20s", s[0 .. 5]);
    assert(stream.data == "hello");
    stream.clear();
    formattedWrite(stream, "%8s", s[0 .. 5]);
    assert(stream.data == "   hello");

    byte[] arrbyte = new byte[4];
    arrbyte[0] = 100;
    arrbyte[1] = -99;
    arrbyte[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrbyte);
    assert(stream.data == "[100, -99, 0, 0]", stream.data);

    ubyte[] arrubyte = new ubyte[4];
    arrubyte[0] = 100;
    arrubyte[1] = 200;
    arrubyte[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrubyte);
    assert(stream.data == "[100, 200, 0, 0]", stream.data);

    short[] arrshort = new short[4];
    arrshort[0] = 100;
    arrshort[1] = -999;
    arrshort[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrshort);
    assert(stream.data == "[100, -999, 0, 0]");
    stream.clear();
    formattedWrite(stream, "%s", arrshort);
    assert(stream.data == "[100, -999, 0, 0]");

    ushort[] arrushort = new ushort[4];
    arrushort[0] = 100;
    arrushort[1] = 20_000;
    arrushort[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrushort);
    assert(stream.data == "[100, 20000, 0, 0]");

    int[] arrint = new int[4];
    arrint[0] = 100;
    arrint[1] = -999;
    arrint[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrint);
    assert(stream.data == "[100, -999, 0, 0]");
    stream.clear();
    formattedWrite(stream, "%s", arrint);
    assert(stream.data == "[100, -999, 0, 0]");

    long[] arrlong = new long[4];
    arrlong[0] = 100;
    arrlong[1] = -999;
    arrlong[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrlong);
    assert(stream.data == "[100, -999, 0, 0]");
    stream.clear();
    formattedWrite(stream, "%s",arrlong);
    assert(stream.data == "[100, -999, 0, 0]");

    ulong[] arrulong = new ulong[4];
    arrulong[0] = 100;
    arrulong[1] = 999;
    arrulong[3] = 0;
    stream.clear();
    formattedWrite(stream, "%s", arrulong);
    assert(stream.data == "[100, 999, 0, 0]");

    string[] arr2 = new string[4];
    arr2[0] = "hello";
    arr2[1] = "world";
    arr2[3] = "foo";
    stream.clear();
    formattedWrite(stream, "%s", arr2);
    assert(stream.data == `["hello", "world", "", "foo"]`, stream.data);

    stream.clear();
    formattedWrite(stream, "%.8d", 7);
    assert(stream.data == "00000007");

    stream.clear();
    formattedWrite(stream, "%.8x", 10);
    assert(stream.data == "0000000a");

    stream.clear();
    formattedWrite(stream, "%-3d", 7);
    assert(stream.data == "7  ");

    stream.clear();
    formattedWrite(stream, "%*d", -3, 7);
    assert(stream.data == "7  ");

    stream.clear();
    formattedWrite(stream, "%.*d", -3, 7);
    assert(stream.data == "7");

    stream.clear();
    formattedWrite(stream, "%s", "abc"c);
    assert(stream.data == "abc");
    stream.clear();
    formattedWrite(stream, "%s", "def"w);
    assert(stream.data == "def", text(stream.data.length));
    stream.clear();
    formattedWrite(stream, "%s", "ghi"d);
    assert(stream.data == "ghi");

    @trusted void* deadBeef() { return cast(void*) 0xDEADBEEF; }
    stream.clear();
    formattedWrite(stream, "%s", deadBeef());
    assert(stream.data == "DEADBEEF", stream.data);

    stream.clear();
    formattedWrite(stream, "%#x", 0xabcd);
    assert(stream.data == "0xabcd");
    stream.clear();
    formattedWrite(stream, "%#X", 0xABCD);
    assert(stream.data == "0XABCD");

    stream.clear();
    formattedWrite(stream, "%#o", octal!12345);
    assert(stream.data == "012345");
    stream.clear();
    formattedWrite(stream, "%o", 9);
    assert(stream.data == "11");

    stream.clear();
    formattedWrite(stream, "%+d", 123);
    assert(stream.data == "+123");
    stream.clear();
    formattedWrite(stream, "%+d", -123);
    assert(stream.data == "-123");
    stream.clear();
    formattedWrite(stream, "% d", 123);
    assert(stream.data == " 123");
    stream.clear();
    formattedWrite(stream, "% d", -123);
    assert(stream.data == "-123");

    stream.clear();
    formattedWrite(stream, "%%");
    assert(stream.data == "%");

    stream.clear();
    formattedWrite(stream, "%d", true);
    assert(stream.data == "1");
    stream.clear();
    formattedWrite(stream, "%d", false);
    assert(stream.data == "0");

    stream.clear();
    formattedWrite(stream, "%d", 'a');
    assert(stream.data == "97", stream.data);
    wchar wc = 'a';
    stream.clear();
    formattedWrite(stream, "%d", wc);
    assert(stream.data == "97");
    dchar dc = 'a';
    stream.clear();
    formattedWrite(stream, "%d", dc);
    assert(stream.data == "97");

    byte b = byte.max;
    stream.clear();
    formattedWrite(stream, "%x", b);
    assert(stream.data == "7f");
    stream.clear();
    formattedWrite(stream, "%x", ++b);
    assert(stream.data == "80");
    stream.clear();
    formattedWrite(stream, "%x", ++b);
    assert(stream.data == "81");

    short sh = short.max;
    stream.clear();
    formattedWrite(stream, "%x", sh);
    assert(stream.data == "7fff");
    stream.clear();
    formattedWrite(stream, "%x", ++sh);
    assert(stream.data == "8000");
    stream.clear();
    formattedWrite(stream, "%x", ++sh);
    assert(stream.data == "8001");

    i = int.max;
    stream.clear();
    formattedWrite(stream, "%x", i);
    assert(stream.data == "7fffffff");
    stream.clear();
    formattedWrite(stream, "%x", ++i);
    assert(stream.data == "80000000");
    stream.clear();
    formattedWrite(stream, "%x", ++i);
    assert(stream.data == "80000001");

    stream.clear();
    formattedWrite(stream, "%x", 10);
    assert(stream.data == "a");
    stream.clear();
    formattedWrite(stream, "%X", 10);
    assert(stream.data == "A");
    stream.clear();
    formattedWrite(stream, "%x", 15);
    assert(stream.data == "f");
    stream.clear();
    formattedWrite(stream, "%X", 15);
    assert(stream.data == "F");

    @trusted void ObjectTest()
    {
        Object c = null;
        stream.clear();
        formattedWrite(stream, "%s", c);
        assert(stream.data == "null");
    }
    ObjectTest();

    enum TestEnum
    {
        Value1, Value2
    }
    stream.clear();
    formattedWrite(stream, "%s", TestEnum.Value2);
    assert(stream.data == "Value2", stream.data);
    stream.clear();
    formattedWrite(stream, "%s", cast(TestEnum) 5);
    assert(stream.data == "cast(TestEnum)5", stream.data);

    //immutable(char[5])[int] aa = ([3:"hello", 4:"betty"]);
    //stream.clear();
    //formattedWrite(stream, "%s", aa.values);
    //assert(stream.data == "[[h,e,l,l,o],[b,e,t,t,y]]");
    //stream.clear();
    //formattedWrite(stream, "%s", aa);
    //assert(stream.data == "[3:[h,e,l,l,o],4:[b,e,t,t,y]]");

    static const dchar[] ds = ['a','b'];
    for (int j = 0; j < ds.length; ++j)
    {
        stream.clear(); formattedWrite(stream, " %d", ds[j]);
        if (j == 0)
            assert(stream.data == " 97");
        else
            assert(stream.data == " 98");
    }

    stream.clear();
    formattedWrite(stream, "%.-3d", 7);
    assert(stream.data == "7", ">" ~ stream.data ~ "<");
}

@safe unittest
{
    import std.array : appender;
    import std.meta : AliasSeq;

    immutable(char[5])[int] aa = ([3:"hello", 4:"betty"]);
    assert(aa[3] == "hello");
    assert(aa[4] == "betty");

    auto stream = appender!(char[])();
    alias AllNumerics =
        AliasSeq!(byte, ubyte, short, ushort, int, uint, long, ulong,
                  float, double, real);
    foreach (T; AllNumerics)
    {
        T value = 1;
        stream.clear();
        formattedWrite(stream, "%s", value);
        assert(stream.data == "1");
    }

    stream.clear();
    formattedWrite(stream, "%s", aa);
}

/**
Formats a value of any type according to a format specifier and
writes the result to an output range.

More details about how types are formatted, and how the format
specifier influences the outcome, can be found in the definition of a
$(MREF_ALTTEXT format string, std,format).

Params:
    w = an $(REF_ALTTEXT output range, isOutputRange, std, range, primitives) where
        the formatted value is written to
    val = the value to write
    f = a $(REF_ALTTEXT FormatSpec, FormatSpec, std, format, spec) defining the
        format specifier
    Writer = the type of the output range `w`
    T = the type of value `val`
    Char = the character type used for `f`

Throws:
    A $(LREF FormatException) if formatting did not succeed.

Note:
    In theory this function should be `@nogc`. But with the current
    implementation there are some cases where allocations occur.
    See $(REF_ALTTEXT $(D sformat), sformat, std, format) for more details.

See_Also:
    $(LREF formattedWrite) which formats several values at once.
 */
void formatValue(Writer, T, Char)(auto ref Writer w, auto ref T val, scope const ref FormatSpec!Char f)
{
    import std.format : enforceFmt;

    enforceFmt(f.width != f.DYNAMIC && f.precision != f.DYNAMIC
               && f.separators != f.DYNAMIC && !f.dynamicSeparatorChar,
               "Dynamic argument not allowed for `formatValue`");

    formatValueImpl(w, val, f);
}

///
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : singleSpec;

    auto writer = appender!string();
    auto spec = singleSpec("%08b");
    writer.formatValue(42, spec);
    assert(writer.data == "00101010");

    spec = singleSpec("%2s");
    writer.formatValue('=', spec);
    assert(writer.data == "00101010 =");

    spec = singleSpec("%+14.6e");
    writer.formatValue(42.0, spec);
    assert(writer.data == "00101010 = +4.200000e+01");
}

// https://issues.dlang.org/show_bug.cgi?id=15386
@safe pure unittest
{
    import std.array : appender;
    import std.format.spec : FormatSpec;
    import std.format : FormatException;
    import std.exception : assertThrown;

    auto w = appender!(char[])();
    auto dor = appender!(char[])();
    auto fs = FormatSpec!char("%.*s");
    fs.writeUpToNextSpec(dor);
    assertThrown!FormatException(formatValue(w, 0, fs));

    fs = FormatSpec!char("%*s");
    fs.writeUpToNextSpec(dor);
    assertThrown!FormatException(formatValue(w, 0, fs));

    fs = FormatSpec!char("%,*s");
    fs.writeUpToNextSpec(dor);
    assertThrown!FormatException(formatValue(w, 0, fs));

    fs = FormatSpec!char("%,?s");
    fs.writeUpToNextSpec(dor);
    assertThrown!FormatException(formatValue(w, 0, fs));

    assertThrown!FormatException(formattedWrite(w, "%(%0*d%)", new int[1]));
}

// https://issues.dlang.org/show_bug.cgi?id=22609
@safe pure unittest
{
    static enum State: ubyte { INACTIVE }
    static struct S {
        State state = State.INACTIVE;
        int generation = 1;
        alias state this;
        // DMDBUG: https://issues.dlang.org/show_bug.cgi?id=16657
        auto opEquals(S other) const { return state == other.state && generation == other.generation; }
        auto opEquals(State other) const { return state == other; }
    }

    import std.array : appender;
    import std.format.spec : singleSpec;

    auto writer = appender!string();
    const spec = singleSpec("%s");
    S a;
    writer.formatValue(a, spec);
    assert(writer.data == "0");
}

// https://issues.dlang.org/show_bug.cgi?id=23400
@safe pure unittest
{
    import std.range : nullSink;
    import std.format.spec : singleSpec;

    static struct S
    {
        // non-const opEquals method
        bool opEquals(S rhs) { return false; }
    }

    enum E { a = S() }

    E e;
    auto writer = nullSink;
    const spec = singleSpec("%s");
    writer.formatValue(e, spec);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // Written in the D programming language.

/**
Functions that manipulate other functions.

This module provides functions for compile time function composition. These
functions are helpful when constructing predicates for the algorithms in
$(MREF std, algorithm) or $(MREF std, range).

$(SCRIPT inhibitQuickIndex = 1;)
$(DIVC quickindex,
$(BOOKTABLE ,
$(TR $(TH Function Name) $(TH Description)
)
    $(TR $(TD $(LREF adjoin))
        $(TD Joins a couple of functions into one that executes the original
        functions independently and returns a tuple with all the results.
    ))
    $(TR $(TD $(LREF compose), $(LREF pipe))
        $(TD Join a couple of functions into one that executes the original
        functions one after the other, using one function's result for the next
        function's argument.
    ))
    $(TR $(TD $(LREF lessThan), $(LREF greaterThan), $(LREF equalTo))
        $(TD Ready-made predicate functions to compare two values.
    ))
    $(TR $(TD $(LREF memoize))
        $(TD Creates a function that caches its result for fast re-evaluation.
    ))
    $(TR $(TD $(LREF not))
        $(TD Creates a function that negates another.
    ))
    $(TR $(TD $(LREF partial))
        $(TD Creates a function that binds the first argument of a given function
        to a given value.
    ))
    $(TR $(TD $(LREF curry))
        $(TD Converts a multi-argument function into a series of single-argument
        functions.  f(x, y) == curry(f)(x)(y)
    ))
    $(TR $(TD $(LREF reverseArgs))
        $(TD Predicate that reverses the order of its arguments.
    ))
    $(TR $(TD $(LREF toDelegate))
        $(TD Converts a callable to a delegate.
    ))
    $(TR $(TD $(LREF unaryFun), $(LREF binaryFun))
        $(TD Create a unary or binary function from a string. Most often
        used when defining algorithms on ranges.
    ))
    $(TR $(TD $(LREF bind))
        $(TD Passes the fields of a struct as arguments to a function.
    ))
))

Copyright: Copyright Andrei Alexandrescu 2008 - 2009.
License:   $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
Authors:   $(HTTP erdani.org, Andrei Alexandrescu)
Source:    $(PHOBOSSRC std/functional.d)
*/
/*
         Copyright Andrei Alexandrescu 2008 - 2009.
Distributed under the Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt or copy at
         http://www.boost.org/LICENSE_1_0.txt)
*/
module std.functional;

import std.meta : AliasSeq, Reverse;
import std.traits : isCallable, Parameters;
import std.conv : toCtString;

import std.internal.attributes : betterC;

public import core.lifetime : forward;

private template needOpCallAlias(alias fun)
{
    /* Determine whether or not unaryFun and binaryFun need to alias to fun or
     * fun.opCall. Basically, fun is a function object if fun(...) compiles. We
     * want is(unaryFun!fun) (resp., is(binaryFun!fun)) to be true if fun is
     * any function object. There are 4 possible cases:
     *
     *  1) fun is the type of a function object with static opCall;
     *  2) fun is an instance of a function object with static opCall;
     *  3) fun is the type of a function object with non-static opCall;
     *  4) fun is an instance of a function object with non-static opCall.
     *
     * In case (1), is(unaryFun!fun) should compile, but does not if unaryFun
     * aliases itself to fun, because typeof(fun) is an error when fun itself
     * is a type. So it must be aliased to fun.opCall instead. All other cases
     * should be aliased to fun directly.
     */
    static if (is(typeof(fun.opCall) == function))
    {
        enum needOpCallAlias = !is(typeof(fun)) && __traits(compiles, () {
            return fun(Parameters!fun.init);
        });
    }
    else
        enum needOpCallAlias = false;
}

/**
Transforms a `string` representing an expression into a unary
function. The `string` must either use symbol name `a` as
the parameter or provide the symbol via the `parmName` argument.

Params:
    fun = a `string` or a callable
    parmName = the name of the parameter if `fun` is a string. Defaults
    to `"a"`.
Returns:
    If `fun` is a `string`, a new single parameter function

    If `fun` is not a `string`, an alias to `fun`.
*/
template unaryFun(alias fun, string parmName = "a")
{
    static if (is(typeof(fun) : string))
    {
        static if (!fun._ctfeMatchUnary(parmName))
        {
            import std.algorithm, std.conv, std.exception, std.math, std.range, std.string;
            import std.meta, std.traits, std.typecons;
        }
        auto unaryFun(ElementType)(auto ref ElementType __a)
        {
            mixin("alias " ~ parmName ~ " = __a ;");
            return mixin(fun);
        }
    }
    else static if (needOpCallAlias!fun)
    {
        // https://issues.dlang.org/show_bug.cgi?id=9906
        alias unaryFun = fun.opCall;
    }
    else
    {
        alias unaryFun = fun;
    }
}

///
@safe unittest
{
    // Strings are compiled into functions:
    alias isEven = unaryFun!("(a & 1) == 0");
    assert(isEven(2) && !isEven(1));
}

@safe unittest
{
    static int f1(int a) { return a + 1; }
    static assert(is(typeof(unaryFun!(f1)(1)) == int));
    assert(unaryFun!(f1)(41) == 42);
    int f2(int a) { return a + 1; }
    static assert(is(typeof(unaryFun!(f2)(1)) == int));
    assert(unaryFun!(f2)(41) == 42);
    assert(unaryFun!("a + 1")(41) == 42);
    //assert(unaryFun!("return a + 1;")(41) == 42);

    int num = 41;
    assert(unaryFun!"a + 1"(num) == 42);

    // https://issues.dlang.org/show_bug.cgi?id=9906
    struct Seen
    {
        static bool opCall(int n) { return true; }
    }
    static assert(needOpCallAlias!Seen);
    static assert(is(typeof(unaryFun!Seen(1))));
    assert(unaryFun!Seen(1));

    Seen s;
    static assert(!needOpCallAlias!s);
    static assert(is(typeof(unaryFun!s(1))));
    assert(unaryFun!s(1));

    struct FuncObj
    {
        bool opCall(int n) { return true; }
    }
    FuncObj fo;
    static assert(!needOpCallAlias!fo);
    static assert(is(typeof(unaryFun!fo)));
    assert(unaryFun!fo(1));

    // Function object with non-static opCall can only be called with an
    // instance, not with merely the type.
    static assert(!is(typeof(unaryFun!FuncObj)));
}

/**
Transforms a `string` representing an expression into a binary function. The
`string` must either use symbol names `a` and `b` as the parameters or
provide the symbols via the `parm1Name` and `parm2Name` arguments.

Params:
    fun = a `string` or a callable
    parm1Name = the name of the first parameter if `fun` is a string.
    Defaults to `"a"`.
    parm2Name = the name of the second parameter if `fun` is a string.
    Defaults to `"b"`.
Returns:
    If `fun` is not a string, `binaryFun` aliases itself away to
    `fun`.
*/
template binaryFun(alias fun, string parm1Name = "a",
        string parm2Name = "b")
{
    static if (is(typeof(fun) : string))
    {
        static if (!fun._ctfeMatchBinary(parm1Name, parm2Name))
        {
            import std.algorithm, std.conv, std.exception, std.math, std.range, std.string;
            import std.meta, std.traits, std.typecons;
        }
        auto binaryFun(ElementType1, ElementType2)
            (auto ref ElementType1 __a, auto ref ElementType2 __b)
        {
            mixin("alias "~parm1Name~" = __a ;");
            mixin("alias "~parm2Name~" = __b ;");
            return mixin(fun);
        }
    }
    else static if (needOpCallAlias!fun)
    {
        // https://issues.dlang.org/show_bug.cgi?id=9906
        alias binaryFun = fun.opCall;
    }
    else
    {
        alias binaryFun = fun;
    }
}

///
@safe unittest
{
    alias less = binaryFun!("a < b");
    assert(less(1, 2) && !less(2, 1));
    alias greater = binaryFun!("a > b");
    assert(!greater("1", "2") && greater("2", "1"));
}

@safe unittest
{
    static int f1(int a, string b) { return a + 1; }
    static assert(is(typeof(binaryFun!(f1)(1, "2")) == int));
    assert(binaryFun!(f1)(41, "a") == 42);
    string f2(int a, string b) { return b ~ "2"; }
    static assert(is(typeof(binaryFun!(f2)(1, "1")) == string));
    assert(binaryFun!(f2)(1, "4") == "42");
    assert(binaryFun!("a + b")(41, 1) == 42);
    //@@BUG
    //assert(binaryFun!("return a + b;")(41, 1) == 42);

    // https://issues.dlang.org/show_bug.cgi?id=9906
    struct Seen
    {
        static bool opCall(int x, int y) { return true; }
    }
    static assert(is(typeof(binaryFun!Seen)));
    assert(binaryFun!Seen(1,1));

    struct FuncObj
    {
        bool opCall(int x, int y) { return true; }
    }
    FuncObj fo;
    static assert(!needOpCallAlias!fo);
    static assert(is(typeof(binaryFun!fo)));
    assert(unaryFun!fo(1,1));

    // Function object with non-static opCall can only be called with an
    // instance, not with merely the type.
    static assert(!is(typeof(binaryFun!FuncObj)));
}

// skip all ASCII chars except a .. z, A .. Z, 0 .. 9, '_' and '.'.
private uint _ctfeSkipOp(ref string op)
{
    if (!__ctfe) assert(false);
    import std.ascii : isASCII, isAlphaNum;
    immutable oldLength = op.length;
    while (op.length)
    {
        immutable front = op[0];
        if (front.isASCII() && !(front.isAlphaNum() || front == '_' || front == '.'))
            op = op[1..$];
        else
            break;
    }
    return oldLength != op.length;
}

// skip all digits
private uint _ctfeSkipInteger(ref string op)
{
    if (!__ctfe) assert(false);
    import std.ascii : isDigit;
    immutable oldLength = op.length;
    while (op.length)
    {
        immutable front = op[0];
        if (front.isDigit())
            op = op[1..$];
        else
            break;
    }
    return oldLength != op.length;
}

// skip name
private uint _ctfeSkipName(ref string op, string name)
{
    if (!__ctfe) assert(false);
    if (op.length >= name.length && op[0 .. name.length] == name)
    {
        op = op[name.length..$];
        return 1;
    }
    return 0;
}

// returns 1 if `fun` is trivial unary function
private uint _ctfeMatchUnary(string fun, string name)
{
    if (!__ctfe) assert(false);
    fun._ctfeSkipOp();
    for (;;)
    {
        immutable h = fun._ctfeSkipName(name) + fun._ctfeSkipInteger();
        if (h == 0)
        {
            fun._ctfeSkipOp();
            break;
        }
        else if (h == 1)
        {
            if (!fun._ctfeSkipOp())
                break;
        }
        else
            return 0;
    }
    return fun.length == 0;
}

@safe unittest
{
    static assert(!_ctfeMatchUnary("sqrt(ё)", "ё"));
    static assert(!_ctfeMatchUnary("ё.sqrt", "ё"));
    static assert(!_ctfeMatchUnary(".ё+ё", "ё"));
    static assert(!_ctfeMatchUnary("_ё+ё", "ё"));
    static assert(!_ctfeMatchUnary("ёё", "ё"));
    static assert(_ctfeMatchUnary("a+a", "a"));
    static assert(_ctfeMatchUnary("a + 10", "a"));
    static assert(_ctfeMatchUnary("4 == a", "a"));
    static assert(_ctfeMatchUnary("2 == a", "a"));
    static assert(_ctfeMatchUnary("1 != a", "a"));
    static assert(_ctfeMatchUnary("a != 4", "a"));
    static assert(_ctfeMatchUnary("a< 1", "a"));
    static assert(_ctfeMatchUnary("434 < a", "a"));
    static assert(_ctfeMatchUnary("132 > a", "a"));
    static assert(_ctfeMatchUnary("123 >a", "a"));
    static assert(_ctfeMatchUnary("a>82", "a"));
    static assert(_ctfeMatchUnary("ё>82", "ё"));
    static assert(_ctfeMatchUnary("ё[ё(ё)]", "ё"));
    static assert(_ctfeMatchUnary("ё[21]", "ё"));
}

// returns 1 if `fun` is trivial binary function
private uint _ctfeMatchBinary(string fun, string name1, string name2)
{
    if (!__ctfe) assert(false);
    fun._ctfeSkipOp();
    for (;;)
    {
        immutable h = fun._ctfeSkipName(name1) + fun._ctfeSkipName(name2) + fun._ctfeSkipInteger();
        if (h == 0)
        {
            fun._ctfeSkipOp();
            break;
        }
        else if (h == 1)
        {
            if (!fun._ctfeSkipOp())
                break;
        }
        else
            return 0;
    }
    return fun.length == 0;
}

@safe unittest
{

    static assert(!_ctfeMatchBinary("sqrt(ё)", "ё", "b"));
    static assert(!_ctfeMatchBinary("ё.sqrt", "ё", "b"));
    static assert(!_ctfeMatchBinary(".ё+ё", "ё", "b"));
    static assert(!_ctfeMatchBinary("_ё+ё", "ё", "b"));
    static assert(!_ctfeMatchBinary("ёё", "ё", "b"));
    static assert(_ctfeMatchBinary("a+a", "a", "b"));
    static assert(_ctfeMatchBinary("a + 10", "a", "b"));
    static assert(_ctfeMatchBinary("4 == a", "a", "b"));
    static assert(_ctfeMatchBinary("2 == a", "a", "b"));
    static assert(_ctfeMatchBinary("1 != a", "a", "b"));
    static assert(_ctfeMatchBinary("a != 4", "a", "b"));
    static assert(_ctfeMatchBinary("a< 1", "a", "b"));
    static assert(_ctfeMatchBinary("434 < a", "a", "b"));
    static assert(_ctfeMatchBinary("132 > a", "a", "b"));
    static assert(_ctfeMatchBinary("123 >a", "a", "b"));
    static assert(_ctfeMatchBinary("a>82", "a", "b"));
    static assert(_ctfeMatchBinary("ё>82", "ё", "q"));
    static assert(_ctfeMatchBinary("ё[ё(10)]", "ё", "q"));
    static assert(_ctfeMatchBinary("ё[21]", "ё", "q"));

    static assert(!_ctfeMatchBinary("sqrt(ё)+b", "b", "ё"));
    static assert(!_ctfeMatchBinary("ё.sqrt-b", "b", "ё"));
    static assert(!_ctfeMatchBinary(".ё+b", "b", "ё"));
    static assert(!_ctfeMatchBinary("_b+ё", "b", "ё"));
    static assert(!_ctfeMatchBinary("ba", "b", "a"));
    static assert(_ctfeMatchBinary("a+b", "b", "a"));
    static assert(_ctfeMatchBinary("a + b", "b", "a"));
    static assert(_ctfeMatchBinary("b == a", "b", "a"));
    static assert(_ctfeMatchBinary("b == a", "b", "a"));
    static assert(_ctfeMatchBinary("b != a", "b", "a"));
    static assert(_ctfeMatchBinary("a != b", "b", "a"));
    static assert(_ctfeMatchBinary("a< b", "b", "a"));
    static assert(_ctfeMatchBinary("b < a", "b", "a"));
    static assert(_ctfeMatchBinary("b > a", "b", "a"));
    static assert(_ctfeMatchBinary("b >a", "b", "a"));
    static assert(_ctfeMatchBinary("a>b", "b", "a"));
    static assert(_ctfeMatchBinary("ё>b", "b", "ё"));
    static assert(_ctfeMatchBinary("b[ё(-1)]", "b", "ё"));
    static assert(_ctfeMatchBinary("ё[-21]", "b", "ё"));
}

//undocumented
template safeOp(string S)
if (S=="<"||S==">"||S=="<="||S==">="||S=="=="||S=="!=")
{
    import std.traits : isIntegral;
    private bool unsafeOp(ElementType1, ElementType2)(ElementType1 a, ElementType2 b) pure
        if (isIntegral!ElementType1 && isIntegral!ElementType2)
    {
        import std.traits : CommonType;
        alias T = CommonType!(ElementType1, ElementType2);
        return mixin("cast(T)a "~S~" cast(T) b");
    }

    bool safeOp(T0, T1)(auto ref T0 a, auto ref T1 b)
    {
        import std.traits : mostNegative;
        static if (isIntegral!T0 && isIntegral!T1 &&
                   (mostNegative!T0 < 0) != (mostNegative!T1 < 0))
        {
            static if (S == "<=" || S == "<")
            {
                static if (mostNegative!T0 < 0)
                    immutable result = a < 0 || unsafeOp(a, b);
                else
                    immutable result = b >= 0 && unsafeOp(a, b);
            }
            else
            {
                static if (mostNegative!T0 < 0)
                    immutable result = a >= 0 && unsafeOp(a, b);
                else
                    immutable result = b < 0 || unsafeOp(a, b);
            }
        }
        else
        {
            static assert(is(typeof(mixin("a "~S~" b"))),
                "Invalid arguments: Cannot compare types " ~ T0.stringof ~ " and " ~ T1.stringof ~ ".");

            immutable result = mixin("a "~S~" b");
        }
        return result;
    }
}

@safe unittest //check user defined types
{
    import std.algorithm.comparison : equal;
    struct Foo
    {
        int a;
        auto opEquals(Foo foo)
        {
            return a == foo.a;
        }
    }
    assert(safeOp!"!="(Foo(1), Foo(2)));
}

/**
   Predicate that returns $(D_PARAM a < b).
   Correctly compares signed and unsigned integers, ie. -1 < 2U.
*/
alias lessThan = safeOp!"<";

///
pure @safe @nogc nothrow unittest
{
    assert(lessThan(2, 3));
    assert(lessThan(2U, 3U));
    assert(lessThan(2, 3.0));
    assert(lessThan(-2, 3U));
    assert(lessThan(2, 3U));
    assert(!lessThan(3U, -2));
    assert(!lessThan(3U, 2));
    assert(!lessThan(0, 0));
    assert(!lessThan(0U, 0));
    assert(!lessThan(0, 0U));
}

/**
   Predicate that returns $(D_PARAM a > b).
   Correctly compares signed and unsigned integers, ie. 2U > -1.
*/
alias greaterThan = safeOp!">";

///
@safe unittest
{
    assert(!greaterThan(2, 3));
    assert(!greaterThan(2U, 3U));
    assert(!greaterThan(2, 3.0));
    assert(!greaterThan(-2, 3U));
    assert(!greaterThan(2, 3U));
    assert(greaterThan(3U, -2));
    assert(greaterThan(3U, 2));
    assert(!greaterThan(0, 0));
    assert(!greaterThan(0U, 0));
    assert(!greaterThan(0, 0U));
}

/**
   Predicate that returns $(D_PARAM a == b).
   Correctly compares signed and unsigned integers, ie. !(-1 == ~0U).
*/
alias equalTo = safeOp!"==";

///
@safe unittest
{
    assert(equalTo(0U, 0));
    assert(equalTo(0, 0U));
    assert(!equalTo(-1, ~0U));
}
/**
N-ary predicate that reverses the order of arguments, e.g., given
$(D pred(a, b, c)), returns $(D pred(c, b, a)).

Params:
    pred = A callable
Returns:
    A function which calls `pred` after reversing the given parameters
*/
template reverseArgs(alias pred)
{
    auto reverseArgs(Args...)(auto ref Args args)
    if (is(typeof(pred(Reverse!args))))
    {
        return pred(Reverse!args);
    }
}

///
@safe unittest
{
    alias gt = reverseArgs!(binaryFun!("a < b"));
    assert(gt(2, 1) && !gt(1, 1));
}

///
@safe unittest
{
    int x = 42;
    bool xyz(int a, int b) { return a * x < b / x; }
    auto foo = &xyz;
    foo(4, 5);
    alias zyx = reverseArgs!(foo);
    assert(zyx(5, 4) == foo(4, 5));
}

///
@safe unittest
{
    alias gt = reverseArgs!(binaryFun!("a < b"));
    assert(gt(2, 1) && !gt(1, 1));
    int x = 42;
    bool xyz(int a, int b) { return a * x < b / x; }
    auto foo = &xyz;
    foo(4, 5);
    alias zyx = reverseArgs!(foo);
    assert(zyx(5, 4) == foo(4, 5));
}

///
@safe unittest
{
    int abc(int a, int b, int c) { return a * b + c; }
    alias cba = reverseArgs!abc;
    assert(abc(91, 17, 32) == cba(32, 17, 91));
}

///
@safe unittest
{
    int a(int a) { return a * 2; }
    alias _a = reverseArgs!a;
    assert(a(2) == _a(2));
}

///
@safe unittest
{
    int b() { return 4; }
    alias _b = reverseArgs!b;
    assert(b() == _b());
}

/**
Negates predicate `pred`.

Params:
    pred = A string or a callable
Returns:
    A function which calls `pred` and returns the logical negation of its
    return value.
 */
template not(alias pred)
{
    auto not(T...)(auto ref T args)
    {
        static if (is(typeof(!pred(args))))
            return !pred(args);
        else static if (T.length == 1)
            return !unaryFun!pred(args);
        else static if (T.length == 2)
            return !binaryFun!pred(args);
        else
            static assert(0);
    }
}

///
@safe unittest
{
    import std.algorithm.searching : find;
    import std.uni : isWhite;
    string a = "   Hello, world!";
    assert(find!(not!isWhite)(a) == "Hello, world!");
}

@safe unittest
{
    assert(not!"a != 5"(5));
    assert(not!"a != b"(5, 5));

    assert(not!(() => false)());
    assert(not!(a => a != 5)(5));
    assert(not!((a, b) => a != b)(5, 5));
    assert(not!((a, b, c) => a * b * c != 125 )(5, 5, 5));
}

/**
$(LINK2 http://en.wikipedia.org/wiki/Partial_application, Partially
applies) $(D_PARAM fun) by tying its first argument to $(D_PARAM arg).

Params:
    fun = A callable
    arg = The first argument to apply to `fun`
Returns:
    A new function which calls `fun` with `arg` plus the passed parameters.
 */
template partial(alias fun, alias arg)
{
    import std.traits : isCallable;
    // Check whether fun is a user defined type which implements opCall or a template.
    // As opCall itself can be templated, std.traits.isCallable does not work here.
    enum isSomeFunctor = (is(typeof(fun) == struct) || is(typeof(fun) == class)) && __traits(hasMember, fun, "opCall");
    static if (isSomeFunctor || __traits(isTemplate, fun))
    {
        auto partial(Ts...)(Ts args2)
        {
            static if (is(typeof(fun(arg, args2))))
            {
                return fun(arg, args2);
            }
            else
            {
                static string errormsg()
                {
                    string msg = "Cannot call '" ~ fun.stringof ~ "' with arguments " ~
                        "(" ~ arg.stringof;
                    foreach (T; Ts)
                        msg ~= ", " ~ T.stringof;
                    msg ~= ").";
                    return msg;
                }
                static assert(0, errormsg());
            }
        }
    }
    else static if (!isCallable!fun)
    {
        static assert(false, "Cannot apply partial to a non-callable '" ~ fun.stringof ~ "'.");
    }
    else
    {
        import std.meta : Filter;

        static if (__traits(compiles, __traits(getOverloads,
            __traits(parent, fun), __traits(identifier, fun))))
            alias overloads = __traits(getOverloads, __traits(parent, fun),
                __traits(identifier, fun));
        else
            alias overloads = AliasSeq!(fun);

        enum isCallableWithArg(alias fun) = Parameters!fun.length > 0 &&
            is(typeof(arg) : Parameters!fun[0]);
        alias candidates = Filter!(isCallableWithArg, overloads);

        static if (overloads.length == 1 && Parameters!fun.length == 0)
        {
            static assert(0, "Cannot partially apply '" ~ fun.stringof ~ "'." ~
                "'" ~ fun.stringof ~ "' has 0 arguments.");
        }
        else static if (candidates.length == 0)
        {
            import std.meta : NoDuplicates, staticMap;

            enum hasParameters(alias fun) = Parameters!fun.length > 0;
            alias firstParameter(alias fun) = Parameters!fun[0];
            alias firstParameters = NoDuplicates!(
                staticMap!(firstParameter, Filter!(hasParameters, overloads)));

            string errorMsg()
            {
                string msg = "Argument mismatch for '" ~ fun.stringof ~
                    "': expected " ~ firstParameters[0].stringof;
                static foreach (firstParam; firstParameters[1 .. $])
                    msg ~= " or " ~ firstParam.stringof;
                msg ~= ", but got " ~ typeof(arg).stringof ~ ".";

                return msg;
            }
            static assert(0, errorMsg());
        }
        else
        {
            import std.traits : ReturnType;
            static foreach (candidate; candidates)
                ReturnType!candidate partial(Parameters!candidate[1..$] args2)
                {
                    return candidate(arg, args2);
                }
        }
    }
}

///
@safe unittest
{
    int fun(int a, int b) { return a + b; }
    alias fun5 = partial!(fun, 5);
    assert(fun5(6) == 11);
    // Note that in most cases you'd use an alias instead of a value
    // assignment. Using an alias allows you to partially evaluate template
    // functions without committing to a particular type of the function.
}

// https://issues.dlang.org/show_bug.cgi?id=21457
///
@safe unittest
{
    // Overloads are resolved when the partially applied function is called
    // with the remaining arguments.
    struct S
    {
        static char fun(int i, string s) { return s[i]; }
        static int fun(int a, int b) { return a * b; }
    }
    alias fun3 = partial!(S.fun, 3);
    assert(fun3("hello") == 'l');
    assert(fun3(10) == 30);
}

// tests for partially evaluating callables
@safe unittest
{
    static int f1(int a, int b) { return a + b; }
    assert(partial!(f1, 5)(6) == 11);

    int f2(int a, int b) { return a + b; }
    int x = 5;
    assert(partial!(f2, x)(6) == 11);
    x = 7;
    assert(partial!(f2, x)(6) == 13);
    static assert(partial!(f2, 5)(6) == 11);

    auto dg = &f2;
    auto f3 = &partial!(dg, x);
    assert(f3(6) == 13);

    static int funOneArg(int a) { return a; }
    assert(partial!(funOneArg, 1)() == 1);

    static int funThreeArgs(int a, int b, int c) { return a + b + c; }
    alias funThreeArgs1 = partial!(funThreeArgs, 1);
    assert(funThreeArgs1(2, 3) == 6);
    static assert(!is(typeof(funThreeArgs1(2))));

    enum xe = 5;
    alias fe = partial!(f2, xe);
    static assert(fe(6) == 11);
}

// tests for partially evaluating templated/overloaded callables
@safe unittest
{
    static auto add(A, B)(A x, B y)
    {
        return x + y;
    }

    alias add5 = partial!(add, 5);
    assert(add5(6) == 11);
    static assert(!is(typeof(add5())));
    static assert(!is(typeof(add5(6, 7))));

    // taking address of templated partial evaluation needs explicit type
    auto dg = &add5!(int);
    assert(dg(6) == 11);

    int x = 5;
    alias addX = partial!(add, x);
    assert(addX(6) == 11);

    static struct Callable
    {
        static string opCall(string a, string b) { return a ~ b; }
        int opCall(int a, int b) { return a * b; }
        double opCall(double a, double b) { return a + b; }
    }
    Callable callable;
    assert(partial!(Callable, "5")("6") == "56");
    assert(partial!(callable, 5)(6) == 30);
    assert(partial!(callable, 7.0)(3.0) == 7.0 + 3.0);

    static struct TCallable
    {
        auto opCall(A, B)(A a, B b)
        {
            return a + b;
        }
    }
    TCallable tcallable;
    assert(partial!(tcallable, 5)(6) == 11);
    static assert(!is(typeof(partial!(tcallable, "5")(6))));

    static struct NonCallable{}
    static assert(!__traits(compiles, partial!(NonCallable, 5)), "Partial should not work on non-callable structs.");
    static assert(!__traits(compiles, partial!(NonCallable.init, 5)),
        "Partial should not work on instances of non-callable structs.");

    static A funOneArg(A)(A a) { return a; }
    alias funOneArg1 = partial!(funOneArg, 1);
    assert(funOneArg1() == 1);

    static auto funThreeArgs(A, B, C)(A a, B b, C c) { return a + b + c; }
    alias funThreeArgs1 = partial!(funThreeArgs, 1);
    assert(funThreeArgs1(2, 3) == 6);
    static assert(!is(typeof(funThreeArgs1(1))));

    auto dg2 = &funOneArg1!();
    assert(dg2() == 1);
}

// Fix https://issues.dlang.org/show_bug.cgi?id=15732
@safe unittest
{
    // Test whether it works with functions.
    auto partialFunction(){
        auto fullFunction = (float a, float b, float c) => a + b / c;
        alias apply1 = partial!(fullFunction, 1);
        return &apply1;
    }
    auto result = partialFunction()(2, 4);
    assert(result == 1.5f);

    // And with delegates.
    auto partialDelegate(float c){
        auto fullDelegate = (float a, float b) => a + b / c;
        alias apply1 = partial!(fullDelegate, 1);
        return &apply1;
    }
    auto result2 = partialDelegate(4)(2);
    assert(result2 == 1.5f);
}

/**
Takes a function of (potentially) many arguments, and returns a function taking
one argument and returns a callable taking the rest.  f(x, y) == curry(f)(x)(y)

Params:
    F = a function taking at least one argument
    t = a callable object whose opCall takes at least 1 object
Returns:
    A single parameter callable object
*/
template curry(alias F)
if (isCallable!F && Parameters!F.length)
{
    //inspired from the implementation from Artur Skawina here:
    //https://forum.dlang.org/post/mailman.1626.1340110492.24740.digitalmars-d@puremagic.com
    //This implementation stores a copy of all filled in arguments with each curried result
    //this way, the curried functions are independent and don't share any references
    //eg: auto fc = curry!f;  auto fc1 = fc(1); auto fc2 = fc(2); fc1(3) != fc2(3)
    struct CurryImpl(size_t N)
    {
        alias FParams = Parameters!F;
        FParams[0 .. N] storedArguments;
        static if (N > 0)
        {
            this(U : FParams[N - 1])(ref CurryImpl!(N - 1) prev, ref U arg)
            {
                storedArguments[0 .. N - 1] = prev.storedArguments[];
                storedArguments[N-1] = arg;
            }
        }

        auto opCall(U : FParams[N])(auto ref U arg) return scope
        {
            static if (N == FParams.length - 1)
            {
                return F(storedArguments, arg);
            }
            else
            {
                return CurryImpl!(N + 1)(this, arg);
            }
        }
    }

    auto curry()
    {
        CurryImpl!0 res;
        return res; // return CurryImpl!0.init segfaults for delegates on Windows
    }
}

///
pure @safe @nogc nothrow unittest
{
    int f(int x, int y, int z)
    {
        return x + y + z;
    }
    auto cf = curry!f;
    auto cf1 = cf(1);
    auto cf2 = cf(2);

    assert(cf1(2)(3) == f(1, 2, 3));
    assert(cf2(2)(3) == f(2, 2, 3));
}

///ditto
auto curry(T)(T t)
if (isCallable!T && Parameters!T.length)
{
    static auto fun(ref T inst, ref Parameters!T args)
    {
        return inst(args);
    }

    return curry!fun()(t);
}

///
pure @safe @nogc nothrow unittest
{
    //works with callable structs too
    struct S
    {
        int w;
        int opCall(int x, int y, int z)
        {
            return w + x + y + z;
        }
    }

    S s;
    s.w = 5;

    auto cs = curry(s);
    auto cs1 = cs(1);
    auto cs2 = cs(2);

    assert(cs1(2)(3) == s(1, 2, 3));
    assert(cs1(2)(3) == (1 + 2 + 3 + 5));
    assert(cs2(2)(3) ==s(2, 2, 3));
}


@safe pure @nogc nothrow unittest
{
    //currying a single argument function does nothing
    int pork(int a){ return a*2;}
    auto curryPork = curry!pork;
    assert(curryPork(0) == pork(0));
    assert(curryPork(1) == pork(1));
    assert(curryPork(-1) == pork(-1));
    assert(curryPork(1000) == pork(1000));

    //test 2 argument function
    double mixedVeggies(double a, int b, bool)
    {
        return a + b;
    }

    auto mixedCurry = curry!mixedVeggies;
    assert(mixedCurry(10)(20)(false) == mixedVeggies(10, 20, false));
    assert(mixedCurry(100)(200)(true) == mixedVeggies(100, 200, true));

    // struct with opCall
    struct S
    {
        double opCall(int x, double y, short z) const pure nothrow @nogc
        {
            return x*y*z;
        }
    }

    S s;
    auto curriedStruct = curry(s);
    assert(curriedStruct(1)(2)(short(3)) == s(1, 2, short(3)));
    assert(curriedStruct(300)(20)(short(10)) == s(300, 20, short(10)));
}

pure @safe nothrow unittest
{
    auto cfl = curry!((double a, int b)  => a + b);
    assert(cfl(13)(2) == 15);

    int c = 42;
    auto cdg = curry!((double a, int b)  => a + b + c);
    assert(cdg(13)(2) == 57);

    static class C
    {
        int opCall(int mult, int add) pure @safe nothrow @nogc scope
        {
            return  mult * 42 + add;
        }
    }

    scope C ci = new C();
    scope cc = curry(ci);
    assert(cc(2)(4) == ci(2, 4));
}

// Disallows callables without parameters
pure @safe @nogc nothrow unittest
{
    static void noargs() {}
    static assert(!__traits(compiles, curry!noargs()));

    static struct NoArgs
    {
        void opCall() {}
    }

    static assert(!__traits(compiles, curry(NoArgs.init)));
}

private template Iota(size_t n)
{
    static if (n == 0)
        alias Iota = AliasSeq!();
    else
        alias Iota = AliasSeq!(Iota!(n - 1), n - 1);
}

/**
Takes multiple functions and adjoins them together.

Params:
    F = the call-able(s) to adjoin
Returns:
    A new function which returns a $(REF Tuple, std,typecons). Each of the
    elements of the tuple will be the return values of `F`.

Note: In the special case where only a single function is provided
($(D F.length == 1)), adjoin simply aliases to the single passed function
(`F[0]`).
*/
template adjoin(F...)
if (F.length >= 1)
{
    static if (F.length == 1)
        alias adjoin = F[0];
    else
        auto adjoin(V...)(auto ref V a)
        {
            import std.typecons : tuple;
            import std.meta : staticMap;

            auto resultElement(size_t i)()
            {
                return F[i](a);
            }

            return tuple(staticMap!(resultElement, Iota!(F.length)));
        }
}

///
@safe unittest
{
    import std.typecons : Tuple;
    static bool f1(int a) { return a != 0; }
    static int f2(int a) { return a / 2; }
    auto x = adjoin!(f1, f2)(5);
    assert(is(typeof(x) == Tuple!(bool, int)));
    assert(x[0] == true && x[1] == 2);
}

@safe unittest
{
    import std.typecons : Tuple;
    static bool F1(int a) { return a != 0; }
    auto x1 = adjoin!(F1)(5);
    static int F2(int a) { return a / 2; }
    auto x2 = adjoin!(F1, F2)(5);
    assert(is(typeof(x2) == Tuple!(bool, int)));
    assert(x2[0] && x2[1] == 2);
    auto x3 = adjoin!(F1, F2, F2)(5);
    assert(is(typeof(x3) == Tuple!(bool, int, int)));
    assert(x3[0] && x3[1] == 2 && x3[2] == 2);

    bool F4(int a) { return a != x1; }
    alias eff4 = adjoin!(F4);
    static struct S
    {
        bool delegate(int) @safe store;
        int fun() { return 42 + store(5); }
    }
    S s;
    s.store = (int a) { return eff4(a); };
    auto x4 = s.fun();
    assert(x4 == 43);
}

@safe unittest
{
    import std.meta : staticMap;
    import std.typecons : Tuple, tuple;
    alias funs = staticMap!(unaryFun, "a", "a * 2", "a * 3", "a * a", "-a");
    alias afun = adjoin!funs;
    assert(afun(5) == tuple(5, 10, 15, 25, -5));

    static class C{}
    alias IC = immutable(C);
    IC foo(){return typeof(return).init;}
    Tuple!(IC, IC, IC, IC) ret1 = adjoin!(foo, foo, foo, foo)();

    static struct S{int* p;}
    alias IS = immutable(S);
    IS bar(){return typeof(return).init;}
    enum Tuple!(IS, IS, IS, IS) ret2 = adjoin!(bar, bar, bar, bar)();
}

// https://issues.dlang.org/show_bug.cgi?id=21347
@safe @betterC unittest
{
    alias f = (int n) => n + 1;
    alias g = (int n) => n + 2;
    alias h = (int n) => n + 3;
    alias i = (int n) => n + 4;

    auto result = adjoin!(f, g, h, i)(0);

    assert(result[0] == 1);
    assert(result[1] == 2);
    assert(result[2] == 3);
    assert(result[3] == 4);
}

/**
   Composes passed-in functions $(D fun[0], fun[1], ...).

   Params:
        fun = the call-able(s) or `string`(s) to compose into one function
    Returns:
        A new function `f(x)` that in turn returns `fun[0](fun[1](...(x)))...`.

   See_Also: $(LREF pipe)
*/
template compose(fun...)
if (fun.length > 0)
{
    static if (fun.length == 1)
    {
        alias compose = unaryFun!(fun[0]);
    }
    else
    {
        alias fun0 = unaryFun!(fun[0]);
        alias rest = compose!(fun[1 .. $]);

        auto compose(Args...)(Args args)
        {
            return fun0(rest(args));
        }
    }
}

///
@safe unittest
{
    import std.algorithm.comparison : equal;
    import std.algorithm.iteration : map;
    import std.array : split;
    import std.conv : to;

    // First split a string in whitespace-separated tokens and then
    // convert each token into an integer
    assert(compose!(map!(to!(int)), split)("1 2 3").equal([1, 2, 3]));
}

// https://issues.dlang.org/show_bug.cgi?id=6484
@safe unittest
{
    int f(int a) { return a; }
    int g(int a) { return a; }
    int h(int a,int b,int c) { return a * b * c; }

    alias F = compose!(f,g,h);
    assert(F(1,2,3) == f(g(h(1,2,3))));
}

/**
   Pipes functions in sequence. Offers the same functionality as $(D
   compose), but with functions specified in reverse order. This may
   lead to more readable code in some situation because the order of
   execution is the same as lexical order.

   Params:
        fun = the call-able(s) or `string`(s) to compose into one function
    Returns:
        A new function `f(x)` that in turn returns `fun[$-1](...fun[1](fun[0](x)))...`.

   Example:

----
// Read an entire text file, split the resulting string in
// whitespace-separated tokens, and then convert each token into an
// integer
int[] a = pipe!(readText, split, map!(to!(int)))("file.txt");
----

   See_Also: $(LREF compose)
 */
alias pipe(fun...) = compose!(Reverse!(fun));

///
@safe unittest
{
    import std.conv : to;
    string foo(int a) { return to!(string)(a); }
    int bar(string a) { return to!(int)(a) + 1; }
    double baz(int a) { return a + 0.5; }
    assert(compose!(baz, bar, foo)(1) == 2.5);
    assert(pipe!(foo, bar, baz)(1) == 2.5);

    assert(compose!(baz, `to!(int)(a) + 1`, foo)(1) == 2.5);
    assert(compose!(baz, bar)("1"[]) == 2.5);

    assert(compose!(baz, bar)("1") == 2.5);

    assert(compose!(`a + 0.5`, `to!(int)(a) + 1`, foo)(1) == 2.5);
}

/**
 * $(LINK2 https://en.wikipedia.org/wiki/Memoization, Memoizes) a function so as
 * to avoid repeated computation. The memoization structure is a hash table keyed by a
 * tuple of the function's arguments. There is a speed gain if the
 * function is repeatedly called with the same arguments and is more
 * expensive than a hash table lookup. For more information on memoization, refer to $(HTTP docs.google.com/viewer?url=http%3A%2F%2Fhop.perl.plover.com%2Fbook%2Fpdf%2F03CachingAndMemoization.pdf, this book chapter).

Example:
----
double transmogrify(int a, string b)
{
   ... expensive computation ...
}
alias fastTransmogrify = memoize!transmogrify;
unittest
{
    auto slow = transmogrify(2, "hello");
    auto fast = fastTransmogrify(2, "hello");
    assert(slow == fast);
}
----

Params:
    fun = the call-able to memozie
    maxSize = The maximum size of the GC buffer to hold the return values
Returns:
    A new function which calls `fun` and caches its return values.

Note:
    Technically the memoized function should be pure because `memoize` assumes it will
    always return the same result for a given tuple of arguments. However, `memoize` does not
    enforce that because sometimes it is useful to memoize an impure function, too.
*/
template memoize(alias fun)
{
    import std.traits : ReturnType;
     // https://issues.dlang.org/show_bug.cgi?id=13580
    // alias Args = Parameters!fun;

    ReturnType!fun memoize(Parameters!fun args)
    {
        alias Args = Parameters!fun;
        import std.typecons : Tuple;
        import std.traits : Unqual;

        static Unqual!(ReturnType!fun)[Tuple!Args] memo;
        auto t = Tuple!Args(args);
        if (auto p = t in memo)
            return *p;
        auto r = fun(args);
        memo[t] = r;
        return r;
    }
}

/// ditto
template memoize(alias fun, uint maxSize)
{
    import std.traits : ReturnType;
     // https://issues.dlang.org/show_bug.cgi?id=13580
    // alias Args = Parameters!fun;
    ReturnType!fun memoize(Parameters!fun args)
    {
        import std.meta : staticMap;
        import std.traits : hasIndirections, Unqual;
        import std.typecons : tuple;
        static struct Value { staticMap!(Unqual, Parameters!fun) args; Unqual!(ReturnType!fun) res; }
        static Value[] memo;
        static size_t[] initialized;

        if (!memo.length)
        {
            import core.memory : GC;

            // Ensure no allocation overflows
            static assert(maxSize < size_t.max / Value.sizeof);
            static assert(maxSize < size_t.max - (8 * size_t.sizeof - 1));

            enum attr = GC.BlkAttr.NO_INTERIOR | (hasIndirections!Value ? 0 : GC.BlkAttr.NO_SCAN);
            memo = (cast(Value*) GC.malloc(Value.sizeof * maxSize, attr))[0 .. maxSize];
            enum nwords = (maxSize + 8 * size_t.sizeof - 1) / (8 * size_t.sizeof);
            initialized = (cast(size_t*) GC.calloc(nwords * size_t.sizeof, attr | GC.BlkAttr.NO_SCAN))[0 .. nwords];
        }

        import core.bitop : bt, bts;
        import core.lifetime : emplace;

        size_t hash;
        foreach (ref arg; args)
            hash = hashOf(arg, hash);
        // cuckoo hashing
        immutable idx1 = hash % maxSize;
        if (!bt(initialized.ptr, idx1))
        {
            emplace(&memo[idx1], args, fun(args));
            // only set to initialized after setting args and value
            // https://issues.dlang.org/show_bug.cgi?id=14025
            bts(initialized.ptr, idx1);
            return memo[idx1].res;
        }
        else if (memo[idx1].args == args)
            return memo[idx1].res;
        // FNV prime
        immutable idx2 = (hash * 16_777_619) % maxSize;
        if (!bt(initialized.ptr, idx2))
        {
            emplace(&memo[idx2], memo[idx1]);
            bts(initialized.ptr, idx2);
        }
        else if (memo[idx2].args == args)
            return memo[idx2].res;
        else if (idx1 != idx2)
            memo[idx2] = memo[idx1];

        memo[idx1] = Value(args, fun(args));
        return memo[idx1].res;
    }
}

/**
 * To _memoize a recursive function, simply insert the memoized call in lieu of the plain recursive call.
 * For example, to transform the exponential-time Fibonacci implementation into a linear-time computation:
 */
@safe nothrow
unittest
{
    ulong fib(ulong n) @safe nothrow
    {
        return n < 2 ? n : memoize!fib(n - 2) + memoize!fib(n - 1);
    }
    assert(fib(10) == 55);
}

/**
 * To improve the speed of the factorial function,
 */
@safe unittest
{
    ulong fact(ulong n) @safe
    {
        return n < 2 ? 1 : n * memoize!fact(n - 1);
    }
    assert(fact(10) == 3628800);
}

/**
 * This memoizes all values of `fact` up to the largest argument. To only cache the final
 * result, move `memoize` outside the function as shown below.
 */
@safe unittest
{
    ulong factImpl(ulong n) @safe
    {
        return n < 2 ? 1 : n * factImpl(n - 1);
    }
    alias fact = memoize!factImpl;
    assert(fact(10) == 3628800);
}

/**
 * When the `maxSize` parameter is specified, memoize will used
 * a fixed size hash table to limit the number of cached entries.
 */
@system unittest // not @safe due to memoize
{
    ulong fact(ulong n)
    {
        // Memoize no more than 8 values
        return n < 2 ? 1 : n * memoize!(fact, 8)(n - 1);
    }
    assert(fact(8) == 40320);
    // using more entries than maxSize will overwrite existing entries
    assert(fact(10) == 3628800);
}

@system unittest // not @safe due to memoize
{
    import core.math : sqrt;
    alias msqrt = memoize!(function double(double x) { return sqrt(x); });
    auto y = msqrt(2.0);
    assert(y == msqrt(2.0));
    y = msqrt(4.0);
    assert(y == sqrt(4.0));

    // alias mrgb2cmyk = memoize!rgb2cmyk;
    // auto z = mrgb2cmyk([43, 56, 76]);
    // assert(z == mrgb2cmyk([43, 56, 76]));

    //alias mfib = memoize!fib;

    static ulong fib(ulong n) @safe
    {
        alias mfib = memoize!fib;
        return n < 2 ? 1 : mfib(n - 2) + mfib(n - 1);
    }

    auto z = fib(10);
    assert(z == 89);

    static ulong fact(ulong n) @safe
    {
        alias mfact = memoize!fact;
        return n < 2 ? 1 : n * mfact(n - 1);
    }
    assert(fact(10) == 3628800);

    // https://issues.dlang.org/show_bug.cgi?id=12568
    static uint len2(const string s) { // Error
    alias mLen2 = memoize!len2;
    if (s.length == 0)
        return 0;
    else
        return 1 + mLen2(s[1 .. $]);
    }

    int _func(int x) @safe { return 1; }
    alias func = memoize!(_func, 10);
    assert(func(int.init) == 1);
    assert(func(int.init) == 1);
}

// https://issues.dlang.org/show_bug.cgi?id=16079
// memoize should work with arrays
@system unittest // not @safe with -dip1000 due to memoize
{
    int executed = 0;
    T median(T)(const T[] nums) {
        import std.algorithm.sorting : sort;
        executed++;
        auto arr = nums.dup;
        arr.sort();
        if (arr.length % 2)
            return arr[$ / 2];
        else
            return (arr[$ / 2 - 1]
                + arr[$ / 2]) / 2;
    }

    alias fastMedian = memoize!(median!int);

    assert(fastMedian([7, 5, 3]) == 5);
    assert(fastMedian([7, 5, 3]) == 5);

    assert(executed == 1);
}

// https://issues.dlang.org/show_bug.cgi?id=16079: memoize should work with structs
@safe unittest
{
    int executed = 0;
    T pickFirst(T)(T first)
    {
        executed++;
        return first;
    }

    struct Foo { int k; }
    Foo A = Foo(3);

    alias first = memoize!(pickFirst!Foo);
    assert(first(Foo(3)) == A);
    assert(first(Foo(3)) == A);
    assert(executed == 1);
}

// https://issues.dlang.org/show_bug.cgi?id=20439 memoize should work with void opAssign
@safe unittest
{
    static struct S
    {
        void opAssign(S) {}
    }

    assert(memoize!(() => S()) == S());
}

// https://issues.dlang.org/show_bug.cgi?id=16079: memoize should work with classes
@system unittest // not @safe with -dip1000 due to memoize
{
    int executed = 0;
    T pickFirst(T)(T first)
    {
        executed++;
        return first;
    }

    class Bar
    {
        size_t k;
        this(size_t k)
        {
            this.k = k;
        }
        override size_t toHash()
        {
            return k;
        }
        override bool opEquals(Object o)
        {
            auto b = cast(Bar) o;
            return b && k == b.k;
        }
    }

    alias firstClass = memoize!(pickFirst!Bar);
    assert(firstClass(new Bar(3)).k == 3);
    assert(firstClass(new Bar(3)).k == 3);
    assert(executed == 1);
}

// https://issues.dlang.org/show_bug.cgi?id=20302
@system unittest
{
    version (none) // TODO change `none` to `all` and fix remaining limitations
        struct S { const int len; }
    else
        struct S { int len; }

    static       string  fun000(      string str,       S s) { return str[0 .. s.len] ~ "123"; }
    static       string  fun001(      string str, const S s) { return str[0 .. s.len] ~ "123"; }
    static       string  fun010(const string str,       S s) { return str[0 .. s.len] ~ "123"; }
    static       string  fun011(const string str, const S s) { return str[0 .. s.len] ~ "123"; }
    static const(string) fun100(      string str,       S s) { return str[0 .. s.len] ~ "123"; }
    static const(string) fun101(      string str, const S s) { return str[0 .. s.len] ~ "123"; }
    static const(string) fun110(const string str,       S s) { return str[0 .. s.len] ~ "123"; }
    static const(string) fun111(const string str, const S s) { return str[0 .. s.len] ~ "123"; }

    static foreach (fun; AliasSeq!(fun000, fun001, fun010, fun011, fun100, fun101, fun110, fun111))
    {{
        alias mfun = memoize!fun;
        assert(mfun("abcdefgh", S(3)) == "abc123");

        alias mfun2 = memoize!(fun, 42);
        assert(mfun2("asd", S(3)) == "asd123");
    }}
}

private struct DelegateFaker(F)
{
    import std.typecons : FuncInfo, MemberFunctionGenerator;

    // for @safe
    static F castToF(THIS)(THIS x) @trusted
    {
        return cast(F) x;
    }

    /*
     * What all the stuff below does is this:
     *--------------------
     * struct DelegateFaker(F) {
     *     extern(linkage)
     *     [ref] ReturnType!F doIt(Parameters!F args) [@attributes]
     *     {
     *         auto fp = cast(F) &this;
     *         return fp(args);
     *     }
     * }
     *--------------------
     */

    // We will use MemberFunctionGenerator in std.typecons.  This is a policy
    // configuration for generating the doIt().
    template GeneratingPolicy()
    {
        // Inform the genereator that we only have type information.
        enum WITHOUT_SYMBOL = true;

        // Generate the function body of doIt().
        template generateFunctionBody(unused...)
        {
            enum generateFunctionBody =
            // [ref] ReturnType doIt(Parameters args) @attributes
            q{
                // When this function gets called, the this pointer isn't
                // really a this pointer (no instance even really exists), but
                // a function pointer that points to the function to be called.
                // Cast it to the correct type and call it.

                auto fp = castToF(&this);
                return fp(args);
            };
        }
    }
    // Type information used by the generated code.
    alias FuncInfo_doIt = FuncInfo!(F);

    // Generate the member function doIt().
    mixin( MemberFunctionGenerator!(GeneratingPolicy!())
            .generateFunction!("FuncInfo_doIt", "doIt", F) );
}

/**
 * Convert a callable to a delegate with the same parameter list and
 * return type, avoiding heap allocations and use of auxiliary storage.
 *
 * Params:
 *     fp = a function pointer or an aggregate type with `opCall` defined.
 * Returns:
 *     A delegate with the context pointer pointing to nothing.
 *
 * Example:
 * ----
 * void doStuff() {
 *     writeln("Hello, world.");
 * }
 *
 * void runDelegate(void delegate() myDelegate) {
 *     myDelegate();
 * }
 *
 * auto delegateToPass = toDelegate(&doStuff);
 * runDelegate(delegateToPass);  // Calls doStuff, prints "Hello, world."
 * ----
 *
 * BUGS:
 * $(UL
 *   $(LI Does not work with `@safe` functions.)
 *   $(LI Ignores C-style / D-style variadic arguments.)
 * )
 */
auto toDelegate(F)(auto ref F fp)
if (isCallable!(F))
{
    static if (is(F == delegate))
    {
        return fp;
    }
    else static if (is(typeof(&F.opCall) == delegate)
                || (is(typeof(&F.opCall) V : V*) && is(V == function)))
    {
        return toDelegate(&fp.opCall);
    }
    else
    {
        alias DelType = typeof(&(new DelegateFaker!(F)).doIt);

        static struct DelegateFields {
            union {
                DelType del;
                //pragma(msg, typeof(del));

                struct {
                    void* contextPtr;
                    void* funcPtr;
                }
            }
        }

        // fp is stored in the returned delegate's context pointer.
        // The returned delegate's function pointer points to
        // DelegateFaker.doIt.
        DelegateFields df;

        df.contextPtr = cast(void*) fp;

        DelegateFaker!(F) dummy;
        auto dummyDel = &dummy.doIt;
        df.funcPtr = dummyDel.funcptr;

        return df.del;
    }
}

///
@system unittest
{
    static int inc(ref uint num) {
        num++;
        return 8675309;
    }

    uint myNum = 0;
    auto incMyNumDel = toDelegate(&inc);
    auto returnVal = incMyNumDel(myNum);
    assert(myNum == 1);
}

@system unittest // not @safe due to toDelegate
{
    static int inc(ref uint num) {
        num++;
        return 8675309;
    }

    uint myNum = 0;
    auto incMyNumDel = toDelegate(&inc);
    int delegate(ref uint) dg = incMyNumDel;
    auto returnVal = incMyNumDel(myNum);
    assert(myNum == 1);

    interface I { int opCall(); }
    class C: I { int opCall() { inc(myNum); return myNum;} }
    auto c = new C;
    auto i = cast(I) c;

    auto getvalc = toDelegate(c);
    assert(getvalc() == 2);

    auto getvali = toDelegate(i);
    assert(getvali() == 3);

    struct S1 { int opCall() { inc(myNum); return myNum; } }
    static assert(!is(typeof(&s1.opCall) == delegate));
    S1 s1;
    auto getvals1 = toDelegate(s1);
    assert(getvals1() == 4);

    struct S2 { static int opCall() { return 123456; } }
    static assert(!is(typeof(&S2.opCall) == delegate));
    S2 s2;
    auto getvals2 =&S2.opCall;
    assert(getvals2() == 123456);

    /* test for attributes */
    {
        static int refvar = 0xDeadFace;

        static ref int func_ref() { return refvar; }
        static int func_pure() pure { return 1; }
        static int func_nothrow() nothrow { return 2; }
        static int func_property() @property { return 3; }
        static int func_safe() @safe { return 4; }
        static int func_trusted() @trusted { return 5; }
        static int func_system() @system { return 6; }
        static int func_pure_nothrow() pure nothrow { return 7; }
        static int func_pure_nothrow_safe() pure nothrow @safe { return 8; }

        auto dg_ref = toDelegate(&func_ref);
        int delegate() pure dg_pure = toDelegate(&func_pure);
        int delegate() nothrow dg_nothrow = toDelegate(&func_nothrow);
        int delegate() @property dg_property = toDelegate(&func_property);
        int delegate() @safe dg_safe = toDelegate(&func_safe);
        int delegate() @trusted dg_trusted = toDelegate(&func_trusted);
        int delegate() @system dg_system = toDelegate(&func_system);
        int delegate() pure nothrow dg_pure_nothrow = toDelegate(&func_pure_nothrow);
        int delegate() @safe pure nothrow dg_pure_nothrow_safe = toDelegate(&func_pure_nothrow_safe);

        //static assert(is(typeof(dg_ref) == ref int delegate())); // [BUG@DMD]

        assert(dg_ref() == refvar);
        assert(dg_pure() == 1);
        assert(dg_nothrow() == 2);
        assert(dg_property() == 3);
        assert(dg_safe() == 4);
        assert(dg_trusted() == 5);
        assert(dg_system() == 6);
        assert(dg_pure_nothrow() == 7);
        assert(dg_pure_nothrow_safe() == 8);
    }
    /* test for linkage */
    {
        struct S
        {
            extern(C) static void xtrnC() {}
            extern(D) static void xtrnD() {}
        }
        auto dg_xtrnC = toDelegate(&S.xtrnC);
        auto dg_xtrnD = toDelegate(&S.xtrnD);
        static assert(! is(typeof(dg_xtrnC) == typeof(dg_xtrnD)));
    }
}

/**
 * Passes the fields of a struct as arguments to a function.
 *
 * Can be used with a $(LINK2 https://dlang.org/spec/expression.html#function_literals,
 * function literal) to give temporary names to the fields of a struct or
 * tuple.
 *
 * Params:
 *   fun = Callable that the struct's fields will be passed to.
 *
 * Returns:
 *   A function that accepts a single struct as an argument and passes its
 *   fields to `fun` when called.
 */
template bind(alias fun)
{
    /**
     * Params:
     *   args = The struct or tuple whose fields will be used as arguments.
     *
     * Returns: `fun(args.tupleof)`
     */
    auto ref bind(T)(auto ref T args)
    if (is(T == struct))
    {
        import std.meta : Map = staticMap;
        import core.lifetime : move;

        // Forwards the i'th member of `args`
        // Needed because core.lifetime.forward doesn't work on struct members
        template forwardArg(size_t i)
        {
            static if (__traits(isRef, args) || !is(typeof(move(args.tupleof[i]))))
                enum forwardArg = "args.tupleof[" ~ toCtString!i ~ "], ";
            else
                enum forwardArg = "move(args.tupleof[" ~ toCtString!i ~ "]), ";
        }

        static if (args.tupleof.length == 0)
            enum argList = "";
        else
            alias argList = Map!(forwardArg, Iota!(args.tupleof.length));

        return mixin("fun(", argList, ")");
    }
}

/// Giving names to tuple elements
@safe unittest
{
    import std.typecons : tuple;

    auto name = tuple("John", "Doe");
    string full = name.bind!((first, last) => first ~ " " ~ last);
    assert(full == "John Doe");
}

/// Passing struct fields to a function
@safe unittest
{
    import std.algorithm.comparison : min, max;

    struct Pair
    {
        int a;
        int b;
    }

    auto p = Pair(123, 456);
    assert(p.bind!min == 123); // min(p.a, p.b)
    assert(p.bind!max == 456); // max(p.a, p.b)
}

/// In a range pipeline
@safe unittest
{
    import std.algorithm.iteration : map, filter;
    import std.algorithm.comparison : equal;
    import std.typecons : tuple;

    auto ages = [
        tuple("Alice", 35),
        tuple("Bob",   64),
        tuple("Carol", 21),
        tuple("David", 39),
        tuple("Eve",   50)
    ];

    auto overForty = ages
        .filter!(bind!((name, age) => age > 40))
        .map!(bind!((name, age) => name));

    assert(overForty.equal(["Bob", "Eve"]));
}

// Zero arguments
@safe unittest
{
    struct Empty {}

    assert(Empty().bind!(() => 123) == 123);
}

// Non-copyable arguments
@safe unittest
{
    import std.typecons : tuple;

    static struct NoCopy
    {
        int n;
        @disable this(this);
    }

    static struct Pair
    {
        NoCopy a, b;
    }

    static auto fun(NoCopy a, NoCopy b)
    {
        return tuple(a.n, b.n);
    }

    auto expected = fun(NoCopy(1), NoCopy(2));
    assert(Pair(NoCopy(1), NoCopy(2)).bind!fun == expected);
}

// ref arguments
@safe unittest
{
    import std.typecons : tuple;

    auto t = tuple(123, 456);
    t.bind!((ref int a, int b) { a = 789; b = 1011; });

    assert(t[0] == 789);
    assert(t[1] == 456);
}

// auto ref arguments
@safe unittest
{
    import std.typecons : tuple;

    auto t = tuple(123);
    t.bind!((auto ref x) {
        static assert(__traits(isRef, x));
    });
    tuple(123).bind!((auto ref x) {
        static assert(!__traits(isRef, x));
    });
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // Written in the D programming language.

/**
Processing of command line options.

The getopt module implements a `getopt` function, which adheres to
the POSIX syntax for command line options. GNU extensions are
supported in the form of long options introduced by a double dash
("--"). Support for bundling of command line options, as was the case
with the more traditional single-letter approach, is provided but not
enabled by default.

Copyright: Copyright Andrei Alexandrescu 2008 - 2015.
License:   $(HTTP www.boost.org/LICENSE_1_0.txt, Boost License 1.0).
Authors:   $(HTTP erdani.org, Andrei Alexandrescu)
Credits:   This module and its documentation are inspired by Perl's
           $(HTTPS perldoc.perl.org/Getopt/Long.html, Getopt::Long) module. The syntax of
           D's `getopt` is simpler than its Perl counterpart because $(D
           getopt) infers the expected parameter types from the static types of
           the passed-in pointers.
Source:    $(PHOBOSSRC std/getopt.d)
*/
/*
         Copyright Andrei Alexandrescu 2008 - 2015.
Distributed under the Boost Software License, Version 1.0.
   (See accompanying file LICENSE_1_0.txt or copy at
         http://www.boost.org/LICENSE_1_0.txt)
*/
module std.getopt;

import std.exception : basicExceptionCtors;
import std.traits;

/**
Thrown on one of the following conditions:
$(UL
  $(LI An unrecognized command-line argument is passed, and
       `std.getopt.config.passThrough` was not present.)
  $(LI A command-line option was not found, and
       `std.getopt.config.required` was present.)
  $(LI A callback option is missing a value.)
)
*/
class GetOptException : Exception
{
    mixin basicExceptionCtors;
}

static assert(is(typeof(new GetOptException("message"))));
static assert(is(typeof(new GetOptException("message", Exception.init))));

/**
   Parse and remove command line options from a string array.

   Synopsis:

---------
import std.getopt;

string data = "file.dat";
int length = 24;
bool verbose;
enum Color { no, yes };
Color color;

void main(string[] args)
{
  auto helpInformation = getopt(
    args,
    "length",  &length,    // numeric
    "file",    &data,      // string
    "verbose", &verbose,   // flag
    "color", "Information about this color", &color);    // enum
  ...

  if (helpInformation.helpWanted)
  {
    defaultGetoptPrinter("Some information about the program.",
      helpInformation.options);
  }
}
---------

 The `getopt` function takes a reference to the command line
 (as received by `main`) as its first argument, and an
 unbounded number of pairs of strings and pointers. Each string is an
 option meant to "fill" the value referenced by the pointer to its
 right (the "bound" pointer). The option string in the call to
 `getopt` should not start with a dash.

 In all cases, the command-line options that were parsed and used by
 `getopt` are removed from `args`. Whatever in the
 arguments did not look like an option is left in `args` for
 further processing by the program. Values that were unaffected by the
 options are not touched, so a common idiom is to initialize options
 to their defaults and then invoke `getopt`. If a
 command-line argument is recognized as an option with a parameter and
 the parameter cannot be parsed properly (e.g., a number is expected
 but not present), a `ConvException` exception is thrown.
 If `std.getopt.config.passThrough` was not passed to `getopt`
 and an unrecognized command-line argument is found, or if a required
 argument is missing a `GetOptException` is thrown.

 Depending on the type of the pointer being bound, `getopt`
 recognizes the following kinds of options:

 $(OL
    $(LI $(I Boolean options). A lone argument sets the option to `true`.
    Additionally $(B true) or $(B false) can be set within the option separated
    with an "=" sign:

---------
  bool verbose = false, debugging = true;
  getopt(args, "verbose", &verbose, "debug", &debugging);
---------

    To set `verbose` to `true`, invoke the program with either
    `--verbose` or `--verbose=true`.

    To set `debugging` to `false`, invoke the program with
    `--debugging=false`.
    )

    $(LI $(I Numeric options.) If an option is bound to a numeric type, a
    number is expected as the next option, or right within the option separated
    with an "=" sign:

---------
  uint timeout;
  getopt(args, "timeout", &timeout);
---------

    To set `timeout` to `5`, invoke the program with either
    `--timeout=5` or $(D --timeout 5).
    )

    $(LI $(I Incremental options.) If an option name has a "+" suffix and is
    bound to a numeric type, then the option's value tracks the number of times
    the option occurred on the command line:

---------
  uint paranoid;
  getopt(args, "paranoid+", &paranoid);
---------

    Invoking the program with "--paranoid --paranoid --paranoid" will set $(D
    paranoid) to 3. Note that an incremental option never expects a parameter,
    e.g., in the command line "--paranoid 42 --paranoid", the "42" does not set
    `paranoid` to 42; instead, `paranoid` is set to 2 and "42" is not
    considered as part of the normal program arguments.
    )

    $(LI $(I Enum options.) If an option is bound to an enum, an enum symbol as
    a string is expected as the next option, or right within the option
    separated with an "=" sign:

---------
  enum Color { no, yes };
  Color color; // default initialized to Color.no
  getopt(args, "color", &color);
---------

    To set `color` to `Color.yes`, invoke the program with either
    `--color=yes` or $(D --color yes).
    )

    $(LI $(I String options.) If an option is bound to a string, a string is
    expected as the next option, or right within the option separated with an
    "=" sign:

---------
string outputFile;
getopt(args, "output", &outputFile);
---------

    Invoking the program with "--output=myfile.txt" or "--output myfile.txt"
    will set `outputFile` to "myfile.txt". If you want to pass a string
    containing spaces, you need to use the quoting that is appropriate to your
    shell, e.g. --output='my file.txt'.
    )

    $(LI $(I Array options.) If an option is bound to an array, a new element
    is appended to the array each time the option occurs:

---------
string[] outputFiles;
getopt(args, "output", &outputFiles);
---------

    Invoking the program with "--output=myfile.txt --output=yourfile.txt" or
    "--output myfile.txt --output yourfile.txt" will set `outputFiles` to
    $(D [ "myfile.txt", "yourfile.txt" ]).

    Alternatively you can set $(LREF arraySep) to allow multiple elements in
    one parameter.

---------
string[] outputFiles;
arraySep = ",";  // defaults to "", meaning one element per parameter
getopt(args, "output", &outputFiles);
---------

    With the above code you can invoke the program with
    "--output=myfile.txt,yourfile.txt", or "--output myfile.txt,yourfile.txt".)

    $(LI $(I Hash options.) If an option is bound to an associative array, a
    string of the form "name=value" is expected as the next option, or right
    within the option separated with an "=" sign:

---------
double[string] tuningParms;
getopt(args, "tune", &tuningParms);
---------

    Invoking the program with e.g. "--tune=alpha=0.5 --tune beta=0.6" will set
    `tuningParms` to [ "alpha" : 0.5, "beta" : 0.6 ].

    Alternatively you can set $(LREF arraySep) as the element separator:

---------
double[string] tuningParms;
arraySep = ",";  // defaults to "", meaning one element per parameter
getopt(args, "tune", &tuningParms);
---------

    With the above code you can invoke the program with
    "--tune=alpha=0.5,beta=0.6", or "--tune alpha=0.5,beta=0.6".

    In general, the keys and values can be of any parsable types.
    )

    $(LI $(I Callback options.) An option can be bound to a function or
    delegate with the signature $(D void function()), $(D void function(string
    option)), $(D void function(string option, string value)), or their
    delegate equivalents.

    $(UL
        $(LI If the callback doesn't take any arguments, the callback is
        invoked whenever the option is seen.
        )

        $(LI If the callback takes one string argument, the option string
        (without the leading dash(es)) is passed to the callback.  After that,
        the option string is considered handled and removed from the options
        array.

---------
void main(string[] args)
{
  uint verbosityLevel = 1;
  void myHandler(string option)
  {
    if (option == "quiet")
    {
      verbosityLevel = 0;
    }
    else
    {
      assert(option == "verbose");
      verbosityLevel = 2;
    }
  }
  getopt(args, "verbose", &myHandler, "quiet", &myHandler);
}
---------

        )

        $(LI If the callback takes two string arguments, the option string is
        handled as an option with one argument, and parsed accordingly. The
        option and its value are passed to the callback. After that, whatever
        was passed to the callback is considered handled and removed from the
        list.

---------
int main(string[] args)
{
  uint verbosityLevel = 1;
  bool handlerFailed = false;
  void myHandler(string option, string value)
  {
    switch (value)
    {
      case "quiet": verbosityLevel = 0; break;
      case "verbose": verbosityLevel = 2; break;
      case "shouting": verbosityLevel = verbosityLevel.max; break;
      default :
        stderr.writeln("Unknown verbosity level ", value);
        handlerFailed = true;
        break;
    }
  }
  getopt(args, "verbosity", &myHandler);
  return handlerFailed ? 1 : 0;
}
---------
        )
    ))
)

Options_with_multiple_names:
Sometimes option synonyms are desirable, e.g. "--verbose",
"--loquacious", and "--garrulous" should have the same effect. Such
alternate option names can be included in the option specification,
using "|" as a separator:

---------
bool verbose;
getopt(args, "verbose|loquacious|garrulous", &verbose);
---------

Case:
By default options are case-insensitive. You can change that behavior
by passing `getopt` the `caseSensitive` directive like this:

---------
bool foo, bar;
getopt(args,
    std.getopt.config.caseSensitive,
    "foo", &foo,
    "bar", &bar);
---------

In the example above, "--foo" and "--bar" are recognized, but "--Foo", "--Bar",
"--FOo", "--bAr", etc. are rejected.
The directive is active until the end of `getopt`, or until the
converse directive `caseInsensitive` is encountered:

---------
bool foo, bar;
getopt(args,
    std.getopt.config.caseSensitive,
    "foo", &foo,
    std.getopt.config.caseInsensitive,
    "bar", &bar);
---------

The option "--Foo" is rejected due to $(D
std.getopt.config.caseSensitive), but not "--Bar", "--bAr"
etc. because the directive $(D
std.getopt.config.caseInsensitive) turned sensitivity off before
option "bar" was parsed.

Short_versus_long_options:
Traditionally, programs accepted single-letter options preceded by
only one dash (e.g. `-t`). `getopt` accepts such parameters
seamlessly. When used with a double-dash (e.g. `--t`), a
single-letter option behaves the same as a multi-letter option. When
used with a single dash, a single-letter option is accepted.

To set `timeout` to `5`, use either of the following: `--timeout=5`,
`--timeout 5`, `--t=5`, `--t 5`, `-t5`, or `-t 5`. Forms such as
`-timeout=5` will be not accepted.

For more details about short options, refer also to the next section.

Bundling:
Single-letter options can be bundled together, i.e. "-abc" is the same as
$(D "-a -b -c"). By default, this option is turned off. You can turn it on
with the `std.getopt.config.bundling` directive:

---------
bool foo, bar;
getopt(args,
    std.getopt.config.bundling,
    "foo|f", &foo,
    "bar|b", &bar);
---------

In case you want to only enable bundling for some of the parameters,
bundling can be turned off with `std.getopt.config.noBundling`.

Required:
An option can be marked as required. If that option is not present in the
arguments an exception will be thrown.

---------
bool foo, bar;
getopt(args,
    std.getopt.config.required,
    "foo|f", &foo,
    "bar|b", &bar);
---------

Only the option directly following `std.getopt.config.required` is
required.

Passing_unrecognized_options_through:
If an application needs to do its own processing of whichever arguments
`getopt` did not understand, it can pass the
`std.getopt.config.passThrough` directive to `getopt`:

---------
bool foo, bar;
getopt(args,
    std.getopt.config.passThrough,
    "foo", &foo,
    "bar", &bar);
---------

An unrecognized option such as "--baz" will be found untouched in
`args` after `getopt` returns.

Help_Information_Generation:
If an option string is followed by another string, this string serves as a
description for this option. The `getopt` function returns a struct of type
`GetoptResult`. This return value contains information about all passed options
as well a $(D bool GetoptResult.helpWanted) flag indicating whether information
about these options was requested. The `getopt` function always adds an option for
`--help|-h` to set the flag if the option is seen on the command line.

Options_Terminator:
A lone double-dash terminates `getopt` gathering. It is used to
separate program options from other parameters (e.g., options to be passed
to another program). Invoking the example above with $(D "--foo -- --bar")
parses foo but leaves "--bar" in `args`. The double-dash itself is
removed from the argument array unless the `std.getopt.config.keepEndOfOptions`
directive is given.
*/
GetoptResult getopt(T...)(ref string[] args, T opts)
{
    import std.exception : enforce;
    enforce(args.length,
            "Invalid arguments string passed: program name missing");
    configuration cfg;
    GetoptResult rslt;

    GetOptException excep;
    void[][string] visitedLongOpts, visitedShortOpts;
    getoptImpl(args, cfg, rslt, excep, visitedLongOpts, visitedShortOpts, opts);

    if (!rslt.helpWanted && excep !is null)
    {
        throw excep;
    }

    return rslt;
}

///
@safe unittest
{
    auto args = ["prog", "--foo", "-b"];

    bool foo;
    bool bar;
    auto rslt = getopt(args, "foo|f", "Some information about foo.", &foo, "bar|b",
        "Some help message about bar.", &bar);

    if (rslt.helpWanted)
    {
        defaultGetoptPrinter("Some information about the program.",
            rslt.options);
    }
}

/**
   Configuration options for `getopt`.

   You can pass them to `getopt` in any position, except in between an option
   string and its bound pointer.
*/
enum config {
    /// Turn case sensitivity on
    caseSensitive,
    /// Turn case sensitivity off (default)
    caseInsensitive,
    /// Turn bundling on
    bundling,
    /// Turn bundling off (default)
    noBundling,
    /// Pass unrecognized arguments through
    passThrough,
    /// Signal unrecognized arguments as errors (default)
    noPassThrough,
    /// Stop at first argument that does not look like an option
    stopOnFirstNonOption,
    /// Do not erase the endOfOptions separator from args
    keepEndOfOptions,
    /// Make the next option a required option
    required
}

/** The result of the `getopt` function.

`helpWanted` is set if the option `--help` or `-h` was passed to the option parser.
*/
struct GetoptResult {
    bool helpWanted; /// Flag indicating if help was requested
    Option[] options; /// All possible options
}

/** Information about an option.
*/
struct Option {
    string optShort; /// The short symbol for this option
    string optLong; /// The long symbol for this option
    string help; /// The description of this option
    bool required; /// If a option is required, not passing it will result in an error
}

private pure Option splitAndGet(string opt) @trusted nothrow
{
    import std.array : split;
    auto sp = split(opt, "|");
    Option ret;
    if (sp.length > 1)
    {
        ret.optShort = "-" ~ (sp[0].length < sp[1].length ?
            sp[0] : sp[1]);
        ret.optLong = "--" ~ (sp[0].length > sp[1].length ?
            sp[0] : sp[1]);
    }
    else if (sp[0].length > 1)
    {
        ret.optLong = "--" ~ sp[0];
    }
    else
    {
        ret.optShort = "-" ~ sp[0];
    }

    return ret;
}

@safe unittest
{
    auto oshort = splitAndGet("f");
    assert(oshort.optShort == "-f");
    assert(oshort.optLong == "");

    auto olong = splitAndGet("foo");
    assert(olong.optShort == "");
    assert(olong.optLong == "--foo");

    auto oshortlong = splitAndGet("f|foo");
    assert(oshortlong.optShort == "-f");
    assert(oshortlong.optLong == "--foo");

    auto olongshort = splitAndGet("foo|f");
    assert(olongshort.optShort == "-f");
    assert(olongshort.optLong == "--foo");
}

/*
This function verifies that the variadic parameters passed in getOpt
follow this pattern:

  [config override], option, [description], receiver,

 - config override: a config value, optional
 - option:          a string or a char
 - description:     a string, optional
 - receiver:        a pointer or a callable
*/
private template optionValidator(A...)
{
    import std.format : format;

    enum fmt = "getopt validator: %s (at position %d)";
    enum isReceiver(T) = is(T == U*, U) || (is(T == function)) || (is(T == delegate));
    enum isOptionStr(T) = isSomeString!T || isSomeChar!T;

    auto validator()
    {
        string msg;
        static if (A.length > 0)
        {
            static if (isReceiver!(A[0]))
            {
                msg = format(fmt, "first argument must be a string or a config", 0);
            }
            else static if (!isOptionStr!(A[0]) && !is(A[0] == config))
            {
                msg = format(fmt, "invalid argument type: " ~ A[0].stringof, 0);
            }
            else
            {
                static foreach (i; 1 .. A.length)
                {
                    static if (!isReceiver!(A[i]) && !isOptionStr!(A[i]) &&
                        !(is(A[i] == config)))
                    {
                        msg = format(fmt, "invalid argument type: " ~ A[i].stringof, i);
                        goto end;
                    }
                    else static if (isReceiver!(A[i]) && !isOptionStr!(A[i-1]))
                    {
                        msg = format(fmt, "a receiver can not be preceeded by a receiver", i);
                        goto end;
                    }
                    else static if (i > 1 && isOptionStr!(A[i]) && isOptionStr!(A[i-1])
                        && isSomeString!(A[i-2]))
                    {
                        msg = format(fmt, "a string can not be preceeded by two strings", i);
                        goto end;
                    }
                }
            }
            static if (!isReceiver!(A[$-1]) && !is(A[$-1] == config))
            {
                msg = format(fmt, "last argument must be a receiver or a config",
                    A.length -1);
            }
        }
    end:
        return msg;
    }
    enum message = validator;
    alias optionValidator = message;
}

@safe pure unittest
{
    alias P = void*;
    alias S = string;
    alias A = char;
    alias C = config;
    alias F = void function();

    static assert(optionValidator!(S,P) == "");
    static assert(optionValidator!(S,F) == "");
    static assert(optionValidator!(A,P) == "");
    static assert(optionValidator!(A,F) == "");

    static assert(optionValidator!(C,S,P) == "");
    static assert(optionValidator!(C,S,F) == "");
    static assert(optionValidator!(C,A,P) == "");
    static assert(optionValidator!(C,A,F) == "");

    static assert(optionValidator!(C,S,S,P) == "");
    static assert(optionValidator!(C,S,S,F) == "");
    static assert(optionValidator!(C,A,S,P) == "");
    static assert(optionValidator!(C,A,S,F) == "");

    static assert(optionValidator!(C,S,S,P) == "");
    static assert(optionValidator!(C,S,S,P,C,S,F) == "");
    static assert(optionValidator!(C,S,P,C,S,S,F) == "");

    static assert(optionValidator!(C,A,P,A,S,F) == "");
    static assert(optionValidator!(C,A,P,C,A,S,F) == "");

    static assert(optionValidator!(P,S,S) != "");
    static assert(optionValidator!(P,P,S) != "");
    static assert(optionValidator!(P,F,S,P) != "");
    static assert(optionValidator!(C,C,S) != "");
    static assert(optionValidator!(S,S,P,S,S,P,S) != "");
    static assert(optionValidator!(S,S,P,P) != "");
    static assert(optionValidator!(S,S,S,P) != "");

    static assert(optionValidator!(C,A,S,P,C,A,F) == "");
    static assert(optionValidator!(C,A,P,C,A,S,F) == "");
}

// https://issues.dlang.org/show_bug.cgi?id=15914
@safe unittest
{
    import std.exception : assertThrown;
    bool opt;
    string[] args = ["program", "-a"];
    getopt(args, config.passThrough, 'a', &opt);
    assert(opt);
    opt = false;
    args = ["program", "-a"];
    getopt(args, 'a', &opt);
    assert(opt);
    opt = false;
    args = ["program", "-a"];
    getopt(args, 'a', "help string", &opt);
    assert(opt);
    opt = false;
    args = ["program", "-a"];
    getopt(args, config.caseSensitive, 'a', "help string", &opt);
    assert(opt);

    assertThrown(getopt(args, "", "forgot to put a string", &opt));
}

private void getoptImpl(T...)(ref string[] args, ref configuration cfg,
    ref GetoptResult rslt, ref GetOptException excep,
    void[][string] visitedLongOpts, void[][string] visitedShortOpts, T opts)
{
    enum validationMessage = optionValidator!T;
    static assert(validationMessage == "", validationMessage);

    import std.algorithm.mutation : remove;
    import std.conv : to;
    import std.uni : toLower;
    static if (opts.length)
    {
        static if (is(typeof(opts[0]) : config))
        {
            // it's a configuration flag, act on it
            setConfig(cfg, opts[0]);
            return getoptImpl(args, cfg, rslt, excep, visitedLongOpts,
                visitedShortOpts, opts[1 .. $]);
        }
        else
        {
            // it's an option string
            auto option = to!string(opts[0]);
            if (option.length == 0)
            {
                excep = new GetOptException("An option name may not be an empty string", excep);
                return;
            }
            Option optionHelp = splitAndGet(option);
            optionHelp.required = cfg.required;

            if (optionHelp.optLong.length)
            {
                auto name = optionHelp.optLong;
                if (!cfg.caseSensitive)
                    name = name.toLower();
                assert(name !in visitedLongOpts,
                    "Long option " ~ optionHelp.optLong ~ " is multiply defined");

                visitedLongOpts[optionHelp.optLong] = [];
            }

            if (optionHelp.optShort.length)
            {
                auto name = optionHelp.optShort;
                if (!cfg.caseSensitive)
                    name = name.toLower();
                assert(name !in visitedShortOpts,
                    "Short option " ~ optionHelp.optShort
                    ~ " is multiply defined");

                visitedShortOpts[optionHelp.optShort] = [];
            }

            static if (is(typeof(opts[1]) : string))
            {
                alias receiver = opts[2];
                optionHelp.help = opts[1];
                immutable lowSliceIdx = 3;
            }
            else
            {
                alias receiver = opts[1];
                immutable lowSliceIdx = 2;
            }

            rslt.options ~= optionHelp;

            bool incremental;
            // Handle options of the form --blah+
            if (option.length && option[$ - 1] == autoIncrementChar)
            {
                option = option[0 .. $ - 1];
                incremental = true;
            }

            bool optWasHandled = handleOption(option, receiver, args, cfg, incremental);

            if (cfg.required && !optWasHandled)
            {
                excep = new GetOptException("Required option "
                    ~ option ~ " was not supplied", excep);
            }
            cfg.required = false;

            getoptImpl(args, cfg, rslt, excep, visitedLongOpts,
                visitedShortOpts, opts[lowSliceIdx .. $]);
        }
    }
    else
    {
        // no more options to look for, potentially some arguments left
        for (size_t i = 1; i < args.length;)
        {
            auto a = args[i];
            if (endOfOptions.length && a == endOfOptions)
            {
                // Consume the "--" if keepEndOfOptions is not specified
                if (!cfg.keepEndOfOptions)
                    args = args.remove(i);
                break;
            }
            if (a.length < 2 || a[0] != optionChar)
            {
                // not an option
                if (cfg.stopOnFirstNonOption) break;
                ++i;
                continue;
            }
            if (a == "--help" || a == "-h")
            {
                rslt.helpWanted = true;
                args = args.remove(i);
                continue;
            }
            if (!cfg.passThrough)
            {
                throw new GetOptException("Unrecognized option "~a, excep);
            }
            ++i;
        }

        Option helpOpt;
        helpOpt.optShort = "-h";
        helpOpt.optLong = "--help";
        helpOpt.help = "This help information.";
        rslt.options ~= helpOpt;
    }
}

private bool handleOption(R)(string option, R receiver, ref string[] args,
    ref configuration cfg, bool incremental)
{
    import std.algorithm.iteration : map, splitter;
    import std.ascii : isAlpha;
    import std.conv : text, to;
    // Scan arguments looking for a match for this option
    bool ret = false;
    for (size_t i = 1; i < args.length; )
    {
        auto a = args[i];
        if (endOfOptions.length && a == endOfOptions) break;
        if (cfg.stopOnFirstNonOption && (!a.length || a[0] != optionChar))
        {
            // first non-option is end of options
            break;
        }
        // Unbundle bundled arguments if necessary
        if (cfg.bundling && a.length > 2 && a[0] == optionChar &&
                a[1] != optionChar)
        {
            string[] expanded;
            foreach (j, dchar c; a[1 .. $])
            {
                // If the character is not alpha, stop right there. This allows
                // e.g. -j100 to work as "pass argument 100 to option -j".
                if (!isAlpha(c))
                {
                    if (c == '=')
                        j++;
                    expanded ~= a[j + 1 .. $];
                    break;
                }
                expanded ~= text(optionChar, c);
            }
            args = args[0 .. i] ~ expanded ~ args[i + 1 .. $];
            continue;
        }

        string val;
        if (!optMatch(a, option, val, cfg))
        {
            ++i;
            continue;
        }

        ret = true;

        // found it
        // from here on, commit to eat args[i]
        // (and potentially args[i + 1] too, but that comes later)
        args = args[0 .. i] ~ args[i + 1 .. $];

        static if (is(typeof(*receiver) == bool))
        {
            if (val.length)
            {
                // parse '--b=true/false'
                *receiver = to!(typeof(*receiver))(val);
            }
            else
            {
                // no argument means set it to true
                *receiver = true;
            }
        }
        else
        {
            import std.exception : enforce;
            // non-boolean option, which might include an argument
            enum isCallbackWithLessThanTwoParameters =
                (is(typeof(receiver) == delegate) || is(typeof(*receiver) == function)) &&
                !is(typeof(receiver("", "")));
            if (!isCallbackWithLessThanTwoParameters && !(val.length) && !incremental)
            {
                // Eat the next argument too.  Check to make sure there's one
                // to be eaten first, though.
                enforce!GetOptException(i < args.length,
                    "Missing value for argument " ~ a ~ ".");
                val = args[i];
                args = args[0 .. i] ~ args[i + 1 .. $];
            }
            static if (is(typeof(*receiver) == enum))
            {
                *receiver = to!(typeof(*receiver))(val);
            }
            else static if (is(typeof(*receiver) : real))
            {
                // numeric receiver
                if (incremental) ++*receiver;
                else *receiver = to!(typeof(*receiver))(val);
            }
            else static if (is(typeof(*receiver) == string))
            {
                // string receiver
                *receiver = to!(typeof(*receiver))(val);
            }
            else static if (is(typeof(receiver) == delegate) ||
                            is(typeof(*receiver) == function))
            {
                static if (is(typeof(receiver("", "")) : void))
                {
                    // option with argument
                    receiver(option, val);
                }
                else static if (is(typeof(receiver("")) : void))
                {
                    alias RType = typeof(receiver(""));
                    static assert(is(RType : void),
                            "Invalid receiver return type " ~ RType.stringof);
                    // boolean-style receiver
                    receiver(option);
                }
                else
                {
                    alias RType = typeof(receiver());
                    static assert(is(RType : void),
                            "Invalid receiver return type " ~ RType.stringof);
                    // boolean-style receiver without argument
                    receiver();
                }
            }
            else static if (isArray!(typeof(*receiver)))
            {
                // array receiver
                import std.range : ElementEncodingType;
                alias E = ElementEncodingType!(typeof(*receiver));

                if (arraySep == "")
                {
                    *receiver ~= to!E(val);
                }
                else
                {
                    foreach (elem; val.splitter(arraySep).map!(a => to!E(a))())
                        *receiver ~= elem;
                }
            }
            else static if (isAssociativeArray!(typeof(*receiver)))
            {
                // hash receiver
                alias K = typeof(receiver.keys[0]);
                alias V = typeof(receiver.values[0]);

                import std.range : only;
                import std.string : indexOf;
                import std.typecons : Tuple, tuple;

                static Tuple!(K, V) getter(string input)
                {
                    auto j = indexOf(input, assignChar);
                    enforce!GetOptException(j != -1, "Could not find '"
                        ~ to!string(assignChar) ~ "' in argument '" ~ input ~ "'.");
                    auto key = input[0 .. j];
                    auto value = input[j + 1 .. $];
                    return tuple(to!K(key), to!V(value));
                }

                static void setHash(Range)(R receiver, Range range)
                {
                    foreach (k, v; range.map!getter)
                        (*receiver)[k] = v;
                }

                if (arraySep == "")
                    setHash(receiver, val.only);
                else
                    setHash(receiver, val.splitter(arraySep));
            }
            else
                static assert(false, "getopt does not know how to handle the type " ~ typeof(receiver).stringof);
        }
    }

    return ret;
}

// https://issues.dlang.org/show_bug.cgi?id=17574
@safe unittest
{
    import std.algorithm.searching : startsWith;

    try
    {
        string[string] mapping;
        immutable as = arraySep;
        arraySep = ",";
        scope (exit)
            arraySep = as;
        string[] args = ["testProgram", "-m", "a=b,c=\"d,e,f\""];
        args.getopt("m", &mapping);
        assert(false, "Exception not thrown");
    }
    catch (GetOptException goe)
        assert(goe.msg.startsWith("Could not find"));
}

// https://issues.dlang.org/show_bug.cgi?id=5316 - arrays with arraySep
@safe unittest
{
    import std.conv;

    arraySep = ",";
    scope (exit) arraySep = "";

    string[] names;
    auto args = ["program.name", "-nfoo,bar,baz"];
    getopt(args, "name|n", &names);
    assert(names == ["foo", "bar", "baz"], to!string(names));

    names = names.init;
    args = ["program.name", "-n", "foo,bar,baz"];
    getopt(args, "name|n", &names);
    assert(names == ["foo", "bar", "baz"], to!string(names));

    names = names.init;
    args = ["program.name", "--name=foo,bar,baz"];
    getopt(args, "name|n", &names);
    assert(names == ["foo", "bar", "baz"], to!string(names));

    names = names.init;
    args = ["program.name", "--name", "foo,bar,baz"];
    getopt(args, "name|n", &names);
    assert(names == ["foo", "bar", "baz"], to!string(names));
}

// https://issues.dlang.org/show_bug.cgi?id=5316 - associative arrays with arraySep
@safe unittest
{
    import std.conv;

    arraySep = ",";
    scope (exit) arraySep = "";

    int[string] values;
    values = values.init;
    auto args = ["program.name", "-vfoo=0,bar=1,baz=2"];
    getopt(args, "values|v", &values);
    assert(values == ["foo":0, "bar":1, "baz":2], to!string(values));

    values = values.init;
    args = ["program.name", "-v", "foo=0,bar=1,baz=2"];
    getopt(args, "values|v", &values);
    assert(values == ["foo":0, "bar":1, "baz":2], to!string(values));

    values = values.init;
    args = ["program.name", "--values=foo=0,bar=1,baz=2"];
    getopt(args, "values|t", &values);
    assert(values == ["foo":0, "bar":1, "baz":2], to!string(values));

    values = values.init;
    args = ["program.name", "--values", "foo=0,bar=1,baz=2"];
    getopt(args, "values|v", &values);
    assert(values == ["foo":0, "bar":1, "baz":2], to!string(values));
}

/**
   The option character (default '-').

   Defaults to '-' but it can be assigned to prior to calling `getopt`.
 */
dchar optionChar = '-';

/**
   The string that conventionally marks the end of all options (default '--').

   Defaults to "--" but can be assigned to prior to calling `getopt`. Assigning an
   empty string to `endOfOptions` effectively disables it.
 */
string endOfOptions = "--";

/**
   The assignment character used in options with parameters (default '=').

   Defaults to '=' but can be assigned to prior to calling `getopt`.
 */
dchar assignChar = '=';

/**
   When set to "", parameters to array and associative array receivers are
   treated as an individual argument. That is, only one argument is appended or
   inserted per appearance of the option switch. If `arraySep` is set to
   something else, then each parameter is first split by the separator, and the
   individual pieces are treated as arguments to the same option.

   Defaults to "" but can be assigned to prior to calling `getopt`.
 */
string arraySep = "";

private enum autoIncrementChar = '+';

private struct configuration
{
    import std.bitmanip : bitfields;
    mixin(bitfields!(
                bool, "caseSensitive",  1,
                bool, "bundling", 1,
                bool, "passThrough", 1,
                bool, "stopOnFirstNonOption", 1,
                bool, "keepEndOfOptions", 1,
                bool, "required", 1,
                ubyte, "", 2));
}

private bool optMatch(string arg, scope string optPattern, ref string value,
    configuration cfg) @safe
{
    import std.algorithm.iteration : splitter;
    import std.string : indexOf;
    import std.uni : icmp;
    //writeln("optMatch:\n  ", arg, "\n  ", optPattern, "\n  ", value);
    //scope(success) writeln("optMatch result: ", value);
    if (arg.length < 2 || arg[0] != optionChar) return false;
    // yank the leading '-'
    arg = arg[1 .. $];
    immutable isLong = arg.length > 1 && arg[0] == optionChar;
    //writeln("isLong: ", isLong);
    // yank the second '-' if present
    if (isLong) arg = arg[1 .. $];
    immutable eqPos = indexOf(arg, assignChar);
    if (isLong && eqPos >= 0)
    {
        // argument looks like --opt=value
        value = arg[eqPos + 1 .. $];
        arg = arg[0 .. eqPos];
    }
    else
    {
        if (!isLong && eqPos == 1)
        {
            // argument looks like -o=value
            value = arg[2 .. $];
            arg = arg[0 .. 1];
        }
        else
        if (!isLong && !cfg.bundling)
        {
            // argument looks like -ovalue and there's no bundling
            value = arg[1 .. $];
            arg = arg[0 .. 1];
        }
        else
        {
            // argument looks like --opt, or -oxyz with bundling
            value = null;
        }
    }
    //writeln("Arg: ", arg, " pattern: ", optPattern, " value: ", value);
    // Split the option
    foreach (v; splitter(optPattern, "|"))
    {
        //writeln("Trying variant: ", v, " against ", arg);
        if (arg == v || (!cfg.caseSensitive && icmp(arg, v) == 0))
            return true;
        if (cfg.bundling && !isLong && v.length == 1
                && indexOf(arg, v) >= 0)
        {
            //writeln("success");
            return true;
        }
    }
    return false;
}

private void setConfig(ref configuration cfg, config option) @safe pure nothrow @nogc
{
    final switch (option)
    {
    case config.caseSensitive: cfg.caseSensitive = true; break;
    case config.caseInsensitive: cfg.caseSensitive = false; break;
    case config.bundling: cfg.bundling = true; break;
    case config.noBundling: cfg.bundling = false; break;
    case config.passThrough: cfg.passThrough = true; break;
    case config.noPassThrough: cfg.passThrough = false; break;
    case config.required: cfg.required = true; break;
    case config.stopOnFirstNonOption:
        cfg.stopOnFirstNonOption = true; break;
    case config.keepEndOfOptions:
        cfg.keepEndOfOptions = true; break;
    }
}

@safe unittest
{
    import std.conv;
    import std.math.operations : isClose;

    uint paranoid = 2;
    string[] args = ["program.name", "--paranoid", "--paranoid", "--paranoid"];
    getopt(args, "paranoid+", &paranoid);
    assert(paranoid == 5, to!(string)(paranoid));

    enum Color { no, yes }
    Color color;
    args = ["program.name", "--color=yes",];
    getopt(args, "color", &color);
    assert(color, to!(string)(color));

    color = Color.no;
    args = ["program.name", "--color", "yes",];
    getopt(args, "color", &color);
    assert(color, to!(string)(color));

    string data = "file.dat";
    int length = 24;
    bool verbose = false;
    args = ["program.name", "--length=5", "--file", "dat.file", "--verbose"];
    getopt(
        args,
        "length",  &length,
        "file",    &data,
        "verbose", &verbose);
    assert(args.length == 1);
    assert(data == "dat.file");
    assert(length == 5);
    assert(verbose);

    //
    string[] outputFiles;
    args = ["program.name", "--output=myfile.txt", "--output", "yourfile.txt"];
    getopt(args, "output", &outputFiles);
    assert(outputFiles.length == 2
           && outputFiles[0] == "myfile.txt" && outputFiles[1] == "yourfile.txt");

    outputFiles = [];
    arraySep = ",";
    args = ["program.name", "--output", "myfile.txt,yourfile.txt"];
    getopt(args, "output", &outputFiles);
    assert(outputFiles.length == 2
           && outputFiles[0] == "myfile.txt" && outputFiles[1] == "yourfile.txt");
    arraySep = "";

    foreach (testArgs;
        [["program.name", "--tune=alpha=0.5", "--tune", "beta=0.6"],
         ["program.name", "--tune=alpha=0.5,beta=0.6"],
         ["program.name", "--tune", "alpha=0.5,beta=0.6"]])
    {
        arraySep = ",";
        double[string] tuningParms;
        getopt(testArgs, "tune", &tuningParms);
        assert(testArgs.length == 1);
        assert(tuningParms.length == 2);
        assert(isClose(tuningParms["alpha"], 0.5));
        assert(isClose(tuningParms["beta"], 0.6));
        arraySep = "";
    }

    uint verbosityLevel = 1;
    void myHandler(string option)
    {
        if (option == "quiet")
        {
            verbosityLevel = 0;
        }
        else
        {
            assert(option == "verbose");
            verbosityLevel = 2;
        }
    }
    args = ["program.name", "--quiet"];
    getopt(args, "verbose", &myHandler, "quiet", &myHandler);
    assert(verbosityLevel == 0);
    args = ["program.name", "--verbose"];
    getopt(args, "verbose", &myHandler, "quiet", &myHandler);
    assert(verbosityLevel == 2);

    verbosityLevel = 1;
    void myHandler2(string option, string value)
    {
        assert(option == "verbose");
        verbosityLevel = 2;
    }
    args = ["program.name", "--verbose", "2"];
    getopt(args, "verbose", &myHandler2);
    assert(verbosityLevel == 2);

    verbosityLevel = 1;
    void myHandler3()
    {
        verbosityLevel = 2;
    }
    args = ["program.name", "--verbose"];
    getopt(args, "verbose", &myHandler3);
    assert(verbosityLevel == 2);

    bool foo, bar;
    args = ["program.name", "--foo", "--bAr"];
    getopt(args,
        std.getopt.config.caseSensitive,
        std.getopt.config.passThrough,
        "foo", &foo,
        "bar", &bar);
    assert(args[1] == "--bAr");

    // test stopOnFirstNonOption

    args = ["program.name", "--foo", "nonoption", "--bar"];
    foo = bar = false;
    getopt(args,
        std.getopt.config.stopOnFirstNonOption,
        "foo", &foo,
        "bar", &bar);
    assert(foo && !bar && args[1] == "nonoption" && args[2] == "--bar");

    args = ["program.name", "--foo", "nonoption", "--zab"];
    foo = bar = false;
    getopt(args,
        std.getopt.config.stopOnFirstNonOption,
        "foo", &foo,
        "bar", &bar);
    assert(foo && !bar && args[1] == "nonoption" && args[2] == "--zab");

    args = ["program.name", "--fb1", "--fb2=true", "--tb1=false"];
    bool fb1, fb2;
    bool tb1 = true;
    getopt(args, "fb1", &fb1, "fb2", &fb2, "tb1", &tb1);
    assert(fb1 && fb2 && !tb1);

    // test keepEndOfOptions

    args = ["program.name", "--foo", "nonoption", "--bar", "--", "--baz"];
    getopt(args,
        std.getopt.config.keepEndOfOptions,
        "foo", &foo,
        "bar", &bar);
    assert(args == ["program.name", "nonoption", "--", "--baz"]);

    // Ensure old behavior without the keepEndOfOptions

    args = ["program.name", "--foo", "nonoption", "--bar", "--", "--baz"];
    getopt(args,
        "foo", &foo,
        "bar", &bar);
    assert(args == ["program.name", "nonoption", "--baz"]);

    // test function callbacks

    static class MyEx : Exception
    {
        this() { super(""); }
        this(string option) { this(); this.option = option; }
        this(string option, string value) { this(option); this.value = value; }

        string option;
        string value;
    }

    static void myStaticHandler1() { throw new MyEx(); }
    args = ["program.name", "--verbose"];
    try { getopt(args, "verbose", &myStaticHandler1); assert(0); }
    catch (MyEx ex) { assert(ex.option is null && ex.value is null); }

    static void myStaticHandler2(string option) { throw new MyEx(option); }
    args = ["program.name", "--verbose"];
    try { getopt(args, "verbose", &myStaticHandler2); assert(0); }
    catch (MyEx ex) { assert(ex.option == "verbose" && ex.value is null); }

    static void myStaticHandler3(string option, string value) { throw new MyEx(option, value); }
    args = ["program.name", "--verbose", "2"];
    try { getopt(args, "verbose", &myStaticHandler3); assert(0); }
    catch (MyEx ex) { assert(ex.option == "verbose" && ex.value == "2"); }

    // check that GetOptException is thrown if the value is missing
    args = ["program.name", "--verbose"];
    try { getopt(args, "verbose", &myStaticHandler3); assert(0); }
    catch (GetOptException e) {}
    catch (Exception e) { assert(0); }
}

@safe unittest // @safe std.getopt.config option use
{
    long x = 0;
    string[] args = ["program", "--inc-x", "--inc-x"];
    getopt(args,
           std.getopt.config.caseSensitive,
           "inc-x", "Add one to x", delegate void() { x++; });
    assert(x == 2);
}

// https://issues.dlang.org/show_bug.cgi?id=2142
@safe unittest
{
    bool f_linenum, f_filename;
    string[] args = [ "", "-nl" ];
    getopt
        (
            args,
            std.getopt.config.bundling,
            //std.getopt.config.caseSensitive,
            "linenum|l", &f_linenum,
            "filename|n", &f_filename
        );
    assert(f_linenum);
    assert(f_filename);
}

// https://issues.dlang.org/show_bug.cgi?id=6887
@safe unittest
{
    string[] p;
    string[] args = ["", "-pa"];
    getopt(args, "p", &p);
    assert(p.length == 1);
    assert(p[0] == "a");
}

// https://issues.dlang.org/show_bug.cgi?id=6888
@safe unittest
{
    int[string] foo;
    auto args = ["", "-t", "a=1"];
    getopt(args, "t", &foo);
    assert(foo == ["a":1]);
}

// https://issues.dlang.org/show_bug.cgi?id=9583
@safe unittest
{
    int opt;
    auto args = ["prog", "--opt=123", "--", "--a", "--b", "--c"];
    getopt(args, "opt", &opt);
    assert(args == ["prog", "--a", "--b", "--c"]);
}

@safe unittest
{
    string foo, bar;
    auto args = ["prog", "-thello", "-dbar=baz"];
    getopt(args, "t", &foo, "d", &bar);
    assert(foo == "hello");
    assert(bar == "bar=baz");

    // From https://issues.dlang.org/show_bug.cgi?id=5762
    string a;
    args = ["prog", "-a-0x12"];
    getopt(args, config.bundling, "a|addr", &a);
    assert(a == "-0x12", a);
    args = ["prog", "--addr=-0x12"];
    getopt(args, config.bundling, "a|addr", &a);
    assert(a == "-0x12");

    // From https://issues.dlang.org/show_bug.cgi?id=11764
    args = ["main", "-test"];
    bool opt;
    args.getopt(config.passThrough, "opt", &opt);
    assert(args == ["main", "-test"]);

    // From https://issues.dlang.org/show_bug.cgi?id=15220
    args = ["main", "-o=str"];
    string o;
    args.getopt("o", &o);
    assert(o == "str");

    args = ["main", "-o=str"];
    o = null;
    args.getopt(config.bundling, "o", &o);
    assert(o == "str");
}

// https://issues.dlang.org/show_bug.cgi?id=5228
@safe unittest
{
    import std.conv;
    import std.exception;

    auto args = ["prog", "--foo=bar"];
    int abc;
    assertThrown!GetOptException(getopt(args, "abc", &abc));

    args = ["prog", "--abc=string"];
    assertThrown!ConvException(getopt(args, "abc", &abc));
}

// https://issues.dlang.org/show_bug.cgi?id=7693
@safe unittest
{
    import std.exception;

    enum Foo {
        bar,
        baz
    }

    auto args = ["prog", "--foo=barZZZ"];
    Foo foo;
    assertThrown(getopt(args, "foo", &foo));
    args = ["prog", "--foo=bar"];
    assertNotThrown(getopt(args, "foo", &foo));
    args = ["prog", "--foo", "barZZZ"];
    assertThrown(getopt(args, "foo", &foo));
    args = ["prog", "--foo", "baz"];
    assertNotThrown(getopt(args, "foo", &foo));
}

// Same as https://issues.dlang.org/show_bug.cgi?id=7693 only for `bool`
@safe unittest
{
    import std.exception;

    auto args = ["prog", "--foo=truefoobar"];
    bool foo;
    assertThrown(getopt(args, "foo", &foo));
    args = ["prog", "--foo"];
    getopt(args, "foo", &foo);
    assert(foo);
}

@safe unittest
{
    bool foo;
    auto args = ["prog", "--foo"];
    getopt(args, "foo", &foo);
    assert(foo);
}

@safe unittest
{
    bool foo;
    bool bar;
    auto args = ["prog", "--foo", "-b"];
    getopt(args, config.caseInsensitive,"foo|f", "Some foo", &foo,
        config.caseSensitive, "bar|b", "Some bar", &bar);
    assert(foo);
    assert(bar);
}

@safe unittest
{
    bool foo;
    bool bar;
    auto args = ["prog", "-b", "--foo", "-z"];
    getopt(args, config.caseInsensitive, config.required, "foo|f", "Some foo",
        &foo, config.caseSensitive, "bar|b", "Some bar", &bar,
        config.passThrough);
    assert(foo);
    assert(bar);
}

@safe unittest
{
    import std.exception;

    bool foo;
    bool bar;
    auto args = ["prog", "-b", "-z"];
    assertThrown(getopt(args, config.caseInsensitive, config.required, "foo|f",
        "Some foo", &foo, config.caseSensitive, "bar|b", "Some bar", &bar,
        config.passThrough));
}

@safe unittest
{
    import std.exception;

    bool foo;
    bool bar;
    auto args = ["prog", "--foo", "-z"];
    assertNotThrown(getopt(args, config.caseInsensitive, config.required,
        "foo|f", "Some foo", &foo, config.caseSensitive, "bar|b", "Some bar",
        &bar, config.passThrough));
    assert(foo);
    assert(!bar);
}

@safe unittest
{
    bool foo;
    auto args = ["prog", "-f"];
    auto r = getopt(args, config.caseInsensitive, "help|f", "Some foo", &foo);
    assert(foo);
    assert(!r.helpWanted);
}

@safe unittest // implicit help option without config.passThrough
{
    string[] args = ["program", "--help"];
    auto r = getopt(args);
    assert(r.helpWanted);
}

// std.getopt: implicit help option breaks the next argument
// https://issues.dlang.org/show_bug.cgi?id=13316
@safe unittest
{
    string[] args = ["program", "--help", "--", "something"];
    getopt(args);
    assert(args == ["program", "something"]);

    args = ["program", "--help", "--"];
    getopt(args);
    assert(args == ["program"]);

    bool b;
    args = ["program", "--help", "nonoption", "--option"];
    getopt(args, config.stopOnFirstNonOption, "option", &b);
    assert(args == ["program", "nonoption", "--option"]);
}

// std.getopt: endOfOptions broken when it doesn't look like an option
// https://issues.dlang.org/show_bug.cgi?id=13317
@safe unittest
{
    auto endOfOptionsBackup = endOfOptions;
    scope(exit) endOfOptions = endOfOptionsBackup;
    endOfOptions = "endofoptions";
    string[] args = ["program", "endofoptions", "--option"];
    bool b = false;
    getopt(args, "option", &b);
    assert(!b);
    assert(args == ["program", "--option"]);
}

// make std.getopt ready for DIP 1000
// https://issues.dlang.org/show_bug.cgi?id=20480
@safe unittest
{
    string[] args = ["test", "--foo", "42", "--bar", "BAR"];
    int foo;
    string bar;
    getopt(args, "foo", &foo, "bar", "bar help", &bar);
    assert(foo == 42);
    assert(bar == "BAR");
}

/** This function prints the passed `Option`s and text in an aligned manner on `stdout`.

The passed text will be printed first, followed by a newline, then the short
and long version of every option will be printed. The short and long version
will be aligned to the longest option of every `Option` passed. If the option
is required, then "Required:" will be printed after the long version of the
`Option`. If a help message is present it will be printed next. The format is
illustrated by this code:

------------
foreach (it; opt)
{
    writefln("%*s %*s%s%s", lengthOfLongestShortOption, it.optShort,
        lengthOfLongestLongOption, it.optLong,
        it.required ? " Required: " : " ", it.help);
}
------------

Params:
    text = The text to printed at the beginning of the help output.
    opt = The `Option` extracted from the `getopt` parameter.
*/
void defaultGetoptPrinter(string text, Option[] opt) @safe
{
    import std.stdio : stdout;
    // stdout global __gshared is trusted with a locked text writer
    auto w = (() @trusted => stdout.lockingTextWriter())();

    defaultGetoptFormatter(w, text, opt);
}

/** This function writes the passed text and `Option` into an output range
in the manner described in the documentation of function
`defaultGetoptPrinter`, unless the style option is used.

Params:
    output = The output range used to write the help information.
    text = The text to print at the beginning of the help output.
    opt = The `Option` extracted from the `getopt` parameter.
    style = The manner in which to display the output of each `Option.`
*/
void defaultGetoptFormatter(Output)(Output output, string text, Option[] opt, string style = "%*s %*s%*s%s\n")
{
    import std.algorithm.comparison : min, max;
    import std.format.write : formattedWrite;

    output.formattedWrite("%s\n", text);

    size_t ls, ll;
    bool hasRequired = false;
    foreach (it; opt)
    {
        ls = max(ls, it.optShort.length);
        ll = max(ll, it.optLong.length);

        hasRequired = hasRequired || it.required;
    }

    string re = " Required: ";

    foreach (it; opt)
    {
        output.formattedWrite(style, ls, it.optShort, ll, it.optLong,
            hasRequired ? re.length : 1, it.required ? re : " ", it.help);
    }
}

@safe unittest
{
    import std.conv;

    import std.array;
    import std.string;
    bool a;
    auto args = ["prog", "--foo"];
    auto t = getopt(args, "foo|f", "Help", &a);
    string s;
    auto app = appender!string();
    defaultGetoptFormatter(app, "Some Text", t.options);

    string helpMsg = app.data;
    //writeln(helpMsg);
    assert(helpMsg.length);
    assert(helpMsg.count("\n") == 3, to!string(helpMsg.count("\n")) ~ " "
        ~ helpMsg);
    assert(helpMsg.indexOf("--foo") != -1);
    assert(helpMsg.indexOf("-f") != -1);
    assert(helpMsg.indexOf("-h") != -1);
    assert(helpMsg.indexOf("--help") != -1);
    assert(helpMsg.indexOf("Help") != -1);

    string wanted = "Some Text\n-f  --foo Help\n-h --help This help "
        ~ "information.\n";
    assert(wanted == helpMsg);
}

@safe unittest
{
    import std.array ;
    import std.conv;
    import std.string;
    bool a;
    auto args = ["prog", "--foo"];
    auto t = getopt(args, config.required, "foo|f", "Help", &a);
    string s;
    auto app = appender!string();
    defaultGetoptFormatter(app, "Some Text", t.options);

    string helpMsg = app.data;
    //writeln(helpMsg);
    assert(helpMsg.length);
    assert(helpMsg.count("\n") == 3, to!string(helpMsg.count("\n")) ~ " "
        ~ helpMsg);
    assert(helpMsg.indexOf("Required:") != -1);
    assert(helpMsg.indexOf("--foo") != -1);
    assert(helpMsg.indexOf("-f") != -1);
    assert(helpMsg.indexOf("-h") != -1);
    assert(helpMsg.indexOf("--help") != -1);
    assert(helpMsg.indexOf("Help") != -1);

    string wanted = "Some Text\n-f  --foo Required: Help\n-h --help "
        ~ "          This help information.\n";
    assert(wanted == helpMsg, helpMsg ~ wanted);
}

// https://issues.dlang.org/show_bug.cgi?id=14724
@safe unittest
{
    bool a;
    auto args = ["prog", "--help"];
    GetoptResult rslt;
    try
    {
        rslt = getopt(args, config.required, "foo|f", "bool a", &a);
    }
    catch (Exception e)
    {
        enum errorMsg = "If the request for help was passed required options" ~
                "must not be set.";
        assert(false, errorMsg);
    }

    assert(rslt.helpWanted);
}

// throw on duplicate options
@system unittest
{
    import core.exception : AssertError;
    import std.exception : assertNotThrown, assertThrown;
    auto args = ["prog", "--abc", "1"];
    int abc, def;
    assertThrown!AssertError(getopt(args, "abc", &abc, "abc", &abc));
    assertThrown!AssertError(getopt(args, "abc|a", &abc, "def|a", &def));
    assertNotThrown!AssertError(getopt(args, "abc", &abc, "def", &def));

    // https://issues.dlang.org/show_bug.cgi?id=23940
    assertThrown!AssertError(getopt(args,
            "abc", &abc, "ABC", &def));
    assertThrown!AssertError(getopt(args, config.caseInsensitive,
            "abc", &abc, "ABC", &def));
    assertNotThrown!AssertError(getopt(args, config.caseSensitive,
            "abc", &abc, "ABC", &def));
}

// https://issues.dlang.org/show_bug.cgi?id=17327 repeated option use
@safe unittest
{
    long num = 0;

    string[] args = ["program", "--num", "3"];
    getopt(args, "n|num", &num);
    assert(num == 3);

    args = ["program", "--num", "3", "--num", "5"];
    getopt(args, "n|num", &num);
    assert(num == 5);

    args = ["program", "--n", "3", "--num", "5", "-n", "-7"];
    getopt(args, "n|num", &num);
    assert(num == -7);

    void add1() { num++; }
    void add2(string option) { num += 2; }
    void addN(string option, string value)
    {
        import std.conv : to;
        num += value.to!long;
    }

    num = 0;
    args = ["program", "--add1", "--add2", "--add1", "--add", "5", "--add2", "--add", "10"];
    getopt(args,
           "add1", "Add 1 to num", &add1,
           "add2", "Add 2 to num", &add2,
           "add", "Add N to num", &addN,);
    assert(num == 21);

    bool flag = false;
    args = ["program", "--flag"];
    getopt(args, "f|flag", "Boolean", &flag);
    assert(flag);

    flag = false;
    args = ["program", "-f", "-f"];
    getopt(args, "f|flag", "Boolean", &flag);
    assert(flag);

    flag = false;
    args = ["program", "--flag=true", "--flag=false"];
    getopt(args, "f|flag", "Boolean", &flag);
    assert(!flag);

    flag = false;
    args = ["program", "--flag=true", "--flag=false", "-f"];
    getopt(args, "f|flag", "Boolean", &flag);
    assert(flag);
}

@system unittest  // Delegates as callbacks
{
    alias TwoArgOptionHandler = void delegate(string option, string value) @safe;

    TwoArgOptionHandler makeAddNHandler(ref long dest)
    {
        void addN(ref long dest, string n)
        {
            import std.conv : to;
            dest += n.to!long;
        }

        return (option, value) => addN(dest, value);
    }

    long x = 0;
    long y = 0;

    string[] args =
        ["program", "--x-plus-1", "--x-plus-1", "--x-plus-5", "--x-plus-n", "10",
         "--y-plus-n", "25", "--y-plus-7", "--y-plus-n", "15", "--y-plus-3"];

    getopt(args,
           "x-plus-1", "Add one to x", delegate void() { x += 1; },
           "x-plus-5", "Add five to x", delegate void(string option) { x += 5; },
           "x-plus-n", "Add NUM to x", makeAddNHandler(x),
           "y-plus-7", "Add seven to y", delegate void() { y += 7; },
           "y-plus-3", "Add three to y", delegate void(string option) { y += 3; },
           "y-plus-n", "Add NUM to x", makeAddNHandler(y),);

    assert(x == 17);
    assert(y == 50);
}

// Hyphens at the start of option values;
// https://issues.dlang.org/show_bug.cgi?id=17650
@safe unittest
{
    auto args = ["program", "-m", "-5", "-n", "-50", "-c", "-", "-f", "-"];

    int m;
    int n;
    char c;
    string f;

    getopt(args,
           "m|mm", "integer", &m,
           "n|nn", "integer", &n,
           "c|cc", "character", &c,
           "f|file", "filename or hyphen for stdin", &f);

    assert(m == -5);
    assert(n == -50);
    assert(c == '-');
    assert(f == "-");
}

// Hyphen at the option value;
// https://issues.dlang.org/show_bug.cgi?id=22394
@safe unittest
{
    auto args = ["program", "-"];

    getopt(args);

    assert(args == ["program", "-"]);
}

@safe unittest
{
    import std.conv;

    import std.array;
    import std.string;
    bool a;
    auto args = ["prog", "--foo"];
    auto t = getopt(args, "foo|f", "Help", &a);
    string s;
    auto app = appender!string();
    defaultGetoptFormatter(app, "Some Text", t.options, "\t\t%*s %*s%*s\n%s\n");

    string helpMsg = app.data;
    //writeln(helpMsg);
    assert(helpMsg.length);
    assert(helpMsg.count("\n") == 5, to!string(helpMsg.count("\n")) ~ " "
        ~ helpMsg);
    assert(helpMsg.indexOf("--foo") != -1);
    assert(helpMsg.indexOf("-f") != -1);
    assert(helpMsg.indexOf("-h") != -1);
    assert(helpMsg.indexOf("--help") != -1);
    assert(helpMsg.indexOf("Help") != -1);

    string wanted = "Some Text\n\t\t-f  --foo \nHelp\n\t\t-h --help \nThis help "
        ~ "information.\n";
    assert(wanted == helpMsg);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // Written in the D programming language
/**
 * Implements a signed 128 bit integer type.
 *
    Author:     Walter Bright
    Copyright:  Copyright (c) 2022, D Language Foundation
    License:    $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0)
    Source:     $(PHOBOSSRC std/int128.d)
 */
module std.int128;

private import core.int128;


/***********************************
 * 128 bit signed integer type.
 */

public struct Int128
{
  @safe pure nothrow @nogc
  {
    Cent data;          /// core.int128.Cent

    /****************
     * Construct an `Int128` from a `long` value.
     * The upper 64 bits are formed by sign extension.
     * Params:
     *  lo = signed lower 64 bits
     */
    this(long lo)
    {
        data.lo = lo;
        data.hi = lo < 0 ? ~0L : 0;
    }

    /****************
     * Construct an `Int128` from a `ulong` value.
     * The upper 64 bits are set to zero.
     * Params:
     *  lo = unsigned lower 64 bits
     */
    this(ulong lo)
    {
        data.lo = lo;
        data.hi = 0;
    }

    /****************
     * Construct an `Int128` from a `long` value.
     * Params:
     *  hi = upper 64 bits
     *  lo = lower 64 bits
     */
    this(long hi, long lo)
    {
        data.hi = hi;
        data.lo = lo;
    }

    /********************
     * Construct an `Int128` from a `Cent`.
     * Params:
     *  data = Cent data
     */
    this(Cent data)
    {
        this.data = data;
    }

    /********************
     * Returns: hash value for Int128
     */
    size_t toHash() const
    {
        return cast(size_t)((data.lo & 0xFFFF_FFFF) + (data.hi & 0xFFFF_FFFF) + (data.lo >> 32) + (data.hi >> 32));
    }

    /************************
     * Compare for equality
     * Params: lo = signed value to compare with
     * Returns: true if Int128 equals value
     */
    bool opEquals(long lo) const
    {
        return data.lo == lo && data.hi == (lo >> 63);
    }

    /************************
     * Compare for equality
     * Params: lo = unsigned value to compare with
     * Returns: true if Int128 equals value
     */
    bool opEquals(ulong lo) const
    {
        return data.hi == 0 && data.lo == lo;
    }

    /************************
     * Compare for equality
     * Params: op2 = value to compare with
     * Returns: true if Int128 equals value
     */
    bool opEquals(Int128 op2) const
    {
        return data.hi == op2.data.hi && data.lo == op2.data.lo;
    }

    /** Support unary arithmentic operator +
     * Params: op = "+"
     * Returns: lvalue of result
     */
    Int128 opUnary(string op)() const
        if (op == "+")
    {
        return this;
    }

    /** Support unary arithmentic operator - ~
     * Params: op = "-", "~"
     * Returns: lvalue of result
     */
    Int128 opUnary(string op)() const
        if (op == "-" || op == "~")
    {
        static if (op == "-")
            return Int128(neg(this.data));
        else static if (op == "~")
            return Int128(com(this.data));
    }

    /** Support unary arithmentic operator ++ --
     * Params: op = "++", "--"
     * Returns: lvalue of result
     */
    Int128 opUnary(string op)()
        if (op == "++" || op == "--")
    {
        static if (op == "++")
            this.data = inc(this.data);
        else static if (op == "--")
            this.data = dec(this.data);
        else
            static assert(0, op);
        return this;
    }

    /** Support casting to a bool
     * Params: T = bool
     * Returns: true if value is not zero
     */
    bool opCast(T : bool)() const
    {
        return tst(this.data);
    }
  } // @safe pure nothrow @nogc

    /** Support casting to an integral type
     * Params: T = integral type
     * Returns: low bits of value reinterpreted as T
     */
    T opCast(T : long)() const
    if (is(byte : T))
    {
        return cast(T) this.data.lo;
    }

    ///
    @safe unittest
    {
        const Int128 a = Int128(0xffff_ffff_ffff_ffffL, 0x0123_4567_89ab_cdefL);
        assert(cast(long) a == 0x0123_4567_89ab_cdefL);
        assert(cast(int)  a ==           0x89ab_cdef);
        assert(cast(byte) a == cast(byte) 0xef);
    }

    /** Support casting to floating point type
     * Params: T = floating point type
     * Returns: value cast to floating point with environment-dependent
     * rounding if the value is not exactly representable
     */
    T opCast(T : real)() const
    {
        import core.math : ldexp;
        if (cast(long) this.data.hi >= 0)
            return ldexp(cast(T) this.data.hi, 64) + this.data.lo;
        else
        {
            const absData = neg(this.data);
            return -ldexp(cast(T) absData.hi, 64) - absData.lo;
        }
    }

    ///
    @safe unittest
    {
        const Int128 a = Int128(-1L << 60);
        assert(cast(double) a == -(2.0 ^^ 60));
        assert(cast(double) (a * a) == 2.0 ^^ 120);
    }

    /** Support binary arithmetic operators + - * / % & | ^ << >> >>>
     * Params:
     *   op = one of the arithmetic binary operators
     *   op2 = second operand
     * Returns: value after the operation is applied
     */
    Int128 opBinary(string op)(Int128 op2) const
        if (op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^")
    {
        static if (op == "+")
            return Int128(add(this.data, op2.data));
        else static if (op == "-")
            return Int128(sub(this.data, op2.data));
        else static if (op == "*")
            return Int128(mul(this.data, op2.data));
        else static if (op == "/")
            return Int128(div(this.data, op2.data));
        else static if (op == "%")
        {
            Cent modulus;
            divmod(this.data, op2.data, modulus);
            return Int128(modulus);
        }
        else static if (op == "&")
            return Int128(and(this.data, op2.data));
        else static if (op == "|")
            return Int128(or(this.data, op2.data));
        else static if (op == "^")
            return Int128(xor(this.data, op2.data));
        else
            static assert(0, "wrong op value");
    }

    /// ditto
    Int128 opBinary(string op, Int)(const Int op2) const
        if ((op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^") &&
            is(Int : long) && __traits(isIntegral, Int))
    {
        static if (__traits(isUnsigned, Int))
            return mixin("this " ~ op ~ " Int128(0, op2)");
        else
            return mixin("this " ~ op ~ " Int128((cast(long) op2) >> 63 , op2)");
    }

    /// ditto
    Int128 opBinary(string op, IntLike)(auto ref IntLike op2) const
        if ((op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^") &&
            is(IntLike : long) && !__traits(isIntegral, IntLike))
    {
        return opBinary!(op)(__traits(getMember, op2, __traits(getAliasThis, IntLike)[0]));
    }

    /// ditto
    Int128 opBinaryRight(string op, Int)(const Int op2) const
        if ((op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^") &&
            is(Int : long) && __traits(isIntegral, Int))
    {
        static if (__traits(isUnsigned, Int))
            mixin("return Int128(0, op2) " ~ op ~ " this;");
        else
            mixin("return Int128((cast(long) op2) >> 63, op2) " ~ op ~ " this;");
    }

    /// ditto
    Int128 opBinaryRight(string op, IntLike)(auto ref IntLike op2) const
        if ((op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^") &&
            is(IntLike : long) && !__traits(isIntegral, IntLike))
    {
        return opBinaryRight!(op)(__traits(getMember, op2, __traits(getAliasThis, IntLike)[0]));
    }

    /// ditto
    Int128 opBinary(string op)(long op2) const
        if (op == "<<")
    {
        return Int128(shl(this.data, cast(uint) op2));
    }

    /// ditto
    Int128 opBinary(string op)(long op2) const
        if (op == ">>")
    {
        return Int128(sar(this.data, cast(uint) op2));
    }

    /// ditto
    Int128 opBinary(string op)(long op2) const
        if (op == ">>>")
    {
        return Int128(shr(this.data, cast(uint) op2));
    }

    /** arithmetic assignment operators += -= *= /= %= &= |= ^= <<= >>= >>>=
     * Params: op = one of +, -, etc.
     *   op2 = second operand
     * Returns: lvalue of updated left operand
     */
    ref Int128 opOpAssign(string op)(Int128 op2)
        if (op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^" ||
            op == "<<" || op == ">>" || op == ">>>")
    {
        mixin("this = this " ~ op ~ " op2;");
        return this;
    }

    /// ditto
    ref Int128 opOpAssign(string op, Int)(auto ref Int op2)
        if ((op == "+" || op == "-" ||
            op == "*" || op == "/" || op == "%" ||
            op == "&" || op == "|" || op == "^" ||
            op == "<<" || op == ">>" || op == ">>>")
            && is(Int : long))
    {
        mixin("this = this " ~ op ~ " op2;");
        return this;
    }

    /** support arithmentic comparison operators < <= > >=
     * Params: op2 = right hand operand
     * Returns: -1 for less than, 0 for equals, 1 for greater than
     */
    int opCmp(Int128 op2) const @nogc nothrow pure @safe
    {
        return this == op2 ? 0 : gt(this.data, op2.data) * 2 - 1;
    }

    /// ditto
    int opCmp(Int)(const Int op2) const @nogc nothrow pure @safe
    if (is(Int : long) && __traits(isIntegral, Int))
    {
        static if (__traits(isUnsigned, Int))
            return opCmp(Int128(0, op2));
        else
            return opCmp(Int128((cast(long) op2) >> 63, op2));
    }

    /// ditto
    int opCmp(IntLike)(auto ref IntLike op2) const
    if (is(IntLike : long) && !__traits(isIntegral, IntLike))
    {
        return opCmp(__traits(getMember, op2, __traits(getAliasThis, IntLike)[0]));
    }

    /**
     * Formats `Int128` with either `%d`, `%x`, `%X`, or `%s` (same as `%d`).
     *
     * Params:
     *   sink = $(REF_ALTTEXT Output range, isOutputRange, std, range, primitives)
     *   to write to.
     *   fmt = A $(REF FormatSpec, std,format) which controls how the number
     *   is displayed.
     *
     * Throws:
     *       $(REF FormatException, std,format) if the format specifier is
     *       not one of 'd', 'x', 'X', 's'.
     *
     * See_Also: $(REF formatValue, std,format)
     */
    void toString(Writer, FormatSpec)(scope ref Writer sink, scope const ref FormatSpec fmt) const
    {
        import std.range.primitives : put;
        import std.format : FormatException, Fmt = FormatSpec;

        static if (is(FormatSpec == Fmt!Char, Char))
        {
            // Puts "Char" into scope if the pattern matches.
        }
        static assert(is(Char),
            "Expecting `FormatSpec` to be instantiation of `std.format.FormatSpec`");

        Char[39] buf = void;
        size_t bufStart = void;
        Char signChar = 0;
        if (fmt.spec == 'd' || fmt.spec == 's')
        {
            const bool isNeg = 0 > cast(long) this.data.hi;
            Cent val = isNeg ? neg(this.data) : this.data;
            immutable Cent radix = { lo: 10, hi: 0 };
            Cent modulus;
            bufStart = buf.length;
            do
            {
                uint x = void;
                if (ugt(radix, val))
                {
                    x = cast(uint) val.lo;
                    val = Cent(0, 0);
                }
                else
                {
                    val = udivmod(val, radix, modulus);
                    x = cast(uint) modulus.lo;
                }
                buf[--bufStart] = cast(Char) ('0' + x);
            } while (tst(val));
            if (isNeg)
                signChar = '-';
            else if (fmt.flPlus)
                signChar = '+';
            else if (fmt.flSpace)
                signChar = ' ';
        }
        else if (fmt.spec == 'x' || fmt.spec == 'X')
        {
            immutable hexDigits = fmt.spec == 'X' ? "0123456789ABCDEF" : "0123456789abcdef";
            ulong a = data.lo;
            bufStart = buf.length - 1;
            size_t penPos = buf.length - 1;
            do
            {
                if ((buf[penPos] = hexDigits[0xF & cast(uint) a]) != '0')
                    bufStart = penPos;
                a >>>= 4;
            } while (--penPos >= buf.length - 16);
            a = data.hi;
            do
            {
                if ((buf[penPos] = hexDigits[0xF & cast(uint) a]) != '0')
                    bufStart = penPos;
                a >>>= 4;
            } while (--penPos >= buf.length - 32);
        }
        else
        {
            throw new FormatException("Format specifier not understood: %" ~ fmt.spec);
        }

        const minw = (buf.length - bufStart) + int(signChar != 0);
        const maxw = minw < fmt.width ? fmt.width : minw;
        const difw = maxw - minw;

        static void putRepeatedChars(Char c)(scope ref Writer sink, size_t n)
        {
            static immutable Char[8] array = [c, c, c, c, c, c, c, c];
            foreach (_; 0 .. n / 8)
                put(sink, array[0 .. 8]);
            if (n & 7)
                put(sink, array[0 .. n & 7]);
        }

        if (!fmt.flDash && !fmt.flZero && difw)
            putRepeatedChars!' '(sink, difw);

        if (signChar)
        {
            Char[1] signCharBuf = signChar;
            put(sink, signCharBuf[0 .. 1]);
        }

        if (!fmt.flDash && fmt.flZero && difw)
            putRepeatedChars!'0'(sink, difw);

        put(sink, buf[bufStart .. $]);

        if (fmt.flDash && difw)
            putRepeatedChars!' '(sink, difw);
    }

    /**
        `toString` is rarely directly invoked; the usual way of using it is via
        $(REF format, std, format):
     */
    @safe unittest
    {
        import std.format : format;

        assert(format("%s", Int128.max) == "170141183460469231731687303715884105727");
        assert(format("%s", Int128.min) == "-170141183460469231731687303715884105728");
        assert(format("%x", Int128.max) == "7fffffffffffffffffffffffffffffff");
        assert(format("%X", Int128.max) == "7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");
        assert(format("%032X", Int128(123L)) == "0000000000000000000000000000007B");
        assert(format("%+ 40d", Int128(123L)) == "                                    +123");
        assert(format("%+-40d", Int128(123L)) == "+123                                    ");
    }

    /// Also can format as `wchar` or `dchar`.
    @safe unittest
    {
        import std.conv : to;

        assert(to!wstring(Int128.max) == "170141183460469231731687303715884105727"w);
        assert(to!dstring(Int128.max) == "170141183460469231731687303715884105727"d);
    }

    enum min = Int128(long.min, 0);             /// minimum value
    enum max = Int128(long.max, ulong.max);     /// maximum value
}

/********************************************* Tests ************************************/

version (unittest)
{
import core.stdc.stdio;

@trusted void print(Int128 c)
{
    printf("%lld, %lld\n", c.data.hi, c.data.lo);
}

@trusted void printx(Int128 c)
{
    printf("%llx, %llx\n", c.data.hi, c.data.lo);
}
}

/// Int128 tests
@safe pure nothrow @nogc
unittest
{
    Int128 c = Int128(5, 6);
    assert(c == c);
    assert(c == +c);
    assert(c == - -c);
    assert(~c == Int128(~5, ~6));
    ++c;
    assert(c == Int128(5, 7));
    assert(--c == Int128(5, 6));
    assert(!!c);
    assert(!Int128());

    assert(c + Int128(10, 20) == Int128(15, 26));
    assert(c - Int128(1, 2)   == Int128(4, 4));
    assert(c * Int128(100, 2) == Int128(610, 12));
    assert(c / Int128(3, 2)   == Int128(0, 1));
    assert(c % Int128(3, 2)   == Int128(2, 4));
    assert((c & Int128(3, 2)) == Int128(1, 2));
    assert((c | Int128(3, 2)) == Int128(7, 6));
    assert((c ^ Int128(3, 2)) == Int128(6, 4));

    assert(c + 15   == Int128(5, 21));
    assert(c - 15   == Int128(4, -9));
    assert(c * 15   == Int128(75, 90));
    assert(c / 15   == Int128(0, 6148914691236517205));
    assert(c % 15   == Int128(0, 11));
    assert((c & 15) == Int128(0, 6));
    assert((c | 15) == Int128(5, 15));
    assert((c ^ 15) == Int128(5, 9));

    assert(15 + c   == Int128(5, 21));
    assert(15 - c   == Int128(-5, 9));
    assert(15 * c   == Int128(75, 90));
    assert(15 / c   == Int128(0, 0));
    assert(15 % c   == Int128(0, 15));
    assert((15 & c) == Int128(0, 6));
    assert((15 | c) == Int128(5, 15));
    assert((15 ^ c) == Int128(5, 9));

    assert(c << 1 == Int128(10, 12));
    assert(-c >> 1 == Int128(-3, 9223372036854775805));
    assert(-c >>> 1 == Int128(9223372036854775805, 9223372036854775805));

    assert((c += 1) == Int128(5, 7));
    assert((c -= 1) == Int128(5, 6));
    assert((c += Int128(0, 1)) == Int128(5, 7));
    assert((c -= Int128(0, 1)) == Int128(5, 6));
    assert((c *= 2) == Int128(10, 12));
    assert((c /= 2) == Int128(5, 6));
    assert((c %= 2) == Int128());
    c += Int128(5, 6);
    assert((c *= Int128(10, 20)) == Int128(160, 120));
    assert((c /= Int128(10, 20)) == Int128(0, 15));
    c += Int128(72, 0);
    assert((c %= Int128(10, 20)) == Int128(1, -125));
    assert((c &= Int128(3, 20)) == Int128(1, 0));
    assert((c |= Int128(8, 2)) == Int128(9, 2));
    assert((c ^= Int128(8, 2)) == Int128(1, 0));
    c |= Int128(10, 5);
    assert((c <<= 1) == Int128(11 * 2, 5 * 2));
    assert((c >>>= 1) == Int128(11, 5));
    c = Int128(long.min, long.min);
    assert((c >>= 1) == Int128(long.min >> 1, cast(ulong) long.min >> 1));

    assert(-Int128.min == Int128.min);
    assert(Int128.max + 1 == Int128.min);

    c = Int128(5, 6);
    assert(c < Int128(6, 5));
    assert(c > 10);

    c = Int128(-1UL);
    assert(c == -1UL);
    c = Int128(-1L);
    assert(c == -1L);
}

@system unittest
{
    alias Seq(T...) = T;
    Int128 c = Int128(-1L);
    assert(c.opCmp(-1L) == 0);
    // To avoid regression calling opCmp with any integral type needs to
    // work without the compiler complaining "opCmp called with argument
    // X matches both <...>".
    static foreach (Int; Seq!(long, int, short, byte, ulong, uint, ushort, ubyte, dchar, wchar, char))
        assert(c < Int.max);
    static foreach (Int; Seq!(int, short, byte))
        assert(c.opCmp(Int(-1)) == 0);
    assert(c < true);
    // To avoid regression calling opCmp with any type that converts to an
    // integral type through alias this needs to work regardless of whether
    // the alias is safe/pure/nothrow/nogc and regardless of whether the
    // type has a disabled postblit.
    static struct Wrapped(T)
    {
        T value;
        uint count;
        T get() @system { ++count; return value; } // not const
        alias get this;
        @disable this(this); // no implicit copies
    }
    assert(c.opCmp(Wrapped!long(-1)) == 0);
    auto w = Wrapped!ulong(ulong.max);
    w.count++; // avoid invalid D-Scanner message that w could have been declared const
    assert(c < w);

    const zero = Int128(0L);
    const one = Int128(1L);
    const neg_one = Int128(-1L);
    const neg_two = Int128(-2L);
    // Correct result with ulong.max:
    assert(zero + ulong.max == ulong.max);
    assert(one * ulong.max == ulong.max);
    assert((neg_one & ulong.max) == ulong.max);
    assert((zero | ulong.max) == ulong.max);
    assert((zero ^ ulong.max) == ulong.max);
    // Correct result with negative arguments:
    assert(zero + -1L == -1L);
    assert(neg_two * -3L == 6L);
    assert(neg_two / -2L == 1L);
    assert(neg_two % -2L == 0L);
    assert((neg_one & -1L) == -1L);
    assert((zero | -1L) == -1L);
    assert((zero ^ -1L) == -1L);
    // Ensure alias this still works.
    {
        Int128 a = zero;
        assert((a ^= w) == ulong.max);
    }
    assert((Wrapped!long(-1L) + zero) == -1L);
}
                                                                                                                                                                                                                                                                                                                                                                 module std.internal.attributes;

/**
Used to annotate `unittest`s which need to be tested in a `-betterC` environment.

Such `unittest`s will be compiled and executed without linking druntime in, with
a `__traits(getUnitTests, mixin(__MODULE__))` style test runner.
Note that just like any other `unittest` in phobos, they will also be compiled
and executed without `-betterC`.
*/
package(std) enum betterC = 1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /**
Helper functions for working with $(I C strings).

This module is intended to provide fast, safe and garbage free
way to work with $(I C strings).

Copyright: Denis Shelomovskij 2013-2014

License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).

Authors: Denis Shelomovskij

Macros:
COREREF = $(HTTP dlang.org/phobos/core_$1.html#$2, `core.$1.$2`)
*/
module std.internal.cstring;

///
@safe unittest
{
    version (Posix)
    {
        import core.stdc.stdlib : free;
        import core.sys.posix.stdlib : setenv;
        import std.exception : enforce;

        void setEnvironment(scope const(char)[] name, scope const(char)[] value)
        { enforce(setenv(name.tempCString(), value.tempCString(), 1) != -1); }
    }

    version (Windows)
    {
        import core.sys.windows.winbase : SetEnvironmentVariableW;
        import std.exception : enforce;

        void setEnvironment(scope const(char)[] name, scope const(char)[] value)
        { enforce(SetEnvironmentVariableW(name.tempCStringW(), value.tempCStringW())); }
    }
}

import std.range;
import std.traits;

/**
Creates temporary 0-terminated $(I C string) with copy of passed text.

Params:
    To = character type of returned C string
    str = string or input range to be converted

Returns:

The value returned is implicitly convertible to $(D const To*) and
has two properties: `ptr` to access $(I C string) as $(D const To*)
and `buffPtr` to access it as `To*`.

The value returned can be indexed by [] to access it as an array.

The temporary $(I C string) is valid unless returned object is destroyed.
Thus if returned object is assigned to a variable the temporary is
valid unless the variable goes out of scope. If returned object isn't
assigned to a variable it will be destroyed at the end of creating
primary expression.

Implementation_note:
For small strings tempCString will use stack allocated buffer,
for large strings (approximately 250 characters and more) it will
allocate temporary one using C's `malloc`.

Note:
This function is intended to be used in function call expression (like
`strlen(str.tempCString())`). Incorrect usage of this function may
lead to memory corruption.
See $(RED WARNING) in $(B Examples) section.
*/

auto tempCString(To = char, From)(scope From str)
if (isSomeChar!To && (isInputRange!From || isSomeString!From) &&
    isSomeChar!(ElementEncodingType!From))
{
    alias CF = Unqual!(ElementEncodingType!From);

    auto res = TempCStringBuffer!To.trustedVoidInit(); // expensive to fill _buff[]

    // Note: res._ptr can't point to res._buff as structs are movable.

    // https://issues.dlang.org/show_bug.cgi?id=14980
    static if (isSomeString!From)
    {
        if (str is null)
        {
            res._length = 0;
            res._ptr = null;
            return res;
        }
    }

    // Use slice assignment if available.
    static if (To.sizeof == CF.sizeof && is(typeof(res._buff[0 .. str.length] = str[])))
    {
        if (str.length < res._buff.length)
        {
            res._buff[0 .. str.length] = str[];
            res._buff[str.length] = 0;
            res._ptr = res.useStack;
        }
        else
        {
            import std.internal.memory : enforceMalloc;
            if (false)
            {
                // This code is removed by the compiler but causes `@safe`ty
                // to be inferred correctly.
                CF[0] x;
                x[] = str[0 .. 0];
            }
            res._ptr = () @trusted {
                auto p = cast(CF*) enforceMalloc((str.length + 1) * CF.sizeof);
                p[0 .. str.length] = str[];
                p[str.length] = 0;
                return cast(To*) p;
            }();
        }
        res._length = str.length;
        return res;
    }
    else
    {
        static assert(!(isSomeString!From && CF.sizeof == To.sizeof), "Should be using slice assignment.");
        To[] p = res._buff;
        size_t i;

        size_t strLength;
        static if (hasLength!From)
        {
            strLength = str.length;
        }
        import std.utf : byUTF;
        static if (isSomeString!From)
            auto r = cast(const(CF)[])str;  // because inout(CF) causes problems with byUTF
        else
            alias r = str;
        To[] heapBuffer;
        foreach (const c; byUTF!(Unqual!To)(r))
        {
            if (i + 1 == p.length)
            {
                if (heapBuffer is null)
                    heapBuffer = trustedReallocStack(p, strLength);
                else
                    heapBuffer = trustedRealloc(heapBuffer);
                p = heapBuffer;
            }
            p[i++] = c;
        }
        p[i] = 0;
        res._length = i;
        res._ptr = (heapBuffer is null ? res.useStack : &heapBuffer[0]);
        return res;
    }
}

///
nothrow @nogc @system unittest
{
    import core.stdc.string;

    string str = "abc";

    // Intended usage
    assert(strlen(str.tempCString()) == 3);

    // Correct usage
    auto tmp = str.tempCString();
    assert(strlen(tmp) == 3); // or `tmp.ptr`, or `tmp.buffPtr`

    // $(RED WARNING): $(RED Incorrect usage)
    auto pInvalid1 = str.tempCString().ptr;
    const char* pInvalid2 = str.tempCString();
    // Both pointers refer to invalid memory here as
    // returned values aren't assigned to a variable and
    // both primary expressions are ended.
}

@safe pure nothrow @nogc unittest
{
    static inout(C)[] arrayFor(C)(inout(C)* cstr) pure nothrow @nogc @trusted
    {
        assert(cstr);
        size_t length = 0;
        while (cstr[length])
            ++length;
        return cstr[0 .. length];
    }

    assert(arrayFor("abc".tempCString()) == "abc");
    assert(arrayFor("abc"d.tempCString().ptr) == "abc");
    assert(arrayFor("abc".tempCString!wchar().buffPtr) == "abc"w);

    import std.utf : byChar, byWchar;
    char[300] abc = 'a';
    assert(arrayFor(tempCString(abc[].byChar).buffPtr) == abc);
    assert(arrayFor(tempCString(abc[].byWchar).buffPtr) == abc);
    assert(tempCString(abc[].byChar)[] == abc);
}

// https://issues.dlang.org/show_bug.cgi?id=14980
pure nothrow @nogc @safe unittest
{
    const(char[]) str = null;
    auto res = tempCString(str);
    const char* ptr = res;
    assert(ptr is null);
}

version (Windows)
{
    import core.sys.windows.winnt : WCHAR;
    alias tempCStringW = tempCString!(WCHAR, const(char)[]);
}

private struct TempCStringBuffer(To = char)
{
@trusted pure nothrow @nogc:

    @disable this();
    @disable this(this);
    alias ptr this; /// implicitly covert to raw pointer

    @property inout(To)* buffPtr() return inout
    {
        return _ptr == useStack ? _buff.ptr : _ptr;
    }

    @property const(To)* ptr() const
    {
        return buffPtr;
    }

    const(To)[] opIndex() const pure
    {
        return buffPtr[0 .. _length];
    }

    ~this()
    {
        if (_ptr != useStack)
        {
            import core.memory : pureFree;
            pureFree(_ptr);
        }
    }

private:
    enum To* useStack = () @trusted { return cast(To*) size_t.max; }();

    To* _ptr;
    size_t _length;        // length of the string
    version (StdUnittest)
    // the 'small string optimization'
    {
        // smaller size to trigger reallocations. Padding is to account for
        // unittest/non-unittest cross-compilation (to avoid corruption)
        To[16 / To.sizeof] _buff;
        To[(256 - 16) / To.sizeof] _unittest_pad;
    }
    else
    {
        To[256 / To.sizeof] _buff; // production size
    }

    static TempCStringBuffer trustedVoidInit() { TempCStringBuffer res = void; return res; }
}

private To[] trustedRealloc(To)(return scope To[] buf)
    @trusted @nogc pure nothrow
{
    pragma(inline, false);  // because it's rarely called
    import std.internal.memory : enforceRealloc;

    const size_t newlen = buf.length * 3 / 2;
    if (buf.length >= size_t.max / (2 * To.sizeof))
    {
        version (D_Exceptions)
        {
            import core.exception : onOutOfMemoryError;
            onOutOfMemoryError();
        }
        else
        {
            assert(0, "Memory allocation failed");
        }
    }
    auto ptr = cast(To*) enforceRealloc(buf.ptr, newlen * To.sizeof);
    return ptr[0 .. newlen];

}

private To[] trustedReallocStack(To)(scope To[] buf, size_t strLength)
    @trusted @nogc pure nothrow
{
    pragma(inline, false);  // because it's rarely called

    import std.internal.memory : enforceMalloc;

    size_t newlen = buf.length * 3 / 2;
    if (newlen <= strLength)
        newlen = strLength + 1; // +1 for terminating 0
    auto ptr = cast(To*) enforceMalloc(newlen * To.sizeof);
    ptr[0 .. buf.length] = buf[];
    return ptr[0 .. newlen];
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         /** Fundamental operations for arbitrary-precision arithmetic
 *
 * These functions are for internal use only.
 */
/*          Copyright Don Clugston 2008 - 2010.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */
/* References:
   "Modern Computer Arithmetic" (MCA) is the primary reference for all
    algorithms used in this library.
  - R.P. Brent and P. Zimmermann, "Modern Computer Arithmetic",
    Version 0.5.9, (Oct 2010).
  - C. Burkinel and J. Ziegler, "Fast Recursive Division", MPI-I-98-1-022,
    Max-Planck Institute fuer Informatik, (Oct 1998).
  - G. Hanrot, M. Quercia, and P. Zimmermann, "The Middle Product Algorithm, I.",
    INRIA 4664, (Dec 2002).
  - M. Bodrato and A. Zanoni, "What about Toom-Cook Matrices Optimality?",
    http://bodrato.it/papers (2006).
  - A. Fog, "Optimizing subroutines in assembly language",
    www.agner.org/optimize (2008).
  - A. Fog, "The microarchitecture of Intel and AMD CPU's",
    www.agner.org/optimize (2008).
  - A. Fog, "Instruction tables: Lists of instruction latencies, throughputs
    and micro-operation breakdowns for Intel and AMD CPU's.", www.agner.org/optimize (2008).

Idioms:
  Many functions in this module use
  'func(Tulong)(Tulong x) if (is(Tulong == ulong))' rather than 'func(ulong x)'
  in order to disable implicit conversion.

*/
module std.internal.math.biguintcore;

version (D_InlineAsm_X86)
{
    static import std.internal.math.biguintx86;
}
static import std.internal.math.biguintnoasm;

import std.internal.math.biguintnoasm : BigDigit, KARATSUBALIMIT,
    KARATSUBASQUARELIMIT;

alias multibyteAdd = multibyteAddSub!('+');
alias multibyteSub = multibyteAddSub!('-');

private import std.traits;
private import std.range.primitives;
public import std.ascii : LetterCase;
import std.range.primitives;
import std.traits;

private:

// dipatchers to the right low-level primitives. Added to allow BigInt CTFE for
// 32 bit systems (https://issues.dlang.org/show_bug.cgi?id=14767) although it's
// used by the other architectures too.
// See comments below in case it has to be refactored.
version (X86)
uint multibyteAddSub(char op)(uint[] dest, const(uint)[] src1, const (uint)[] src2, uint carry)
{
    // must be checked before, otherwise D_InlineAsm_X86 is true.
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteAddSub!op(dest, src1, src2, carry);
    // Runtime.
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteAddSub!op(dest, src1, src2, carry);
    // Runtime if no asm available.
    else
        return std.internal.math.biguintnoasm.multibyteAddSub!op(dest, src1, src2, carry);
}
// Any other architecture
else alias multibyteAddSub = std.internal.math.biguintnoasm.multibyteAddSub;

version (X86)
uint multibyteIncrementAssign(char op)(uint[] dest, uint carry)
{
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteIncrementAssign!op(dest, carry);
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteIncrementAssign!op(dest, carry);
    else
        return std.internal.math.biguintnoasm.multibyteIncrementAssign!op(dest, carry);
}
else alias multibyteIncrementAssign = std.internal.math.biguintnoasm.multibyteIncrementAssign;

version (X86)
uint multibyteShl()(uint[] dest, const(uint)[] src, uint numbits)
{
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteShl(dest, src, numbits);
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteShl(dest, src, numbits);
    else
        return std.internal.math.biguintnoasm.multibyteShl(dest, src, numbits);
}
else alias multibyteShl = std.internal.math.biguintnoasm.multibyteShl;

version (X86)
void multibyteShr()(uint[] dest, const(uint)[] src, uint numbits)
{
    if (__ctfe)
        std.internal.math.biguintnoasm.multibyteShr(dest, src, numbits);
    else version (D_InlineAsm_X86)
        std.internal.math.biguintx86.multibyteShr(dest, src, numbits);
    else
        std.internal.math.biguintnoasm.multibyteShr(dest, src, numbits);
}
else alias multibyteShr = std.internal.math.biguintnoasm.multibyteShr;

version (X86)
uint multibyteMul()(uint[] dest, const(uint)[] src, uint multiplier, uint carry)
{
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteMul(dest, src, multiplier, carry);
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteMul(dest, src, multiplier, carry);
    else
        return std.internal.math.biguintnoasm.multibyteMul(dest, src, multiplier, carry);
}
else alias multibyteMul = std.internal.math.biguintnoasm.multibyteMul;

version (X86)
uint multibyteMulAdd(char op)(uint[] dest, const(uint)[] src, uint multiplier, uint carry)
{
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteMulAdd!op(dest, src, multiplier, carry);
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteMulAdd!op(dest, src, multiplier, carry);
    else
        return std.internal.math.biguintnoasm.multibyteMulAdd!op(dest, src, multiplier, carry);
}
else alias multibyteMulAdd = std.internal.math.biguintnoasm.multibyteMulAdd;

version (X86)
void multibyteMultiplyAccumulate()(uint[] dest, const(uint)[] left, const(uint)[] right)
{
    if (__ctfe)
        std.internal.math.biguintnoasm.multibyteMultiplyAccumulate(dest, left, right);
    else version (D_InlineAsm_X86)
        std.internal.math.biguintx86.multibyteMultiplyAccumulate(dest, left, right);
    else
        std.internal.math.biguintnoasm.multibyteMultiplyAccumulate(dest, left, right);
}
else alias multibyteMultiplyAccumulate = std.internal.math.biguintnoasm.multibyteMultiplyAccumulate;

version (X86)
uint multibyteDivAssign()(uint[] dest, uint divisor, uint overflow)
{
    if (__ctfe)
        return std.internal.math.biguintnoasm.multibyteDivAssign(dest, divisor, overflow);
    else version (D_InlineAsm_X86)
        return std.internal.math.biguintx86.multibyteDivAssign(dest, divisor, overflow);
    else
        return std.internal.math.biguintnoasm.multibyteDivAssign(dest, divisor, overflow);
}
else alias multibyteDivAssign = std.internal.math.biguintnoasm.multibyteDivAssign;

version (X86)
void multibyteAddDiagonalSquares()(uint[] dest, const(uint)[] src)
{
    if (__ctfe)
        std.internal.math.biguintnoasm.multibyteAddDiagonalSquares(dest, src);
    else version (D_InlineAsm_X86)
        std.internal.math.biguintx86.multibyteAddDiagonalSquares(dest, src);
    else
        std.internal.math.biguintnoasm.multibyteAddDiagonalSquares(dest, src);
}
else alias multibyteAddDiagonalSquares = std.internal.math.biguintnoasm.multibyteAddDiagonalSquares;

version (X86)
void multibyteTriangleAccumulate()(uint[] dest, const(uint)[] x)
{
    if (__ctfe)
        std.internal.math.biguintnoasm.multibyteTriangleAccumulate(dest, x);
    else version (D_InlineAsm_X86)
        std.internal.math.biguintx86.multibyteTriangleAccumulate(dest, x);
    else
        std.internal.math.biguintnoasm.multibyteTriangleAccumulate(dest, x);
}
else alias multibyteTriangleAccumulate = std.internal.math.biguintnoasm.multibyteTriangleAccumulate;

version (X86)
void multibyteSquare()(BigDigit[] result, const(BigDigit)[] x)
{
    if (__ctfe)
        std.internal.math.biguintnoasm.multibyteSquare(result, x);
    else version (D_InlineAsm_X86)
        std.internal.math.biguintx86.multibyteSquare(result, x);
    else
        std.internal.math.biguintnoasm.multibyteSquare(result, x);
}
else alias multibyteSquare = std.internal.math.biguintnoasm.multibyteSquare;

// Limits for when to switch between algorithms.
// Half the size of the data cache.
@nogc nothrow pure @safe size_t getCacheLimit()
{
    import core.cpuid : dataCaches;
    return dataCaches[0].size * 1024 / 2;
}
enum size_t FASTDIVLIMIT = 100; // crossover to recursive division


// These constants are used by shift operations
static if (BigDigit.sizeof == int.sizeof)
{
    enum { LG2BIGDIGITBITS = 5, BIGDIGITSHIFTMASK = 31 }
    alias BIGHALFDIGIT = ushort;
}
else static if (BigDigit.sizeof == long.sizeof)
{
    alias BIGHALFDIGIT = uint;
    enum { LG2BIGDIGITBITS = 6, BIGDIGITSHIFTMASK = 63 }
}
else static assert(0, "Unsupported BigDigit size");

import std.exception : assumeUnique;
import std.traits : isIntegral;
enum BigDigitBits = BigDigit.sizeof*8;
template maxBigDigits(T)
if (isIntegral!T)
{
    enum maxBigDigits = (T.sizeof+BigDigit.sizeof-1)/BigDigit.sizeof;
}

static immutable BigDigit[] ZERO = [0];
static immutable BigDigit[] ONE = [1];
static immutable BigDigit[] TWO = [2];
static immutable BigDigit[] TEN = [10];


public:

/// BigUint performs memory management and wraps the low-level calls.
struct BigUint
{
private:
    pure invariant()
    {
        assert( data.length >= 1 && (data.length == 1 || data[$-1] != 0 ),
                "Invariant requires data to not empty or zero");
    }

    immutable(BigDigit) [] data = ZERO;

    this(return scope immutable(BigDigit) [] x) pure nothrow @nogc @safe
    {
       data = x;
    }
  package(std)  // used from: std.bigint
    this(T)(T x) pure nothrow @safe scope if (isIntegral!T)
    {
        opAssign(x);
    }

    enum trustedAssumeUnique = function(BigDigit[] input) pure @trusted @nogc {
        return assumeUnique(input);
    };
public:
    // Length in uints
    @property size_t uintLength() pure nothrow const @safe @nogc scope
    {
        static if (BigDigit.sizeof == uint.sizeof)
        {
            return data.length;
        }
        else static if (BigDigit.sizeof == ulong.sizeof)
        {
            return data.length * 2 -
            ((data[$-1] & 0xFFFF_FFFF_0000_0000L) ? 1 : 0);
        }
    }
    @property size_t ulongLength() pure nothrow const @safe @nogc scope
    {
        static if (BigDigit.sizeof == uint.sizeof)
        {
            return (data.length + 1) >> 1;
        }
        else static if (BigDigit.sizeof == ulong.sizeof)
        {
            return data.length;
        }
    }

    // The value at (cast(ulong[]) data)[n]
    ulong peekUlong(size_t n) pure nothrow const @safe @nogc scope
    {
        static if (BigDigit.sizeof == int.sizeof)
        {
            if (data.length == n*2 + 1) return data[n*2];
            return data[n*2] + ((cast(ulong) data[n*2 + 1]) << 32 );
        }
        else static if (BigDigit.sizeof == long.sizeof)
        {
            return data[n];
        }
    }

    uint peekUint(size_t n) pure nothrow const @safe @nogc scope
    {
        static if (BigDigit.sizeof == int.sizeof)
        {
            return data[n];
        }
        else
        {
            immutable x = data[n >> 1];
            return (n & 1) ? cast(uint)(x >> 32) : cast(uint) x;
        }
    }

    ///
    void opAssign(Tulong)(Tulong u) pure nothrow @safe scope if (is (Tulong == ulong))
    {
        if (u == 0) data = ZERO;
        else if (u == 1) data = ONE;
        else if (u == 2) data = TWO;
        else if (u == 10) data = TEN;
        else
        {
            static if (BigDigit.sizeof == int.sizeof)
            {
                uint ulo = cast(uint)(u & 0xFFFF_FFFF);
                uint uhi = cast(uint)(u >> 32);
                if (uhi == 0)
                {
                    data = [ulo];
                }
                else
                {
                    data = [ulo, uhi];
                }
            }
            else static if (BigDigit.sizeof == long.sizeof)
            {
                data = [u];
            }
        }
    }
    void opAssign(Tdummy = void)(BigUint y) pure nothrow @nogc @safe scope
    {
        this.data = y.data;
    }

    ///
    int opCmp(Tdummy = void)(const BigUint y) pure nothrow @nogc const @safe scope
    {
        if (data.length != y.data.length)
            return (data.length > y.data.length) ?  1 : -1;
        size_t k = highestDifferentDigit(data, y.data);
        if (data[k] == y.data[k])
            return 0;
        return data[k] > y.data[k] ? 1 : -1;
    }

    ///
    int opCmp(Tulong)(Tulong y) pure nothrow @nogc const @safe scope if (is (Tulong == ulong))
    {
        if (data.length > maxBigDigits!Tulong)
            return 1;

        foreach_reverse (i; 0 .. maxBigDigits!Tulong)
        {
            BigDigit tmp = cast(BigDigit)(y>>(i*BigDigitBits));
            if (tmp == 0)
                if (data.length >= i+1)
                {
                    // Since ZERO is [0], so we cannot simply return 1 here, as
                    // data[i] would be 0 for i == 0 in that case.
                    return (data[i] > 0) ? 1 : 0;
                }
                else
                    continue;
            else
                if (i+1 > data.length)
                    return -1;
                else if (tmp != data[i])
                    return data[i] > tmp ? 1 : -1;
        }
        return 0;
    }

    bool opEquals(Tdummy = void)(ref const BigUint y) pure nothrow @nogc const @safe scope
    {
           return y.data[] == data[];
    }

    bool opEquals(Tdummy = void)(ulong y) pure nothrow @nogc const @safe scope
    {
        if (data.length > 2)
            return false;
        uint ylo = cast(uint)(y & 0xFFFF_FFFF);
        uint yhi = cast(uint)(y >> 32);
        if (data.length == 2 && data[1]!=yhi)
            return false;
        if (data.length == 1 && yhi != 0)
            return false;
        return (data[0] == ylo);
    }

    bool isZero() pure const nothrow @safe @nogc scope
    {
        return data.length == 1 && data[0] == 0;
    }

    size_t numBytes() pure nothrow const @safe @nogc scope
    {
        return data.length * BigDigit.sizeof;
    }

    // the extra bytes are added to the start of the string
    char [] toDecimalString(int frontExtraBytes) const pure nothrow @safe scope
    {
        immutable predictlength = 20+20*(data.length/2); // just over 19
        char [] buff = new char[frontExtraBytes + predictlength];
        ptrdiff_t sofar = biguintToDecimal(buff, data.dup);
        return buff[sofar-frontExtraBytes..$];
    }

    /** Convert to a hex string, printing a minimum number of digits 'minPadding',
     *  allocating an additional 'frontExtraBytes' at the start of the string.
     *  Padding is done with padChar, which may be '0' or ' '.
     *  'separator' is a digit separation character. If non-zero, it is inserted
     *  between every 8 digits.
     *  Separator characters do not contribute to the minPadding.
     */
    char [] toHexString(int frontExtraBytes, char separator = 0,
            int minPadding=0, char padChar = '0',
            LetterCase letterCase = LetterCase.upper) const pure nothrow @safe scope
    {
        // Calculate number of extra padding bytes
        size_t extraPad = (minPadding > data.length * 2 * BigDigit.sizeof)
            ? minPadding - data.length * 2 * BigDigit.sizeof : 0;

        // Length not including separator bytes
        size_t lenBytes = data.length * 2 * BigDigit.sizeof;

        // Calculate number of separator bytes
        size_t mainSeparatorBytes = separator ? (lenBytes  / 8) - 1 : 0;
        immutable totalSeparatorBytes = separator ? ((extraPad + lenBytes + 7) / 8) - 1: 0;

        char [] buff = new char[lenBytes + extraPad + totalSeparatorBytes + frontExtraBytes];
        biguintToHex(buff[$ - lenBytes - mainSeparatorBytes .. $], data, separator, letterCase);
        if (extraPad > 0)
        {
            if (separator)
            {
                size_t start = frontExtraBytes; // first index to pad
                if (extraPad &7)
                {
                    // Do 1 to 7 extra zeros.
                    buff[frontExtraBytes .. frontExtraBytes + (extraPad & 7)] = padChar;
                    buff[frontExtraBytes + (extraPad & 7)] = (padChar == ' ' ? ' ' : separator);
                    start += (extraPad & 7) + 1;
                }
                for (int i=0; i< (extraPad >> 3); ++i)
                {
                    buff[start .. start + 8] = padChar;
                    buff[start + 8] = (padChar == ' ' ? ' ' : separator);
                    start += 9;
                }
            }
            else
            {
                buff[frontExtraBytes .. frontExtraBytes + extraPad]=padChar;
            }
        }
        int z = frontExtraBytes;
        if (lenBytes > minPadding)
        {
            // Strip leading zeros.
            ptrdiff_t maxStrip = lenBytes - minPadding;
            while (z< buff.length-1 && (buff[z]=='0' || buff[z]==padChar) && maxStrip>0)
            {
                ++z;
                --maxStrip;
            }
        }
        if (padChar!='0')
        {
            // Convert leading zeros into padChars.
            for (size_t k= z; k< buff.length-1 && (buff[k]=='0' || buff[k]==padChar); ++k)
            {
                if (buff[k]=='0') buff[k]=padChar;
            }
        }
        return buff[z-frontExtraBytes..$];
    }

    /**
     * Convert to an octal string.
     */
    char[] toOctalString() pure nothrow @safe const scope
    {
        auto predictLength = 1 + data.length*BigDigitBits / 3;
        char[] buff = new char[predictLength];
        size_t firstNonZero = biguintToOctal(buff, data);
        return buff[firstNonZero .. $];
    }

    // return false if invalid character found
    bool fromHexString(Range)(Range s) scope if (
        isBidirectionalRange!Range && isSomeChar!(ElementType!Range))
    {
        import std.range : walkLength;

        //Strip leading zeros
        while (!s.empty && s.front == '0')
            s.popFront;

        if (s.empty)
        {
            data = ZERO;
            return true;
        }

        immutable len = (s.save.walkLength + 15) / 4;
        auto tmp = new BigDigit[len + 1];
        uint part, sofar, partcount;

        foreach_reverse (character; s)
        {
            if (character == '_')
                continue;

            uint x;
            if (character >= '0' && character <= '9')
            {
                x = character - '0';
            }
            else if (character >= 'A' && character <= 'F')
            {
                x = character - 'A' + 10;
            }
            else if (character >= 'a' && character <= 'f')
            {
                x = character - 'a' + 10;
            }
            else
            {
                return false;
            }

            part >>= 4;
            part |= (x << (32 - 4));
            ++partcount;

            if (partcount == 8)
            {
                tmp[sofar] = part;
                ++sofar;
                partcount = 0;
                part = 0;
            }
        }
        if (part)
        {
            for ( ; partcount != 8; ++partcount) part >>= 4;
            tmp[sofar] = part;
            ++sofar;
        }
        if (sofar == 0)
            data = ZERO;
        else
            data = trustedAssumeUnique(tmp[0 .. sofar]);

        return true;
    }

    // return true if OK; false if erroneous characters found
    bool fromDecimalString(Range)(Range s) scope if (
        isForwardRange!Range && isSomeChar!(ElementType!Range))
    {
        import std.range : walkLength;

        while (!s.empty && s.front == '0')
        {
            s.popFront;
        }

        if (s.empty)
        {
            data = ZERO;
            return true;
        }

        auto predict_length = (18 * 2 + 2 * s.save.walkLength) / 19;
        auto tmp = new BigDigit[predict_length];

        tmp.length = biguintFromDecimal(tmp, s);

        data = trustedAssumeUnique(tmp);
        return true;
    }

    void fromMagnitude(Range)(Range magnitude) scope
        if (isInputRange!Range
            && (isForwardRange!Range || hasLength!Range)
            && isUnsigned!(ElementType!Range))
    {
        while (!magnitude.empty && magnitude.front == 0)
            magnitude.popFront;
        static if (hasLength!Range)
            immutable inputLen = magnitude.length;
        else
            immutable inputLen = magnitude.save.walkLength;
        if (!inputLen)
        {
            this.data = ZERO;
            return;
        }
        // `magnitude` has its most significant element first but BigUint.data
        // stores the most significant last.
        BigDigit[] newDigits;
        alias E = ElementType!Range;
        static if (E.sizeof == BigDigit.sizeof)
        {
            newDigits = new BigDigit[inputLen];
            foreach_reverse (ref digit; newDigits)
            {
                digit = magnitude.front;
                magnitude.popFront();
            }
        }
        else static if (E.sizeof < BigDigit.sizeof)
        {
            enum elementsPerDigit = BigDigit.sizeof / E.sizeof;
            newDigits = new BigDigit[(inputLen + elementsPerDigit - 1) / elementsPerDigit];
            immutable remainder = inputLen % elementsPerDigit;
            // If there is a remainder specially assemble the most significant digit.
            if (remainder)
            {
                BigDigit tmp = magnitude.front;
                magnitude.popFront();
                foreach (_; 1 .. remainder)
                {
                    tmp = (tmp << (E.sizeof * 8)) | magnitude.front;
                    magnitude.popFront();
                }
                newDigits[$-1] = tmp;
            }
            // Assemble full digits from most to least significant.
            foreach_reverse (ref digit; newDigits[0 .. $ - int(remainder != 0)])
            {
                BigDigit tmp;
                static foreach (n; 0 .. elementsPerDigit)
                {
                    tmp |= cast(BigDigit) magnitude.front <<
                        ((BigDigit.sizeof - (E.sizeof * (n + 1))) * 8);
                    magnitude.popFront();
                }
                digit = tmp;
            }
        }
        else static if (E.sizeof > BigDigit.sizeof)
        {
            enum digitsPerElement = E.sizeof / BigDigit.sizeof;
            newDigits = new BigDigit[inputLen * digitsPerElement];
            size_t i = newDigits.length - 1;
            foreach (element; magnitude)
            {
                static foreach (n; 0 .. digitsPerElement)
                    newDigits[i - n] =
                        cast(BigDigit) (element >> ((E.sizeof - (BigDigit.sizeof * (n + 1))) * 8));
                i -= digitsPerElement;
            }
            while (newDigits[$-1] == 0)
                newDigits = newDigits[0 .. $-1];
        }
        else
            static assert(0);
        this.data = trustedAssumeUnique(newDigits);
        return;
    }

    nothrow pure @safe unittest
    {
        immutable BigDigit[] referenceData = [BigDigit(0x2003_4005), 0x6007_8009, 0xABCD];
        // Internal representation is most-significant-last but `fromMagnitude`
        // argument is most-significant-first.
        immutable BigDigit[] referenceMagnitude = [BigDigit(0xABCD), 0x6007_8009, 0x2003_4005];
        BigUint b;
        // Test with reference magnitude.
        b.fromMagnitude(referenceMagnitude);
        assert(b.data == referenceData);
        // Test ubyte array.
        import std.bitmanip : nativeToBigEndian;
        ubyte[] ubyteMagnitude = nativeToBigEndian(referenceMagnitude[0]) ~
            nativeToBigEndian(referenceMagnitude[1]) ~
            nativeToBigEndian(referenceMagnitude[2]);
        b.data = ZERO;
        b.fromMagnitude(ubyteMagnitude);
        assert(b.data == referenceData);
        // Test ulong array.
        static if (BigDigit.sizeof == uint.sizeof)
            immutable(ulong)[] ulongMagnitude = [ulong(referenceMagnitude[0]),
                ((cast(ulong) referenceMagnitude[1]) << 32) | referenceMagnitude[2],
            ];
        else static if (BigDigit.sizeof == ulong.sizeof)
            alias ulongMagnitude = referenceMagnitude;
        b.data = ZERO;
        b.fromMagnitude(ulongMagnitude);
        assert(b.data == referenceData);
    }

    ////////////////////////
    //
    // All of these member functions create a new BigUint.

    // return x >> y
    BigUint opBinary(string op, Tulong)(Tulong y) pure nothrow @safe const return scope
        if (op == ">>" && is (Tulong == ulong))
    {
        assert(y > 0, "Can not right shift BigUint by 0");
        uint bits = cast(uint) y & BIGDIGITSHIFTMASK;
        if ((y >> LG2BIGDIGITBITS) >= data.length) return BigUint(ZERO);
        uint words = cast(uint)(y >> LG2BIGDIGITBITS);
        if (bits == 0)
        {
            return BigUint(data[words..$]);
        }
        else
        {
            uint [] result = new BigDigit[data.length - words];
            multibyteShr(result, data[words..$], bits);

            if (result.length > 1 && result[$-1] == 0)
                return BigUint(trustedAssumeUnique(result[0 .. $-1]));
            else
                return BigUint(trustedAssumeUnique(result));
        }
    }

    // return x << y
    BigUint opBinary(string op, Tulong)(Tulong y) pure nothrow @safe const scope
        if (op == "<<" && is (Tulong == ulong))
    {
        assert(y > 0, "Can not left shift BigUint by 0");
        if (isZero()) return this;
        uint bits = cast(uint) y & BIGDIGITSHIFTMASK;
        assert((y >> LG2BIGDIGITBITS) < cast(ulong)(uint.max),
                "Shift result exceeds temporary store");
        uint words = cast(uint)(y >> LG2BIGDIGITBITS);
        BigDigit [] result = new BigDigit[data.length + words+1];
        result[0 .. words] = 0;
        if (bits == 0)
        {
            result[words .. words+data.length] = data[];
            return BigUint(trustedAssumeUnique(result[0 .. words+data.length]));
        }
        else
        {
            immutable c = multibyteShl(result[words .. words+data.length], data, bits);
            if (c == 0) return BigUint(trustedAssumeUnique(result[0 .. words+data.length]));
            result[$-1] = c;
            return BigUint(trustedAssumeUnique(result));
        }
    }

    // If wantSub is false, return x + y, leaving sign unchanged
    // If wantSub is true, return abs(x - y), negating sign if x < y
    static BigUint addOrSubInt(Tulong)(const scope BigUint x, Tulong y,
            bool wantSub, ref bool sign) pure nothrow @safe if (is(Tulong == ulong))
    {
        BigUint r;
        if (wantSub)
        {   // perform a subtraction
            if (x.data.length > 2)
            {
                // subInt returns GC allocated array, can be safely cast to immutable
                r.data = (() @trusted => cast(immutable) subInt(x.data, y))();
            }
            else
            {   // could change sign!
                ulong xx = x.data[0];
                if (x.data.length > 1)
                    xx += (cast(ulong) x.data[1]) << 32;
                ulong d;
                if (xx <= y)
                {
                    d = y - xx;
                    sign = !sign;
                }
                else
                {
                    d = xx - y;
                }
                if (d == 0)
                {
                    r = 0UL;
                    sign = false;
                    return r;
                }
                if (d > uint.max)
                {
                    r.data = [cast(uint)(d & 0xFFFF_FFFF), cast(uint)(d >> 32)];
                }
                else
                {
                    r.data = [cast(uint)(d & 0xFFFF_FFFF)];
                }
            }
        }
        else
        {
            // addInt returns GC allocated array, can be safely cast to immutable
            r.data = (() @trusted => cast(immutable) addInt(x.data, y))();
        }
        return r;
    }

    // If wantSub is false, return x + y, leaving sign unchanged.
    // If wantSub is true, return abs(x - y), negating sign if x<y
    static BigUint addOrSub(scope BigUint x, scope BigUint y, bool wantSub, ref bool sign)
        pure nothrow @safe
    {
        BigUint r;
        if (wantSub)
        {   // perform a subtraction
            bool negative;
            // sub returns GC allocated array, can be safely cast to immutable
            r.data = (() @trusted => cast(immutable) sub(x.data, y.data, &negative))();
            sign ^= negative;
            if (r.isZero())
            {
                sign = false;
            }
        }
        else
        {
            // add returns GC allocated array, can be safely cast to immutable
            r.data = (() @trusted => cast(immutable) add(x.data, y.data))();
        }
        return r;
    }


    //  return x*y.
    static BigUint mulInt(T = ulong)(BigUint x, T y) pure nothrow @safe
    {
        if (y == 0 || x == 0) return BigUint(ZERO);
        static if (T.sizeof * 8 <= 32)
            uint hi = 0;
        else
            uint hi = cast(uint) (y >>> 32);
        uint lo = cast(uint) (y & 0xFFFF_FFFF);
        uint [] result = new BigDigit[x.data.length+1+(hi != 0)];
        result[x.data.length] = multibyteMul(result[0 .. x.data.length], x.data, lo, 0);
        if (hi != 0)
        {
            result[x.data.length+1] = multibyteMulAdd!('+')(result[1 .. x.data.length+1],
                x.data, hi, 0);
        }
        return BigUint(removeLeadingZeros(trustedAssumeUnique(result)));
    }

    /*  return x * y.
     */
    static BigUint mul(scope BigUint x, scope BigUint y) pure nothrow @safe
    {
        if (y == 0 || x == 0)
            return BigUint(ZERO);
        auto len = x.data.length + y.data.length;
        BigDigit [] result = new BigDigit[len];
        if (y.data.length > x.data.length)
        {
            mulInternal(result, y.data, x.data);
        }
        else
        {
            if (x.data[]==y.data[]) squareInternal(result, x.data);
            else mulInternal(result, x.data, y.data);
        }
        // the highest element could be zero,
        // in which case we need to reduce the length
        return BigUint(removeLeadingZeros(trustedAssumeUnique(result)));
    }

    // return x / y
    static BigUint divInt(T)(return scope BigUint x, T y_) pure nothrow @safe
    if ( is(immutable T == immutable uint) )
    {
        uint y = y_;
        if (y == 1)
            return x;
        uint [] result = new BigDigit[x.data.length];
        if ((y&(-y))==y)
        {
            assert(y != 0, "BigUint division by zero");
            // perfect power of 2
            uint b = 0;
            for (;y != 1; y>>=1)
            {
                ++b;
            }
            multibyteShr(result, x.data, b);
        }
        else
        {
            result[] = x.data[];
            cast(void) multibyteDivAssign(result, y, 0);
        }
        return BigUint(removeLeadingZeros(trustedAssumeUnique(result)));
    }

    static BigUint divInt(T)(scope BigUint x, T y) pure nothrow @safe
    if ( is(immutable T == immutable ulong) )
    {
        if (y <= uint.max)
            return divInt!uint(x, cast(uint) y);
        if (x.data.length < 2)
            return BigUint(ZERO);
        uint hi = cast(uint)(y >>> 32);
        uint lo = cast(uint)(y & 0xFFFF_FFFF);
        immutable uint[2] z = [lo, hi];
        BigDigit[] result = new BigDigit[x.data.length - z.length + 1];
        divModInternal(result, null, x.data, z[]);
        return BigUint(removeLeadingZeros(trustedAssumeUnique(result)));
    }

    // return x % y
    static uint modInt(T)(scope BigUint x, T y_) pure if ( is(immutable T == immutable uint) )
    {
        import core.memory : GC;
        uint y = y_;
        assert(y != 0, "% 0 not allowed");
        if ((y&(-y)) == y)
        {   // perfect power of 2
            return x.data[0] & (y-1);
        }
        else
        {
            // horribly inefficient - malloc, copy, & store are unnecessary.
            uint [] wasteful = new BigDigit[x.data.length];
            wasteful[] = x.data[];
            immutable rem = multibyteDivAssign(wasteful, y, 0);
            () @trusted { GC.free(wasteful.ptr); } ();
            return rem;
        }
    }

    // return x / y
    static BigUint div(return scope BigUint x, scope BigUint y) pure nothrow @safe
    {
        if (y.data.length > x.data.length)
            return BigUint(ZERO);
        if (y.data.length == 1)
            return divInt(x, y.data[0]);
        BigDigit [] result = new BigDigit[x.data.length - y.data.length + 1];
           divModInternal(result, null, x.data, y.data);
        return BigUint(removeLeadingZeros(trustedAssumeUnique(result)));
    }

    // return x % y
    static BigUint mod(return scope BigUint x, scope BigUint y) pure nothrow @safe
    {
        if (y.data.length > x.data.length) return x;
        if (y.data.length == 1)
        {
            return BigUint([modInt(x, y.data[0])]);
        }
        BigDigit [] result = new BigDigit[x.data.length - y.data.length + 1];
        BigDigit [] rem = new BigDigit[y.data.length];
        divModInternal(result, rem, x.data, y.data);
        return BigUint(removeLeadingZeros(trustedAssumeUnique(rem)));
    }

    // Return x / y in quotient, x % y in remainder
    static void divMod(BigUint x, scope BigUint y,
                       out BigUint quotient, out BigUint remainder) pure nothrow @safe
    {
        /* TODO Qualify parameter `x` as `return` when it applies to `out` parameters */
        if (y.data.length > x.data.length)
        {
            quotient = 0uL;
            remainder = x;
        }
        else if (y.data.length == 1)
        {
            quotient = divInt(x, y.data[0]);
            remainder = BigUint([modInt(x, y.data[0])]);
        }
        else
        {
            BigDigit[] quot = new BigDigit[x.data.length - y.data.length + 1];
            BigDigit[] rem = new BigDigit[y.data.length];
            divModInternal(quot, rem, x.data, y.data);
            quotient = BigUint(removeLeadingZeros(trustedAssumeUnique(quot)));
            remainder = BigUint(removeLeadingZeros(trustedAssumeUnique(rem)));
        }
    }

    // return x op y
    static BigUint bitwiseOp(string op)(scope BigUint x, scope BigUint y, bool xSign, bool ySign, ref bool resultSign)
    pure nothrow @safe if (op == "|" || op == "^" || op == "&")
    {
        auto d1 = includeSign(x.data, y.uintLength, xSign);
        auto d2 = includeSign(y.data, x.uintLength, ySign);

        foreach (i; 0 .. d1.length)
        {
            mixin("d1[i] " ~ op ~ "= d2[i];");
        }

        mixin("resultSign = xSign " ~ op ~ " ySign;");

        if (resultSign)
        {
            twosComplement(d1, d1);
        }

        return BigUint(removeLeadingZeros(trustedAssumeUnique(d1)));
    }

    /**
     * Return a BigUint which is x raised to the power of y.
     * Method: Powers of 2 are removed from x, then left-to-right binary
     * exponentiation is used.
     * Memory allocation is minimized: at most one temporary BigUint is used.
     */
    static BigUint pow(return scope BigUint x, ulong y) pure nothrow @safe
    {
        // Deal with the degenerate cases first.
        if (y == 0) return BigUint(ONE);
        if (y == 1) return x;
        if (x == 0 || x == 1) return x;

        BigUint result;

        // Simplify, step 1: Remove all powers of 2.
        uint firstnonzero = firstNonZeroDigit(x.data);
        // Now we know x = x[firstnonzero..$] * (2^^(firstnonzero*BigDigitBits))
        // where BigDigitBits = BigDigit.sizeof * 8

        // See if x[firstnonzero..$] can now fit into a single digit.
        bool singledigit = ((x.data.length - firstnonzero) == 1);
        // If true, then x0 is that digit
        // and the result will be (x0 ^^ y) * (2^^(firstnonzero*y*BigDigitBits))
        BigDigit x0 = x.data[firstnonzero];
        assert(x0 != 0, "pow(0, y) not allowed");
        // Length of the non-zero portion
        size_t nonzerolength = x.data.length - firstnonzero;
        ulong y0;
        uint evenbits = 0; // number of even bits in the bottom of x
        while (!(x0 & 1))
        {
            x0 >>= 1;
            ++evenbits;
        }

        if (x.data.length- firstnonzero == 2)
        {
            // Check for a single digit straddling a digit boundary
            const BigDigit x1 = x.data[firstnonzero+1];
            if ((x1 >> evenbits) == 0)
            {
                x0 |= (x1 << (BigDigit.sizeof * 8 - evenbits));
                singledigit = true;
            }
        }
        // Now if (singledigit), x^^y  = (x0 ^^ y) * 2^^(evenbits * y) * 2^^(firstnonzero*y*BigDigitBits))

        uint evenshiftbits = 0; // Total powers of 2 to shift by, at the end

        // Simplify, step 2: For singledigits, see if we can trivially reduce y

        BigDigit finalMultiplier = 1UL;

        if (singledigit)
        {
            // x fits into a single digit. Raise it to the highest power we can
            // that still fits into a single digit, then reduce the exponent accordingly.
            // We're quite likely to have a residual multiply at the end.
            // For example, 10^^100 = (((5^^13)^^7) * 5^^9) * 2^^100.
            // and 5^^13 still fits into a uint.
            evenshiftbits  = cast(uint)( (evenbits * y) & BIGDIGITSHIFTMASK);
            if (x0 == 1)
            {   // Perfect power of 2
                result = 1UL;
                return result << (evenbits + firstnonzero * 8 * BigDigit.sizeof) * y;
            }
            immutable p = highestPowerBelowUintMax(x0);
            if (y <= p)
            {   // Just do it with pow
                result = cast(ulong) intpow(x0, y);
                if (evenbits + firstnonzero == 0)
                    return result;
                return result << (evenbits + firstnonzero * 8 * BigDigit.sizeof) * y;
            }
            y0 = y / p;
            finalMultiplier = intpow(x0, y - y0*p);
            x0 = intpow(x0, p);
            // Result is x0
            nonzerolength = 1;
        }
        // Now if (singledigit), x^^y  = finalMultiplier * (x0 ^^ y0) * 2^^(evenbits * y) * 2^^(firstnonzero*y*BigDigitBits))

        // Perform a crude check for overflow and allocate result buffer.
        // The length required is y * lg2(x) bits.
        // which will always fit into y*x.length digits. But this is
        // a gross overestimate if x is small (length 1 or 2) and the highest
        // digit is nearly empty.
        // A better estimate is:
        //   y * lg2(x[$-1]/BigDigit.max) + y * (x.length - 1) digits,
        //  and the first term is always between
        //  y * (bsr(x.data[$-1]) + 1) / BIGDIGITBITS and
        //  y * (bsr(x.data[$-1]) + 2) / BIGDIGITBITS
        // For single digit payloads, we already have
        //   x^^y  = finalMultiplier * (x0 ^^ y0) * 2^^(evenbits * y) * 2^^(firstnonzero*y*BigDigitBits))
        // and x0 is almost a full digit, so it's a tight estimate.
        // Number of digits is therefore 1 + x0.length*y0 + (evenbits*y)/BIGDIGIT + firstnonzero*y
        // Note that the divisions must be rounded up.

        // Estimated length in BigDigits
        immutable estimatelength = singledigit
            ? 1 + y0 + ((evenbits*y  + BigDigit.sizeof * 8 - 1) / (BigDigit.sizeof *8)) + firstnonzero*y
            :  x.data.length * y;
        // Imprecise check for overflow. Makes the extreme cases easier to debug
        // (less extreme overflow will result in an out of memory error).
        if (estimatelength > uint.max/(4*BigDigit.sizeof))
            assert(0, "Overflow in BigInt.pow");

        // The result buffer includes space for all the trailing zeros
        BigDigit [] resultBuffer = new BigDigit[cast(size_t) estimatelength];

        // Do all the powers of 2!
        size_t result_start = cast(size_t)( firstnonzero * y
            + (singledigit ? ((evenbits * y) >> LG2BIGDIGITBITS) : 0));

        resultBuffer[0 .. result_start] = 0;
        BigDigit [] t1 = resultBuffer[result_start..$];
        BigDigit [] r1;

        if (singledigit)
        {
            r1 = t1[0 .. 1];
            r1[0] = x0;
            y = y0;
        }
        else
        {
            // It's not worth right shifting by evenbits unless we also shrink the length after each
            // multiply or squaring operation. That might still be worthwhile for large y.
            r1 = t1[0 .. x.data.length - firstnonzero];
            r1[0..$] = x.data[firstnonzero..$];
        }

        if (y>1)
        {   // Set r1 = r1 ^^ y.
            // The secondary buffer only needs space for the multiplication results
            BigDigit [] t2 = new BigDigit[resultBuffer.length - result_start];
            BigDigit [] r2;

            int shifts = 63; // num bits in a long
            while (!(y & 0x8000_0000_0000_0000L))
            {
                y <<= 1;
                --shifts;
            }
            y <<=1;

            while (y != 0)
            {
                // For each bit of y: Set r1 =  r1 * r1
                // If the bit is 1, set r1 = r1 * x
                // Eg, if y is 0b101, result = ((x^^2)^^2)*x == x^^5.
                // Optimization opportunity: if more than 2 bits in y are set,
                // it's usually possible to reduce the number of multiplies
                // by caching odd powers of x. eg for y = 54,
                // (0b110110), set u = x^^3, and result is ((u^^8)*u)^^2
                r2 = t2[0 .. r1.length*2];
                squareInternal(r2, r1);
                if (y & 0x8000_0000_0000_0000L)
                {
                    r1 = t1[0 .. r2.length + nonzerolength];
                    if (singledigit)
                    {
                        r1[$-1] = multibyteMul(r1[0 .. $-1], r2, x0, 0);
                    }
                    else
                    {
                        mulInternal(r1, r2, x.data[firstnonzero..$]);
                    }
                }
                else
                {
                    r1 = t1[0 .. r2.length];
                    r1[] = r2[];
                }
                y <<=1;
                shifts--;
            }
            while (shifts>0)
            {
                r2 = t2[0 .. r1.length * 2];
                squareInternal(r2, r1);
                r1 = t1[0 .. r2.length];
                r1[] = r2[];
                --shifts;
            }
        }

        if (finalMultiplier != 1)
        {
            const BigDigit carry = multibyteMul(r1, r1, finalMultiplier, 0);
            if (carry)
            {
                r1 = t1[0 .. r1.length + 1];
                r1[$-1] = carry;
            }
        }
        if (evenshiftbits)
        {
            const BigDigit carry = multibyteShl(r1, r1, evenshiftbits);
            if (carry != 0)
            {
                r1 = t1[0 .. r1.length + 1];
                r1[$ - 1] = carry;
            }
        }
        while (r1[$ - 1]==0)
        {
            r1=r1[0 .. $ - 1];
        }
        return BigUint(trustedAssumeUnique(resultBuffer[0 .. result_start + r1.length]));
    }

    // Implement toHash so that BigUint works properly as an AA key.
    size_t toHash() const @nogc nothrow pure @safe scope
    {
        return .hashOf(data);
    }

} // end BigUint

@safe pure nothrow unittest
{
    // ulong comparison test
    BigUint a = [1];
    assert(a == 1);
    // https://issues.dlang.org/show_bug.cgi?id=9548
    assert(a < 0x8000_0000_0000_0000UL);

    // https://issues.dlang.org/show_bug.cgi?id=12234
    BigUint z = [0];
    assert(z == 0UL);
    assert(!(z > 0UL));
    assert(!(z < 0UL));
}

// https://issues.dlang.org/show_bug.cgi?id=16223
@system pure nothrow unittest
{
    BigUint a = [3];
    int b = 5;
    assert(BigUint.mulInt(a,b) == 15);
}

// Remove leading zeros from x, to restore the BigUint invariant
inout(BigDigit) [] removeLeadingZeros(return scope inout(BigDigit) [] x) pure nothrow @safe
{
    size_t k = x.length;
    while (k>1 && x[k - 1]==0) --k;
    return x[0 .. k];
}

pure @safe unittest
{
   BigUint r = BigUint([5]);
   BigUint t = BigUint([7]);
   BigUint s = BigUint.mod(r, t);
   assert(s == 5);
}


@safe pure unittest
{
    BigUint r;
    r = 5UL;
    assert(r.peekUlong(0) == 5UL);
    assert(r.peekUint(0) == 5U);
    r = 0x1234_5678_9ABC_DEF0UL;
    assert(r.peekUlong(0) == 0x1234_5678_9ABC_DEF0UL);
    assert(r.peekUint(0) == 0x9ABC_DEF0U);
}


// Pow tests
pure @safe unittest
{
    BigUint r, s;
    r.fromHexString("80000000_00000001");
    s = BigUint.pow(r, 5);
    r.fromHexString("08000000_00000000_50000000_00000001_40000000_00000002_80000000"
      ~ "_00000002_80000000_00000001");
    assert(s == r);
    s = 10UL;
    s = BigUint.pow(s, 39);
    r.fromDecimalString("1000000000000000000000000000000000000000");
    assert(s == r);
    r.fromHexString("1_E1178E81_00000000");
    s = BigUint.pow(r, 15); // Regression test: this used to overflow array bounds

    r.fromDecimalString("000_000_00");
    assert(r == 0);
    r.fromDecimalString("0007");
    assert(r == 7);
    r.fromDecimalString("0");
    assert(r == 0);
}

// Radix conversion tests
@safe pure unittest
{
    BigUint r;
    r.fromHexString("1_E1178E81_00000000");
    assert(r.toHexString(0, '_', 0) == "1_E1178E81_00000000");
    assert(r.toHexString(0, '_', 20) == "0001_E1178E81_00000000");
    assert(r.toHexString(0, '_', 16+8) == "00000001_E1178E81_00000000");
    assert(r.toHexString(0, '_', 16+9) == "0_00000001_E1178E81_00000000");
    assert(r.toHexString(0, '_', 16+8+8) ==   "00000000_00000001_E1178E81_00000000");
    assert(r.toHexString(0, '_', 16+8+8+1) ==      "0_00000000_00000001_E1178E81_00000000");
    assert(r.toHexString(0, '_', 16+8+8+1, ' ') == "                  1_E1178E81_00000000");
    assert(r.toHexString(0, 0, 16+8+8+1) == "00000000000000001E1178E8100000000");
    r = 0UL;
    assert(r.toHexString(0, '_', 0) == "0");
    assert(r.toHexString(0, '_', 7) == "0000000");
    assert(r.toHexString(0, '_', 7, ' ') == "      0");
    assert(r.toHexString(0, '#', 9) == "0#00000000");
    assert(r.toHexString(0, 0, 9) == "000000000");
}

//
@safe pure unittest
{
    BigUint r;
    r.fromHexString("1_E1178E81_00000000");
    assert(r.toHexString(0, '_', 0, '0', LetterCase.lower) == "1_e1178e81_00000000");
    assert(r.toHexString(0, '_', 20, '0', LetterCase.lower) == "0001_e1178e81_00000000");
    assert(r.toHexString(0, '_', 16+8, '0', LetterCase.lower) == "00000001_e1178e81_00000000");
    assert(r.toHexString(0, '_', 16+9, '0', LetterCase.lower) == "0_00000001_e1178e81_00000000");
    assert(r.toHexString(0, '_', 16+8+8, '0', LetterCase.lower) ==   "00000000_00000001_e1178e81_00000000");
    assert(r.toHexString(0, '_', 16+8+8+1, '0', LetterCase.lower) == "0_00000000_00000001_e1178e81_00000000");
    assert(r.toHexString(0, '_', 16+8+8+1, ' ', LetterCase.lower) == "                  1_e1178e81_00000000");
    assert(r.toHexString(0, 0, 16+8+8+1, '0', LetterCase.lower) == "00000000000000001e1178e8100000000");
    r = 0UL;
    assert(r.toHexString(0, '_', 0, '0', LetterCase.lower) == "0");
    assert(r.toHexString(0, '_', 7, '0', LetterCase.lower) == "0000000");
    assert(r.toHexString(0, '_', 7, ' ', LetterCase.lower) == "      0");
    assert(r.toHexString(0, '#', 9, '0', LetterCase.lower) == "0#00000000");
    assert(r.toHexString(0, 'Z', 9, '0', LetterCase.lower) == "0Z00000000");
    assert(r.toHexString(0, 0, 9, '0', LetterCase.lower) == "000000000");
}


private:
void twosComplement(const(BigDigit) [] x, BigDigit[] result)
pure nothrow @safe
{
    foreach (i; 0 .. x.length)
    {
        result[i] = ~x[i];
    }
    result[x.length..$] = BigDigit.max;

    foreach (i; 0 .. result.length)
    {
        if (result[i] == BigDigit.max)
        {
            result[i] = 0;
        }
        else
        {
            result[i] += 1;
            break;
        }
    }
}

// Encode BigInt as BigDigit array (sign and 2's complement)
BigDigit[] includeSign(scope const(BigDigit) [] x, size_t minSize, bool sign)
pure nothrow @safe
{
    size_t length = (x.length > minSize) ? x.length : minSize;
    BigDigit [] result = new BigDigit[length];
    if (sign)
    {
        twosComplement(x, result);
    }
    else
    {
        result[0 .. x.length] = x;
    }
    return result;
}

// works for any type
T intpow(T)(T x, ulong n) pure nothrow @safe
{
    T p;

    switch (n)
    {
    case 0:
        p = 1;
        break;

    case 1:
        p = x;
        break;

    case 2:
        p = x * x;
        break;

    default:
        p = 1;
        while (1)
        {
            if (n & 1)
                p *= x;
            n >>= 1;
            if (!n)
                break;
            x *= x;
        }
        break;
    }
    return p;
}


//  returns the maximum power of x that will fit in a uint.
int highestPowerBelowUintMax(uint x) pure nothrow @safe
{
     assert(x > 1, "x must be greater than 1");
     static immutable ubyte [22] maxpwr = [ 31, 20, 15, 13, 12, 11, 10, 10, 9, 9,
                                          8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7];
     if (x<24) return maxpwr[x-2];
     if (x<41) return 6;
     if (x<85) return 5;
     if (x<256) return 4;
     if (x<1626) return 3;
     if (x<65_536) return 2;
     return 1;
}

//  returns the maximum power of x that will fit in a ulong.
int highestPowerBelowUlongMax(uint x) pure nothrow @safe
{
     assert(x > 1, "x must be greater than 1");
     static immutable ubyte [39] maxpwr = [ 63, 40, 31, 27, 24, 22, 21, 20, 19, 18,
                                         17, 17, 16, 16, 15, 15, 15, 15, 14, 14,
                                         14, 14, 13, 13, 13, 13, 13, 13, 13, 12,
                                         12, 12, 12, 12, 12, 12, 12, 12, 12];
     if (x<41) return maxpwr[x-2];
     if (x<57) return 11;
     if (x<85) return 10;
     if (x<139) return 9;
     if (x<256) return 8;
     if (x<566) return 7;
     if (x<1626) return 6;
     if (x<7132) return 5;
     if (x<65_536) return 4;
     if (x<2_642_246) return 3;
     return 2;
}

version (StdUnittest)
{

private int slowHighestPowerBelowUintMax(uint x) pure nothrow @safe
{
     int pwr = 1;
     for (ulong q = x;x*q < cast(ulong) uint.max; )
     {
         q*=x; ++pwr;
     }
     return pwr;
}

@safe pure unittest
{
    assert(highestPowerBelowUintMax(10)==9);
    for (int k=82; k<88; ++k)
    {
        assert(highestPowerBelowUintMax(k)== slowHighestPowerBelowUintMax(k));
    }
}

}


/*  General unsigned subtraction routine for bigints.
 *  Sets result = x - y. If the result is negative, negative will be true.
 * Returns:
 *    unique memory
 */
BigDigit [] sub(const scope BigDigit [] x, const scope BigDigit [] y, bool *negative)
pure nothrow @safe
{
    if (x.length == y.length)
    {
        // There's a possibility of cancellation, if x and y are almost equal.
        ptrdiff_t last = highestDifferentDigit(x, y);
        BigDigit [] result = new BigDigit[last+1];
        if (x[last] < y[last])
        {   // we know result is negative
            multibyteSub(result[0 .. last+1], y[0 .. last+1], x[0 .. last+1], 0);
            *negative = true;
        }
        else
        {   // positive or zero result
            multibyteSub(result[0 .. last+1], x[0 .. last+1], y[0 .. last+1], 0);
            *negative = false;
        }
        while (result.length > 1 && result[$-1] == 0)
        {
            result = result[0..$-1];
        }
//        if (result.length >1 && result[$-1]==0) return result[0..$-1];
        return result;
    }
    // Lengths are different
    const(BigDigit) [] large, small;
    if (x.length < y.length)
    {
        *negative = true;
        large = y; small = x;
    }
    else
    {
        *negative = false;
        large = x; small = y;
    }
    // result.length will be equal to larger length, or could decrease by 1.


    BigDigit [] result = new BigDigit[large.length];
    BigDigit carry = multibyteSub(result[0 .. small.length], large[0 .. small.length], small, 0);
    result[small.length..$] = large[small.length..$];
    if (carry)
    {
        multibyteIncrementAssign!('-')(result[small.length..$], carry);
    }
    while (result.length > 1 && result[$-1] == 0)
    {
        result = result[0..$-1];
    }
    return result;
}


/*
 * return a + b
 * Returns:
 *    unique memory
 */
BigDigit [] add(const scope BigDigit [] a, const scope BigDigit [] b) pure nothrow @safe
{
    const(BigDigit) [] x, y;
    if (a.length < b.length)
    {
        x = b; y = a;
    }
    else
    {
        x = a; y = b;
    }
    // now we know x.length > y.length
    // create result. add 1 in case it overflows
    BigDigit [] result = new BigDigit[x.length + 1];

    BigDigit carry = multibyteAdd(result[0 .. y.length], x[0 .. y.length], y, 0);
    if (x.length != y.length)
    {
        result[y.length..$-1]= x[y.length..$];
        carry  = multibyteIncrementAssign!('+')(result[y.length..$-1], carry);
    }
    if (carry)
    {
        result[$-1] = carry;
        return result;
    }
    else
        return result[0..$-1];
}

/**  return x + y
 */
BigDigit [] addInt(const BigDigit[] x, ulong y) @safe pure nothrow
{
    uint hi = cast(uint)(y >>> 32);
    uint lo = cast(uint)(y& 0xFFFF_FFFF);
    auto len = x.length;
    if (x.length < 2 && hi != 0) ++len;
    BigDigit [] result = new BigDigit[len+1];
    result[0 .. x.length] = x[];
    if (x.length < 2 && hi != 0)
    {
        result[1]=hi;
        hi=0;
    }
    uint carry = multibyteIncrementAssign!('+')(result[0..$-1], lo);
    if (hi != 0) carry += multibyteIncrementAssign!('+')(result[1..$-1], hi);
    if (carry)
    {
        result[$-1] = carry;
        return result;
    }
    else
        return result[0..$-1];
}

/** Return x - y.
 *  x must be greater than y.
 */
BigDigit [] subInt(const BigDigit[] x, ulong y) pure nothrow @safe
{
    uint hi = cast(uint)(y >>> 32);
    uint lo = cast(uint)(y & 0xFFFF_FFFF);
    BigDigit [] result = new BigDigit[x.length];
    result[] = x[];
    multibyteIncrementAssign!('-')(result[], lo);
    if (hi)
        multibyteIncrementAssign!('-')(result[1..$], hi);
    if (result[$-1] == 0)
        return result[0..$-1];
    else
        return result;
}

/**  General unsigned multiply routine for bigints.
 *  Sets result = x * y.
 *
 *  The length of y must not be larger than the length of x.
 *  Different algorithms are used, depending on the lengths of x and y.
 *  TODO: "Modern Computer Arithmetic" suggests the OddEvenKaratsuba algorithm for the
 *  unbalanced case. (But I doubt it would be faster in practice).
 *
 */
void mulInternal(BigDigit[] result, const(BigDigit)[] x, const(BigDigit)[] y)
    pure nothrow @safe
{
    import core.memory : GC;
    assert( result.length == x.length + y.length,
            "result array must have enough space to store computed result");
    assert( y.length > 0, "y must not be empty");
    assert( x.length >= y.length, "x must be greater or equal than y");
    if (y.length <= KARATSUBALIMIT)
    {
        // Small multiplier, we'll just use the asm classic multiply.
        if (y.length == 1)
        {   // Trivial case, no cache effects to worry about
            result[x.length] = multibyteMul(result[0 .. x.length], x, y[0], 0);
            return;
        }

        immutable CACHELIMIT = getCacheLimit;
        if (x.length + y.length < CACHELIMIT)
            return mulSimple(result, x, y);

        // If x is so big that it won't fit into the cache, we divide it into chunks
        // Every chunk must be greater than y.length.
        // We make the first chunk shorter, if necessary, to ensure this.

        auto chunksize = CACHELIMIT / y.length;
        immutable residual  =  x.length % chunksize;
        if (residual < y.length)
        {
            chunksize -= y.length;
        }

        // Use schoolbook multiply.
        mulSimple(result[0 .. chunksize + y.length], x[0 .. chunksize], y);
        auto done = chunksize;

        while (done < x.length)
        {
            // result[done .. done+ylength] already has a value.
            chunksize = (done + (CACHELIMIT / y.length) < x.length) ? (CACHELIMIT / y.length) :  x.length - done;
            BigDigit [KARATSUBALIMIT] partial;
            partial[0 .. y.length] = result[done .. done+y.length];
            mulSimple(result[done .. done+chunksize+y.length], x[done .. done+chunksize], y);
            addAssignSimple(result[done .. done+chunksize + y.length], partial[0 .. y.length]);
            done += chunksize;
        }
        return;
    }

    immutable half = (x.length >> 1) + (x.length & 1);
    if (2*y.length*y.length <= x.length*x.length)
    {
        // UNBALANCED MULTIPLY
        // Use school multiply to cut into quasi-squares of Karatsuba-size
        // or larger. The ratio of the two sides of the 'square' must be
        // between 1.414:1 and 1:1. Use Karatsuba on each chunk.
        //
        // For maximum performance, we want the ratio to be as close to
        // 1:1 as possible. To achieve this, we can either pad x or y.
        // The best choice depends on the modulus x%y.
        auto numchunks = x.length / y.length;
        auto chunksize = y.length;
        auto extra =  x.length % y.length;
        auto maxchunk = chunksize + extra;
        bool paddingY; // true = we're padding Y, false = we're padding X.
        bool isExtraSmall = extra * extra * 2 < y.length * y.length;
        if (numchunks == 1 && isExtraSmall)
        {
            // We divide (x_first_half * y) and (x_last_half * y)
            // between 1.414:1 and 1.707:1 (1.707 = 1+1/sqrt(2)).
            // (1.414 ~ 1.707)/2:1 is balanced.
            BigDigit [] scratchbuff = new BigDigit[karatsubaRequiredBuffSize(y.length) + y.length];
            BigDigit [] partial = scratchbuff[$ - y.length .. $];
            scratchbuff = scratchbuff[0 .. $ - y.length];
            mulKaratsuba(result[0 .. half + y.length], y, x[0 .. half], scratchbuff);
            partial[] = result[half .. half + y.length];
            mulKaratsuba(result[half .. $], y, x[half .. $], scratchbuff);
            BigDigit c = addAssignSimple(result[half .. half + y.length], partial);
            if (c) multibyteIncrementAssign!('+')(result[half + y.length..$], c);
            () @trusted { GC.free(scratchbuff.ptr); } ();
        }
        else
        {
            if (isExtraSmall)
            {
                // The leftover bit is small enough that it should be incorporated
                // in the existing chunks.
                // Make all the chunks a tiny bit bigger
                // (We're padding y with zeros)
                chunksize += extra / numchunks;
                extra = x.length - chunksize*numchunks;
                // there will probably be a few left over.
                // Every chunk will either have size chunksize, or chunksize+1.
                maxchunk = chunksize + 1;
                paddingY = true;
                assert(chunksize + extra + chunksize *(numchunks-1) == x.length,
                    "Unexpected size");
            }
            else
            {
                // the extra bit is large enough that it's worth making a new chunk.
                // (This means we're padding x with zeros, when doing the first one).
                maxchunk = chunksize;
                ++numchunks;
                paddingY = false;
                assert(extra + chunksize *(numchunks-1) == x.length,
                    "Unexpected size");
            }
            // We make the buffer a bit bigger so we have space for the partial sums.
            BigDigit [] scratchbuff = new BigDigit[karatsubaRequiredBuffSize(maxchunk) + y.length];
            BigDigit [] partial = scratchbuff[$ - y.length .. $];
            scratchbuff = scratchbuff[0 .. $ - y.length];
            size_t done; // how much of X have we done so far?
            if (paddingY)
            {
                // If the first chunk is bigger, do it first. We're padding y.
                mulKaratsuba(result[0 .. y.length + chunksize + (extra > 0 ? 1 : 0 )],
                    x[0 .. chunksize + (extra>0?1:0)], y, scratchbuff);
                done = chunksize + (extra > 0 ? 1 : 0);
                if (extra) --extra;
            }
            else
            {   // We're padding X. Begin with the extra bit.
                mulKaratsuba(result[0 .. y.length + extra], y, x[0 .. extra], scratchbuff);
                done = extra;
                extra = 0;
            }
            immutable basechunksize = chunksize;
            while (done < x.length)
            {
                chunksize = basechunksize + (extra > 0 ? 1 : 0);
                if (extra) --extra;
                partial[] = result[done .. done+y.length];
                mulKaratsuba(result[done .. done + y.length + chunksize],
                        x[done .. done+chunksize], y, scratchbuff);
                addAssignSimple(result[done .. done + y.length + chunksize], partial);
                done += chunksize;
            }
            () @trusted { GC.free(scratchbuff.ptr); } ();
        }
    }
    else
    {
        // Balanced. Use Karatsuba directly.
        BigDigit [] scratchbuff = new BigDigit[karatsubaRequiredBuffSize(x.length)];
        mulKaratsuba(result, x, y, scratchbuff);
        () @trusted { GC.free(scratchbuff.ptr); } ();
    }
}

// https://issues.dlang.org/show_bug.cgi?id=20493
@safe unittest
{
    // the bug report has a testcase with very large numbers (~10^3800 and ~10^2300)
    // the number itself isn't important, only the amount of digits, so we do a simpler
    // multiplication of the same size, analogous to:
    // 11111111 * 11111111 = 0123456787654321
    // but instead of base 10, it's in base `BigDigit`

    BigDigit[398] x = 1;
    BigDigit[236] y = 1;
    BigDigit[x.length + y.length] result;
    mulInternal(result[], x[], y[]);

    // create an array of the form [1, 2, ..., y.length, ..., y.length, y.length-1, ..., 1, 0]
    BigDigit[x.length + y.length] expected = y.length;
    foreach (BigDigit i; 0 .. y.length)
    {
        expected[i] = i+1;
        expected[$-1-i] = i;
    }

    assert(result == expected);
}

/**  General unsigned squaring routine for BigInts.
 *   Sets result = x*x.
 *   NOTE: If the highest half-digit of x is zero, the highest digit of result will
 *   also be zero.
 */
void squareInternal(BigDigit[] result, const BigDigit[] x) pure nothrow @safe
{
  import core.memory : GC;
  // Squaring is potentially half a multiply, plus add the squares of
  // the diagonal elements.
  assert(result.length == 2*x.length,
     "result needs to have twice the capacity of x");
  if (x.length <= KARATSUBASQUARELIMIT)
  {
      if (x.length == 1)
      {
         result[1] = multibyteMul(result[0 .. 1], x, x[0], 0);
         return;
      }
      return squareSimple(result, x);
  }
  // The nice thing about squaring is that it always stays balanced
  BigDigit [] scratchbuff = new BigDigit[karatsubaRequiredBuffSize(x.length)];
  squareKaratsuba(result, x, scratchbuff);
  () @trusted { GC.free(scratchbuff.ptr); } ();
}


import core.bitop : bsr;

/// if remainder is null, only calculate quotient.
void divModInternal(BigDigit [] quotient, BigDigit[] remainder, const BigDigit [] u,
        const BigDigit [] v) pure nothrow @safe
{
    import core.memory : GC;
    assert(quotient.length == u.length - v.length + 1,
        "Invalid quotient length");
    assert(remainder == null || remainder.length == v.length,
        "Invalid remainder");
    assert(v.length > 1, "v must have more than 1 element");
    assert(u.length >= v.length, "u must be as longer or longer than v");

    // Normalize by shifting v left just enough so that
    // its high-order bit is on, and shift u left the
    // same amount. The highest bit of u will never be set.

    BigDigit [] vn = new BigDigit[v.length];
    BigDigit [] un = new BigDigit[u.length + 1];
    // How much to left shift v, so that its MSB is set.
    uint s = BIGDIGITSHIFTMASK - bsr(v[$-1]);
    if (s != 0)
    {
        multibyteShl(vn, v, s);
        un[$-1] = multibyteShl(un[0..$-1], u, s);
    }
    else
    {
        vn[] = v[];
        un[0..$-1] = u[];
        un[$-1] = 0;
    }
    if (quotient.length<FASTDIVLIMIT)
    {
        schoolbookDivMod(quotient, un, vn);
    }
    else
    {
        blockDivMod(quotient, un, vn);
    }

    // Unnormalize remainder, if required.
    if (remainder != null)
    {
        if (s == 0) remainder[] = un[0 .. vn.length];
        else multibyteShr(remainder, un[0 .. vn.length+1], s);
    }
    () @trusted { GC.free(un.ptr); GC.free(vn.ptr); } ();
}

pure @safe unittest
{
    immutable(uint) [] u = [0, 0xFFFF_FFFE, 0x8000_0000];
    immutable(uint) [] v = [0xFFFF_FFFF, 0x8000_0000];
    uint [] q = new uint[u.length - v.length + 1];
    uint [] r = new uint[2];
    divModInternal(q, r, u, v);
    assert(q[]==[0xFFFF_FFFFu, 0]);
    assert(r[]==[0xFFFF_FFFFu, 0x7FFF_FFFF]);
    u = [0, 0xFFFF_FFFE, 0x8000_0001];
    v = [0xFFFF_FFFF, 0x8000_0000];
    divModInternal(q, r, u, v);
}


// Converts a big uint to a hexadecimal string.
//
// Optionally, a separator character (eg, an underscore) may be added between
// every 8 digits.
// buff.length must be data.length*8 if separator is zero,
// or data.length*9 if separator is non-zero. It will be completely filled.
char [] biguintToHex(return scope char [] buff, const scope BigDigit [] data, char separator=0,
        LetterCas/** Arbitrary precision arithmetic ('bignum') for processors with no asm support
 *
 * All functions operate on arrays of uints, stored LSB first.
 * If there is a destination array, it will be the first parameter.
 * Currently, all of these functions are subject to change, and are
 * intended for internal use only.
 * This module is intended only to assist development of high-speed routines
 * on currently unsupported processors.
 * The X86 asm version is about 30 times faster than the D version (DMD).
 */

/*          Copyright Don Clugston 2008 - 2010.
 * Distributed under the Boost Software License, Version 1.0.
 *    (See accompanying file LICENSE_1_0.txt or copy at
 *          http://www.boost.org/LICENSE_1_0.txt)
 */

module std.internal.math.biguintnoasm;

nothrow:
@safe:

public:
alias BigDigit = uint; // A Bignum is an array of BigDigits.

    // Limits for when to switch between multiplication algorithms.
enum int KARATSUBALIMIT = 10; // Minimum value for which Karatsuba is worthwhile.
enum int KARATSUBASQUARELIMIT = 12; // Minimum value for which square Karatsuba is worthwhile


/** Multi-byte addition or subtraction
 *    dest[] = src1[] + src2[] + carry (0 or 1).
 * or dest[] = src1[] - src2[] - carry (0 or 1).
 * Returns carry or borrow (0 or 1).
 * Set op == '+' for addition, '-' for subtraction.
 */
uint multibyteAddSub(char op)(uint[] dest, const(uint) [] src1,
    const (uint) [] src2, uint carry) pure @nogc @safe
{
    ulong c = carry;
    for (size_t i = 0; i < src2.length; ++i)
    {
        static if (op=='+') c = c  + src1[i] + src2[i];
             else           c = cast(ulong) src1[i] - src2[i] - c;
        dest[i] = cast(uint) c;
        c = (c > 0xFFFF_FFFF);
    }
    return cast(uint) c;
}

@safe unittest
{
    uint [] a = new uint[40];
    uint [] b = new uint[40];
    uint [] c = new uint[40];
    for (size_t i = 0; i < a.length; ++i)
    {
        if (i&1) a[i]=cast(uint)(0x8000_0000 + i);
        else a[i]=cast(uint) i;
        b[i]= 0x8000_0003;
    }
    c[19]=0x3333_3333;
    uint carry = multibyteAddSub!('+')(c[0 .. 18], b[0 .. 18], a[0 .. 18], 0);
    assert(c[0]==0x8000_0003, "c[0] has invalid value");
    assert(c[1]==4, "c[1] must be for");
    assert(c[19]==0x3333_3333, "c[19] has invalid value"); // check for overrun
    assert(carry == 1, "carry must be 1");
    for (size_t i = 0; i < a.length; ++i)
    {
        a[i] = b[i] = c[i] = 0;
    }
    a[8]=0x048D159E;
    b[8]=0x048D159E;
    a[10]=0x1D950C84;
    b[10]=0x1D950C84;
    a[5] =0x44444444;
    carry = multibyteAddSub!('-')(a[0 .. 12], a[0 .. 12], b[0 .. 12], 0);
    assert(a[11] == 0, "a[11] must be 0");
    for (size_t i = 0; i < 10; ++i)
        if (i != 5)
            assert(a[i] == 0, "a[1] must be 0");

    for (size_t q = 3; q < 36; ++q)
    {
        for (size_t i = 0; i< a.length; ++i)
        {
            a[i] = b[i] = c[i] = 0;
        }
        a[q-2]=0x040000;
        b[q-2]=0x040000;
       carry = multibyteAddSub!('-')(a[0 .. q], a[0 .. q], b[0 .. q], 0);
       assert(a[q-2]==0, "a[q-2] must be 0");
    }
}



/** dest[] += carry, or dest[] -= carry.
 *  op must be '+' or '-'
 *  Returns final carry or borrow (0 or 1)
 */
uint multibyteIncrementAssign(char op)(uint[] dest, uint carry)
    pure @nogc @safe
{
    static if (op=='+')
    {
        ulong c = carry;
        c += dest[0];
        dest[0] = cast(uint) c;
        if (c <= 0xFFFF_FFFF)
            return 0;

        for (size_t i = 1; i < dest.length; ++i)
        {
            ++dest[i];
            if (dest[i] != 0)
                return 0;
        }
        return 1;
    }
    else
    {
        ulong c = carry;
        c = dest[0] - c;
        dest[0] = cast(uint) c;
        if (c <= 0xFFFF_FFFF)
            return 0;
        for (size_t i = 1; i < dest.length; ++i)
        {
            --dest[i];
            if (dest[i] != 0xFFFF_FFFF)
                return 0;
        }
        return 1;
    }
}

/** dest[] = src[] << numbits
 *  numbits must be in the range 1 .. 31
 */
uint multibyteShl(uint [] dest, const(uint) [] src, uint numbits)
    pure @nogc @safe
{
    ulong c = 0;
    for (size_t i = 0; i < dest.length; ++i)
    {
        c += (cast(ulong)(src[i]) << numbits);
        dest[i] = cast(uint) c;
        c >>>= 32;
   }
   return cast(uint) c;
}


/** dest[] = src[] >> numbits
 *  numbits must be in the range 1 .. 31
 */
void multibyteShr(uint [] dest, const(uint) [] src, uint numbits)
    pure @nogc @safe
{
    ulong c = 0;
    for (ptrdiff_t i = dest.length; i != 0; --i)
    {
        c += (src[i-1] >>numbits) + (cast(ulong)(src[i-1]) << (64 - numbits));
        dest[i-1] = cast(uint) c;
        c >>>= 32;
   }
}

@safe unittest
{

    uint [] aa = [0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];
    multibyteShr(aa[0..$-2], aa, 4);
    assert(aa[0] == 0x6122_2222 && aa[1] == 0xA455_5555 && aa[2] == 0x0899_9999);
    assert(aa[3] == 0xBCCC_CCCD);

    aa = [0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD, 0xEEEE_EEEE];
    multibyteShr(aa[0..$-1], aa, 4);
    assert(aa[0] == 0x6122_2222 && aa[1] == 0xA455_5555
        && aa[2] == 0xD899_9999 && aa[3] == 0x0BCC_CCCC);

    aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A, 0xBCCC_CCCD,
        0xEEEE_EEEE];
    multibyteShl(aa[1 .. 4], aa[1..$], 4);
    assert(aa[0] == 0xF0FF_FFFF && aa[1] == 0x2222_2230
        && aa[2]==0x5555_5561 && aa[3]==0x9999_99A4 && aa[4]==0x0BCCC_CCCD);
}

/** dest[] = src[] * multiplier + carry.
 * Returns carry.
 */
uint multibyteMul(uint[] dest, const(uint)[] src, uint multiplier, uint carry)
    pure @nogc @safe
{
    assert(dest.length == src.length, "dest and src must have the same length");
    ulong c = carry;
    for (size_t i = 0; i < src.length; ++i)
    {
        c += cast(ulong)(src[i]) * multiplier;
        dest[i] = cast(uint) c;
        c>>=32;
    }
    return cast(uint) c;
}

@safe unittest
{
    uint [] aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A,
        0xBCCC_CCCD, 0xEEEE_EEEE];
    multibyteMul(aa[1 .. 4], aa[1 .. 4], 16, 0);
    assert(aa[0] == 0xF0FF_FFFF && aa[1] == 0x2222_2230 && aa[2]==0x5555_5561
        && aa[3]==0x9999_99A4 && aa[4]==0x0BCCC_CCCD);
}

/**
 * dest[] += src[] * multiplier + carry(0 .. FFFF_FFFF).
 * Returns carry out of MSB (0 .. FFFF_FFFF).
 */
uint multibyteMulAdd(char op)(uint [] dest, const(uint)[] src,
    uint multiplier, uint carry) pure @nogc @safe
{
    assert(dest.length == src.length, "dest and src must have the same length");
    ulong c = carry;
    for (size_t i = 0; i < src.length; ++i)
    {
        static if (op=='+')
        {
            c += cast(ulong)(multiplier) * src[i]  + dest[i];
            dest[i] = cast(uint) c;
            c >>= 32;
        }
        else
        {
            c += cast(ulong) multiplier * src[i];
            ulong t = cast(ulong) dest[i] - cast(uint) c;
            dest[i] = cast(uint) t;
            c = cast(uint)((c >> 32) - (t >> 32));
        }
    }
    return cast(uint) c;
}

@safe unittest
{

    uint [] aa = [0xF0FF_FFFF, 0x1222_2223, 0x4555_5556, 0x8999_999A,
        0xBCCC_CCCD, 0xEEEE_EEEE];
    uint [] bb = [0x1234_1234, 0xF0F0_F0F0, 0x00C0_C0C0, 0xF0F0_F0F0,
        0xC0C0_C0C0];
    multibyteMulAdd!('+')(bb[1..$-1], aa[1..$-2], 16, 5);
    assert(bb[0] == 0x1234_1234 && bb[4] == 0xC0C0_C0C0);
    assert(bb[1] == 0x2222_2230 + 0xF0F0_F0F0 + 5
        && bb[2] == 0x5555_5561 + 0x00C0_C0C0 + 1
        && bb[3] == 0x9999_99A4 + 0xF0F0_F0F0 );
}


/**
   Sets result = result[0 .. left.length] + left * right

   It is defined in this way to allow cache-efficient multiplication.
   This function is equivalent to:
    ----
    for (size_t i = 0; i< right.length; ++i)
    {
        dest[left.length + i] = multibyteMulAdd(dest[i .. left.length+i],
                left, right[i], 0);
    }
    ----
 */
void multibyteMultiplyAccumulate(uint [] dest, const(uint)[] left, const(uint)
        [] right) pure @nogc @safe
{
    for (size_t i = 0; i < right.length; ++i)
    {
        dest[left.length + i] = multibyteMulAdd!('+')(dest[i .. left.length+i],
                left, right[i], 0);
    }
}

/**  dest[] /= divisor.
 * overflow is the initial remainder, and must be in the range 0 .. divisor-1.
 */
uint multibyteDivAssign(uint [] dest, uint divisor, uint overflow)
    pure @nogc @safe
{
    ulong c = cast(ulong) overflow;
    for (ptrdiff_t i = dest.length-1; i >= 0; --i)
    {
        c = (c << 32) + cast(ulong)(dest[i]);
        uint q = cast(uint)(c/divisor);
        c -= divisor * q;
        dest[i] = q;
    }
    return cast(uint) c;
}

@safe unittest
{
    uint [] aa = new uint[101];
    for (uint i = 0; i < aa.length; ++i)
        aa[i] = 0x8765_4321 * (i+3);
    uint overflow = multibyteMul(aa, aa, 0x8EFD_FCFB, 0x33FF_7461);
    uint r = multibyteDivAssign(aa, 0x8EFD_FCFB, overflow);
    for (uint i=0; i<aa.length; ++i)
    {
        assert(aa[i] == 0x8765_4321 * (i+3));
    }
    assert(r == 0x33FF_7461);

}
// Set dest[2*i .. 2*i+1]+=src[i]*src[i]
void multibyteAddDiagonalSquares(uint[] dest, const(uint)[] src)
    pure @nogc @safe
{
    ulong c = 0;
    for (size_t i = 0; i < src.length; ++i)
    {
        // At this point, c is 0 or 1, since FFFF*FFFF+FFFF_FFFF = 1_0000_0000.
        c += cast(ulong)(src[i]) * src[i] + dest[2*i];
        dest[2*i] = cast(uint) c;
        c = (c>>=32) + dest[2*i+1];
        dest[2*i+1] = cast(uint) c;
        c >>= 32;
    }
}

// Does half a square multiply. (square = diagonal + 2*triangle)
void multibyteTriangleAccumulate(uint[] dest, const(uint)[] x)
    pure @nogc @safe
{
    // x[0]*x[1...$] + x[1]*x[2..$] + ... + x[$-2]x[$-1..$]
    dest[x.length] = multibyteMul(dest[1 .. x.length], x[1..$], x[0], 0);
    if (x.length < 4)
    {
        if (x.length == 3)
        {
            ulong c = cast(ulong)(x[$-1]) * x[$-2]  + dest[2*x.length-3];
            dest[2*x.length - 3] = cast(uint) c;
            c >>= 32;
            dest[2*x.length - 2] = cast(uint) c;
        }
        return;
    }
    for (size_t i = 2; i < x.length - 2; ++i)
    {
        dest[i-1+ x.length] = multibyteMulAdd!('+')(
             dest[i+i-1 .. i+x.length-1], x[i..$], x[i-1], 0);
    }
        // Unroll the last two entries, to reduce loop overhead:
    ulong  c = cast(ulong)(x[$-3]) * x[$-2] + dest[2*x.length-5];
    dest[2*x.length-5] = cast(uint) c;
    c >>= 32;
    c += cast(ulong)(x[$-3]) * x[$-1] + dest[2*x.length-4];
    dest[2*x.length-4] = cast(uint) c;
    c >>= 32;
    c += cast(ulong)(x[$-1]) * x[$-2];
    dest[2*x.length-3] = cast(uint) c;
    c >>= 32;
    dest[2*x.length-2] = cast(uint) c;
}

void multibyteSquare(BigDigit[] result, const(BigDigit) [] x) pure @nogc @safe
{
    multibyteTriangleAccumulate(result, x);
    result[$-1] = multibyteShl(result[1..$-1], result[1..$-1], 1); // mul by 2
    result[0] = 0;
    multibyteAddDiagonalSquares(result, x);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * Error Functions and Normal Distribution.
 *
 * License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Copyright: Based on the CEPHES math library, which is
 *            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).
 * Authors:   Stephen L. Moshier, ported to D by Don Clugston and David Nadlinger
 */
/**
 * Macros:
 *  NAN = $(RED NAN)
 *  SUP = <span style="vertical-align:super;font-size:smaller">$0</span>
 *  GAMMA =  &#915;
 *  INTEGRAL = &#8747;
 *  INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)
 *  POWER = $1<sup>$2</sup>
 *  BIGSUM = $(BIG &Sigma; <sup>$2</sup><sub>$(SMALL $1)</sub>)
 *  CHOOSE = $(BIG &#40;) <sup>$(SMALL $1)</sup><sub>$(SMALL $2)</sub> $(BIG &#41;)
 *  TABLE_SV = <table border="1" cellpadding="4" cellspacing="0">
 *      <caption>Special Values</caption>
 *      $0</table>
 *  SVH = $(TR $(TH $1) $(TH $2))
 *  SV  = $(TR $(TD $1) $(TD $2))
 */
module std.internal.math.errorfunction;
import std.math;
import core.math : fabs, sqrt;

pure:
nothrow:
@safe:
@nogc:

private {
immutable real EXP_2  = 0.135335283236612691893999494972484403L; /* exp(-2) */
enum real SQRT2PI = 2.50662827463100050241576528481104525L; // sqrt(2pi)


enum real MAXLOG = 0x1.62e42fefa39ef358p+13L;  // log(real.max)
enum real MINLOG = -0x1.6436716d5406e6d8p+13L; // log(real.min*real.epsilon) = log(smallest denormal)
}

T rationalPoly(T)(T x, const(T) [] numerator, const(T) [] denominator) pure nothrow
{
    return poly(x, numerator)/poly(x, denominator);
}


private {

/* erfc(x) = exp(-x^2) P(1/x)/Q(1/x)
   1/8 <= 1/x <= 1
   Peak relative error 5.8e-21  */
immutable real[10] P = [ -0x1.30dfa809b3cc6676p-17L, 0x1.38637cd0913c0288p+18L,
   0x1.2f015e047b4476bp+22L, 0x1.24726f46aa9ab08p+25L, 0x1.64b13c6395dc9c26p+27L,
   0x1.294c93046ad55b5p+29L, 0x1.5962a82f92576dap+30L, 0x1.11a709299faba04ap+31L,
   0x1.11028065b087be46p+31L, 0x1.0d8ef40735b097ep+30L
];

immutable real[11] Q = [ 0x1.14d8e2a72dec49f4p+19L, 0x1.0c880ff467626e1p+23L,
   0x1.04417ef060b58996p+26L, 0x1.404e61ba86df4ebap+28L, 0x1.0f81887bc82b873ap+30L,
   0x1.4552a5e39fb49322p+31L, 0x1.11779a0ceb2a01cep+32L, 0x1.3544dd691b5b1d5cp+32L,
   0x1.a91781f12251f02ep+31L, 0x1.0d8ef3da605a1c86p+30L, 1.0L
];

// For 128 bit quadruple-precision floats, we use a higher-precision implementation
// with more polynomial segments.
enum isIEEEQuadruple = floatTraits!real.realFormat == RealFormat.ieeeQuadruple;
static if (isIEEEQuadruple)
{
    // erfc(x + 0.25) = erfc(0.25) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 1.4e-35
    immutable real[9] RNr13 = [
        -2.353707097641280550282633036456457014829E3L,
        3.871159656228743599994116143079870279866E2L,
        -3.888105134258266192210485617504098426679E2L,
        -2.129998539120061668038806696199343094971E1L,
        -8.125462263594034672468446317145384108734E1L,
        8.151549093983505810118308635926270319660E0L,
        -5.033362032729207310462422357772568553670E0L,
        -4.253956621135136090295893547735851168471E-2L,
        -8.098602878463854789780108161581050357814E-2L
    ];
    immutable real[9] RDr13 = [
        2.220448796306693503549505450626652881752E3L,
        1.899133258779578688791041599040951431383E2L,
        1.061906712284961110196427571557149268454E3L,
        7.497086072306967965180978101974566760042E1L,
        2.146796115662672795876463568170441327274E2L,
        1.120156008362573736664338015952284925592E1L,
        2.211014952075052616409845051695042741074E1L,
        6.469655675326150785692908453094054988938E-1L,
        1.0
    ];

    // erfc(0.25) = C13a + C13b to extra precision.
    immutable real C13a = 0.723663330078125L;
    immutable real C13b = 1.0279753638067014931732235184287934646022E-5L;

    // erfc(x + 0.375) = erfc(0.375) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 1.2e-35
    immutable real[9] RNr14 = [
        -2.446164016404426277577283038988918202456E3L,
        6.718753324496563913392217011618096698140E2L,
        -4.581631138049836157425391886957389240794E2L,
        -2.382844088987092233033215402335026078208E1L,
        -7.119237852400600507927038680970936336458E1L,
        1.313609646108420136332418282286454287146E1L,
        -6.188608702082264389155862490056401365834E0L,
        -2.787116601106678287277373011101132659279E-2L,
        -2.230395570574153963203348263549700967918E-2L
    ];
    immutable real[9] RDr14 = [
        2.495187439241869732696223349840963702875E3L,
        2.503549449872925580011284635695738412162E2L,
        1.159033560988895481698051531263861842461E3L,
        9.493751466542304491261487998684383688622E1L,
        2.276214929562354328261422263078480321204E2L,
        1.367697521219069280358984081407807931847E1L,
        2.276988395995528495055594829206582732682E1L,
        7.647745753648996559837591812375456641163E-1L,
        1.0L
    ];

    // erfc(0.375) = C14a + C14b to extra precision.
    immutable real C14a = 0.5958709716796875L;
    immutable real C14b = 1.2118885490201676174914080878232469565953E-5L;

    // erfc(x + 0.5) = erfc(0.5) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 4.7e-36
    immutable real[9] RNr15 = [
        -2.624212418011181487924855581955853461925E3L,
        8.473828904647825181073831556439301342756E2L,
        -5.286207458628380765099405359607331669027E2L,
        -3.895781234155315729088407259045269652318E1L,
        -6.200857908065163618041240848728398496256E1L,
        1.469324610346924001393137895116129204737E1L,
        -6.961356525370658572800674953305625578903E0L,
        5.145724386641163809595512876629030548495E-3L,
        1.990253655948179713415957791776180406812E-2L
    ];
    immutable real[9] RDr15 = [
        2.986190760847974943034021764693341524962E3L,
        5.288262758961073066335410218650047725985E2L,
        1.363649178071006978355113026427856008978E3L,
        1.921707975649915894241864988942255320833E2L,
        2.588651100651029023069013885900085533226E2L,
        2.628752920321455606558942309396855629459E1L,
        2.455649035885114308978333741080991380610E1L,
        1.378826653595128464383127836412100939126E0L,
        1.0L
    ];
    // erfc(0.5) = C15a + C15b to extra precision.
    immutable real C15a = 0.4794921875L;
    immutable real C15b = 7.9346869534623172533461080354712635484242E-6L;

    // erfc(x + 0.625) = erfc(0.625) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 5.1e-36
    immutable real[9] RNr16 = [
        -2.347887943200680563784690094002722906820E3L,
        8.008590660692105004780722726421020136482E2L,
        -5.257363310384119728760181252132311447963E2L,
        -4.471737717857801230450290232600243795637E1L,
        -4.849540386452573306708795324759300320304E1L,
        1.140885264677134679275986782978655952843E1L,
        -6.731591085460269447926746876983786152300E0L,
        1.370831653033047440345050025876085121231E-1L,
        2.022958279982138755020825717073966576670E-2L,
    ];
    immutable real[9] RDr16 = [
        3.075166170024837215399323264868308087281E3L,
        8.730468942160798031608053127270430036627E2L,
        1.458472799166340479742581949088453244767E3L,
        3.230423687568019709453130785873540386217E2L,
        2.804009872719893612081109617983169474655E2L,
        4.465334221323222943418085830026979293091E1L,
        2.612723259683205928103787842214809134746E1L,
        2.341526751185244109722204018543276124997E0L,
        1.0L
    ];
    // erfc(0.625) = C16a + C16b to extra precision.
    immutable real C16a = 0.3767547607421875L;
    immutable real C16b = 4.3570693945275513594941232097252997287766E-6L;

    // erfc(x + 0.75) = erfc(0.75) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 1.7e-35
    immutable real[9] RNr17 = [
        -1.767068734220277728233364375724380366826E3L,
        6.693746645665242832426891888805363898707E2L,
        -4.746224241837275958126060307406616817753E2L,
        -2.274160637728782675145666064841883803196E1L,
        -3.541232266140939050094370552538987982637E1L,
        6.988950514747052676394491563585179503865E0L,
        -5.807687216836540830881352383529281215100E0L,
        3.631915988567346438830283503729569443642E-1L,
        -1.488945487149634820537348176770282391202E-2L
    ];
    immutable real[9] RDr17 = [
        2.748457523498150741964464942246913394647E3L,
        1.020213390713477686776037331757871252652E3L,
        1.388857635935432621972601695296561952738E3L,
        3.903363681143817750895999579637315491087E2L,
        2.784568344378139499217928969529219886578E2L,
        5.555800830216764702779238020065345401144E1L,
        2.646215470959050279430447295801291168941E1L,
        2.984905282103517497081766758550112011265E0L,
        1.0L
    ];
    // erfc(0.75) = C17a + C17b to extra precision.
    immutable real C17a = 0.2888336181640625L;
    immutable real C17b = 1.0748182422368401062165408589222625794046E-5L;


    // erfc(x + 0.875) = erfc(0.875) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 2.2e-35
    immutable real[9] RNr18 = [
        -1.342044899087593397419622771847219619588E3L,
        6.127221294229172997509252330961641850598E2L,
        -4.519821356522291185621206350470820610727E2L,
        1.223275177825128732497510264197915160235E1L,
        -2.730789571382971355625020710543532867692E1L,
        4.045181204921538886880171727755445395862E0L,
        -4.925146477876592723401384464691452700539E0L,
        5.933878036611279244654299924101068088582E-1L,
        -5.557645435858916025452563379795159124753E-2L
    ];
    immutable real[9] RDr18 = [
        2.557518000661700588758505116291983092951E3L,
        1.070171433382888994954602511991940418588E3L,
        1.344842834423493081054489613250688918709E3L,
        4.161144478449381901208660598266288188426E2L,
        2.763670252219855198052378138756906980422E2L,
        5.998153487868943708236273854747564557632E1L,
        2.657695108438628847733050476209037025318E1L,
        3.252140524394421868923289114410336976512E0L,
        1.0L
    ];

    // erfc(0.875) = C18a + C18b to extra precision.
    immutable real C18a = 0.215911865234375L;
    immutable real C18b = 1.3073705765341685464282101150637224028267E-5L;

    // erfc(x + 1.0) = erfc(1.0) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 1.6e-35
    immutable real[9] RNr19 = [
        -1.139180936454157193495882956565663294826E3L,
        6.134903129086899737514712477207945973616E2L,
        -4.628909024715329562325555164720732868263E2L,
        4.165702387210732352564932347500364010833E1L,
        -2.286979913515229747204101330405771801610E1L,
        1.870695256449872743066783202326943667722E0L,
        -4.177486601273105752879868187237000032364E0L,
        7.533980372789646140112424811291782526263E-1L,
        -8.629945436917752003058064731308767664446E-2L
    ];
    immutable real[9] RDr19 = [
        2.744303447981132701432716278363418643778E3L,
        1.266396359526187065222528050591302171471E3L,
        1.466739461422073351497972255511919814273E3L,
        4.868710570759693955597496520298058147162E2L,
        2.993694301559756046478189634131722579643E2L,
        6.868976819510254139741559102693828237440E1L,
        2.801505816247677193480190483913753613630E1L,
        3.604439909194350263552750347742663954481E0L,
        1.0L
    ];

    // erfc(1.0) = C19a + C19b to extra precision.
    immutable real C19a = 0.15728759765625L;
    immutable real C19b = 1.1609394035130658779364917390740703933002E-5L;

    // erfc(x + 1.125) = erfc(1.125) + x R(x)
    // 0 <= x < 0.125
    // Peak relative error 3.6e-36
    immutable real[9] RNr20 = [
        -9.652706916457973956366721379612508047640E2L,
        5.577066396050932776683469951773643880634E2L,
        -4.406335508848496713572223098693575485978E2L,
        5.202893466490242733570232680736966655434E1L,
        -1.931311847665757913322495948705563937159E1L,
        -9.364318268748287664267341457164918090611E-2L,
        -3.306390351286352764891355375882586201069E0L,
        7.573806045289044647727613003096916516475E-1L,
        -9.611744011489092894027478899545635991213E-2L
    ];
    immutable real[9] RDr20 = [
        3.032829629520142564106649167182428189014E3L,
        1.659648470721967719961167083684972196891E3L,
        1.703545128657284619402511356932569292535E3L,
        6.393465677731598872500200253155257708763E2L,
        3.489131397281030947405287112726059221934E2L,
        8.848641738570783406484348434387611713070E1L,
        3.132269062552392974833215844236160958502E1L,
        4.430131663290563523933419966185230513168E0L,
        1.0L
    ];

    // erfc(1.125) = C20a + C20b to extra precision.
    immutable real C20a = 0.111602783203125L;
    immutable real C20b = 8.9850951672359304215530728365232161564636E-6L;

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 7/8 <= 1/x < 1
    // Peak relative error 1.4e-35
    immutable real[10] RNr8 = [
        3.587451489255356250759834295199296936784E1L,
        5.406249749087340431871378009874875889602E2L,
        2.931301290625250886238822286506381194157E3L,
        7.359254185241795584113047248898753470923E3L,
        9.201031849810636104112101947312492532314E3L,
        5.749697096193191467751650366613289284777E3L,
        1.710415234419860825710780802678697889231E3L,
        2.150753982543378580859546706243022719599E2L,
        8.740953582272147335100537849981160931197E0L,
        4.876422978828717219629814794707963640913E-2L
    ];
    immutable real[10] RDr8 = [
        6.358593134096908350929496535931630140282E1L,
        9.900253816552450073757174323424051765523E2L,
        5.642928777856801020545245437089490805186E3L,
        1.524195375199570868195152698617273739609E4L,
        2.113829644500006749947332935305800887345E4L,
        1.526438562626465706267943737310282977138E4L,
        5.561370922149241457131421914140039411782E3L,
        9.394035530179705051609070428036834496942E2L,
        6.147019596150394577984175188032707343615E1L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 3/4 <= 1/x < 7/8
    // Peak relative error 1.7e-36
    immutable real[10] RNr7 = [
        1.293515364043117601705535485785956592493E2L,
        2.474534371269189867053251150063459055230E3L,
        1.756537563959875738809491329250457486510E4L,
        5.977479535376639763773153344676726091607E4L,
        1.054313816139671870123172936972055385049E5L,
        9.754699773487726957401038094714603033904E4L,
        4.579131242577671038339922925213209214880E4L,
        1.000710322164510887997115157797717324370E4L,
        8.496863250712471449526805271633794700452E2L,
        1.797349831386892396933210199236530557333E1L
    ];
    immutable real[11] RDr7 = [
        2.292696320307033494820399866075534515002E2L,
        4.500632608295626968062258401895610053116E3L,
        3.321218723485498111535866988511716659339E4L,
        1.196084512221845156596781258490840961462E5L,
        2.287033883912529843927983406878910939930E5L,
        2.370223495794642027268482075021298394425E5L,
        1.305173734022437154610938308944995159199E5L,
        3.589386258485887630236490009835928559621E4L,
        4.339996864041074149726360516336773136101E3L,
        1.753135522665469574605384979152863899099E2L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 5/8 <= 1/x < 3/4
    // Peak relative error 1.6e-35
    immutable real[10] RNr6 = [
        1.423313561367394923305025174137639124533E1L,
        3.244462503273003837514629113846075327206E2L,
        2.784937282403293364911673341412846781934E3L,
        1.163060685810874867196849890286455473382E4L,
        2.554141394931962276102205517358731053756E4L,
        2.982733782500729530503336931258698708782E4L,
        1.789683564523810605328169719436374742840E4L,
        5.056032142227470121262177112822018882754E3L,
        5.605349942234782054561269306895707034586E2L,
        1.561652599080729507274832243665726064881E1L
    ];
    immutable real[11] RDr6 = [
        2.522757606611479946069351519410222913326E1L,
        5.876797910931896554014229647006604017806E2L,
        5.211092128250480712011248211246144751074E3L,
        2.282679910855404599271496827409168580797E4L,
        5.371245819205596609986320599133109262447E4L,
        6.926186102106400355114925675028888924445E4L,
        4.794366033363621432575096487724913414473E4L,
        1.673190682734065914573814938835674963896E4L,
        2.589544846151313120096957014256536236242E3L,
        1.349438432583208276883323156200117027433E2L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 1/2 <= 1/x < 5/8
    // Peak relative error 4.3e-36
    immutable real[11] RNr5 = [
        6.743447478279267339131211137241149796763E-2L,
        2.031339015932962998168472743355874796350E0L,
        2.369234815713196480221800940201367484379E1L,
        1.387819614016107433603101545594790875922E2L,
        4.435600256936515839937720907171966121786E2L,
        7.881577949936817507981170892417739733047E2L,
        7.615749099291545976179905281851765734680E2L,
        3.752484528663442467089606663006771157777E2L,
        8.279644286027145214308303292537009564726E1L,
        6.201462983413738162709722770960040042647E0L,
        6.649631608720062333043506249503378282697E-2L
    ];
    immutable real[11] RDr5 = [
        1.195244945161889822018178270706903972343E-1L,
        3.660216908153253021384862427197665991311E0L,
        4.373405883243078019655721779021995159854E1L,
        2.653305963056235008916733402786877121865E2L,
        8.921329790491152046318422124415895506335E2L,
        1.705552231555600759729260640562363304312E3L,
        1.832711109606893446763174603477244625325E3L,
        1.056823953275835649973998168744261083316E3L,
        2.975561981792909722126456997074344895584E2L,
        3.393149095158232521894537008472203487436E1L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 3/8 <= 1/x < 1/2
    // Peak relative error 1.8e-36
    immutable real[11] RNr4 = [
        3.558685919236420073872459554885612994007E-2L,
        1.460223642496950651561817195253277924528E0L,
        2.379856746555189546876720308841066577268E1L,
        2.005205521246554860334064698817220160117E2L,
        9.533374928664989955629120027419490517596E2L,
        2.623024576994438336130421711314560425373E3L,
        4.126446434603735586340585027628851620886E3L,
        3.540675861596687801829655387867654030013E3L,
        1.506037084891064572653273761987617394259E3L,
        2.630715699182706745867272452228891752353E2L,
        1.202476629652900619635409242749750364878E1L
    ];
    immutable real[12] RDr4 = [
        6.307606561714590590399683184410336583739E-2L,
        2.619717051134271249293056836082721776665E0L,
        4.344441402681725017630451522968410844608E1L,
        3.752891116408399440953195184301023399176E2L,
        1.849305988804654653921972804388006355502E3L,
        5.358505261991675891835885654499883449403E3L,
        9.091890995405251314631428721090705475825E3L,
        8.731418313949291797856351745278287516416E3L,
        4.420211285043270337492325400764271868740E3L,
        1.031487363021856106882306509107923200832E3L,
        8.387036084846046121805145056040429461783E1L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 1/4 <= 1/x < 3/8
    // Peak relative error 8.1e-37
    immutable real[12] RNr3 = [
        4.584481542956275354582319313040418316755E-5L,
        2.674923158288848442110883948437930349128E-3L,
        6.344232532055212248017211243740466847311E-2L,
        7.985145965992002744933550450451513513963E-1L,
        5.845078061888281665064746347663123946270E0L,
        2.566625318816866587482759497608029522596E1L,
        6.736225182343446605268837827950856640948E1L,
        1.021796460139598089409347761712730512053E2L,
        8.344336615515430530929955615400706619764E1L,
        3.207749011528249356283897356277376306967E1L,
        4.386185123863412086856423971695142026036E0L,
        8.971576448581208351826868348023528863856E-2L
    ];
    immutable real[12] RDr3 = [
        8.125781965218112303281657065320409661370E-5L,
        4.781806762611504685247817818428945295520E-3L,
        1.147785538413798317790357996845767614561E-1L,
        1.469285552007088106614218996464752307606E0L,
        1.101712261349880339221039938999124077650E1L,
        5.008507527095093413713171655268276861071E1L,
        1.383058691613468970486425146336829447433E2L,
        2.264114250278912520501010108736339599752E2L,
        2.081377197698598680576330179979996940039E2L,
        9.724438129690013609440151781601781137944E1L,
        1.907905050771832372089975877589291760121E1L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 1/8 <= 1/x < 1/4
    // Peak relative error 1.5e-36
    immutable real[12] RNr2 = [
        6.928615158005256885698045840589513728399E-7L,
        5.616245938942075826026382337922413007879E-5L,
        1.871624980715261794832358438894219696113E-3L,
        3.349922063795792371642023765253747563009E-2L,
        3.531865233974349943956345502463135695834E-1L,
        2.264714157625072773976468825160906342360E0L,
        8.810720294489253776747319730638214883026E0L,
        2.014056685571655833019183248931442888437E1L,
        2.524586947657190747039554310814128743320E1L,
        1.520656940937208886246188940244581671609E1L,
        3.334145500790963675035841482334493680498E0L,
        1.122108380007109245896534245151140632457E-1L
    ];
    immutable real[12] RDr2 = [
        1.228065061824874795984937092427781089256E-6L,
        1.001593999520159167559129042893802235969E-4L,
        3.366527555699367241421450749821030974446E-3L,
        6.098626947195865254152265585991861150369E-2L,
        6.541547922508613985813189387198804660235E-1L,
        4.301130233305371976727117480925676583204E0L,
        1.737155892350891711527711121692994762909E1L,
        4.206892112110558214680649401236873828801E1L,
        5.787487996025016843403524261574779631219E1L,
        4.094047148590822715163181507813774861621E1L,
        1.230603930056944875836549716515643997094E1L,
        1.0L
    ];

    // erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
    // 1/128 <= 1/x < 1/8
    // Peak relative error 2.2e-36
    immutable real[10] RNr1 = [
        1.293111801138199795250035229383033322539E-6L,
        9.785224720880980456171438759161161816706E-5L,
        2.932474396233212166056331430621176065943E-3L,
        4.496429595719847083917435337780697436921E-2L,
        3.805989855927720844877478869846718877846E-1L,
        1.789745532222426292126781724570152590071E0L,
        4.465737379634389318903237306594171764628E0L,
        5.268535822258082278401240171488850433767E0L,
        2.258357766807433839494276681092713991651E0L,
        1.504459334078750002966538036652860809497E-1L
    ];
    immutable real[10] RDr1 = [
        2.291980991578770070179177302906728371406E-6L,
        1.745845828808028552029674694534934620384E-4L,
        5.283248841982102317072923869576785278019E-3L,
        8.221212297078141470944454807434634848018E-2L,
        7.120500674861902950423510939060230945621E-1L,
        3.475435367560809622183983439133664598155E0L,
        9.243253391989233533874386043611304387113E0L,
        1.227894792475280941511758877318903197188E1L,
        6.789361410398841316638617624392719077724E0L,
        1.0L
    ];

    // erf(z+1)  = erfConst + P(z)/Q(z)
    // -.125 <= z <= 0
    // Peak relative error 7.3e-36
    immutable real erfConst = 0.845062911510467529296875L;
    immutable real[9] TN2 = [
        -4.088889697077485301010486931817357000235E1L,
        7.157046430681808553842307502826960051036E3L,
        -2.191561912574409865550015485451373731780E3L,
        2.180174916555316874988981177654057337219E3L,
        2.848578658049670668231333682379720943455E2L,
        1.630362490952512836762810462174798925274E2L,
        6.317712353961866974143739396865293596895E0L,
        2.450441034183492434655586496522857578066E1L,
        5.127662277706787664956025545897050896203E-1L
    ];
    immutable real[10] TD2 = [
        1.731026445926834008273768924015161048885E4L,
        1.209682239007990370796112604286048173750E4L,
        1.160950290217993641320602282462976163857E4L,
        5.394294645127126577825507169061355698157E3L,
        2.791239340533632669442158497532521776093E3L,
        8.989365571337319032943005387378993827684E2L,
        2.974016493766349409725385710897298069677E2L,
        6.148192754590376378740261072533527271947E1L,
        1.178502892490738445655468927408440847480E1L,
        1.0L
    ];

    // erf(x)  = x + x P(x^2)/Q(x^2)
    // 0 <= x <= 7/8
    // Peak relative error 1.8e-35
    immutable real[9] TN1 = [
        -3.858252324254637124543172907442106422373E10L,
        9.580319248590464682316366876952214879858E10L,
        1.302170519734879977595901236693040544854E10L,
        2.922956950426397417800321486727032845006E9L,
        1.764317520783319397868923218385468729799E8L,
        1.573436014601118630105796794840834145120E7L,
        4.028077380105721388745632295157816229289E5L,
        1.644056806467289066852135096352853491530E4L,
        3.390868480059991640235675479463287886081E1L
    ];
    immutable real[10] TD1 = [
        -3.005357030696532927149885530689529032152E11L,
        -1.342602283126282827411658673839982164042E11L,
        -2.777153893355340961288511024443668743399E10L,
        -3.483826391033531996955620074072768276974E9L,
        -2.906321047071299585682722511260895227921E8L,
        -1.653347985722154162439387878512427542691E7L,
        -6.245520581562848778466500301865173123136E5L,
        -1.402124304177498828590239373389110545142E4L,
        -1.209368072473510674493129989468348633579E2L,
        1.0L
    ];
}
else
{
    /* erfc(x) = exp(-x^2) 1/x R(1/x^2) / S(1/x^2)
       1/128 <= 1/x < 1/8
       Peak relative error 1.9e-21  */
    immutable real[5] R = [ 0x1.b9f6d8b78e22459ep-6L, 0x1.1b84686b0a4ea43ap-1L,
       0x1.b8f6aebe96000c2ap+1L, 0x1.cb1dbedac27c8ec2p+2L, 0x1.cf885f8f572a4c14p+1L
    ];

    immutable real[6] S = [
       0x1.87ae3cae5f65eb5ep-5L, 0x1.01616f266f306d08p+0L, 0x1.a4abe0411eed6c22p+2L,
       0x1.eac9ce3da600abaap+3L, 0x1.5752a9ac2faebbccp+3L, 1.0L
    ];

    /* erf(x)  = x P(x^2)/Q(x^2)
       0 <= x <= 1
       Peak relative error 7.6e-23  */
    immutable real[7] T = [ 0x1.0da01654d757888cp+20L, 0x1.2eb7497bc8b4f4acp+17L,
       0x1.79078c19530f72a8p+15L, 0x1.4eaf2126c0b2c23p+11L, 0x1.1f2ea81c9d272a2ep+8L,
       0x1.59ca6e2d866e625p+2L, 0x1.c188e0b67435faf4p-4L
    ];

    immutable real[7] U = [ 0x1.dde6025c395ae34ep+19L, 0x1.c4bc8b6235df35aap+18L,
       0x1.8465900e88b6903ap+16L, 0x1.855877093959ffdp+13L, 0x1.e5c44395625ee358p+9L,
       0x1.6a0fed103f1c68a6p+5L, 1.0L
    ];
}
}

/**
 *  Complementary error function
 *
 * erfc(x) = 1 - erf(x), and has high relative accuracy for
 * values of x far from zero. (For values near zero, use erf(x)).
 *
 *  1 - erf(x) =  2/ $(SQRT)(&pi;)
 *     $(INTEGRAL x, $(INFINITY)) exp( - $(POWER t, 2)) dt
 *
 *
 * For small x, erfc(x) = 1 - erf(x); otherwise rational
 * approximations are computed.
 *
 * A special function expx2(x) is used to suppress error amplification
 * in computing exp(-x^2).
 */
real erfc(real a)
{
    if (a == real.infinity)
        return 0.0;
    if (a == -real.infinity)
        return 2.0;

    immutable x = (a < 0.0) ? -a : a;

    if (x < (isIEEEQuadruple ? 0.25 : 1.0))
        return 1.0 - erf(a);

    static if (isIEEEQuadruple)
    {
        if (x < 1.25)
        {
            real y;
            final switch (cast(int)(8.0 * x))
            {
                case 2:
                    const z = x - 0.25;
                    y = C13b + z * rationalPoly(z, RNr13, RDr13);
                    y += C13a;
                    break;
                case 3:
                    const z = x - 0.375;
                    y = C14b + z * rationalPoly(z, RNr14, RDr14);
                    y += C14a;
                    break;
                case 4:
                    const z = x - 0.5;
                    y = C15b + z * rationalPoly(z, RNr15, RDr15);
                    y += C15a;
                    break;
                case 5:
                    const z = x - 0.625;
                    y = C16b + z * rationalPoly(z, RNr16, RDr16);
                    y += C16a;
                    break;
                case 6:
                    const z = x - 0.75;
                    y = C17b + z * rationalPoly(z, RNr17, RDr17);
                    y += C17a;
                    break;
                case 7:
                    const z = x - 0.875;
                    y = C18b + z * rationalPoly(z, RNr18, RDr18);
                    y += C18a;
                    break;
                case 8:
                    const z = x - 1.0;
                    y = C19b + z * rationalPoly(z, RNr19, RDr19);
                    y += C19a;
                    break;
                case 9:
                    const z = x - 1.125;
                    y = C20b + z * rationalPoly(z, RNr20, RDr20);
                    y += C20a;
                    break;
            }
            if (a < 0.0)
                y = 2.0 - y;
            return y;
        }
    }

    if (-a * a < -MAXLOG)
    {
        // underflow
        if (a < 0.0) return 2.0;
        else return 0.0;
    }

    real y;
    immutable z = expx2(a, -1);

    static if (isIEEEQuadruple)
    {
        y = z * erfce(x);
    }
    else
    {
        y = 1.0 / x;
        if (x < 8.0)
            y = z * rationalPoly(y, P, Q);
        else
            y = z * y * rationalPoly(y * y, R, S);
    }

    if (a < 0.0)
        y = 2.0 - y;

    if (y == 0.0)
    {
        // underflow
        if (a < 0.0) return 2.0;
        else return 0.0;
    }

    return y;
}


private {
/* Exponentially scaled erfc function
   exp(x^2) erfc(x)
   valid for x > 1.
   Use with normalDistribution and expx2.  */
static if (isIEEEQuadruple)
{
    real erfce(real x)
    {
        immutable z = 1.0L / (x * x);

        real p;
        switch (cast(int)(8.0 / x))
        {
            default:
            case 0:
                p = rationalPoly(z, RNr1, RDr1);
                break;
            case 1:
                p = rationalPoly(z, RNr2, RDr2);
                break;
            case 2:
                p = rationalPoly(z, RNr3, RDr3);
                break;
            case 3:
                p = rationalPoly(z, RNr4, RDr4);
                break;
            case 4:
                p = rationalPoly(z, RNr5, RDr5);
                break;
            case 5:
                p = rationalPoly(z, RNr6, RDr6);
                break;
            case 6:
                p = rationalPoly(z, RNr7, RDr7);
                break;
            case 7:
                p = rationalPoly(z, RNr8, RDr8);
                break;
        }
        return p / x;
    }
}
else
{
    real erfce(real x)
    {
        real y = 1.0/x;

        if (x < 8.0)
        {
            return rationalPoly(y, P, Q);
        }
        else
        {
            return y * rationalPoly(y * y, R, S);
        }
    }
}
}

/**
 *  Error function
 *
 * The integral is
 *
 *  erf(x) =  2/ $(SQRT)(&pi;)
 *     $(INTEGRAL 0, x) exp( - $(POWER t, 2)) dt
 *
 * The magnitude of x is limited to about 106.56 for IEEE 80-bit
 * arithmetic; 1 or -1 is returned outside this range.
 *
 * For 0 <= |x| < 1, a rational polynomials are used; otherwise
 * erf(x) = 1 - erfc(x).
 *
 * ACCURACY:
 *                      Relative error:
 * arithmetic   domain     # trials      peak         rms
 *    IEEE      0,1         50000       2.0e-19     5.7e-20
 */
real erf(real x)
{
    if (x == 0.0)
        return x; // deal with negative zero
    if (x == -real.infinity)
        return -1.0;
    if (x == real.infinity)
        return 1.0;
    immutable ax = fabs(x);
    if (ax > 1.0L)
        return 1.0L - erfc(x);

    static if (isIEEEQuadruple)
    {
        immutable z = x * x;

        real y;
        if (ax < 0.875)
        {
            y = ax + ax * rationalPoly(x * x, TN1, TD1);
        }
        else
        {
            y = erfConst + rationalPoly(ax - 1.0L, TN2, TD2);
        }

        if (x < 0)
            y = -y;
        return y;
    }
    else
    {
        real z = x * x;
        return x * rationalPoly(x * x, T, U);
    }
}

@safe unittest
{
    // High resolution test points.
    enum real erfc0_250 = 0.723663330078125L + 1.0279753638067014931732235184287934646022E-5L;
    enum real erfc0_375 = 0.5958709716796875L + 1.2118885490201676174914080878232469565953E-5L;
    enum real erfc0_500 = 0.4794921875L + 7.9346869534623172533461080354712635484242E-6L;
    enum real erfc0_625 = 0.3767547607421875L + 4.3570693945275513594941232097252997287766E-6L;
    enum real erfc0_750 = 0.2888336181640625L + 1.0748182422368401062165408589222625794046E-5L;
    enum real erfc0_875 = 0.215911865234375L + 1.3073705765341685464282101150637224028267E-5L;
    enum real erfc1_000 = 0.15728759765625L + 1.1609394035130658779364917390740703933002E-5L;
    enum real erfc1_125 = 0.111602783203125L + 8.9850951672359304215530728365232161564636E-6L;

    enum real erf0_875  = (1-0.215911865234375L) - 1.3073705765341685464282101150637224028267E-5L;

    static bool isNaNWithPayload(real x, ulong payload) @safe pure nothrow @nogc
    {
      return isNaN(x) && getNaNPayload(x) == payload;
    }

    assert(feqrel(erfc(0.250L), erfc0_250 )>=real.mant_dig-1);
    assert(feqrel(erfc(0.375L), erfc0_375 )>=real.mant_dig-0);
    assert(feqrel(erfc(0.500L), erfc0_500 )>=real.mant_dig-2);
    assert(feqrel(erfc(0.625L), erfc0_625 )>=real.mant_dig-1);
    assert(feqrel(erfc(0.750L), erfc0_750 )>=real.mant_dig-1);
    assert(feqrel(erfc(0.875L), erfc0_875 )>=real.mant_dig-4);
    assert(feqrel(erfc(1.000L), erfc1_000 )>=real.mant_dig-2);
    assert(feqrel(erfc(1.125L), erfc1_125 )>=real.mant_dig-2);
    assert(feqrel(erf(0.875L), erf0_875 )>=real.mant_dig-1);
    // The DMC implementation of erfc() fails this next test (just).
    // Test point from Mathematica 11.0.
    assert(feqrel(erfc(4.1L), 6.70002765408489837272673380763418472e-9L) >= real.mant_dig-5);

    assert(isIdentical(erf(0.0),0.0));
    assert(isIdentical(erf(-0.0),-0.0));
    assert(erf(real.infinity) == 1.0);
    assert(erf(-real.infinity) == -1.0);
    assert(isNaNWithPayload(erf(NaN(0xDEF)), 0xDEF));
    assert(isNaNWithPayload(erfc(NaN(0xDEF)), 0xDEF));
    assert(isIdentical(erfc(real.infinity),0.0));
    assert(erfc(-real.infinity) == 2.0);
    assert(erfc(0) == 1.0);
}

/*
 *  Exponential of squared argument
 *
 * Computes y = exp(x*x) while suppressing error amplification
 * that would ordinarily arise from the inexactness of the
 * exponential argument x*x.
 *
 * If sign < 0, the result is inverted; i.e., y = exp(-x*x) .
 *
 * ACCURACY:
 *                      Relative error:
 * arithmetic      domain        # trials      peak         rms
 *   IEEE     -106.566, 106.566    10^5       1.6e-19     4.4e-20
 */

real expx2(real x, int sign)
{
    /*
    Cephes Math Library Release 2.9:  June, 2000
    Copyright 2000 by Stephen L. Moshier
    */
    const real M = 32_768.0;
    const real MINV = 3.0517578125e-5L;

    x = fabs(x);
    if (sign < 0)
        x = -x;

  /* Represent x as an exact multiple of M plus a residual.
     M is a power of 2 chosen so that exp(m * m) does not overflow
     or underflow and so that |x - m| is small.  */
    real m = MINV * floor(M * x + 0.5L);
    real f = x - m;

    /* x^2 = m^2 + 2mf + f^2 */
    real u = m * m;
    real u1 = 2 * m * f  +  f * f;

    if (sign < 0)
    {
        u = -u;
        u1 = -u1;
    }

    if ((u+u1) > MAXLOG)
        return real.infinity;

    /* u is exact, u1 is small.  */
    return exp(u) * exp(u1);
}


/*
Computes the normal distribution function.

The normal (or Gaussian, or bell-shaped) distribution is
defined as:

normalDist(x) = 1/$(SQRT) &pi; $(INTEGRAL -$(INFINITY), x) exp( - $(POWER t, 2)/2) dt
    = 0.5 + 0.5 * erf(x/sqrt(2))
    = 0.5 * erfc(- x/sqrt(2))

To maintain accuracy at high values of x, use
normalDistribution(x) = 1 - normalDistribution(-x).

Accuracy:
Within a few bits of machine resolution over the entire
range.

References:
$(LINK http://www.netlib.org/cephes/ldoubdoc.html),
G. Marsaglia, "Evaluating the Normal Distribution",
Journal of Statistical Software <b>11</b>, (July 2004).
*/
real normalDistributionImpl(real a)
{
    real x = a * SQRT1_2;
    real z = fabs(x);

    if ( z < 1.0 )
        return 0.5L + 0.5L * erf(x);
    else
    {
        real y = 0.5L * erfce(z);
        /* Multiply by exp(-x^2 / 2)  */
        z = expx2(a, -1);
        y = y * sqrt(z);
        if ( x > 0.0L )
            y = 1.0L - y;
        return y;
    }
}

@safe unittest
{
assert(fabs(normalDistributionImpl(1L) - (0.841344746068543L)) < 0.0000000000000005L);
assert(isIdentical(normalDistributionImpl(NaN(0x325)), NaN(0x325)));
}

/*
 * Inverse of Normal distribution function
 *
 * Returns the argument, x, for which the area under the
 * Normal probability density function (integrated from
 * minus infinity to x) is equal to p.
 *
 * For small arguments 0 < p < exp(-2), the program computes
 * z = sqrt( -2 log(p) );  then the approximation is
 * x = z - log(z)/z  - (1/z) P(1/z) / Q(1/z) .
 * For larger arguments,  x/sqrt(2 pi) = w + w^3 R(w^2)/S(w^2)) ,
 * where w = p - 0.5.
 */
// TODO: isIEEEQuadruple (128 bit) real implementation; not available from CEPHES.
real normalDistributionInvImpl(real p)
in {
  assert(p >= 0.0L && p <= 1.0L, "Domain error");
}
do
{
static immutable real[8] P0 =
[ -0x1.758f4d969484bfdcp-7L, 0x1.53cee17a59259dd2p-3L,
   -0x1.ea01e4400a9427a2p-1L,  0x1.61f7504a0105341ap+1L, -0x1.09475a594d0399f6p+2L,
    0x1.7c59e7a0df99e3e2p+1L, -0x1.87a81da52edcdf14p-1L,  0x1.1fb149fd3f83600cp-7L
];

static immutable real[8] Q0 =
[ -0x1.64b92ae791e64bb2p-7L, 0x1.7585c7d597298286p-3L,
   -0x1.40011be4f7591ce6p+0L, 0x1.1fc067d8430a425ep+2L, -0x1.21008ffb1e7ccdf2p+3L,
   0x1.3d1581cf9bc12fccp+3L, -0x1.53723a89fd8f083cp+2L, 1.0L
];

static immutable real[10] P1 =
[ 0x1.20ceea49ea142f12p-13L, 0x1.cbe8a7267aea80bp-7L,
   0x1.79fea765aa787c48p-2L, 0x1.d1f59faa1f4c4864p+1L, 0x1.1c22e426a013bb96p+4L,
   0x1.a8675a0c51ef3202p+5L, 0x1.75782c4f83614164p+6L, 0x1.7a2f3d90948f1666p+6L,
   0x1.5cd116ee4c088c3ap+5L, 0x1.1361e3eb6e3cc20ap+2L
];

static immutable real[10] Q1 =
[ 0x1.3a4ce1406cea98fap-13L, 0x1.f45332623335cda2p-7L,
   0x1.98f28bbd4b98db1p-2L, 0x1.ec3b24f9c698091cp+1L, 0x1.1cc56ecda7cf58e4p+4L,
   0x1.92c6f7376bf8c058p+5L, 0x1.4154c25aa47519b4p+6L, 0x1.1b321d3b927849eap+6L,
   0x1.403a5f5a4ce7b202p+4L, 1.0L
];

static immutable real[8] P2 =
[ 0x1.8c124a850116a6d8p-21L, 0x1.534abda3c2fb90bap-13L,
   0x1.29a055ec93a4718cp-7L, 0x1.6468e98aad6dd474p-3L, 0x1.3dab2ef4c67a601cp+0L,
   0x1.e1fb3a1e70c67464p+1L, 0x1.b6cce8035ff57b02p+2L, 0x1.9f4c9e749ff35f62p+1L
];

static immutable real[8] Q2 =
[ 0x1.af03f4fc0655e006p-21L, 0x1.713192048d11fb2p-13L,
   0x1.4357e5bbf5fef536p-7L, 0x1.7fdac8749985d43cp-3L, 0x1.4a080c813a2d8e84p+0L,
   0x1.c3a4b423cdb41bdap+1L, 0x1.8160694e24b5557ap+2L, 1.0L
];

static immutable real[8] P3 =
[ -0x1.55da447ae3806168p-34L, -0x1.145635641f8778a6p-24L,
 -0x1.abf46d6b48040128p-17L, -0x1.7da550945da790fcp-11L, -0x1.aa0b2a31157775fap-8L,
   0x1.b11d97522eed26bcp-3L, 0x1.1106d22f9ae89238p+1L, 0x1.029a358e1e630f64p+1L
];

static immutable real[8] Q3 =
[ -0x1.74022dd5523e6f84p-34L, -0x1.2cb60d61e29ee836p-24L,
   -0x1.d19e6ec03a85e556p-17L, -0x1.9ea2a7b4422f6502p-11L, -0x1.c54b1e852f107162p-8L,
   0x1.e05268dd3c07989ep-3L, 0x1.239c6aff14afbf82p+1L, 1.0L
];

    if (p <= 0.0L || p >= 1.0L)
    {
        if (p == 0.0L)
            return -real.infinity;
        if ( p == 1.0L )
            return real.infinity;
        return real.nan; // domain error
    }
    int code = 1;
    real y = p;
    if ( y > (1.0L - EXP_2) )
    {
        y = 1.0L - y;
        code = 0;
    }

    real x, z, y2, x0, x1;

    if ( y > EXP_2 )
    {
        y = y - 0.5L;
        y2 = y * y;
        x = y + y * (y2 * rationalPoly( y2, P0, Q0));
        return x * SQRT2PI;
    }

    x = sqrt( -2.0L * log(y) );
    x0 = x - log(x)/x;
    z = 1.0L/x;
    if ( x < 8.0L )
    {
        x1 = z * rationalPoly( z, P1, Q1);
    }
    else if ( x < 32.0L )
    {
        x1 = z * rationalPoly( z, P2, Q2);
    }
    else
    {
        x1 = z * rationalPoly( z, P3, Q3);
    }
    x = x0 - x1;
    if ( code != 0 )
    {
        x = -x;
    }
    return x;
}


@safe unittest
{
    // TODO: Use verified test points.
    // The values below are from Excel 2003.
    assert(fabs(normalDistributionInvImpl(0.001) - (-3.09023230616779L)) < 0.00000000000005L);
    assert(fabs(normalDistributionInvImpl(1e-50) - (-14.9333375347885L)) < 0.00000000000005L);
    assert(feqrel(normalDistributionInvImpl(0.999L), -normalDistributionInvImpl(0.001L)) > real.mant_dig-6);

    // Excel 2003 gets all the following values wrong!
    assert(normalDistributionInvImpl(0.0) == -real.infinity);
    assert(normalDistributionInvImpl(1.0) == real.infinity);
    assert(normalDistributionInvImpl(0.5) == 0);
    // (Excel 2003 returns norminv(p) = -30 for all p < 1e-200).
    // The value tested here is the one the function returned in Jan 2006.
    real unknown1 = normalDistributionInvImpl(1e-250L);
    assert( fabs(unknown1 -(-33.79958617269L) ) < 0.00000005L);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /**
 * Implementation of the gamma and beta functions, and their integrals.
 *
 * License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Copyright: Based on the CEPHES math library, which is
 *            Copyright (C) 1994 Stephen L. Moshier (moshier@world.std.com).
 * Authors:   Stephen L. Moshier (original C code). Conversion to D by Don Clugston
 *
 *
Macros:
 *  TABLE_SV = <table border="1" cellpadding="4" cellspacing="0">
 *      <caption>Special Values</caption>
 *      $0</table>
 *  SVH = $(TR $(TH $1) $(TH $2))
 *  SV  = $(TR $(TD $1) $(TD $2))
 *  GAMMA =  &#915;
 *  INTEGRATE = $(BIG &#8747;<sub>$(SMALL $1)</sub><sup>$2</sup>)
 *  POWER = $1<sup>$2</sup>
 *  NAN = $(RED NAN)
 */
module std.internal.math.gammafunction;
import std.internal.math.errorfunction;
import std.math;
import core.math : fabs, sin, sqrt;

pure:
nothrow:
@safe:
@nogc:

private {

enum real SQRT2PI = 2.50662827463100050242E0L; // sqrt(2pi)
immutable real EULERGAMMA = 0.57721_56649_01532_86060_65120_90082_40243_10421_59335_93992L; /** Euler-Mascheroni constant 0.57721566.. */

// Polynomial approximations for gamma and loggamma.

immutable real[8] GammaNumeratorCoeffs = [ 1.0L,
    0x1.acf42d903366539ep-1L, 0x1.73a991c8475f1aeap-2L, 0x1.c7e918751d6b2a92p-4L,
    0x1.86d162cca32cfe86p-6L, 0x1.0c378e2e6eaf7cd8p-8L, 0x1.dc5c66b7d05feb54p-12L,
    0x1.616457b47e448694p-15L
];

immutable real[9] GammaDenominatorCoeffs = [ 1.0L,
  0x1.a8f9faae5d8fc8bp-2L,  -0x1.cb7895a6756eebdep-3L,  -0x1.7b9bab006d30652ap-5L,
  0x1.c671af78f312082ep-6L, -0x1.a11ebbfaf96252dcp-11L, -0x1.447b4d2230a77ddap-10L,
  0x1.ec1d45bb85e06696p-13L,-0x1.d4ce24d05bd0a8e6p-17L
];

immutable real[9] GammaSmallCoeffs = [ 1.0L,
    0x1.2788cfc6fb618f52p-1L, -0x1.4fcf4026afa2f7ecp-1L, -0x1.5815e8fa24d7e306p-5L,
    0x1.5512320aea2ad71ap-3L, -0x1.59af0fb9d82e216p-5L,  -0x1.3b4b61d3bfdf244ap-7L,
    0x1.d9358e9d9d69fd34p-8L, -0x1.38fc4bcbada775d6p-10L
];

immutable real[9] GammaSmallNegCoeffs = [ -1.0L,
    0x1.2788cfc6fb618f54p-1L, 0x1.4fcf4026afa2bc4cp-1L, -0x1.5815e8fa2468fec8p-5L,
    -0x1.5512320baedaf4b6p-3L, -0x1.59af0fa283baf07ep-5L, 0x1.3b4a70de31e05942p-7L,
    0x1.d9398be3bad13136p-8L, 0x1.291b73ee05bcbba2p-10L
];

immutable real[7] logGammaStirlingCoeffs = [
    0x1.5555555555553f98p-4L, -0x1.6c16c16c07509b1p-9L, 0x1.a01a012461cbf1e4p-11L,
    -0x1.3813089d3f9d164p-11L, 0x1.b911a92555a277b8p-11L, -0x1.ed0a7b4206087b22p-10L,
    0x1.402523859811b308p-8L
];

immutable real[7] logGammaNumerator = [
    -0x1.0edd25913aaa40a2p+23L, -0x1.31c6ce2e58842d1ep+24L, -0x1.f015814039477c3p+23L,
    -0x1.74ffe40c4b184b34p+22L, -0x1.0d9c6d08f9eab55p+20L,  -0x1.54c6b71935f1fc88p+16L,
    -0x1.0e761b42932b2aaep+11L
];

immutable real[8] logGammaDenominator = [
    -0x1.4055572d75d08c56p+24L, -0x1.deeb6013998e4d76p+24L, -0x1.106f7cded5dcc79ep+24L,
    -0x1.25e17184848c66d2p+22L, -0x1.301303b99a614a0ap+19L, -0x1.09e76ab41ae965p+15L,
    -0x1.00f95ced9e5f54eep+9L, 1.0L
];

/*
 * Helper function: Gamma function computed by Stirling's formula.
 *
 * Stirling's formula for the gamma function is:
 *
 * $(GAMMA)(x) = sqrt(2 &pi;) x<sup>x-0.5</sup> exp(-x) (1 + 1/x P(1/x))
 *
 */
real gammaStirling(real x)
{
    // CEPHES code Copyright 1994 by Stephen L. Moshier

    static immutable real[9] SmallStirlingCoeffs = [
        0x1.55555555555543aap-4L, 0x1.c71c71c720dd8792p-9L, -0x1.5f7268f0b5907438p-9L,
        -0x1.e13cd410e0477de6p-13L, 0x1.9b0f31643442616ep-11L, 0x1.2527623a3472ae08p-14L,
        -0x1.37f6bc8ef8b374dep-11L,-0x1.8c968886052b872ap-16L, 0x1.76baa9c6d3eeddbcp-11L
    ];

    static immutable real[7] LargeStirlingCoeffs = [ 1.0L,
        8.33333333333333333333E-2L, 3.47222222222222222222E-3L,
        -2.68132716049382716049E-3L, -2.29472093621399176955E-4L,
        7.84039221720066627474E-4L, 6.97281375836585777429E-5L
    ];

    real w = 1.0L/x;
    real y = exp(x);
    if ( x > 1024.0L )
    {
        // For large x, use rational coefficients from the analytical expansion.
        w = poly(w, LargeStirlingCoeffs);
        // Avoid overflow in pow()
        real v = pow( x, 0.5L * x - 0.25L );
        y = v * (v / y);
    }
    else
    {
        w = 1.0L + w * poly( w, SmallStirlingCoeffs);
        static if (floatTraits!(real).realFormat == RealFormat.ieeeDouble)
        {
            // Avoid overflow in pow() for 64-bit reals
            if (x > 143.0)
            {
                real v = pow( x, 0.5 * x - 0.25 );
                y = v * (v / y);
            }
            else
            {
                y = pow( x, x - 0.5 ) / y;
            }
        }
        else
        {
            y = pow( x, x - 0.5L ) / y;
        }
    }
    y = SQRT2PI * y * w;
    return  y;
}

/*
 * Helper function: Incomplete gamma function computed by Temme's expansion.
 *
 * This is a port of igamma_temme_large from Boost.
 *
 */
real igammaTemmeLarge(real a, real x)
{
    static immutable real[][13] coef = [
        [ -0.333333333333333333333L, 0.0833333333333333333333L,
          -0.0148148148148148148148L, 0.00115740740740740740741L,
          0.000352733686067019400353L, -0.0001787551440329218107L,
          0.39192631785224377817e-4L, -0.218544851067999216147e-5L,
          -0.18540622107151599607e-5L, 0.829671134095308600502e-6L,
          -0.176659527368260793044e-6L, 0.670785354340149858037e-8L,
          0.102618097842403080426e-7L, -0.438203601845335318655e-8L,
          0.914769958223679023418e-9L, -0.255141939949462497669e-10L,
          -0.583077213255042506746e-10L, 0.243619480206674162437e-10L,
          -0.502766928011417558909e-11L ],
        [ -0.00185185185185185185185L, -0.00347222222222222222222L,
          0.00264550264550264550265L, -0.000990226337448559670782L,
          0.000205761316872427983539L, -0.40187757201646090535e-6L,
          -0.18098550334489977837e-4L, 0.764916091608111008464e-5L,
          -0.161209008945634460038e-5L, 0.464712780280743434226e-8L,
          0.137863344691572095931e-6L, -0.575254560351770496402e-7L,
          0.119516285997781473243e-7L, -0.175432417197476476238e-10L,
          -0.100915437106004126275e-8L, 0.416279299184258263623e-9L,
          -0.856390702649298063807e-10L ],
        [ 0.00413359788359788359788L, -0.00268132716049382716049L,
          0.000771604938271604938272L, 0.200938786008230452675e-5L,
          -0.000107366532263651605215L, 0.529234488291201254164e-4L,
          -0.127606351886187277134e-4L, 0.342357873409613807419e-7L,
          0.137219573090629332056e-5L, -0.629899213838005502291e-6L,
          0.142806142060642417916e-6L, -0.204770984219908660149e-9L,
          -0.140925299108675210533e-7L, 0.622897408492202203356e-8L,
          -0.136704883966171134993e-8L ],
        [ 0.000649434156378600823045L, 0.000229472093621399176955L,
          -0.000469189494395255712128L, 0.000267720632062838852962L,
          -0.756180167188397641073e-4L, -0.239650511386729665193e-6L,
          0.110826541153473023615e-4L, -0.56749528269915965675e-5L,
          0.142309007324358839146e-5L, -0.278610802915281422406e-10L,
          -0.169584040919302772899e-6L, 0.809946490538808236335e-7L,
          -0.191111684859736540607e-7L ],
        [ -0.000861888290916711698605L, 0.000784039221720066627474L,
          -0.000299072480303190179733L, -0.146384525788434181781e-5L,
          0.664149821546512218666e-4L, -0.396836504717943466443e-4L,
          0.113757269706784190981e-4L, 0.250749722623753280165e-9L,
          -0.169541495365583060147e-5L, 0.890750753220530968883e-6L,
          -0.229293483400080487057e-6L ],
        [ -0.000336798553366358150309L, -0.697281375836585777429e-4L,
          0.000277275324495939207873L, -0.000199325705161888477003L,
          0.679778047793720783882e-4L, 0.141906292064396701483e-6L,
          -0.135940481897686932785e-4L, 0.801847025633420153972e-5L,
          -0.229148117650809517038e-5L ],
        [ 0.000531307936463992223166L, -0.000592166437353693882865L,
          0.000270878209671804482771L, 0.790235323266032787212e-6L,
          -0.815396936756196875093e-4L, 0.561168275310624965004e-4L,
          -0.183291165828433755673e-4L, -0.307961345060330478256e-8L,
          0.346515536880360908674e-5L, -0.20291327396058603727e-5L,
          0.57887928631490037089e-6L ],
        [ 0.000344367606892377671254L, 0.517179090826059219337e-4L,
          -0.000334931610811422363117L, 0.000281269515476323702274L,
          -0.000109765822446847310235L, -0.127410090954844853795e-6L,
          0.277444515115636441571e-4L, -0.182634888057113326614e-4L,
          0.578769494973505239894e-5L ],
        [ -0.000652623918595309418922L, 0.000839498720672087279993L,
          -0.000438297098541721005061L, -0.696909145842055197137e-6L,
          0.000166448466420675478374L, -0.000127835176797692185853L,
          0.462995326369130429061e-4L ],
        [ -0.000596761290192746250124L, -0.720489541602001055909e-4L,
          0.000678230883766732836162L, -0.0006401475260262758451L,
          0.000277501076343287044992L ],
        [ 0.00133244544948006563713L, -0.0019144384985654775265L,
          0.00110893691345966373396L ],
        [ 0.00157972766073083495909L, 0.000162516262783915816899L,
          -0.00206334210355432762645L, 0.00213896861856890981541L,
          -0.00101085593912630031708L ],
        [ -0.00407251211951401664727L, 0.00640336283380806979482L,
          -0.00404101610816766177474L ]
    ];

    // avoid nans when one of the arguments is inf:
    if (x == real.infinity && a != real.infinity)
        return 0;

    if (x != real.infinity && a == real.infinity)
        return 1;

    real sigma = (x - a) / a;
    real phi = sigma - log(sigma + 1);

    real y = a * phi;
    real z = sqrt(2 * phi);
    if (x < a)
        z = -z;

    real[13] workspace;
    foreach (i; 0 .. coef.length)
        workspace[i] = poly(z, coef[i]);

    real result = poly(1 / a, workspace);
    result *= exp(-y) / sqrt(2 * PI * a);
    if (x < a)
        result = -result;

    result += erfc(sqrt(y)) / 2;

    return result;
}

} // private

public:
/// The maximum value of x for which gamma(x) < real.infinity.
static if (floatTraits!(real).realFormat == RealFormat.ieeeQuadruple)
    enum real MAXGAMMA = 1755.5483429L;
else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended)
    enum real MAXGAMMA = 1755.5483429L;
else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended53)
    enum real MAXGAMMA = 1755.5483429L;
else static if (floatTraits!(real).realFormat == RealFormat.ieeeDouble)
    enum real MAXGAMMA = 171.6243769L;
else
    static assert(0, "missing MAXGAMMA for other real types");


/*****************************************************
 *  The Gamma function, $(GAMMA)(x)
 *
 *  $(GAMMA)(x) is a generalisation of the factorial function
 *  to real and complex numbers.
 *  Like x!, $(GAMMA)(x+1) = x*$(GAMMA)(x).
 *
 *  Mathematically, if z.re > 0 then
 *   $(GAMMA)(z) = $(INTEGRATE 0, &infin;) $(POWER t, z-1)$(POWER e, -t) dt
 *
 *  $(TABLE_SV
 *    $(SVH  x,          $(GAMMA)(x) )
 *    $(SV  $(NAN),      $(NAN)      )
 *    $(SV  &plusmn;0.0, &plusmn;&infin;)
 *    $(SV integer > 0,  (x-1)!      )
 *    $(SV integer < 0,  $(NAN)      )
 *    $(SV +&infin;,     +&infin;    )
 *    $(SV -&infin;,     $(NAN)      )
 *  )
 */
real gamma(real x)
{
/* Based on code from the CEPHES library.
 * CEPHES code Copyright 1994 by Stephen L. Moshier
 *
 * Arguments |x| <= 13 are reduced by recurrence and the function
 * approximated by a rational function of degree 7/8 in the
 * interval (2,3).  Large arguments are handled by Stirling's
 * formula. Large negative arguments are made positive using
 * a reflection formula.
 */

    real q, z;
    if (isNaN(x)) return x;
    if (x == -x.infinity) return real.nan;
    if ( fabs(x) > MAXGAMMA ) return real.infinity;
    if (x == 0) return 1.0 / x; // +- infinity depending on sign of x, create an exception.

    q = fabs(x);

    if ( q > 13.0L )
    {
        // Large arguments are handled by Stirling's
        // formula. Large negative arguments are made positive using
        // the reflection formula.

        if ( x < 0.0L )
        {
            if (x < -1/real.epsilon)
            {
                // Large negatives lose all precision
                return real.nan;
            }
            int sgngam = 1; // sign of gamma.
            long intpart = cast(long)(q);
            if (q == intpart)
                  return real.nan; // poles for all integers <0.
            real p = intpart;
            if ( (intpart & 1) == 0 )
                sgngam = -1;
            z = q - p;
            if ( z > 0.5L )
            {
                p += 1.0L;
                z = q - p;
            }
            z = q * sin( PI * z );
            z = fabs(z) * gammaStirling(q);
            if ( z <= PI/real.max ) return sgngam * real.infinity;
            return sgngam * PI/z;
        }
        else
        {
            return gammaStirling(x);
        }
    }

    // Arguments |x| <= 13 are reduced by recurrence and the function
    // approximated by a rational function of degree 7/8 in the
    // interval (2,3).

    z = 1.0L;
    while ( x >= 3.0L )
    {
        x -= 1.0L;
        z *= x;
    }

    while ( x < -0.03125L )
    {
        z /= x;
        x += 1.0L;
    }

    if ( x <= 0.03125L )
    {
        if ( x == 0.0L )
            return real.nan;
        else
        {
            if ( x < 0.0L )
            {
                x = -x;
                return z / (x * poly( x, GammaSmallNegCoeffs ));
            }
            else
            {
                return z / (x * poly( x, GammaSmallCoeffs ));
            }
        }
    }

    while ( x < 2.0L )
    {
        z /= x;
        x += 1.0L;
    }
    if ( x == 2.0L ) return z;

    x -= 2.0L;
    return z * poly( x, GammaNumeratorCoeffs ) / poly( x, GammaDenominatorCoeffs );
}

@safe unittest
{
    // gamma(n) = factorial(n-1) if n is an integer.
    real fact = 1.0L;
    for (int i=1; fact<real.max; ++i)
    {
        // Require exact equality for small factorials
        if (i<14) assert(gamma(i*1.0L) == fact);
        assert(feqrel(gamma(i*1.0L), fact) >= real.mant_dig-15);
        fact *= (i*1.0L);
    }
    assert(gamma(0.0) == real.infinity);
    assert(gamma(-0.0) == -real.infinity);
    assert(isNaN(gamma(-1.0)));
    assert(isNaN(gamma(-15.0)));
    assert(isIdentical(gamma(NaN(0xABC)), NaN(0xABC)));
    assert(gamma(real.infinity) == real.infinity);
    assert(gamma(real.max) == real.infinity);
    assert(isNaN(gamma(-real.infinity)));
    assert(gamma(real.min_normal*real.epsilon) == real.infinity);
    assert(gamma(MAXGAMMA)< real.infinity);
    assert(gamma(MAXGAMMA*2) == real.infinity);

    // Test some high-precision values (50 decimal digits)
    real SQRT_PI = 1.77245385090551602729816748334114518279754945612238L;


    assert(feqrel(gamma(0.5L), SQRT_PI) >= real.mant_dig-1);
    assert(feqrel(gamma(17.25L), 4.224986665692703551570937158682064589938e13L) >= real.mant_dig-4);

    assert(feqrel(gamma(1.0 / 3.0L),  2.67893853470774763365569294097467764412868937795730L) >= real.mant_dig-2);
    assert(feqrel(gamma(0.25L),
        3.62560990822190831193068515586767200299516768288006L) >= real.mant_dig-1);
    assert(feqrel(gamma(1.0 / 5.0L),
        4.59084371199880305320475827592915200343410999829340L) >= real.mant_dig-1);
}

/*****************************************************
 * Natural logarithm of gamma function.
 *
 * Returns the base e (2.718...) logarithm of the absolute
 * value of the gamma function of the argument.
 *
 * For reals, logGamma is equivalent to log(fabs(gamma(x))).
 *
 *  $(TABLE_SV
 *    $(SVH  x,             logGamma(x)   )
 *    $(SV  $(NAN),         $(NAN)      )
 *    $(SV integer <= 0,    +&infin;    )
 *    $(SV &plusmn;&infin;, +&infin;    )
 *  )
 */
real logGamma(real x)
{
    /* Based on code from the CEPHES library.
     * CEPHES code Copyright 1994 by Stephen L. Moshier
     *
     * For arguments greater than 33, the logarithm of the gamma
     * function is approximated by the logarithmic version of
     * Stirling's formula using a polynomial approximation of
     * degree 4. Arguments between -33 and +33 are reduced by
     * recurrence to the interval [2,3] of a rational approximation.
     * The cosecant reflection formula is employed for arguments
     * less than -33.
     */
    real q, w, z, f, nx;

    if (isNaN(x)) return x;
    if (fabs(x) == x.infinity) return x.infinity;

    if ( x < -34.0L )
    {
        q = -x;
        w = logGamma(q);
        real p = floor(q);
        if ( p == q )
            return real.infinity;
        int intpart = cast(int)(p);
        real sgngam = 1;
        if ( (intpart & 1) == 0 )
            sgngam = -1;
        z = q - p;
        if ( z > 0.5L )
        {
            p += 1.0L;
            z = p - q;
        }
        z = q * sin( PI * z );
        if ( z == 0.0L )
            return sgngam * real.infinity;
    /*  z = LOGPI - logl( z ) - w; */
        z = log( PI/z ) - w;
        return z;
    }

    if ( x < 13.0L )
    {
        z = 1.0L;
        nx = floor( x +  0.5L );
        f = x - nx;
        while ( x >= 3.0L )
        {
            nx -= 1.0L;
            x = nx + f;
            z *= x;
        }
        while ( x < 2.0L )
        {
            if ( fabs(x) <= 0.03125L )
            {
                if ( x == 0.0L )
                    return real.infinity;
                if ( x < 0.0L )
                {
                    x = -x;
                    q = z / (x * poly( x, GammaSmallNegCoeffs));
                } else
                    q = z / (x * poly( x, GammaSmallCoeffs));
                return log( fabs(q) );
            }
            z /= nx +  f;
            nx += 1.0L;
            x = nx + f;
        }
        z = fabs(z);
        if ( x == 2.0L )
            return log(z);
        x = (nx - 2.0L) + f;
        real p = x * rationalPoly( x, logGammaNumerator, logGammaDenominator);
        return log(z) + p;
    }

    // const real MAXLGM = 1.04848146839019521116e+4928L;
    //  if ( x > MAXLGM ) return sgngaml * real.infinity;

    const real LOGSQRT2PI  =  0.91893853320467274178L; // log( sqrt( 2*pi ) )

    q = ( x - 0.5L ) * log(x) - x + LOGSQRT2PI;
    if (x > 1.0e10L) return q;
    real p = 1.0L / (x*x);
    q += poly( p, logGammaStirlingCoeffs ) / x;
    return q ;
}

@safe unittest
{
    assert(isIdentical(logGamma(NaN(0xDEF)), NaN(0xDEF)));
    assert(logGamma(real.infinity) == real.infinity);
    assert(logGamma(-1.0) == real.infinity);
    assert(logGamma(0.0) == real.infinity);
    assert(logGamma(-50.0) == real.infinity);
    assert(isIdentical(0.0L, logGamma(1.0L)));
    assert(isIdentical(0.0L, logGamma(2.0L)));
    assert(logGamma(real.min_normal*real.epsilon) == real.infinity);
    assert(logGamma(-real.min_normal*real.epsilon) == real.infinity);

    // x, correct loggamma(x), correct d/dx loggamma(x).
    immutable static real[] testpoints = [
    8.0L,                    8.525146484375L      + 1.48766904143001655310E-5,   2.01564147795560999654E0L,
    8.99993896484375e-1L,    6.6375732421875e-2L  + 5.11505711292524166220E-6L, -7.54938684259372234258E-1,
    7.31597900390625e-1L,    2.2369384765625e-1   + 5.21506341809849792422E-6L, -1.13355566660398608343E0L,
    2.31639862060546875e-1L, 1.3686676025390625L  + 1.12609441752996145670E-5L, -4.56670961813812679012E0,
    1.73162841796875L,      -8.88214111328125e-2L + 3.36207740803753034508E-6L, 2.33339034686200586920E-1L,
    1.23162841796875L,      -9.3902587890625e-2L  + 1.28765089229009648104E-5L, -2.49677345775751390414E-1L,
    7.3786976294838206464e19L,   3.301798506038663053312e21L - 1.656137564136932662487046269677E5L,
                          4.57477139169563904215E1L,
    1.08420217248550443401E-19L, 4.36682586669921875e1L + 1.37082843669932230418E-5L,
                         -9.22337203685477580858E18L,
    1.0L, 0.0L, -5.77215664901532860607E-1L,
    2.0L, 0.0L, 4.22784335098467139393E-1L,
    -0.5L,  1.2655029296875L    + 9.19379714539648894580E-6L, 3.64899739785765205590E-2L,
    -1.5L,  8.6004638671875e-1L + 6.28657731014510932682E-7L, 7.03156640645243187226E-1L,
    -2.5L, -5.6243896484375E-2L + 1.79986700949327405470E-7,  1.10315664064524318723E0L,
    -3.5L,  -1.30902099609375L  + 1.43111007079536392848E-5L, 1.38887092635952890151E0L
    ];
   // TODO: test derivatives as well.
    for (int i=0; i<testpoints.length; i+=3)
    {
        assert( feqrel(logGamma(testpoints[i]), testpoints[i+1]) > real.mant_dig-5);
        if (testpoints[i]<MAXGAMMA)
        {
            assert( feqrel(log(fabs(gamma(testpoints[i]))), testpoints[i+1]) > real.mant_dig-5);
        }
    }
    assert(feqrel(logGamma(-50.2L),log(fabs(gamma(-50.2L)))) > real.mant_dig-2);
    assert(feqrel(logGamma(-0.008L),log(fabs(gamma(-0.008L)))) > real.mant_dig-2);
    assert(feqrel(logGamma(-38.8L),log(fabs(gamma(-38.8L)))) > real.mant_dig-4);
    static if (real.mant_dig >= 64) // incl. 80-bit reals
        assert(feqrel(logGamma(1500.0L),log(gamma(1500.0L))) > real.mant_dig-2);
    else static if (real.mant_dig >= 53) // incl. 64-bit reals
        assert(feqrel(logGamma(150.0L),log(gamma(150.0L))) > real.mant_dig-2);
}


private {
/*
 * These value can be calculated like this:
 * 1) Get exact real.max/min_normal/epsilon from compiler:
 *    writefln!"%a"(real.max/min_normal_epsilon)
 * 2) Convert for Wolfram Alpha
 *    0xf.fffffffffffffffp+16380 ==> (f.fffffffffffffff base 16) * 2^16380
 * 3) Calculate result on wofram alpha:
 *    http://www.wolframalpha.com/input/?i=ln((1.ffffffffffffffffffffffffffff+base+16)+*+2%5E16383)+in+base+2
 * 4) Convert to proper format:
 *    string mantissa = "1.011...";
 *    write(mantissa[0 .. 2]); mantissa = mantissa[2 .. $];
 *    for (size_t i = 0; i < mantissa.length/4; i++)
 *    {
 *        writef!"%x"(to!ubyte(mantissa[0 .. 4], 2)); mantissa = mantissa[4 .. $];
 *    }
 */
static if (floatTraits!(real).realFormat == RealFormat.ieeeQuadruple)
{
    enum real MAXLOG = 0x1.62e42fefa39ef35793c7673007e6p+13L;  // log(real.max)
    enum real MINLOG = -0x1.6546282207802c89d24d65e96274p+13L; // log(real.min_normal*real.epsilon) = log(smallest denormal)
}
else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended)
{
    enum real MAXLOG = 0x1.62e42fefa39ef358p+13L;  // log(real.max)
    enum real MINLOG = -0x1.6436716d5406e6d8p+13L; // log(real.min_normal*real.epsilon) = log(smallest denormal)
}
else static if (floatTraits!(real).realFormat == RealFormat.ieeeExtended53)
{
    enum real MAXLOG = 0x1.62e42fefa39ef358p+13L;  // log(real.max)
    enum real MINLOG = -0x1.6436716d5406e6d8p+13L; // log(real.min_normal*real.epsilon) = log(smallest denormal)
}
else static if (floatTraits!(real).realFormat == RealFormat.ieeeDouble)
{
    enum real MAXLOG = 0x1.62e42fefa39efp+9L;  // log(real.max)
    enum real MINLOG = -0x1.74385446d71c3p+9L; // log(real.min_normal*real.epsilon) = log(smallest denormal)
}
else
    static assert(0, "missing MAXLOG and MINLOG for other real types");

enum real BETA_BIG = 9.223372036854775808e18L;
enum real BETA_BIGINV = 1.084202172485504434007e-19L;
}

/** Incomplete beta integral
 *
 * Returns incomplete beta integral of the arguments, evaluated
 * from zero to x. The regularized incomplete beta function is defined as
 *
 * betaIncomplete(a, b, x) = &Gamma;(a+b)/(&Gamma;(a) &Gamma;(b)) *
 * $(INTEGRATE 0, x) $(POWER t, a-1)$(POWER (1-t),b-1) dt
 *
 * and is the same as the cumulative distribution function.
 *
 * The domain of definition is 0 <= x <= 1.  In this
 * implementation a and b are restricted to positive values.
 * The integral from x to 1 may be obtained by the symmetry
 * relation
 *
 *    betaIncompleteCompl(a, b, x )  =  betaIncomplete( b, a, 1-x )
 *
 * The integral is evaluated by a continued fraction expansion
 * or, when b*x is small, by a power series.
 */
real betaIncomplete(real aa, real bb, real xx )
{
    if ( !(aa>0 && bb>0) )
    {
         if ( isNaN(aa) ) return aa;
         if ( isNaN(bb) ) return bb;
         return real.nan; // domain error
    }
    if (!(xx>0 && xx<1.0))
    {
        if (isNaN(xx)) return xx;
        if ( xx == 0.0L ) return 0.0;
        if ( xx == 1.0L )  return 1.0;
        return real.nan; // domain error
    }
    if ( (bb * xx) <= 1.0L && xx <= 0.95L)
    {
        return betaDistPowerSeries(aa, bb, xx);
    }
    real x;
    real xc; // = 1 - x

    real a, b;
    int flag = 0;

    /* Reverse a and b if x is greater than the mean. */
    if ( xx > (aa/(aa+bb)) )
    {
        // here x > aa/(aa+bb) and (bb*x>1 or x>0.95)
        flag = 1;
        a = bb;
        b = aa;
        xc = xx;
        x = 1.0L - xx;
    }
    else
    {
        a = aa;
        b = bb;
        xc = 1.0L - xx;
        x = xx;
    }

    if ( flag == 1 && (b * x) <= 1.0L && x <= 0.95L)
    {
        // here xx > aa/(aa+bb) and  ((bb*xx>1) or xx>0.95) and (aa*(1-xx)<=1) and xx > 0.05
        return 1.0 - betaDistPowerSeries(a, b, x); // note loss of precision
    }

    real w;
    // Choose expansion for optimal convergence
    // One is for x * (a+b+2) < (a+1),
    // the other is for x * (a+b+2) > (a+1).
    real y = x * (a+b-2.0L) - (a-1.0L);
    if ( y < 0.0L )
    {
        w = betaDistExpansion1( a, b, x );
    }
    else
    {
        w = betaDistExpansion2( a, b, x ) / xc;
    }

    /* Multiply w by the factor
         a      b
        x  (1-x)   Gamma(a+b) / ( a Gamma(a) Gamma(b) ) .   */

    y = a * log(x);
    real t = b * log(xc);
    if ( (a+b) < MAXGAMMA && fabs(y) < MAXLOG && fabs(t) < MAXLOG )
    {
        t = pow(xc,b);
        t *= pow(x,a);
        t /= a;
        t *= w;
        t *= gamma(a+b) / (gamma(a) * gamma(b));
    }
    else
    {
        /* Resort to logarithms.  */
        y += t + logGamma(a+b) - logGamma(a) - logGamma(b);
        y += log(w/a);

        t = exp(y);
/+
        // There seems to be a bug in Cephes at this point.
        // Problems occur for y > MAXLOG, not y < MINLOG.
        if ( y < MINLOG )
        {
            t = 0.0L;
        }
        else
        {
            t = exp(y);
        }
+/
    }
    if ( flag == 1 )
    {
/+   // CEPHES includes this code, but I think it is erroneous.
        if ( t <= real.epsilon )
        {
            t = 1.0L - real.epsilon;
        } else
+/
        t = 1.0L - t;
    }
    return t;
}

/** Inverse of incomplete beta integral
 *
 * Given y, the function finds x such that
 *
 *  betaIncomplete(a, b, x) == y
 *
 *  Newton iterations or interval halving is used.
 */
real betaIncompleteInv(real aa, real bb, real yy0 )
{
    real a, b, y0, d, y, x, x0, x1, lgm, yp, di, dithresh, yl, yh, xt;
    int i, rflg, dir, nflg;

    if (isNaN(yy0)) return yy0;
    if (isNaN(aa)) return aa;
    if (isNaN(bb)) return bb;
    if ( yy0 <= 0.0L )
        return 0.0L;
    if ( yy0 >= 1.0L )
        return 1.0L;
    x0 = 0.0L;
    yl = 0.0L;
    x1 = 1.0L;
    yh = 1.0L;
    if ( aa <= 1.0L || bb <= 1.0L )
    {
        dithresh = 1.0e-7L;
        rflg = 0;
        a = aa;
        b = bb;
        y0 = yy0;
        x = a/(a+b);
        y = betaIncomplete( a, b, x );
        nflg = 0;
        goto ihalve;
    }
    else
    {
        nflg = 0;
        dithresh = 1.0e-4L;
    }

    // approximation to inverse function

    yp = -normalDistributionInvImpl( yy0 );

    if ( yy0 > 0.5L )
    {
        rflg = 1;
        a = bb;
        b = aa;
        y0 = 1.0L - yy0;
        yp = -yp;
    }
    else
    {
        rflg = 0;
        a = aa;
        b = bb;
        y0 = yy0;
    }

    lgm = (yp * yp - 3.0L)/6.0L;
    x = 2.0L/( 1.0L/(2.0L * a-1.0L)  +  1.0L/(2.0L * b - 1.0L) );
    d = yp * sqrt( x + lgm ) / x
        - ( 1.0L/(2.0L * b - 1.0L) - 1.0L/(2.0L * a - 1.0L) )
        * (lgm + (5.0L/6.0L) - 2.0L/(3.0L * x));
    d = 2.0L * d;
    if ( d < MINLOG )
    {
        x = 1.0L;
        goto under;
    }
    x = a/( a + b * exp(d) );
    y = betaIncomplete( a, b, x );
    yp = (y - y0)/y0;
    if ( fabs(yp) < 0.2 )
        goto newt;

    /* Resort to interval halving if not close enough. */
ihalve:

    dir = 0;
    di = 0.5L;
    for ( i=0; i<400; i++ )
    {
        if ( i != 0 )
        {
            x = x0  +  di * (x1 - x0);
            if ( x == 1.0L )
            {
                x = 1.0L - real.epsilon;
            }
            if ( x == 0.0L )
            {
                di = 0.5;
                x = x0  +  di * (x1 - x0);
                if ( x == 0.0 )
                    goto under;
            }
            y = betaIncomplete( a, b, x );
            yp = (x1 - x0)/(x1 + x0);
            if ( fabs(yp) < dithresh )
                goto newt;
            yp = (y-y0)/y0;
            if ( fabs(yp) < dithresh )
                goto newt;
        }
        if ( y < y0 )
        {
            x0 = x;
            yl = y;
            if ( dir < 0 )
            {
                dir = 0;
                di = 0.5L;
            } else if ( dir > 3 )
                di = 1.0L - (1.0L - di) * (1.0L - di);
            else if ( dir > 1 )
                di = 0.5L * di + 0.5L;
            else
                di = (y0 - y)/(yh - yl);
            dir += 1;
            if ( x0 > 0.95L )
            {
                if ( rflg == 1 )
                {
                    rflg = 0;
                    a = aa;
                    b = bb;
                    y0 = yy0;
                }
                else
                {
                    rflg = 1;
                    a = bb;
                    b = aa;
                    y0 = 1.0 - yy0;
                }
                x = 1.0L - x;
                y = betaIncomplete( a, b, x );
                x0 = 0.0;
                yl = 0.0;
                x1 = 1.0;
                yh = 1.0;
                goto ihalve;
            }
        }
        else
        {
            x1 = x;
            if ( rflg == 1 && x1 < real.epsilon )
            {
                x = 0.0L;
                goto done;
            }
            yh = y;
            if ( dir > 0 )
            {
                dir = 0;
                di = 0.5L;
            }
            else if ( dir < -3 )
                di = di * di;
            else if ( dir < -1 )
                di = 0.5L * di;
            else
                di = (y - y0)/(yh - yl);
            dir -= 1;
            }
        }
    if ( x0 >= 1.0L )
    {
        // partial loss of precision
        x = 1.0L - real.epsilon;
        goto done;
    }
    if ( x <= 0.0L )
    {
under:
        // underflow has occurred
        x = real.min_normal * real.min_normal;
        goto done;
    }

newt:

    if ( nflg )
    {
        goto done;
    }
    nflg = 1;
    lgm = logGamma(a+b) - logGamma(a) - logGamma(b);

    for ( i=0; i<15; i++ )
    {
        /* Compute the function at this point. */
        if ( i != 0 )
            y = betaIncomplete(a,b,x);
        if ( y < yl )
        {
            x = x0;
            y = yl;
        }
        else if ( y > yh )
        {
            x = x1;
            y = yh;
        }
        else if ( y < y0 )
        {
            x0 = x;
            yl = y;
        }
        else
        {
            x1 = x;
            yh = y;
        }
        if ( x == 1.0L || x == 0.0L )
            break;
        /* Compute the derivative of the function at this point. */
        d = (a - 1.0L) * log(x) + (b - 1.0L) * log(1.0L - x) + lgm;
        if ( d < MINLOG )
        {
            goto done;
        }
        if ( d > MAXLOG )
        {
            break;
        }
        d = exp(d);
        /* Compute the step to the next approximation of x. */
        d = (y - y0)/d;
        xt = x - d;
        if ( xt <= x0 )
        {
            y = (x - x0) / (x1 - x0);
            xt = x0 + 0.5L * y * (x - x0);
            if ( xt <= 0.0L )
                break;
        }
        if ( xt >= x1 )
        {
            y = (x1 - x) / (x1 - x0);
            xt = x1 - 0.5L * y * (x1 - x);
            if ( xt >= 1.0L )
                break;
        }
        x = xt;
        if ( fabs(d/x) < (128.0L * real.epsilon) )
            goto done;
    }
    /* Did not converge.  */
    dithresh = 256.0L * real.epsilon;
    goto ihalve;

done:
    if ( rflg )
    {
        if ( x <= real.epsilon )
            x = 1.0L - real.epsilon;
        else
            x = 1.0L - x;
    }
    return x;
}

@safe unittest { // also tested by the normal distribution
    // check NaN propagation
    assert(isIdentical(betaIncomplete(NaN(0xABC),2,3), NaN(0xABC)));
    assert(isIdentical(betaIncomplete(7,NaN(0xABC),3), NaN(0xABC)));
    assert(isIdentical(betaIncomplete(7,15,NaN(0xABC)), NaN(0xABC)));
    assert(isIdentical(betaIncompleteInv(NaN(0xABC),1,17), NaN(0xABC)));
    assert(isIdentical(betaIncompleteInv(2,NaN(0xABC),8), NaN(0xABC)));
    assert(isIdentical(betaIncompleteInv(2,3, NaN(0xABC)), NaN(0xABC)));

    assert(isNaN(betaIncomplete(-1, 2, 3)));

    assert(betaIncomplete(1, 2, 0)==0);
    assert(betaIncomplete(1, 2, 1)==1);
    assert(isNaN(betaIncomplete(1, 2, 3)));
    assert(betaIncompleteInv(1, 1, 0)==0);
    assert(betaIncompleteInv(1, 1, 1)==1);

    // Test against Mathematica   betaRegularized[z,a,b]
    // These arbitrary points are chosen to give good code coverage.
    assert(feqrel(betaIncomplete(8, 10, 0.2L), 0.010_934_315_234_099_2L) >=  real.mant_dig - 5);
    assert(feqrel(betaIncomplete(2, 2.5L, 0.9L), 0.989_722_597_604_452_767_171_003_59L) >= real.mant_dig - 1);
    static if (real.mant_dig >= 64) // incl. 80-bit reals
        assert(feqrel(betaIncomplete(1000, 800, 0.5L), 1.179140859734704555102808541457164E-06L) >= real.mant_dig - 13);
    else
        assert(feqrel(betaIncomplete(1000, 800, 0.5L), 1.179140859734704555102808541457164E-06L) >= real.mant_dig - 14);
    assert(feqrel(betaIncomplete(0.0001, 10000, 0.0001L), 0.999978059362107134278786L) >= real.mant_dig - 18);
    assert(betaIncomplete(0.01L, 327726.7L, 0.545113L) == 1.0);
    assert(feqrel(betaIncompleteInv(8, 10, 0.010_934_315_234_099_2L), 0.2L) >= real.mant_dig - 2);
    assert(feqrel(betaIncomplete(0.01L, 498.437L, 0.0121433L), 0.99999664562033077636065L) >= real.mant_dig - 1);
    assert(feqrel(betaIncompleteInv(5, 10, 0.2000002972865658842L), 0.229121208190918L) >= real.mant_dig - 3);
    assert(feqrel(betaIncompleteInv(4, 7, 0.8000002209179505L), 0.483657360076904L) >= real.mant_dig - 3);

    // Coverage tests. I don't have correct values for these tests, but
    // these values cover most of the code, so they are useful for
    // regression testing.
    // Extensive testing failed to increase the coverage. It seems likely that about
    // half the code in this function is unnecessary; there is potential for
    // significant improvement over the original CEPHES code.
    static if (real.mant_dig == 64) // 80-bit reals
    {
        assert(betaIncompleteInv(0.01L, 8e-48L, 5.45464e-20L) == 1-real.epsilon);
        assert(betaIncompleteInv(0.01L, 8e-48L, 9e-26L) == 1-real.epsilon);

        // Beware: a one-bit change in pow() changes almost all digits in the result!
        assert(feqrel(
            betaIncompleteInv(0x1.b3d151fbba0eb18p+1L, 1.2265e-19L, 2.44859e-18L),
            0x1.c0110c8531d0952cp-1L
        ) > 10);
        // This next case uncovered a one-bit difference in the FYL2X instruction
        // between Intel and AMD processors. This difference gets magnified by 2^^38.
        // WolframAlpha crashes attempting to calculate this.
        assert(feqrel(betaIncompleteInv(0x1.ff1275ae5b939bcap-41L, 4.6713e18L, 0.0813601L),
            0x1.f97749d90c7adba8p-63L) >= real.mant_dig - 39);
        real a1 = 3.40483L;
        assert(betaIncompleteInv(a1, 4.0640301659679627772e19L, 0.545113L) == 0x1.ba8c08108aaf5d14p-109L);
        real b1 = 2.82847e-25L;
        assert(feqrel(betaIncompleteInv(0.01L, b1, 9e-26L), 0x1.549696104490aa9p-830L) >= real.mant_dig-10);

        // --- Problematic cases ---
        // This is a situation where the series expansion fails to converge
        assert( isNaN(betaIncompleteInv(0.12167L, 4.0640301659679627772e19L, 0.0813601L)));
        // This next result is almost certainly erroneous.
        // Mathematica states: "(cannot be determined by current methods)"
        assert(betaIncomplete(1.16251e20L, 2.18e39L, 5.45e-20L) == -real.infinity);
        // WolframAlpha gives no result for this, though indicates that it approximately 1.0 - 1.3e-9
        assert(1 - betaIncomplete(0.01L, 328222, 4.0375e-5L) == 0x1.5f62926b4p-30L);
    }
}


private {
// Implementation functions

// Continued fraction expansion #1 for incomplete beta integral
// Use when x < (a+1)/(a+b+2)
real betaDistExpansion1(real a, real b, real x )
{
    real xk, pk, pkm1, pkm2, qk, qkm1, qkm2;
    real k1, k2, k3, k4, k5, k6, k7, k8;
    real r, t, ans;
    int n;

    k1 = a;
    k2 = a + b;
    k3 = a;
    k4 = a + 1.0L;
    k5 = 1.0L;
    k6 = b - 1.0L;
    k7 = k4;
    k8 = a + 2.0L;

    pkm2 = 0.0L;
    qkm2 = 1.0L;
    pkm1 = 1.0L;
    qkm1 = 1.0L;
    ans = 1.0L;
    r = 1.0L;
    n = 0;
    const real thresh = 3.0L * real.epsilon;
    do
    {
        xk = -( x * k1 * k2 )/( k3 * k4 );
        pk = pkm1 +  pkm2 * xk;
        qk = qkm1 +  qkm2 * xk;
        pkm2 = pkm1;
        pkm1 = pk;
        qkm2 = qkm1;
        qkm1 = qk;

        xk = ( x * k5 * k6 )/( k7 * k8 );
        pk = pkm1 +  pkm2 * xk;
        qk = qkm1 +  qkm2 * xk;
        pkm2 = pkm1;
        pkm1 = pk;
        qkm2 = qkm1;
        qkm1 = qk;

        if ( qk != 0.0L )
            r = pk/qk;
        if ( r != 0.0L )
        {
            t = fabs( (ans - r)/r );
            ans = r;
        }
        else
        {
           t = 1.0L;
        }

        if ( t < thresh )
            return ans;

        k1 += 1.0L;
        k2 += 1.0L;
        k3 += 2.0L;
        k4 += 2.0L;
        k5 += 1.0L;
        k6 -= 1.0L;
        k7 += 2.0L;
        k8 += 2.0L;

        if ( (fabs(qk) + fabs(pk)) > BETA_BIG )
        {
            pkm2 *= BETA_BIGINV;
            pkm1 *= BETA_BIGINV;
            qkm2 *= BETA_BIGINV;
            qkm1 *= BETA_BIGINV;
            }
        if ( (fabs(qk) < BETA_BIGINV) || (fabs(pk) < BETA_BIGINV) )
        {
            pkm2 *= BETA_BIG;
            pkm1 *= BETA_BIG;
            qkm2 *= BETA_BIG;
            qkm1 *= BETA_BIG;
            }
        }
    while ( ++n < 400 );
// loss of precision has occurred
// mtherr( "incbetl", PLOSS );
    return ans;
}

// Continued fraction expansion #2 for incomplete beta integral
// Use when x > (a+1)/(a+b+2)
real betaDistExpansion2(real a, real b, real x )
{
    real  xk, pk, pkm1, pkm2, qk, qkm1, qkm2;
    real k1, k2, k3, k4, k5, k6, k7, k8;
    real r, t, ans, z;

    k1 = a;
    k2 = b - 1.0L;
    k3 = a;
    k4 = a + 1.0L;
    k5 = 1.0L;
    k6 = a + b;
    k7 = a + 1.0L;
    k8 = a + 2.0L;

    pkm2 = 0.0L;
    qkm2 = 1.0L;
    pkm1 = 1.0L;
    qkm1 = 1.0L;
    z = x / (1.0L-x);
    ans = 1.0L;
    r = 1.0L;
    int n = 0;
    const real thresh = 3.0L * real.epsilon;
    do
    {
        xk = -( z * k1 * k2 )/( k3 * k4 );
        pk = pkm1 +  pkm2 * xk;
        qk = qkm1 +  qkm2 * xk;
        pkm2 = pkm1;
        pkm1 = pk;
        qkm2 = qkm1;
        qkm1 = qk;

        xk = ( z * k5 * k6 )/( k7 * k8 );
        pk = pkm1 +  pkm2 * xk;
        qk = qkm1 +  qkm2 * xk;
        pkm2 = pkm1;
        pkm1 = pk;
        qkm2 = qkm1;
        qkm1 = qk;

        if ( qk != 0.0L )
            r = pk/qk;
        if ( r != 0.0L )
        {
            t = fabs( (ans - r)/r );
            ans = r;
        } else
            t = 1.0L;

        if ( t < thresh )
            return ans;
        k1 += 1.0L;
        k2 -= 1.0L;
        k3 += 2.0L;
        k4 += 2.0L;
        k5 += 1.0L;
        k6 += 1.0L;
        k7 += 2.0L;
        k8 += 2.0L;

        if ( (fabs(qk) + fabs(pk)) > BETA_BIG )
        {
            pkm2 *= BETA_BIGINV;
            pkm1 *= BETA_BIGINV;
            qkm2 *= BETA_BIGINV;
            qkm1 *= BETA_BIGINV;
        }
        if ( (fabs(qk) < BETA_BIGINV) || (fabs(pk) < BETA_BIGINV) )
        {
            pkm2 *= BETA_BIG;
            pkm1 *= BETA_BIG;
            qkm2 *= BETA_BIG;
            qkm1 *= BETA_BIG;
        }
    } while ( ++n < 400 );
// loss of precision has occurred
//mtherr( "incbetl", PLOSS );
    return ans;
}

/* Power series for incomplete gamma integral.
   Use when b*x is small.  */
real betaDistPowerSeries(real a, real b, real x )
{
    real ai = 1.0L / a;
    real u = (1.0L - b) * x;
    real v = u / (a + 1.0L);
    real t1 = v;
    real t = u;
    real n = 2.0L;
    real s = 0.0L;
    real z = real.epsilon * ai;
    while ( fabs(v) > z )
    {
        u = (n - b) * x / n;
        t *= u;
        v = t / (a + n);
        s += v;
        n += 1.0L;
    }
    s += t1;
    s += ai;

    u = a * log(x);
    if ( (a+b) < MAXGAMMA && fabs(u) < MAXLOG )
    {
        t = gamma(a+b)/(gamma(a)*gamma(b));
        s = s * t * pow(x,a);
    }
    else
    {
        t = logGamma(a+b) - logGamma(a) - logGamma(b) + u + log(s);

        if ( t < MINLOG )
        {
            s = 0.0L;
        } else
            s = exp(t);
    }
    return s;
}

}

/***************************************
 *  Incomplete gamma integral and its complement
 *
 * These functions are defined by
 *
 *   gammaIncomplete = ( $(INTEGRATE 0, x) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)
 *
 *  gammaIncompleteCompl(a,x)   =   1 - gammaIncomplete(a,x)
 * = ($(INTEGRATE x, &infin;) $(POWER e, -t) $(POWER t, a-1) dt )/ $(GAMMA)(a)
 *
 * In this implementation both arguments must be positive.
 * The integral is evaluated by either a power series or
 * continued fraction expansion, depending on the relative
 * values of a and x.
 */
real gammaIncomplete(real a, real x )
in
{
   assert(x >= 0);
   assert(a > 0);
}
do
{
    /* left tail of incomplete gamma function:
     *
     *          inf.      k
     *   a  -x   -       x
     *  x  e     >   ----------
     *           -     -
     *          k=0   | (a+k+1)
     *
     */
    if (x == 0)
       return 0.0L;

    if ( (x > 1.0L) && (x > a ) )
        return 1.0L - gammaIncompleteCompl(a,x);

    real ax = a * log(x) - x - logGamma(a);
/+
    if ( ax < MINLOGL ) return 0; // underflow
    //  { mtherr( "igaml", UNDERFLOW ); return( 0.0L ); }
+/
    ax = exp(ax);

    /* power series */
    real r = a;
    real c = 1.0L;
    real ans = 1.0L;

    do
    {
        r += 1.0L;
        c *= x/r;
        ans += c;
    } while ( c/ans > real.epsilon );

    return ans * ax/a;
}

/** ditto */
real gammaIncompleteCompl(real a, real x )
in
{
   assert(x >= 0);
   assert(a > 0);
}
do
{
    if (x == 0)
        return 1.0L;
    if ( (x < 1.0L) || (x < a) )
        return 1.0L - gammaIncomplete(a,x);

    // DAC (Cephes bug fix): This is necessary to avoid
    // spurious nans, eg
    // log(x)-x = NaN when x = real.infinity
    const real MAXLOGL =  1.1356523406294143949492E4L;
    if (x > MAXLOGL)
        return igammaTemmeLarge(a, x);

    real ax = a * log(x) - x - logGamma(a);
//const real MINLOGL = -1.1355137111933024058873E4L;
//  if ( ax < MINLOGL ) return 0; // underflow;
    ax = exp(ax);


    /* continued fraction */
    real y = 1.0L - a;
    real z = x + y + 1.0L;
    real c = 0.0L;

    real pk, qk, t;

    real pkm2 = 1.0L;
    real qkm2 = x;
    real pkm1 = x + 1.0L;
    real qkm1 = z * x;
    real ans = pkm1/qkm1;

    do
    {
        c += 1.0L;
        y += 1.0L;
        z += 2.0L;
        real yc = y * c;
        pk = pkm1 * z  -  pkm2 * yc;
        qk = qkm1 * z  -  qkm2 * yc;
        if ( qk != 0.0L )
        {
            real r = pk/qk;
            t = fabs( (ans - r)/r );
            ans = r;
        }
        else
        {
            t = 1.0L;
        }
    pkm2 = pkm1;
        pkm1 = pk;
        qkm2 = qkm1;
        qkm1 = qk;

        const real BIG = 9.223372036854775808e18L;

        if ( fabs(pk) > BIG )
        {
            pkm2 /= BIG;
            pkm1 /= BIG;
            qkm2 /= BIG;
            qkm1 /= BIG;
        }
    } while ( t > real.epsilon );

    return ans * ax;
}

/** Inverse of complemented incomplete gamma integral
 *
 * Given a and p, the function finds x such that
 *
 *  gammaIncompleteCompl( a, x ) = p.
 *
 * Starting with the approximate value x = a $(POWER t, 3), where
 * t = 1 - d - normalDistributionInv(p) sqrt(d),
 * and d = 1/9a,
 * the routine performs up to 10 Newton iterations to find the
 * root of incompleteGammaCompl(a,x) - p = 0.
 */
real gammaIncompleteComplInv(real a, real p)
in
{
  assert(p >= 0 && p <= 1);
  assert(a>0);
}
do
{
    if (p == 0) return real.infinity;

    real y0 = p;
    const real MAXLOGL =  1.1356523406294143949492E4L;
    real x0, x1, x, yl, yh, y, d, lgm, dithresh;
    int i, dir;

    /* bound the solution */
    x0 = real.max;
    yl = 0.0L;
    x1 = 0.0L;
    yh = 1.0L;
    dithresh = 4.0 * real.epsilon;

    /* approximation to inverse function */
    d = 1.0L/(9.0L*a);
    y = 1.0L - d - normalDistributionInvImpl(y0) * sqrt(d);
    x = a * y * y * y;

    lgm = logGamma(a);

    for ( i=0; i<10; i++ )
    {
        if ( x > x0 || x < x1 )
            goto ihalve;
        y = gammaIncompleteCompl(a,x);
        if ( y < yl || y > yh )
            goto ihalve;
        if ( y < y0 )
        {
            x0 = x;
            yl = y;
        }
        else
        {
            x1 = x;
            yh = y;
        }
    /* compute the derivative of the function at this point */
        d = (a - 1.0L) * log(x0) - x0 - lgm;
        if ( d < -MAXLOGL )
            goto ihalve;
        d = -exp(d);
    /* compute the step to the next approximation of x */
        d = (y - y0)/d;
        x = x - d;
        if ( i < 3 ) continue;
        if ( fabs(d/x) < dithresh ) return x;
    }

    /* Resort to interval halving if Newton iteration did not converge. */
ihalve:
    d = 0.0625L;
    if ( x0 == real.max )
    {
        if ( x <= 0.0L )
            x = 1.0L;
        while ( x0 == real.max )
        {
            x = (1.0L + d) * x;
            y = gammaIncompleteCompl( a, x );
            if ( y < y0 )
            {
                x0 = x;
                yl = y;
                break;
            }
            d = d + d;
        }
    }
    d = 0.5L;
    dir = 0;

    for ( i=0; i<400; i++ )
    {
        x = x1  +  d * (x0 - x1);
        y = gammaIncompleteCompl( a, x );
        lgm = (x0 - x1)/(x1 + x0);
        if ( fabs(lgm) < dithresh )
            break;
        lgm = (y - y0)/y0;
        if ( fabs(lgm) < dithresh )
            break;
        if ( x <= 0.0L )
            break;
        if ( y > y0 )
        {
            x1 = x;
            yh = y;
            if ( dir < 0 )
            {
                dir = 0;
                d = 0.5L;
            } else if ( dir > 1 )
                d = 0.5L * d + 0.5L;
            else
                d = (y0 - yl)/(yh - yl);
            dir += 1;
        }
        else
        {
            x0 = x;
            yl = y;
            if ( dir > 0 )
            {
                dir = 0;
                d = 0.5L;
            } else if ( dir < -1 )
                d = 0.5L * d;
            else
                d = (y0 - yl)/(yh - yl);
            dir -= 1;
        }
    }
    /+
    if ( x == 0.0L )
        mtherr( "igamil", UNDERFLOW );
    +/
    return x;
}

@safe unittest
{
//Values from Excel's GammaInv(1-p, x, 1)
assert(fabs(gammaIncompleteComplInv(1, 0.5L) - 0.693147188044814L) < 0.00000005L);
assert(fabs(gammaIncompleteComplInv(12, 0.99L) - 5.42818075054289L) < 0.00000005L);
assert(fabs(gammaIncompleteComplInv(100, 0.8L) - 91.5013985848288L) < 0.000005L);
assert(gammaIncomplete(1, 0)==0);
assert(gammaIncompleteCompl(1, 0)==1);
assert(gammaIncomplete(4545, real.infinity)==1);

// Values from Excel's (1-GammaDist(x, alpha, 1, TRUE))

assert(fabs(1.0L-gammaIncompleteCompl(0.5L, 2) - 0.954499729507309L) < 0.00000005L);
assert(fabs(gammaIncomplete(0.5L, 2) - 0.954499729507309L) < 0.00000005L);
// Fixed Cephes bug:
assert(gammaIncompleteCompl(384, real.infinity)==0);
assert(gammaIncompleteComplInv(3, 0)==real.infinity);
// Fixed a bug that caused gammaIncompleteCompl to return a wrong value when
// x was larger than a, but not by much, and both were large:
// The value is from WolframAlpha (Gamma[100000, 100001, inf] / Gamma[100000])
static if (real.mant_dig >= 64) // incl. 80-bit reals
    assert(fabs(gammaIncompleteCompl(100000, 100001) - 0.49831792109L) < 0.000000000005L);
else
    assert(fabs(gammaIncompleteCompl(100000, 100001) - 0.49831792109L) < 0.00000005L);
}


// DAC: These values are Bn / n for n=2,4,6,8,10,12,14.
immutable real [7] Bn_n  = [
    1.0L/(6*2), -1.0L/(30*4), 1.0L/(42*6), -1.0L/(30*8),
    5.0L/(66*10), -691.0L/(2730*12), 7.0L/(6*14) ];

/** Digamma function
*
*  The digamma function is the logarithmic derivative of the gamma function.
*
*  digamma(x) = d/dx logGamma(x)
*
* References:
*   1. Abramowitz, M., and Stegun, I. A. (1970).
*      Handbook of mathematical functions. Dover, New York,
*      pages 258-259, equations 6.3.6 and 6.3.18.
*/
real digamma(real x)
{
   // Based on CEPHES, Stephen L. Moshier.

    real p, q, nz, s, w, y, z;
    long i, n;
    int negative;

    negative = 0;
    nz = 0.0;

    if ( x <= 0.0 )
    {
        negative = 1;
        q = x;
        p = floor(q);
        if ( p == q )
        {
            return real.nan; // singularity.
        }
    /* Remove the zeros of tan(PI x)
     * by subtracting the nearest integer from x
     */
        nz = q - p;
        if ( nz != 0.5 )
        {
            if ( nz > 0.5 )
            {
                p += 1.0;
                nz = q - p;
            }
            nz = PI/tan(PI*nz);
        }
        else
        {
            nz = 0.0;
        }
        x = 1.0 - x;
    }

    // check for small positive integer
    if ((x <= 13.0) && (x == floor(x)) )
    {
        y = 0.0;
        n = lrint(x);
        // DAC: CEPHES bugfix. Cephes did this in reverse order, which
        // created a larger roundoff error.
        for (i=n-1; i>0; --i)
        {
            y+=1.0L/i;
        }
        y -= EULERGAMMA;
        goto done;
    }

    s = x;
    w = 0.0;
    while ( s < 10.0 )
    {
        w += 1.0/s;
        s += 1.0;
    }

    if ( s < 1.0e17L )
    {
        z = 1.0/(s * s);
        y = z * poly(z, Bn_n);
    } else
        y = 0.0;

    y = log(s)  -  0.5L/s  -  y  -  w;

done:
    if ( negative )
    {
        y -= nz;
    }
    return y;
}

@safe unittest
{
    // Exact values
    assert(digamma(1.0)== -EULERGAMMA);
    assert(feqrel(digamma(0.25), -PI/2 - 3* LN2 - EULERGAMMA) >= real.mant_dig-7);
    assert(feqrel(digamma(1.0L/6), -PI/2 *sqrt(3.0L) - 2* LN2 -1.5*log(3.0L) - EULERGAMMA) >= real.mant_dig-7);
    assert(digamma(-5.0).isNaN());
    assert(feqrel(digamma(2.5), -EULERGAMMA - 2*LN2 + 2.0 + 2.0L/3) >= real.mant_dig-9);
    assert(isIdentical(digamma(NaN(0xABC)), NaN(0xABC)));

    for (int k=1; k<40; ++k)
    {
        real y=0;
        for (int u=k; u >= 1; --u)
        {
            y += 1.0L/u;
        }
        assert(feqrel(digamma(k+1.0), -EULERGAMMA + y) >= real.mant_dig-2);
    }
}

/** Log Minus Digamma function
*
*  logmdigamma(x) = log(x) - digamma(x)
*
* References:
*   1. Abramowitz, M., and Stegun, I. A. (1970).
*      Handbook of mathematical functions. Dover, New York,
*      pages 258-259, equations 6.3.6 and 6.3.18.
*/
real logmdigamma(real x)
{
    if (x <= 0.0)
    {
        if (x == 0.0)
        {
            return real.infinity;
        }
        return real.nan;
    }

    real s = x;
    real w = 0.0;
    while ( s < 10.0 )
    {
        w += 1.0/s;
        s += 1.0;
    }

    real y;
    if ( s < 1.0e17L )
    {
        immutable real z = 1.0/(s * s);
        y = z * poly(z, Bn_n);
    } else
        y = 0.0;

    return x == s ? y + 0.5L/s : (log(x/s) + 0.5L/s + y + w);
}

@safe unittest
{
    assert(logmdigamma(-5.0).isNaN());
    assert(isIdentical(logmdigamma(NaN(0xABC)), NaN(0xABC)));
    assert(logmdigamma(0.0) == real.infinity);
    for (auto x = 0.01; x < 1.0; x += 0.1)
        assert(isClose(digamma(x), log(x) - logmdigamma(x)));
    for (auto x = 1.0; x < 15.0; x += 1.0)
        assert(isClose(digamma(x), log(x) - logmdigamma(x)));
}

/** Inverse of the Log Minus Digamma function
 *
 *   Returns x such $(D log(x) - digamma(x) == y).
 *
 * References:
 *   1. Abramowitz, M., and Stegun, I. A. (1970).
 *      Handbook of mathematical functions. Dover, New York,
 *      pages 258-259, equation 6.3.18.
 *
 * Authors: Ilya Yaroshenko
 */
real logmdigammaInverse(real y)
{
    import std.numeric : findRoot;
    // FIXME: should be returned back to enum.
    // Fix requires CTFEable `log` on non-x86 targets (check both LDC and GDC).
    immutable maxY = logmdigamma(real.min_normal);
    assert(maxY > 0 && maxY <= real.max);

    if (y >= maxY)
    {
        //lim x->0 (log(x)-digamma(x))*x == 1
        return 1 / y;
    }
    if (y < 0)
    {
        return real.nan;
    }
    if (y < real.min_normal)
    {
        //6.3.18
        return 0.5 / y;
    }
    if (y > 0)
    {
        // x/2 <= logmdigamma(1 / x) <= x, x > 0
        // calls logmdigamma ~6 times
        return 1 / findRoot((real x) => logmdigamma(1 / x) - y, y,  2*y);
    }
    return y; //NaN
}

@safe unittest
{
    import std.typecons;
    //WolframAlpha, 22.02.2015
    immutable Tuple!(real, real)[5] testData = [
        tuple(1.0L, 0.615556766479594378978099158335549201923L),
        tuple(1.0L/8, 4.15937801516894947161054974029150730555L),
        tuple(1.0L/1024, 512.166612384991507850643277924243523243L),
        tuple(0.000500083333325000003968249801594877323784632117L, 1000.0L),
        tuple(1017.644138623741168814449776695062817947092468536L, 1.0L/1024),
    ];
    foreach (test; testData)
        assert(isClose(logmdigammaInverse(test[0]), test[1], 2e-15L));

    assert(isClose(logmdigamma(logmdigammaInverse(1)), 1, 1e-15L));
    assert(isClose(logmdigamma(logmdigammaInverse(real.min_normal)), real.min_normal, 1e-15L));
    assert(isClose(logmdigamma(logmdigammaInverse(real.max/2)), real.max/2, 1e-15L));
    assert(isClose(logmdigammaInverse(logmdigamma(1)), 1, 1e-15L));
    assert(isClose(logmdigammaInverse(logmdigamma(real.min_normal)), real.min_normal, 1e-15L));
    assert(isClose(logmdigammaInverse(logmdigamma(real.max/2)), real.max/2, 1e-15L));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  module std.internal.memory;

package(std):

version (D_Exceptions)
{
    import core.exception : onOutOfMemoryError;
    private enum allocationFailed = `onOutOfMemoryError();`;
}
else
{
    private enum allocationFailed = `assert(0, "Memory allocation failed");`;
}

// (below comments are non-DDOC, but are written in similar style)

/+
Mnemonic for `enforce!OutOfMemoryError(malloc(size))` that (unlike malloc)
can be considered pure because it causes the program to abort if the result
of the allocation is null, with the consequence that errno will not be
visibly changed by calling this function. Note that `malloc` can also
return `null` in non-failure situations if given an argument of 0. Hence,
it is a programmer error to use this function if the requested allocation
size is logically permitted to be zero. `enforceCalloc` and `enforceRealloc`
work analogously.

All these functions are usable in `betterC`.
+/
void* enforceMalloc()(size_t size) @nogc nothrow pure @safe
{
    auto result = fakePureMalloc(size);
    if (!result) mixin(allocationFailed);
    return result;
}

// ditto
void* enforceCalloc()(size_t nmemb, size_t size) @nogc nothrow pure @safe
{
    auto result = fakePureCalloc(nmemb, size);
    if (!result) mixin(allocationFailed);
    return result;
}

// ditto
void* enforceRealloc()(return scope void* ptr, size_t size) @nogc nothrow pure @system
{
    auto result = fakePureRealloc(ptr, size);
    if (!result) mixin(allocationFailed);
    return result;
}

// Purified for local use only.
extern (C) @nogc nothrow pure private
{
    pragma(mangle, "malloc") void* fakePureMalloc(size_t) @safe;
    pragma(mangle, "calloc") void* fakePureCalloc(size_t nmemb, size_t size) @safe;
    pragma(mangle, "realloc") void* fakePureRealloc(return scope void* ptr, size_t size) @system;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          /*
 * Copyright: 2014 by Digital Mars
 * License: $(LINK2 http://boost.org/LICENSE_1_0.txt, Boost License 1.0).
 * Authors: Walter Bright
 * Source: $(PHOBOSSRC std/internal/scopebuffer.d)
 */

module std.internal.scopebuffer;


//debug=ScopeBuffer;

import core.stdc.stdlib : realloc;
import std.traits;
import std.internal.attributes : betterC;

/**************************************
 * ScopeBuffer encapsulates using a local array as a temporary buffer.
 * It is initialized with a local array that should be large enough for
 * most uses. If the need exceeds that size, ScopeBuffer will reallocate
 * the data using its `realloc` function.
 *
 * ScopeBuffer cannot contain more than `(uint.max-16)/2` elements.
 *
 * ScopeBuffer is an Output Range.
 *
 * Since ScopeBuffer may store elements of type `T` in `malloc`'d memory,
 * those elements are not scanned when the GC collects. This can cause
 * memory corruption. Do not use ScopeBuffer when elements of type `T` point
 * to the GC heap, except when a `realloc` function is provided which supports this.
 *
 * Example:
---
import core.stdc.stdio;
import std.internal.scopebuffer;
void main()
{
    char[2] buf = void;
    auto textbuf = ScopeBuffer!char(buf);
    scope(exit) textbuf.free(); // necessary for cleanup

    // Put characters and strings into textbuf, verify they got there
    textbuf.put('a');
    textbuf.put('x');
    textbuf.put("abc");
    assert(textbuf.length == 5);
    assert(textbuf[1 .. 3] == "xa");
    assert(textbuf[3] == 'b');

    // Can shrink it
    textbuf.length = 3;
    assert(textbuf[0 .. textbuf.length] == "axa");
    assert(textbuf[textbuf.length - 1] == 'a');
    assert(textbuf[1 .. 3] == "xa");

    textbuf.put('z');
    assert(textbuf[] == "axaz");

    // Can shrink it to 0 size, and reuse same memory
    textbuf.length = 0;
}
---
 * It is invalid to access ScopeBuffer's contents when ScopeBuffer goes out of scope.
 * Hence, copying the contents are necessary to keep them around:
---
import std.internal.scopebuffer;
string cat(string s1, string s2)
{
    char[10] tmpbuf = void;
    auto textbuf = ScopeBuffer!char(tmpbuf);
    scope(exit) textbuf.free();
    textbuf.put(s1);
    textbuf.put(s2);
    textbuf.put("even more");
    return textbuf[].idup;
}
---
 * ScopeBuffer is intended for high performance usages in `@system` and `@trusted` code.
 * It is designed to fit into two 64 bit registers, again for high performance use.
 * If used incorrectly, memory leaks and corruption can result. Be sure to use
 * $(D scope(exit) textbuf.free();) for proper cleanup, and do not refer to a ScopeBuffer
 * instance's contents after `ScopeBuffer.free()` has been called.
 *
 * The `realloc` parameter defaults to C's `realloc()`. Another can be supplied to override it.
 *
 * ScopeBuffer instances may be copied, as in:
---
textbuf = doSomething(textbuf, args);
---
 * which can be very efficent, but these must be regarded as a move rather than a copy.
 * Additionally, the code between passing and returning the instance must not throw
 * exceptions, otherwise when `ScopeBuffer.free()` is called, memory may get corrupted.
 */

@system
struct ScopeBuffer(T, alias realloc = /*core.stdc.stdlib*/.realloc)
if (isAssignable!T &&
    !hasElaborateDestructor!T &&
    !hasElaborateCopyConstructor!T &&
    !hasElaborateAssign!T)
{
    import core.exception : onOutOfMemoryError;
    import core.stdc.string : memcpy;


    /**************************
     * Initialize with buf to use as scratch buffer space.
     * Params:
     *  buf = Scratch buffer space, must have length that is even
     * Example:
     * ---
     * ubyte[10] tmpbuf = void;
     * auto sbuf = ScopeBuffer!ubyte(tmpbuf);
     * ---
     * Note:
     * If buf was created by the same `realloc` passed as a parameter
     * to `ScopeBuffer`, then the contents of `ScopeBuffer` can be extracted without needing
     * to copy them, and `ScopeBuffer.free()` will not need to be called.
     */
    this(T[] buf)
        in
        {
            assert(!(buf.length & wasResized));    // assure even length of scratch buffer space
            assert(buf.length <= uint.max);     // because we cast to uint later
        }
    do
    {
        this.buf = buf.ptr;
        this.bufLen = cast(uint) buf.length;
    }

    @system @betterC unittest
    {
        ubyte[10] tmpbuf = void;
        auto sbuf = ScopeBuffer!ubyte(tmpbuf);
    }

    /**************************
     * Releases any memory used.
     * This will invalidate any references returned by the `[]` operator.
     * A destructor is not used, because that would make it not POD
     * (Plain Old Data) and it could not be placed in registers.
     */
    void free()
    {
        debug(ScopeBuffer) buf[0 .. bufLen] = 0;
        if (bufLen & wasResized)
            realloc(buf, 0);
        buf = null;
        bufLen = 0;
        used = 0;
    }

    /************************
     * Append element c to the buffer.
     * This member function makes `ScopeBuffer` an Output Range.
     */
    void put(T c)
    {
        /* j will get enregistered, while used will not because resize() may change used
         */
        const j = used;
        if (j == bufLen)
        {
            assert(j <= (uint.max - 16) / 2);
            resize(j * 2 + 16);
        }
        buf[j] = c;
        used = j + 1;
    }

    /************************
     * Append array s to the buffer.
     *
     * If `const(T)` can be converted to `T`, then put will accept
     * `const(T)[]` as input. It will accept a `T[]` otherwise.
     */
    package alias CT = Select!(is(const(T) : T), const(T), T);
    /// ditto
    void put(CT[] s)
    {
        const newlen = used + s.length;
        assert((cast(ulong) used + s.length) <= uint.max);
        const len = bufLen;
        if (newlen > len)
        {
            assert(len <= uint.max / 2);
            resize(newlen <= len * 2 ? len * 2 : newlen);
        }
        buf[used .. newlen] = s[];
        used = cast(uint) newlen;
    }

    /******
     * Returns:
     *  A slice into the temporary buffer.
     * Warning:
     *  The result is only valid until the next `put()` or `ScopeBuffer` goes out of scope.
     */
    @system inout(T)[] opSlice(size_t lower, size_t upper) inout
        in
        {
            assert(lower <= bufLen);
            assert(upper <= bufLen);
            assert(lower <= upper);
        }
    do
    {
        return buf[lower .. upper];
    }

    /// ditto
    @system inout(T)[] opSlice() inout
    {
        assert(used <= bufLen);
        return buf[0 .. used];
    }

    /*******
     * Returns:
     *  The element at index i.
     */
    ref inout(T) opIndex(size_t i) inout
    {
        assert(i < bufLen);
        return buf[i];
    }

    /***
     * Returns:
     *  The number of elements in the `ScopeBuffer`.
     */
    @property size_t length() const
    {
        return used;
    }

    /***
     * Used to shrink the length of the buffer,
     * typically to `0` so the buffer can be reused.
     * Cannot be used to extend the length of the buffer.
     */
    @property void length(size_t i)
        in
        {
            assert(i <= this.used);
        }
    do
    {
        this.used = cast(uint) i;
    }

    alias opDollar = length;

  private:
    T* buf;
    // Using uint instead of size_t so the struct fits in 2 registers in 64 bit code
    uint bufLen;
    enum wasResized = 1;         // this bit is set in bufLen if we control the memory
    uint used;

    void resize(size_t newsize)
        in
        {
            assert(newsize <= uint.max);
        }
    do
    {
        //writefln("%s: oldsize %s newsize %s", id, buf.length, newsize);
        newsize |= wasResized;
        void *newBuf = realloc((bufLen & wasResized) ? buf : null, newsize * T.sizeof);
        if (!newBuf)
            onOutOfMemoryError();
        if (!(bufLen & wasResized))
        {
            memcpy(newBuf, buf, used * T.sizeof);
            debug(ScopeBuffer) buf[0 .. bufLen] = 0;
        }
        buf = cast(T*) newBuf;
        bufLen = cast(uint) newsize;

        /* This function is called only rarely,
         * inlining results in poorer register allocation.
         */
        version (DigitalMars)
            /* With dmd, a fake loop will prevent inlining.
             * Using a hack until a language enhancement is implemented.
             */
            while (1) { break; }
    }
}

@system @betterC unittest
{
    import core.stdc.stdio;
    import std.range;

    char[2] tmpbuf = void;
    {
    // Exercise all the lines of code except for assert(0)'s
    auto textbuf = ScopeBuffer!char(tmpbuf);
    scope(exit) textbuf.free();

    static assert(isOutputRange!(ScopeBuffer!char, char));

    textbuf.put('a');
    textbuf.put('x');
    textbuf.put("abc");         // tickle put([])'s resize
    assert(textbuf.length == 5);
    assert(textbuf[1 .. 3] == "xa");
    assert(textbuf[3] == 'b');

    textbuf.length = textbuf.length - 1;
    assert(textbuf[0 .. textbuf.length] == "axab");

    textbuf.length = 3;
    assert(textbuf[0 .. textbuf.length] == "axa");
    assert(textbuf[textbuf.length - 1] == 'a');
    assert(textbuf[1 .. 3] == "xa");

    textbuf.put(cast(dchar)'z');
    assert(textbuf[] == "axaz");

    textbuf.length = 0;                 // reset for reuse
    assert(textbuf.length == 0);

    foreach (char c; "asdf;lasdlfaklsdjfalksdjfa;lksdjflkajsfdasdfkja;sdlfj")
    {
        textbuf.put(c); // tickle put(c)'s resize
    }
    assert(textbuf[] == "asdf;lasdlfaklsdjfalksdjfa;lksdjflkajsfdasdfkja;sdlfj");
    } // run destructor on textbuf here

}

@system unittest
{
    string cat(string s1, string s2)
    {
        char[10] tmpbuf = void;
        auto textbuf = ScopeBuffer!char(tmpbuf);
        scope(exit) textbuf.free();
        textbuf.put(s1);
        textbuf.put(s2);
        textbuf.put("even more");
        return textbuf[].idup;
    }

    auto s = cat("hello", "betty");
    assert(s == "hellobettyeven more");
}

// const
@system @betterC unittest
{
    char[10] tmpbuf = void;
    auto textbuf = ScopeBuffer!char(tmpbuf);
    scope(exit) textbuf.free();
    foreach (i; 0 .. 10) textbuf.put('w');
    const csb = textbuf;
    const elem = csb[3];
    const slice0 = csb[0 .. 5];
    const slice1 = csb[];
}

/*********************************
 * Creates a `ScopeBuffer` instance using type deduction - see
 * $(LREF .ScopeBuffer.this) for details.
 * Params:
 *      tmpbuf = the initial buffer to use
 * Returns:
 *      An instance of `ScopeBuffer`.
 */

auto scopeBuffer(T)(T[] tmpbuf)
{
    return ScopeBuffer!T(tmpbuf);
}

///
@system @betterC unittest
{
    ubyte[10] tmpbuf = void;
    auto sb = scopeBuffer(tmpbuf);
    scope(exit) sb.free();
}

@system @betterC unittest
{
    ScopeBuffer!(int*) b;
    int*[] s;
    b.put(s);

    ScopeBuffer!char c;
    string s1;
    char[] s2;
    c.put(s1);
    c.put(s2);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               /**
For testing only.
Used with the dummy ranges for testing higher order ranges.
*/
module std.internal.test.dummyrange;

import std.meta;
import std.range.primitives;
import std.typecons;

enum RangeType
{
    Input,
    Forward,
    Bidirectional,
    Random
}

enum Length
{
    Yes,
    No
}

enum ReturnBy
{
    Reference,
    Value
}

import std.traits : isArray;

// Range that's useful for testing other higher order ranges,
// can be parametrized with attributes.  It just dumbs down an array of
// numbers 1 .. 10.
struct DummyRange(ReturnBy _r, Length _l, RangeType _rt, T = uint[])
if (isArray!T)
{
    private static immutable uinttestData =
        [1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 9U, 10U];
    // These enums are so that the template params are visible outside
    // this instantiation.
    enum r = _r;
    enum l = _l;
    enum rt = _rt;

    static if (is(T == uint[]))
    {
        T arr = uinttestData;
    }
    else
    {
        T arr;
    }

    alias RetType = ElementType!(T);
    alias RetTypeNoAutoDecoding = ElementEncodingType!(T);

    void reinit()
    {
        // Workaround for DMD bug 4378
        static if (is(T == uint[]))
        {
            arr = uinttestData.dup;
        }
    }

    void popFront()
    {
        arr = arr[1..$];
    }

    @property bool empty() const
    {
        return arr.length == 0;
    }

    static if (r == ReturnBy.Reference)
    {
        @property ref inout(RetType) front() inout
        {
            return arr[0];
        }
    }
    else
    {
        @property RetType front() const
        {
            return arr[0];
        }

        @property void front(RetTypeNoAutoDecoding val)
        {
            arr[0] = val;
        }
    }

    static if (rt >= RangeType.Forward)
    {
        @property typeof(this) save()
        {
            return this;
        }
    }

    static if (rt >= RangeType.Bidirectional)
    {
        void popBack()
        {
            arr = arr[0..$ - 1];
        }

        static if (r == ReturnBy.Reference)
        {
            @property ref inout(RetType) back() inout
            {
                return arr[$ - 1];
            }
        }
        else
        {
            @property RetType back() const
            {
                return arr[$ - 1];
            }

            @property void back(RetTypeNoAutoDecoding val)
            {
                arr[$ - 1] = val;
            }
        }
    }

    static if (rt >= RangeType.Random)
    {
        static if (r == ReturnBy.Reference)
        {
            ref inout(RetType) opIndex(size_t index) inout
            {
                return arr[index];
            }
        }
        else
        {
            RetType opIndex(size_t index) const
            {
                return arr[index];
            }

            RetType opIndexAssign(RetTypeNoAutoDecoding val, size_t index)
            {
                return arr[index] = val;
            }

            RetType opIndexOpAssign(string op)(RetTypeNoAutoDecoding value, size_t index)
            {
                mixin("return arr[index] " ~ op ~ "= value;");
            }

            RetType opIndexUnary(string op)(size_t index)
            {
                mixin("return " ~ op ~ "arr[index];");
            }
        }

        typeof(this) opSlice(size_t lower, size_t upper)
        {
            auto ret = this;
            ret.arr = arr[lower .. upper];
            return ret;
        }

        typeof(this) opSlice()
        {
            return this;
        }
    }

    static if (l == Length.Yes)
    {
        @property size_t length() const
        {
            return arr.length;
        }

        alias opDollar = length;
    }
}

enum dummyLength = 10;

alias AllDummyRanges = AliasSeq!(
    DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Forward),
    DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Bidirectional),
    DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Random),
    DummyRange!(ReturnBy.Reference, Length.No, RangeType.Forward),
    DummyRange!(ReturnBy.Reference, Length.No, RangeType.Bidirectional),
    DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Input),
    DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Forward),
    DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Bidirectional),
    DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Random),
    DummyRange!(ReturnBy.Value, Length.No, RangeType.Input),
    DummyRange!(ReturnBy.Value, Length.No, RangeType.Forward),
    DummyRange!(ReturnBy.Value, Length.No, RangeType.Bidirectional)
);

template AllDummyRangesType(T)
{
    alias AllDummyRangesType = AliasSeq!(
        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Forward, T),
        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Bidirectional, T),
        DummyRange!(ReturnBy.Reference, Length.Yes, RangeType.Random, T),
        DummyRange!(ReturnBy.Reference, Length.No, RangeType.Forward, T),
        DummyRange!(ReturnBy.Reference, Length.No, RangeType.Bidirectional, T),
        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Input, T),
        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Forward, T),
        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Bidirectional, T),
        DummyRange!(ReturnBy.Value, Length.Yes, RangeType.Random, T),
        DummyRange!(ReturnBy.Value, Length.No, RangeType.Input, T),
        DummyRange!(ReturnBy.Value, Length.No, RangeType.Forward, T),
        DummyRange!(ReturnBy.Value, Length.No, RangeType.Bidirectional, T)
    );
}

/**
Tests whether forward, bidirectional and random access properties are
propagated properly from the base range(s) R to the higher order range
H.  Useful in combination with DummyRange for testing several higher
order ranges.
*/
template propagatesRangeType(H, R...)
{
    static if (allSatisfy!(isRandomAccessRange, R))
        enum bool propagatesRangeType = isRandomAccessRange!H;
    else static if (allSatisfy!(isBidirectionalRange, R))
        enum bool propagatesRangeType = isBidirectionalRange!H;
    else static if (allSatisfy!(isForwardRange, R))
        enum bool propagatesRangeType = isForwardRange!H;
    else
        enum bool propagatesRangeType = isInputRange!H;
}

template propagatesLength(H, R...)
{
    static if (allSatisfy!(hasLength, R))
        enum bool propagatesLength = hasLength!H;
    else
        enum bool propagatesLength = !hasLength!H;
}

/**
Reference type input range
*/
class ReferenceInputRange(T)
{
    import std.array : array;

    this(Range)(Range r) if (isInputRange!Range) {_payload = array(r);}
    final @property ref T front(){return _payload.front;}
    final void popFront(){_payload.popFront();}
    final @property bool empty(){return _payload.empty;}
    protected T[] _payload;
}

/**
Infinite input range
*/
class ReferenceInfiniteInputRange(T)
{
    this(T first = T.init) {_val = first;}
    final @property T front(){return _val;}
    final void popFront(){++_val;}
    enum bool empty = false;
    protected T _val;
}

/**
Reference forward range
*/
class ReferenceForwardRange(T) : ReferenceInputRange!T
{
    this(Range)(Range r) if (isInputRange!Range) {super(r);}
    final @property auto save(this This)() {return new This( _payload);}
}

/**
Infinite forward range
*/
class ReferenceInfiniteForwardRange(T) : ReferenceInfiniteInputRange!T
{
    this(T first = T.init) {super(first);}
    final @property ReferenceInfiniteForwardRange save()
    {return new ReferenceInfiniteForwardRange!T(_val);}
}

/**
Reference bidirectional range
*/
class ReferenceBidirectionalRange(T) : ReferenceForwardRange!T
{
    this(Range)(Range r) if (isInputRange!Range) {super(r);}
    final @property ref T back(){return _payload.back;}
    final void popBack(){_payload.popBack();}
}

@safe unittest
{
    static assert(isInputRange!(ReferenceInputRange!int));
    static assert(isInputRange!(ReferenceInfiniteInputRange!int));

    static assert(isForwardRange!(ReferenceForwardRange!int));
    static assert(isForwardRange!(ReferenceInfiniteForwardRange!int));

    static assert(isBidirectionalRange!(ReferenceBidirectionalRange!int));
}

private:

pure struct Cmp(T)
if (is(T == uint))
{
    static auto iota(size_t low = 1, size_t high = 11)
    {
        import std.range : iota;
        return iota(cast(uint) low, cast(uint) high);
    }

    static void initialize(ref uint[] arr)
    {
        import std.array : array;
        arr = iota().array;
    }

    static bool function(uint,uint) cmp = function(uint a, uint b) { return a == b; };

    enum dummyValue = 1337U;
    enum dummyValueRslt = 1337U * 2;
}

pure struct Cmp(T)
if (is(T == double))
{
    import std.math.operations : isClose;

    static auto iota(size_t low = 1, size_t high = 11)
    {
        import std.range : iota;
        return iota(cast(double) low, cast(double) high, 1.0);
    }

    static void initialize(ref double[] arr)
    {
        import std.array : array;
        arr = iota().array;
    }

    alias cmp = isClose!(double,double,double);

    enum dummyValue = 1337.0;
    enum dummyValueRslt = 1337.0 * 2.0;
}

struct TestFoo
{
    int a;

    bool opEquals(const ref TestFoo other) const
    {
        return this.a == other.a;
    }

    TestFoo opBinary(string op)(TestFoo other)
    {
        TestFoo ret = this;
        mixin("ret.a " ~ op ~ "= other.a;");
        return ret;
    }

    TestFoo opOpAssign(string op)(TestFoo other)
    {
        mixin("this.a " ~ op ~ "= other.a;");
        return this;
    }
}

pure struct Cmp(T)
if (is(T == TestFoo))
{
    static auto iota(size_t low = 1, size_t high = 11)
    {
        import std.algorithm.iteration : map;
        import std.range : iota;
        return iota(cast(int) low, cast(int) high).map!(a => TestFoo(a));
    }

    static void initialize(ref TestFoo[] arr)
    {
        import std.array : array;
        arr = iota().array;
    }

    static bool function(TestFoo,TestFoo) cmp = function(TestFoo a, TestFoo b)
    {
        return a.a == b.a;
    };

    @property static TestFoo dummyValue()
    {
        return TestFoo(1337);
    }

    @property static TestFoo dummyValueRslt()
    {
        return TestFoo(1337 * 2);
    }
}

@system unittest
{
    import std.algorithm.comparison : equal;
    import std.range : iota, retro, repeat;

    static void testInputRange(T,Cmp)()
    {
        T it;
        Cmp.initialize(it.arr);
        for (size_t numRuns = 0; numRuns < 2; ++numRuns)
        {
            if (numRuns == 1)
            {
                static if (is(immutable ElementType!(T) == immutable uint))
                {
                    it.reinit();
                }

                Cmp.initialize(it.arr);
            }

            assert(equal!(Cmp.cmp)(it, Cmp.iota(1, 11)));

            static if (hasLength!T)
            {
                assert(it.length == 10);
            }

            assert(!Cmp.cmp(it.front, Cmp.dummyValue));
            auto s = it.front;
            it.front = Cmp.dummyValue;
            assert(Cmp.cmp(it.front, Cmp.dummyValue));
            it.front = s;

            auto cmp = Cmp.iota(1,11);

            size_t jdx = 0;
            while (!it.empty && !cmp.empty)
            {
                static if (hasLength!T)
                {
                    assert(it.length == 10 - jdx);
                }

                assert(Cmp.cmp(it.front, cmp.front));
                it.popFront();
                cmp.popFront();

                ++jdx;
            }

            assert(it.empty);
            assert(cmp.empty);
        }

    }

    static void testForwardRange(T,Cmp)()
    {
        T it;
        Cmp.initialize(it.arr);
        auto s = it.save();
        s.popFront();
        assert(!Cmp.cmp(s.front, it.front));
    }

    static void testBidirectionalRange(T,Cmp)()
    {
        T it;
        Cmp.initialize(it.arr);
        assert(equal!(Cmp.cmp)(it.retro, Cmp.iota().retro));

        auto s = it.back;
        assert(!Cmp.cmp(s, Cmp.dummyValue));
        it.back = Cmp.dummyValue;
        assert( Cmp.cmp(it.back, Cmp.dummyValue));
        it.back = s;
    }

    static void testRandomAccessRange(T,Cmp)()
    {
        T it;
        Cmp.initialize(it.arr);
        size_t idx = 0;
        foreach (jt; it)
        {
            assert(it[idx] == jt);

            T copy = it[idx .. $];
            auto cmp = Cmp.iota(idx + 1, it.length + 1);
            assert(equal!(Cmp.cmp)(copy, cmp));

            ++idx;
        }

        {
            auto copy = it;
            copy.arr = it.arr.dup;
            for (size_t i = 0; i < copy.length; ++i)
            {
                copy[i] = Cmp.dummyValue;
                copy[i] += Cmp.dummyValue;
            }
            assert(equal!(Cmp.cmp)(copy, Cmp.dummyValueRslt.repeat(copy.length)));
        }

        static if (it.r == ReturnBy.Reference)
        {
            T copy;
            copy.arr = it.arr.dup;
            for (size_t i = 0; i < copy.length; ++i)
            {
                copy[i] = Cmp.dummyValue;
                copy[i] += Cmp.dummyValue;
            }

            assert(equal!(Cmp.cmp)(copy, Cmp.dummyValueRslt.repeat(copy.length)));
        }
    }

    import std.meta : AliasSeq;

    static foreach (S; AliasSeq!(uint, double, TestFoo))
    {
        foreach (T; AllDummyRangesType!(S[]))
        {
            testInputRange!(T,Cmp!S)();

            static if (isForwardRange!T)
            {
                testForwardRange!(T,Cmp!S)();
            }

            static if (isBidirectionalRange!T)
            {
                testBidirectionalRange!(T,Cmp!S)();
            }

            static if (isRandomAccessRange!T)
            {
                testRandomAccessRange!(T,Cmp!S)();
            }
        }
    }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /**
For testing only.
Contains tests related to member privacy that cannot be verified inside
std.range itself.
*/
module std.internal.test.range;

// Note: currently can't be @safe because RefCounted, which is used by chunks,
// isn't.
@system /*@safe*/ unittest
{
    import std.algorithm.comparison : equal;
    import std.range : chunks;

    struct R
    {
        int state = 0;
        @property bool empty() { return state >= 5; }
        @property int front() { return state; }
        void popFront() { state++; }
    }

    auto r = R().chunks(3);
    assert(r.equal!equal([[ 0, 1, 2 ], [ 3, 4 ]]));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /**
For testing only.
Provides a struct with UDA's defined in an external module.
Useful for validating behavior with member privacy.
*/
module std.internal.test.uda;

enum Attr;

struct HasPrivateMembers
{
  @Attr int a;
  int b;
  @Attr private int c;
  private int d;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               module std.internal.unicode_comp;
import std.internal.unicode_tables;

@safe pure nothrow @nogc package(std):


static if (size_t.sizeof == 4)
{
//10144 bytes
enum combiningClassTrieEntries = TrieEntry!(ubyte, 8, 8, 5)(cast(immutable size_t[]) x"
0000000000000040000005C0",
cast(immutable size_t[]) x"
0000010000000B00000010A0",
cast(immutable size_t[]) x"
020201000402030206020205090807020000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000002000100040003000000000000000000000000000000000000000500000000
0000000000000000000700060000000800000009000B000A00000000000D000C000F000E000000100000000000110000
00130012000000140000001500170016001800000000001900180000001B001A001800000000001A001800000000001A
001800000000001A000000000000001A001800000000001C001800000000001A001D00000000001A000000000000001E
001F00000000002000210000000000220024002300250000000000260000002700280000000000000000002900000000
0000000000000000000000000000000000000000000000000000000000000000000000000000002A0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
002C002B00000000000000000000002D0000000000000000002E000000000000002F0000000000000000000000000000
0000003000310000003200000000003300340000003600350037000000380000003900000000000000000000003B003A
000000000000000000000000003D003C0000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000003F003E0000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000004000000000000000410000000000000042000000000000000000000000000000000000
000000000000000000000000000000000043000000000000000000440000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000450000000000460047000000000000000000000000000000000000
004900480000000000000000004A0035004B00000000004C004D00000000004E0000000000000000004F000000510050
000000000000000000000000001A00000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
005300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000005400000000000000000000000000000055000000000000005600000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
005800570000000000000000005900000000000000000000000000000000000000000000000000000000000000000000
005A00000000000000000000000000000000000000000000005B0000005C0000000000000000005D0000005E00000000
00000000005F0048006000000000000000620061004D0000000000000000006300640000000000000000000000650000
006600000067001A0000000000000000000000000000006800000000000000690000000000000000004100000000006A
0041000000000000006B000000000000006C000000000000000000000000000000600000000000000000000000000000
006D00000000006E00000000004E0000002C00000000006F000000700000000000000000000000000000000000000000
004100000000000000000000000000000000000000000071000000720000000000000000000000000000000000000000
000000000000007300000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000740000
007500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000076000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000770000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000780000007A007900000000000000000000007B0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000007D007C000000000000007E0000000000750000000000000000000000000000
0000000000000000007F0000008000000000000000000000000000000000000000000000000000000000000000810000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000820000000000000083000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6DCDCE8E6D8E8DCDCDCDCDCDC
DCCACADCCADCDCDCDCDCDCCADCDCDCDCDCDCDCDC01010101DCDCDC01E6E6E6DCE6E6E6E6DCE6F0E6E6E6DCDC00DCDCE6
DCE6E6E6E6DCDCDCE6DCDCE8E9EAEAE9E6E9EAEAE6E6E6E6E6E6E6E6E6E6E6E600000000000000000000000000000000
E6000000E6E6E6E600000000000000000000000000000000000000000000000000000000000000000000000000000000
E6E6DC00E6DCE6E6DCDEE6E6E6E6E6E6DCDCE6E6DCDCDCDCE6DCE6E6E6E4DEE60D0C0B0A11100F0E1413131217001615
001918001200DCE600000000000000000000000000000000000000000000000000000000000000000000000000000000
E6E6E6E6E6E6E6E600201F1E0000000000000000000000001B0000001F1E1D1CE6222120E6DCDCE6E6E6E6E6DCE6E6DC
000000000000000000000000000000000000002300000000000000000000000000000000000000000000000000000000
00000000E6E60000E6E6E6E6E60000E6DCE6E6E6E60000E6E6DC00E60000DCE600000000000000000000000000000000
000000000000000000000000000000000000240000000000000000000000000000000000000000000000000000000000
E6E6DCE6DCE6E6DCDCE6DCDCE6DCE6DCE6DCE6E6E6DCE6DC00E6E6DC0000000000000000000000000000000000000000
0000000000000000E6000000E6E6E6E6E6DCE6E600000000000000000000DC0000000000000000000000000000000000
00000000E6E60000E600E6E6E6E6E6E6E6E6E6E6E6E6E600E6E6E6000000E6E600000000000000000000000000000000
000000000000000000000000000000000000000000000000DCDCDC000000000000000000000000000000000000000000
0000000000000000DCDCDCE6E6E6E6E60000000000000000E6E60000DCE6E6E6DCDCDCDCE6E6E6E6E6E6E6E6E6E6E6E6
DC00E6E6E6DCE6E6E6E6DCE6DCDCDCE6E61D1C1BE6DCE6E6E6DCDCE6E6E6E6E600000000000000000000000000000000
0000000000000000000000000000000700000000000000000000000000000900E6DCE600000000E60000000000000000
000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000E600000000000000000000000000000000090000000000005B54000000000000000000
000000000000000000000000000000000000000000000000090000000000000900000000000000000009000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000009676700000000
00000000000000006B6B6B6B000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000976760000000000000000000000007A7A7A7A0000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000DCDC0000000000000000000000000000000000000000
00000000DC00DC000000D800000000000000000000000000000000000000000000828100000000848282000000008282
E6E60082E6E600090000000000000000000000000000000000000000000000000000000000DC00000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000070000000009090000000000
0000000000000000000000000000DC000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000E6E6E6000000000000000000000000000000000000000000000009090000000000000000
000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000
0009000000000000000000000000E60000000000000000000000E4000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000DCE6DE000000000000000000000000000000000000000000
00000000E6000000000000DC000000000000000900000000000000000000000000000000E6E6E600E6E6E6E6DC0000E6
00000000000000000000000000000000E6E6E6E6DCDCDCE6E6DCDCDCDC00DCE6DCE6E6DCE6E6E6DCE6DCE6E600E6E6E6
000000000000000000000000000000000000000000000000000000000000000000000000000000070000000000000000
00000000000000090000000000000000000000000000000000000000000000000000000000000000E6000000E6E6E6DC
E6E6E6E60000000000000000000000000000000000000000090900000000000000000000000000000000000000000000
000000000007000000000000000000000909000000000000000000000000000000000000000000000000000000000000
000000000700000000000000000000000000000000000000000000000000000000E6E6E6DCDCDC01E6E6DCDCDCDCDCDC
010100E601010101000000010000DC0000000000000000E60000E6E600000000E6DCE6E6E6E6E6E6E6DCE6E6DCD6EAE6
E6E6E6CAE6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E4E8E6E6E6DADCE4DCE6DCE9
000000000000000000000000000000000101E6E6E6E6E6E6E6010101000000E60000E600E60101000101E6DCDCDCDCDC
000000E6000000000000000000000000000000000000000000000000E60000000000E6E6000000000000000000000000
0000000000000000000000000000000000000000000000000000000009000000E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6
E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E60000000000000000E4DA0000E0E0DEE800000000000000000000000000000000
0000000000000000000000000000000000000000000000000008080000000000000000000000000000000000E6000000
00000000E6E6E6E6E6E6E6E60000E6E600000000000000000000000000000000000000000000000000000000E6E60000
000000000000000000000000000000000000E6E600000000000000000000000000000000000900000000000000000000
000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000
E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E60000E6E60000000000000000000000000000000000000000DC0000000000DCDC
000000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000
000000000000000000000000000000000700000000000000000000000000000000000009000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000E6E600E6E60000DC000000E6E6E60000
0000E6000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000090000000000000000000000000000000000000000000000000000000000000000000000000000001A0000
E6E6E6E6DCE6E6E6DCDCDCDCE6E6DCDC0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000DC00000000DC00000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000E6E6000000E6E6E600000000000000000000000000000000E600DC00
0000000000000000000000000000000000000000000000000000000000000000000000000000000000DC01E609000000
0000000000DCE60000000000000000000000000000000000000000000000000000000000E6E6E6E60000000000000000
000000000000000000000000000000000000000000000000E6000000000000E600000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000DCDCDC0000000000DCDC0000DCE6E6E6DCDCDCE6
000000DC000000000000000000000000DCE600000000DCE6000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000900000000000000000900000000000000000000000000000000000000
0000000000000000000709000000000000E6E6E600000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000900000000000009000000000000000000000009000000000007000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000709000000000000000000
000000000000000000090700000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000070000000000000700000000E6E60000E6E6E6E6000000E6E6E6E6E6000000E60000000000000000
0009000000070000000000000000000000000000000000000000000000E6000007090000000000000000000000000000
000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000007090000000000000000000000000000000000000900000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090900
070000000000000000000000000000000000000000000000000000000000000000000000090000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000090000000000
000700000000090900000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000900000000000000000000000009090000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000101010100000001000000000000000000000000000000000000000000000000
E6E6E6E600E6E6E600000000000000000000000000000000000000000000000000000606000000000000000000000000
00000000000000000000000000000000000000000000000000000000000100000000000001D8D80000000101D8D8E200
00D8D8D800000000DC000000DCDCDCDC00DCDCDCE6E6E600DCDCE6E60000000000000000000000000000000000000000
0000000000000000E6E600000000E6E600000000000000000000000000000000E6E60000000000E60000000000000000
00000000000000000000000000000000E6E6E6E600E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E6E60000E6E6E6E6E6
E600E6E6E6E600E600E6E6E60000000000000000000000000000000000000000000000000000000000000000E6000000
0000000000000000000000000000000000000000000000000000000000E6000000000000000000000000000000000000
000000000000000000000000E6E6E6E600000000000000000000000000000000000000000000000000000000E6DCE8E8
0000000000000000000000000000000000000000000000000000000000000000DCDCDCDC00DCDCDC0000000000000000
00000000E6E6E6E60007E6E6000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
enum composeIdxMask = (1 << 11) - 1, composeCntShift = 11;
enum compositionJumpTrieEntries = TrieEntry!(ushort, 12, 9)(cast(immutable size_t[]) x"
0000000000000800",
cast(immutable size_t[]) x"
0000100000002600",
cast(immutable size_t[]) x"
00010000000300020005000400070006000700080007000700090007000A0007000C000B000700070007000700070007
0007000D0007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
0007000700070007000700070007000700070007000700070007000700070007000F000E000700100007001100070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
000700070007000700070007000700070007000700070007000700070007000700070007000700070007000700070007
0007000700070007000700070007000700070007000700070007000700070007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF08010800FFFF08028003FFFF281618138821301B383308327841383A28510850185C30568068485F
FFFF10783882407A9890388930A510A348AD10ABFFFF30B6FFFFFFFFFFFFFFFF80BCFFFF28CF18CC88DA30D438EC08EB
70FB40F3290B11091916311081224919FFFF1132393C4134994B41433960115E51691167FFFF3173FFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1979FFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF217C0981098009841182
FFFFFFFFFFFF2185FFFFFFFF0989FFFFFFFFFFFFFFFFFFFF198E218AFFFF0991FFFF0992FFFFFFFFFFFF2193FFFFFFFF
FFFFFFFFFFFF2197099C099B099F119DFFFFFFFFFFFF21A0FFFFFFFF09A4FFFFFFFFFFFFFFFFFFFF19A921A5FFFF09AC
FFFF09ADFFFFFFFFFFFF21AEFFFFFFFFFFFFFFFF21B621B2FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFF11BC11BAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF11C011BEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFF09C309C2FFFFFFFFFFFFFFFF09C509C4FFFFFFFFFFFFFFFFFFFFFFFF09C709C609C909C8FFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF09CAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
29D029CBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF29D5FFFFFFFF29DAFFFFFFFFFFFFFFFF09DFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFF09E109E0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF09E309E209E509E4FFFFFFFFFFFFFFFF09E709E6
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFF09E8FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF39E9FFFFFFFFFFFF21F0FFFF29F4FFFF
39F9FFFFFFFFFFFFFFFFFFFF2200FFFF0A04FFFFFFFFFFFF3205FFFFFFFFFFFF2A0BFFFFFFFFFFFFFFFF0A10FFFF0A11
4212FFFFFFFFFFFF221AFFFF321EFFFF4224FFFFFFFFFFFFFFFFFFFF222CFFFF1230FFFFFFFFFFFF4232FFFFFFFFFFFF
323AFFFF1A431A40FFFFFFFFFFFF0A46FFFFFFFFFFFF1247FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A49FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFF124A0A4CFFFF1A4DFFFF0A521250FFFF2253FFFF0A57FFFFFFFFFFFF0A58FFFFFFFF2259FFFFFFFFFFFF0A5DFFFF
FFFFFFFF0A5EFFFF0A5FFFFFFFFFFFFFFFFF12600A62FFFF1A63FFFF0A681266FFFF2269FFFF0A6DFFFFFFFFFFFF0A6E
FFFFFFFF226FFFFFFFFFFFFF0A73FFFFFFFFFFFF0A74FFFF0A75FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A76
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF0A780A77FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A7A0A79FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0A7C0A7BFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF1A7DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A80FFFF0A81FFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A82FFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A830A84FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A85FFFFFFFFFFFFFFFFFFFFFFFFFFFF0A860A87FFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1288FFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1A8AFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFF0A8DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF0A90128EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A91FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A92FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1A93
FFFFFFFFFFFF0A96FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF0A991297FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF1A9AFFFFFFFFFFFFFFFF0A9DFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A9EFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0A9FFFFF0AA0FFFF0AA1FFFF0AA2FFFF0AA3FFFFFFFFFFFF
0AA4FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0AA5FFFF0AA60AA80AA7
FFFFFFFFFFFF0AA9FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF0AAB0AAAFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0AAD0AACFFFFFFFFFFFFFFFF
FFFFFFFF0AAF0AAEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF12B212B0FFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0AB50AB4FFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0AB70AB6FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF22BC22B80AC10AC00AC30AC20AC50AC4
22CA22C60ACF0ACE0AD10AD00AD30AD212D612D4FFFFFFFFFFFFFFFFFFFFFFFF12DA12D8FFFFFFFFFFFFFFFFFFFFFFFF
22E022DC0AE50AE40AE70AE60AE90AE822EE22EA0AF30AF20AF50AF40AF70AF61AFB1AF8FFFFFFFFFFFFFFFFFFFFFFFF
1B011AFEFFFFFFFFFFFFFFFFFFFFFFFF13061304FFFFFFFFFFFFFFFFFFFFFFFF130A1308FFFFFFFFFFFFFFFFFFFFFFFF
1B0F1B0CFFFFFFFFFFFFFFFFFFFFFFFF1B12FFFFFFFFFFFFFFFFFFFFFFFFFFFF231923150B1E0B1D0B200B1F0B220B21
232723230B2C0B2B0B2E0B2D0B300B2FFFFF0B31FFFFFFFFFFFF0B32FFFFFFFFFFFFFFFFFFFFFFFFFFFF0B33FFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFF0B34FFFFFFFFFFFFFFFFFFFFFFFF1B35FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B38
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B39
FFFFFFFFFFFFFFFFFFFFFFFFFFFF1B3AFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFF0B3DFFFF0B3EFFFF0B3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B40FFFF0B41FFFF0B42FFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B43FFFFFFFFFFFFFFFFFFFF
FFFF0B440B45FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFF0B46FFFF0B47FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFF0B48FFFFFFFFFFFFFFFF0B49FFFF0B4AFFFFFFFFFFFFFFFF0B4BFFFFFFFF0B4CFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B4DFFFFFFFFFFFF0B4F0B4EFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B510B50FFFFFFFF0B530B52FFFFFFFF0B550B540B570B56FFFFFFFF
FFFFFFFF0B590B58FFFFFFFF0B5B0B5AFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B5CFFFFFFFF0B5DFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B5EFFFFFFFFFFFFFFFF0B600B5F0B61FFFFFFFFFFFFFFFFFFFF
FFFFFFFF0B630B620B650B64FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B66
FFFFFFFF0B67FFFF0B68FFFF0B69FFFF0B6AFFFF0B6BFFFF0B6CFFFF0B6DFFFF0B6EFFFF0B6FFFFF0B70FFFF0B71FFFF
0B72FFFFFFFFFFFFFFFF0B73FFFF0B74FFFF0B75FFFFFFFFFFFFFFFF1376FFFFFFFFFFFFFFFF1378137AFFFFFFFFFFFF
FFFF137C137EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B80FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B81
FFFFFFFF0B82FFFF0B83FFFF0B84FFFF0B85FFFF0B86FFFF0B87FFFF0B88FFFF0B89FFFF0B8AFFFF0B8BFFFF0B8CFFFF
0B8DFFFFFFFFFFFFFFFF0B8EFFFF0B8FFFFF0B90FFFFFFFFFFFFFFFF1391FFFFFFFFFFFFFFFF13931395FFFFFFFFFFFF
FFFF13971399FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0B9BFFFF
0B9D0B9//Written in the D programming language
/**
 * License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * Authors: Dmitry Olshansky
 *
 */
// !!! DO NOT EDIT !!!
// !!! Did you even read the comment? !!!
// This module is automatically generated from Unicode Character Database files
// https://github.com/dlang/phobos/blob/master/tools/unicode_table_generator.d
//dfmt off
module std.internal.unicode_decomp;
import std.internal.unicode_tables;

@safe pure nothrow @nogc package(std):


static if (size_t.sizeof == 4)
{
//23488 bytes
enum compatMappingTrieEntries = TrieEntry!(ushort, 8, 8, 5)(cast(immutable size_t[]) x"
000000000000004000000540",
cast(immutable size_t[]) x"
0000010000000A0000002360",
cast(immutable size_t[]) x"
020201000402030202020205070602020202020208020202000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000001000000030002000500040007000600080000000A0009
000C000B00000000000D0000000F000E00000000001100100013001200150014001700160019001800000000001B001A
00000000000000000000001C00000000001D0000001E0000000000000000001F00000000000000000000000000000000
000000000000000000000000000000000020000000000021000000000000002200230000000000240000000000000000
0000000000000025000000260000002700000000000000280000000000000029000000000000002A000000000000002B
002C000000000000002D00000000002E0000002F00310030003300320000000000340000000000000000000000350000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000037003600000038000000000000000000000000000000000000000000000000
00390000003B003A003D003C00000000003F003E0041004000430042004500440047004600490048004B004A004D004C
004F004E0051005000530052000000000055005400570056005900580000005A005C005B005E005D0060005F00610000
006200000000000000000000000000000000000000630000006500640067006600000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000006800690000000000000000006A00000000000000000000000000000000
00000000006B0000000000000000000000000000006C0000000000000000000000000000000000000000006D006E0000
0070006F0072007100740073000000750077007600790078007B007A007D007C007E00000080007F0000008100000000
00830082008500840087008600890088008B008A008D008C008F008E0091009000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000920000000000000000009300000000000000940000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000096009500000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000980097009A0099009C009B009E009D00A0009F00A200A100A400A3000000A5
00A700A600A900A800AB00AA00AD00AC00AF00AE00B100B000B300B200B500B400B700B600B900B800BB00BA00BD00BC
00BF00BE00C100C000C300C200C500C400C700C600C900C800CB00CA00CD00CC00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000CF00CE000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000D100D00000000000D2000000000000000000000000000000000000000000000000000000000000
00000000000000D30000000000000000000000000000000000D4000000000000000000000000000000D5000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00D600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000D800D700D90000000000DA0000000000000000000000000000000000000000000000000000000000000000
00DC00DB00DE00DD00E000DF00E200E100E400E300E600E500DB00E700E800DC00E900DE00EB00EA00EC00E200EE00ED
00F000EF00F200F100F400F300F600F50000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00F7000000F900F800000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000FB00FA00FD00FC00FF00FE00000000
000000000000000000000000000000000000000000000000000000000000000001010100010301020000010400000000
010601050000010700000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000010800000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000010A0109010C010B010E010D0110010F
011201110114011301160115011801170000011900000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000100000000000000000000000000000015000006920000000000090000
00000000030F0343120F000300000000031400480000078A03C603CE000004940570056D0586057305B005A605F80000
062E062B0658063106E706E406F906EA0792000007AC07A907C207AF000007E608B4000008BA08B7096208CE00000000
09AF09AC09C509B209EF09E50A4A00000A8C0A890AB60A8F0B490B460B580B4C0C4400000C610C5E0C770C6400000C9B
0D6B00000D710D6E0E0F0D850E1E000009C8058909CB058C0A0D05CE0A3E05EC0A4105EF0A4405F20A4705F50A71061A
000000000AA506470AB006520AB306550AD306750ABC065E0AFE069A0B0406A00B0706A30B0D06A90B1906BA00000000
0B4F06ED0B5206F00B5506F30B6E070F000006F60B3A06D80B7607170BB1072E0743000007500BCF07460BDC07400BD2
00000BCC078F0000079E0C4107980C500F300C4A000000000C8607D10C9107DC0CA507F0000000000D0A08450D20085B
0D10084B0D2E086F0D3508760D4C088D0D3B087C0D6008A90D5708A0000000000D7408BD0D7B08C40D8208CB0D9B08E4
0D9E08E70DC709100DEC09420E120965097C097109820E2C060D0E32084306140CB107FC000000000000000000000000
00000000000000000000000008F3000000000DAA00000000000000000000000000000000000000000000000000000000
00000000000000000613060C07360A6A0BBC073D0786078305B70C35070309F607F30B6208EA0CA808D90DA108D50D90
08DD0D8C08D10D9400000D8809E805A909E105A20E680E5D000000000B0A06A60BAB07280CCF081A0CD2081D0F070E82
06090B790A6706100AFB0697000000000C3E078C09F205B30E650E5A0E6F0E6009F905BA09FC05BD0ABF06610AC20664
0B6507060B6807090CAB07F60CAE07F90D13084E0D1608510DA408ED0DA708F00D49088A0D5D08A6000000000B2206C3
00000000000000000000000009DE059F0ACC066E0C9E07E90C7E07C90C9407DF0C9707E20E18096B0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0EB70B100A14073E0EE10EDD0DE40EE90000069500000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000012000F004B00240027000600000000
0A2B0EB10B44084300000F0A000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000004001A002B00000000001D0000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000F2E0000000000000000000000540000000000000546
0000000000000000001C000307410F450FC00FA0000010110000104A10991073000011E2000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000107C101A115210EC11D21176
000012700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000126911DB12601232000012A811CB11471073106E1299107C0000124B00000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000124D120B00001255114D100A00000000
106A00000000000000000000000000001313130D130A000000000000130100000000000000000000131F132B00001334
000000000000000000000000000000001325000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000013790000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000001361135B135400000000000013C60000
0000000000000000137313810000139C0000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000013D013CD0000000000000000000000000000000013160000000013660000000000000000
0000000000000000000000000000000013481304134B130700000000135E13100000000013E213DD13691319136E131C
0000000013761322137C1328138C132E0000000013EA13E513BD134313991331139F133713A2133A13AD133D00000000
13B6134000000000000000000000000000000000000000000000000013ED000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000149414911497183A00001875
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000149A00001906183D
000018BC00000000000000000000000000001918000018FD000000000000000000000000000000000000000000000000
000000001915000000000000000000000000000000000000000000000000000000000000000000000000000000000000
192D00000000000000000000000000001936000000000000000019390000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
191E191B19241921192A1927193319300000000000000000000000000000000000000000194500000000194800000000
000000000000000000000000000000000000000000000000193F193C1942000000000000000000000000000000000000
000000000000000000000000000000000000000019570000000000000000195A00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
194B00001951194E00000000000019540000000000000000000000000000000000001966196300000000196900000000
0000000000000000000000000000000000000000000000001960195D0000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000196C0000000000000000000000000000000000000000
00000000000000000000000000000000000000001975196F000019720000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000001978000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000197B000000000000000019850000
000019881981197E00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000001991198B0000198E0000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000001994199A19970000199E00000000000000000000000000000000
000000000000000000000000000000000000000019A10000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000019AA00000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000019A719A40000000000000000000000000000000000000000
0000000000000000000019AD000000000000000000000000000000000000000000000000000000000000000000000000
0000000019B200000000000000000000000000000000000019B500000000000000000000000019B80000000019BB0000
0000000000000000000019BE000000000000000000000000000000000000000019AF0000000000000000000000000000
0000000019C1000019C4000019DC19E019E319E700000000000000000000000019C70000000000000000000000000000
000000000000000000000000000000000000000019CD00000000000000000000000000000000000019D0000000000000
00000000000019D30000000019D600000000000000000000000019D90000000000000000000000000000000000000000
19CA0000000000000000000000000000000000000000000000000000000019EA00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000019ED00000000
00000000000000000000000000001AE300001AE600001AE900001AEC00001AEF0000000000001AF20000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000001AF500001AF80000000000001AFE1AFB1B0100000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000E580568000005D5062905E606870E7C06CF06AC071A0607
07230734000007810E8B07A7076D06AF056B0890069207730E910E8F093A1B040A800A310EA30EA106020EA50B7C0000
0E7805D30E97078A1B081B060BA60CD61B0C0A27086D0EC911471B0E114B1149129B12990A140AE3086D0A2711491147
1299124D0000129B00000000000000000000000000000000000000000000000000001388000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000E9300000E9909A30EA50E6B0EA90ADC0EB50EAD0EBD0EBB1B100EBF0EC50F140F161B120ECB0ECD0ED10ECF
0ED50ED30EEB0EDB0E800EED0EF50EF30EF71B0A06110EF90F030F0111CB0F050A0A05CB0A1605DA0A1905DD0A1C05E0
0A4D05FB0A6E06170A74061D0A7D06260A7706200A7A06230AA8064A0AAC064E0AD606780AD9067B0ACF06710AF20684
0B01069D0B1C06BD0B2506C60B1F06C00B2806C90B2B06CC0B7107120B5B06FC0BA807250BAE072B0BB407310BD50749
0BD8074C0BE207560BDF07530C1507750C1807780C1B077B0C4707950C4D079B0C5607A40C5307A10C7A07C50C8207CD
0C8907D40C8D07D80CEF08380CF2083B0D0D08480D1908540D1C08570D23085E0D3808790D4208830D3108720D3E087F
0D4508860D51089D0D5A08A30D6608AF0D6308AC0DC4090D0DCD09160DCA09130D7708C00D7E08C70DDE09270DE1092A
0DE6093C0DE9093F0DF209480DEF09450DF8094B0E0409570E07095A0E1B096E0E2F097F0E3809880E3B098B0D540B2E
0E240DF50D3809A9000000000000000009FF05C009EC05AD09B9057A09B5057609C1058209BD057E0A0205C309D20593
09CE058F09DA059B09D605970A0605C70AC506670AB9065B0AA206440A9606380A9206340A9E06400A9A063C0AC8066A
0B5F07000B6B070C0CC808130CA207ED0C6B07B60C6707B20C7307BE0C6F07BA0CCB08160CB808030CB407FF0CC0080B
0CBC08070CC4080F0DC1090A0D9808E10DB108FA0DAD08F60DB909020DB508FE0DBD09060E0C095F0E2709770E210974
0E150968000000000000000000000000111B10F9111E10FC112711051130110E0F700F4E0F730F510F7C0F5A0F850F63
11601155116311581167115C000000000FAE0FA30FB10FA60FB50FAA00000000119F117D11A2118011AB118911B41192
0FE50FC30FE80FC60FF10FCF0FFA0FD811F911EA11FC11ED120011F1120411F5102C101D102F10201033102410371028
12401235124312381247123C000000001058104D105B1050105F10540000000012871278128A127B128E127F12921283
107F00001082000010860000108A000012D112AF12D412B212DD12BB12E612C410BE109C10C1109F10CA10A810D310B1
10EC10E51152114F1176116F11D211CF1232122F1260125D12A812A1000000001139111711221100112B110911341112
0F8E0F6C0F770F550F800F5E0F890F6711BD119B11A6118411AF118D11B8119610030FE10FEC0FCA0FF50FD30FFE0FDC
12EF12CD12D812B612E112BF12EA12C810DC10BA10C510A310CE10AC10D710B510F310F6114410E8000010EF1140113D
0F480F4B0F450F42002A0F92002A11CD0020005111C811720000117911C411C10FA00F9D0FC00FBD002D100700350031
11D511D811E211DE0000000011E61208101410171011100E003C000000440040126312661270126C1252124F12741296
1076107910731070001810670998001C0000000012FA12A4000012AB12F612F3104A104710991096000310E000000039
00010001000100010001000100010001000100010000000100000000000000001B1600000000000000000000004E0000
00000000000000000000000000000000000000000000000002FC02FA000002FF00000000000000000000000000010000
000000001B1C000000001B1F1B2B1B2800000000000000000000008F0000000C00000000000000000000000005630000
009205600000000000000000000000000000000000000000000000001B23000000000000000000000000000000010000
00000000000000000000000000000000000000000000000000000000000000000AE30305000000000374036503920383
03B003A11B5A02F400A105440B3E00A503140305030F0343037403650392038303B003A11B5A02F400A10544000000A5
0A8006920B44078A0B100EA10A2B0B7C0B3E05D308430CD600000BA60000000000000000000000000000000000000000
000008420000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
09A509A10E5005E30A2100000E7E0A250E53000006AC060206AC06AC0E740B1006CF06CF0A2B07340781000000000789
06AF0000076D083E076D076D00000000089208660000089A0000060A0000077F0000060A05B0071A05E305D50A800000
067E06290723000013FF078A1415140D0AE3141A068000001149124B10630F9700001B580000000005E600000A800A31
073E0AE300000000000000000000000003E203DA03CA03C103D204550498045903D604CF03DE04E704EB049C03BE0511
06D106CF06DE06D4091B06B20922091E068206E10953095005E30734072305E60B330AE30B400B360DD2086D0DD90DD5
0B440B430E000DFD09A30A2B05D30A3100000000000000000000000000000000030D0000000000000000000000000000
00000000000000000000000000000000000000001B3A1B33000000000000000000000000000000000000000000000000
00000000000000000000000000001B3F0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000001B4200001B451B4800000000000000000000000000000000
00000000000000000000000000000000000000000000000000001B4D000000001B5200000000000000001B5500000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000001B5C00001B5F
00000000000000001B651B621B6E000000001B7100000000000000000000000000000000000000000000000000000000
1B7500000000000000001B781B7B00001B7E000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000055600001B84000000000000000000000000000000001B810000055B054A
1B8A1B87000000001B901B8D000000001B961B930000000000000000000000001B9C1B99000000001BA81BA500000000
1BAE1BAB0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000001BBA1BB71BC01BBD00000000000000000000000000000000
000000000000000000000000000000001BA21B9F1BB41BB10000000000000000000000001BC61BC31BCC1BC900000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
1BE4000000001BE600000000000000000000000000000000000000000000000000000000000000000000000000000000
034303140365030F0383037403A10392031C03B00342032F036403550382037303A0039103F703AF00D900A300E600E2
00EE00EA00F600F200A700FA00B100AC00BB00B600C500C000CF00CA00DD00D403460319036803590386037703A40395
031F03B303450332036703580385037603A3039403FA03B2016A01660172016E017A01760182017E018A01860192018E
019A019601A2019E01AA01A601B201AE01BA01B601C201BE01CA01C605D5056805E605E3067E062906AC0687060706CF
0734071A0781072306AF07A7076D083E0890086106B2056B06820773060A095D093A06920A3109A30ADC0A800B100602
073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A270B440DE406110695000003050000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000001B69000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000054F054200000552
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000001BD90000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000006B2073E00000000
000000000000000000000000000000000000000000000000000000001BDE000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000232E000000000000000000000000000000000000
000000000000000000000000000000000000000027640000000000000000000000000000000000000000000000000000
1FAA1F981FB81FB01FC21FBC1FCA1FC61FFD1FD0201120092021201920392029203D203B206B205720772073207F2079
208F208D209D209B20A920A1210120F7212B21212131212F214A213921662160217C21762180217E218E218C21AA21A4
21B221AE21C121BA21DB21C521E121DD21E721E321F321EB223D220122492247228B228922972295229F229B032522A3
032922C3231222D523202318232C232623322330233623342394233823BE23B823C223C023C823C423D423CA23E623E2
24082406240E240C241424122428242624382436243C243A24582446245C245A248E246E24A0249024AC24A824CE24BC
24F424F0250424FE250C25082510250E251E251C2530252C253625342540253C25442542254A254825A4259A25C025BE
25DA25C425E225DE260425E6260A2606260E260C262626242634262A26442636264A2648266C265C267826762692267C
269C269426B426AE26C826BC26CE26CC26D226D026DA26D826EC26DE26F026EE26FE26FC270C27022710270E27162714
271A27182724271C27322730273A2738273E273C27442742274C274627542750275A2756275E275C2766276200000000
000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000001BF82081207F000020830000000000000000
00000000000000000000000000000000000000000000000000001C2D00001C3000001C3300001C3600001C3900001C3C
00001C3F00001C4200001C4500001C4800001C4B00001C4E1C5100001C5400001C570000000000000000000000000000
1C5D1C5A1C60000000001C631C691C661C6C000000001C6F1C781C750000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000001C2A0000000000000000008700000000008A1C7B1C82
00000000000000000000000000000000000000000000000000001CD500001CF200001CA500001D4100001D4A00001D5E
00001D6E00001D7900001D7E00001D8B00001D9000001D9A1DA100001DA600001CBF0000000000000000000000000000
1DD51DCC1DEA000000001DF11E101E061E25000000001E2D1D591E500000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000001CB01EF300001F011EFC00001F06000000001D501F0F
000000000000000000000000000000000000000000000000000000000000000019EF00001ABB19F41ABD19F619FB1ABF
1A021A001AC31AC11AC71AC51ACB1AC91A071A511A111A0C1A131A5B1A1A1A181A2C1A221A391A2E1A431A3E19F21A48
1A851A831A891A871A8D1A8B1A371A8F1A951A931A991A971A9D1A201AA11A9F1AA51AA31AA91A2A1A4D1A7F1ACD1A4F
1AD11ACF1AD51AD31AD91AD71ADB1A531A551ADD1A591A571A5F1A5D1A631A611A671A651A6B1A691A6F1A6D1A731A71
1A771A751AE11ADF1A7B1A791AAB1A7D1AAF1AAD1AB31AB11AB71AB500001AB9000000001FC61F9820F91F9E1FAC1FA0
24161FA21FA61FBC213E1F9A1FD0210301D701CE01E901E001FB01F2020D0204023302250245023C0257024E01DB01D2
01ED01E401FF01F6021102080237022902490240025B02520216022E0000021E0270026002A002680288027402840264
0290026C02C402B002B802C002A402EC02BC02AC02D002B402C8029802D402E40278028C02A8029C027C02CC029402E8
028002D802E002DC21C320D324B022950000000000000000000000000000000004060831041C04110432042704400439
044E04470475046E047F047C0485048219F619EF1A0219FB1A0C1A071A1A1A131A2E1A221A3E1A391A481A4319F819F1
1A0419FD1A0E1A091A1C1A151A301A241A401A3B1A4A1A451A271A3300001A1F1FC61F9820F91F9E20131FC820111F9C
207F1FBE2394032922D523382101267C22ED032522F222CD23CE20B9247C26102494205D214A241A1FFB265423482091
1FDD26E0213C20251FAC1FA021AC1FA2207B20B32164216A1FDB24422089261A04882135048E048B04B1049104B704B4
04BD04BA04C304C004C904C604E404CC034E033B04D604A3050304F2052905180327053A034D033A0A8506B407390A82
1CA01C871CB91CAE1CD31CC91D221CF01D481D3F1D6C1D5C1D7C1CCD1D8E1D891D9F1CAA1C8D1DA41DBE1D551D3D1DC0
1DCA1DBC1E041DE81E4E1E231E8B1CE01E9E1CD11EB31EAF1EC81EC01CE41ECA1EE31C9C1EF11D0C1EFF1EFA1FD81F04
1C8F1C891C9A1C941CA81CA21CBB1CB31CCB1CC21CE21CCF1CEB1CE61CDD1CD81CFA1CF51CFF1D061D0E1D0B1D1C1D15
1D2C1D101D3A1D331D531D441D611D571D711D661D851D811DA91D931D301DB21DC61DBB1DD81DE41DCF1DDF1DFB1DF4
1DED1E001E1A1E131E1F1E091E301E441E4A1E341E3E1E391E5B1E281E671E531E6A1E611E741E6E1E7D1E791E851E81
1E921E8D1EA01E951D171EA41EBA1EB51ECE1EC21ED81ED31EE51EDD1D1E1EE8033F031103610352037F0370039D038E
03BB03AC033E032B03600351037E036F039C038D03BA03AB040D0402042304180B12042E056A0A560C5B0A120A5C0CE9
0A630A5F21BC06DB213B22B222EF22AB0C290CDD0BED1211071C0B7E0689075B0B8F0A290C2C0CE0121D121406010BF9
0B81068D068C0764122008960A590C000AEF0B9712230C380A330C030C060B9A0A370A360C0A0B9D0A3B0A3A0C1E0BA1
06910C2207680B850CF906900D030CFD0C3B0CEC0C1212260C2F0CE30BF01217076F0B890C320CE60BF3121A07720B8C
077E0BB705D7099C0A300A2D05E805FF06940A5306AE0B16071F0B3D0BA507220BC20BBF0BC90BC50BFC0BF608230C0E
08260CD80D28082E0939086C05D1092D034A0337036C035D038A037B03A80399032303B703490336036B035C0389037A
03A7039803FE03B604140409042A041F043C0435044A0443047104510AF7047800000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000013B913B200000000
00000000000000000000000000000000000000000000000000000000000000000000276E000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000067E05E30000083E000000000E7A0E7200000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000002772276C27740EC1
000000000000000000000000000000000EFB000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000022C52608261C26361FAE2378276220AB2144276220DD267C2239214224FC2434
25B62598265A25D0234C230623EE23A22670257C1FC0270623102095259623B42198272E258E2388225325D825BC252A
22CF21D123DA23581FE326602065202F230C2287244423B2259225082630259E271E26C42462272C24DE2482268A256E
25F2273221DF211F251A24BA246623CC26C026182186211D2362230824D6237C26A024EA252020632033203524E02498
26A4257A2255260025F8230621701FB423E4220B207524241FEB246A1FA421FD22932342209F24D4244A211525EA257E
26482328225D233E226D255A1FCE24222031200F24CA22F625F025462069267A214A20C322A121D9246C238A270A2698
2740273422C120572642231E222D21BF2283223B23A8238224922400251624E42582263A268C264E2059204323A020CD
25EA25C6220721CF2324226923DE24B820FB1FD621A2217023EC220D250223FA267E251226C626BE1FE526E42674248C
221926B21FF71FC42182217223062299243223AE2658258822B9275E2055269E22E522DF23702354242023F224D22460
201326EA26A6224321941FEF263C2364221D21F523E422E9204726AA218A20BB22D722AE234622FC242A23F025C824F8
267825CE207D26B820BD2372240223B026AC259027362722236022E324A8252E24C024AE239C23D81FD225FE20492562
21C7204124C62257234E2168264022BF26A225C021D525DE20E91FFF0000000000002113000022B720370000243E23DC
247E2470248A248024C226CA0000250400002594000025F626500000000026660000000026F626F4272A26F826B02662
1FF91FE7206120032087206720EF20E1211120F3218821172213218C222B2227228D223722BB22A5235A22F823802368
23BA23AA246423F4247622F224782474247C247A2488248624A4249A24E424B224EC24E8250A24F6254C25322580254C
25E025D425FC25FA2620261E2650264C26DC26BA220F26E8253E283300000000202D1FA81FE1200D20172001206D205F
20D720E120ED20DF211B211321462140215C215421D721D321FF21EF22232217222B221B2237222522712245227B2277
22B7228F22D122CF232022DB235423282376237A238E2380245623AA23D623BC23FC23DC241C240A2430242E2440243E
245224482468245024B224A624DA24BE24F224E42564250A25B2257825DC25D625EC25E025EE25F625F825FA25FC25F4
262026022656263E2682267226BA26A826D426CA26E226DC271226E828092762281B28071F501F3C284F1F5228912861
276027580000000000000000000000000AE20ADE0AE10AE60D2B0AE500000D2B00000000000000000000000000000000
0000000013F9000013F313F013F613FC000000000000000014300000147D000013FF1451141F141A140B143914621446
02F4147814751472146E146A14041401140F1407141C1417142714210000142A1433142D143B14360000144300001448
144E144B1453000000001456145F145C146714641424147A143E1412140A145918C318C318C918C918C918C918CB18CB
18CB18CB18CF18CF18CF18CF18C718C718C718C718CD18CD18CD18CD18C518C518C518C518E718E718E718E718E918E9
18E918E918D318D318D318D318D118D118D118D118D518D518D518D518D718D718D718D718DD18DD18DB18DB18DF18DF
18D918D918E318E318E118E118EB18EB18EB18EB18EF18EF18EF18EF18F318F318F318F318F118F118F118F118F518F5
18F718F718F718F71918191818FB18FB18FB18FB18F918F918F918F9163C163C19151915000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000018ED000018ED18ED18AE18ED18AA18AE18B218AA190618B2190D190D19001900190B190B18B618B618B618B6
14C014C01878187818B818B8189C189C18AC18AC18A818A818B018B018B418B418A018B418A018A0190F190F190F190F
1880187C18A01890149F18A414A914A214BF14B614C914C214E314D8151514F8151D1518152F15261537153214DC14CD
157C14E014E7157F15B015A515C515B7163E160D1650164D1665165B16731670168F168A16B2162016EA16B516F016ED
16FE16F717061701171C170D1724171F172A17271730172D173E173317551741177317641624163714FC178B15041500
150815D117D8150C17FA17EB18141803181C1817182A181F1847182D1855184E186F185E158F1872184215990064005D
0072006B00800079188C18881894189018A418A014B3148614B914B614C214BF14F514F2150F14F81518151515231520
152915261532152F170116FE171F171C17301724173E173316371741178B162415D11790180017FD180E180318171814
18581842185E185B186F1869187C1872188418801898189014A2149F14B614A914C914BC14E314D8151214F815371526
14DC14CD157C14E015A514E715B715B0160D15C5163E16181650164D1665165B168A16701620168F16B516B216ED16EA
16F716F0170D1706172A17271730172D1755173317731764148B1637150014FC15D1150417EB17D8180317FA181C1811
1830181F184E1847185E18551890169814B6189814F814BC1526151215C5152C15F715D4173016021637173318111803
1698185E16D716D0168216DE16AA168516C416AD15D716C7160515DA153B160814D114A614EB14D5164514AD16681648
15DF166B15F115E615F415F7161B15C21682166216AA168516C416AD15D716C7160515DA153B160814D114A614EB14D5
164514AD1668164815DF166B15F115E615F415F7161B15C215DF166215F115E615D415F71673160215B015A515DF15B7
15F115E6168A1673148E148E000000000000000000000000000000000000000000000000000000000000000000000000
14DB14CC14DF14DB14FB14E6150314FF154E154E156C157015A815B315CC15AC15C815CC15D015D01610161015E91641
15E215E915FA15FA15FE15FE165E16531676165E167A16761692167E169E169E16B816A216BC16C016F316F317141710
176F17671758176B17761758177D177617A9177D17B617AD179E179617C117BD000000001822179A17EE182617DF17F2
17E317DF1806180A1861186114D414AC14EE14D0150B14EA155615071552153A161415BA165715ED17811760184A1851
17CC186517F6171817671710173A16A617C517DB1736175C17DB175C1565153E16FA17A2173614A51641169217E715BE
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000001709163A14841489161E17B116961594
16231635154216270000159C000000000000000000000000000000000000000000000000000000000000000000000000
1BE002F605401BE2008D05461C26009302FF1C2800000000000000000000000000000000000000000000000000000000
000000000000000000000000000000001B1A02FC09961B1800A109960E3E00A51BFA0E421BF41BFE1BE81BF61BE41BEA
1BEC1BE61BF01BEE00001BF2098E0000000C0992000C000C0996000C099609961BE002F6000002FA05400546008D0093
00A11B1A0E3E00A51BFA0E4200971BFE02F2009D02F802F40559054800000544009909900566009B0000000000000000
16CA00570000005A0000006116CD006816D4006F16DB007616E2007D16E500841491148014941491183A14941497183A
187514971875187514821875149D1482149D149D14C5149D14C714C514C714C7151B14C7151B151B14A0151B14A014A0
14A314A014A314A314AA14A314AA14AA158B14AA158D158B1487158D14B4148715A314B415A315A315DD15A315DD15DD
160B15DD160B160B164B160B164B164B166E164B166E166E1688166E16881688168D1688168D168D16B0168D16B016B0
16E816B016E816E8170416E8170417041722170417221722159717221597159714B7159714B714B714BA14B714BA14BA
148C14BA148C148C1833148C14C0183314A714C014A714A7174914A7174D17491751174D174617510000174600000000
008D000000970095009B0099009F009D00A500A102F402F202F802F6030302FA03140305030F03430374036503920383
03B003A10546054005440548009305590568056605E305D5062905E60687067E06CF06AC071A06070723073407A70781
083E06AF0861076D056B0890077306B2095D0682098E060A09920990099609940692099809A3093A0A800A3106020ADC
0AE30B100B7C073E05D30A2B078A0B3E05D80CD608430A140A270BA60DE4086D06950B440E3E06110E420E401BD50E44
1BE21BD71BEE1BEC1F0B1BE01C851F041CAC1C9E1CC71CB71EBE1EB11D9D1EC61C871CC51CAE1CA01CC91CB91CF01CD3
1D3F1D221D5C1D481CCD1D6C1D891D7C1CAA1D8E1DA41D9F1D551C8D1DC01DBE1DBC1D3D1DE81DCA1E231E041CE01E4E
1CD11E8B1EAF1E9E1EC01EB31ECA1EC81C9C1CE41D0C1EE31CB51EF1008B008819EF1A7F1ABB19F41ABD19F619FB1ABF
1A021A001AC31AC11AC71AC51ACB1AC91A071A511A111A0C1A131A5B1A1A1A181A2C1A221A391A2E1A431A3E00001A48
000000001A8319F21A871A851A8B1A89000000001A8F1A8D1A931A371A971A95000000001A201A991A9F1A9D1AA31AA1
000000001A2A1AA500001AA9000000000E480E4600090E4E0E4A0E4C00001B2F1B311BCF1B381B361BD11B3D00001BD3
00000000000000000000000000000000000000000000000000000000000000000F3300000E630F350E950F0E0F1C0000
0F2027760E9B0F1E1B140E9D0EA70E9F0EB30F280EAB0EAF0E740F100EB90F120F2A0EEF0EC30F2C277027D127D30EC7
27D50EFD0ED70E6D05D80ED927D70EDF0EE50EE30F260EE727780F220EF10F2400001BDC0F180EFF0F0C0F1A0E870E85
27D90E89000027DB00000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000277A0000277D0000000000000000000000000000000000000000
000000002780000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000002786278300000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000278900000000278C00000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000279200000000278F00002795
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000279B279800000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000279E00000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000027A427A1
27AB27A727B327AF000027B7000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000027BB000027BE27C627C227C9000027CD000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
05D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A7076D083E0890086106B2056B06820773
060A095D093A06920A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A27
0B440DE40611069505D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A7076D083E08900861
06B2056B06820773060A095D093A06920A3109A30ADC0A8000000602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D8
0BA60843086D0A270B440DE40611069505D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A7
076D083E0890086106B2056B06820773060A095D093A06920A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D3
0CD6078A0A1405D80BA60843086D0A270B440DE4061106950000056805E605E30000000000000687060700000000071A
0781000006AF07A70000083E0890086106B2056B06820773060A095D093A06920A3109A30ADC00000B100000073E0AE3
0A2B0B7C0B3E05D30CD600000A1405D80BA60843086D0A270B440DE40611069505D5056805E605E3067E062906AC0687
060706CF0734071A0781072306AF07A7076D083E0890086106B2056B06820773060A095D093A06920A3109A30ADC0A80
0B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A270B440DE40611069505D5056805E60000
067E062900000687060700000734071A0781072306AF07A70000083E0890086106B2056B068207730000095D093A0692
0A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A270B440DE406110695
05D5056805E60000067E062900000687060706CF0734071A00000723000007A7000000000890086106B2056B06820773
0000095D093A06920A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A27
0B440DE40611069505D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A7076D083E08900861
06B2056B06820773060A095D093A06920A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D8
0BA60843086D0A270B440DE4061106950781072306AF07A7076D083E0890086106B2056B06820773060A095D093A0692
0A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D8060A095D093A06920A3109A30ADC0A80
0B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A270B440DE40611069505D5056805E605E3
067E062906AC0687060706CF0734071A0781072306AF07A7076D083E0890086106B2056B06820773060A095D093A0692
0A3109A30ADC0A800B100602073E0AE30A2B0B7C0B3E05D30CD6078A0A1405D80BA60843086D0A270B440DE406110695
05D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A70B440DE4061106950E8D0E7600000000
0F950F400F990F970FB90F9B100A0FBB103B100C103F103D1043104110631045100A1065106C106A108E106E10921090
1B50077F114710E3114B1149116B114D11CB116D120B11CD120F120D122B1229124B122D1255124D125912571299125B
129D129B1B4B129F11CB114D1299120B124B124D0F950F400F990F970FB90F9B100A0FBB103B100C103F103D10431041
10631045100A1065106C106A108E106E109210901B50077F114710E3114B1149116B114D11CB116D120B11CD120F120D
122B1229124B122D1255124D125912571299125B129D129B1B4B129F11CB114D1299120B124B124D0F950F400F990F97
0FB90F9B100A0FBB103B100C103F103D1043104110631045100A1065106C106A108E106E109210901B50077F114710E3
114B1149116B114D11CB116D120B11CD120F120D122B1229124B122D1255124D125912571299125B129D129B1B4B129F
11CB114D1299120B124B124D0F950F400F990F970FB90F9B100A0FBB103B100C103F103D1043104110631045100A1065
106C106A108E106E109210901B50077F114710E3114B1149116B114D11CB116D120B11CD120F120D122B1229124B122D
1255124D125912571299125B129D129B1B4B129F11CB114D1299120B124B124D0F950F400F990F970FB90F9B100A0FBB
103B100C103F103D1043104110631045100A1065106C106A108E106E109210901B50077F114710E3114B1149116B114D
11CB116D120B11CD120F120D122B1229124B122D1255124D125912571299125B129D129B1B4B129F11CB114D1299120B
124B124D12FF12FD0000000003140305030F0343037403650392038303B003A103140305030F03430374036503920383
03B003A103140305030F0343037403650392038303B003A103140305030F0343037403650392038303B003A103140305
030F0343037403650392038303B003A10000000000000000000000000000000000000000000000000000000000000000
134E13461352135013591357136C1364137F137113861384138F138A139313911397139513A713A513AB13A913B413B0
13C013BB13E0276A13C913C413D713E8134613DB1350134E13571352136413591371136C1384137F138F138A13971393
13A713A513AB13A913B213B013D313B413C213C413D513CB13D927680000000000000000000000000000000000000000
00000000000000000000000000000000149D1482158B14A01833000014A314B414A7166E1597172214BA14B7168D15A3
160B16E81487170414C715DD14AA151B164B158D16B0168818F518BF18C118E5149D0000000014A00000148C14A30000
14A700001597172214BA14B7168D15A3160B16E80000170414C715DD14AA151B164B000016B000000000000000000000
00000000000014A00000000014A3000014A700001597000014BA0000168D15A3160B000000001704000015DD14AA0000
164B000016B0000018F5000018C10000149D0000000014A00000148C14A3000014A7166E0000172214BA14B7168D15A3
160B16E80000170414C715DD14AA151B164B000016B01688000018BF000018E5149D1482158B14A01833148C14A314B4
14A7166E1597000014BA14B7168D15A3160B16E81487170414C715DD14AA151B164B158D16B016880000000000000000
149D0000158B14A01833000014A314B414A7166E1597000014BA14B7168D15A3160B16E81487170414C715DD14AA151B
164B158D16B0168800000000000000000307030A03F1031604AB046804FA04DE0520050B000005310000000000000000
010200FE010A01060112010E011A01160122011E012A01260132012E013A01360142013E014A01460152014E015A0156
0162015E05E31BFC05E5076D0000093605D5056805E605E3067E062906AC0687060706CF0734071A0781072306AF07A7
076D083E0890086106B2056B06820773060A095D076F06B1086908630933082A00000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000761075E0000076C00000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000060600000000000000000000000000000000000000000000000000000000
1D4D1C7200001D5C000000000000000000000000000000000000000000000000216222491DA620A521331FC6213E25E4
22B01FCC229923A421F7204F229D201B24D820452612240E20C12125224F237E1F98226526521F9E1FAC21AC225F20B3
224B262624A22484236E20B7032922CD20512418266E20E700000000000000001C001C181C0C1C041C101C1C1C081C20
00001C1400000000000000000000000020AF21F900000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000003140305030F03430374036503920383
03B003A10000000000000000000000001FB21FB627DD1FBA1FE71FDF1FED1FE91FF31FF11FF51FF927E51F1220052003
201520071F1427DF201B200B202327E31FD42027202D202B203B28A11F18203F204D204B20532051205F1F1A20672061
206F206D20752071208720852093208B2099209720992099239627EB20A720A320AD27ED20B520B120BF20C920C720C5
20CF20CB20D520D120DB20D920DF20DB20E520E320FD20EB20FF20EF20F520F121232041210921072105210B210D210F
27EF2119212921272133212D2148213727F327F12150214E214C21521F1C2156215A1F1E215E215E216C27F52170216E
27F72174217A2178217E21E921841F202192218C27FB219027FD2196219A219C21A6219E1F2221A821B421B021B821B6
27FF1F2421C91F2621CD21CB28B521D1280321DD2538280321E521E528111F2821ED28651F2A21F1220321FB22092205
1F2E221122131F2C221528052221221F22212223222B2229222F22332235223122392237224121BD2251224D22632259
2261280B2267225B2275226B2279280D226F2273227D1F30228522811F32227F2291228D22A7280F22B522C722BB1F38
1F341F36201F201D22BD22C91F6A252222D122CF22DD22D3281922D922E71F3A22F422E1281D22F822EB22FA1F3C22FE
23022300230A2304230E281F23141F3E23162821231C1F40232823222823232A282527F92827233A23442340234A233C
235A235223562354235E235C23502829236C236A23761F42282B237423842366282F282D23902386238C238E23921F44
2398239A27E1239E283123A6283523AC23BC23B6283723C623D223D0283B283923E823E023EA1F461F481F4823F823F6
23FE23FC1F4A2404283D2410283F241E280124242841242C284528431F4E1F4C28492448284B2847244C284D244E244E
1F5224521F54245428511F562462245E1F582468247A2853285728552496248A249A1F5A249E249C285B285924AA285B
285D1F5C24B624B4285F1F5E1F6024C424C824CC286324D01F6224DC24E624E21F6424EE28692867286B1F66286D24FA
25062500286F250A25142871251828731F6828132526252425281F6C2875215828152877253828172646253A25501F6E
2552254E2554205B255825562879255C255E255A256A2568256C2560258025762570256625742572287F287B1F70287D
258625842887258A2881258C1F741F7228852883259C1F7625A0259E25A825A225AC25A625B225AA25B025AE1F7825B4
25BA25B825C21F7A288925C425CC25CA25D21F7C288B1F161F7E288D25E81F80260225F4288F260A2616261426282622
27E72893262C262E27E92632263E2638289728952664265E289926682680266A26882686268E2684289B26901F822696
289D269A26B61F8426C221A028A3289F1F881F8628A526D628A71F8A26E226E228A926E61F8C26F2270026FA27082704
28AB1F8E272027121F90272627281F921F9428AD28B128AF273A28B327441F96274A27482752274E28B7275600000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
//12544 bytes
enum canonMappingTrieEntries = TrieEntry!(ushort, 8, 8, 5)(cast(immutable size_t[]) x"
000000000000004000000440",
cast(immutable size_t[]) x"
000001000000080000001000",
cast(immutable size_t[]) x"
020201000302020202020204020502020202020206020202000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000002000100040003000600050007000000090008
000B000A00000000000000000000000000000000000D000C000F000E0000001000120011001400130000000000160015
000000000000000000000000000000000017000000000000000000000000001800000000000000000000000000000000
00000000000000000000000000000000001900000000001A000000000000001B001C00000000001D0000000000000000
000000000000001E0000001F000000200000000000000021000000000000002200000000000000230000000000000024
000000000000000000000000000000000000000000260025002800270000000000290000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000002B002A0000002C000000000000000000000000000000000000000000000000
00000000000000000000000000000000002E002D0030002F00320031003400330036003500380037003A0039003C003B
0000003D000000000000000000000000003E0000000000000040003F0000004100430042004500440047004600480000
004900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000004A00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000004C004B004E004D0050004F00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000520051005400530056005500580057
005A0059005C005B005E005D0000005F0061006000000062000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000006400630000000000650000000000000000000000000000
000000000000000000000000000000000000000000000066000000000000000000000000000000000067000000000000
000000000000000000680000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000069000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000006B006A006C00000000006D00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000006F006E0071007000730072007500740077007600790078007B007A007D007C
0000007E0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000F000C00250012004F00450085000000A1009E00CB00A40121011E013301240188000001A0019D01B601A3000001DA
026D00000273027002F30287000000000322031F03380325036203580398000003B403B103DE03B7043704340446043A
049C000004B404B104CA04B7000004EE05840000058A0587060D059E061C0000033B0028033E002B0380006D038C0079
038F007C0392007F0395008203A2008F0000000003CD00BA03D800C503DB00C803FB00E803E400D1040A00F7041000FD
0413010004190106041C010900000000043D01270440012A0443012D045C014900000130000000000462014F0471015D
0163000001700477016604840000047A000000000185000001940499018E04A8000004A20000000004D901C504E401D0
04F801E400000000052F021B0545023105350221054B02370552023E0569025505580244057B02640572025B00000000
058D02760594027D059B028405B4029D05B702A005E002C905F502DE061002F6030B0302031106280314062E00000631
050401F000000000000000000000000000000000000000000000000002AC0000000005C3000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000560000013D0369
01E7045002A304FB029205BA028E05A9029605A5028A05AD000005A1035B0048035400410653064A0000000004160103
046B01570522020E05250211065F065C0000046500000000040700F4000000000496018203650052065006470656064D
036C0059036F005C03E700D403EA00D7045301400456014304FE01EA050101ED05380224053B022705BD02A605C002A9
056602520578026100000000042501120000000000000000000000000351003E03F400E104F101DD04D101BD04E701D3
04EA01D6061602FC0000000000000000000000000000000000000000000000000010000D066B00000000013700000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000066200000000
000000000000000000000000000000010000000000000000063D00000645067006DF06C30000072C0000075907980778
000008D10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000007810735084707E908C108670000092F00000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000092808CA091F08FD0000095F0000000009B40000000009B700000000
0000000000000000000000000000000009CC09C609C300000000000009BA0000000000000000000009D809E4000009ED
0000000000000000000000000000000009DE000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000A200000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000A0E0A080A050000000000000A410000
00000000000000000A1A0A2600000A2F0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000A470A440000000000000000000000000000000009CF000000000A110000000000000000
0000000000000000000000000000000009FF09BD0A0209C0000000000A0B09C9000000000A4D0A4A0A1409D20A1709D5
000000000A1D09DB0A2309E10A2909E7000000000A530A500A3E09FC0A2C09EA0A3209F00A3509F30A3809F600000000
0A3B09F9000000000000000000000000000000000AC10ABE0AC40AC700000ACA00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000AD300000ACD0000000000000000
00000000000000000000000000000000000000000AD00000000000000000000000000000000000000000000000000000
000000000000000000000000000000000AE800000000000000000000000000000AF100000000000000000AF400000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000AD90AD60ADF0ADC0AE50AE20AEE0AEB00000000000000000000000000000000
000000000B00000000000B03000000000000000000000000000000000000000000000000000000000AFA0AF70AFD0000
0000000000000000000000000000000000000000000000000000000000000000000000000B1200000000000000000B15
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000B0600000B0C0B090000000000000B0F00000000000000000000000000000000
00000B210B1E000000000B24000000000000000000000000000000000000000000000000000000000B1B0B1800000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000B2700000000
0000000000000000000000000000000000000000000000000000000000000000000000000B300B2A00000B2D00000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000B330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000B3600000000000000000B40000000000B430B3C0B39000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000B4C0B4600000B4900000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000B4F0B550B5200000B59
000000000B5F0000000000000000000000000000000000000B620000000000000000000000000B65000000000B680000
000000000000000000000B6B00000000000000000000000000000000000000000B5C0000000000000000000000000000
000000000B6E00000B71000000000B8900000B8C0000000000000000000000000B740000000000000000000000000000
00000000000000000000000000000000000000000B7A0000000000000000000000000000000000000B7D000000000000
0000000000000B80000000000B830000000000000000000000000B860000000000000000000000000000000000000000
0B77000000000000000000000000000000000000000000000000000000000B8F00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B92
00000B9500000B9800000B9B00000B9E0000000000000BA1000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000BA400000BA70000000000000BAD0BAA0BB00000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000037D006A038300700386007303890076
039B0088039F008C03A5009203AE009B03A8009503AB009803D000BD03D400C103FE00EB040100EE03F700E4040400F1
040D00FA041F010C042801150422010F042B0118042E011B045F014C0449013604680154046E015A04740160047D0169
0480016C048A017604870173048D01790490017C0493017F049F018B04A5019104AE019A04AB019704CD01B904D501C1
04DC01C804E001CC05290215052C02180532021E053E022A0541022D0548023405550241055F024B054E023A055B0247
0562024E056C02580575025E0581026A057E026705DD02C605E602CF05E302CC059002790597028005E902D205EC02D5
05EF02D805F202DB05FB02E405F802E1060102E7060402EA060702ED061902FF062B030E063403170637031A056F0431
062205FE0659000000000000000000000372005F035F004C032C001903280015033400210330001D0375006203450032
0341002E034D003A034900360379006603ED00DA03E100CE03CA00B703BE00AB03BA00A703C600B303C200AF03F000DD
044D013A04590146051B020704F501E104BE01AA04BA01A604C601B204C201AE051E020A050B01F7050701F3051301FF
050F01FB0517020305DA02C305B1029A05CA02B305C602AF05D202BB05CE02B705D602BF060A02F006250308061F0305
061302F9000000000000000000000000081807F6081B07F908240802082D080B069B0679069E067C06A7068506B0068E
0855084A0858084D085C08510000000006D106C606D406C906D806CD000000000890086E08930871089C087A08A50883
070406E2070706E5071006EE071906F708E808D908EB08DC08EF08E008F308E407470738074A073B074E073F07520743
090B0900090E090309120907000000000767075C076A075F076E076300000000094609370949093A094D093E09510942
0784000007870000078B0000078F000009880966098B096909940972099D097B07BD079B07C0079E07C907A707D207B0
07E907E2084708440867086008C108BE08FD08FA091F091C095F09580000000008360814081F07FD082808060831080F
06B9069706A2068006AB068906B4069208AE088C0897087508A0087E08A9088707220700070B06E9071406F2071D06FB
09A60984098F096D0998097609A1097F07DB07B907C407A207CD07AB07D607B407F007F3084107E5000007EC083D083A
067306760670066D000006BD000008BC0640000008B908630000086A08B508B206C306C006DF06DC0BB307260BB90BB6
08C408C708D108CD0000000008D508F7072F0732072C07290BBC00000BC20BBF09220925092F092B0919091609330955
077B077E07780775063A0772031D063D0000000009B1095B0000096209AD09AA0759075607980795064307DF00000000
0BC70BC50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000079300000000004F01520000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000BCC0BC90000000000000000
000000000000000000000000000000000000000//Written in the D programming language
/**
 * License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * Authors: Dmitry Olshansky
 *
 */
// !!! DO NOT EDIT !!!
// !!! Did you even read the comment? !!!
// This module is automatically generated from Unicode Character Database files
// https://github.com/dlang/phobos/blob/master/tools/unicode_table_generator.d
//dfmt off
module std.internal.unicode_grapheme;
import std.internal.unicode_tables;

package(std):


static if (size_t.sizeof == 4)
{
//832 bytes
enum hangulLVTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000004000000080",
cast(immutable size_t[]) x"
000001000000008000000A00",
cast(immutable size_t[]) x"
000000000002010000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000020001000400030006000500010007000300020005000400070006000200010004000300060005
000100070003000200050004000700060002000100040003000600050001000700030002000500040007000600080001
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000001000000101000000001000000001000000001000000001000000001010000001
010000000010000000010000000010000000010000000010100000010100000000100000000100000000100000000100
000000101000000101000000001000000001000000001000000001000000001010000001010000000010000000010000
000010000000010000000010100000010100000000100000000100000000100000000100000000101000000101000000
001000000001000000001000000001000000001010000001010000000010000000010000000010000000010000000010
010000000010000000010000000010000000010000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
//832 bytes
enum hangulLVTTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000004000000080",
cast(immutable size_t[]) x"
000001000000008000000A00",
cast(immutable size_t[]) x"
000000000002010000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000020001000400030006000500010007000300020005000400070006000200010004000300060005
000100070003000200050004000700060002000100040003000600050001000700030002000500040007000600080001
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000EFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFE
FEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFF
FFFFFFEFEFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFF
FFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFEFEFFFFFF
FFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFEFFFFFFEFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEF
FEFFFFFFFFEFFFFFFFFEFFFFFFFFEFFFFFFFFEFF0000000F000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
//896 bytes
enum prependTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000004000000080",
cast(immutable size_t[]) x"
000001000000008000000C00",
cast(immutable size_t[]) x"
010101000101010101010102010101010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000002000100000003000000000004000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000060005000000000000000000000000
000700000000000800090000000A00000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000003F00000000000000000000000000000000000000002000000000000000
000080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000300000000000000000000000000040000000000000000000040000000000000000000000000000000000000000000
000000000000000000000000000000000000000020000000000020000000000000000000000000000000000000000000
00000000000000000000000C000000000000000080000000000000020000000000000000000000000000000000000000
00000000040000000000000000000000000003F000000000000000000000000000000000000000000000004000000000
000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000",
);
//1280 bytes
enum controlTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
0000000000000040000000D0",
cast(immutable size_t[]) x"
000001000000012000000E00",
cast(immutable size_t[]) x"
020201000302020202020402020605020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020702020202020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000001000000010001000100010001000200010001000100010001000100010001
000100010001000100010001000100010001000300010001000100010001000100010004000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010006000500010001000100010001000100010001
000100010001000100010001000100010001000100010001000100070001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010008000100010001000100010001000100010001000100010001000100010001000100010001
0009000100010001000100010001000100010001000100010001000100010001000B000A000C000C000C000C000C000C
000C000C000C000C000C000C000C000C0001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
00010001000100010001000100010001FFFFDBFF000000000000000080000000FFFFFFFF000020000000000000000000
000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000
000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000
0000C80000007F00000000000000FFFF0000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000080000000000000000000000000000000000000000000000000000000000000000FFF0000
00000000FFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000F000000000000000000000000000000000000000007F8000000000000000000000000000000000000
FFFFFFFF000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000
000000000000000000000000FFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0000000000000000000000000000000000000000000000000000000000000000",
);
//1856 bytes
enum spacingMarkTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
0000000000000040000000B0",
cast(immutable size_t[]) x"
00000100000000E000002400",
cast(immutable size_t[]) x"
010101000101020104010103010501010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000010000000300020005000400070006
00000008000000000000000000090000000A0000000C000B0000000D0000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000F000E00110010000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00130012001500140017001600190018001B001A0000001C001E001D0020001F00000000000000000000000000000000
000000000000000000000000002100000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000008C80000000000DE01000000000000000C800000000000198100000000
00000008C0000000000000010000000000000008C000000000001A01000000000000000C000000000000198100000000
000000008000000000001DC6000000000000000E000000000000001E000000000000000C4000000000000D9B00080000
0000000C8000000000001DC1000000000000000C000000007F030000000C000000000000000800000000000000000000
0000000000080000000000000000000000000000C0000000000000008000000000000000000000000000000000000000
000000001802000000C00000000000000000001000000000000000000000000000200000001000000000000000000000
00000000C0400000000001BF000000000000000001FB0E78000000000000000000000000000000000000000000000000
060000000000000000A000000007E0000000000000000000000000000000000000000010E80000000000001B00000000
00000004000004C200000000000C5C800000000000300FF0000000000000000000000000000000000000000000800002
0000000000000098000000000000000000000003FFF000000000000F000000000000000000000000000C000000000000
00000008CC3000000000000100000000000000000019800000002000000000000000000000000000000000000020C800
00000000000000000000000000000000000000000000000000000000000016D800000005000000000000000000000000
000000040187000000000000000000000000000000001000000000600000000000000004803800000000400100000000
00000000002C70000000000000000000000000000000000000000000000000070000000C800000000000399E0000000C
000000000000000000000000000000000000000000E000000000002300000000000000005A0600000000000200000000
00000000000000000000000000000000000000004F030000000000000000000000000000580700000000000000000000
000000000040D00000000000000000000000000000000040000000000000000000000000000000000000000000000000
00000000010070000000000000000000000000000000000000000000000000000000000021BE00000000000500000000
0000000000000000F00E0000000000100000000002000000018000000000000000800000000000000000000000000000
000000004000800000000000000000000000000000120200000000000000000000000000000000000000000000000000
00587C000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000
00000008C03000000000000200000000000000000000000000000000000000000000000000000000FFFE0000FFFFFFFF
000000FF0000000000000000000300000000000000000000000000000000204000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000",
);
//3488 bytes
enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000004000000110",
cast(immutable size_t[]) x"
00000100000001A000004B00",
cast(immutable size_t[]) x"
0202010004020302070206050A0908020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020B02020202020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000001000000030002000500040007000600090008000B000A000D000C
0000000E000F000000000000001000000012001100140013001600150000000000000017000000000000000000000000
000000000000000000190018000000000000001A00000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000001B001D001C001F001E0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000220021
0023000000250024000000000000000000000000000000260027000000290028002B002A002D002C002F002E00310030
003300320000003400360035003800370000000000000000000000000000000000000000000000000000000000000000
000000000000000000000039000000000000000000000000000000000000000000000000000000000000000000000000
00000000003B003A00000000003C00000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000003D0000000000000000000000000000000000000000000000000000000000000000003E0000
003F000000000040000000000000000000000000000000410000000000000000003B0042000000430000004400000000
004600450000000000000000000000000000000000470000000000000000000000000000000000000000000000000000
004900480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000FFFF00000000000000000000000000000000
00000000000000000000000000000000000003F800000000000000000000000000000000000000000000000000000000
FFFE0000BFFFFFFF000000B60000000007FF000000000000FFFFF8000001000000000000000000009FC0000000003D9F
00020000FFFF0000000007FF00000000000000000001FFC000000000200FF800FBC0000000003EEF0E00000000000000
FF00000000000000FFFFFC00FFFFFFFB000000071400000000FE21FE0000000C00000002500000000080201E4000000C
000000061000000000023986002300000000000610000000000021BEFC00000C00000002D000000000E0201E0000000C
0000000440000000008020010000000000000011D000000000603DC10000000C0000000290000000006030440000000C
00000003580000000080201E0000000C0000000200000000805C8400000000000000000007F2000000007F8000000000
000000001FF2000000007F00000000000300000002A00000000000007FFE0000FEFFE0DF1FFFFFFF0000004000000000
0000000066FDE000C3000000001E0001200020640000000000000000000000000000000000000000E000000000000000
00000000000000000000000000000000001C0000000C0000000C0000000C0000000000003FB00000200FFE4000000000
0000B80000000000000000000000000000000060000002000000000000000000000000000E0401870000000000000000
0000000000000000000000000000000009800000000000007F4000009FF81FE500000000FFFF000000007FFF00000000
0000000F17F0000000000004000FF8000000000300003B3C000000000003A3400000000000CFF0000000000000000000
0000000000000000FFF70000031021FD000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF
000010000000000000000000000000000000000000000000FFFF00000001FFFF00000000000000000000000000000000
0000000000000000000000000003800000000000000000000000000080000000000000000000000000000000FFFFFFFF
000000000000FC000000000000000000060000000000000000000000000000000000000000000000000000003FF78000
C0000000000000000000000000030000000008440000106000000000000000000000000000000000000000308003FFFF
0000000000003FC00003FF80000000000000000733C8000000000000000000200000000000667E000000100810000000
00000000C19D000000000002004030000000000000000000000000000000000000000000000000000000000000002120
40000000000000000000000000000000000000000000000000000000000000000000FFFF0000FFFF0000000000000000
0000000000000000000000000000000000000000000000000000000000000000C0000000000000000000000000000000
000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000
0000000000000000000000000000000100000000000000000000000007C0000000000000000000000000000000000000
0000F06E8700000000000000000000000000000000000000000000000000006000000000000000F00000000000000000
0000000000000000000000000000000000000000000000000000000000000000000000000000180000000000E0000000
00000000000000000001FFC0000000000000003C00000000000000000000000000000002FF0000000000007F80190000
0000000306780000000000040000000000000007001FEF800000000000080000000000037FC0000000009E0000000000
0000000040D380000000000200000000000000000000000080000000000007F8000000035800000000800001001F1FC0
0000000000000000000000000000000000000000FF0000004000005C0000000000000000A5F900000000000D00000000
0000000000000000000000000000000000000000B03C8000300000010000000000000000A7F800000000000100000000
0000000000BF28000000000000000000E000000000000FBC000000000000000000000000000000000000000000000000
0000000006FF800000000000000000000000000000000000000000000000000000000000580100000000000800000000
00000000000000000CF0000000000001000007FE79F800000E7E008000000000037FFC00000000000000000000000000
00000000BF7F00000000000000000000FFFC0000006DFCFF000000000000000000000000B47E0000000000BF00000000
00A300000000000000000000000000000000000000000000000000000000000000000000000000000000000000180000
0000000307C000000000000500000000000000000000000000000000000000000000000000000000003FFF8100000000
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001F0000
00000000007F000000000000000000000000000000000000000000000000000000000000000000000000800000000000
000780000000000000000000000000100000000000000000000000000000000060000000000000000000000000000000
FFFFFFFFFFFF3FFF0000007F0000000000000000000000000000000000000000000000000000000000000000F807C3A0
00000FE700003C00000000000000000000000000000000000000001C0000000000000000000000000000000000000000
FFFFFFFFF87FFFFFFFFFFFFF00201FFFF80000100000FFFE0000000000000000F9FFFF7F000007DB0000000000000000
00008000000000000000000000000000000000000000000000000000000000000000000000004000000000000000F000
000000000000000000000000000000000000000000000000000000000000F00000000000000000000000000000000000
0000000000000000007F0000000000000000000000000000000007F00000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000F800000000000000FFFFFFFFFFFFFFFFFFFFFFFF
00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF
0000000000000000000000000000000000000000000000000000000000000000",
);
//1344 bytes
enum Extended_PictographicTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000004000000090",
cast(immutable size_t[]) x"
00000100000000A000001800",
cast(immutable size_t[]) x"
020201000202020202020202030202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000001000000010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100030002000400010006000500080007
00090001000A000100010001000100010001000B0001000C000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000E000D0010000F0011000D00130012001500140001000D000D000D0016000D00010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000010000000000002000000000000000000000000000000000000000000
0000000002000004000000000000000003F000000000060000000000000000000C000000000001000000000000000000
000001000000000000008000070FFE000000000000000000000000000000000000000000000000000000000400000000
000000000000000000000000000000000000000000400C000000000178000000FFF7FFBFFFFFFFFFFFFFFFFFFFFFFFFF
FFFF003FFFFFFFFFFFFFFFFFFFFFFFFF2057FF3F0018010200B85090000000F800E00000800100020000000000000000
0000000000300000000000000000000000000000000000000000000000000000180000E0000000000021000000000000
000000000000000000000000000000000000000020010000000000000000000000000000000000000000000000000000
0000000000000000000000000000000002800000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000E0000000800000000000C003F00007FE4000FFFFE000FFFFFFFF0000003F
0400FFFEF7FC8000FFFFFE00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF07FFFFFFFFFFFFFF3FFFFFFFFFFFFFC0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF0000FFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000FFF00000
0000000000000000FFE00000FFFFFFFF0000F00000000000FC00FF00000000000000FF00FFFFC000FFFFFFFFFFFFFFFF
FFFFF000F7FFFFFFFFFFFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFF3FFFFFFF0000000000000000000000000000000000000000000000000000000000000000",
);

}


static if (size_t.sizeof == 8)
{
//832 bytes
enum hangulLVTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000040",
cast(immutable size_t[]) x"
000000000000010000000000000000800000000000000A00",
cast(immutable size_t[]) x"
000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000040003000200010001000700060005000500040003000200020001000700060006000500040003
000300020001000700070006000500040004000300020001000100070006000500050004000300020008000100070006
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000100000010000001000100000010000000000100000010001000000100000010
001000000100000000001000000100000000001000000100010000001000000100010000001000000000010000001000
100000010000001000100000010000000000100000010000000000100000010001000000100000010001000000100000
000001000000100010000001000000100010000001000000000010000001000000000010000001000100000010000001
000100000010000000000100000010001000000100000010001000000100000000001000000100000000001000000100
001000000100000000001000000100000000000000000100000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
//832 bytes
enum hangulLVTTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000040",
cast(immutable size_t[]) x"
000000000000010000000000000000800000000000000A00",
cast(immutable size_t[]) x"
000201000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000040003000200010001000700060005000500040003000200020001000700060006000500040003
000300020001000700070006000500040004000300020001000100070006000500050004000300020008000100070006
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000FEFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFEF
FFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFF
EFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFEFFFEFFFFFFEFFFFF
FFFFFEFFFFFFEFFFEFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFE
FFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFEFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFFFFFFFFEFFFFFFEFF
FFEFFFFFFEFFFFFFFFFFEFFFFFFEFFFF0000000FFFFFFEFF000000000000000000000000000000000000000000000000
00000000000000000000000000000000",
);
//896 bytes
enum prependTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000040",
cast(immutable size_t[]) x"
000000000000010000000000000000800000000000000C00",
cast(immutable size_t[]) x"
010101010101010001010101010101020101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000200010000000000000000000000030000000000040000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000600050000000000000000
0000000800070000000A0000000900000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000003F000000000000000000000000000000000000000020000000
000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000003000000000004000000000000000000000000000000000000400000000000000000000000000000000000
000000000000000000000000000000002000000000000000000000000000200000000000000000000000000000000000
0000000000000000000000000000000C8000000000000000000000000000000200000000000000000000000000000000
0400000000000000000000000000000000000000000003F0000000000000000000000000000000000000000000000040
000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000",
);
//1280 bytes
enum controlTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000068",
cast(immutable size_t[]) x"
000000000000010000000000000001200000000000000E00",
cast(immutable size_t[]) x"
030202020202010002060502020204020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020207020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000001000100010000000100020001000100010001000100010001000100010001
000100010001000100010001000100010001000100010003000100010001000100010001000100040001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000600050001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000700010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100080001000100010001000100010001000100010001000100010001000100010001
0001000100090001000100010001000100010001000100010001000100010001000C000C000B000A000C000C000C000C
000C000C000C000C000C000C000C000C0001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
0001000100010001000100010001000100000000FFFFDBFF800000000000000000002000FFFFFFFF0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000
000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000
00007F000000C8000000FFFF000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000080000000000000000000000000000000000000000000000000000000000000000FFF000000000000
FFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000F000000000000000000000000000000000000000007F800000000000000000000000000000000000000000000
00000000FFFFFFFF0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000
0000000000000000FFFF000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
0000000000000000000000000000000000000000000000000000000000000000",
);
//1856 bytes
enum spacingMarkTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000058",
cast(immutable size_t[]) x"
000000000000010000000000000000E00000000000002400",
cast(immutable size_t[]) x"
010102010101010001050101040101030101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101
010101010101010101010101010101010101010101010101010101010101010101010101010101010000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000030002000100000007000600050004
00000000000000080009000000000000000C000B000A0000000000000000000D00000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000110010000F000E000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
001500140013001200190018001700160000001C001B001A0020001F001E001D00000000000000000000000000000000
000000000000000000210000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000002200000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000C800000000000008000000000000DE01800000000000000C0000000000001981
C0000000000000080000000000000001C0000000000000080000000000001A01000000000000000C0000000000001981
80000000000000000000000000001DC6000000000000000E000000000000001E400000000000000C0008000000000D9B
800000000000000C0000000000001DC1000000000000000C000C00007F03000000080000000000000000000000000000
00080000000000000000000000000000C000000000000000800000000000000000000000000000000000000000000000
18020000000000000000000000C000000000000000000010000000000000000000100000002000000000000000000000
C04000000000000000000000000001BF01FB0E7800000000000000000000000000000000000000000000000000000000
00000000060000000007E00000A0000000000000000000000000000000000000E800000000000010000000000000001B
000004C200000004000C5C800000000000300FF000000000000000000000000000000000000000000080000200000000
00000098000000000000000000000000FFF0000000000003000000000000000F000000000000000000000000000C0000
CC3000000000000800000000000000010019800000000000000000000000200000000000000000000020C80000000000
000000000000000000000000000000000000000000000000000016D80000000000000000000000050000000000000000
018700000000000400000000000000000000100000000000000000000000006080380000000000040000000000004001
002C700000000000000000000000000000000000000000000000000700000000800000000000000C0000000C0000399E
0000000000000000000000000000000000E000000000000000000000000000235A060000000000000000000000000002
000000000000000000000000000000004F03000000000000000000000000000058070000000000000000000000000000
0040D0000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000
010070000000000000000000000000000000000000000000000000000000000021BE0000000000000000000000000005
000000000000000000000010F00E00000200000000000000000000000180000000000000008000000000000000000000
400080000000000000000000000000000012020000000000000000000000000000000000000000000000000000000000
0000000000587C0000000000000000000000000000000000000000000000000000000000000000000060000000000000
C0300000000000080000000000000002000000000000000000000000000000000000000000000000FFFFFFFFFFFE0000
00000000000000FF00030000000000000000000000000000000020400000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000",
);
//3488 bytes
enum graphemeExtendTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000088",
cast(immutable size_t[]) x"
000000000000010000000000000001A00000000000004B00",
cast(immutable size_t[]) x"
04020302020201000A090802070206050202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
02020202020202020202020202020202020202020202020B020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000100000000000000050004000300020009000800070006000D000C000B000A
000F00000000000E00100000000000000014001300120011000000000016001500000000000000170000000000000000
00000000000000000000000000190018000000000000001A000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000001B00000000001F001E001D001C0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000200000000000000022002100000000
0025002400230000000000000000000000000026000000000029002800270000002D002C002B002A00310030002F002E
000000340033003200380037003600350000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000390000000000000000000000000000000000000000000000000000000000000000
003B003A00000000003C0000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000003D000000000000000000000000000000000000000000000000003E000000000000
00000040003F000000000000000000000000004100000000000000000000000000000043003B00420000000000000044
000000000046004500000000000000000047000000000000000000000000000000000000000000000000000000000000
000000000049004800000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000FFFFFFFFFFFFFFFF0000FFFFFFFFFFFF00000000000000000000000000000000
0000000000000000000000000000000000000000000003F8000000000000000000000000000000000000000000000000
BFFFFFFFFFFE000000000000000000B60000000007FF000000010000FFFFF800000000000000000000003D9F9FC00000
FFFF00000002000000000000000007FF0001FFC000000000200FF8000000000000003EEFFBC00000000000000E000000
00000000FF000000FFFFFFFBFFFFFC0014000000000000070000000C00FE21FE50000000000000024000000C0080201E
100000000000000600230000000239861000000000000006FC00000C000021BED0000000000000020000000C00E0201E
40000000000000040000000000802001D0000000000000110000000C00603DC190000000000000020000000C00603044
58000000000000030000000C0080201E000000000000000200000000805C840007F20000000000000000000000007F80
1FF20000000000000000000000007F0002A00000030000007FFE0000000000001FFFFFFFFEFFE0DF0000000000000040
66FDE00000000000001E0001C300000000000000200020640000000000000000000000000000000000000000E0000000
00000000000000000000000000000000000C0000001C0000000C0000000C00003FB000000000000000000000200FFE40
000000000000B8000000000000000000000002000000006000000000000000000E040187000000000000000000000000
0000000000000000000000000000000000000000098000009FF81FE57F400000FFFF0000000000000000000000007FFF
17F000000000000F000FF8000000000400003B3C000000030003A3400000000000CFF000000000000000000000000000
0000000000000000031021FDFFF70000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF
0000000000001000000000000000000000000000000000000001FFFFFFFF000000000000000000000000000000000000
00000000000000000003800000000000000000000000000080000000000000000000000000000000FFFFFFFF00000000
0000FC000000000000000000000000000000000006000000000000000000000000000000000000003FF7800000000000
00000000C000000000030000000000000000106000000844000000000000000000000000000000008003FFFF00000030
00003FC000000000000000000003FF8033C8000000000007000000200000000000667E00000000001000000000001008
C19D00000000000000403000000000020000000000000000000000000000000000000000000000000000212000000000
00000000400000000000000000000000000000000000000000000000000000000000FFFF0000FFFF0000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000C00000000000000000000000
000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000
00000000000000000000000100000000000000000000000007C000000000000000000000000000000000000000000000
870000000000F06E000000000000000000000000000000000000006000000000000000F0000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000180000000000E000000000000000
0000000000000000000000000001FFC0000000000000003C0000000000000000FF00000000000002801900000000007F
06780000000000030000000000000004001FEF800000000700080000000000007FC00000000000030000000000009E00
40D380000000000000000000000000020000000000000000000007F8800000005800000000000003001F1FC000800001
00000000000000000000000000000000FF00000000000000000000004000005CA5F9000000000000000000000000000D
00000000000000000000000000000000B03C8000000000000000000030000001A7F80000000000000000000000000001
00BF280000000000000000000000000000000FBCE0000000000000000000000000000000000000000000000000000000
06FF80000000000000000000000000000000000000000000000000000000000058010000000000000000000000000008
0000000000000000000000010CF0000079F80000000007FE000000000E7E008000000000037FFC000000000000000000
BF7F0000000000000000000000000000006DFCFFFFFC00000000000000000000B47E00000000000000000000000000BF
0000000000A3000000000000000000000000000000000000000000000000000000000000000000000018000000000000
07C0000000000003000000000000000500000000000000000000000000000000000000000000000000000000003FFF81
00000000000000000000000000000000000000000000000000000000000000000000000000000000001F000000000000
007F00000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000
000000000007800000000010000000000000000000000000000000000000000000000000600000000000000000000000
FFFF3FFFFFFFFFFF000000000000007F000000000000000000000000000000000000000000000000F807C3A000000000
00003C0000000FE700000000000000000000000000000000000000000000001C00000000000000000000000000000000
F87FFFFFFFFFFFFF00201FFFFFFFFFFF0000FFFEF80000100000000000000000000007DBF9FFFF7F0000000000000000
000000000000800000000000000000000000000000000000000000000000000000004000000000000000F00000000000
0000000000000000000000000000000000000000000000000000F0000000000000000000000000000000000000000000
000000000000000000000000007F0000000000000000000000000000000007F000000000000000000000000000000000
000000000000000000000000000000000000000000000000F800000000000000FFFFFFFF00000000FFFFFFFFFFFFFFFF
00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFF
0000000000000000000000000000000000000000000000000000000000000000",
);
//1344 bytes
enum Extended_PictographicTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
000000000000000000000000000000200000000000000048",
cast(immutable size_t[]) x"
000000000000010000000000000000A00000000000001800",
cast(immutable size_t[]) x"
020202020202010003020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000001000100010000000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100040001000300020008000700060005
000A00010009000100010001000100010001000C0001000B000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
0010000F000E000D001300120011000D0001000D001500140016000D000D000D00010001000100010001000100010001
000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100010001
000000000000000000000000000000000000420000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000001000000000000000000000000000020000000000000000000000000000000000
020000040000000000000000000000000000060003F000000000000000000000000001000C0000000000000000000000
0000000000000100070FFE00000080000000000000000000000000000000000000000000000000000000000000000004
0000000000000000000000000000000000400C00000000007800000000000001FFFFFFFFFFF7FFBFFFFFFFFFFFFFFFFF
FFFFFFFFFFFF003FFFFFFFFFFFFFFFFF001801022057FF3F000000F800B850908001000200E000000000000000000000
003000000000000000000000000000000000000000000000000000000000000000000000180000E00000000000210000
000000000000000000000000000000002001000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000028000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000080000000E000C003F00000000000FFFFE00007FE40000000003FFFFFFFFF
F7FC80000400FFFEFFFFFFFFFFFFFE00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF07FFFFFFFFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFC0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000FFF0000000000000
0000000000000000FFFFFFFFFFE00000000000000000F00000000000FC00FF00FFFFC0000000FF00FFFFFFFFFFFFFFFF
F7FFFFFFFFFFF000FFFFFFFFFFFFFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
FFFFFFFFFFFFFFFF3FFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000",
);

}

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            //Written in the D programming language
/**
 * License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).
 *
 * Authors: Dmitry Olshansky
 *
 */
// !!! DO NOT EDIT !!!
// !!! Did you even read the comment? !!!
// This module is automatically generated from Unicode Character Database files
// https://github.com/dlang/phobos/blob/master/tools/unicode_table_generator.d
//dfmt off
module std.internal.unicode_norm;
import std.internal.unicode_tables;

package(std):


static if (size_t.sizeof == 4)
{
//1728 bytes
enum nfcQCTrieEntries = TrieEntry!(bool, 8, 5, 8)(cast(immutable size_t[]) x"
0000000000000040000000C0",
cast(immutable size_t[]) x"
000001000000010000001E00",
cast(immutable size_t[]) x"
020201000302020202020204020502020202020206020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202020202
020202020202020202020202020202020202020202020202020202020202020202020202020202020000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000010000000000000000000200030000000500040007000600080000
000A000900000000000000000000000000000000000B000000000000000C0000000E000D000F00000000000000000000
000000000000001000000000000000000000001100000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000000000000000000000012000000140013000000000000000000000000000000000000000000000000
0000000000000000000000000000000000160015001700000019001800000000001A0000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000001B0000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000001200120000001C000000000000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000081A9FDF010361F80000003F40100000
000000800000000000000000000000000000000000000000003800000000000000000000000000000000000000000000
0000000010000000FF000000000000000000000040000000B08000000000000000000000004800004E00000000000000
00000000000000000000000000000000000000004000000030C000000000000000000000400000000080000000000000
000000000000000000400000000000000000000000000000006000040000000000000000400000000080000000000000
000000000000000080008400000000000000000000000000108420080168020020080002020010840000000000000000
0000000000004000000000000000000000000000000000000000000000000000000000000000000000000000003FFFFE
00000000FFFFFF0000000007000000000000000000200000000000000000000000000000000000000000000000000000
0000000000000000000000002AAA0000000000004800000008080A002A00C80800000003000000000000000000000000
000000000000000000000000000000000000000000000C40000000000000000000000000000000000000000000000000
000000000000060000000000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000000010000000000000000000000000000000000000000000000006000000000000000000000000000000
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FE53FFFFFFFFC65FFFFFFFFFFFF3FFF
FFFFFFFFFFFFFFFF03FFFFFF00000000A00000005F7FFC0000007FDB0000000000000000000000000000000000000000
000000000000000000000000000000000000000004000000000000000000000000000000000000800000000000000000
000000000000000000000000000000000000000040000000008000000000000000000000000000000000000000000000
000000000000000000000000000000000000000024010000000000000000000000000000000000000000000000000000
000000000000800000000000000000000000000000010000000000000000000000000000000000000000000000000000
0000000000000000C00000000000001F00000000F800000000000001000000003FFFFFFF000000000000000000000