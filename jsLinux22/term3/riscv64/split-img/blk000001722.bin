ddr.phys_addr);
		break;
	}
	msg->reply = reply ? CEC_MSG_RECORD_STATUS : 0;
}

static __inline__ void cec_ops_record_on(const struct cec_msg *msg,
				     struct cec_op_record_src *rec_src)
{
	rec_src->type = msg->msg[2];
	switch (rec_src->type) {
	case CEC_OP_RECORD_SRC_OWN:
		break;
	case CEC_OP_RECORD_SRC_DIGITAL:
		cec_get_digital_service_id(msg->msg + 3, &rec_src->digital);
		break;
	case CEC_OP_RECORD_SRC_ANALOG:
		rec_src->analog.ana_bcast_type = msg->msg[3];
		rec_src->analog.ana_freq =
			(msg->msg[4] << 8) | msg->msg[5];
		rec_src->analog.bcast_system = msg->msg[6];
		break;
	case CEC_OP_RECORD_SRC_EXT_PLUG:
		rec_src->ext_plug.plug = msg->msg[3];
		break;
	case CEC_OP_RECORD_SRC_EXT_PHYS_ADDR:
		rec_src->ext_phys_addr.phys_addr =
			(msg->msg[3] << 8) | msg->msg[4];
		break;
	}
}

static __inline__ void cec_msg_record_status(struct cec_msg *msg, __u8 rec_status)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_RECORD_STATUS;
	msg->msg[2] = rec_status;
}

static __inline__ void cec_ops_record_status(const struct cec_msg *msg,
					 __u8 *rec_status)
{
	*rec_status = msg->msg[2];
}

static __inline__ void cec_msg_record_tv_screen(struct cec_msg *msg,
					    int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_RECORD_TV_SCREEN;
	msg->reply = reply ? CEC_MSG_RECORD_ON : 0;
}


/* Timer Programming Feature */
static __inline__ void cec_msg_timer_status(struct cec_msg *msg,
					__u8 timer_overlap_warning,
					__u8 media_info,
					__u8 prog_info,
					__u8 prog_error,
					__u8 duration_hr,
					__u8 duration_min)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_TIMER_STATUS;
	msg->msg[2] = (timer_overlap_warning << 7) |
		(media_info << 5) |
		(prog_info ? 0x10 : 0) |
		(prog_info ? prog_info : prog_error);
	if (prog_info == CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE ||
	    prog_info == CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE ||
	    prog_error == CEC_OP_PROG_ERROR_DUPLICATE) {
		msg->len += 2;
		msg->msg[3] = ((duration_hr / 10) << 4) | (duration_hr % 10);
		msg->msg[4] = ((duration_min / 10) << 4) | (duration_min % 10);
	}
}

static __inline__ void cec_ops_timer_status(const struct cec_msg *msg,
					__u8 *timer_overlap_warning,
					__u8 *media_info,
					__u8 *prog_info,
					__u8 *prog_error,
					__u8 *duration_hr,
					__u8 *duration_min)
{
	*timer_overlap_warning = msg->msg[2] >> 7;
	*media_info = (msg->msg[2] >> 5) & 3;
	if (msg->msg[2] & 0x10) {
		*prog_info = msg->msg[2] & 0xf;
		*prog_error = 0;
	} else {
		*prog_info = 0;
		*prog_error = msg->msg[2] & 0xf;
	}
	if (*prog_info == CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE ||
	    *prog_info == CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE ||
	    *prog_error == CEC_OP_PROG_ERROR_DUPLICATE) {
		*duration_hr = (msg->msg[3] >> 4) * 10 + (msg->msg[3] & 0xf);
		*duration_min = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	} else {
		*duration_hr = *duration_min = 0;
	}
}

static __inline__ void cec_msg_timer_cleared_status(struct cec_msg *msg,
						__u8 timer_cleared_status)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_TIMER_CLEARED_STATUS;
	msg->msg[2] = timer_cleared_status;
}

static __inline__ void cec_ops_timer_cleared_status(const struct cec_msg *msg,
						__u8 *timer_cleared_status)
{
	*timer_cleared_status = msg->msg[2];
}

static __inline__ void cec_msg_clear_analogue_timer(struct cec_msg *msg,
						int reply,
						__u8 day,
						__u8 month,
						__u8 start_hr,
						__u8 start_min,
						__u8 duration_hr,
						__u8 duration_min,
						__u8 recording_seq,
						__u8 ana_bcast_type,
						__u16 ana_freq,
						__u8 bcast_system)
{
	msg->len = 13;
	msg->msg[1] = CEC_MSG_CLEAR_ANALOGUE_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	msg->msg[9] = ana_bcast_type;
	msg->msg[10] = ana_freq >> 8;
	msg->msg[11] = ana_freq & 0xff;
	msg->msg[12] = bcast_system;
	msg->reply = reply ? CEC_MSG_TIMER_CLEARED_STATUS : 0;
}

static __inline__ void cec_ops_clear_analogue_timer(const struct cec_msg *msg,
						__u8 *day,
						__u8 *month,
						__u8 *start_hr,
						__u8 *start_min,
						__u8 *duration_hr,
						__u8 *duration_min,
						__u8 *recording_seq,
						__u8 *ana_bcast_type,
						__u16 *ana_freq,
						__u8 *bcast_system)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	*ana_bcast_type = msg->msg[9];
	*ana_freq = (msg->msg[10] << 8) | msg->msg[11];
	*bcast_system = msg->msg[12];
}

static __inline__ void cec_msg_clear_digital_timer(struct cec_msg *msg,
				int reply,
				__u8 day,
				__u8 month,
				__u8 start_hr,
				__u8 start_min,
				__u8 duration_hr,
				__u8 duration_min,
				__u8 recording_seq,
				const struct cec_op_digital_service_id *digital)
{
	msg->len = 16;
	msg->reply = reply ? CEC_MSG_TIMER_CLEARED_STATUS : 0;
	msg->msg[1] = CEC_MSG_CLEAR_DIGITAL_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	cec_set_digital_service_id(msg->msg + 9, digital);
}

static __inline__ void cec_ops_clear_digital_timer(const struct cec_msg *msg,
				__u8 *day,
				__u8 *month,
				__u8 *start_hr,
				__u8 *start_min,
				__u8 *duration_hr,
				__u8 *duration_min,
				__u8 *recording_seq,
				struct cec_op_digital_service_id *digital)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	cec_get_digital_service_id(msg->msg + 9, digital);
}

static __inline__ void cec_msg_clear_ext_timer(struct cec_msg *msg,
					   int reply,
					   __u8 day,
					   __u8 month,
					   __u8 start_hr,
					   __u8 start_min,
					   __u8 duration_hr,
					   __u8 duration_min,
					   __u8 recording_seq,
					   __u8 ext_src_spec,
					   __u8 plug,
					   __u16 phys_addr)
{
	msg->len = 13;
	msg->msg[1] = CEC_MSG_CLEAR_EXT_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	msg->msg[9] = ext_src_spec;
	msg->msg[10] = plug;
	msg->msg[11] = phys_addr >> 8;
	msg->msg[12] = phys_addr & 0xff;
	msg->reply = reply ? CEC_MSG_TIMER_CLEARED_STATUS : 0;
}

static __inline__ void cec_ops_clear_ext_timer(const struct cec_msg *msg,
					   __u8 *day,
					   __u8 *month,
					   __u8 *start_hr,
					   __u8 *start_min,
					   __u8 *duration_hr,
					   __u8 *duration_min,
					   __u8 *recording_seq,
					   __u8 *ext_src_spec,
					   __u8 *plug,
					   __u16 *phys_addr)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	*ext_src_spec = msg->msg[9];
	*plug = msg->msg[10];
	*phys_addr = (msg->msg[11] << 8) | msg->msg[12];
}

static __inline__ void cec_msg_set_analogue_timer(struct cec_msg *msg,
					      int reply,
					      __u8 day,
					      __u8 month,
					      __u8 start_hr,
					      __u8 start_min,
					      __u8 duration_hr,
					      __u8 duration_min,
					      __u8 recording_seq,
					      __u8 ana_bcast_type,
					      __u16 ana_freq,
					      __u8 bcast_system)
{
	msg->len = 13;
	msg->msg[1] = CEC_MSG_SET_ANALOGUE_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	msg->msg[9] = ana_bcast_type;
	msg->msg[10] = ana_freq >> 8;
	msg->msg[11] = ana_freq & 0xff;
	msg->msg[12] = bcast_system;
	msg->reply = reply ? CEC_MSG_TIMER_STATUS : 0;
}

static __inline__ void cec_ops_set_analogue_timer(const struct cec_msg *msg,
					      __u8 *day,
					      __u8 *month,
					      __u8 *start_hr,
					      __u8 *start_min,
					      __u8 *duration_hr,
					      __u8 *duration_min,
					      __u8 *recording_seq,
					      __u8 *ana_bcast_type,
					      __u16 *ana_freq,
					      __u8 *bcast_system)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	*ana_bcast_type = msg->msg[9];
	*ana_freq = (msg->msg[10] << 8) | msg->msg[11];
	*bcast_system = msg->msg[12];
}

static __inline__ void cec_msg_set_digital_timer(struct cec_msg *msg,
			int reply,
			__u8 day,
			__u8 month,
			__u8 start_hr,
			__u8 start_min,
			__u8 duration_hr,
			__u8 duration_min,
			__u8 recording_seq,
			const struct cec_op_digital_service_id *digital)
{
	msg->len = 16;
	msg->reply = reply ? CEC_MSG_TIMER_STATUS : 0;
	msg->msg[1] = CEC_MSG_SET_DIGITAL_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	cec_set_digital_service_id(msg->msg + 9, digital);
}

static __inline__ void cec_ops_set_digital_timer(const struct cec_msg *msg,
			__u8 *day,
			__u8 *month,
			__u8 *start_hr,
			__u8 *start_min,
			__u8 *duration_hr,
			__u8 *duration_min,
			__u8 *recording_seq,
			struct cec_op_digital_service_id *digital)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	cec_get_digital_service_id(msg->msg + 9, digital);
}

static __inline__ void cec_msg_set_ext_timer(struct cec_msg *msg,
					 int reply,
					 __u8 day,
					 __u8 month,
					 __u8 start_hr,
					 __u8 start_min,
					 __u8 duration_hr,
					 __u8 duration_min,
					 __u8 recording_seq,
					 __u8 ext_src_spec,
					 __u8 plug,
					 __u16 phys_addr)
{
	msg->len = 13;
	msg->msg[1] = CEC_MSG_SET_EXT_TIMER;
	msg->msg[2] = day;
	msg->msg[3] = month;
	/* Hours and minutes are in BCD format */
	msg->msg[4] = ((start_hr / 10) << 4) | (start_hr % 10);
	msg->msg[5] = ((start_min / 10) << 4) | (start_min % 10);
	msg->msg[6] = ((duration_hr / 10) << 4) | (duration_hr % 10);
	msg->msg[7] = ((duration_min / 10) << 4) | (duration_min % 10);
	msg->msg[8] = recording_seq;
	msg->msg[9] = ext_src_spec;
	msg->msg[10] = plug;
	msg->msg[11] = phys_addr >> 8;
	msg->msg[12] = phys_addr & 0xff;
	msg->reply = reply ? CEC_MSG_TIMER_STATUS : 0;
}

static __inline__ void cec_ops_set_ext_timer(const struct cec_msg *msg,
					 __u8 *day,
					 __u8 *month,
					 __u8 *start_hr,
					 __u8 *start_min,
					 __u8 *duration_hr,
					 __u8 *duration_min,
					 __u8 *recording_seq,
					 __u8 *ext_src_spec,
					 __u8 *plug,
					 __u16 *phys_addr)
{
	*day = msg->msg[2];
	*month = msg->msg[3];
	/* Hours and minutes are in BCD format */
	*start_hr = (msg->msg[4] >> 4) * 10 + (msg->msg[4] & 0xf);
	*start_min = (msg->msg[5] >> 4) * 10 + (msg->msg[5] & 0xf);
	*duration_hr = (msg->msg[6] >> 4) * 10 + (msg->msg[6] & 0xf);
	*duration_min = (msg->msg[7] >> 4) * 10 + (msg->msg[7] & 0xf);
	*recording_seq = msg->msg[8];
	*ext_src_spec = msg->msg[9];
	*plug = msg->msg[10];
	*phys_addr = (msg->msg[11] << 8) | msg->msg[12];
}

static __inline__ void cec_msg_set_timer_program_title(struct cec_msg *msg,
						   const char *prog_title)
{
	unsigned int len = strlen(prog_title);

	if (len > 14)
		len = 14;
	msg->len = 2 + len;
	msg->msg[1] = CEC_MSG_SET_TIMER_PROGRAM_TITLE;
	memcpy(msg->msg + 2, prog_title, len);
}

static __inline__ void cec_ops_set_timer_program_title(const struct cec_msg *msg,
						   char *prog_title)
{
	unsigned int len = msg->len > 2 ? msg->len - 2 : 0;

	if (len > 14)
		len = 14;
	memcpy(prog_title, msg->msg + 2, len);
	prog_title[len] = '\0';
}

/* System Information Feature */
static __inline__ void cec_msg_cec_version(struct cec_msg *msg, __u8 cec_version)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_CEC_VERSION;
	msg->msg[2] = cec_version;
}

static __inline__ void cec_ops_cec_version(const struct cec_msg *msg,
				       __u8 *cec_version)
{
	*cec_version = msg->msg[2];
}

static __inline__ void cec_msg_get_cec_version(struct cec_msg *msg,
					   int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GET_CEC_VERSION;
	msg->reply = reply ? CEC_MSG_CEC_VERSION : 0;
}

static __inline__ void cec_msg_report_physical_addr(struct cec_msg *msg,
					__u16 phys_addr, __u8 prim_devtype)
{
	msg->len = 5;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_REPORT_PHYSICAL_ADDR;
	msg->msg[2] = phys_addr >> 8;
	msg->msg[3] = phys_addr & 0xff;
	msg->msg[4] = prim_devtype;
}

static __inline__ void cec_ops_report_physical_addr(const struct cec_msg *msg,
					__u16 *phys_addr, __u8 *prim_devtype)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*prim_devtype = msg->msg[4];
}

static __inline__ void cec_msg_give_physical_addr(struct cec_msg *msg,
					      int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_PHYSICAL_ADDR;
	msg->reply = reply ? CEC_MSG_REPORT_PHYSICAL_ADDR : 0;
}

static __inline__ void cec_msg_set_menu_language(struct cec_msg *msg,
					     const char *language)
{
	msg->len = 5;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_SET_MENU_LANGUAGE;
	memcpy(msg->msg + 2, language, 3);
}

static __inline__ void cec_ops_set_menu_language(const struct cec_msg *msg,
					     char *language)
{
	memcpy(language, msg->msg + 2, 3);
	language[3] = '\0';
}

static __inline__ void cec_msg_get_menu_language(struct cec_msg *msg,
					     int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GET_MENU_LANGUAGE;
	msg->reply = reply ? CEC_MSG_SET_MENU_LANGUAGE : 0;
}

/*
 * Assumes a single RC Profile byte and a single Device Features byte,
 * i.e. no extended features are supported by this helper function.
 *
 * As of CEC 2.0 no extended features are defined, should those be added
 * in the future, then this function needs to be adapted or a new function
 * should be added.
 */
static __inline__ void cec_msg_report_features(struct cec_msg *msg,
				__u8 cec_version, __u8 all_device_types,
				__u8 rc_profile, __u8 dev_features)
{
	msg->len = 6;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_REPORT_FEATURES;
	msg->msg[2] = cec_version;
	msg->msg[3] = all_device_types;
	msg->msg[4] = rc_profile;
	msg->msg[5] = dev_features;
}

static __inline__ void cec_ops_report_features(const struct cec_msg *msg,
			__u8 *cec_version, __u8 *all_device_types,
			const __u8 **rc_profile, const __u8 **dev_features)
{
	const __u8 *p = &msg->msg[4];

	*cec_version = msg->msg[2];
	*all_device_types = msg->msg[3];
	*rc_profile = p;
	*dev_features = NULL;
	while (p < &msg->msg[14] && (*p & CEC_OP_FEAT_EXT))
		p++;
	if (!(*p & CEC_OP_FEAT_EXT)) {
		*dev_features = p + 1;
		while (p < &msg->msg[15] && (*p & CEC_OP_FEAT_EXT))
			p++;
	}
	if (*p & CEC_OP_FEAT_EXT)
		*rc_profile = *dev_features = NULL;
}

static __inline__ void cec_msg_give_features(struct cec_msg *msg,
					 int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_FEATURES;
	msg->reply = reply ? CEC_MSG_REPORT_FEATURES : 0;
}

/* Deck Control Feature */
static __inline__ void cec_msg_deck_control(struct cec_msg *msg,
					__u8 deck_control_mode)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_DECK_CONTROL;
	msg->msg[2] = deck_control_mode;
}

static __inline__ void cec_ops_deck_control(const struct cec_msg *msg,
					__u8 *deck_control_mode)
{
	*deck_control_mode = msg->msg[2];
}

static __inline__ void cec_msg_deck_status(struct cec_msg *msg,
				       __u8 deck_info)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_DECK_STATUS;
	msg->msg[2] = deck_info;
}

static __inline__ void cec_ops_deck_status(const struct cec_msg *msg,
				       __u8 *deck_info)
{
	*deck_info = msg->msg[2];
}

static __inline__ void cec_msg_give_deck_status(struct cec_msg *msg,
					    int reply,
					    __u8 status_req)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_GIVE_DECK_STATUS;
	msg->msg[2] = status_req;
	msg->reply = (reply && status_req != CEC_OP_STATUS_REQ_OFF) ?
				CEC_MSG_DECK_STATUS : 0;
}

static __inline__ void cec_ops_give_deck_status(const struct cec_msg *msg,
					    __u8 *status_req)
{
	*status_req = msg->msg[2];
}

static __inline__ void cec_msg_play(struct cec_msg *msg,
				__u8 play_mode)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_PLAY;
	msg->msg[2] = play_mode;
}

static __inline__ void cec_ops_play(const struct cec_msg *msg,
				__u8 *play_mode)
{
	*play_mode = msg->msg[2];
}


/* Tuner Control Feature */
struct cec_op_tuner_device_info {
	__u8 rec_flag;
	__u8 tuner_display_info;
	__u8 is_analog;
	union {
		struct cec_op_digital_service_id digital;
		struct {
			__u8 ana_bcast_type;
			__u16 ana_freq;
			__u8 bcast_system;
		} analog;
	};
};

static __inline__ void cec_msg_tuner_device_status_analog(struct cec_msg *msg,
						      __u8 rec_flag,
						      __u8 tuner_display_info,
						      __u8 ana_bcast_type,
						      __u16 ana_freq,
						      __u8 bcast_system)
{
	msg->len = 7;
	msg->msg[1] = CEC_MSG_TUNER_DEVICE_STATUS;
	msg->msg[2] = (rec_flag << 7) | tuner_display_info;
	msg->msg[3] = ana_bcast_type;
	msg->msg[4] = ana_freq >> 8;
	msg->msg[5] = ana_freq & 0xff;
	msg->msg[6] = bcast_system;
}

static __inline__ void cec_msg_tuner_device_status_digital(struct cec_msg *msg,
		   __u8 rec_flag, __u8 tuner_display_info,
		   const struct cec_op_digital_service_id *digital)
{
	msg->len = 10;
	msg->msg[1] = CEC_MSG_TUNER_DEVICE_STATUS;
	msg->msg[2] = (rec_flag << 7) | tuner_display_info;
	cec_set_digital_service_id(msg->msg + 3, digital);
}

static __inline__ void cec_msg_tuner_device_status(struct cec_msg *msg,
			const struct cec_op_tuner_device_info *tuner_dev_info)
{
	if (tuner_dev_info->is_analog)
		cec_msg_tuner_device_status_analog(msg,
			tuner_dev_info->rec_flag,
			tuner_dev_info->tuner_display_info,
			tuner_dev_info->analog.ana_bcast_type,
			tuner_dev_info->analog.ana_freq,
			tuner_dev_info->analog.bcast_system);
	else
		cec_msg_tuner_device_status_digital(msg,
			tuner_dev_info->rec_flag,
			tuner_dev_info->tuner_display_info,
			&tuner_dev_info->digital);
}

static __inline__ void cec_ops_tuner_device_status(const struct cec_msg *msg,
				struct cec_op_tuner_device_info *tuner_dev_info)
{
	tuner_dev_info->is_analog = msg->len < 10;
	tuner_dev_info->rec_flag = msg->msg[2] >> 7;
	tuner_dev_info->tuner_display_info = msg->msg[2] & 0x7f;
	if (tuner_dev_info->is_analog) {
		tuner_dev_info->analog.ana_bcast_type = msg->msg[3];
		tuner_dev_info->analog.ana_freq = (msg->msg[4] << 8) | msg->msg[5];
		tuner_dev_info->analog.bcast_system = msg->msg[6];
		return;
	}
	cec_get_digital_service_id(msg->msg + 3, &tuner_dev_info->digital);
}

static __inline__ void cec_msg_give_tuner_device_status(struct cec_msg *msg,
						    int reply,
						    __u8 status_req)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_GIVE_TUNER_DEVICE_STATUS;
	msg->msg[2] = status_req;
	msg->reply = (reply && status_req != CEC_OP_STATUS_REQ_OFF) ?
				CEC_MSG_TUNER_DEVICE_STATUS : 0;
}

static __inline__ void cec_ops_give_tuner_device_status(const struct cec_msg *msg,
						    __u8 *status_req)
{
	*status_req = msg->msg[2];
}

static __inline__ void cec_msg_select_analogue_service(struct cec_msg *msg,
						   __u8 ana_bcast_type,
						   __u16 ana_freq,
						   __u8 bcast_system)
{
	msg->len = 6;
	msg->msg[1] = CEC_MSG_SELECT_ANALOGUE_SERVICE;
	msg->msg[2] = ana_bcast_type;
	msg->msg[3] = ana_freq >> 8;
	msg->msg[4] = ana_freq & 0xff;
	msg->msg[5] = bcast_system;
}

static __inline__ void cec_ops_select_analogue_service(const struct cec_msg *msg,
						   __u8 *ana_bcast_type,
						   __u16 *ana_freq,
						   __u8 *bcast_system)
{
	*ana_bcast_type = msg->msg[2];
	*ana_freq = (msg->msg[3] << 8) | msg->msg[4];
	*bcast_system = msg->msg[5];
}

static __inline__ void cec_msg_select_digital_service(struct cec_msg *msg,
				const struct cec_op_digital_service_id *digital)
{
	msg->len = 9;
	msg->msg[1] = CEC_MSG_SELECT_DIGITAL_SERVICE;
	cec_set_digital_service_id(msg->msg + 2, digital);
}

static __inline__ void cec_ops_select_digital_service(const struct cec_msg *msg,
				struct cec_op_digital_service_id *digital)
{
	cec_get_digital_service_id(msg->msg + 2, digital);
}

static __inline__ void cec_msg_tuner_step_decrement(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_TUNER_STEP_DECREMENT;
}

static __inline__ void cec_msg_tuner_step_increment(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_TUNER_STEP_INCREMENT;
}


/* Vendor Specific Commands Feature */
static __inline__ void cec_msg_device_vendor_id(struct cec_msg *msg, __u32 vendor_id)
{
	msg->len = 5;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_DEVICE_VENDOR_ID;
	msg->msg[2] = vendor_id >> 16;
	msg->msg[3] = (vendor_id >> 8) & 0xff;
	msg->msg[4] = vendor_id & 0xff;
}

static __inline__ void cec_ops_device_vendor_id(const struct cec_msg *msg,
					    __u32 *vendor_id)
{
	*vendor_id = (msg->msg[2] << 16) | (msg->msg[3] << 8) | msg->msg[4];
}

static __inline__ void cec_msg_give_device_vendor_id(struct cec_msg *msg,
						 int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_DEVICE_VENDOR_ID;
	msg->reply = reply ? CEC_MSG_DEVICE_VENDOR_ID : 0;
}

static __inline__ void cec_msg_vendor_command(struct cec_msg *msg,
					  __u8 size, const __u8 *vendor_cmd)
{
	if (size > 14)
		size = 14;
	msg->len = 2 + size;
	msg->msg[1] = CEC_MSG_VENDOR_COMMAND;
	memcpy(msg->msg + 2, vendor_cmd, size);
}

static __inline__ void cec_ops_vendor_command(const struct cec_msg *msg,
					  __u8 *size,
					  const __u8 **vendor_cmd)
{
	*size = msg->len - 2;

	if (*size > 14)
		*size = 14;
	*vendor_cmd = msg->msg + 2;
}

static __inline__ void cec_msg_vendor_command_with_id(struct cec_msg *msg,
						  __u32 vendor_id, __u8 size,
						  const __u8 *vendor_cmd)
{
	if (size > 11)
		size = 11;
	msg->len = 5 + size;
	msg->msg[1] = CEC_MSG_VENDOR_COMMAND_WITH_ID;
	msg->msg[2] = vendor_id >> 16;
	msg->msg[3] = (vendor_id >> 8) & 0xff;
	msg->msg[4] = vendor_id & 0xff;
	memcpy(msg->msg + 5, vendor_cmd, size);
}

static __inline__ void cec_ops_vendor_command_with_id(const struct cec_msg *msg,
						  __u32 *vendor_id,  __u8 *size,
						  const __u8 **vendor_cmd)
{
	*size = msg->len - 5;

	if (*size > 11)
		*size = 11;
	*vendor_id = (msg->msg[2] << 16) | (msg->msg[3] << 8) | msg->msg[4];
	*vendor_cmd = msg->msg + 5;
}

static __inline__ void cec_msg_vendor_remote_button_down(struct cec_msg *msg,
						     __u8 size,
						     const __u8 *rc_code)
{
	if (size > 14)
		size = 14;
	msg->len = 2 + size;
	msg->msg[1] = CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN;
	memcpy(msg->msg + 2, rc_code, size);
}

static __inline__ void cec_ops_vendor_remote_button_down(const struct cec_msg *msg,
						     __u8 *size,
						     const __u8 **rc_code)
{
	*size = msg->len - 2;

	if (*size > 14)
		*size = 14;
	*rc_code = msg->msg + 2;
}

static __inline__ void cec_msg_vendor_remote_button_up(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_VENDOR_REMOTE_BUTTON_UP;
}


/* OSD Display Feature */
static __inline__ void cec_msg_set_osd_string(struct cec_msg *msg,
					  __u8 disp_ctl,
					  const char *osd)
{
	unsigned int len = strlen(osd);

	if (len > 13)
		len = 13;
	msg->len = 3 + len;
	msg->msg[1] = CEC_MSG_SET_OSD_STRING;
	msg->msg[2] = disp_ctl;
	memcpy(msg->msg + 3, osd, len);
}

static __inline__ void cec_ops_set_osd_string(const struct cec_msg *msg,
					  __u8 *disp_ctl,
					  char *osd)
{
	unsigned int len = msg->len > 3 ? msg->len - 3 : 0;

	*disp_ctl = msg->msg[2];
	if (len > 13)
		len = 13;
	memcpy(osd, msg->msg + 3, len);
	osd[len] = '\0';
}


/* Device OSD Transfer Feature */
static __inline__ void cec_msg_set_osd_name(struct cec_msg *msg, const char *name)
{
	unsigned int len = strlen(name);

	if (len > 14)
		len = 14;
	msg->len = 2 + len;
	msg->msg[1] = CEC_MSG_SET_OSD_NAME;
	memcpy(msg->msg + 2, name, len);
}

static __inline__ void cec_ops_set_osd_name(const struct cec_msg *msg,
					char *name)
{
	unsigned int len = msg->len > 2 ? msg->len - 2 : 0;

	if (len > 14)
		len = 14;
	memcpy(name, msg->msg + 2, len);
	name[len] = '\0';
}

static __inline__ void cec_msg_give_osd_name(struct cec_msg *msg,
					 int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_OSD_NAME;
	msg->reply = reply ? CEC_MSG_SET_OSD_NAME : 0;
}


/* Device Menu Control Feature */
static __inline__ void cec_msg_menu_status(struct cec_msg *msg,
				       __u8 menu_state)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_MENU_STATUS;
	msg->msg[2] = menu_state;
}

static __inline__ void cec_ops_menu_status(const struct cec_msg *msg,
				       __u8 *menu_state)
{
	*menu_state = msg->msg[2];
}

static __inline__ void cec_msg_menu_request(struct cec_msg *msg,
					int reply,
					__u8 menu_req)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_MENU_REQUEST;
	msg->msg[2] = menu_req;
	msg->reply = reply ? CEC_MSG_MENU_STATUS : 0;
}

static __inline__ void cec_ops_menu_request(const struct cec_msg *msg,
					__u8 *menu_req)
{
	*menu_req = msg->msg[2];
}

struct cec_op_ui_command {
	__u8 ui_cmd;
	__u8 has_opt_arg;
	union {
		struct cec_op_channel_data channel_identifier;
		__u8 ui_broadcast_type;
		__u8 ui_sound_presentation_control;
		__u8 play_mode;
		__u8 ui_function_media;
		__u8 ui_function_select_av_input;
		__u8 ui_function_select_audio_input;
	};
};

static __inline__ void cec_msg_user_control_pressed(struct cec_msg *msg,
					const struct cec_op_ui_command *ui_cmd)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_USER_CONTROL_PRESSED;
	msg->msg[2] = ui_cmd->ui_cmd;
	if (!ui_cmd->has_opt_arg)
		return;
	switch (ui_cmd->ui_cmd) {
	case CEC_OP_UI_CMD_SELECT_BROADCAST_TYPE:
	case CEC_OP_UI_CMD_SELECT_SOUND_PRESENTATION:
	case CEC_OP_UI_CMD_PLAY_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_MEDIA_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_AV_INPUT_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_AUDIO_INPUT_FUNCTION:
		/* The optional operand is one byte for all these ui commands */
		msg->len++;
		msg->msg[3] = ui_cmd->play_mode;
		break;
	case CEC_OP_UI_CMD_TUNE_FUNCTION:
		msg->len += 4;
		msg->msg[3] = (ui_cmd->channel_identifier.channel_number_fmt << 2) |
			      (ui_cmd->channel_identifier.major >> 8);
		msg->msg[4] = ui_cmd->channel_identifier.major & 0xff;
		msg->msg[5] = ui_cmd->channel_identifier.minor >> 8;
		msg->msg[6] = ui_cmd->channel_identifier.minor & 0xff;
		break;
	}
}

static __inline__ void cec_ops_user_control_pressed(const struct cec_msg *msg,
						struct cec_op_ui_command *ui_cmd)
{
	ui_cmd->ui_cmd = msg->msg[2];
	ui_cmd->has_opt_arg = 0;
	if (msg->len == 3)
		return;
	switch (ui_cmd->ui_cmd) {
	case CEC_OP_UI_CMD_SELECT_BROADCAST_TYPE:
	case CEC_OP_UI_CMD_SELECT_SOUND_PRESENTATION:
	case CEC_OP_UI_CMD_PLAY_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_MEDIA_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_AV_INPUT_FUNCTION:
	case CEC_OP_UI_CMD_SELECT_AUDIO_INPUT_FUNCTION:
		/* The optional operand is one byte for all these ui commands */
		ui_cmd->play_mode = msg->msg[3];
		ui_cmd->has_opt_arg = 1;
		break;
	case CEC_OP_UI_CMD_TUNE_FUNCTION:
		if (msg->len < 7)
			break;
		ui_cmd->has_opt_arg = 1;
		ui_cmd->channel_identifier.channel_number_fmt = msg->msg[3] >> 2;
		ui_cmd->channel_identifier.major = ((msg->msg[3] & 3) << 6) | msg->msg[4];
		ui_cmd->channel_identifier.minor = (msg->msg[5] << 8) | msg->msg[6];
		break;
	}
}

static __inline__ void cec_msg_user_control_released(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_USER_CONTROL_RELEASED;
}

/* Remote Control Passthrough Feature */

/* Power Status Feature */
static __inline__ void cec_msg_report_power_status(struct cec_msg *msg,
					       __u8 pwr_state)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_REPORT_POWER_STATUS;
	msg->msg[2] = pwr_state;
}

static __inline__ void cec_ops_report_power_status(const struct cec_msg *msg,
					       __u8 *pwr_state)
{
	*pwr_state = msg->msg[2];
}

static __inline__ void cec_msg_give_device_power_status(struct cec_msg *msg,
						    int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_DEVICE_POWER_STATUS;
	msg->reply = reply ? CEC_MSG_REPORT_POWER_STATUS : 0;
}

/* General Protocol Messages */
static __inline__ void cec_msg_feature_abort(struct cec_msg *msg,
					 __u8 abort_msg, __u8 reason)
{
	msg->len = 4;
	msg->msg[1] = CEC_MSG_FEATURE_ABORT;
	msg->msg[2] = abort_msg;
	msg->msg[3] = reason;
}

static __inline__ void cec_ops_feature_abort(const struct cec_msg *msg,
					 __u8 *abort_msg, __u8 *reason)
{
	*abort_msg = msg->msg[2];
	*reason = msg->msg[3];
}

/* This changes the current message into a feature abort message */
static __inline__ void cec_msg_reply_feature_abort(struct cec_msg *msg, __u8 reason)
{
	cec_msg_set_reply_to(msg, msg);
	msg->len = 4;
	msg->msg[2] = msg->msg[1];
	msg->msg[3] = reason;
	msg->msg[1] = CEC_MSG_FEATURE_ABORT;
}

static __inline__ void cec_msg_abort(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_ABORT;
}


/* System Audio Control Feature */
static __inline__ void cec_msg_report_audio_status(struct cec_msg *msg,
					       __u8 aud_mute_status,
					       __u8 aud_vol_status)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_REPORT_AUDIO_STATUS;
	msg->msg[2] = (aud_mute_status << 7) | (aud_vol_status & 0x7f);
}

static __inline__ void cec_ops_report_audio_status(const struct cec_msg *msg,
					       __u8 *aud_mute_status,
					       __u8 *aud_vol_status)
{
	*aud_mute_status = msg->msg[2] >> 7;
	*aud_vol_status = msg->msg[2] & 0x7f;
}

static __inline__ void cec_msg_give_audio_status(struct cec_msg *msg,
					     int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_AUDIO_STATUS;
	msg->reply = reply ? CEC_MSG_REPORT_AUDIO_STATUS : 0;
}

static __inline__ void cec_msg_set_system_audio_mode(struct cec_msg *msg,
						 __u8 sys_aud_status)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_SET_SYSTEM_AUDIO_MODE;
	msg->msg[2] = sys_aud_status;
}

static __inline__ void cec_ops_set_system_audio_mode(const struct cec_msg *msg,
						 __u8 *sys_aud_status)
{
	*sys_aud_status = msg->msg[2];
}

static __inline__ void cec_msg_system_audio_mode_request(struct cec_msg *msg,
						     int reply,
						     __u16 phys_addr)
{
	msg->len = phys_addr == 0xffff ? 2 : 4;
	msg->msg[1] = CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST;
	msg->msg[2] = phys_addr >> 8;
	msg->msg[3] = phys_addr & 0xff;
	msg->reply = reply ? CEC_MSG_SET_SYSTEM_AUDIO_MODE : 0;

}

static __inline__ void cec_ops_system_audio_mode_request(const struct cec_msg *msg,
						     __u16 *phys_addr)
{
	if (msg->len < 4)
		*phys_addr = 0xffff;
	else
		*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
}

static __inline__ void cec_msg_system_audio_mode_status(struct cec_msg *msg,
						    __u8 sys_aud_status)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_SYSTEM_AUDIO_MODE_STATUS;
	msg->msg[2] = sys_aud_status;
}

static __inline__ void cec_ops_system_audio_mode_status(const struct cec_msg *msg,
						    __u8 *sys_aud_status)
{
	*sys_aud_status = msg->msg[2];
}

static __inline__ void cec_msg_give_system_audio_mode_status(struct cec_msg *msg,
							 int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS;
	msg->reply = reply ? CEC_MSG_SYSTEM_AUDIO_MODE_STATUS : 0;
}

static __inline__ void cec_msg_report_short_audio_descriptor(struct cec_msg *msg,
					__u8 num_descriptors,
					const __u32 *descriptors)
{
	unsigned int i;

	if (num_descriptors > 4)
		num_descriptors = 4;
	msg->len = 2 + num_descriptors * 3;
	msg->msg[1] = CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR;
	for (i = 0; i < num_descriptors; i++) {
		msg->msg[2 + i * 3] = (descriptors[i] >> 16) & 0xff;
		msg->msg[3 + i * 3] = (descriptors[i] >> 8) & 0xff;
		msg->msg[4 + i * 3] = descriptors[i] & 0xff;
	}
}

static __inline__ void cec_ops_report_short_audio_descriptor(const struct cec_msg *msg,
							 __u8 *num_descriptors,
							 __u32 *descriptors)
{
	unsigned int i;

	*num_descriptors = (msg->len - 2) / 3;
	if (*num_descriptors > 4)
		*num_descriptors = 4;
	for (i = 0; i < *num_descriptors; i++)
		descriptors[i] = (msg->msg[2 + i * 3] << 16) |
			(msg->msg[3 + i * 3] << 8) |
			msg->msg[4 + i * 3];
}

static __inline__ void cec_msg_request_short_audio_descriptor(struct cec_msg *msg,
					int reply,
					__u8 num_descriptors,
					const __u8 *audio_format_id,
					const __u8 *audio_format_code)
{
	unsigned int i;

	if (num_descriptors > 4)
		num_descriptors = 4;
	msg->len = 2 + num_descriptors;
	msg->msg[1] = CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR;
	msg->reply = reply ? CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR : 0;
	for (i = 0; i < num_descriptors; i++)
		msg->msg[2 + i] = (audio_format_id[i] << 6) |
				  (audio_format_code[i] & 0x3f);
}

static __inline__ void cec_ops_request_short_audio_descriptor(const struct cec_msg *msg,
					__u8 *num_descriptors,
					__u8 *audio_format_id,
					__u8 *audio_format_code)
{
	unsigned int i;

	*num_descriptors = msg->len - 2;
	if (*num_descriptors > 4)
		*num_descriptors = 4;
	for (i = 0; i < *num_descriptors; i++) {
		audio_format_id[i] = msg->msg[2 + i] >> 6;
		audio_format_code[i] = msg->msg[2 + i] & 0x3f;
	}
}


/* Audio Rate Control Feature */
static __inline__ void cec_msg_set_audio_rate(struct cec_msg *msg,
					  __u8 audio_rate)
{
	msg->len = 3;
	msg->msg[1] = CEC_MSG_SET_AUDIO_RATE;
	msg->msg[2] = audio_rate;
}

static __inline__ void cec_ops_set_audio_rate(const struct cec_msg *msg,
					  __u8 *audio_rate)
{
	*audio_rate = msg->msg[2];
}


/* Audio Return Channel Control Feature */
static __inline__ void cec_msg_report_arc_initiated(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_REPORT_ARC_INITIATED;
}

static __inline__ void cec_msg_initiate_arc(struct cec_msg *msg,
					int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_INITIATE_ARC;
	msg->reply = reply ? CEC_MSG_REPORT_ARC_INITIATED : 0;
}

static __inline__ void cec_msg_request_arc_initiation(struct cec_msg *msg,
						  int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_REQUEST_ARC_INITIATION;
	msg->reply = reply ? CEC_MSG_INITIATE_ARC : 0;
}

static __inline__ void cec_msg_report_arc_terminated(struct cec_msg *msg)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_REPORT_ARC_TERMINATED;
}

static __inline__ void cec_msg_terminate_arc(struct cec_msg *msg,
					 int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_TERMINATE_ARC;
	msg->reply = reply ? CEC_MSG_REPORT_ARC_TERMINATED : 0;
}

static __inline__ void cec_msg_request_arc_termination(struct cec_msg *msg,
						   int reply)
{
	msg->len = 2;
	msg->msg[1] = CEC_MSG_REQUEST_ARC_TERMINATION;
	msg->reply = reply ? CEC_MSG_TERMINATE_ARC : 0;
}


/* Dynamic Audio Lipsync Feature */
/* Only for CEC 2.0 and up */
static __inline__ void cec_msg_report_current_latency(struct cec_msg *msg,
						  __u16 phys_addr,
						  __u8 video_latency,
						  __u8 low_latency_mode,
						  __u8 audio_out_compensated,
						  __u8 audio_out_delay)
{
	msg->len = 6;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_REPORT_CURRENT_LATENCY;
	msg->msg[2] = phys_addr >> 8;
	msg->msg[3] = phys_addr & 0xff;
	msg->msg[4] = video_latency;
	msg->msg[5] = (low_latency_mode << 2) | audio_out_compensated;
	if (audio_out_compensated == 3)
		msg->msg[msg->len++] = audio_out_delay;
}

static __inline__ void cec_ops_report_current_latency(const struct cec_msg *msg,
						  __u16 *phys_addr,
						  __u8 *video_latency,
						  __u8 *low_latency_mode,
						  __u8 *audio_out_compensated,
						  __u8 *audio_out_delay)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*video_latency = msg->msg[4];
	*low_latency_mode = (msg->msg[5] >> 2) & 1;
	*audio_out_compensated = msg->msg[5] & 3;
	if (*audio_out_compensated == 3 && msg->len >= 7)
		*audio_out_delay = msg->msg[6];
	else
		*audio_out_delay = 0;
}

static __inline__ void cec_msg_request_current_latency(struct cec_msg *msg,
						   int reply,
						   __u16 phys_addr)
{
	msg->len = 4;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_REQUEST_CURRENT_LATENCY;
	msg->msg[2] = phys_addr >> 8;
	msg->msg[3] = phys_addr & 0xff;
	msg->reply = reply ? CEC_MSG_REPORT_CURRENT_LATENCY : 0;
}

static __inline__ void cec_ops_request_current_latency(const struct cec_msg *msg,
						   __u16 *phys_addr)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
}


/* Capability Discovery and Control Feature */
static __inline__ void cec_msg_cdc_hec_inquire_state(struct cec_msg *msg,
						 __u16 phys_addr1,
						 __u16 phys_addr2)
{
	msg->len = 9;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_INQUIRE_STATE;
	msg->msg[5] = phys_addr1 >> 8;
	msg->msg[6] = phys_addr1 & 0xff;
	msg->msg[7] = phys_addr2 >> 8;
	msg->msg[8] = phys_addr2 & 0xff;
}

static __inline__ void cec_ops_cdc_hec_inquire_state(const struct cec_msg *msg,
						 __u16 *phys_addr,
						 __u16 *phys_addr1,
						 __u16 *phys_addr2)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*phys_addr1 = (msg->msg[5] << 8) | msg->msg[6];
	*phys_addr2 = (msg->msg[7] << 8) | msg->msg[8];
}

static __inline__ void cec_msg_cdc_hec_report_state(struct cec_msg *msg,
						__u16 target_phys_addr,
						__u8 hec_func_state,
						__u8 host_func_state,
						__u8 enc_func_state,
						__u8 cdc_errcode,
						__u8 has_field,
						__u16 hec_field)
{
	msg->len = has_field ? 10 : 8;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_REPORT_STATE;
	msg->msg[5] = target_phys_addr >> 8;
	msg->msg[6] = target_phys_addr & 0xff;
	msg->msg[7] = (hec_func_state << 6) |
		      (host_func_state << 4) |
		      (enc_func_state << 2) |
		      cdc_errcode;
	if (has_field) {
		msg->msg[8] = hec_field >> 8;
		msg->msg[9] = hec_field & 0xff;
	}
}

static __inline__ void cec_ops_cdc_hec_report_state(const struct cec_msg *msg,
						__u16 *phys_addr,
						__u16 *target_phys_addr,
						__u8 *hec_func_state,
						__u8 *host_func_state,
						__u8 *enc_func_state,
						__u8 *cdc_errcode,
						__u8 *has_field,
						__u16 *hec_field)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*target_phys_addr = (msg->msg[5] << 8) | msg->msg[6];
	*hec_func_state = msg->msg[7] >> 6;
	*host_func_state = (msg->msg[7] >> 4) & 3;
	*enc_func_state = (msg->msg[7] >> 4) & 3;
	*cdc_errcode = msg->msg[7] & 3;
	*has_field = msg->len >= 10;
	*hec_field = *has_field ? ((msg->msg[8] << 8) | msg->msg[9]) : 0;
}

static __inline__ void cec_msg_cdc_hec_set_state(struct cec_msg *msg,
					     __u16 phys_addr1,
					     __u16 phys_addr2,
					     __u8 hec_set_state,
					     __u16 phys_addr3,
					     __u16 phys_addr4,
					     __u16 phys_addr5)
{
	msg->len = 10;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_INQUIRE_STATE;
	msg->msg[5] = phys_addr1 >> 8;
	msg->msg[6] = phys_addr1 & 0xff;
	msg->msg[7] = phys_addr2 >> 8;
	msg->msg[8] = phys_addr2 & 0xff;
	msg->msg[9] = hec_set_state;
	if (phys_addr3 != CEC_PHYS_ADDR_INVALID) {
		msg->msg[msg->len++] = phys_addr3 >> 8;
		msg->msg[msg->len++] = phys_addr3 & 0xff;
		if (phys_addr4 != CEC_PH‹® Œ®                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         YS_ADDR_INVALID) {
			msg->msg[msg->len++] = phys_addr4 >> 8;
			msg->msg[msg->len++] = phys_addr4 & 0xff;
			if (phys_addr5 != CEC_PHYS_ADDR_INVALID) {
				msg->msg[msg->len++] = phys_addr5 >> 8;
				msg->msg[msg->len++] = phys_addr5 & 0xff;
			}
		}
	}
}

static __inline__ void cec_ops_cdc_hec_set_state(const struct cec_msg *msg,
					     __u16 *phys_addr,
					     __u16 *phys_addr1,
					     __u16 *phys_addr2,
					     __u8 *hec_set_state,
					     __u16 *phys_addr3,
					     __u16 *phys_addr4,
					     __u16 *phys_addr5)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*phys_addr1 = (msg->msg[5] << 8) | msg->msg[6];
	*phys_addr2 = (msg->msg[7] << 8) | msg->msg[8];
	*hec_set_state = msg->msg[9];
	*phys_addr3 = *phys_addr4 = *phys_addr5 = CEC_PHYS_ADDR_INVALID;
	if (msg->len >= 12)
		*phys_addr3 = (msg->msg[10] << 8) | msg->msg[11];
	if (msg->len >= 14)
		*phys_addr4 = (msg->msg[12] << 8) | msg->msg[13];
	if (msg->len >= 16)
		*phys_addr5 = (msg->msg[14] << 8) | msg->msg[15];
}

static __inline__ void cec_msg_cdc_hec_set_state_adjacent(struct cec_msg *msg,
						      __u16 phys_addr1,
						      __u8 hec_set_state)
{
	msg->len = 8;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_SET_STATE_ADJACENT;
	msg->msg[5] = phys_addr1 >> 8;
	msg->msg[6] = phys_addr1 & 0xff;
	msg->msg[7] = hec_set_state;
}

static __inline__ void cec_ops_cdc_hec_set_state_adjacent(const struct cec_msg *msg,
						      __u16 *phys_addr,
						      __u16 *phys_addr1,
						      __u8 *hec_set_state)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*phys_addr1 = (msg->msg[5] << 8) | msg->msg[6];
	*hec_set_state = msg->msg[7];
}

static __inline__ void cec_msg_cdc_hec_request_deactivation(struct cec_msg *msg,
							__u16 phys_addr1,
							__u16 phys_addr2,
							__u16 phys_addr3)
{
	msg->len = 11;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION;
	msg->msg[5] = phys_addr1 >> 8;
	msg->msg[6] = phys_addr1 & 0xff;
	msg->msg[7] = phys_addr2 >> 8;
	msg->msg[8] = phys_addr2 & 0xff;
	msg->msg[9] = phys_addr3 >> 8;
	msg->msg[10] = phys_addr3 & 0xff;
}

static __inline__ void cec_ops_cdc_hec_request_deactivation(const struct cec_msg *msg,
							__u16 *phys_addr,
							__u16 *phys_addr1,
							__u16 *phys_addr2,
							__u16 *phys_addr3)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*phys_addr1 = (msg->msg[5] << 8) | msg->msg[6];
	*phys_addr2 = (msg->msg[7] << 8) | msg->msg[8];
	*phys_addr3 = (msg->msg[9] << 8) | msg->msg[10];
}

static __inline__ void cec_msg_cdc_hec_notify_alive(struct cec_msg *msg)
{
	msg->len = 5;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_NOTIFY_ALIVE;
}

static __inline__ void cec_ops_cdc_hec_notify_alive(const struct cec_msg *msg,
						__u16 *phys_addr)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
}

static __inline__ void cec_msg_cdc_hec_discover(struct cec_msg *msg)
{
	msg->len = 5;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HEC_DISCOVER;
}

static __inline__ void cec_ops_cdc_hec_discover(const struct cec_msg *msg,
					    __u16 *phys_addr)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
}

static __inline__ void cec_msg_cdc_hpd_set_state(struct cec_msg *msg,
					     __u8 input_port,
					     __u8 hpd_state)
{
	msg->len = 6;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HPD_SET_STATE;
	msg->msg[5] = (input_port << 4) | hpd_state;
}

static __inline__ void cec_ops_cdc_hpd_set_state(const struct cec_msg *msg,
					    __u16 *phys_addr,
					    __u8 *input_port,
					    __u8 *hpd_state)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*input_port = msg->msg[5] >> 4;
	*hpd_state = msg->msg[5] & 0xf;
}

static __inline__ void cec_msg_cdc_hpd_report_state(struct cec_msg *msg,
						__u8 hpd_state,
						__u8 hpd_error)
{
	msg->len = 6;
	msg->msg[0] |= 0xf; /* broadcast */
	msg->msg[1] = CEC_MSG_CDC_MESSAGE;
	/* msg[2] and msg[3] (phys_addr) are filled in by the CEC framework */
	msg->msg[4] = CEC_MSG_CDC_HPD_REPORT_STATE;
	msg->msg[5] = (hpd_state << 4) | hpd_error;
}

static __inline__ void cec_ops_cdc_hpd_report_state(const struct cec_msg *msg,
						__u16 *phys_addr,
						__u8 *hpd_state,
						__u8 *hpd_error)
{
	*phys_addr = (msg->msg[2] << 8) | msg->msg[3];
	*hpd_state = msg->msg[5] >> 4;
	*hpd_error = msg->msg[5] & 0xf;
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause) */
/*
 * cec - HDMI Consumer Electronics Control public header
 *
 * Copyright 2016 Cisco Systems, Inc. and/or its affiliates. All rights reserved.
 */

#ifndef _CEC_UAPI_H
#define _CEC_UAPI_H

#include <linux/types.h>
#include <linux/string.h>

#define CEC_MAX_MSG_SIZE	16

/**
 * struct cec_msg - CEC message structure.
 * @tx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
 *		driver when the message transmission has finished.
 * @rx_ts:	Timestamp in nanoseconds using CLOCK_MONOTONIC. Set by the
 *		driver when the message was received.
 * @len:	Length in bytes of the message.
 * @timeout:	The timeout (in ms) that is used to timeout CEC_RECEIVE.
 *		Set to 0 if you want to wait forever. This timeout can also be
 *		used with CEC_TRANSMIT as the timeout for waiting for a reply.
 *		If 0, then it will use a 1 second timeout instead of waiting
 *		forever as is done with CEC_RECEIVE.
 * @sequence:	The framework assigns a sequence number to messages that are
 *		sent. This can be used to track replies to previously sent
 *		messages.
 * @flags:	Set to 0.
 * @msg:	The message payload.
 * @reply:	This field is ignored with CEC_RECEIVE and is only used by
 *		CEC_TRANSMIT. If non-zero, then wait for a reply with this
 *		opcode. Set to CEC_MSG_FEATURE_ABORT if you want to wait for
 *		a possible ABORT reply. If there was an error when sending the
 *		msg or FeatureAbort was returned, then reply is set to 0.
 *		If reply is non-zero upon return, then len/msg are set to
 *		the received message.
 *		If reply is zero upon return and status has the
 *		CEC_TX_STATUS_FEATURE_ABORT bit set, then len/msg are set to
 *		the received feature abort message.
 *		If reply is zero upon return and status has the
 *		CEC_TX_STATUS_MAX_RETRIES bit set, then no reply was seen at
 *		all. If reply is non-zero for CEC_TRANSMIT and the message is a
 *		broadcast, then -EINVAL is returned.
 *		if reply is non-zero, then timeout is set to 1000 (the required
 *		maximum response time).
 * @rx_status:	The message receive status bits. Set by the driver.
 * @tx_status:	The message transmit status bits. Set by the driver.
 * @tx_arb_lost_cnt: The number of 'Arbitration Lost' events. Set by the driver.
 * @tx_nack_cnt: The number of 'Not Acknowledged' events. Set by the driver.
 * @tx_low_drive_cnt: The number of 'Low Drive Detected' events. Set by the
 *		driver.
 * @tx_error_cnt: The number of 'Error' events. Set by the driver.
 */
struct cec_msg {
	__u64 tx_ts;
	__u64 rx_ts;
	__u32 len;
	__u32 timeout;
	__u32 sequence;
	__u32 flags;
	__u8 msg[CEC_MAX_MSG_SIZE];
	__u8 reply;
	__u8 rx_status;
	__u8 tx_status;
	__u8 tx_arb_lost_cnt;
	__u8 tx_nack_cnt;
	__u8 tx_low_drive_cnt;
	__u8 tx_error_cnt;
};

/**
 * cec_msg_initiator - return the initiator's logical address.
 * @msg:	the message structure
 */
static __inline__ __u8 cec_msg_initiator(const struct cec_msg *msg)
{
	return msg->msg[0] >> 4;
}

/**
 * cec_msg_destination - return the destination's logical address.
 * @msg:	the message structure
 */
static __inline__ __u8 cec_msg_destination(const struct cec_msg *msg)
{
	return msg->msg[0] & 0xf;
}

/**
 * cec_msg_opcode - return the opcode of the message, -1 for poll
 * @msg:	the message structure
 */
static __inline__ int cec_msg_opcode(const struct cec_msg *msg)
{
	return msg->len > 1 ? msg->msg[1] : -1;
}

/**
 * cec_msg_is_broadcast - return true if this is a broadcast message.
 * @msg:	the message structure
 */
static __inline__ int cec_msg_is_broadcast(const struct cec_msg *msg)
{
	return (msg->msg[0] & 0xf) == 0xf;
}

/**
 * cec_msg_init - initialize the message structure.
 * @msg:	the message structure
 * @initiator:	the logical address of the initiator
 * @destination:the logical address of the destination (0xf for broadcast)
 *
 * The whole structure is zeroed, the len field is set to 1 (i.e. a poll
 * message) and the initiator and destination are filled in.
 */
static __inline__ void cec_msg_init(struct cec_msg *msg,
				__u8 initiator, __u8 destination)
{
	memset(msg, 0, sizeof(*msg));
	msg->msg[0] = (initiator << 4) | destination;
	msg->len = 1;
}

/**
 * cec_msg_set_reply_to - fill in destination/initiator in a reply message.
 * @msg:	the message structure for the reply
 * @orig:	the original message structure
 *
 * Set the msg destination to the orig initiator and the msg initiator to the
 * orig destination. Note that msg and orig may be the same pointer, in which
 * case the change is done in place.
 */
static __inline__ void cec_msg_set_reply_to(struct cec_msg *msg,
					struct cec_msg *orig)
{
	/* The destination becomes the initiator and vice versa */
	msg->msg[0] = (cec_msg_destination(orig) << 4) |
		      cec_msg_initiator(orig);
	msg->reply = msg->timeout = 0;
}

/* cec_msg flags field */
#define CEC_MSG_FL_REPLY_TO_FOLLOWERS	(1 << 0)
#define CEC_MSG_FL_RAW			(1 << 1)

/* cec_msg tx/rx_status field */
#define CEC_TX_STATUS_OK		(1 << 0)
#define CEC_TX_STATUS_ARB_LOST		(1 << 1)
#define CEC_TX_STATUS_NACK		(1 << 2)
#define CEC_TX_STATUS_LOW_DRIVE		(1 << 3)
#define CEC_TX_STATUS_ERROR		(1 << 4)
#define CEC_TX_STATUS_MAX_RETRIES	(1 << 5)
#define CEC_TX_STATUS_ABORTED		(1 << 6)
#define CEC_TX_STATUS_TIMEOUT		(1 << 7)

#define CEC_RX_STATUS_OK		(1 << 0)
#define CEC_RX_STATUS_TIMEOUT		(1 << 1)
#define CEC_RX_STATUS_FEATURE_ABORT	(1 << 2)
#define CEC_RX_STATUS_ABORTED		(1 << 3)

static __inline__ int cec_msg_status_is_ok(const struct cec_msg *msg)
{
	if (msg->tx_status && !(msg->tx_status & CEC_TX_STATUS_OK))
		return 0;
	if (msg->rx_status && !(msg->rx_status & CEC_RX_STATUS_OK))
		return 0;
	if (!msg->tx_status && !msg->rx_status)
		return 0;
	return !(msg->rx_status & CEC_RX_STATUS_FEATURE_ABORT);
}

#define CEC_LOG_ADDR_INVALID		0xff
#define CEC_PHYS_ADDR_INVALID		0xffff

/*
 * The maximum number of logical addresses one device can be assigned to.
 * The CEC 2.0 spec allows for only 2 logical addresses at the moment. The
 * Analog Devices CEC hardware supports 3. So let's go wild and go for 4.
 */
#define CEC_MAX_LOG_ADDRS 4

/* The logical addresses defined by CEC 2.0 */
#define CEC_LOG_ADDR_TV			0
#define CEC_LOG_ADDR_RECORD_1		1
#define CEC_LOG_ADDR_RECORD_2		2
#define CEC_LOG_ADDR_TUNER_1		3
#define CEC_LOG_ADDR_PLAYBACK_1		4
#define CEC_LOG_ADDR_AUDIOSYSTEM	5
#define CEC_LOG_ADDR_TUNER_2		6
#define CEC_LOG_ADDR_TUNER_3		7
#define CEC_LOG_ADDR_PLAYBACK_2		8
#define CEC_LOG_ADDR_RECORD_3		9
#define CEC_LOG_ADDR_TUNER_4		10
#define CEC_LOG_ADDR_PLAYBACK_3		11
#define CEC_LOG_ADDR_BACKUP_1		12
#define CEC_LOG_ADDR_BACKUP_2		13
#define CEC_LOG_ADDR_SPECIFIC		14
#define CEC_LOG_ADDR_UNREGISTERED	15 /* as initiator address */
#define CEC_LOG_ADDR_BROADCAST		15 /* as destination address */

/* The logical address types that the CEC device wants to claim */
#define CEC_LOG_ADDR_TYPE_TV		0
#define CEC_LOG_ADDR_TYPE_RECORD	1
#define CEC_LOG_ADDR_TYPE_TUNER		2
#define CEC_LOG_ADDR_TYPE_PLAYBACK	3
#define CEC_LOG_ADDR_TYPE_AUDIOSYSTEM	4
#define CEC_LOG_ADDR_TYPE_SPECIFIC	5
#define CEC_LOG_ADDR_TYPE_UNREGISTERED	6
/*
 * Switches should use UNREGISTERED.
 * Processors should use SPECIFIC.
 */

#define CEC_LOG_ADDR_MASK_TV		(1 << CEC_LOG_ADDR_TV)
#define CEC_LOG_ADDR_MASK_RECORD	((1 << CEC_LOG_ADDR_RECORD_1) | \
					 (1 << CEC_LOG_ADDR_RECORD_2) | \
					 (1 << CEC_LOG_ADDR_RECORD_3))
#define CEC_LOG_ADDR_MASK_TUNER		((1 << CEC_LOG_ADDR_TUNER_1) | \
					 (1 << CEC_LOG_ADDR_TUNER_2) | \
					 (1 << CEC_LOG_ADDR_TUNER_3) | \
					 (1 << CEC_LOG_ADDR_TUNER_4))
#define CEC_LOG_ADDR_MASK_PLAYBACK	((1 << CEC_LOG_ADDR_PLAYBACK_1) | \
					 (1 << CEC_LOG_ADDR_PLAYBACK_2) | \
					 (1 << CEC_LOG_ADDR_PLAYBACK_3))
#define CEC_LOG_ADDR_MASK_AUDIOSYSTEM	(1 << CEC_LOG_ADDR_AUDIOSYSTEM)
#define CEC_LOG_ADDR_MASK_BACKUP	((1 << CEC_LOG_ADDR_BACKUP_1) | \
					 (1 << CEC_LOG_ADDR_BACKUP_2))
#define CEC_LOG_ADDR_MASK_SPECIFIC	(1 << CEC_LOG_ADDR_SPECIFIC)
#define CEC_LOG_ADDR_MASK_UNREGISTERED	(1 << CEC_LOG_ADDR_UNREGISTERED)

static __inline__ int cec_has_tv(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_TV;
}

static __inline__ int cec_has_record(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_RECORD;
}

static __inline__ int cec_has_tuner(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_TUNER;
}

static __inline__ int cec_has_playback(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_PLAYBACK;
}

static __inline__ int cec_has_audiosystem(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_AUDIOSYSTEM;
}

static __inline__ int cec_has_backup(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_BACKUP;
}

static __inline__ int cec_has_specific(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_SPECIFIC;
}

static __inline__ int cec_is_unregistered(__u16 log_addr_mask)
{
	return log_addr_mask & CEC_LOG_ADDR_MASK_UNREGISTERED;
}

static __inline__ int cec_is_unconfigured(__u16 log_addr_mask)
{
	return log_addr_mask == 0;
}

/*
 * Use this if there is no vendor ID (CEC_G_VENDOR_ID) or if the vendor ID
 * should be disabled (CEC_S_VENDOR_ID)
 */
#define CEC_VENDOR_ID_NONE		0xffffffff

/* The message handling modes */
/* Modes for initiator */
#define CEC_MODE_NO_INITIATOR		(0x0 << 0)
#define CEC_MODE_INITIATOR		(0x1 << 0)
#define CEC_MODE_EXCL_INITIATOR		(0x2 << 0)
#define CEC_MODE_INITIATOR_MSK		0x0f

/* Modes for follower */
#define CEC_MODE_NO_FOLLOWER		(0x0 << 4)
#define CEC_MODE_FOLLOWER		(0x1 << 4)
#define CEC_MODE_EXCL_FOLLOWER		(0x2 << 4)
#define CEC_MODE_EXCL_FOLLOWER_PASSTHRU	(0x3 << 4)
#define CEC_MODE_MONITOR_PIN		(0xd << 4)
#define CEC_MODE_MONITOR		(0xe << 4)
#define CEC_MODE_MONITOR_ALL		(0xf << 4)
#define CEC_MODE_FOLLOWER_MSK		0xf0

/* Userspace has to configure the physical address */
#define CEC_CAP_PHYS_ADDR	(1 << 0)
/* Userspace has to configure the logical addresses */
#define CEC_CAP_LOG_ADDRS	(1 << 1)
/* Userspace can transmit messages (and thus become follower as well) */
#define CEC_CAP_TRANSMIT	(1 << 2)
/*
 * Passthrough all messages instead of processing them.
 */
#define CEC_CAP_PASSTHROUGH	(1 << 3)
/* Supports remote control */
#define CEC_CAP_RC		(1 << 4)
/* Hardware can monitor all messages, not just directed and broadcast. */
#define CEC_CAP_MONITOR_ALL	(1 << 5)
/* Hardware can use CEC only if the HDMI HPD pin is high. */
#define CEC_CAP_NEEDS_HPD	(1 << 6)
/* Hardware can monitor CEC pin transitions */
#define CEC_CAP_MONITOR_PIN	(1 << 7)
/* CEC_ADAP_G_CONNECTOR_INFO is available */
#define CEC_CAP_CONNECTOR_INFO	(1 << 8)

/**
 * struct cec_caps - CEC capabilities structure.
 * @driver: name of the CEC device driver.
 * @name: name of the CEC device. @driver + @name must be unique.
 * @available_log_addrs: number of available logical addresses.
 * @capabilities: capabilities of the CEC adapter.
 * @version: version of the CEC adapter framework.
 */
struct cec_caps {
	char driver[32];
	char name[32];
	__u32 available_log_addrs;
	__u32 capabilities;
	__u32 version;
};

/**
 * struct cec_log_addrs - CEC logical addresses structure.
 * @log_addr: the claimed logical addresses. Set by the driver.
 * @log_addr_mask: current logical address mask. Set by the driver.
 * @cec_version: the CEC version that the adapter should implement. Set by the
 *	caller.
 * @num_log_addrs: how many logical addresses should be claimed. Set by the
 *	caller.
 * @vendor_id: the vendor ID of the device. Set by the caller.
 * @flags: flags.
 * @osd_name: the OSD name of the device. Set by the caller.
 * @primary_device_type: the primary device type for each logical address.
 *	Set by the caller.
 * @log_addr_type: the logical address types. Set by the caller.
 * @all_device_types: CEC 2.0: all device types represented by the logical
 *	address. Set by the caller.
 * @features:	CEC 2.0: The logical address features. Set by the caller.
 */
struct cec_log_addrs {
	__u8 log_addr[CEC_MAX_LOG_ADDRS];
	__u16 log_addr_mask;
	__u8 cec_version;
	__u8 num_log_addrs;
	__u32 vendor_id;
	__u32 flags;
	char osd_name[15];
	__u8 primary_device_type[CEC_MAX_LOG_ADDRS];
	__u8 log_addr_type[CEC_MAX_LOG_ADDRS];

	/* CEC 2.0 */
	__u8 all_device_types[CEC_MAX_LOG_ADDRS];
	__u8 features[CEC_MAX_LOG_ADDRS][12];
};

/* Allow a fallback to unregistered */
#define CEC_LOG_ADDRS_FL_ALLOW_UNREG_FALLBACK	(1 << 0)
/* Passthrough RC messages to the input subsystem */
#define CEC_LOG_ADDRS_FL_ALLOW_RC_PASSTHRU	(1 << 1)
/* CDC-Only device: supports only CDC messages */
#define CEC_LOG_ADDRS_FL_CDC_ONLY		(1 << 2)

/**
 * struct cec_drm_connector_info - tells which drm connector is
 * associated with the CEC adapter.
 * @card_no: drm card number
 * @connector_id: drm connector ID
 */
struct cec_drm_connector_info {
	__u32 card_no;
	__u32 connector_id;
};

#define CEC_CONNECTOR_TYPE_NO_CONNECTOR	0
#define CEC_CONNECTOR_TYPE_DRM		1

/**
 * struct cec_connector_info - tells if and which connector is
 * associated with the CEC adapter.
 * @type: connector type (if any)
 * @drm: drm connector info
 */
struct cec_connector_info {
	__u32 type;
	union {
		struct cec_drm_connector_info drm;
		__u32 raw[16];
	};
};

/* Events */

/* Event that occurs when the adapter state changes */
#define CEC_EVENT_STATE_CHANGE		1
/*
 * This event is sent when messages are lost because the application
 * didn't empty the message queue in time
 */
#define CEC_EVENT_LOST_MSGS		2
#define CEC_EVENT_PIN_CEC_LOW		3
#define CEC_EVENT_PIN_CEC_HIGH		4
#define CEC_EVENT_PIN_HPD_LOW		5
#define CEC_EVENT_PIN_HPD_HIGH		6
#define CEC_EVENT_PIN_5V_LOW		7
#define CEC_EVENT_PIN_5V_HIGH		8

#define CEC_EVENT_FL_INITIAL_STATE	(1 << 0)
#define CEC_EVENT_FL_DROPPED_EVENTS	(1 << 1)

/**
 * struct cec_event_state_change - used when the CEC adapter changes state.
 * @phys_addr: the current physical address
 * @log_addr_mask: the current logical address mask
 * @have_conn_info: if non-zero, then HDMI connector information is available.
 *	This field is only valid if CEC_CAP_CONNECTOR_INFO is set. If that
 *	capability is set and @have_conn_info is zero, then that indicates
 *	that the HDMI connector device is not instantiated, either because
 *	the HDMI driver is still configuring the device or because the HDMI
 *	device was unbound.
 */
struct cec_event_state_change {
	__u16 phys_addr;
	__u16 log_addr_mask;
	__u16 have_conn_info;
};

/**
 * struct cec_event_lost_msgs - tells you how many messages were lost.
 * @lost_msgs: how many messages were lost.
 */
struct cec_event_lost_msgs {
	__u32 lost_msgs;
};

/**
 * struct cec_event - CEC event structure
 * @ts: the timestamp of when the event was sent.
 * @event: the event.
 * array.
 * @state_change: the event payload for CEC_EVENT_STATE_CHANGE.
 * @lost_msgs: the event payload for CEC_EVENT_LOST_MSGS.
 * @raw: array to pad the union.
 */
struct cec_event {
	__u64 ts;
	__u32 event;
	__u32 flags;
	union {
		struct cec_event_state_change state_change;
		struct cec_event_lost_msgs lost_msgs;
		__u32 raw[16];
	};
};

/* ioctls */

/* Adapter capabilities */
#define CEC_ADAP_G_CAPS		_IOWR('a',  0, struct cec_caps)

/*
 * phys_addr is either 0 (if this is the CEC root device)
 * or a valid physical address obtained from the sink's EDID
 * as read by this CEC device (if this is a source device)
 * or a physical address obtained and modified from a sink
 * EDID and used for a sink CEC device.
 * If nothing is connected, then phys_addr is 0xffff.
 * See HDMI 1.4b, section 8.7 (Physical Address).
 *
 * The CEC_ADAP_S_PHYS_ADDR ioctl may not be available if that is handled
 * internally.
 */
#define CEC_ADAP_G_PHYS_ADDR	_IOR('a',  1, __u16)
#define CEC_ADAP_S_PHYS_ADDR	_IOW('a',  2, __u16)

/*
 * Configure the CEC adapter. It sets the device type and which
 * logical types it will try to claim. It will return which
 * logical addresses it could actually claim.
 * An error is returned if the adapter is disabled or if there
 * is no physical address assigned.
 */

#define CEC_ADAP_G_LOG_ADDRS	_IOR('a',  3, struct cec_log_addrs)
#define CEC_ADAP_S_LOG_ADDRS	_IOWR('a',  4, struct cec_log_addrs)

/* Transmit/receive a CEC command */
#define CEC_TRANSMIT		_IOWR('a',  5, struct cec_msg)
#define CEC_RECEIVE		_IOWR('a',  6, struct cec_msg)

/* Dequeue CEC events */
#define CEC_DQEVENT		_IOWR('a',  7, struct cec_event)

/*
 * Get and set the message handling mode for this filehandle.
 */
#define CEC_G_MODE		_IOR('a',  8, __u32)
#define CEC_S_MODE		_IOW('a',  9, __u32)

/* Get the connector info */
#define CEC_ADAP_G_CONNECTOR_INFO _IOR('a',  10, struct cec_connector_info)

/*
 * The remainder of this header defines all CEC messages and operands.
 * The format matters since it the cec-ctl utility parses it to generate
 * code for implementing all these messages.
 *
 * Comments ending with 'Feature' group messages for each feature.
 * If messages are part of multiple features, then the "Has also"
 * comment is used to list the previously defined messages that are
 * supported by the feature.
 *
 * Before operands are defined a comment is added that gives the
 * name of the operand and in brackets the variable name of the
 * corresponding argument in the cec-funcs.h function.
 */

/* Messages */

/* One Touch Play Feature */
#define CEC_MSG_ACTIVE_SOURCE				0x82
#define CEC_MSG_IMAGE_VIEW_ON				0x04
#define CEC_MSG_TEXT_VIEW_ON				0x0d


/* Routing Control Feature */

/*
 * Has also:
 *	CEC_MSG_ACTIVE_SOURCE
 */

#define CEC_MSG_INACTIVE_SOURCE				0x9d
#define CEC_MSG_REQUEST_ACTIVE_SOURCE			0x85
#define CEC_MSG_ROUTING_CHANGE				0x80
#define CEC_MSG_ROUTING_INFORMATION			0x81
#define CEC_MSG_SET_STREAM_PATH				0x86


/* Standby Feature */
#define CEC_MSG_STANDBY					0x36


/* One Touch Record Feature */
#define CEC_MSG_RECORD_OFF				0x0b
#define CEC_MSG_RECORD_ON				0x09
/* Record Source Type Operand (rec_src_type) */
#define CEC_OP_RECORD_SRC_OWN				1
#define CEC_OP_RECORD_SRC_DIGITAL			2
#define CEC_OP_RECORD_SRC_ANALOG			3
#define CEC_OP_RECORD_SRC_EXT_PLUG			4
#define CEC_OP_RECORD_SRC_EXT_PHYS_ADDR			5
/* Service Identification Method Operand (service_id_method) */
#define CEC_OP_SERVICE_ID_METHOD_BY_DIG_ID		0
#define CEC_OP_SERVICE_ID_METHOD_BY_CHANNEL		1
/* Digital Service Broadcast System Operand (dig_bcast_system) */
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_GEN	0x00
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_GEN	0x01
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_GEN		0x02
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_BS		0x08
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_CS		0x09
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ARIB_T		0x0a
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_CABLE	0x10
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_SAT	0x11
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_ATSC_T		0x12
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_C		0x18
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S		0x19
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_S2		0x1a
#define CEC_OP_DIG_SERVICE_BCAST_SYSTEM_DVB_T		0x1b
/* Analogue Broadcast Type Operand (ana_bcast_type) */
#define CEC_OP_ANA_BCAST_TYPE_CABLE			0
#define CEC_OP_ANA_BCAST_TYPE_SATELLITE			1
#define CEC_OP_ANA_BCAST_TYPE_TERRESTRIAL		2
/* Broadcast System Operand (bcast_system) */
#define CEC_OP_BCAST_SYSTEM_PAL_BG			0x00
#define CEC_OP_BCAST_SYSTEM_SECAM_LQ			0x01 /* SECAM L' */
#define CEC_OP_BCAST_SYSTEM_PAL_M			0x02
#define CEC_OP_BCAST_SYSTEM_NTSC_M			0x03
#define CEC_OP_BCAST_SYSTEM_PAL_I			0x04
#define CEC_OP_BCAST_SYSTEM_SECAM_DK			0x05
#define CEC_OP_BCAST_SYSTEM_SECAM_BG			0x06
#define CEC_OP_BCAST_SYSTEM_SECAM_L			0x07
#define CEC_OP_BCAST_SYSTEM_PAL_DK			0x08
#define CEC_OP_BCAST_SYSTEM_OTHER			0x1f
/* Channel Number Format Operand (channel_number_fmt) */
#define CEC_OP_CHANNEL_NUMBER_FMT_1_PART		0x01
#define CEC_OP_CHANNEL_NUMBER_FMT_2_PART		0x02

#define CEC_MSG_RECORD_STATUS				0x0a
/* Record Status Operand (rec_status) */
#define CEC_OP_RECORD_STATUS_CUR_SRC			0x01
#define CEC_OP_RECORD_STATUS_DIG_SERVICE		0x02
#define CEC_OP_RECORD_STATUS_ANA_SERVICE		0x03
#define CEC_OP_RECORD_STATUS_EXT_INPUT			0x04
#define CEC_OP_RECORD_STATUS_NO_DIG_SERVICE		0x05
#define CEC_OP_RECORD_STATUS_NO_ANA_SERVICE		0x06
#define CEC_OP_RECORD_STATUS_NO_SERVICE			0x07
#define CEC_OP_RECORD_STATUS_INVALID_EXT_PLUG		0x09
#define CEC_OP_RECORD_STATUS_INVALID_EXT_PHYS_ADDR	0x0a
#define CEC_OP_RECORD_STATUS_UNSUP_CA			0x0b
#define CEC_OP_RECORD_STATUS_NO_CA_ENTITLEMENTS		0x0c
#define CEC_OP_RECORD_STATUS_CANT_COPY_SRC		0x0d
#define CEC_OP_RECORD_STATUS_NO_MORE_COPIES		0x0e
#define CEC_OP_RECORD_STATUS_NO_MEDIA			0x10
#define CEC_OP_RECORD_STATUS_PLAYING			0x11
#define CEC_OP_RECORD_STATUS_ALREADY_RECORDING		0x12
#define CEC_OP_RECORD_STATUS_MEDIA_PROT			0x13
#define CEC_OP_RECORD_STATUS_NO_SIGNAL			0x14
#define CEC_OP_RECORD_STATUS_MEDIA_PROBLEM		0x15
#define CEC_OP_RECORD_STATUS_NO_SPACE			0x16
#define CEC_OP_RECORD_STATUS_PARENTAL_LOCK		0x17
#define CEC_OP_RECORD_STATUS_TERMINATED_OK		0x1a
#define CEC_OP_RECORD_STATUS_ALREADY_TERM		0x1b
#define CEC_OP_RECORD_STATUS_OTHER			0x1f

#define CEC_MSG_RECORD_TV_SCREEN			0x0f


/* Timer Programming Feature */
#define CEC_MSG_CLEAR_ANALOGUE_TIMER			0x33
/* Recording Sequence Operand (recording_seq) */
#define CEC_OP_REC_SEQ_SUNDAY				0x01
#define CEC_OP_REC_SEQ_MONDAY				0x02
#define CEC_OP_REC_SEQ_TUESDAY				0x04
#define CEC_OP_REC_SEQ_WEDNESDAY			0x08
#define CEC_OP_REC_SEQ_THURSDAY				0x10
#define CEC_OP_REC_SEQ_FRIDAY				0x20
#define CEC_OP_REC_SEQ_SATERDAY				0x40
#define CEC_OP_REC_SEQ_ONCE_ONLY			0x00

#define CEC_MSG_CLEAR_DIGITAL_TIMER			0x99

#define CEC_MSG_CLEAR_EXT_TIMER				0xa1
/* External Source Specifier Operand (ext_src_spec) */
#define CEC_OP_EXT_SRC_PLUG				0x04
#define CEC_OP_EXT_SRC_PHYS_ADDR			0x05

#define CEC_MSG_SET_ANALOGUE_TIMER			0x34
#define CEC_MSG_SET_DIGITAL_TIMER			0x97
#define CEC_MSG_SET_EXT_TIMER				0xa2

#define CEC_MSG_SET_TIMER_PROGRAM_TITLE			0x67
#define CEC_MSG_TIMER_CLEARED_STATUS			0x43
/* Timer Cleared Status Data Operand (timer_cleared_status) */
#define CEC_OP_TIMER_CLR_STAT_RECORDING			0x00
#define CEC_OP_TIMER_CLR_STAT_NO_MATCHING		0x01
#define CEC_OP_TIMER_CLR_STAT_NO_INFO			0x02
#define CEC_OP_TIMER_CLR_STAT_CLEARED			0x80

#define CEC_MSG_TIMER_STATUS				0x35
/* Timer Overlap Warning Operand (timer_overlap_warning) */
#define CEC_OP_TIMER_OVERLAP_WARNING_NO_OVERLAP		0
#define CEC_OP_TIMER_OVERLAP_WARNING_OVERLAP		1
/* Media Info Operand (media_info) */
#define CEC_OP_MEDIA_INFO_UNPROT_MEDIA			0
#define CEC_OP_MEDIA_INFO_PROT_MEDIA			1
#define CEC_OP_MEDIA_INFO_NO_MEDIA			2
/* Programmed Indicator Operand (prog_indicator) */
#define CEC_OP_PROG_IND_NOT_PROGRAMMED			0
#define CEC_OP_PROG_IND_PROGRAMMED			1
/* Programmed Info Operand (prog_info) */
#define CEC_OP_PROG_INFO_ENOUGH_SPACE			0x08
#define CEC_OP_PROG_INFO_NOT_ENOUGH_SPACE		0x09
#define CEC_OP_PROG_INFO_MIGHT_NOT_BE_ENOUGH_SPACE	0x0b
#define CEC_OP_PROG_INFO_NONE_AVAILABLE			0x0a
/* Not Programmed Error Info Operand (prog_error) */
#define CEC_OP_PROG_ERROR_NO_FREE_TIMER			0x01
#define CEC_OP_PROG_ERROR_DATE_OUT_OF_RANGE		0x02
#define CEC_OP_PROG_ERROR_REC_SEQ_ERROR			0x03
#define CEC_OP_PROG_ERROR_INV_EXT_PLUG			0x04
#define CEC_OP_PROG_ERROR_INV_EXT_PHYS_ADDR		0x05
#define CEC_OP_PROG_ERROR_CA_UNSUPP			0x06
#define CEC_OP_PROG_ERROR_INSUF_CA_ENTITLEMENTS		0x07
#define CEC_OP_PROG_ERROR_RESOLUTION_UNSUPP		0x08
#define CEC_OP_PROG_ERROR_PARENTAL_LOCK			0x09
#define CEC_OP_PROG_ERROR_CLOCK_FAILURE			0x0a
#define CEC_OP_PROG_ERROR_DUPLICATE			0x0e


/* System Information Feature */
#define CEC_MSG_CEC_VERSION				0x9e
/* CEC Version Operand (cec_version) */
#define CEC_OP_CEC_VERSION_1_3A				4
#define CEC_OP_CEC_VERSION_1_4				5
#define CEC_OP_CEC_VERSION_2_0				6

#define CEC_MSG_GET_CEC_VERSION				0x9f
#define CEC_MSG_GIVE_PHYSICAL_ADDR			0x83
#define CEC_MSG_GET_MENU_LANGUAGE			0x91
#define CEC_MSG_REPORT_PHYSICAL_ADDR			0x84
/* Primary Device Type Operand (prim_devtype) */
#define CEC_OP_PRIM_DEVTYPE_TV				0
#define CEC_OP_PRIM_DEVTYPE_RECORD			1
#define CEC_OP_PRIM_DEVTYPE_TUNER			3
#define CEC_OP_PRIM_DEVTYPE_PLAYBACK			4
#define CEC_OP_PRIM_DEVTYPE_AUDIOSYSTEM			5
#define CEC_OP_PRIM_DEVTYPE_SWITCH			6
#define CEC_OP_PRIM_DEVTYPE_PROCESSOR			7

#define CEC_MSG_SET_MENU_LANGUAGE			0x32
#define CEC_MSG_REPORT_FEATURES				0xa6	/* HDMI 2.0 */
/* All Device Types Operand (all_device_types) */
#define CEC_OP_ALL_DEVTYPE_TV				0x80
#define CEC_OP_ALL_DEVTYPE_RECORD			0x40
#define CEC_OP_ALL_DEVTYPE_TUNER			0x20
#define CEC_OP_ALL_DEVTYPE_PLAYBACK			0x10
#define CEC_OP_ALL_DEVTYPE_AUDIOSYSTEM			0x08
#define CEC_OP_ALL_DEVTYPE_SWITCH			0x04
/*
 * And if you wondering what happened to PROCESSOR devices: those should
 * be mapped to a SWITCH.
 */

/* Valid for RC Profile and Device Feature operands */
#define CEC_OP_FEAT_EXT					0x80	/* Extension bit */
/* RC Profile Operand (rc_profile) */
#define CEC_OP_FEAT_RC_TV_PROFILE_NONE			0x00
#define CEC_OP_FEAT_RC_TV_PROFILE_1			0x02
#define CEC_OP_FEAT_RC_TV_PROFILE_2			0x06
#define CEC_OP_FEAT_RC_TV_PROFILE_3			0x0a
#define CEC_OP_FEAT_RC_TV_PROFILE_4			0x0e
#define CEC_OP_FEAT_RC_SRC_HAS_DEV_ROOT_MENU		0x50
#define CEC_OP_FEAT_RC_SRC_HAS_DEV_SETUP_MENU		0x48
#define CEC_OP_FEAT_RC_SRC_HAS_CONTENTS_MENU		0x44
#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_TOP_MENU		0x42
#define CEC_OP_FEAT_RC_SRC_HAS_MEDIA_CONTEXT_MENU	0x41
/* Device Feature Operand (dev_features) */
#define CEC_OP_FEAT_DEV_HAS_RECORD_TV_SCREEN		0x40
#define CEC_OP_FEAT_DEV_HAS_SET_OSD_STRING		0x20
#define CEC_OP_FEAT_DEV_HAS_DECK_CONTROL		0x10
#define CEC_OP_FEAT_DEV_HAS_SET_AUDIO_RATE		0x08
#define CEC_OP_FEAT_DEV_SINK_HAS_ARC_TX			0x04
#define CEC_OP_FEAT_DEV_SOURCE_HAS_ARC_RX		0x02

#define CEC_MSG_GIVE_FEATURES				0xa5	/* HDMI 2.0 */


/* Deck Control Feature */
#define CEC_MSG_DECK_CONTROL				0x42
/* Deck Control Mode Operand (deck_control_mode) */
#define CEC_OP_DECK_CTL_MODE_SKIP_FWD			1
#define CEC_OP_DECK_CTL_MODE_SKIP_REV			2
#define CEC_OP_DECK_CTL_MODE_STOP			3
#define CEC_OP_DECK_CTL_MODE_EJECT			4

#define CEC_MSG_DECK_STATUS				0x1b
/* Deck Info Operand (deck_info) */
#define CEC_OP_DECK_INFO_PLAY				0x11
#define CEC_OP_DECK_INFO_RECORD				0x12
#define CEC_OP_DECK_INFO_PLAY_REV			0x13
#define CEC_OP_DECK_INFO_STILL				0x14
#define CEC_OP_DECK_INFO_SLOW				0x15
#define CEC_OP_DECK_INFO_SLOW_REV			0x16
#define CEC_OP_DECK_INFO_FAST_FWD			0x17
#define CEC_OP_DECK_INFO_FAST_REV			0x18
#define CEC_OP_DECK_INFO_NO_MEDIA			0x19
#define CEC_OP_DECK_INFO_STOP				0x1a
#define CEC_OP_DECK_INFO_SKIP_FWD			0x1b
#define CEC_OP_DECK_INFO_SKIP_REV			0x1c
#define CEC_OP_DECK_INFO_INDEX_SEARCH_FWD		0x1d
#define CEC_OP_DECK_INFO_INDEX_SEARCH_REV		0x1e
#define CEC_OP_DECK_INFO_OTHER				0x1f

#define CEC_MSG_GIVE_DECK_STATUS			0x1a
/* Status Request Operand (status_req) */
#define CEC_OP_STATUS_REQ_ON				1
#define CEC_OP_STATUS_REQ_OFF				2
#define CEC_OP_STATUS_REQ_ONCE				3

#define CEC_MSG_PLAY					0x41
/* Play Mode Operand (play_mode) */
#define CEC_OP_PLAY_MODE_PLAY_FWD			0x24
#define CEC_OP_PLAY_MODE_PLAY_REV			0x20
#define CEC_OP_PLAY_MODE_PLAY_STILL			0x25
#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MIN		0x05
#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MED		0x06
#define CEC_OP_PLAY_MODE_PLAY_FAST_FWD_MAX		0x07
#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MIN		0x09
#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MED		0x0a
#define CEC_OP_PLAY_MODE_PLAY_FAST_REV_MAX		0x0b
#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MIN		0x15
#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MED		0x16
#define CEC_OP_PLAY_MODE_PLAY_SLOW_FWD_MAX		0x17
#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MIN		0x19
#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MED		0x1a
#define CEC_OP_PLAY_MODE_PLAY_SLOW_REV_MAX		0x1b


/* Tuner Control Feature */
#define CEC_MSG_GIVE_TUNER_DEVICE_STATUS		0x08
#define CEC_MSG_SELECT_ANALOGUE_SERVICE			0x92
#define CEC_MSG_SELECT_DIGITAL_SERVICE			0x93
#define CEC_MSG_TUNER_DEVICE_STATUS			0x07
/* Recording Flag Operand (rec_flag) */
#define CEC_OP_REC_FLAG_NOT_USED			0
#define CEC_OP_REC_FLAG_USED				1
/* Tuner Display Info Operand (tuner_display_info) */
#define CEC_OP_TUNER_DISPLAY_INFO_DIGITAL		0
#define CEC_OP_TUNER_DISPLAY_INFO_NONE			1
#define CEC_OP_TUNER_DISPLAY_INFO_ANALOGUE		2

#define CEC_MSG_TUNER_STEP_DECREMENT			0x06
#define CEC_MSG_TUNER_STEP_INCREMENT			0x05


/* Vendor Specific Commands Feature */

/*
 * Has also:
 *	CEC_MSG_CEC_VERSION
 *	CEC_MSG_GET_CEC_VERSION
 */
#define CEC_MSG_DEVICE_VENDOR_ID			0x87
#define CEC_MSG_GIVE_DEVICE_VENDOR_ID			0x8c
#define CEC_MSG_VENDOR_COMMAND				0x89
#define CEC_MSG_VENDOR_COMMAND_WITH_ID			0xa0
#define CEC_MSG_VENDOR_REMOTE_BUTTON_DOWN		0x8a
#define CEC_MSG_VENDOR_REMOTE_BUTTON_UP			0x8b


/* OSD Display Feature */
#define CEC_MSG_SET_OSD_STRING				0x64
/* Display Control Operand (disp_ctl) */
#define CEC_OP_DISP_CTL_DEFAULT				0x00
#define CEC_OP_DISP_CTL_UNTIL_CLEARED			0x40
#define CEC_OP_DISP_CTL_CLEAR				0x80


/* Device OSD Transfer Feature */
#define CEC_MSG_GIVE_OSD_NAME				0x46
#define CEC_MSG_SET_OSD_NAME				0x47


/* Device Menu Control Feature */
#define CEC_MSG_MENU_REQUEST				0x8d
/* Menu Request Type Operand (menu_req) */
#define CEC_OP_MENU_REQUEST_ACTIVATE			0x00
#define CEC_OP_MENU_REQUEST_DEACTIVATE			0x01
#define CEC_OP_MENU_REQUEST_QUERY			0x02

#define CEC_MSG_MENU_STATUS				0x8e
/* Menu State Operand (menu_state) */
#define CEC_OP_MENU_STATE_ACTIVATED			0x00
#define CEC_OP_MENU_STATE_DEACTIVATED			0x01

#define CEC_MSG_USER_CONTROL_PRESSED			0x44
/* UI Command Operand (ui_cmd) */
#define CEC_OP_UI_CMD_SELECT				0x00
#define CEC_OP_UI_CMD_UP				0x01
#define CEC_OP_UI_CMD_DOWN				0x02
#define CEC_OP_UI_CMD_LEFT				0x03
#define CEC_OP_UI_CMD_RIGHT				0x04
#define CEC_OP_UI_CMD_RIGHT_UP				0x05
#define CEC_OP_UI_CMD_RIGHT_DOWN			0x06
#define CEC_OP_UI_CMD_LEFT_UP				0x07
#define CEC_OP_UI_CMD_LEFT_DOWN				0x08
#define CEC_OP_UI_CMD_DEVICE_ROOT_MENU			0x09
#define CEC_OP_UI_CMD_DEVICE_SETUP_MENU			0x0a
#define CEC_OP_UI_CMD_CONTENTS_MENU			0x0b
#define CEC_OP_UI_CMD_FAVORITE_MENU			0x0c
#define CEC_OP_UI_CMD_BACK				0x0d
#define CEC_OP_UI_CMD_MEDIA_TOP_MENU			0x10
#define CEC_OP_UI_CMD_MEDIA_CONTEXT_SENSITIVE_MENU	0x11
#define CEC_OP_UI_CMD_NUMBER_ENTRY_MODE			0x1d
#define CEC_OP_UI_CMD_NUMBER_11				0x1e
#define CEC_OP_UI_CMD_NUMBER_12				0x1f
#define CEC_OP_UI_CMD_NUMBER_0_OR_NUMBER_10		0x20
#define CEC_OP_UI_CMD_NUMBER_1				0x21
#define CEC_OP_UI_CMD_NUMBER_2				0x22
#define CEC_OP_UI_CMD_NUMBER_3				0x23
#define CEC_OP_UI_CMD_NUMBER_4				0x24
#define CEC_OP_UI_CMD_NUMBER_5				0x25
#define CEC_OP_UI_CMD_NUMBER_6				0x26
#define CEC_OP_UI_CMD_NUMBER_7				0x27
#define CEC_OP_UI_CMD_NUMBER_8				0x28
#define CEC_OP_UI_CMD_NUMBER_9				0x29
#define CEC_OP_UI_CMD_DOT				0x2a
#define CEC_OP_UI_CMD_ENTER				0x2b
#define CEC_OP_UI_CMD_CLEAR				0x2c
#define CEC_OP_UI_CMD_NEXT_FAVORITE			0x2f
#define CEC_OP_UI_CMD_CHANNEL_UP			0x30
#define CEC_OP_UI_CMD_CHANNEL_DOWN			0x31
#define CEC_OP_UI_CMD_PREVIOUS_CHANNEL			0x32
#define CEC_OP_UI_CMD_SOUND_SELECT			0x33
#define CEC_OP_UI_CMD_INPUT_SELECT			0x34
#define CEC_OP_UI_CMD_DISPLAY_INFORMATION		0x35
#define CEC_OP_UI_CMD_HELP				0x36
#define CEC_OP_UI_CMD_PAGE_UP				0x37
#define CEC_OP_UI_CMD_PAGE_DOWN				0x38
#define CEC_OP_UI_CMD_POWER				0x40
#define CEC_OP_UI_CMD_VOLUME_UP				0x41
#define CEC_OP_UI_CMD_VOLUME_DOWN			0x42
#define CEC_OP_UI_CMD_MUTE				0x43
#define CEC_OP_UI_CMD_PLAY				0x44
#define CEC_OP_UI_CMD_STOP				0x45
#define CEC_OP_UI_CMD_PAUSE				0x46
#define CEC_OP_UI_CMD_RECORD				0x47
#define CEC_OP_UI_CMD_REWIND				0x48
#define CEC_OP_UI_CMD_FAST_FORWARD			0x49
#define CEC_OP_UI_CMD_EJECT				0x4a
#define CEC_OP_UI_CMD_SKIP_FORWARD			0x4b
#define CEC_OP_UI_CMD_SKIP_BACKWARD			0x4c
#define CEC_OP_UI_CMD_STOP_RECORD			0x4d
#define CEC_OP_UI_CMD_PAUSE_RECORD			0x4e
#define CEC_OP_UI_CMD_ANGLE				0x50
#define CEC_OP_UI_CMD_SUB_PICTURE			0x51
#define CEC_OP_UI_CMD_VIDEO_ON_DEMAND			0x52
#define CEC_OP_UI_CMD_ELECTRONIC_PROGRAM_GUIDE		0x53
#define CEC_OP_UI_CMD_TIMER_PROGRAMMING			0x54
#define CEC_OP_UI_CMD_INITIAL_CONFIGURATION		0x55
#define CEC_OP_UI_CMD_SELECT_BROADCAST_TYPE		0x56
#define CEC_OP_UI_CMD_SELECT_SOUND_PRESENTATION		0x57
#define CEC_OP_UI_CMD_AUDIO_DESCRIPTION			0x58
#define CEC_OP_UI_CMD_INTERNET				0x59
#define CEC_OP_UI_CMD_3D_MODE				0x5a
#define CEC_OP_UI_CMD_PLAY_FUNCTION			0x60
#define CEC_OP_UI_CMD_PAUSE_PLAY_FUNCTION		0x61
#define CEC_OP_UI_CMD_RECORD_FUNCTION			0x62
#define CEC_OP_UI_CMD_PAUSE_RECORD_FUNCTION		0x63
#define CEC_OP_UI_CMD_STOP_FUNCTION			0x64
#define CEC_OP_UI_CMD_MUTE_FUNCTION			0x65
#define CEC_OP_UI_CMD_RESTORE_VOLUME_FUNCTION		0x66
#define CEC_OP_UI_CMD_TUNE_FUNCTION			0x67
#define CEC_OP_UI_CMD_SELECT_MEDIA_FUNCTION		0x68
#define CEC_OP_UI_CMD_SELECT_AV_INPUT_FUNCTION		0x69
#define CEC_OP_UI_CMD_SELECT_AUDIO_INPUT_FUNCTION	0x6a
#define CEC_OP_UI_CMD_POWER_TOGGLE_FUNCTION		0x6b
#define CEC_OP_UI_CMD_POWER_OFF_FUNCTION		0x6c
#define CEC_OP_UI_CMD_POWER_ON_FUNCTION			0x6d
#define CEC_OP_UI_CMD_F1_BLUE				0x71
#define CEC_OP_UI_CMD_F2_RED				0x72
#define CEC_OP_UI_CMD_F3_GREEN				0x73
#define CEC_OP_UI_CMD_F4_YELLOW				0x74
#define CEC_OP_UI_CMD_F5				0x75
#define CEC_OP_UI_CMD_DATA				0x76
/* UI Broadcast Type Operand (ui_bcast_type) */
#define CEC_OP_UI_BCAST_TYPE_TOGGLE_ALL			0x00
#define CEC_OP_UI_BCAST_TYPE_TOGGLE_DIG_ANA		0x01
#define CEC_OP_UI_BCAST_TYPE_ANALOGUE			0x10
#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_T			0x20
#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_CABLE		0x30
#define CEC_OP_UI_BCAST_TYPE_ANALOGUE_SAT		0x40
#define CEC_OP_UI_BCAST_TYPE_DIGITAL			0x50
#define CEC_OP_UI_BCAST_TYPE_DIGITAL_T			0x60
#define CEC_OP_UI_BCAST_TYPE_DIGITAL_CABLE		0x70
#define CEC_OP_UI_BCAST_TYPE_DIGITAL_SAT		0x80
#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT		0x90
#define CEC_OP_UI_BCAST_TYPE_DIGITAL_COM_SAT2		0x91
#define CEC_OP_UI_BCAST_TYPE_IP				0xa0
/* UI Sound Presentation Control Operand (ui_snd_pres_ctl) */
#define CEC_OP_UI_SND_PRES_CTL_DUAL_MONO		0x10
#define CEC_OP_UI_SND_PRES_CTL_KARAOKE			0x20
#define CEC_OP_UI_SND_PRES_CTL_DOWNMIX			0x80
#define CEC_OP_UI_SND_PRES_CTL_REVERB			0x90
#define CEC_OP_UI_SND_PRES_CTL_EQUALIZER		0xa0
#define CEC_OP_UI_SND_PRES_CTL_BASS_UP			0xb1
#define CEC_OP_UI_SND_PRES_CTL_BASS_NEUTRAL		0xb2
#define CEC_OP_UI_SND_PRES_CTL_BASS_DOWN		0xb3
#define CEC_OP_UI_SND_PRES_CTL_TREBLE_UP		0xc1
#define CEC_OP_UI_SND_PRES_CTL_TREBLE_NEUTRAL		0xc2
#define CEC_OP_UI_SND_PRES_CTL_TREBLE_DOWN		0xc3

#define CEC_MSG_USER_CONTROL_RELEASED			0x45


/* Remote Control Passthrough Feature */

/*
 * Has also:
 *	CEC_MSG_USER_CONTROL_PRESSED
 *	CEC_MSG_USER_CONTROL_RELEASED
 */


/* Power Status Feature */
#define CEC_MSG_GIVE_DEVICE_POWER_STATUS		0x8f
#define CEC_MSG_REPORT_POWER_STATUS			0x90
/* Power Status Operand (pwr_state) */
#define CEC_OP_POWER_STATUS_ON				0
#define CEC_OP_POWER_STATUS_STANDBY			1
#define CEC_OP_POWER_STATUS_TO_ON			2
#define CEC_OP_POWER_STATUS_TO_STANDBY			3


/* General Protocol Messages */
#define CEC_MSG_FEATURE_ABORT				0x00
/* Abort Reason Operand (reason) */
#define CEC_OP_ABORT_UNRECOGNIZED_OP			0
#define CEC_OP_ABORT_INCORRECT_MODE			1
#define CEC_OP_ABORT_NO_SOURCE				2
#define CEC_OP_ABORT_INVALID_OP				3
#define CEC_OP_ABORT_REFUSED				4
#define CEC_OP_ABORT_UNDETERMINED			5

#define CEC_MSG_ABORT					0xff


/* System Audio Control Feature */

/*
 * Has also:
 *	CEC_MSG_USER_CONTROL_PRESSED
 *	CEC_MSG_USER_CONTROL_RELEASED
 */
#define CEC_MSG_GIVE_AUDIO_STATUS			0x71
#define CEC_MSG_GIVE_SYSTEM_AUDIO_MODE_STATUS		0x7d
#define CEC_MSG_REPORT_AUDIO_STATUS			0x7a
/* Audio Mute Status Operand (aud_mute_status) */
#define CEC_OP_AUD_MUTE_STATUS_OFF			0
#define CEC_OP_AUD_MUTE_STATUS_ON			1

#define CEC_MSG_REPORT_SHORT_AUDIO_DESCRIPTOR		0xa3
#define CEC_MSG_REQUEST_SHORT_AUDIO_DESCRIPTOR		0xa4
#define CEC_MSG_SET_SYSTEM_AUDIO_MODE			0x72
/* System Audio Status Operand (sys_aud_status) */
#define CEC_OP_SYS_AUD_STATUS_OFF			0
#define CEC_OP_SYS_AUD_STATUS_ON			1

#define CEC_MSG_SYSTEM_AUDIO_MODE_REQUEST		0x70
#define CEC_MSG_SYSTEM_AUDIO_MODE_STATUS		0x7e
/* Audio Format ID Operand (audio_format_id) */
#define CEC_OP_AUD_FMT_ID_CEA861			0
#define CEC_OP_AUD_FMT_ID_CEA861_CXT			1


/* Audio Rate Control Feature */
#define CEC_MSG_SET_AUDIO_RATE				0x9a
/* Audio Rate Operand (audio_rate) */
#define CEC_OP_AUD_RATE_OFF				0
#define CEC_OP_AUD_RATE_WIDE_STD			1
#define CEC_OP_AUD_RATE_WIDE_FAST			2
#define CEC_OP_AUD_RATE_WIDE_SLOW			3
#define CEC_OP_AUD_RATE_NARROW_STD			4
#define CEC_OP_AUD_RATE_NARROW_FAST			5
#define CEC_OP_AUD_RATE_NARROW_SLOW			6


/* Audio Return Channel Control Feature */
#define CEC_MSG_INITIATE_ARC				0xc0
#define CEC_MSG_REPORT_ARC_INITIATED			0xc1
#define CEC_MSG_REPORT_ARC_TERMINATED			0xc2
#define CEC_MSG_REQUEST_ARC_INITIATION			0xc3
#define CEC_MSG_REQUEST_ARC_TERMINATION			0xc4
#define CEC_MSG_TERMINATE_ARC				0xc5


/* Dynamic Audio Lipsync Feature */
/* Only for CEC 2.0 and up */
#define CEC_MSG_REQUEST_CURRENT_LATENCY			0xa7
#define CEC_MSG_REPORT_CURRENT_LATENCY			0xa8
/* Low Latency Mode Operand (low_latency_mode) */
#define CEC_OP_LOW_LATENCY_MODE_OFF			0
#define CEC_OP_LOW_LATENCY_MODE_ON			1
/* Audio Output Compensated Operand (audio_out_compensated) */
#define CEC_OP_AUD_OUT_COMPENSATED_NA			0
#define CEC_OP_AUD_OUT_COMPENSATED_DELAY		1
#define CEC_OP_AUD_OUT_COMPENSATED_NO_DELAY		2
#define CEC_OP_AUD_OUT_COMPENSATED_PARTIAL_DELAY	3


/* Capability Discovery and Control Feature */
#define CEC_MSG_CDC_MESSAGE				0xf8
/* Ethernet-over-HDMI: nobody ever does this... */
#define CEC_MSG_CDC_HEC_INQUIRE_STATE			0x00
#define CEC_MSG_CDC_HEC_REPORT_STATE			0x01
/* HEC Functionality State Operand (hec_func_state) */
#define CEC_OP_HEC_FUNC_STATE_NOT_SUPPORTED		0
#define CEC_OP_HEC_FUNC_STATE_INACTIVE			1
#define CEC_OP_HEC_FUNC_STATE_ACTIVE			2
#define CEC_OP_HEC_FUNC_STATE_ACTIVATION_FIELD		3
/* Host Functionality State Operand (host_func_state) */
#define CEC_OP_HOST_FUNC_STATE_NOT_SUPPORTED		0
#define CEC_OP_HOST_FUNC_STATE_INACTIVE			1
#define CEC_OP_HOST_FUNC_STATE_ACTIVE			2
/* ENC Functionality State Operand (enc_func_state) */
#define CEC_OP_ENC_FUNC_STATE_EXT_CON_NOT_SUPPORTED	0
#define CEC_OP_ENC_FUNC_STATE_EXT_CON_INACTIVE		1
#define CEC_OP_ENC_FUNC_STATE_EXT_CON_ACTIVE		2
/* CDC Error Code Operand (cdc_errcode) */
#define CEC_OP_CDC_ERROR_CODE_NONE			0
#define CEC_OP_CDC_ERROR_CODE_CAP_UNSUPPORTED		1
#define CEC_OP_CDC_ERROR_CODE_WRONG_STATE		2
#define CEC_OP_CDC_ERROR_CODE_OTHER			3
/* HEC Support Operand (hec_support) */
#define CEC_OP_HEC_SUPPORT_NO				0
#define CEC_OP_HEC_SUPPORT_YES				1
/* HEC Activation Operand (hec_activation) */
#define CEC_OP_HEC_ACTIVATION_ON			0
#define CEC_OP_HEC_ACTIVATION_OFF			1

#define CEC_MSG_CDC_HEC_SET_STATE_ADJACENT		0x02
#define CEC_MSG_CDC_HEC_SET_STATE			0x03
/* HEC Set State Operand (hec_set_state) */
#define CEC_OP_HEC_SET_STATE_DEACTIVATE			0
#define CEC_OP_HEC_SET_STATE_ACTIVATE			1

#define CEC_MSG_CDC_HEC_REQUEST_DEACTIVATION		0x04
#define CEC_MSG_CDC_HEC_NOTIFY_ALIVE			0x05
#define CEC_MSG_CDC_HEC_DISCOVER			0x06
/* Hotplug Detect messages */
#define CEC_MSG_CDC_HPD_SET_STATE			0x10
/* HPD State Operand (hpd_state) */
#define CEC_OP_HPD_STATE_CP_EDID_DISABLE		0
#define CEC_OP_HPD_STATE_CP_EDID_ENABLE			1
#define CEC_OP_HPD_STATE_CP_EDID_DISABLE_ENABLE		2
#define CEC_OP_HPD_STATE_EDID_DISABLE			3
#define CEC_OP_HPD_STATE_EDID_ENABLE			4
#define CEC_OP_HPD_STATE_EDID_DISABLE_ENABLE		5
#define CEC_MSG_CDC_HPD_REPORT_STATE			0x11
/* HPD Error Code Operand (hpd_error) */
#define CEC_OP_HPD_ERROR_NONE				0
#define CEC_OP_HPD_ERROR_INITIATOR_NOT_CAPABLE		1
#define CEC_OP_HPD_ERROR_INITIATOR_WRONG_STATE		2
#define CEC_OP_HPD_ERROR_OTHER				3
#define CEC_OP_HPD_ERROR_NONE_NO_VIDEO			4

/* End of Messages */

/* Helper functions to identify the 'special' CEC devices */

static __inline__ int cec_is_2nd_tv(const struct cec_log_addrs *las)
{
	/*
	 * It is a second TV if the logical address is 14 or 15 and the
	 * primary device type is a TV.
	 */
	return las->num_log_addrs &&
	       las->log_addr[0] >= CEC_LOG_ADDR_SPECIFIC &&
	       las->primary_device_type[0] == CEC_OP_PRIM_DEVTYPE_TV;
}

static __inline__ int cec_is_processor(const struct cec_log_addrs *las)
{
	/*
	 * It is a processor if the logical address is 12-15 and the
	 * primary device type is a Processor.
	 */
	return las->num_log_addrs &&
	       las->log_addr[0] >= CEC_LOG_ADDR_BACKUP_1 &&
	       las->primary_device_type[0] == CEC_OP_PRIM_DEVTYPE_PROCESSOR;
}

static __inline__ int cec_is_switch(const struct cec_log_addrs *las)
{
	/*
	 * It is a switch if the logical address is 15 and the
	 * primary device type is a Switch and the CDC-Only flag is not set.
	 */
	return las->num_log_addrs == 1 &&
	       las->log_addr[0] == CEC_LOG_ADDR_UNREGISTERED &&
	       las->primary_device_type[0] == CEC_OP_PRIM_DEVTYPE_SWITCH &&
	       !(las->flags & CEC_LOG_ADDRS_FL_CDC_ONLY);
}

static __inline__ int cec_is_cdc_only(const struct cec_log_addrs *las)
{
	/*
	 * It is a CDC-only device if the logical address is 15 and the
	 * primary device type is a Switch and the CDC-Only flag is set.
	 */
	return las->num_log_addrs == 1 &&
	       las->log_addr[0] == CEC_LOG_ADDR_UNREGISTERED &&
	       las->primary_device_type[0] == CEC_OP_PRIM_DEVTYPE_SWITCH &&
	       (las->flags & CEC_LOG_ADDRS_FL_CDC_ONLY);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* SPDX-License-Identifier: LGPL-2.1 WITH Linux-syscall-note */
/* cgroupstats.h - exporting per-cgroup statistics
 *
 * Copyright IBM Corporation, 2007
 * Author Balbir Singh <balbir@linux.vnet.ibm.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2.1 of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it would be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef _LINUX_CGROUPSTATS_H
#define _LINUX_CGROUPSTATS_H

#include <linux/types.h>
#include <linux/taskstats.h>

/*
 * Data shared between user space and kernel space on a per cgroup
 * basis. This data is shared using taskstats.
 *
 * Most of these states are derived by looking at the task->state value
 * For the nr_io_wait state, a flag in the delay accounting structure
 * indicates that the task is waiting on IO
 *
 * Each member is aligned to a 8 byte boundary.
 */
struct cgroupstats {
	__u64	nr_sleeping;		/* Number of tasks sleeping */
	__u64	nr_running;		/* Number of tasks running */
	__u64	nr_stopped;		/* Number of tasks in stopped state */
	__u64	nr_uninterruptible;	/* Number of tasks in uninterruptible */
					/* state */
	__u64	nr_io_wait;		/* Number of tasks waiting on IO */
};

/*
 * Commands sent from userspace
 * Not versioned. New commands should only be inserted at the enum's end
 * prior to __CGROUPSTATS_CMD_MAX
 */

enum {
	CGROUPSTATS_CMD_UNSPEC = __TASKSTATS_CMD_MAX,	/* Reserved */
	CGROUPSTATS_CMD_GET,		/* user->kernel request/get-response */
	CGROUPSTATS_CMD_NEW,		/* kernel->user event */
	__CGROUPSTATS_CMD_MAX,
};

#define CGROUPSTATS_CMD_MAX (__CGROUPSTATS_CMD_MAX - 1)

enum {
	CGROUPSTATS_TYPE_UNSPEC = 0,	/* Reserved */
	CGROUPSTATS_TYPE_CGROUP_STATS,	/* contains name + stats */
	__CGROUPSTATS_TYPE_MAX,
};

#define CGROUPSTATS_TYPE_MAX (__CGROUPSTATS_TYPE_MAX - 1)

enum {
	CGROUPSTATS_CMD_ATTR_UNSPEC = 0,
	CGROUPSTATS_CMD_ATTR_FD,
	__CGROUPSTATS_CMD_ATTR_MAX,
};

#define CGROUPSTATS_CMD_ATTR_MAX (__CGROUPSTATS_CMD_ATTR_MAX - 1)

#endif /* _LINUX_CGROUPSTATS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * ioctl interface for the scsi media changer driver
 */

#ifndef _LINUX_CHIO_H
#define _LINUX_CHIO_H

/* changer element types */
#define CHET_MT   0	/* media transport element (robot) */
#define CHET_ST   1	/* storage element (media slots) */
#define CHET_IE   2	/* import/export element */
#define CHET_DT   3	/* data transfer element (tape/cdrom/whatever) */
#define CHET_V1   4	/* vendor specific #1 */
#define CHET_V2   5	/* vendor specific #2 */
#define CHET_V3   6	/* vendor specific #3 */
#define CHET_V4   7	/* vendor specific #4 */


/*
 * CHIOGPARAMS
 *    query changer properties
 *
 * CHIOVGPARAMS
 *    query vendor-specific element types
 *
 *    accessing elements works by specifing type and unit of the element.
 *    for example, storage elements are addressed with type = CHET_ST and
 *    unit = 0 .. cp_nslots-1
 *
 */
struct changer_params {
	int cp_curpicker;  /* current transport element */
	int cp_npickers;   /* number of transport elements      (CHET_MT) */
	int cp_nslots;     /* number of storage elements        (CHET_ST) */
	int cp_nportals;   /* number of import/export elements  (CHET_IE) */
	int cp_ndrives;    /* number of data transfer elements  (CHET_DT) */
};
struct changer_vendor_params {
	int  cvp_n1;       /* number of vendor specific elems   (CHET_V1) */
	char cvp_label1[16];
	int  cvp_n2;       /* number of vendor specific elems   (CHET_V2) */
	char cvp_label2[16];
	int  cvp_n3;       /* number of vendor specific elems   (CHET_V3) */
	char cvp_label3[16];
	int  cvp_n4;       /* number of vendor specific elems   (CHET_V4) */
	char cvp_label4[16];
	int  reserved[8];
};


/*
 * CHIOMOVE
 *    move a medium from one element to another
 */
struct changer_move {
	int cm_fromtype;	/* type/unit of source element */
	int cm_fromunit;	
	int cm_totype;	/* type/unit of destination element */
	int cm_tounit;
	int cm_flags;
};
#define CM_INVERT   1   /* flag: rotate media (for double-sided like MOD) */


/*
 * CHIOEXCHANGE
 *    move one medium from element #1 to element #2,
 *    and another one from element #2 to element #3.
 *    element #1 and #3 are allowed to be identical.
 */
struct changer_exchange {
	int ce_srctype;	    /* type/unit of element #1 */
	int ce_srcunit;
	int ce_fdsttype;    /* type/unit of element #2 */
	int ce_fdstunit;
	int ce_sdsttype;    /* type/unit of element #3 */
	int ce_sdstunit;
	int ce_flags;
};
#define CE_INVERT1   1
#define CE_INVERT2   2


/*
 * CHIOPOSITION
 *    move the transport element (robot arm) to a specific element.
 */
struct changer_position {
	int cp_type;
	int cp_unit;
	int cp_flags;
};
#define CP_INVERT   1


/*
 * CHIOGSTATUS
 *    get element status for all elements of a specific type
 */
struct changer_element_status {
	int             ces_type;
	unsigned char   *ces_data;
};
#define CESTATUS_FULL     0x01 /* full */
#define CESTATUS_IMPEXP   0x02	/* media was imported (inserted by sysop) */
#define CESTATUS_EXCEPT   0x04	/* error condition */
#define CESTATUS_ACCESS   0x08	/* access allowed */
#define CESTATUS_EXENAB   0x10	/* element can export media */
#define CESTATUS_INENAB   0x20	/* element can import media */


/*
 * CHIOGELEM
 *    get more detailed status information for a single element
 */
struct changer_get_element {
	int	cge_type;	 /* type/unit */
	int	cge_unit;
	int	cge_status;      /* status */
	int     cge_errno;       /* errno */
	int     cge_srctype;     /* source element of the last move/exchange */
	int     cge_srcunit;
	int     cge_id;          /* scsi id  (for data transfer elements) */
	int     cge_lun;         /* scsi lun (for data transfer elements) */
	char    cge_pvoltag[36]; /* primary volume tag */
	char    cge_avoltag[36]; /* alternate volume tag */
	int     cge_flags;
};
/* flags */
#define CGE_ERRNO     0x01       /* errno available       */
#define CGE_INVERT    0x02       /* media inverted        */
#define CGE_SRC       0x04       /* media src available   */
#define CGE_IDLUN     0x08       /* ID+LUN available      */
#define CGE_PVOLTAG   0x10       /* primary volume tag available */
#define CGE_AVOLTAG   0x20       /* alternate volume tag available */


/*
 * CHIOSVOLTAG
 *    set volume tag
 */
struct changer_set_voltag {
	int	csv_type;	 /* type/unit */
	int	csv_unit;
	char    csv_voltag[36];  /* volume tag */
	int     csv_flags;
};
#define CSV_PVOLTAG   0x01       /* primary volume tag */
#define CSV_AVOLTAG   0x02       /* alternate volume tag */
#define CSV_CLEARTAG  0x04       /* clear volume tag */

/* ioctls */
#define CHIOMOVE       _IOW('c', 1,struct changer_move)
#define CHIOEXCHANGE   _IOW('c', 2,struct changer_exchange)
#define CHIOPOSITION   _IOW('c', 3,struct changer_position)
#define CHIOGPICKER    _IOR('c', 4,int)                        /* not impl. */
#define CHIOSPICKER    _IOW('c', 5,int)                        /* not impl. */
#define CHIOGPARAMS    _IOR('c', 6,struct changer_params)
#define CHIOGSTATUS    _IOW('c', 8,struct changer_element_status)
#define CHIOGELEM      _IOW('c',16,struct changer_get_element)
#define CHIOINITELEM   _IO('c',17)
#define CHIOSVOLTAG    _IOW('c',18,struct changer_set_voltag)
#define CHIOGVPARAMS   _IOR('c',19,struct changer_vendor_params)

#endif /* _LINUX_CHIO_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              á
   .   Œ
   ..  â
  ècifs_mount.h                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* SPDX-License-Identifier: LGPL-2.1+ WITH Linux-syscall-note */
/*
 *   include/uapi/linux/cifs/cifs_mount.h
 *
 *   Author(s): Scott Lovenberg (scott.lovenberg@gmail.com)
 *
 *   This library is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Lesser General Public License as published
 *   by the Free Software Foundation; either version 2.1 of the License, or
 *   (at your option) any later version.
 *
 *   This library is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
 *   the GNU Lesser General Public License for more details.
 */
#ifndef _CIFS_MOUNT_H
#define _CIFS_MOUNT_H

/* Max string lengths for cifs mounting options. */
#define CIFS_MAX_DOMAINNAME_LEN 256 /* max fully qualified domain name */
#define CIFS_MAX_USERNAME_LEN   256 /* reasonable max for current servers */
#define CIFS_MAX_PASSWORD_LEN   512 /* Windows max seems to be 256 wide chars */
#define CIFS_MAX_SHARE_LEN      256 /* reasonable max share name length */
#define CIFS_NI_MAXHOST        1024 /* max host name length (256 * 4 bytes) */


#endif /* _CIFS_MOUNT_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _CM4000_H_
#define _CM4000_H_

#include <linux/types.h>
#include <linux/ioctl.h>

#define	MAX_ATR			33

#define	CM4000_MAX_DEV		4

/* those two structures are passed via ioctl() from/to userspace.  They are
 * used by existing userspace programs, so I kepth the awkward "bIFSD" naming
 * not to break compilation of userspace apps. -HW */

typedef struct atreq {
	__s32 atr_len;
	unsigned char atr[64];
	__s32 power_act;
	unsigned char bIFSD;
	unsigned char bIFSC;
} atreq_t;


/* what is particularly stupid in the original driver is the arch-dependent
 * member sizes. This leads to CONFIG_COMPAT breakage, since 32bit userspace
 * will lay out the structure members differently than the 64bit kernel.
 *
 * I've changed "ptsreq.protocol" from "unsigned long" to "__u32".
 * On 32bit this will make no difference.  With 64bit kernels, it will make
 * 32bit apps work, too.
 */

typedef struct ptsreq {
	__u32 protocol; /*T=0: 2^0, T=1:  2^1*/
 	unsigned char flags;
 	unsigned char pts1;
 	unsigned char pts2;
	unsigned char pts3;
} ptsreq_t;

#define	CM_IOC_MAGIC		'c'
#define	CM_IOC_MAXNR	        255

#define	CM_IOCGSTATUS		_IOR (CM_IOC_MAGIC, 0, unsigned char *)
#define	CM_IOCGATR		_IOWR(CM_IOC_MAGIC, 1, atreq_t *)
#define	CM_IOCSPTS		_IOW (CM_IOC_MAGIC, 2, ptsreq_t *)
#define	CM_IOCSRDR		_IO  (CM_IOC_MAGIC, 3)
#define CM_IOCARDOFF            _IO  (CM_IOC_MAGIC, 4)

#define CM_IOSDBGLVL            _IOW(CM_IOC_MAGIC, 250, int*)

/* card and device states */
#define	CM_CARD_INSERTED		0x01
#define	CM_CARD_POWERED			0x02
#define	CM_ATR_PRESENT			0x04
#define	CM_ATR_VALID	 		0x08
#define	CM_STATE_VALID			0x0f
/* extra info only from CM4000 */
#define	CM_NO_READER			0x10
#define	CM_BAD_CARD			0x20


#endif /* _CM4000_H_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* SPDX-License-Identifier: LGPL-2.1 WITH Linux-syscall-note */
/*
 * cn_proc.h - process events connector
 *
 * Copyright (C) Matt Helsley, IBM Corp. 2005
 * Based on cn_fork.h by Nguyen Anh Quynh and Guillaume Thouvenin
 * Copyright (C) 2005 Nguyen Anh Quynh <aquynh@gmail.com>
 * Copyright (C) 2005 Guillaume Thouvenin <guillaume.thouvenin@bull.net>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of version 2.1 of the GNU Lesser General Public License
 * as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it would be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#ifndef CN_PROC_H
#define CN_PROC_H

#include <linux/types.h>

/*
 * Userspace sends this enum to register with the kernel that it is listening
 * for events on the connector.
 */
enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2
};

/*
 * From the user's point of view, the process
 * ID is the thread group ID and thread ID is the internal
 * kernel "pid". So, fields are assigned as follow:
 *
 *  In user space     -  In  kernel space
 *
 * parent process ID  =  parent->tgid
 * parent thread  ID  =  parent->pid
 * child  process ID  =  child->tgid
 * child  thread  ID  =  child->pid
 */

struct proc_event {
	enum what {
		/* Use successive bits so the enums can be used to record
		 * sets of events as well
		 */
		PROC_EVENT_NONE = 0x00000000,
		PROC_EVENT_FORK = 0x00000001,
		PROC_EVENT_EXEC = 0x00000002,
		PROC_EVENT_UID  = 0x00000004,
		PROC_EVENT_GID  = 0x00000040,
		PROC_EVENT_SID  = 0x00000080,
		PROC_EVENT_PTRACE = 0x00000100,
		PROC_EVENT_COMM = 0x00000200,
		/* "next" should be 0x00000400 */
		/* "last" is the last process event: exit,
		 * while "next to last" is coredumping event */
		PROC_EVENT_COREDUMP = 0x40000000,
		PROC_EVENT_EXIT = 0x80000000
	} what;
	__u32 cpu;
	__u64 __attribute__((aligned(8))) timestamp_ns;
		/* Number of nano seconds since system boot */
	union { /* must be last field of proc_event struct */
		struct {
			__u32 err;
		} ack;

		struct fork_proc_event {
			__kernel_pid_t parent_pid;
			__kernel_pid_t parent_tgid;
			__kernel_pid_t child_pid;
			__kernel_pid_t child_tgid;
		} fork;

		struct exec_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
		} exec;

		struct id_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			union {
				__u32 ruid; /* task uid */
				__u32 rgid; /* task gid */
			} r;
			union {
				__u32 euid;
				__u32 egid;
			} e;
		} id;

		struct sid_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
		} sid;

		struct ptrace_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			__kernel_pid_t tracer_pid;
			__kernel_pid_t tracer_tgid;
		} ptrace;

		struct comm_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			char           comm[16];
		} comm;

		struct coredump_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			__kernel_pid_t parent_pid;
			__kernel_pid_t parent_tgid;
		} coredump;

		struct exit_proc_event {
			__kernel_pid_t process_pid;
			__kernel_pid_t process_tgid;
			__u32 exit_code, exit_signal;
			__kernel_pid_t parent_pid;
			__kernel_pid_t parent_tgid;
		} exit;

	} event_data;
};

#endif /* CN_PROC_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* 
   You may distribute this file under either of the two licenses that
   follow at your discretion.
*/

/* BLURB lgpl

                           Coda File System
                              Release 5

          Copyright (c) 1987-1999 Carnegie Mellon University
                  Additional copyrights listed below

This code is distributed "AS IS" without warranty of any kind under
the terms of the GNU Library General Public Licence Version 2, as
shown in the file LICENSE, or under the license shown below. The
technical and financial contributors to Coda are listed in the file
CREDITS.

                        Additional copyrights 
*/

/*

            Coda: an Experimental Distributed File System
                             Release 4.0

          Copyright (c) 1987-1999 Carnegie Mellon University
                         All Rights Reserved

Permission  to  use, copy, modify and distribute this software and its
documentation is hereby granted,  provided  that  both  the  copyright
notice  and  this  permission  notice  appear  in  all  copies  of the
software, derivative works or  modified  versions,  and  any  portions
thereof, and that both notices appear in supporting documentation, and
that credit is given to Carnegie Mellon University  in  all  documents
and publicity pertaining to direct or indirect use of this code or its
derivatives.

CODA IS AN EXPERIMENTAL SOFTWARE SYSTEM AND IS  KNOWN  TO  HAVE  BUGS,
SOME  OF  WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON ALLOWS
FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION.   CARNEGIE  MELLON
DISCLAIMS  ANY  LIABILITY  OF  ANY  KIND  FOR  ANY  DAMAGES WHATSOEVER
RESULTING DIRECTLY OR INDIRECTLY FROM THE USE OF THIS SOFTWARE  OR  OF
ANY DERIVATIVE WORK.

Carnegie  Mellon  encourages  users  of  this  software  to return any
improvements or extensions that  they  make,  and  to  grant  Carnegie
Mellon the rights to redistribute these changes without encumbrance.
*/

/*
 *
 * Based on cfs.h from Mach, but revamped for increased simplicity.
 * Linux modifications by 
 * Peter Braam, Aug 1996
 */

#ifndef _CODA_HEADER_
#define _CODA_HEADER_


/* Catch new _KERNEL defn for NetBSD and DJGPP/__CYGWIN32__ */
#if defined(__NetBSD__) || \
  ((defined(DJGPP) || defined(__CYGWIN32__)) && !defined(KERNEL))
#include <sys/types.h>
#endif 

#ifndef CODA_MAXSYMLINKS
#define CODA_MAXSYMLINKS 10
#endif

#if defined(DJGPP) || defined(__CYGWIN32__)
#ifdef KERNEL
typedef unsigned long u_long;
typedef unsigned int u_int;
typedef unsigned short u_short;
typedef u_long ino_t;
typedef u_long dev_t;
typedef void * caddr_t;
#ifdef DOS
typedef unsigned __int64 u_quad_t;
#else 
typedef unsigned long long u_quad_t;
#endif

#define __inline__

#else  /* DJGPP but not KERNEL */
#include <sys/time.h>
typedef unsigned long long u_quad_t;
#endif /* !KERNEL */
#endif /* !DJGPP */


#if defined(__linux__)
#include <linux/time.h>
#define cdev_t u_quad_t
#if !defined(_UQUAD_T_) && (!defined(__GLIBC__) || __GLIBC__ < 2)
#define _UQUAD_T_ 1
typedef unsigned long long u_quad_t;
#endif
#else
#define cdev_t dev_t
#endif

#ifndef __BIT_TYPES_DEFINED__
#define __BIT_TYPES_DEFINED__
typedef signed char	      int8_t;
typedef unsigned char	    u_int8_t;
typedef short		     int16_t;
typedef unsigned short	   u_int16_t;
typedef int		     int32_t;
typedef unsigned int	   u_int32_t;
#endif


/*
 * Cfs constants
 */
#define CODA_MAXNAMLEN   255
#define CODA_MAXPATHLEN  1024
#define CODA_MAXSYMLINK  10

/* these are Coda's version of O_RDONLY etc combinations
 * to deal with VFS open modes
 */
#define	C_O_READ	0x001
#define	C_O_WRITE       0x002
#define C_O_TRUNC       0x010
#define C_O_EXCL	0x100
#define C_O_CREAT	0x200

/* these are to find mode bits in Venus */ 
#define C_M_READ  00400
#define C_M_WRITE 00200

/* for access Venus will use */
#define C_A_C_OK    8               /* Test for writing upon create.  */
#define C_A_R_OK    4               /* Test for read permission.  */
#define C_A_W_OK    2               /* Test for write permission.  */
#define C_A_X_OK    1               /* Test for execute permission.  */
#define C_A_F_OK    0               /* Test for existence.  */



#ifndef _VENUS_DIRENT_T_
#define _VENUS_DIRENT_T_ 1
struct venus_dirent {
        u_int32_t d_fileno;		/* file number of entry */
        u_int16_t d_reclen;		/* length of this record */
        u_int8_t  d_type;			/* file type, see below */
        u_int8_t  d_namlen;		/* length of string in d_name */
        char	  d_name[CODA_MAXNAMLEN + 1];/* name must be no longer than this */
};
#undef DIRSIZ
#define DIRSIZ(dp)      ((sizeof (struct venus_dirent) - (CODA_MAXNAMLEN+1)) + \
                         (((dp)->d_namlen+1 + 3) &~ 3))

/*
 * File types
 */
#define	CDT_UNKNOWN	 0
#define	CDT_FIFO	 1
#define	CDT_CHR		 2
#define	CDT_DIR		 4
#define	CDT_BLK		 6
#define	CDT_REG		 8
#define	CDT_LNK		10
#define	CDT_SOCK	12
#define	CDT_WHT		14

/*
 * Convert between stat structure types and directory types.
 */
#define	IFTOCDT(mode)	(((mode) & 0170000) >> 12)
#define	CDTTOIF(dirtype)	((dirtype) << 12)

#endif

#ifndef _VUID_T_
#define _VUID_T_
typedef u_int32_t vuid_t;
typedef u_int32_t vgid_t;
#endif /*_VUID_T_ */

struct CodaFid {
	u_int32_t opaque[4];
};

#define coda_f2i(fid)\
	(fid ? (fid->opaque[3] ^ (fid->opaque[2]<<10) ^ (fid->opaque[1]<<20) ^ fid->opaque[0]) : 0)

#ifndef _VENUS_VATTR_T_
#define _VENUS_VATTR_T_
/*
 * Vnode types.  VNON means no type.
 */
enum coda_vtype	{ C_VNON, C_VREG, C_VDIR, C_VBLK, C_VCHR, C_VLNK, C_VSOCK, C_VFIFO, C_VBAD };

struct coda_timespec {
	int64_t		tv_sec;		/* seconds */
	long		tv_nsec;	/* nanoseconds */
};

struct coda_vattr {
	long     	va_type;	/* vnode type (for create) */
	u_short		va_mode;	/* files access mode and type */
	short		va_nlink;	/* number of references to file */
	vuid_t		va_uid;		/* owner user id */
	vgid_t		va_gid;		/* owner group id */
	long		va_fileid;	/* file id */
	u_quad_t	va_size;	/* file size in bytes */
	long		va_blocksize;	/* blocksize preferred for i/o */
	struct coda_timespec va_atime;	/* time of last access */
	struct coda_timespec va_mtime;	/* time of last modification */
	struct coda_timespec va_ctime;	/* time file changed */
	u_long		va_gen;		/* generation number of file */
	u_long		va_flags;	/* flags defined for file */
	cdev_t	        va_rdev;	/* device special file represents */
	u_quad_t	va_bytes;	/* bytes of disk space held by file */
	u_quad_t	va_filerev;	/* file modification number */
};

#endif 

/* structure used by CODA_STATFS for getting cache information from venus */
struct coda_statfs {
    int32_t f_blocks;
    int32_t f_bfree;
    int32_t f_bavail;
    int32_t f_files;
    int32_t f_ffree;
};

/*
 * Kernel <--> Venus communications.
 */

#define CODA_ROOT	2
#define CODA_OPEN_BY_FD	3
#define CODA_OPEN	4
#define CODA_CLOSE	5
#define CODA_IOCTL	6
#define CODA_GETATTR	7
#define CODA_SETATTR	8
#define CODA_ACCESS	9
#define CODA_LOOKUP	10
#define CODA_CREATE	11
#define CODA_REMOVE	12
#define CODA_LINK	13
#define CODA_RENAME	14
#define CODA_MKDIR	15
#define CODA_RMDIR	16
#define CODA_SYMLINK	18
#define CODA_READLINK	19
#define CODA_FSYNC	20
#define CODA_VGET	22
#define CODA_SIGNAL	23
#define CODA_REPLACE	 24 /* DOWNCALL */
#define CODA_FLUSH       25 /* DOWNCALL */
#define CODA_PURGEUSER   26 /* DOWNCALL */
#define CODA_ZAPFILE     27 /* DOWNCALL */
#define CODA_ZAPDIR      28 /* DOWNCALL */
#define CODA_PURGEFID    30 /* DOWNCALL */
#define CODA_OPEN_BY_PATH 31
#define CODA_RESOLVE     32
#define CODA_REINTEGRATE 33
#define CODA_STATFS	 34
#define CODA_STORE	 35
#define CODA_RELEASE	 36
#define CODA_ACCESS_INTENT 37
#define CODA_NCALLS 38

#define DOWNCALL(opcode) (opcode >= CODA_REPLACE && opcode <= CODA_PURGEFID)

#define VC_MAXDATASIZE	    8192
#define VC_MAXMSGSIZE      sizeof(union inputArgs)+sizeof(union outputArgs) +\
                            VC_MAXDATASIZE  

#define CIOC_KERNEL_VERSION _IOWR('c', 10, size_t)

//      CODA_KERNEL_VERSION 0 /* don't care about kernel version number */
//      CODA_KERNEL_VERSION 1 /* The old venus 4.6 compatible interface */
//      CODA_KERNEL_VERSION 2 /* venus_lookup gets an extra parameter */
//      CODA_KERNEL_VERSION 3 /* 128-bit file identifiers */
//      CODA_KERNEL_VERSION 4 /* 64-bit timespec */
#define CODA_KERNEL_VERSION 5 /* access intent support */

/*
 *        Venus <-> Coda  RPC arguments
 */
struct coda_in_hdr {
    u_int32_t opcode;
    u_int32_t unique;	    /* Keep multiple outstanding msgs distinct */
    __kernel_pid_t pid;
    __kernel_pid_t pgid;
    vuid_t uid;
};

/* Really important that opcode and unique are 1st two fields! */
struct coda_out_hdr {
    u_int32_t opcode;
    u_int32_t unique;	
    u_int32_t result;
};

/* coda_root: NO_IN */
struct coda_root_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
};

struct coda_root_in {
    struct coda_in_hdr in;
};

/* coda_open: */
struct coda_open_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_open_out {
    struct coda_out_hdr oh;
    cdev_t	dev;
    ino_t	inode;
};


/* coda_store: */
struct coda_store_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_store_out {
    struct coda_out_hdr out;
};

/* coda_release: */
struct coda_release_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_release_out {
    struct coda_out_hdr out;
};

/* coda_close: */
struct coda_close_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_close_out {
    struct coda_out_hdr out;
};

/* coda_ioctl: */
struct coda_ioctl_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	cmd;
    int	len;
    int	rwflag;
    char *data;			/* Place holder for data. */
};

struct coda_ioctl_out {
    struct coda_out_hdr oh;
    int	len;
    caddr_t	data;		/* Place holder for data. */
};


/* coda_getattr: */
struct coda_getattr_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_getattr_out {
    struct coda_out_hdr oh;
    struct coda_vattr attr;
};


/* coda_setattr: NO_OUT */
struct coda_setattr_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
};

struct coda_setattr_out {
    struct coda_out_hdr out;
};

/* coda_access: NO_OUT */
struct coda_access_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_access_out {
    struct coda_out_hdr out;
};


/* lookup flags */
#define CLU_CASE_SENSITIVE     0x01
#define CLU_CASE_INSENSITIVE   0x02

/* coda_lookup: */
struct  coda_lookup_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int         name;		/* Place holder for data. */
    int         flags;	
};

struct coda_lookup_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    int	vtype;
};


/* coda_create: */
struct coda_create_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
    int excl;
    int mode;
    int 	name;		/* Place holder for data. */
};

struct coda_create_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    struct coda_vattr attr;
};


/* coda_remove: NO_OUT */
struct coda_remove_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int name;		/* Place holder for data. */
};

struct coda_remove_out {
    struct coda_out_hdr out;
};

/* coda_link: NO_OUT */
struct coda_link_in {
    struct coda_in_hdr ih;
    struct CodaFid sourceFid;	/* cnode to link *to* */
    struct CodaFid destFid;	/* Directory in which to place link */
    int tname;		/* Place holder for data. */
};

struct coda_link_out {
    struct coda_out_hdr out;
};


/* coda_rename: NO_OUT */
struct coda_rename_in {
    struct coda_in_hdr ih;
    struct CodaFid sourceFid;
    int 	srcname;
    struct CodaFid destFid;
    int 	destname;
};

struct coda_rename_out {
    struct coda_out_hdr out;
};

/* coda_mkdir: */
struct coda_mkdir_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    struct coda_vattr attr;
    int	   name;		/* Place holder for data. */
};

struct coda_mkdir_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    struct coda_vattr attr;
};


/* coda_rmdir: NO_OUT */
struct coda_rmdir_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int name;		/* Place holder for data. */
};

struct coda_rmdir_out {
    struct coda_out_hdr out;
};

/* coda_symlink: NO_OUT */
struct coda_symlink_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;	/* Directory to put symlink in */
    int srcname;
    struct coda_vattr attr;
    int tname;
};

struct coda_symlink_out {
    struct coda_out_hdr out;
};

/* coda_readlink: */
struct coda_readlink_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_readlink_out {
    struct coda_out_hdr oh;
    int	count;
    caddr_t	data;		/* Place holder for data. */
};


/* coda_fsync: NO_OUT */
struct coda_fsync_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_fsync_out {
    struct coda_out_hdr out;
};

/* coda_vget: */
struct coda_vget_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
};

struct coda_vget_out {
    struct coda_out_hdr oh;
    struct CodaFid VFid;
    int	vtype;
};


/* CODA_SIGNAL is out-of-band, doesn't need data. */
/* CODA_INVALIDATE is a venus->kernel call */
/* CODA_FLUSH is a venus->kernel call */

/* coda_purgeuser: */
/* CODA_PURGEUSER is a venus->kernel call */
struct coda_purgeuser_out {
    struct coda_out_hdr oh;
    vuid_t uid;
};

/* coda_zapfile: */
/* CODA_ZAPFILE is a venus->kernel call */
struct coda_zapfile_out {  
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_zapdir: */
/* CODA_ZAPDIR is a venus->kernel call */	
struct coda_zapdir_out {	  
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_purgefid: */
/* CODA_PURGEFID is a venus->kernel call */	
struct coda_purgefid_out { 
    struct coda_out_hdr oh;
    struct CodaFid CodaFid;
};

/* coda_replace: */
/* CODA_REPLACE is a venus->kernel call */	
struct coda_replace_out { /* coda_replace is a venus->kernel call */
    struct coda_out_hdr oh;
    struct CodaFid NewFid;
    struct CodaFid OldFid;
};

/* coda_open_by_fd: */
struct coda_open_by_fd_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int        flags;
};

struct coda_open_by_fd_out {
    struct coda_out_hdr oh;
    int fd;

};

/* coda_open_by_path: */
struct coda_open_by_path_in {
    struct coda_in_hdr ih;
    struct CodaFid VFid;
    int	flags;
};

struct coda_open_by_path_out {
    struct coda_out_hdr oh;
	int path;
};

/* coda_statfs: NO_IN */
struct coda_statfs_in {
    struct coda_in_hdr in;
};

struct coda_statfs_out {
    struct coda_out_hdr oh;
    struct coda_statfs stat;
};

#define CODA_ACCESS_TYPE_READ		1
#define CODA_ACCESS_TYPE_WRITE		2
#define CODA_ACCESS_TYPE_MMAP		3
#define CODA_ACCESS_TYPE_READ_FINISH	4
#define CODA_ACCESS_TYPE_WRITE_FINISH	5

/* coda_access_intent: NO_OUT */
struct coda_access_intent_in {
	struct coda_in_hdr ih;
	struct CodaFid VFid;
	int count;
	int pos;
	int type;
};

struct coda_access_intent_out {
	struct coda_out_hdr out;
};

/* 
 * Occasionally, we don't cache the fid returned by CODA_LOOKUP. 
 * For instance, if the fid is inconsistent. 
 * This case is handled by setting the top bit of the type result parameter.
 */
#define CODA_NOCACHE          0x80000000

union inputArgs {
    struct coda_in_hdr ih;		/* NB: every struct below begins with an ih */
    struct coda_open_in coda_open;
    struct coda_store_in coda_store;
    struct coda_release_in coda_release;
    struct coda_close_in coda_close;
    struct coda_ioctl_in coda_ioctl;
    struct coda_getattr_in coda_getattr;
    struct coda_setattr_in coda_setattr;
    struct coda_access_in coda_access;
    struct coda_lookup_in coda_lookup;
    struct coda_create_in coda_create;
    struct coda_remove_in coda_remove;
    struct coda_link_in coda_link;
    struct coda_rename_in coda_rename;
    struct coda_mkdir_in coda_mkdir;
    struct coda_rmdir_in coda_rmdir;
    struct coda_symlink_in coda_symlink;
    struct coda_readlink_in coda_readlink;
    struct coda_fsync_in coda_fsync;
    struct coda_vget_in coda_vget;
    struct coda_open_by_fd_in coda_open_by_fd;
    struct coda_open_by_path_in coda_open_by_path;
    struct coda_statfs_in coda_statfs;
    struct coda_access_intent_in coda_access_intent;
};

union outputArgs {
    struct coda_out_hdr oh;		/* NB: every struct below begins with an oh */
    struct coda_root_out coda_root;
    struct coda_open_out coda_open;
    struct coda_ioctl_out coda_ioctl;
    struct coda_getattr_out coda_getattr;
    struct coda_lookup_out coda_lookup;
    struct coda_create_out coda_create;
    struct coda_mkdir_out coda_mkdir;
    struct coda_readlink_out coda_readlink;
    struct coda_vget_out coda_vget;
    struct coda_purgeuser_out coda_purgeuser;
    struct coda_zapfile_out coda_zapfile;
    struct coda_zapdir_out coda_zapdir;
    struct coda_purgefid_out coda_purgefid;
    struct coda_replace_out coda_replace;
    struct coda_open_by_fd_out coda_open_by_fd;
    struct coda_open_by_path_out coda_open_by_path;
    struct coda_statfs_out coda_statfs;
};    

union coda_downcalls {
    /* CODA_INVALIDATE is a venus->kernel call */
    /* CODA_FLUSH is a venus->kernel call */
    struct coda_purgeuser_out purgeuser;
    struct coda_zapfile_out zapfile;
    struct coda_zapdir_out zapdir;
    struct coda_purgefid_out purgefid;
    struct coda_replace_out replace;
};


/*
 * Used for identifying usage of "Control" and pioctls
 */

#define PIOCPARM_MASK 0x0000ffff
struct ViceIoctl {
        void *in;        /* Data to be transferred in */
        void *out;       /* Data to be transferred out */
        u_short in_size;        /* Size of input buffer <= 2K */
        u_short out_size;       /* Maximum size of output buffer, <= 2K */
};

struct PioctlData {
        const char *path;
        int follow;
        struct ViceIoctl vi;
};

#define CODA_CONTROL		".CONTROL"
#define CODA_CONTROLLEN		8
#define CTL_INO			-1

/* Data passed to mount */

#define CODA_MOUNT_VERSION 1

struct coda_mount_data {
	int		version;
	int		fd;       /* Opened device */
};

#endif /* _CODA_HEADER_ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/* This file is derived from the GAS 2.1.4 assembler control file.
   The GAS product is under the GNU General Public License, version 2 or later.
   As such, this file is also under that license.

   If the file format changes in the COFF object, this file should be
   subsequently updated to reflect the changes.

   The actual loader module only uses a few of these structures. The full
   set is documented here because I received the full set. If you wish
   more information about COFF, then O'Reilly has a very excellent book.
*/

#ifndef _LINUX_COFF_H
#define _LINUX_COFF_H

#define  E_SYMNMLEN  8   /* Number of characters in a symbol name         */
#define  E_FILNMLEN 14   /* Number of characters in a file name           */
#define  E_DIMNUM    4   /* Number of array dimensions in auxiliary entry */

/*
 * These defines are byte order independent. There is no alignment of fields
 * permitted in the structures. Therefore they are declared as characters
 * and the values loaded from the character positions. It also makes it
 * nice to have it "endian" independent.
 */
 
/* Load a short int from the following tables with little-endian formats */
#define COFF_SHORT_L(ps) ((short)(((unsigned short)((unsigned char)ps[1])<<8)|\
				  ((unsigned short)((unsigned char)ps[0]))))

/* Load a long int from the following tables with little-endian formats */
#define COFF_LONG_L(ps) (((long)(((unsigned long)((unsigned char)ps[3])<<24) |\
				 ((unsigned long)((unsigned char)ps[2])<<16) |\
				 ((unsigned long)((unsigned char)ps[1])<<8)  |\
				 ((unsigned long)((unsigned char)ps[0])))))
 
/* Load a short int from the following tables with big-endian formats */
#define COFF_SHORT_H(ps) ((short)(((unsigned short)((unsigned char)ps[0])<<8)|\
				  ((unsigned short)((unsigned char)ps[1]))))

/* Load a long int from the following tables with big-endian formats */
#define COFF_LONG_H(ps) (((long)(((unsigned long)((unsigned char)ps[0])<<24) |\
				 ((unsigned long)((unsigned char)ps[1])<<16) |\
				 ((unsigned long)((unsigned char)ps[2])<<8)  |\
				 ((unsigned long)((unsigned char)ps[3])))))

/* These may be overridden later by brain dead implementations which generate
   a big-endian header with little-endian data. In that case, generate a
   replacement macro which tests a flag and uses either of the two above
   as appropriate. */

#define COFF_LONG(v)   COFF_LONG_L(v)
#define COFF_SHORT(v)  COFF_SHORT_L(v)

/*** coff information for Intel 386/486.  */

/********************** FILE HEADER **********************/

struct COFF_filehdr {
	char f_magic[2];	/* magic number			*/
	char f_nscns[2];	/* number of sections		*/
	char f_timdat[4];	/* time & date stamp		*/
	char f_symptr[4];	/* file pointer to symtab	*/
	char f_nsyms[4];	/* number of symtab entries	*/
	char f_opthdr[2];	/* sizeof(optional hdr)		*/
	char f_flags[2];	/* flags			*/
};

/*
 *   Bits for f_flags:
 *
 *	F_RELFLG	relocation info stripped from file
 *	F_EXEC		file is executable  (i.e. no unresolved external
 *			references)
 *	F_LNNO		line numbers stripped from file
 *	F_LSYMS		local symbols stripped from file
 *	F_MINMAL	this is a minimal object file (".m") output of fextract
 *	F_UPDATE	this is a fully bound update file, output of ogen
 *	F_SWABD		this file has had its bytes swabbed (in names)
 *	F_AR16WR	this file has the byte ordering of an AR16WR
 *			(e.g. 11/70) machine
 *	F_AR32WR	this file has the byte ordering of an AR32WR machine
 *			(e.g. vax and iNTEL 386)
 *	F_AR32W		this file has the byte ordering of an AR32W machine
 *			(e.g. 3b,maxi)
 *	F_PATCH		file contains "patch" list in optional header
 *	F_NODF		(minimal file only) no decision functions for
 *			replaced functions
 */

#define  COFF_F_RELFLG		0000001
#define  COFF_F_EXEC		0000002
#define  COFF_F_LNNO		0000004
#define  COFF_F_LSYMS		0000010
#define  COFF_F_MINMAL		0000020
#define  COFF_F_UPDATE		0000040
#define  COFF_F_SWABD		0000100
#define  COFF_F_AR16WR		0000200
#define  COFF_F_AR32WR		0000400
#define  COFF_F_AR32W		0001000
#define  COFF_F_PATCH		0002000
#define  COFF_F_NODF		0002000

#define	COFF_I386MAGIC	        0x14c   /* Linux's system    */

#if 0   /* Perhaps, someday, these formats may be used.      */
#define COFF_I386PTXMAGIC	0x154
#define COFF_I386AIXMAGIC	0x175   /* IBM's AIX system  */
#define COFF_I386BADMAG(x) ((COFF_SHORT((x).f_magic) != COFF_I386MAGIC) \
			  && COFF_SHORT((x).f_magic) != COFF_I386PTXMAGIC \
			  && COFF_SHORT((x).f_magic) != COFF_I386AIXMAGIC)
#else
#define COFF_I386BADMAG(x) (COFF_SHORT((x).f_magic) != COFF_I386MAGIC)
#endif

#define	COFF_FILHDR	struct COFF_filehdr
#define	COFF_FILHSZ	sizeof(COFF_FILHDR)

/********************** AOUT "OPTIONAL HEADER" **********************/

/* Linux COFF must have this "optional" header. Standard COFF has no entry
   location for the "entry" point. They normally would start with the first
   location of the .text section. This is not a good idea for linux. So,
   the use of this "optional" header is not optional. It is required.

   Do not be tempted to assume that the size of the optional header is
   a constant and simply index the next byte by the size of this structure.
   Use the 'f_opthdr' field in the main coff header for the size of the
   structure actually written to the file!!
*/

typedef struct 
{
  char 	magic[2];		/* type of file				 */
  char	vstamp[2];		/* version stamp			 */
  char	tsize[4];		/* text size in bytes, padded to FW bdry */
  char	dsize[4];		/* initialized   data "   "		 */
  char	bsize[4];		/* uninitialized data "   "		 */
  char	entry[4];		/* entry pt.				 */
  char 	text_start[4];		/* base of text used for this file       */
  char 	data_start[4];		/* base of data used for this file       */
}
COFF_AOUTHDR;

#define COFF_AOUTSZ (sizeof(COFF_AOUTHDR))

#define COFF_STMAGIC	0401
#define COFF_OMAGIC     0404
#define COFF_JMAGIC     0407    /* dirty text and data image, can't share  */
#define COFF_DMAGIC     0410    /* dirty text segment, data aligned        */
#define COFF_ZMAGIC     0413    /* The proper magic number for executables  */
#define COFF_SHMAGIC	0443	/* shared library header                   */

/********************** SECTION HEADER **********************/

struct COFF_scnhdr {
  char		s_name[8];	/* section name			    */
  char		s_paddr[4];	/* physical address, aliased s_nlib */
  char		s_vaddr[4];	/* virtual address		    */
  char		s_size[4];	/* section size			    */
  char		s_scnptr[4];	/* file ptr to raw data for section */
  char		s_relptr[4];	/* file ptr to relocation	    */
  char		s_lnnoptr[4];	/* file ptr to line numbers	    */
  char		s_nreloc[2];	/* number of relocation entries	    */
  char		s_nlnno[2];	/* number of line number entries    */
  char		s_flags[4];	/* flags			    */
};

#define	COFF_SCNHDR	struct COFF_scnhdr
#define	COFF_SCNHSZ	sizeof(COFF_SCNHDR)

/*
 * names of "special" sections
 */

#define COFF_TEXT	".text"
#define COFF_DATA	".data"
#define COFF_BSS	".bss"
#define COFF_COMMENT    ".comment"
#define COFF_LIB        ".lib"

#define COFF_SECT_TEXT  0      /* Section for instruction code             */
#define COFF_SECT_DATA  1      /* Section for initialized globals          */
#define COFF_SECT_BSS   2      /* Section for un-initialized globals       */
#define COFF_SECT_REQD  3      /* Minimum number of sections for good file */

#define COFF_STYP_REG     0x00 /* regular segment                          */
#define COFF_STYP_DSECT   0x01 /* dummy segment                            */
#define COFF_STYP_NOLOAD  0x02 /* no-load segment                          */
#define COFF_STYP_GROUP   0x04 /* group segment                            */
#define COFF_STYP_PAD     0x08 /* .pad segment                             */
#define COFF_STYP_COPY    0x10 /* copy section                             */
#define COFF_STYP_TEXT    0x20 /* .text segment                            */
#define COFF_STYP_DATA    0x40 /* .data segment                            */
#define COFF_STYP_BSS     0x80 /* .bss segment                             */
#define COFF_STYP_INFO   0x200 /* .comment section                         */
#define COFF_STYP_OVER   0x400 /* overlay section                          */
#define COFF_STYP_LIB    0x800 /* library section                          */

/*
 * Shared libraries have the following section header in the data field for
 * each library.
 */

struct COFF_slib {
  char		sl_entsz[4];	/* Size of this entry               */
  char		sl_pathndx[4];	/* size of the header field         */
};

#define	COFF_SLIBHD	struct COFF_slib
#define	COFF_SLIBSZ	sizeof(COFF_SLIBHD)

/********************** LINE NUMBERS **********************/

/* 1 line number entry for every "breakpointable" source line in a section.
 * Line numbers are grouped on a per function basis; first entry in a function
 * grouping will have l_lnno = 0 and in place of physical address will be the
 * symbol table index of the function name.
 */

struct COFF_lineno {
  union {
    char l_symndx[4];	/* function name symbol index, iff l_lnno == 0*/
    char l_paddr[4];	/* (physical) address of line number	*/
  } l_addr;
  char l_lnno[2];	/* line number		*/
};

#define	COFF_LINENO	struct COFF_lineno
#define	COFF_LINESZ	6

/********************** SYMBOLS **********************/

#define COFF_E_SYMNMLEN	 8	/* # characters in a short symbol name	*/
#define COFF_E_FILNMLEN	14	/* # characters in a file name		*/
#define COFF_E_DIMNUM	 4	/* # array dimensions in auxiliary entry */

/*
 *  All symbols and sections have the following definition
 */

struct COFF_syment 
{
  union {
    char e_name[E_SYMNMLEN];    /* Symbol name (first 8 characters) */
    struct {
      char e_zeroes[4];         /* Leading zeros */
      char e_offset[4];         /* Offset if this is a header section */
    } e;
  } e;

  char e_value[4];              /* Value (address) of the segment */
  char e_scnum[2];              /* Section number */
  char e_type[2];               /* Type of section */
  char e_sclass[1];             /* Loader class */
  char e_numaux[1];             /* Number of auxiliary entries which follow */
};

#define COFF_N_BTMASK	(0xf)   /* Mask for important class bits */
#define COFF_N_TMASK	(0x30)  /* Mask for important type bits  */
#define COFF_N_BTSHFT	(4)     /* # bits to shift class field   */
#define COFF_N_TSHIFT	(2)     /* # bits to shift type field    */

/*
 *  Auxiliary entries because the main table is too limiting.
 */
  
union COFF_auxent {

/*
 *  Debugger information
 */

  struct {
    char x_tagndx[4];	        /* str, un, or enum tag indx */
    union {
      struct {
	char  x_lnno[2];        /* declaration line number */
	char  x_size[2];        /* str/union/array size */
      } x_lnsz;
      char x_fsize[4];	        /* size of function */
    } x_misc;

    union {
      struct {		        /* if ISFCN, tag, or .bb */
	char x_lnnoptr[4];	/* ptr to fcn line # */
	char x_endndx[4];	/* entry ndx past block end */
      } x_fcn;

      struct {		        /* if ISARY, up to 4 dimen. */
	char x_dimen[E_DIMNUM][2];
      } x_ary;
    } x_fcnary;

    char x_tvndx[2];	/* tv index */
  } x_sym;

/*
 *   Source file names (debugger information)
 */

  union {
    char x_fname[E_FILNMLEN];
    struct {
      char x_zeroes[4];
      char x_offset[4];
    } x_n;
  } x_file;

/*
 *   Section information
 */

  struct {
    char x_scnlen[4];	/* section length */
    char x_nreloc[2];	/* # relocation entries */
    char x_nlinno[2];	/* # line numbers */
  } x_scn;

/*
 *   Transfer vector (branch table)
 */
  
  struct {
    char x_tvfill[4];	/* tv fill value */
    char x_tvlen[2];	/* length of .tv */
    char x_tvran[2][2];	/* tv range */
  } x_tv;		/* info about .tv section (in auxent of symbol .tv)) */
};

#define	COFF_SYMENT	struct COFF_syment
#define	COFF_SYMESZ	18	
#define	COFF_AUXENT	union COFF_auxent
#define	COFF_AUXESZ	18

#define COFF_ETEXT	"etext"

/********************** RELOCATION DIRECTIVES **********************/

struct COFF_reloc {
  char r_vaddr[4];        /* Virtual address of item    */
  char r_symndx[4];       /* Symbol index in the symtab */
  char r_type[2];         /* Relocation type            */
};

#define COFF_RELOC struct COFF_reloc
#define COFF_RELSZ 10

#define COFF_DEF_DATA_SECTION_ALIGNMENT  4
#define COFF_DEF_BSS_SECTION_ALIGNMENT   4
#define COFF_DEF_TEXT_SECTION_ALIGNMENT  4

/* For new sections we haven't heard of before */
#define COFF_DEF_SECTION_ALIGNMENT       4

#endif /* _LINUX_COFF_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           /* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
 * 	connector.h
 * 
 * 2004-2005 Copyright (c) Evgeniy Polyakov <zbr@ioremap.net>
 * All rights reserved.
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef __CONNECTOR_H
#define __CONNECTOR_H

#include <linux/types.h>

/*
 * Process Events connector unique ids -- used for message routing
 */
#define CN_IDX_PROC			0x1
#define CN_VAL_PROC			0x1
#define CN_IDX_CIFS			0x2
#define CN_VAL_CIFS                     0x1
#define CN_W1_IDX			0x3	/* w1 communication */
#define CN_W1_VAL			0x1
#define CN_IDX_V86D			0x4
#define CN_VAL_V86D_UVESAFB		0x1
#define CN_IDX_BB			0x5	/* BlackBoard, from the TSP GPL sampling framework */
#define CN_DST_IDX			0x6
#define CN_DST_VAL			0x1
#define CN_IDX_DM			0x7	/* Device Mapper */
#define CN_VAL_DM_USERSPACE_LOG		0x1
#define CN_IDX_DRBD			0x8
#define CN_VAL_DRBD			0x1
#define CN_KVP_IDX			0x9	/* HyperV KVP */
#define CN_KVP_VAL			0x1	/* queries from the kernel */
#define CN_VSS_IDX			0xA     /* HyperV VSS */
#define CN_VSS_VAL			0x1     /* queries from the kernel */


#define CN_NETLINK_USERS		11	/* Highest index + 1 */

/*
 * Maximum connector's message size.
 */
#define CONNECTOR_MAX_MSG_SIZE		16384

/*
 * idx and val are unique identifiers which 
 * are used for message routing and 
 * must be registered in connector.h for in-kernel usage.
 */

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;

	__u32 seq;
	__u32 ack;

	__u16 len;		/* Length of the following data */
	__u16 flags;
	__u8 data[0];
};

#endif /* __CONNECTOR_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/* const.h: Macros for dealing with constants.  */

#ifndef _LINUX_CONST_H
#define _LINUX_CONST_H

/* Some constant macros are used in both assembler and
 * C code.  Therefore we cannot annotate them always with
 * 'UL' and other type specifiers unilaterally.  We
 * use the following macros to deal with this.
 *
 * Similarly, _AT() will cast an expression with a type in C, but
 * leave it unchanged in asm.
 */

#ifdef __ASSEMBLY__
#define _AC(X,Y)	X
#define _AT(T,X)	X
#else
#define __AC(X,Y)	(X##Y)
#define _AC(X,Y)	__AC(X,Y)
#define _AT(T,X)	((T)(X))
#endif

#define _UL(x)		(_AC(x, UL))
#define _ULL(x)		(_AC(x, ULL))

#define _BITUL(x)	(_UL(1) << (x))
#define _BITULL(x)	(_ULL(1) << (x))

#endif /* _LINUX_CONST_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef __UAPI_CORESIGHT_STM_H_
#define __UAPI_CORESIGHT_STM_H_

#include <linux/const.h>

#define STM_FLAG_TIMESTAMPED   _BITUL(3)
#define STM_FLAG_GUARANTEED    _BITUL(7)

/*
 * The CoreSight STM supports guaranteed and invariant timing
 * transactions.  Guaranteed transactions are guaranteed to be
 * traced, this might involve stalling the bus or system to
 * ensure the transaction is accepted by the STM.  While invariant
 * timing transactions are not guaranteed to be traced, they
 * will take an invariant amount of time regardless of the
 * state of the STM.
 */
enum {
	STM_OPTION_GUARANTEED = 0,
	STM_OPTION_INVARIANT,
};

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef __CRAMFS_H
#define __CRAMFS_H

#include <linux/types.h>
#include <linux/magic.h>

#define CRAMFS_SIGNATURE	"Compressed ROMFS"

/*
 * Width of various bitfields in struct cramfs_inode.
 * Primarily used to generate warnings in mkcramfs.
 */
#define CRAMFS_MODE_WIDTH 16
#define CRAMFS_UID_WIDTH 16
#define CRAMFS_SIZE_WIDTH 24
#define CRAMFS_GID_WIDTH 8
#define CRAMFS_NAMELEN_WIDTH 6
#define CRAMFS_OFFSET_WIDTH 26

/*
 * Since inode.namelen is a unsigned 6-bit number, the maximum cramfs
 * path length is 63 << 2 = 252.
 */
#define CRAMFS_MAXPATHLEN (((1 << CRAMFS_NAMELEN_WIDTH) - 1) << 2)

/*
 * Reasonably terse representation of the inode data.
 */
struct cramfs_inode {
	__u32 mode:CRAMFS_MODE_WIDTH, uid:CRAMFS_UID_WIDTH;
	/* SIZE for device files is i_rdev */
	__u32 size:CRAMFS_SIZE_WIDTH, gid:CRAMFS_GID_WIDTH;
	/* NAMELEN is the length of the file name, divided by 4 and
           rounded up.  (cramfs doesn't support hard links.) */
	/* OFFSET: For symlinks and non-empty regular files, this
	   contains the offset (divided by 4) of the file data in
	   compressed form (starting with an array of block pointers;
	   see README).  For non-empty directories it is the offset
	   (divided by 4) of the inode of the first file in that
	   directory.  For anything else, offset is zero. */
	__u32 namelen:CRAMFS_NAMELEN_WIDTH, offset:CRAMFS_OFFSET_WIDTH;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

/*
 * Superblock information at the beginning of the FS.
 */
struct cramfs_super {
	__u32 magic;			/* 0x28cd3d45 - random number */
	__u32 size;			/* length in bytes */
	__u32 flags;			/* feature flags */
	__u32 future;			/* reserved for future use */
	__u8 signature[16];		/* "Compressed ROMFS" */
	struct cramfs_info fsid;	/* unique filesystem info */
	__u8 name[16];			/* user-defined name */
	struct cramfs_inode root;	/* root inode data */
};

/*
 * Feature flags
 *
 * 0x00000000 - 0x000000ff: features that work for all past kernels
 * 0x00000100 - 0xffffffff: features that don't work for past kernels
 */
#define CRAMFS_FLAG_FSID_VERSION_2	0x00000001	/* fsid version #2 */
#define CRAMFS_FLAG_SORTED_DIRS		0x00000002	/* sorted dirs */
#define CRAMFS_FLAG_HOLES		0x00000100	/* support for holes */
#define CRAMFS_FLAG_WRONG_SIGNATURE	0x00000200	/* reserved */
#define CRAMFS_FLAG_SHIFTED_ROOT_OFFSET	0x00000400	/* shifted root fs */
#define CRAMFS_FLAG_EXT_BLOCK_POINTERS	0x00000800	/* block pointer extensions */

/*
 * Valid values in super.flags.  Currently we refuse to mount
 * if (flags & ~CRAMFS_SUPPORTED_FLAGS).  Maybe that should be
 * changed to test super.future instead.
 */
#define CRAMFS_SUPPORTED_FLAGS	( 0x000000ff \
				| CRAMFS_FLAG_HOLES \
				| CRAMFS_FLAG_WRONG_SIGNATURE \
				| CRAMFS_FLAG_SHIFTED_ROOT_OFFSET \
				| CRAMFS_FLAG_EXT_BLOCK_POINTERS )

/*
 * Block pointer flags
 *
 * The maximum block offset that needs to be represented is roughly:
 *
 *   (1 << CRAMFS_OFFSET_WIDTH) * 4 +
 *   (1 << CRAMFS_SIZE_WIDTH) / PAGE_SIZE * (4 + PAGE_SIZE)
 *   = 0x11004000
 *
 * That leaves room for 3 flag bits in the block pointer table.
 */
#define CRAMFS_BLK_FLAG_UNCOMPRESSED	(1 << 31)
#define CRAMFS_BLK_FLAG_DIRECT_PTR	(1 << 30)

#define CRAMFS_BLK_FLAGS	( CRAMFS_BLK_FLAG_UNCOMPRESSED \
				| CRAMFS_BLK_FLAG_DIRECT_PTR )

/*
 * Direct blocks are at least 4-byte aligned.
 * Pointers to direct blocks are shifted down by 2 bits.
 */
#define CRAMFS_BLK_DIRECT_PTR_SHIFT	2

#endif /* __CRAMFS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * Crypto user configuration API.
 *
 * Copyright (C) 2011 secunet Security Networks AG
 * Copyright (C) 2011 Steffen Klassert <steffen.klassert@secunet.com>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef _LINUX_CRYPTOUSER_H
#define _LINUX_CRYPTOUSER_H

#include <linux/types.h>

/* Netlink configuration messages.  */
enum {
	CRYPTO_MSG_BASE = 0x10,
	CRYPTO_MSG_NEWALG = 0x10,
	CRYPTO_MSG_DELALG,
	CRYPTO_MSG_UPDATEALG,
	CRYPTO_MSG_GETALG,
	CRYPTO_MSG_DELRNG,
	CRYPTO_MSG_GETSTAT,
	__CRYPTO_MSG_MAX
};
#define CRYPTO_MSG_MAX (__CRYPTO_MSG_MAX - 1)
#define CRYPTO_NR_MSGTYPES (CRYPTO_MSG_MAX + 1 - CRYPTO_MSG_BASE)

#define CRYPTO_MAX_NAME 64

/* Netlink message attributes.  */
enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC,
	CRYPTOCFGA_PRIORITY_VAL,	/* __u32 */
	CRYPTOCFGA_REPORT_LARVAL,	/* struct crypto_report_larval */
	CRYPTOCFGA_REPORT_HASH,		/* struct crypto_report_hash */
	CRYPTOCFGA_REPORT_BLKCIPHER,	/* struct crypto_report_blkcipher */
	CRYPTOCFGA_REPORT_AEAD,		/* struct crypto_report_aead */
	CRYPTOCFGA_REPORT_COMPRESS,	/* struct crypto_report_comp */
	CRYPTOCFGA_REPORT_RNG,		/* struct crypto_report_rng */
	CRYPTOCFGA_REPORT_CIPHER,	/* struct crypto_report_cipher */
	CRYPTOCFGA_REPORT_AKCIPHER,	/* struct crypto_report_akcipher */
	CRYPTOCFGA_REPORT_KPP,		/* struct crypto_report_kpp */
	CRYPTOCFGA_REPORT_ACOMP,	/* struct crypto_report_acomp */
	CRYPTOCFGA_STAT_LARVAL,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_HASH,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_BLKCIPHER,	/* struct crypto_stat */
	CRYPTOCFGA_STAT_AEAD,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_COMPRESS,	/* struct crypto_stat */
	CRYPTOCFGA_STAT_RNG,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_CIPHER,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_AKCIPHER,	/* struct crypto_stat */
	CRYPTOCFGA_STAT_KPP,		/* struct crypto_stat */
	CRYPTOCFGA_STAT_ACOMP,		/* struct crypto_stat */
	__CRYPTOCFGA_MAX

#define CRYPTOCFGA_MAX (__CRYPTOCFGA_MAX - 1)
};

struct crypto_user_alg {
	char cru_name[CRYPTO_MAX_NAME];
	char cru_driver_name[CRYPTO_MAX_NAME];
	char cru_module_name[CRYPTO_MAX_NAME];
	__u32 cru_type;
	__u32 cru_mask;
	__u32 cru_refcnt;
	__u32 cru_flags;
};

struct crypto_stat_aead {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_encrypt_cnt;
	__u64 stat_encrypt_tlen;
	__u64 stat_decrypt_cnt;
	__u64 stat_decrypt_tlen;
	__u64 stat_err_cnt;
};

struct crypto_stat_akcipher {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_encrypt_cnt;
	__u64 stat_encrypt_tlen;
	__u64 stat_decrypt_cnt;
	__u64 stat_decrypt_tlen;
	__u64 stat_verify_cnt;
	__u64 stat_sign_cnt;
	__u64 stat_err_cnt;
};

struct crypto_stat_cipher {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_encrypt_cnt;
	__u64 stat_encrypt_tlen;
	__u64 stat_decrypt_cnt;
	__u64 stat_decrypt_tlen;
	__u64 stat_err_cnt;
};

struct crypto_stat_compress {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_compress_cnt;
	__u64 stat_compress_tlen;
	__u64 stat_decompress_cnt;
	__u64 stat_decompress_tlen;
	__u64 stat_err_cnt;
};

struct crypto_stat_hash {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_hash_cnt;
	__u64 stat_hash_tlen;
	__u64 stat_err_cnt;
};

struct crypto_stat_kpp {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_setsecret_cnt;
	__u64 stat_generate_public_key_cnt;
	__u64 stat_compute_shared_secret_cnt;
	__u64 stat_err_cnt;
};

struct crypto_stat_rng {
	char type[CRYPTO_MAX_NAME];
	__u64 stat_generate_cnt;
	__u64 stat_generate_tlen;
	__u64 stat_seed_cnt;
	__u64 stat_err_cnt;
};

struct crypto_stat_larval {
	char type[CRYPTO_MAX_NAME];
};

struct crypto_report_larval {
	char type[CRYPTO_MAX_NAME];
};

struct crypto_report_hash {
	char type[CRYPTO_MAX_NAME];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct crypto_report_cipher {
	char type[CRYPTO_MAX_NAME];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
};

struct crypto_report_blkcipher {
	char type[CRYPTO_MAX_NAME];
	char geniv[CRYPTO_MAX_NAME];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

struct crypto_report_aead {
	char type[CRYPTO_MAX_NAME];
	char geniv[CRYPTO_MAX_NAME];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_report_comp {
	char type[CRYPTO_MAX_NAME];
};

struct crypto_report_rng {
	char type[CRYPTO_MAX_NAME];
	unsigned int seedsize;
};

struct crypto_report_akcipher {
	char type[CRYPTO_MAX_NAME];
};

struct crypto_report_kpp {
	char type[CRYPTO_MAX_NAME];
};

struct crypto_report_acomp {
	char type[CRYPTO_MAX_NAME];
};

#define CRYPTO_REPORT_MAXSIZE (sizeof(struct crypto_user_alg) + \
			       sizeof(struct crypto_report_blkcipher))

#endif /* _LINUX_CRYPTOUSER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * Definitions for talking to the CUDA.  The CUDA is a microcontroller
 * which controls the ADB, system power, RTC, and various other things.
 *
 * Copyright (C) 1996 Paul Mackerras.
 */

#ifndef _LINUX_CUDA_H
#define _LINUX_CUDA_H

/* CUDA commands (2nd byte) */
#define CUDA_WARM_START		0
#define CUDA_AUTOPOLL		1
#define CUDA_GET_6805_ADDR	2
#define CUDA_GET_TIME		3
#define CUDA_GET_PRAM		7
#define CUDA_SET_6805_ADDR	8
#define CUDA_SET_TIME		9
#define CUDA_POWERDOWN		0xa
#define CUDA_POWERUP_TIME	0xb
#define CUDA_SET_PRAM		0xc
#define CUDA_MS_RESET		0xd
#define CUDA_SEND_DFAC		0xe
#define CUDA_RESET_SYSTEM	0x11
#define CUDA_SET_IPL		0x12
#define CUDA_SET_AUTO_RATE	0x14
#define CUDA_GET_AUTO_RATE	0x16
#define CUDA_SET_DEVICE_LIST	0x19
#define CUDA_GET_DEVICE_LIST	0x1a
#define CUDA_GET_SET_IIC	0x22


#endif /* _LINUX_CUDA_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/* $Revision: 3.0 $$Date: 1998/11/02 14:20:59 $
 * linux/include/linux/cyclades.h
 *
 * This file was initially written by
 * Randolph Bentson <bentson@grieg.seaslug.org> and is maintained by
 * Ivan Passos <ivan@cyclades.com>.
 *
 * This file contains the general definitions for the cyclades.c driver
 *$Log: cyclades.h,v $
 *Revision 3.1  2002/01/29 11:36:16  henrique
 *added throttle field on struct cyclades_port to indicate whether the
 *port is throttled or not
 *
 *Revision 3.1  2000/04/19 18:52:52  ivan
 *converted address fields to unsigned long and added fields for physical
 *addresses on cyclades_card structure;
 *
 *Revision 3.0  1998/11/02 14:20:59  ivan
 *added nports field on cyclades_card structure;
 *
 *Revision 2.5  1998/08/03 16:57:01  ivan
 *added cyclades_idle_stats structure;
 * 
 *Revision 2.4  1998/06/01 12:09:53  ivan
 *removed closing_wait2 from cyclades_port structure;
 *
 *Revision 2.3  1998/03/16 18:01:12  ivan
 *changes in the cyclades_port structure to get it closer to the 
 *standard serial port structure;
 *added constants for new ioctls;
 *
 *Revision 2.2  1998/02/17 16:50:00  ivan
 *changes in the cyclades_port structure (addition of shutdown_wait and 
 *chip_rev variables);
 *added constants for new ioctls and for CD1400 rev. numbers.
 *
 *Revision 2.1	1997/10/24 16:03:00  ivan
 *added rflow (which allows enabling the CD1400 special flow control 
 *feature) and rtsdtr_inv (which allows DTR/RTS pin inversion) to 
 *cyclades_port structure;
 *added Alpha support
 *
 *Revision 2.0  1997/06/30 10:30:00  ivan
 *added some new doorbell command constants related to IOCTLW and
 *UART error signaling
 *
 *Revision 1.8  1997/06/03 15:30:00  ivan
 *added constant ZFIRM_HLT
 *added constant CyPCI_Ze_win ( = 2 * Cy_PCI_Zwin)
 *
 *Revision 1.7  1997/03/26 10:30:00  daniel
 *new entries at the end of cyclades_port struct to reallocate
 *variables illegally allocated within card memory.
 *
 *Revision 1.6  1996/09/09 18:35:30  bentson
 *fold in changes for Cyclom-Z -- including structures for
 *communicating with board as well modest changes to original
 *structures to support new features.
 *
 *Revision 1.5  1995/11/13 21:13:31  bentson
 *changes suggested by Michael Chastain <mec@duracef.shout.net>
 *to support use of this file in non-kernel applications
 *
 *
 */

#ifndef _LINUX_CYCLADES_H
#define _LINUX_CYCLADES_H

#include <linux/types.h>

struct cyclades_monitor {
        unsigned long           int_count;
        unsigned long           char_count;
        unsigned long           char_max;
        unsigned long           char_last;
};

/*
 * These stats all reflect activity since the device was last initialized.
 * (i.e., since the port was opened with no other processes already having it
 * open)
 */
struct cyclades_idle_stats {
    __kernel_old_time_t in_use;	/* Time device has been in use (secs) */
    __kernel_old_time_t recv_idle; /* Time since last char received (secs) */
    __kernel_old_time_t xmit_idle; /* Time since last char transmitted (secs) */
    unsigned long  recv_bytes;	/* Bytes received */
    unsigned long  xmit_bytes;	/* Bytes transmitted */
    unsigned long  overruns;	/* Input overruns */
    unsigned long  frame_errs;	/* Input framing errors */
    unsigned long  parity_errs;	/* Input parity errors */
};

#define CYCLADES_MAGIC  0x4359

#define CYGETMON                0x435901
#define CYGETTHRESH             0x435902
#define CYSETTHRESH             0x435903
#define CYGETDEFTHRESH          0x435904
#define CYSETDEFTHRESH          0x435905
#define CYGETTIMEOUT            0x435906
#define CYSETTIMEOUT            0x435907
#define CYGETDEFTIMEOUT         0x435908
#define CYSETDEFTIMEOUT         0x435909
#define CYSETRFLOW		0x43590a
#define CYGETRFLOW		0x43590b
#define CYSETRTSDTR_INV		0x43590c
#define CYGETRTSDTR_INV		0x43590d
#define CYZSETPOLLCYCLE		0x43590e
#define CYZGETPOLLCYCLE		0x43590f
#define CYGETCD1400VER		0x435910
#define	CYSETWAIT		0x435912
#define	CYGETWAIT		0x435913

/*************** CYCLOM-Z ADDITIONS ***************/

#define CZIOC           ('M' << 8)
#define CZ_NBOARDS      (CZIOC|0xfa)
#define CZ_BOOT_START   (CZIOC|0xfb)
#define CZ_BOOT_DATA    (CZIOC|0xfc)
#define CZ_BOOT_END     (CZIOC|0xfd)
#define CZ_TEST         (CZIOC|0xfe)

#define CZ_DEF_POLL	(HZ/25)

#define MAX_BOARD       4       /* Max number of boards */
#define MAX_DEV         256     /* Max number of ports total */
#define	CYZ_MAX_SPEED	921600

#define	CYZ_FIFO_SIZE	16

#define CYZ_BOOT_NWORDS 0x100
struct CYZ_BOOT_CTRL {
        unsigned short  nboard;
        int             status[MAX_BOARD];
        int             nchannel[MAX_BOARD];
        int             fw_rev[MAX_BOARD];
        unsigned long   offset;
        unsigned long   data[CYZ_BOOT_NWORDS];
};


#ifndef DP_WINDOW_SIZE
/*
 *	Memory Window Sizes
 */

#define	DP_WINDOW_SIZE		(0x00080000)	/* window size 512 Kb */
#define	ZE_DP_WINDOW_SIZE	(0x00100000)	/* window size 1 Mb (Ze and
						  8Zo V.2 */
#define	CTRL_WINDOW_SIZE	(0x00000080)	/* runtime regs 128 bytes */

/*
 *	CUSTOM_REG - Cyclom-Z/PCI Custom Registers Set. The driver
 *	normally will access only interested on the fpga_id, fpga_version,
 *	start_cpu and stop_cpu.
 */

struct	CUSTOM_REG {
	__u32	fpga_id;		/* FPGA Identification Register */
	__u32	fpga_version;		/* FPGA Version Number Register */
	__u32	cpu_start;		/* CPU start Register (write) */
	__u32	cpu_stop;		/* CPU stop Register (write) */
	__u32	misc_reg;		/* Miscellaneous Register */
	__u32	idt_mode;		/* IDT mode Register */
	__u32	uart_irq_status;	/* UART IRQ status Register */
	__u32	clear_timer0_irq;	/* Clear timer interrupt Register */
	__u32	clear_timer1_irq;	/* Clear timer interrupt Register */
	__u32	clear_timer2_irq;	/* Clear timer interrupt Register */
	__u32	test_register;		/* Test Register */
	__u32	test_count;		/* Test Count Register */
	__u32	timer_select;		/* Timer select register */
	__u32	pr_uart_irq_status;	/* Prioritized UART IRQ stat Reg */
	__u32	ram_wait_state;		/* RAM wait-state Register */
	__u32	uart_wait_state;	/* UART wait-state Register */
	__u32	timer_wait_state;	/* timer wait-state Register */
	__u32	ack_wait_state;		/* ACK wait State Register */
};

/*
 *	RUNTIME_9060 - PLX PCI9060ES local configuration and shared runtime
 *	registers. This structure can be used to access the 9060 registers
 *	(memory mapped).
 */

struct RUNTIME_9060 {
	__u32	loc_addr_range;	/* 00h - Local Address Range */
	__u32	loc_addr_base;	/* 04h - Local Address Base */
	__u32	loc_arbitr;	/* 08h - Local Arbitration */
	__u32	endian_descr;	/* 0Ch - Big/Little Endian Descriptor */
	__u32	loc_rom_range;	/* 10h - Local ROM Range */
	__u32	loc_rom_base;	/* 14h - Local ROM Base */
	__u32	loc_bus_descr;	/* 18h - Local Bus descriptor */
	__u32	loc_range_mst;	/* 1Ch - Local Range for Master to PCI */
	__u32	loc_base_mst;	/* 20h - Local Base for Master PCI */
	__u32	loc_range_io;	/* 24h - Local Range for Master IO */
	__u32	pci_base_mst;	/* 28h - PCI Base for Master PCI */
	__u32	pci_conf_io;	/* 2Ch - PCI configuration for Master IO */
	__u32	filler1;	/* 30h */
	__u32	filler2;	/* 34h */
	__u32	filler3;	/* 38h */
	__u32	filler4;	/* 3Ch */
	__u32	mail_box_0;	/* 40h - Mail Box 0 */
	__u32	mail_box_1;	/* 44h - Mail Box 1 */
	__u32	mail_box_2;	/* 48h - Mail Box 2 */
	__u32	mail_box_3;	/* 4Ch - Mail Box 3 */
	__u32	filler5;	/* 50h */
	__u32	filler6;	/* 54h */
	__u32	filler7;	/* 58h */
	__u32	filler8;	/* 5Ch */
	__u32	pci_doorbell;	/* 60h - PCI to Local Doorbell */
	__u32	loc_doorbell;	/* 64h - Local to PCI Doorbell */
	__u32	intr_ctrl_stat;	/* 68h - Interrupt Control/Status */
	__u32	init_ctrl;	/* 6Ch - EEPROM control, Init Control, etc */
};

/* Values for the Local Base Address re-map register */

#define	WIN_RAM		0x00000001L	/* set the sliding window to RAM */
#define	WIN_CREG	0x14000001L	/* set the window to custom Registers */

/* Values timer select registers */

#define	TIMER_BY_1M	0x00		/* clock divided by 1M */
#define	TIMER_BY_256K	0x01		/* clock divided by 256k */
#define	TIMER_BY_128K	0x02		/* clock divided by 128k */
#define	TIMER_BY_32K	0x03		/* clock divided by 32k */

/****************** ****************** *******************/
#endif

#ifndef ZFIRM_ID
/* #include "zfwint.h" */
/****************** ****************** *******************/
/*
 *	This file contains the definitions for interfacing with the
 *	Cyclom-Z ZFIRM Firmware.
 */

/* General Constant definitions */

#define	MAX_CHAN	64		/* max number of channels per board */

/* firmware id structure (set after boot) */

#define ID_ADDRESS	0x00000180L	/* signature/pointer address */
#define	ZFIRM_ID	0x5557465AL	/* ZFIRM/U signature */
#define	ZFIRM_HLT	0x59505B5CL	/* ZFIRM needs external power supply */
#define	ZFIRM_RST	0x56040674L	/* RST signal (due to FW reset) */

#define	ZF_TINACT_DEF	1000		/* default inactivity timeout 
					   (1000 ms) */
#define	ZF_TINACT	ZF_TINACT_DEF

struct	FIRM_ID {
	__u32	signature;		/* ZFIRM/U signature */
	__u32	zfwctrl_addr;		/* pointer to ZFW_CTRL structure */
};

/* Op. System id */

#define	C_OS_LINUX	0x00000030	/* generic Linux system */

/* channel op_mode */

#define	C_CH_DISABLE	0x00000000	/* channel is disabled */
#define	C_CH_TXENABLE	0x00000001	/* channel Tx enabled */
#define	C_CH_RXENABLE	0x00000002	/* channel Rx enabled */
#define	C_CH_ENABLE	0x00000003	/* channel Tx/Rx enabled */
#define	C_CH_LOOPBACK	0x00000004	/* Loopback mode */

/* comm_parity - parity */

#define	C_PR_NONE	0x00000000	/* None */
#define	C_PR_ODD	0x00000001	/* Odd */
#define C_PR_EVEN	0x00000002	/* Even */
#define C_PR_MARK	0x00000004	/* Mark */
#define C_PR_SPACE	0x00000008	/* Space */
#define C_PR_PARITY	0x000000ff

#define	C_PR_DISCARD	0x00000100	/* discard char with frame/par error */
#define C_PR_IGNORE	0x00000200	/* ignore frame/par error */

/* comm_data_l - data length and stop bits */

#define C_DL_CS5	0x00000001
#define C_DL_CS6	0x00000002
#define C_DL_CS7	0x00000004
#define C_DL_CS8	0x00000008
#define	C_DL_CS		0x0000000f
#define C_DL_1STOP	0x00000010
#define C_DL_15STOP	0x00000020
#define C_DL_2STOP	0x00000040
#define	C_DL_STOP	0x000000f0

/* interrupt enabling/status */

#define	C_IN_DISABLE	0x00000000	/* zero, disable interrupts */
#define	C_IN_TXBEMPTY	0x00000001	/* tx buffer empty */
#define	C_IN_TXLOWWM	0x00000002	/* tx buffer below LWM */
#define	C_IN_RXHIWM	0x00000010	/* rx buffer above HWM */
#define	C_IN_RXNNDT	0x00000020	/* rx no new data timeout */
#define	C_IN_MDCD	0x00000100	/* modem DCD change */
#define	C_IN_MDSR	0x00000200	/* modem DSR change */
#define	C_IN_MRI	0x00000400	/* modem RI change */
#define	C_IN_MCTS	0x00000800	/* modem CTS change */
#define	C_IN_RXBRK	0x00001000	/* Break received */
#define	C_IN_PR_ERROR	0x00002000	/* parity error */
#define	C_IN_FR_ERROR	0x00004000	/* frame error */
#define C_IN_OVR_ERROR  0x00008000      /* overrun error */
#define C_IN_RXOFL	0x00010000      /* RX buffer overflow */
#define C_IN_IOCTLW	0x00020000      /* I/O control w/ wait */
#define C_IN_MRTS	0x00040000	/* modem RTS drop */
#define C_IN_ICHAR	0x00080000
 
/* flow control */

#define	C_FL_OXX	0x00000001	/* output Xon/Xoff flow control */
#define	C_FL_IXX	0x00000002	/* output Xon/Xoff flow control */
#define C_FL_OIXANY	0x00000004	/* output Xon/Xoff (any xon) */
#define	C_FL_SWFLOW	0x0000000f

/* flow status */

#define	C_FS_TXIDLE	0x00000000	/* no Tx data in the buffer or UART */
#define	C_FS_SENDING	0x00000001	/* UART is sending data */
#define	C_FS_SWFLOW	0x00000002	/* Tx is stopped by received Xoff */

/* rs_control/rs_status RS-232 signals */

#define C_RS_PARAM	0x80000000	/* Indicates presence of parameter in 
					   IOCTLM command */
#define	C_RS_RTS	0x00000001	/* RTS */
#define	C_RS_DTR	0x00000004	/* DTR */
#define	C_RS_DCD	0x00000100	/* CD */
#define	C_RS_DSR	0x00000200	/* DSR */
#define	C_RS_RI		0x00000400	/* RI */
#define	C_RS_CTS	0x00000800	/* CTS */

/* commands Host <-> Board */

#define	C_CM_RESET	0x01		/* reset/flush buffers */
#define	C_CM_IOCTL	0x02		/* re-read CH_CTRL */
#define	C_CM_IOCTLW	0x03		/* re-read CH_CTRL, intr when done */
#define	C_CM_IOCTLM	0x04		/* RS-232 outputs change */
#define	C_CM_SENDXOFF	0x10		/* send Xoff */
#define	C_CM_SENDXON	0x11		/* send Xon */
#define C_CM_CLFLOW	0x12		/* Clear flow control (resume) */
#define	C_CM_SENDBRK	0x41		/* send break */
#define	C_CM_INTBACK	0x42		/* Interrupt back */
#define	C_CM_SET_BREAK	0x43		/* Tx break on */
#define	C_CM_CLR_BREAK	0x44		/* Tx break off */
#define	C_CM_CMD_DONE	0x45		/* Previous command done */
#define C_CM_INTBACK2	0x46		/* Alternate Interrupt back */
#define	C_CM_TINACT	0x51		/* set inactivity detection */
#define	C_CM_IRQ_ENBL	0x52		/* enable generation of interrupts */
#define	C_CM_IRQ_DSBL	0x53		/* disable generation of interrupts */
#define	C_CM_ACK_ENBL	0x54		/* enable acknowledged interrupt mode */
#define	C_CM_ACK_DSBL	0x55		/* disable acknowledged intr mode */
#define	C_CM_FLUSH_RX	0x56		/* flushes Rx buffer */
#define	C_CM_FLUSH_TX	0x57		/* flushes Tx buffer */
#define C_CM_Q_ENABLE	0x58		/* enables queue access from the 
					   driver */
#define C_CM_Q_DISABLE  0x59            /* disables queue access from the 
					   driver */

#define	C_CM_TXBEMPTY	0x60		/* Tx buffer is empty */
#define	C_CM_TXLOWWM	0x61		/* Tx buffer low water mark */
#define	C_CM_RXHIWM	0x62		/* Rx buffer high water mark */
#define	C_CM_RXNNDT	0x63		/* rx no new data timeout */
#define	C_CM_TXFEMPTY	0x64
#define	C_CM_ICHAR	0x65
#define	C_CM_MDCD	0x70		/* modem DCD change */
#define	C_CM_MDSR	0x71		/* modem DSR change */
#define	C_CM_MRI	0x72		/* modem RI change */
#define	C_CM_MCTS	0x73		/* modem CTS change */
#define C_CM_MRTS	0x74		/* modem RTS drop */
#define	C_CM_RXBRK	0x84		/* Break received */
#define	C_CM_PR_ERROR	0x85		/* Parity error */
#define	C_CM_FR_ERROR	0x86		/* Frame error */
#define C_CM_OVR_ERROR  0x87            /* Overrun error */
#define C_CM_RXOFL	0x88            /* RX buffer overflow */
#define	C_CM_CMDERROR	0x90		/* command error */
#define	C_CM_FATAL	0x91		/* fatal error */
#define	C_CM_HW_RESET	0x92		/* reset board */

/*
 *	CH_CTRL - This per port structure contains all parameters
 *	that control an specific port. It can be seen as the
 *	configuration registers of a "super-serial-controller".
 */

struct CH_CTRL {
	__u32	op_mode;	/* operation mode */
	__u32	intr_enable;	/* interrupt masking */
	__u32	sw_flow;	/* SW flow control */
	__u32	flow_status;	/* output flow status */
	__u32	comm_baud;	/* baud rate  - numerically specified */
	__u32	comm_parity;	/* parity */
	__u32	comm_data_l;	/* data length/stop */
	__u32	comm_flags;	/* other flags */
	__u32	hw_flow;	/* HW flow control */
	__u32	rs_control;	/* RS-232 outputs */
	__u32	rs_status;	/* RS-232 inputs */
	__u32	flow_xon;	/* xon char */
	__u32	flow_xoff;	/* xoff char */
	__u32	hw_overflow;	/* hw overflow counter */
	__u32	sw_overflow;	/* sw overflow counter */
	__u32	comm_error;	/* frame/parity error counter */
	__u32 ichar;
	__u32 filler[7];
};


/*
 *	BUF_CTRL - This per channel structure contains
 *	all Tx and Rx buffer control for a given channel.
 */

struct	BUF_CTRL	{
	__u32	flag_dma;	/* buffers are in Host memory */
	__u32	tx_bufaddr;	/* address of the tx buffer */
	__u32	tx_bufsize;	/* tx buffer size */
	__u32	tx_threshold;	/* tx low water mark */
	__u32	tx_get;		/* tail index tx buf */
	__u32	tx_put;		/* head index tx buf */
	__u32	rx_bufaddr;	/* address of the rx buffer */
	__u32	rx_bufsize;	/* rx buffer size */
	__u32	rx_threshold;	/* rx high water mark */
	__u32	rx_get;		/* tail index rx buf */
	__u32	rx_put;		/* head index rx buf */
	__u32	filler[5];	/* filler to align structures */
};

/*
 *	BOARD_CTRL - This per board structure contains all global 
 *	control fields related to the board.
 */

struct BOARD_CTRL {

	/* static info provided by the on-board CPU */
	__u32	n_channel;	/* number of channels */
	__u32	fw_version;	/* firmware version */

	/* static info provided by the driver */
	__u32	op_system;	/* op_system id */
	__u32	dr_version;	/* driver version */

	/* board control area */
	__u32	inactivity;	/* inactivity control */

	/* host to FW commands */
	__u32	hcmd_channel;	/* channel number */
	__u32	hcmd_param;	/* pointer to parameters */

	/* FW to Host commands */
	__u32	fwcmd_channel;	/* channel number */
	__u32	fwcmd_param;	/* pointer to parameters */
	__u32	zf_int_queue_addr; /* offset for INT_QUEUE structure */

	/* filler so the structures are aligned */
	__u32	filler[6];
};

/* Host Interrupt Queue */

#define QUEUE_SIZE	(10*MAX_CHAN)

struct	INT_QUEUE {
	unsigned char	intr_code[QUEUE_SIZE];
	unsigned long	channel[QUEUE_SIZE];
	unsigned long	param[QUEUE_SIZE];
	unsigned long	put;
	unsigned long	get;
};

/*
 *	ZFW_CTRL - This is the data structure that includes all other
 *	data structures used by the Firmware.
 */
 
struct ZFW_CTRL {
	struct BOARD_CTRL	board_ctrl;
	struct CH_CTRL		ch_ctrl[MAX_CHAN];
	struct BUF_CTRL		buf_ctrl[MAX_CHAN];
};

/****************** ****************** *******************/
#endif

#endif /* _LINUX_CYCLADES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                /* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
* cycx_cfm.h	Cyclom 2X WAN Link Driver.
*		Definitions for the Cyclom 2X Firmware Module (CFM).
*
* Author:	Arnaldo Carvalho de Melo <acme@conectiva.com.br>
*
* Copyright:	(c) 1998-2003 Arnaldo Carvalho de Melo
*
* Based on sdlasfm.h by Gene Kozin <74604.152@compuserve.com>
*
*		This program is free software; you can redistribute it and/or
*		modify it under the terms of the GNU General Public License
*		as published by the Free Software Foundation; either version
*		2 of the License, or (at your option) any later version.
* ============================================================================
* 1998/08/08	acme		Initial version.
*/
#ifndef	_CYCX_CFM_H
#define	_CYCX_CFM_H

/* Defines */

#define	CFM_VERSION	2
#define	CFM_SIGNATURE	"CFM - Cyclades CYCX Firmware Module"

/* min/max */
#define	CFM_IMAGE_SIZE	0x20000	/* max size of CYCX code image file */
#define	CFM_DESCR_LEN	256	/* max length of description string */
#define	CFM_MAX_CYCX	1	/* max number of compatible adapters */
#define	CFM_LOAD_BUFSZ	0x400	/* buffer size for reset code (buffer_load) */

/* Firmware Commands */
#define GEN_POWER_ON	0x1280

#define GEN_SET_SEG	0x1401	/* boot segment setting. */
#define GEN_BOOT_DAT	0x1402	/* boot data. */
#define GEN_START	0x1403	/* board start. */
#define GEN_DEFPAR	0x1404	/* buffer length for boot. */

/* Adapter Types */
#define CYCX_2X		2
/* for now only the 2X is supported, no plans to support 8X or 16X */
#define CYCX_8X		8
#define CYCX_16X	16

#define	CFID_X25_2X	5200

/**
 *	struct cycx_fw_info - firmware module information.
 *	@codeid - firmware ID
 *	@version - firmware version number
 *	@adapter - compatible adapter types
 *	@memsize - minimum memory size
 *	@reserved - reserved
 *	@startoffs - entry point offset
 *	@winoffs - dual-port memory window offset
 *	@codeoffs - code load offset
 *	@codesize - code size
 *	@dataoffs - configuration data load offset
 *	@datasize - configuration data size
 */
struct cycx_fw_info {
	unsigned short	codeid;
	unsigned short	version;
	unsigned short	adapter[CFM_MAX_CYCX];
	unsigned long	memsize;
	unsigned short	reserved[2];
	unsigned short	startoffs;
	unsigned short	winoffs;
	unsigned short	codeoffs;
	unsigned long	codesize;
	unsigned short	dataoffs;
	unsigned long	datasize;
};

/**
 *	struct cycx_firmware - CYCX firmware file structure
 *	@signature - CFM file signature
 *	@version - file format version
 *	@checksum - info + image
 *	@reserved - reserved
 *	@descr - description string
 *	@info - firmware module info
 *	@image - code image (variable size)
 */
struct cycx_firmware {
	char		    signature[80];
	unsigned short	    version;
	unsigned short	    checksum;
	unsigned short	    reserved[6];
	char		    descr[CFM_DESCR_LEN];
	struct cycx_fw_info info;
	unsigned char	    image[0];
};

struct cycx_fw_header {
	unsigned long  reset_size;
	unsigned long  data_size;
	unsigned long  code_size;
};
#endif	/* _CYCX_CFM_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * Copyright (c) 2008-2011, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place - Suite 330, Boston, MA 02111-1307 USA.
 *
 * Author: Lucy Liu <lucy.liu@intel.com>
 */

#ifndef __LINUX_DCBNL_H__
#define __LINUX_DCBNL_H__

#include <linux/types.h>

/* IEEE 802.1Qaz std supported values */
#define IEEE_8021QAZ_MAX_TCS	8

#define IEEE_8021QAZ_TSA_STRICT		0
#define IEEE_8021QAZ_TSA_CB_SHAPER	1
#define IEEE_8021QAZ_TSA_ETS		2
#define IEEE_8021QAZ_TSA_VENDOR		255

/* This structure contains the IEEE 802.1Qaz ETS managed object
 *
 * @willing: willing bit in ETS configuration TLV
 * @ets_cap: indicates supported capacity of ets feature
 * @cbs: credit based shaper ets algorithm supported
 * @tc_tx_bw: tc tx bandwidth indexed by traffic class
 * @tc_rx_bw: tc rx bandwidth indexed by traffic class
 * @tc_tsa: TSA Assignment table, indexed by traffic class
 * @prio_tc: priority assignment table mapping 8021Qp to traffic class
 * @tc_reco_bw: recommended tc bandwidth indexed by traffic class for TLV
 * @tc_reco_tsa: recommended tc bandwidth indexed by traffic class for TLV
 * @reco_prio_tc: recommended tc tx bandwidth indexed by traffic class for TLV
 *
 * Recommended values are used to set fields in the ETS recommendation TLV
 * with hardware offloaded LLDP.
 *
 * ----
 *  TSA Assignment 8 bit identifiers
 *	0	strict priority
 *	1	credit-based shaper
 *	2	enhanced transmission selection
 *	3-254	reserved
 *	255	vendor specific
 */
struct ieee_ets {
	__u8	willing;
	__u8	ets_cap;
	__u8	cbs;
	__u8	tc_tx_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_rx_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_tsa[IEEE_8021QAZ_MAX_TCS];
	__u8	prio_tc[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_reco_bw[IEEE_8021QAZ_MAX_TCS];
	__u8	tc_reco_tsa[IEEE_8021QAZ_MAX_TCS];
	__u8	reco_prio_tc[IEEE_8021QAZ_MAX_TCS];
};

/* This structure contains rate limit extension to the IEEE 802.1Qaz ETS
 * managed object.
 * Values are 64 bits long and specified in Kbps to enable usage over both
 * slow and very fast networks.
 *
 * @tc_maxrate: maximal tc tx bandwidth indexed by traffic class
 */
struct ieee_maxrate {
	__u64	tc_maxrate[IEEE_8021QAZ_MAX_TCS];
};

enum dcbnl_cndd_states {
	DCB_CNDD_RESET = 0,
	DCB_CNDD_EDGE,
	DCB_CNDD_INTERIOR,
	DCB_CNDD_INTERIOR_READY,
};

/* This structure contains the IEEE 802.1Qau QCN managed object.
 *
 *@rpg_enable: enable QCN RP
 *@rppp_max_rps: maximum number of RPs allowed for this CNPV on this port
 *@rpg_time_reset: time between rate increases if no CNMs received.
 *		   given in u-seconds
 *@rpg_byte_reset: transmitted data between rate increases if no CNMs received.
 *		   given in Bytes
 *@rpg_threshold: The number of times rpByteStage or rpTimeStage can count
 *		   before RP rate control state machine advances states
 *@rpg_max_rate: the maxinun rate, in Mbits per second,
 *		 at which an RP can transmit
 *@rpg_ai_rate: The rate, in Mbits per second,
 *		used to increase rpTargetRate in the RPR_ACTIVE_INCREASE
 *@rpg_hai_rate: The rate, in Mbits per second,
 *		 used to increase rpTargetRate in the RPR_HYPER_INCREASE state
 *@rpg_gd: Upon CNM receive, flow rate is limited to (Fb/Gd)*CurrentRate.
 *	   rpgGd is given as log2(Gd), where Gd may only be powers of 2
 *@rpg_min_dec_fac: The minimum factor by which the current transmit rate
 *		    can be changed by reception of a CNM.
 *		    value is given as percentage (1-100)
 *@rpg_min_rate: The minimum value, in bits per second, for rate to limit
 *@cndd_state_machine: The state of the congestion notification domain
 *		       defense state machine, as defined by IEEE 802.3Qau
 *		       section 32.1.1. In the interior ready state,
 *		       the QCN capable hardware may add CN-TAG TLV to the
 *		       outgoing traffic, to specifically identify outgoing
 *		       flows.
 */

struct ieee_qcn {
	__u8 rpg_enable[IEEE_8021QAZ_MAX_TCS];
	__u32 rppp_max_rps[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_time_reset[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_byte_reset[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_threshold[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_max_rate[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_ai_rate[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_hai_rate[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_gd[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_min_dec_fac[IEEE_8021QAZ_MAX_TCS];
	__u32 rpg_min_rate[IEEE_8021QAZ_MAX_TCS];
	__u32 cndd_state_machine[IEEE_8021QAZ_MAX_TCS];
};

/* This structure contains the IEEE 802.1Qau QCN statistics.
 *
 *@rppp_rp_centiseconds: the number of RP-centiseconds accumulated
 *			 by RPs at this priority level on this Port
 *@rppp_created_rps: number of active RPs(flows) that react to CNMs
 */

struct ieee_qcn_stats {
	__u64 rppp_rp_centiseconds[IEEE_8021QAZ_MAX_TCS];
	__u32 rppp_created_rps[IEEE_8021QAZ_MAX_TCS];
};

/* This structure contains the IEEE 802.1Qaz PFC managed object
 *
 * @pfc_cap: Indicates the number of traffic classes on the local device
 *	     that may simultaneously have PFC enabled.
 * @pfc_en: bitmap indicating pfc enabled traffic classes
 * @mbc: enable macsec bypass capability
 * @delay: the allowance made for a round-trip propagation delay of the
 *	   link in bits.
 * @requests: count of the sent pfc frames
 * @indications: count of the received pfc frames
 */
struct ieee_pfc {
	__u8	pfc_cap;
	__u8	pfc_en;
	__u8	mbc;
	__u16	delay;
	__u64	requests[IEEE_8021QAZ_MAX_TCS];
	__u64	indications[IEEE_8021QAZ_MAX_TCS];
};

#define IEEE_8021Q_MAX_PRIORITIES 8
#define DCBX_MAX_BUFFERS  8
struct dcbnl_buffer {
	/* priority to buffer mapping */
	__u8    prio2buffer[IEEE_8021Q_MAX_PRIORITIES];
	/* buffer size in Bytes */
	__u32   buffer_size[DCBX_MAX_BUFFERS];
	__u32   total_size;
};

/* CEE DCBX std supported values */
#define CEE_DCBX_MAX_PGS	8
#define CEE_DCBX_MAX_PRIO	8

/**
 * struct cee_pg - CEE Priority-Group managed object
 *
 * @willing: willing bit in the PG tlv
 * @error: error bit in the PG tlv
 * @pg_en: enable bit of the PG feature
 * @tcs_supported: number of traffic classes supported
 * @pg_bw: bandwidth percentage for each priority group
 * @prio_pg: priority to PG mapping indexed by priority
 */
struct cee_pg {
	__u8    willing;
	__u8    error;
	__u8    pg_en;
	__u8    tcs_supported;
	__u8    pg_bw[CEE_DCBX_MAX_PGS];
	__u8    prio_pg[CEE_DCBX_MAX_PGS];
};

/**
 * struct cee_pfc - CEE PFC managed object
 *
 * @willing: willing bit in the PFC tlv
 * @error: error bit in the PFC tlv
 * @pfc_en: bitmap indicating pfc enabled traffic classes
 * @tcs_supported: number of traffic classes supported
 */
struct cee_pfc {
	__u8    willing;
	__u8    error;
	__u8    pfc_en;
	__u8    tcs_supported;
};

/* IEEE 802.1Qaz std supported values */
#define IEEE_8021QAZ_APP_SEL_ETHERTYPE	1
#define IEEE_8021QAZ_APP_SEL_STREAM	2
#define IEEE_8021QAZ_APP_SEL_DGRAM	3
#define IEEE_8021QAZ_APP_SEL_ANY	4
#define IEEE_8021QAZ_APP_SEL_DSCP       5

/* This structure contains the IEEE 802.1Qaz APP managed object. This
 * object is also used for the CEE std as well.
 *
 * @selector: protocol identifier type
 * @protocol: protocol of type indicated
 * @priority: 3-bit unsigned integer indicating priority for IEEE
 *            8-bit 802.1p user priority bitmap for CEE
 *
 * ----
 *  Selector field values for IEEE 802.1Qaz
 *	0	Reserved
 *	1	Ethertype
 *	2	Well known port number over TCP or SCTP
 *	3	Well known port number over UDP or DCCP
 *	4	Well known port number over TCP, SCTP, UDP, or DCCP
 *	5	Differentiated Services Code Point (DSCP) value
 *	6-7	Reserved
 *
 *  Selector field values for CEE
 *	0	Ethertype
 *	1	Well known port number over TCP or UDP
 *	2-3	Reserved
 */
struct dcb_app {
	__u8	selector;
	__u8	priority;
	__u16	protocol;
};

/**
 * struct dcb_peer_app_info - APP feature information sent by the peer
 *
 * @willing: willing bit in the peer APP tlv
 * @error: error bit in the peer APP tlv
 *
 * In addition to this information the full peer APP tlv also contains
 * a table of 'app_count' APP objects defined above.
 */
struct dcb_peer_app_info {
	__u8	willing;
	__u8	error;
};

struct dcbmsg {
	__u8               dcb_family;
	__u8               cmd;
	__u16              dcb_pad;
};

/**
 * enum dcbnl_commands - supported DCB commands
 *
 * @DCB_CMD_UNDEFINED: unspecified command to catch errors
 * @DCB_CMD_GSTATE: request the state of DCB in the device
 * @DCB_CMD_SSTATE: set the state of DCB in the device
 * @DCB_CMD_PGTX_GCFG: request the priority group configuration for Tx
 * @DCB_CMD_PGTX_SCFG: set the priority group configuration for Tx
 * @DCB_CMD_PGRX_GCFG: request the priority group configuration for Rx
 * @DCB_CMD_PGRX_SCFG: set the priority group configuration for Rx
 * @DCB_CMD_PFC_GCFG: request the priority flow control configuration
 * @DCB_CMD_PFC_SCFG: set the priority flow control configuration
 * @DCB_CMD_SET_ALL: apply all changes to the underlying device
 * @DCB_CMD_GPERM_HWADDR: get the permanent MAC address of the underlying
 *                        device.  Only useful when using bonding.
 * @DCB_CMD_GCAP: request the DCB capabilities of the device
 * @DCB_CMD_GNUMTCS: get the number of traffic classes currently supported
 * @DCB_CMD_SNUMTCS: set the number of traffic classes
 * @DCB_CMD_GBCN: set backward congestion notification configuration
 * @DCB_CMD_SBCN: get backward congestion notification configuration.
 * @DCB_CMD_GAPP: get application protocol configuration
 * @DCB_CMD_SAPP: set application protocol configuration
 * @DCB_CMD_IEEE_SET: set IEEE 802.1Qaz configuration
 * @DCB_CMD_IEEE_GET: get IEEE 802.1Qaz configuration
 * @DCB_CMD_GDCBX: get DCBX engine configuration
 * @DCB_CMD_SDCBX: set DCBX engine configuration
 * @DCB_CMD_GFEATCFG: get DCBX features flags
 * @DCB_CMD_SFEATCFG: set DCBX features negotiation flags
 * @DCB_CMD_CEE_GET: get CEE aggregated configuration
 * @DCB_CMD_IEEE_DEL: delete IEEE 802.1Qaz configuration
 */
enum dcbnl_commands {
	DCB_CMD_UNDEFINED,

	DCB_CMD_GSTATE,
	DCB_CMD_SSTATE,

	DCB_CMD_PGTX_GCFG,
	DCB_CMD_PGTX_SCFG,
	DCB_CMD_PGRX_GCFG,
	DCB_CMD_PGRX_SCFG,

	DCB_CMD_PFC_GCFG,
	DCB_CMD_PFC_SCFG,

	DCB_CMD_SET_ALL,

	DCB_CMD_GPERM_HWADDR,

	DCB_CMD_GCAP,

	DCB_CMD_GNUMTCS,
	DCB_CMD_SNUMTCS,

	DCB_CMD_PFC_GSTATE,
	DCB_CMD_PFC_SSTATE,

	DCB_CMD_BCN_GCFG,
	DCB_CMD_BCN_SCFG,

	DCB_CMD_GAPP,
	DCB_CMD_SAPP,

	DCB_CMD_IEEE_SET,
	DCB_CMD_IEEE_GET,

	DCB_CMD_GDCBX,
	DCB_CMD_SDCBX,

	DCB_CMD_GFEATCFG,
	DCB_CMD_SFEATCFG,

	DCB_CMD_CEE_GET,
	DCB_CMD_IEEE_DEL,

	__DCB_CMD_ENUM_MAX,
	DCB_CMD_MAX = __DCB_CMD_ENUM_MAX - 1,
};

/**
 * enum dcbnl_attrs - DCB top-level netlink attributes
 *
 * @DCB_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_ATTR_IFNAME: interface name of the underlying device (NLA_STRING)
 * @DCB_ATTR_STATE: enable state of DCB in the device (NLA_U8)
 * @DCB_ATTR_PFC_STATE: enable state of PFC in the device (NLA_U8)
 * @DCB_ATTR_PFC_CFG: priority flow control configuration (NLA_NESTED)
 * @DCB_ATTR_NUM_TC: number of traffic classes supported in the device (NLA_U8)
 * @DCB_ATTR_PG_CFG: priority group configuration (NLA_NESTED)
 * @DCB_ATTR_SET_ALL: bool to commit changes to hardware or not (NLA_U8)
 * @DCB_ATTR_PERM_HWADDR: MAC address of the physical device (NLA_NESTED)
 * @DCB_ATTR_CAP: DCB capabilities of the device (NLA_NESTED)
 * @DCB_ATTR_NUMTCS: number of traffic classes supported (NLA_NESTED)
 * @DCB_ATTR_BCN: backward congestion notification configuration (NLA_NESTED)
 * @DCB_ATTR_IEEE: IEEE 802.1Qaz supported attributes (NLA_NESTED)
 * @DCB_ATTR_DCBX: DCBX engine configuration in the device (NLA_U8)
 * @DCB_ATTR_FEATCFG: DCBX features flags (NLA_NESTED)
 * @DCB_ATTR_CEE: CEE std supported attributes (NLA_NESTED)
 */
enum dcbnl_attrs {
	DCB_ATTR_UNDEFINED,

	DCB_ATTR_IFNAME,
	DCB_ATTR_STATE,
	DCB_ATTR_PFC_STATE,
	DCB_ATTR_PFC_CFG,
	DCB_ATTR_NUM_TC,
	DCB_ATTR_PG_CFG,
	DCB_ATTR_SET_ALL,
	DCB_ATTR_PERM_HWADDR,
	DCB_ATTR_CAP,
	DCB_ATTR_NUMTCS,
	DCB_ATTR_BCN,
	DCB_ATTR_APP,

	/* IEEE std attributes */
	DCB_ATTR_IEEE,

	DCB_ATTR_DCBX,
	DCB_ATTR_FEATCFG,

	/* CEE nested attributes */
	DCB_ATTR_CEE,

	__DCB_ATTR_ENUM_MAX,
	DCB_ATTR_MAX = __DCB_ATTR_ENUM_MAX - 1,
};

/**
 * enum ieee_attrs - IEEE 802.1Qaz get/set attributes
 *
 * @DCB_ATTR_IEEE_UNSPEC: unspecified
 * @DCB_ATTR_IEEE_ETS: negotiated ETS configuration
 * @DCB_ATTR_IEEE_PFC: negotiated PFC configuration
 * @DCB_ATTR_IEEE_APP_TABLE: negotiated APP configuration
 * @DCB_ATTR_IEEE_PEER_ETS: peer ETS configuration - get only
 * @DCB_ATTR_IEEE_PEER_PFC: peer PFC configuration - get only
 * @DCB_ATTR_IEEE_PEER_APP: peer APP tlv - get only
 */
enum ieee_attrs {
	DCB_ATTR_IEEE_UNSPEC,
	DCB_ATTR_IEEE_ETS,
	DCB_ATTR_IEEE_PFC,
	DCB_ATTR_IEEE_APP_TABLE,
	DCB_ATTR_IEEE_PEER_ETS,
	DCB_ATTR_IEEE_PEER_PFC,
	DCB_ATTR_IEEE_PEER_APP,
	DCB_ATTR_IEEE_MAXRATE,
	DCB_ATTR_IEEE_QCN,
	DCB_ATTR_IEEE_QCN_STATS,
	DCB_ATTR_DCB_BUFFER,
	__DCB_ATTR_IEEE_MAX
};
#define DCB_ATTR_IEEE_MAX (__DCB_ATTR_IEEE_MAX - 1)

enum ieee_attrs_app {
	DCB_ATTR_IEEE_APP_UNSPEC,
	DCB_ATTR_IEEE_APP,
	__DCB_ATTR_IEEE_APP_MAX
};
#define DCB_ATTR_IEEE_APP_MAX (__DCB_ATTR_IEEE_APP_MAX - 1)

/**
 * enum cee_attrs - CEE DCBX get attributes.
 *
 * @DCB_ATTR_CEE_UNSPEC: unspecified
 * @DCB_ATTR_CEE_PEER_PG: peer PG configuration - get only
 * @DCB_ATTR_CEE_PEER_PFC: peer PFC configuration - get only
 * @DCB_ATTR_CEE_PEER_APP_TABLE: peer APP tlv - get only
 * @DCB_ATTR_CEE_TX_PG: TX PG configuration (DCB_CMD_PGTX_GCFG)
 * @DCB_ATTR_CEE_RX_PG: RX PG configuration (DCB_CMD_PGRX_GCFG)
 * @DCB_ATTR_CEE_PFC: PFC configuration (DCB_CMD_PFC_GCFG)
 * @DCB_ATTR_CEE_APP_TABLE: APP configuration (multi DCB_CMD_GAPP)
 * @DCB_ATTR_CEE_FEAT: DCBX features flags (DCB_CMD_GFEATCFG)
 *
 * An aggregated collection of the cee std negotiated parameters.
 */
enum cee_attrs {
	DCB_ATTR_CEE_UNSPEC,
	DCB_ATTR_CEE_PEER_PG,
	DCB_ATTR_CEE_PEER_PFC,
	DCB_ATTR_CEE_PEER_APP_TABLE,
	DCB_ATTR_CEE_TX_PG,
	DCB_ATTR_CEE_RX_PG,
	DCB_ATTR_CEE_PFC,
	DCB_ATTR_CEE_APP_TABLE,
	DCB_ATTR_CEE_FEAT,
	__DCB_ATTR_CEE_MAX
};
#define DCB_ATTR_CEE_MAX (__DCB_ATTR_CEE_MAX - 1)

enum peer_app_attr {
	DCB_ATTR_CEE_PEER_APP_UNSPEC,
	DCB_ATTR_CEE_PEER_APP_INFO,
	DCB_ATTR_CEE_PEER_APP,
	__DCB_ATTR_CEE_PEER_APP_MAX
};
#define DCB_ATTR_CEE_PEER_APP_MAX (__DCB_ATTR_CEE_PEER_APP_MAX - 1)

enum cee_attrs_app {
	DCB_ATTR_CEE_APP_UNSPEC,
	DCB_ATTR_CEE_APP,
	__DCB_ATTR_CEE_APP_MAX
};
#define DCB_ATTR_CEE_APP_MAX (__DCB_ATTR_CEE_APP_MAX - 1)

/**
 * enum dcbnl_pfc_attrs - DCB Priority Flow Control user priority nested attrs
 *
 * @DCB_PFC_UP_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_PFC_UP_ATTR_0: Priority Flow Control value for User Priority 0 (NLA_U8)
 * @DCB_PFC_UP_ATTR_1: Priority Flow Control value for User Priority 1 (NLA_U8)
 * @DCB_PFC_UP_ATTR_2: Priority Flow Control value for User Priority 2 (NLA_U8)
 * @DCB_PFC_UP_ATTR_3: Priority Flow Control value for User Priority 3 (NLA_U8)
 * @DCB_PFC_UP_ATTR_4: Priority Flow Control value for User Priority 4 (NLA_U8)
 * @DCB_PFC_UP_ATTR_5: Priority Flow Control value for User Priority 5 (NLA_U8)
 * @DCB_PFC_UP_ATTR_6: Priority Flow Control value for User Priority 6 (NLA_U8)
 * @DCB_PFC_UP_ATTR_7: Priority Flow Control value for User Priority 7 (NLA_U8)
 * @DCB_PFC_UP_ATTR_MAX: highest attribute number currently defined
 * @DCB_PFC_UP_ATTR_ALL: apply to all priority flow control attrs (NLA_FLAG)
 *
 */
enum dcbnl_pfc_up_attrs {
	DCB_PFC_UP_ATTR_UNDEFINED,

	DCB_PFC_UP_ATTR_0,
	DCB_PFC_UP_ATTR_1,
	DCB_PFC_UP_ATTR_2,
	DCB_PFC_UP_ATTR_3,
	DCB_PFC_UP_ATTR_4,
	DCB_PFC_UP_ATTR_5,
	DCB_PFC_UP_ATTR_6,
	DCB_PFC_UP_ATTR_7,
	DCB_PFC_UP_ATTR_ALL,

	__DCB_PFC_UP_ATTR_ENUM_MAX,
	DCB_PFC_UP_ATTR_MAX = __DCB_PFC_UP_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_pg_attrs - DCB Priority Group attributes
 *
 * @DCB_PG_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_PG_ATTR_TC_0: Priority Group Traffic Class 0 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_1: Priority Group Traffic Class 1 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_2: Priority Group Traffic Class 2 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_3: Priority Group Traffic Class 3 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_4: Priority Group Traffic Class 4 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_5: Priority Group Traffic Class 5 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_6: Priority Group Traffic Class 6 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_7: Priority Group Traffic Class 7 configuration (NLA_NESTED)
 * @DCB_PG_ATTR_TC_MAX: highest attribute number currently defined
 * @DCB_PG_ATTR_TC_ALL: apply to all traffic classes (NLA_NESTED)
 * @DCB_PG_ATTR_BW_ID_0: Percent of link bandwidth for Priority Group 0 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_1: Percent of link bandwidth for Priority Group 1 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_2: Percent of link bandwidth for Priority Group 2 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_3: Percent of link bandwidth for Priority Group 3 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_4: Percent of link bandwidth for Priority Group 4 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_5: Percent of link bandwidth for Priority Group 5 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_6: Percent of link bandwidth for Priority Group 6 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_7: Percent of link bandwidth for Priority Group 7 (NLA_U8)
 * @DCB_PG_ATTR_BW_ID_MAX: highest attribute number currently defined
 * @DCB_PG_ATTR_BW_ID_ALL: apply to all priority groups (NLA_FLAG)
 *
 */
enum dcbnl_pg_attrs {
	DCB_PG_ATTR_UNDEFINED,

	DCB_PG_ATTR_TC_0,
	DCB_PG_ATTR_TC_1,
	DCB_PG_ATTR_TC_2,
	DCB_PG_ATTR_TC_3,
	DCB_PG_ATTR_TC_4,
	DCB_PG_ATTR_TC_5,
	DCB_PG_ATTR_TC_6,
	DCB_PG_ATTR_TC_7,
	DCB_PG_ATTR_TC_MAX,
	DCB_PG_ATTR_TC_ALL,

	DCB_PG_ATTR_BW_ID_0,
	DCB_PG_ATTR_BW_ID_1,
	DCB_PG_ATTR_BW_ID_2,
	DCB_PG_ATTR_BW_ID_3,
	DCB_PG_ATTR_BW_ID_4,
	DCB_PG_ATTR_BW_ID_5,
	DCB_PG_ATTR_BW_ID_6,
	DCB_PG_ATTR_BW_ID_7,
	DCB_PG_ATTR_BW_ID_MAX,
	DCB_PG_ATTR_BW_ID_ALL,

	__DCB_PG_ATTR_ENUM_MAX,
	DCB_PG_ATTR_MAX = __DCB_PG_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_tc_attrs - DCB Traffic Class attributes
 *
 * @DCB_TC_ATTR_PARAM_UNDEFINED: unspecified attribute to catch errors
 * @DCB_TC_ATTR_PARAM_PGID: (NLA_U8) Priority group the traffic class belongs to
 *                          Valid values are:  0-7
 * @DCB_TC_ATTR_PARAM_UP_MAPPING: (NLA_U8) Traffic class to user priority map
 *                                Some devices may not support changing the
 *                                user priority map of a TC.
 * @DCB_TC_ATTR_PARAM_STRICT_PRIO: (NLA_U8) Strict priority setting
 *                                 0 - none
 *                                 1 - group strict
 *                                 2 - link strict
 * @DCB_TC_ATTR_PARAM_BW_PCT: optional - (NLA_U8) If supported by the device and
 *                            not configured to use link strict priority,
 *                            this is the percentage of bandwidth of the
 *                            priority group this traffic class belongs to
 * @DCB_TC_ATTR_PARAM_ALL: (NLA_FLAG) all traffic class parameters
 *
 */
enum dcbnl_tc_attrs {
	DCB_TC_ATTR_PARAM_UNDEFINED,

	DCB_TC_ATTR_PARAM_PGID,
	DCB_TC_ATTR_PARAM_UP_MAPPING,
	DCB_TC_ATTR_PARAM_STRICT_PRIO,
	DCB_TC_ATTR_PARAM_BW_PCT,
	DCB_TC_ATTR_PARAM_ALL,

	__DCB_TC_ATTR_PARAM_ENUM_MAX,
	DCB_TC_ATTR_PARAM_MAX = __DCB_TC_ATTR_PARAM_ENUM_MAX - 1,
};

/**
 * enum dcbnl_cap_attrs - DCB Capability attributes
 *
 * @DCB_CAP_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_CAP_ATTR_ALL: (NLA_FLAG) all capability parameters
 * @DCB_CAP_ATTR_PG: (NLA_U8) device supports Priority Groups
 * @DCB_CAP_ATTR_PFC: (NLA_U8) device supports Priority Flow Control
 * @DCB_CAP_ATTR_UP2TC: (NLA_U8) device supports user priority to
 *                               traffic class mapping
 * @DCB_CAP_ATTR_PG_TCS: (NLA_U8) bitmap where each bit represents a
 *                                number of traffic classes the device
 *                                can be configured to use for Priority Groups
 * @DCB_CAP_ATTR_PFC_TCS: (NLA_U8) bitmap where each bit represents a
 *                                 number of traffic classes the device can be
 *                                 configured to use for Priority Flow Control
 * @DCB_CAP_ATTR_GSP: (NLA_U8) device supports group strict priority
 * @DCB_CAP_ATTR_BCN: (NLA_U8) device supports Backwards Congestion
 *                             Notification
 * @DCB_CAP_ATTR_DCBX: (NLA_U8) device supports DCBX engine
 *
 */
enum dcbnl_cap_attrs {
	DCB_CAP_ATTR_UNDEFINED,
	DCB_CAP_ATTR_ALL,
	DCB_CAP_ATTR_PG,
	DCB_CAP_ATTR_PFC,
	DCB_CAP_ATTR_UP2TC,
	DCB_CAP_ATTR_PG_TCS,
	DCB_CAP_ATTR_PFC_TCS,
	DCB_CAP_ATTR_GSP,
	DCB_CAP_ATTR_BCN,
	DCB_CAP_ATTR_DCBX,

	__DCB_CAP_ATTR_ENUM_MAX,
	DCB_CAP_ATTR_MAX = __DCB_CAP_ATTR_ENUM_MAX - 1,
};

/**
 * DCBX capability flags
 *
 * @DCB_CAP_DCBX_HOST: DCBX negotiation is performed by the host LLDP agent.
 *                     'set' routines are used to configure the device with
 *                     the negotiated parameters
 *
 * @DCB_CAP_DCBX_LLD_MANAGED: DCBX negotiation is not performed in the host but
 *                            by another entity
 *                            'get' routines are used to retrieve the
 *                            negotiated parameters
 *                            'set' routines can be used to set the initial
 *                            negotiation configuration
 *
 * @DCB_CAP_DCBX_VER_CEE: for a non-host DCBX engine, indicates the engine
 *                        supports the CEE protocol flavor
 *
 * @DCB_CAP_DCBX_VER_IEEE: for a non-host DCBX engine, indicates the engine
 *                         supports the IEEE protocol flavor
 *
 * @DCB_CAP_DCBX_STATIC: for a non-host DCBX engine, indicates the engine
 *                       supports static configuration (i.e no actual
 *                       negotiation is performed negotiated parameters equal
 *                       the initial configuration)
 *
 */
#define DCB_CAP_DCBX_HOST		0x01
#define DCB_CAP_DCBX_LLD_MANAGED	0x02
#define DCB_CAP_DCBX_VER_CEE		0x04
#define DCB_CAP_DCBX_VER_IEEE		0x08
#define DCB_CAP_DCBX_STATIC		0x10

/**
 * enum dcbnl_numtcs_attrs - number of traffic classes
 *
 * @DCB_NUMTCS_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_NUMTCS_ATTR_ALL: (NLA_FLAG) all traffic class attributes
 * @DCB_NUMTCS_ATTR_PG: (NLA_U8) number of traffic classes used for
 *                               priority groups
 * @DCB_NUMTCS_ATTR_PFC: (NLA_U8) number of traffic classes which can
 *                                support priority flow control
 */
enum dcbnl_numtcs_attrs {
	DCB_NUMTCS_ATTR_UNDEFINED,
	DCB_NUMTCS_ATTR_ALL,
	DCB_NUMTCS_ATTR_PG,
	DCB_NUMTCS_ATTR_PFC,

	__DCB_NUMTCS_ATTR_ENUM_MAX,
	DCB_NUMTCS_ATTR_MAX = __DCB_NUMTCS_ATTR_ENUM_MAX - 1,
};

enum dcbnl_bcn_attrs{
	DCB_BCN_ATTR_UNDEFINED = 0,

	DCB_BCN_ATTR_RP_0,
	DCB_BCN_ATTR_RP_1,
	DCB_BCN_ATTR_RP_2,
	DCB_BCN_ATTR_RP_3,
	DCB_BCN_ATTR_RP_4,
	DCB_BCN_ATTR_RP_5,
	DCB_BCN_ATTR_RP_6,
	DCB_BCN_ATTR_RP_7,
	DCB_BCN_ATTR_RP_ALL,

	DCB_BCN_ATTR_BCNA_0,
	DCB_BCN_ATTR_BCNA_1,
	DCB_BCN_ATTR_ALPHA,
	DCB_BCN_ATTR_BETA,
	DCB_BCN_ATTR_GD,
	DCB_BCN_ATTR_GI,
	DCB_BCN_ATTR_TMAX,
	DCB_BCN_ATTR_TD,
	DCB_BCN_ATTR_RMIN,
	DCB_BCN_ATTR_W,
	DCB_BCN_ATTR_RD,
	DCB_BCN_ATTR_RU,
	DCB_BCN_ATTR_WRTT,
	DCB_BCN_ATTR_RI,
	DCB_BCN_ATTR_C,
	DCB_BCN_ATTR_ALL,

	__DCB_BCN_ATTR_ENUM_MAX,
	DCB_BCN_ATTR_MAX = __DCB_BCN_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcb_general_attr_values - general DCB attribute values
 *
 * @DCB_ATTR_UNDEFINED: value used to indicate an attribute is not supported
 *
 */
enum dcb_general_attr_values {
	DCB_ATTR_VALUE_UNDEFINED = 0xff
};

#define DCB_APP_IDTYPE_ETHTYPE	0x00
#define DCB_APP_IDTYPE_PORTNUM	0x01
enum dcbnl_app_attrs {
	DCB_APP_ATTR_UNDEFINED,

	DCB_APP_ATTR_IDTYPE,
	DCB_APP_ATTR_ID,
	DCB_APP_ATTR_PRIORITY,

	__DCB_APP_ATTR_ENUM_MAX,
	DCB_APP_ATTR_MAX = __DCB_APP_ATTR_ENUM_MAX - 1,
};

/**
 * enum dcbnl_featcfg_attrs - features conifiguration flags
 *
 * @DCB_FEATCFG_ATTR_UNDEFINED: unspecified attribute to catch errors
 * @DCB_FEATCFG_ATTR_ALL: (NLA_FLAG) all features configuration attributes
 * @DCB_FEATCFG_ATTR_PG: (NLA_U8) configuration flags for priority groups
 * @DCB_FEATCFG_ATTR_PFC: (NLA_U8) configuration flags for priority
 *                                 flow control
 * @DCB_FEATCFG_ATTR_APP: (NLA_U8) configuration flags for application TLV
 *
 */
#define DCB_FEATCFG_ERROR	0x01	/* error in feature resolution */
#define DCB_FEATCFG_ENABLE	0x02	/* enable feature */
#define DCB_FEATCFG_WILLING	0x04	/* feature is willing */
#define DCB_FEATCFG_ADVERTISE	0x08	/* advertise feature */
enum dcbnl_featcfg_attrs {
	DCB_FEATCFG_ATTR_UNDEFINED,
	DCB_FEATCFG_ATTR_ALL,
	DCB_FEATCFG_ATTR_PG,
	DCB_FEATCFG_ATTR_PFC,
	DCB_FEATCFG_ATTR_APP,

	__DCB_FEATCFG_ATTR_ENUM_MAX,
	DCB_FEATCFG_ATTR_MAX = __DCB_FEATCFG_ATTR_ENUM_MAX - 1,
};

#endif /* __LINUX_DCBNL_H__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    /* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _LINUX_DCCP_H
#define _LINUX_DCCP_H

#include <linux/types.h>
#include <asm/byteorder.h>

/**
 * struct dccp_hdr - generic part of DCCP packet header
 *
 * @dccph_sport - Relevant port on the endpoint that sent this packet
 * @dccph_dport - Relevant port on the other endpoint
 * @dccph_doff - Data Offset from the start of the DCCP header, in 32-bit words
 * @dccph_ccval - Used by the HC-Sender CCID
 * @dccph_cscov - Parts of the packet that are covered by the Checksum field
 * @dccph_checksum - Internet checksum, depends on dccph_cscov
 * @dccph_x - 0 = 24 bit sequence number, 1 = 48
 * @dccph_type - packet type, see DCCP_PKT_ prefixed macros
 * @dccph_seq - sequence number high or low order 24 bits, depends on dccph_x
 */
struct dccp_hdr {
	__be16	dccph_sport,
		dccph_dport;
	__u8	dccph_doff;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	dccph_cscov:4,
		dccph_ccval:4;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u8	dccph_ccval:4,
		dccph_cscov:4;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif
	__sum16	dccph_checksum;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	dccph_x:1,
		dccph_type:4,
		dccph_reserved:3;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u8	dccph_reserved:3,
		dccph_type:4,
		dccph_x:1;
#else
#error  "Adjust your <asm/byteorder.h> defines"
#endif
	__u8	dccph_seq2;
	__be16	dccph_seq;
};

/**
 * struct dccp_hdr_ext - the low bits of a 48 bit seq packet
 *
 * @dccph_seq_low - low 24 bits of a 48 bit seq packet
 */
struct dccp_hdr_ext {
	__be32	dccph_seq_low;
};

/**
 * struct dccp_hdr_request - Connection initiation request header
 *
 * @dccph_req_service - Service to which the client app wants to connect
 */
struct dccp_hdr_request {
	__be32	dccph_req_service;
};
/**
 * struct dccp_hdr_ack_bits - acknowledgment bits common to most packets
 *
 * @dccph_resp_ack_nr_high - 48 bit ack number high order bits, contains GSR
 * @dccph_resp_ack_nr_low - 48 bit ack number low order bits, contains GSR
 */
struct dccp_hdr_ack_bits {
	__be16	dccph_reserved1;
	__be16	dccph_ack_nr_high;
	__be32	dccph_ack_nr_low;
};
/**
 * struct dccp_hdr_response - Connection initiation response header
 *
 * @dccph_resp_ack - 48 bit Acknowledgment Number Subheader (5.3)
 * @dccph_resp_service - Echoes the Service Code on a received DCCP-Request
 */
struct dccp_hdr_response {
	struct dccp_hdr_ack_bits	dccph_resp_ack;
	__be32				dccph_resp_service;
};

/**
 * struct dccp_hdr_reset - Unconditionally shut down a connection
 *
 * @dccph_reset_ack - 48 bit Acknowledgment Number Subheader (5.6)
 * @dccph_reset_code - one of %dccp_reset_codes
 * @dccph_reset_data - the Data 1 ... Data 3 fields from 5.6
 */
struct dccp_hdr_reset {
	struct dccp_hdr_ack_bits	dccph_reset_ack;
	__u8				dccph_reset_code,
					dccph_reset_data[3];
};

enum dccp_pkt_type {
	DCCP_PKT_REQUEST = 0,
	DCCP_PKT_RESPONSE,
	DCCP_PKT_DATA,
	DCCP_PKT_ACK,
	DCCP_PKT_DATAACK,
	DCCP_PKT_CLOSEREQ,
	DCCP_PKT_CLOSE,
	DCCP_PKT_RESET,
	DCCP_PKT_SYNC,
	DCCP_PKT_SYNCACK,
	DCCP_PKT_INVALID,
};

#define DCCP_NR_PKT_TYPES DCCP_PKT_INVALID

static __inline__ unsigned int dccp_packet_hdr_len(const __u8 type)
{
	if (type == DCCP_PKT_DATA)
		return 0;
	if (type == DCCP_PKT_DATAACK	||
	    type == DCCP_PKT_ACK	||
	    type == DCCP_PKT_SYNC	||
	    type == DCCP_PKT_SYNCACK	||
	    type == DCCP_PKT_CLOSE	||
	    type == DCCP_PKT_CLOSEREQ)
		return sizeof(struct dccp_hdr_ack_bits);
	if (type == DCCP_PKT_REQUEST)
		return sizeof(struct dccp_hdr_request);
	if (type == DCCP_PKT_RESPONSE)
		return sizeof(struct dccp_hdr_response);
	return sizeof(struct dccp_hdr_reset);
}
enum dccp_reset_codes {
	DCCP_RESET_CODE_UNSPECIFIED = 0,
	DCCP_RESET_CODE_CLOSED,
	DCCP_RESET_CODE_ABORTED,
	DCCP_RESET_CODE_NO_CONNECTION,
	DCCP_RESET_CODE_PACKET_ERROR,
	DCCP_RESET_CODE_OPTION_ERROR,
	DCCP_RESET_CODE_MANDATORY_ERROR,
	DCCP_RESET_CODE_CONNECTION_REFUSED,
	DCCP_RESET_CODE_BAD_SERVICE_CODE,
	DCCP_RESET_CODE_TOO_BUSY,
	DCCP_RESET_CODE_BAD_INIT_COOKIE,
	DCCP_RESET_CODE_AGGRESSION_PENALTY,

	DCCP_MAX_RESET_CODES		/* Leave at the end!  */
};

/* DCCP options */
enum {
	DCCPO_PADDING = 0,
	DCCPO_MANDATORY = 1,
	DCCPO_MIN_RESERVED = 3,
	DCCPO_MAX_RESERVED = 31,
	DCCPO_CHANGE_L = 32,
	DCCPO_CONFIRM_L = 33,
	DCCPO_CHANGE_R = 34,
	DCCPO_CONFIRM_R = 35,
	DCCPO_NDP_COUNT = 37,
	DCCPO_ACK_VECTOR_0 = 38,
	DCCPO_ACK_VECTOR_1 = 39,
	DCCPO_TIMESTAMP = 41,
	DCCPO_TIMESTAMP_ECHO = 42,
	DCCPO_ELAPSED_TIME = 43,
	DCCPO_MAX = 45,
	DCCPO_MIN_RX_CCID_SPECIFIC = 128,	/* from sender to receiver */
	DCCPO_MAX_RX_CCID_SPECIFIC = 191,
	DCCPO_MIN_TX_CCID_SPECIFIC = 192,	/* from receiver to sender */
	DCCPO_MAX_TX_CCID_SPECIFIC = 255,
};
/* maximum size of a single TLV-encoded DCCP option (sans type/len bytes) */
#define DCCP_SINGLE_OPT_MAXLEN	253

/* DCCP CCIDS */
enum {
	DCCPC_CCID2 = 2,
	DCCPC_CCID3 = 3,
};

/* DCCP features (RFC 4340 section 6.4) */
enum dccp_feature_numbers {
	DCCPF_RESERVED = 0,
	DCCPF_CCID = 1,
	DCCPF_SHORT_SEQNOS = 2,
	DCCPF_SEQUENCE_WINDOW = 3,
	DCCPF_ECN_INCAPABLE = 4,
	DCCPF_ACK_RATIO = 5,
	DCCPF_SEND_ACK_VECTOR = 6,
	DCCPF_SEND_NDP_COUNT = 7,
	DCCPF_MIN_CSUM_COVER = 8,
	DCCPF_DATA_CHECKSUM = 9,
	/* 10-127 reserved */
	DCCPF_MIN_CCID_SPECIFIC = 128,
	DCCPF_SEND_LEV_RATE = 192,	/* RFC 4342, sec. 8.4 */
	DCCPF_MAX_CCID_SPECIFIC = 255,
};

/* DCCP socket control message types for cmsg */
enum dccp_cmsg_type {
	DCCP_SCM_PRIORITY = 1,
	DCCP_SCM_QPOLICY_MAX = 0xFFFF,
	/* ^-- Up to here reserved exclusively for qpolicy parameters */
	DCCP_SCM_MAX
};

/* DCCP priorities for outgoing/queued packets */
enum dccp_packet_dequeueing_policy {
	DCCPQ_POLICY_SIMPLE,
	DCCPQ_POLICY_PRIO,
	DCCPQ_POLICY_MAX
};

/* DCCP socket options */
#define DCCP_SOCKOPT_PACKET_SIZE	1 /* XXX deprecated, without effect */
#define DCCP_SOCKOPT_SERVICE		2
#define DCCP_SOCKOPT_CHANGE_L		3
#define DCCP_SOCKOPT_CHANGE_R		4
#define DCCP_SOCKOPT_GET_CUR_MPS	5
#define DCCP_SOCKOPT_SERVER_TIMEWAIT	6
#define DCCP_SOCKOPT_SEND_CSCOV		10
#define DCCP_SOCKOPT_RECV_CSCOV		11
#define DCCP_SOCKOPT_AVAILABLE_CCIDS	12
#define DCCP_SOCKOPT_CCID		13
#define DCCP_SOCKOPT_TX_CCID		14
#define DCCP_SOCKOPT_RX_CCID		15
#define DCCP_SOCKOPT_QPOLICY_ID		16
#define DCCP_SOCKOPT_QPOLICY_TXQLEN	17
#define DCCP_SOCKOPT_CCID_RX_INFO	128
#define DCCP_SOCKOPT_CCID_TX_INFO	192

/* maximum number of services provided on the same listening port */
#define DCCP_SERVICE_LIST_MAX_LEN      32


#endif /* _LINUX_DCCP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* SPDX-License-Identifier: GPL-2.0+ WITH Linux-syscall-note */
/*
 * include/uapi/linux/devlink.h - Network physical device Netlink interface
 * Copyright (c) 2016 Mellanox Technologies. All rights reserved.
 * Copyright (c) 2016 Jiri Pirko <jiri@mellanox.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#ifndef _LINUX_DEVLINK_H_
#define _LINUX_DEVLINK_H_

#define DEVLINK_GENL_NAME "devlink"
#define DEVLINK_GENL_VERSION 0x1
#define DEVLINK_GENL_MCGRP_CONFIG_NAME "config"

enum devlink_command {
	/* don't change the order or add anything between, this is ABI! */
	DEVLINK_CMD_UNSPEC,

	DEVLINK_CMD_GET,		/* can dump */
	DEVLINK_CMD_SET,
	DEVLINK_CMD_NEW,
	DEVLINK_CMD_DEL,

	DEVLINK_CMD_PORT_GET,		/* can dump */
	DEVLINK_CMD_PORT_SET,
	DEVLINK_CMD_PORT_NEW,
	DEVLINK_CMD_PORT_DEL,

	DEVLINK_CMD_PORT_SPLIT,
	DEVLINK_CMD_PORT_UNSPLIT,

	DEVLINK_CMD_SB_GET,		/* can dump */
	DEVLINK_CMD_SB_SET,
	DEVLINK_CMD_SB_NEW,
	DEVLINK_CMD_SB_DEL,

	DEVLINK_CMD_SB_POOL_GET,	/* can dump */
	DEVLINK_CMD_SB_POOL_SET,
	DEVLINK_CMD_SB_POOL_NEW,
	DEVLINK_CMD_SB_POOL_DEL,

	DEVLINK_CMD_SB_PORT_POOL_GET,	/* can dump */
	DEVLINK_CMD_SB_PORT_POOL_SET,
	DEVLINK_CMD_SB_PORT_POOL_NEW,
	DEVLINK_CMD_SB_PORT_POOL_DEL,

	DEVLINK_CMD_SB_TC_POOL_BIND_GET,	/* can dump */
	DEVLINK_CMD_SB_TC_POOL_BIND_SET,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL,

	/* Shared buffer occupancy monitoring commands */
	DEVLINK_CMD_SB_OCC_SNAPSHOT,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR,

	DEVLINK_CMD_ESWITCH_GET,
#define DEVLINK_CMD_ESWITCH_MODE_GET /* obsolete, never use this! */ \
	DEVLINK_CMD_ESWITCH_GET

	DEVLINK_CMD_ESWITCH_SET,
#define DEVLINK_CMD_ESWITCH_MODE_SET /* obsolete, never use this! */ \
	DEVLINK_CMD_ESWITCH_SET

	DEVLINK_CMD_DPIPE_TABLE_GET,
	DEVLINK_CMD_DPIPE_ENTRIES_GET,
	DEVLINK_CMD_DPIPE_HEADERS_GET,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET,
	DEVLINK_CMD_RESOURCE_SET,
	DEVLINK_CMD_RESOURCE_DUMP,

	/* Hot driver reload, makes configuration changes take place. The
	 * devlink instance is not released during the process.
	 */
	DEVLINK_CMD_RELOAD,

	DEVLINK_CMD_PARAM_GET,		/* can dump */
	DEVLINK_CMD_PARAM_SET,
	DEVLINK_CMD_PARAM_NEW,
	DEVLINK_CMD_PARAM_DEL,

	DEVLINK_CMD_REGION_GET,
	DEVLINK_CMD_REGION_SET,
	DEVLINK_CMD_REGION_NEW,
	DEVLINK_CMD_REGION_DEL,
	DEVLINK_CMD_REGION_READ,

	DEVLINK_CMD_PORT_PARAM_GET,	/* can dump */
	DEVLINK_CMD_PORT_PARAM_SET,
	DEVLINK_CMD_PORT_PARAM_NEW,
	DEVLINK_CMD_PORT_PARAM_DEL,

	DEVLINK_CMD_INFO_GET,		/* can dump */

	DEVLINK_CMD_HEALTH_REPORTER_GET,
	DEVLINK_CMD_HEALTH_REPORTER_SET,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR,

	DEVLINK_CMD_FLASH_UPDATE,
	DEVLINK_CMD_FLASH_UPDATE_END,		/* notification only */
	DEVLINK_CMD_FLASH_UPDATE_STATUS,	/* notification only */

	DEVLINK_CMD_TRAP_GET,		/* can dump */
	DEVLINK_CMD_TRAP_SET,
	DEVLINK_CMD_TRAP_NEW,
	DEVLINK_CMD_TRAP_DEL,

	DEVLINK_CMD_TRAP_GROUP_GET,	/* can dump */
	DEVLINK_CMD_TRAP_GROUP_SET,
	DEVLINK_CMD_TRAP_GROUP_NEW,
	DEVLINK_CMD_TRAP_GROUP_DEL,

	DEVLINK_CMD_TRAP_POLICER_GET,	/* can dump */
	DEVLINK_CMD_TRAP_POLICER_SET,
	DEVLINK_CMD_TRAP_POLICER_NEW,
	DEVLINK_CMD_TRAP_POLICER_DEL,

	/* add new commands above here */
	__DEVLINK_CMD_MAX,
	DEVLINK_CMD_MAX = __DEVLINK_CMD_MAX - 1
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET,
	DEVLINK_PORT_TYPE_AUTO,
	DEVLINK_PORT_TYPE_ETH,
	DEVLINK_PORT_TYPE_IB,
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS,
	DEVLINK_SB_POOL_TYPE_EGRESS,
};

/* static threshold - limiting the maximum number of bytes.
 * dynamic threshold - limiting the maximum number of bytes
 *   based on the currently available free space in the shared buffer pool.
 *   In this mode, the maximum quota is calculated based
 *   on the following formula:
 *     max_quota = alpha / (1 + alpha) * Free_Buffer
 *   While Free_Buffer is the amount of none-occupied buffer associated to
 *   the relevant pool.
 *   The value range which can be passed is 0-20 and serves
 *   for computation of alpha by following formula:
 *     alpha = 2 ^ (passed_value - 10)
 */

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC,
};

#define DEVLINK_SB_THRESHOLD_TO_ALPHA_MAX 20

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY,
	DEVLINK_ESWITCH_MODE_SWITCHDEV,
};

enum devlink_eswitch_inline_mode {
	DEVLINK_ESWITCH_INLINE_MODE_NONE,
	DEVLINK_ESWITCH_INLINE_MODE_LINK,
	DEVLINK_ESWITCH_INLINE_MODE_NETWORK,
	DEVLINK_ESWITCH_INLINE_MODE_TRANSPORT,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL, /* Any kind of a port physically
					* facing the user.
					*/
	DEVLINK_PORT_FLAVOUR_CPU, /* CPU port */
	DEVLINK_PORT_FLAVOUR_DSA, /* Distributed switch architecture
				   * interconnect port.
				   */
	DEVLINK_PORT_FLAVOUR_PCI_PF, /* Represents eswitch port for
				      * the PCI PF. It is an internal
				      * port that faces the PCI PF.
				      */
	DEVLINK_PORT_FLAVOUR_PCI_VF, /* Represents eswitch port
				      * for the PCI VF. It is an internal
				      * port that faces the PCI VF.
				      */
	DEVLINK_PORT_FLAVOUR_VIRTUAL, /* Any virtual port facing the user. */
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME,
	DEVLINK_PARAM_CMODE_DRIVERINIT,
	DEVLINK_PARAM_CMODE_PERMANENT,

	/* Add new configuration modes above */
	__DEVLINK_PARAM_CMODE_MAX,
	DEVLINK_PARAM_CMODE_MAX = __DEVLINK_PARAM_CMODE_MAX - 1
};

enum devlink_param_fw_load_policy_value {
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DRIVER,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_FLASH,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_DISK,
	DEVLINK_PARAM_FW_LOAD_POLICY_VALUE_UNKNOWN,
};

enum devlink_param_reset_dev_on_drv_probe_value {
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_UNKNOWN,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_ALWAYS,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_NEVER,
	DEVLINK_PARAM_RESET_DEV_ON_DRV_PROBE_VALUE_DISK,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS,		/* u64 */
	DEVLINK_ATTR_STATS_RX_BYTES,		/* u64 */
	DEVLINK_ATTR_STATS_RX_DROPPED,		/* u64 */

	__DEVLINK_ATTR_STATS_MAX,
	DEVLINK_ATTR_STATS_MAX = __DEVLINK_ATTR_STATS_MAX - 1
};

/**
 * enum devlink_trap_action - Packet trap action.
 * @DEVLINK_TRAP_ACTION_DROP: Packet is dropped by the device and a copy is not
 *                            sent to the CPU.
 * @DEVLINK_TRAP_ACTION_TRAP: The sole copy of the packet is sent to the CPU.
 * @DEVLINK_TRAP_ACTION_MIRROR: Packet is forwarded by the device and a copy is
 *                              sent to the CPU.
 */
enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP,
	DEVLINK_TRAP_ACTION_TRAP,
	DEVLINK_TRAP_ACTION_MIRROR,
};

/**
 * enum devlink_trap_type - Packet trap type.
 * @DEVLINK_TRAP_TYPE_DROP: Trap reason is a drop. Trapped packets are only
 *                          processed by devlink and not injected to the
 *                          kernel's Rx path.
 * @DEVLINK_TRAP_TYPE_EXCEPTION: Trap reason is an exception. Packet was not
 *                               forwarded as intended due to an exception
 *                               (e.g., missing neighbour entry) and trapped to
 *                               control plane for resolution. Trapped packets
 *                               are processed by devlink and injected to
 *                               the kernel's Rx path.
 * @DEVLINK_TRAP_TYPE_CONTROL: Packet was trapped because it is required for
 *                             the correct functioning of the control plane.
 *                             For example, an ARP request packet. Trapped
 *                             packets are injected to the kernel's Rx path,
 *                             but not reported to drop monitor.
 */
enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP,
	DEVLINK_TRAP_TYPE_EXCEPTION,
	DEVLINK_TRAP_TYPE_CONTROL,
};

enum {
	/* Trap can 